.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-22
*****************************************************
modname : VAK111
changed : 2000-11-22
module  : Drop_Table
 
Author  : ThomasA
Created : 1994-11-02
*****************************************************
 
Purpose :
 
Define  :
 
        PROCEDURE
              a111drop_table (
                    VAR acv       : tak_all_command_glob;
                    VAR tabid     : tgg00_Surrogate;
                    tab_kind      : tgg00_TableKind;
                    succ_vers     : boolean;
                    do_cascade    : boolean;
                    no_references : boolean);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
&       IFDEF TRACE
        FROM
              Test_Procedures  : VTA01;
 
        PROCEDURE
              t01surrogate (
                    layer     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey       : tgg00_SysInfoKey;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv      : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv       : tak_all_command_glob;
                    dstate        : tak_directory_state;
                    VAR tableid   : tgg00_Surrogate;
                    VAR base_ptr  : tak_sysbufferaddress;
                    get_all       : boolean;
                    VAR ok        : boolean);
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR mbuf    : tgg00_MessBlock;
                    result_req  : boolean;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10_add_repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    add_sysinfo  : boolean;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_version (
                    VAR acv        : tak_all_command_glob;
                    VAR base_rec   : tak_baserecord;
                    m_type         : tgg00_MessType;
                    view_scan      : boolean);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10_del_tab_sysinfo  (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate;
                    VAR qual    : tak_del_tab_qual;
                    temp_table  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        PROCEDURE
              a101_InvalidateListAppend (
                    VAR acv       : tak_all_command_glob;
                    VAR SchemaId  : tgg00_Surrogate;
                    VAR Tablename : tsp00_KnlIdentifier);
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11del_usage_entry (
                    VAR acv       : tak_all_command_glob;
                    VAR usa_tabid : tgg00_Surrogate;
                    VAR del_tabid : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              AK_Domain : VAK12;
 
        PROCEDURE
              a12read_domain_ref (
                    VAR acv         : tak_all_command_glob;
                    VAR owner_id    : tgg00_Surrogate;
                    VAR domain_name : tsp00_KnlIdentifier;
                    VAR domain_ref  : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_usertab_tools : VAK19;
 
        PROCEDURE
              a19all_del_usertab  (
                    VAR acv : tak_all_command_glob;
                    buf : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24get_indexname (
                    VAR acv        : tak_all_command_glob;
                    indexbuf       : tak_sysbufferaddress;
                    index          : integer;
                    VAR index_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a24init_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24finish_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record);
 
        FUNCTION
              a24next_named_index (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Link : VAK25;
 
        PROCEDURE
              a25drop_link (
                    VAR acv         : tak_all_command_glob;
                    VAR a25v        : tak_a25_glob;
                    tabno           : integer;
                    VAR viewscanpar : tak_save_viewscan_par);
 
      ------------------------------ 
 
        FROM
              AK_Comment : VAK26;
 
        PROCEDURE
              a26drop_comment (
                    VAR acv      : tak_all_command_glob;
                    comment_type : tak_comment_type;
                    VAR id1      : tgg00_Surrogate;
                    VAR id2      : tgg00_Surrogate;
                    colno        : integer);
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262drop_tab_col_trigger (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_save_viewscan_par;
                    VAR new_stack   : tgg00_StackEntry);
 
        PROCEDURE
              a262DropInternalTriggers (
                    VAR acv  : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_VIEW_SCAN : VAK27;
 
        PROCEDURE
              a27init_viewscanpar (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_save_viewscan_par;
                    v_type          : tak_viewscantype);
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        VAR
              a28updstatwanted_tree : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              Catalog_Migration_2 : VAK362;
 
        VAR
              a362OnlineTaskId : tsp00_TaskId;
 
      ------------------------------ 
 
        FROM
              AK_data_dictionary : VAK38;
 
        PROCEDURE
              a38index_drop (
                    VAR acv        : tak_all_command_glob;
                    VAR username   : tsp00_KnlIdentifier;
                    VAR tablename  : tsp00_KnlIdentifier;
                    VAR columnname : tsp00_KnlIdentifier;
                    VAR indexname  : tsp00_KnlIdentifier);
 
        PROCEDURE
              a38table_drop (
                    VAR acv     : tak_all_command_glob;
                    VAR baserec : tak_baserecord);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a262drop_tab_col_trigger;
 
              tak_viewscan_par tak_save_viewscan_par
 
        PROCEDURE
              a27init_viewscanpar;
 
              tak_viewscan_par tak_save_viewscan_par
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      cak111primary_table        =      1;
      cak111secondary_table      =      2;
 
TYPE
 
      drop_table_record = RECORD
            dt_succ_filevers : boolean;
            dt_temp_table    : boolean;
            dt_cascade       : boolean;
            dt_no_references : boolean;
            dt_usabuf        : tak_sysbufferaddress;
            dt_usakey        : tgg00_SysInfoKey;
      END;
 
 
 
(*------------------------------*) 
 
PROCEDURE
      ak111DestroyFiles (
            VAR acv         : tak_all_command_glob;
            base_ptr        : tak_sysbufferaddress);
 
VAR
      b_err       : tgg00_BasisError;
      newlong_cnt : tsp00_Int2;
      oldlong_cnt : tsp00_Int2;
 
BEGIN
WITH acv DO
    BEGIN
    a06a_mblock_init (acv,
          m_drop, mm_table, base_ptr^.sbase.btreeid);
    ak111ni_describe_named_indexes   (acv, base_ptr^.sbase);
    (* PTS 1115206 M.Ki. *)
    ak111cnt_long_cols (acv, base_ptr^.sbase, newlong_cnt, oldlong_cnt);
    a_mblock.mb_qual^.mlink_cnt   := newlong_cnt;
    a_mblock.mb_qual^.mstring_cnt := newlong_cnt + oldlong_cnt;
    a_mblock.mb_qual^.mstring_pos := cgg_nil_varcol_cnt_off;
    IF  a_returncode = 0
    THEN
        (* send mess buffer to destroy table and indexes *)
        BEGIN
&       ifdef trace
        t01int4 (ak_sem, 'a_is_ddl    ', ord (a_is_ddl));
&       endif
        IF  base_ptr^.sbase.btreeid.fileTabId_gg00
            = a28updstatwanted_tree.fileTabId_gg00
        THEN
            a28updstatwanted_tree := b01niltree_id;
        (*ENDIF*) 
        a06rsend_mess_buf (acv, a_mblock, NOT cak_return_req, b_err);
        IF  (b_err <> e_ok)
        THEN
&           ifdef trace
            IF  (a362OnlineTaskId = UNDEF_SP00) OR
                (ftsPerm_egg00 in base_ptr^.sbase.btreeid.fileType_gg00)
            THEN
                a07_b_put_error (acv, b_err, 1);
&           else
            (*ENDIF*) 
        (*ENDIF*) 
        IF  b_err <> e_file_not_found
        THEN
            a07_b_put_error (acv, b_err, 1);
&       endif
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a111drop_table (
            VAR acv       : tak_all_command_glob;
            VAR tabid     : tgg00_Surrogate;
            tab_kind      : tgg00_TableKind;
            succ_vers     : boolean;
            do_cascade    : boolean;
            no_references : boolean);
 
VAR
      site         : tgg00_ServerdbNo;
      drop_tab_rec : drop_table_record;
 
BEGIN
site[1] := tabid[1];
site[2] := tabid[2];
drop_tab_rec.dt_temp_table    := site = cak_temp_table_site;
drop_tab_rec.dt_succ_filevers := succ_vers AND NOT no_references;
drop_tab_rec.dt_cascade       := do_cascade;
drop_tab_rec.dt_no_references := no_references;
ak111drop_table (acv, tabid, tab_kind, tabid, tab_kind, true, drop_tab_rec);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111del_domain_references (
            VAR acv  : tak_all_command_glob;
            base_ptr : tak_sysbufferaddress);
 
CONST
      c_found = csp_maxint2;
 
VAR
      b_err         : tgg00_BasisError;
      jx            : integer;
      kx            : integer;
      domain_cnt    : integer;
      b             : tak_sysbufferaddress;
      dom_ref       : tak_sysbufferaddress;
      dom_id        : tgg00_Surrogate;
      domain_owners : ARRAY[1..MAX_COL_PER_TAB_GG00] OF tgg00_Surrogate;
      domain_names  : ARRAY[1..MAX_COL_PER_TAB_GG00] OF tsp00_KnlIdentifier;
      sysk          : tgg00_SysInfoKey;
 
BEGIN
IF  NOT a101_IsExtendedTempFile (acv, base_ptr^.sbase.btreeid)
THEN
    BEGIN
    domain_cnt     := 0;
    sysk           := base_ptr^.syskey;
    sysk.sentrytyp := cak_edomainusage;
    WITH base_ptr^.sbase DO
        FOR jx := bfirstindex TO blastindex DO
            WITH bcolumn[jx]^ DO
                IF  ctdomain in ccolpropset
                THEN
                    BEGIN
                    sysk.slinkage[1] := chr (cextcolno DIV 256);
                    sysk.slinkage[2] := chr (cextcolno MOD 256);
                    a10get_sysinfo (acv, sysk, d_release,
                          b, b_err);
                    IF  b_err = e_ok
                    THEN
                        BEGIN
                        kx := 1;
                        WHILE kx <= domain_cnt DO
                            IF  (domain_owners[kx] =
                                b^.scol_uses_dom.cud_owner) AND
                                (domain_names[kx] =
                                b^.scol_uses_dom.cud_name)
                            THEN
                                kx := c_found
                            ELSE
                                kx := kx + 1;
                            (*ENDIF*) 
                        (*ENDWHILE*) 
                        IF  kx <> c_found
                        THEN
                            BEGIN
                            domain_cnt       := kx;
                            domain_owners[kx] :=
                                  b^.scol_uses_dom.cud_owner;
                            domain_names[kx] :=
                                  b^.scol_uses_dom.cud_name;
                            a12read_domain_ref (acv,
                                  domain_owners[kx],
                                  domain_names[kx], dom_ref);
                            IF  dom_ref <> NIL
                            THEN
                                BEGIN
                                dom_id :=
                                      dom_ref^.sdomainref.dsurrogate;
                                a11del_usage_entry (acv, dom_id,
                                      sysk.stableid)
                                END
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDFOR*) 
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111del_synonymdef (
            VAR acv        : tak_all_command_glob;
            VAR synid      : tgg00_Surrogate;
            first_drop_tab : boolean);
 
VAR
      b_err      : tgg00_BasisError;
      synbuf     : tak_sysbufferaddress;
      synkey     : tgg00_SysInfoKey;
      synrefkey  : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        synkey         := a01defaultkey;
        synkey.sauthid := synid;
        a10get_sysinfo (acv,
              synkey, d_fix, synbuf, b_err);
        IF  b_err = e_ok
        THEN
            WITH synbuf^.ssynonym DO
                BEGIN
                synrefkey.sauthid     := syn_authid;
                synrefkey.sidentifier := syn_tablen;
                synrefkey.sentrytyp   := cak_etableref;
                synrefkey.slinkage    := cak_init_linkage;
                synrefkey.skeylen     :=
                      mxak_standard_sysk + sizeof (synrefkey.sidentifier);
                a10del_sysinfo (acv, synrefkey, b_err);
                IF  b_err = e_ok
                THEN
                    BEGIN
                    IF  first_drop_tab
                    THEN
                        IF  syn_tablekind = tsynonym
                        THEN
                            BEGIN
                            IF  syncomment
                            THEN
                                a26drop_comment (acv,
                                      cm_synonym, synid, synid, 1);
                            (*ENDIF*) 
                            IF  syn_tableid <> cgg_zero_id
                            THEN
                                BEGIN
                                IF  a_init_ddl <> ddl_drop_sequence
                                THEN
                                    a11del_usage_entry (acv, syn_tableid,
                                          synid)
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                            END
                        ELSE
                            a07_nb_put_error (acv,
                                  e_unknown_synonymname,
                                  1, syn_tablen);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    a38table_drop (acv, synbuf^.sbase);
                    a10del_sysinfo (acv, synkey, b_err)
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111del_usage_rec (
            VAR acv       : tak_all_command_glob;
            VAR usage_buf : tak_sysbufferaddress;
            VAR b_err     : tgg00_BasisError);
 
BEGIN
a10del_sysinfo (acv, usage_buf^.syskey, b_err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111del_view_from_usage (
            VAR acv          : tak_all_command_glob;
            VAR from_tableid : tgg00_Surrogate;
            VAR view_tableid : tgg00_Surrogate;
            use_all_tabs     : boolean);
 
VAR
      b_err  : tgg00_BasisError;
      i      : integer;
      vtextb : tak_sysbufferaddress;
      vtextk : tgg00_SysInfoKey;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    vtextk := a01defaultkey;
    WITH vtextk DO
        BEGIN
        stableid  := view_tableid;
        sentrytyp := cak_eviewtext;
        END;
    (*ENDWITH*) 
    a10get_sysinfo (acv, vtextk, d_fix,
          vtextb, b_err);
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    ELSE
        WITH vtextb^.sviewtext DO
            BEGIN
            i := 1;
            WHILE (i <= vttabcount) AND
                  (acv.a_returncode=0) DO
                WITH vttab[ i ] DO
                    BEGIN
                    IF  (vtttableid <> from_tableid) OR use_all_tabs
                    THEN
                        BEGIN
                        a11del_usage_entry (acv, vtttableid, view_tableid);
                        IF  vttfromTableInfo = fti_synonym
                        THEN
                            a11del_usage_entry (acv, vttreftabid, view_tableid);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    i := i + 1;
                    END;
                (*ENDWITH*) 
            (*ENDWHILE*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    a10_rel_sysinfo (acv, vtextk);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111destroy_files (
            VAR acv         : tak_all_command_glob;
            VAR base_ptr    : tak_sysbufferaddress);
 
VAR
      is_primary_key_tab : boolean;
      is_foreign_key_tab : boolean;
      ok                 : boolean;
      tabid              : tgg00_Surrogate;
      dummy_st           : tgg00_StackEntry;
      a25v               : tak_a25_glob;
      viewscanpar        : tak_save_viewscan_par;
 
BEGIN
ak111del_domain_references (acv, base_ptr);
WITH acv, a_mblock   DO
    IF  a_returncode = 0
    THEN
        BEGIN
        tabid := base_ptr^.sbase.bsurrogate;
        a27init_viewscanpar(acv, viewscanpar, v_save_scheme);
        a_p_arr1.pbasep := base_ptr;
        a262DropInternalTriggers (acv);
        WITH base_ptr^.sbase DO
            IF  (del_trigger in blinkexist) OR
                (ins_trigger in blinkexist) OR
                (upd_trigger in blinkexist)
            THEN
                a262drop_tab_col_trigger (acv, viewscanpar, dummy_st);
            (*ENDIF*) 
        (*ENDWITH*) 
        WITH a25v DO
            BEGIN
            a103GetSchemaName (acv,
                  base_ptr^.sbase.bschema, a2authname[ 1 ]);
            a2tablen[ 1 ]               := base_ptr^.sbase.btablen^;
            a2syskey[ 1 ]               := base_ptr^.syskey;
            a2syskey[ 1 ].sentrytyp     := cak_eprimarykey;
            a2base_p [1] := base_ptr;
            END;
        (*ENDWITH*) 
        is_primary_key_tab :=
              is_primary_table in base_ptr^.sbase.blinkexist;
        is_foreign_key_tab :=
              is_secondary_table in base_ptr^.sbase.blinkexist;
        viewscanpar.vsc_first_save := true;
        viewscanpar.vsc_tree_id    := b01niltree_id;
        IF  is_primary_key_tab AND (a_returncode = 0)
        THEN
            BEGIN
            viewscanpar.vsc_last_save    := NOT(is_foreign_key_tab);
            a25drop_link (acv, a25v,
                  cak111secondary_table, viewscanpar);
            viewscanpar.vsc_first_save := false
            END;
        (*ENDIF*) 
        IF  is_foreign_key_tab AND (a_returncode = 0)
        THEN
            BEGIN
            viewscanpar.vsc_last_save    := true;
            a25v.a2syskey[ 1 ].sentrytyp := cak_eforeignkey;
            a25v.a2syskey[ 1 ].slinkage  := cak_init_linkage;
            a25drop_link (acv, a25v, cak111primary_table, viewscanpar)
            END;
        (*ENDIF*) 
        a06_systable_get (acv, d_release, tabid, base_ptr, true, ok);
        IF  ok
        THEN
            ak111DestroyFiles (acv, base_ptr)
        ELSE
            a07ak_system_error (acv, 111, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111drop_table (
            VAR acv          : tak_all_command_glob;
            tableid          : tgg00_Surrogate; (* must not be VAR *)
            tablkind         : tgg00_TableKind;
            VAR from_tableid : tgg00_Surrogate;
            from_tab_kind    : tgg00_TableKind;
            first_drop_tab   : boolean;
            VAR dt_rec       : drop_table_record);
 
VAR
      ok        : boolean;
      b_err     : tgg00_BasisError;
      udefcount : tsp00_Int2;
      i         : tsp00_Int2;
      linkage   : tsp00_C2;
 
BEGIN
IF  NOT dt_rec.dt_cascade
THEN (* no cascading drop allowed, return error *)
    IF  tableid <> from_tableid
    THEN
        BEGIN
        a06_systable_get (acv, d_release,
              tableid, acv.a_p_arr1.pbasep, true, ok);
        IF  ok
        THEN
            IF  acv.a_p_arr1.pbasep^.sbase.btablekind = tsynonym
            THEN
                a07_nb_put_error (acv, e_use_cascade,
                      1, acv.a_p_arr1.pbasep^.ssynonym.syn_tablen)
            ELSE
                a07_nb_put_error (acv, e_use_cascade,
                      1, acv.a_p_arr1.pbasep^.sbase.btablen^)
            (*ENDIF*) 
        ELSE
            a07_b_put_error (acv, e_use_cascade, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    b_err := e_ok;
    linkage   := cak_init_linkage;
    udefcount := 0;
    REPEAT
        (* PTS 1111576 E.Z. *)
        IF  (dt_rec.dt_temp_table)
        THEN
            b_err := e_sysinfo_not_found
        ELSE
            BEGIN
            WITH dt_rec.dt_usakey DO
                BEGIN
                stableid := tableid;
                sentrytyp:= cak_eusage;
                slinkage := linkage;
                skeylen  := mxak_standard_sysk
                END;
            (*ENDWITH*) 
            a10get_sysinfo (acv, dt_rec.dt_usakey, d_release,
                  dt_rec.dt_usabuf, b_err)
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            WITH dt_rec.dt_usabuf^.susage DO
                BEGIN
                REPEAT
                    udefcount := udefcount + 1;
                    IF  udefcount > usagecount
                    THEN
                        BEGIN
                        IF  usagenext_exist
                        THEN
                            udefcount := 0;
                        (*ENDIF*) 
                        ak111del_usage_rec (acv,
                              dt_rec.dt_usabuf, b_err);
                        IF  b_err = e_ok
                        THEN
                            BEGIN
                            IF  udefcount = 0
                            THEN
                                BEGIN
                                b_err := e_buffer_limit;
                                a06inc_linkage (linkage)
                                END
                            ELSE
                                b_err := e_sysinfo_not_found;
                            (*ENDIF*) 
                            END
                        ELSE
                            a07_b_put_error (acv, b_err, 1);
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  NOT usagedef[ udefcount ].usa_empty
                        THEN
                            b_err := e_use_fetch_rest;
                        (*ENDIF*) 
                    (*ENDIF*) 
                UNTIL
                    b_err <> e_ok;
                (*ENDREPEAT*) 
                IF  b_err = e_use_fetch_rest
                THEN
                    b_err := e_ok;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            WITH dt_rec.dt_usabuf^.susage.usagedef[ udefcount ] DO
                ak111drop_table (acv, usa_tableid,
                      usa_tablekind, tableid, tablkind,
                      false, dt_rec)
            (*ENDWITH*) 
        ELSE
            IF  b_err = e_sysinfo_not_found
            THEN
                IF  tablkind = tsynonym
                THEN
                    ak111del_synonymdef (acv, tableid, first_drop_tab)
                ELSE
                    ak111erase_table (acv, tableid,
                          from_tableid, from_tab_kind,
                          first_drop_tab, dt_rec)
                (*ENDIF*) 
            ELSE
                IF  b_err = e_buffer_limit
                THEN
                    b_err := e_ok
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    IF  b_err <> e_sysinfo_not_found
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111erase_table  (
            VAR acv          : tak_all_command_glob;
            VAR tableid      : tgg00_Surrogate;
            VAR from_tableid : tgg00_Surrogate;
            from_table_kind  : tgg00_TableKind;
            first_drop_tab   : boolean;
            VAR dt_rec       : drop_table_record);
 
VAR
      ok          : boolean;
      temp_table  : boolean;
      b_err       : tgg00_BasisError;
      c2          : tsp00_C2;
      sysk        : tgg00_SysInfoKey;
      qual        : tak_del_tab_qual;
      base_ptr    : tak_sysbufferaddress;
      handling    : tgg00_HandlingSet;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
&   IFDEF TRACE
    t01surrogate (ak_sem, 'erase tabid ', tableid);
    t01surrogate (ak_sem, 'from  tabid ', from_tableid);
&   ENDIF
    handling := acv.a_pars_curr.fileHandling_gg00;
    a06_systable_get (acv, d_fix, tableid, base_ptr, true, ok);
    IF  ok
    THEN
        WITH acv, base_ptr^.sbase DO
            BEGIN
            temp_table := bschema = cak_temp_user_id;
            IF  NOT temp_table
            THEN
                BEGIN
                (* PTS 1140510 *)
                a101_InvalidateListAppend (acv, bschema, btablen^);
                a38table_drop (acv, base_ptr^.sbase);
                sysk.sentrytyp := cak_etableref
                END
            ELSE
                BEGIN
                IF  NOT (hsNoLog_egg00 in btreeid. fileHandling_gg00)
                THEN
                    a_pars_curr.fileHandling_gg00 := [ hsWithoutLock_egg00 ];
                (*ENDIF*) 
                sysk.sentrytyp := cak_etemptableref
                END;
            (*ENDIF*) 
            (* delete table reference record *)
            sysk.sauthid     := bschema;
            sysk.sidentifier := btablen^;
            sysk.slinkage    := cak_init_linkage;
            sysk.skeylen     :=
                  mxak_standard_sysk + sizeof (sysk.sidentifier);
            a10del_sysinfo (acv, sysk, b_err);
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (* if not ok the table has already been dropped in the course *)
    (* of the drop execution, i.e. the view has been defined by a *)
    (* synonym that has already been dropped in the course of the *)
    (* drop execution                                             *)
    (*ENDIF*) 
    IF  (acv.a_returncode = 0) AND ok
    THEN
        WITH base_ptr^, syskey, sbase DO
            BEGIN
            IF  (btablekind in [twithkey, twithoutkey])
                OR
                ((btablekind = tonebase) AND (tableid = btreeid.fileTabId_gg00))
            THEN (* current table is a base table *)
                ak111destroy_files (acv, base_ptr)
            ELSE
                BEGIN
                IF  (btablekind = tonebase) AND
                    (from_table_kind <> tsynonym)
                THEN
                    BEGIN
                    IF  first_drop_tab
                    THEN
                        BEGIN
                        IF  NOT dt_rec.dt_no_references
                        THEN
                            ak111del_view_from_usage (acv,
                                  from_tableid,
                                  tableid, true);
                        (*ENDIF*) 
                        IF  dt_rec.dt_succ_filevers
                        THEN
                            BEGIN
                            c2[1] := btreeid.fileTabId_gg00[1];
                            c2[2] := btreeid.fileTabId_gg00[2];
                            IF  c2 <> cak_show_table_site
                            THEN
                                BEGIN
                                a06_systable_get (acv, d_fix,
                                      btreeid.fileTabId_gg00,
                                      acv.a_p_arr1.pbasep, false, ok);
                                IF  ok
                                THEN
                                    (* PTS 1111576 E.Z. *)
                                    ak111new_table_fileversion (acv,
                                          acv.a_p_arr1.pbasep^.sbase);
                                (* PTS 1110817
                                      ELSE
                                      a07ak_system_error (acv, 111, 1)
                                      *)
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  NOT (btablekind in [tdb2view])
                        AND
                        NOT dt_rec.dt_no_references
                    THEN
                        BEGIN
                        ak111del_view_from_usage (acv,
                              from_tableid, tableid,
                              first_drop_tab);
                        IF  (dt_rec.dt_succ_filevers) AND
                            (first_drop_tab)
                        THEN
                            ak111new_fileversion_all (acv, tableid);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  NOT temp_table
            THEN
                a19all_del_usertab (acv, base_ptr);
            (*ENDIF*) 
            qual.del_colno := 0;
            a10_del_tab_sysinfo (acv,
                  tableid, qual, temp_table, b_err);
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    acv.a_pars_curr.fileHandling_gg00 := handling
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111new_fileversion_all (
            VAR acv     : tak_all_command_glob;
            VAR tableid : tgg00_Surrogate);
 
VAR
      b_err       : tgg00_BasisError;
      c2          : tsp00_C2;
      ok          : boolean;
      tabno       : integer;
      qualbuf     : tak_sysbufferaddress;
      base_ptr    : tak_sysbufferaddress;
      syskey      : tgg00_SysInfoKey;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    syskey           := a01defaultkey;
    syskey.sauthid   := tableid;
    syskey.sentrytyp := cak_eviewqual_basis;
    a10get_sysinfo (acv, syskey, d_fix, qualbuf, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        FOR tabno := 1 TO qualbuf^.sviewqual_basis.vbasetabcnt DO
            WITH qualbuf^.sviewqual_basis.vtable[ tabno ] DO
                BEGIN
                c2[1] := vttableid[1];
                c2[2] := vttableid[2];
                IF  c2 <> cak_show_table_site (* PTS 1122364 *)
                THEN
                    BEGIN
                    a06_systable_get( acv, d_fix,
                          vttableid, base_ptr, true, ok );
                    IF  ok
                    THEN
                        BEGIN
                        (* PTS 1111576 E.Z. *)
                        ak111new_table_fileversion( acv, base_ptr^.sbase);
                        IF  acv.a_returncode = 0
                        THEN
                            a10rel_sysinfo( base_ptr );
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
        a10_rel_sysinfo( acv, syskey );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111ni_describe_named_indexes (
            VAR acv       : tak_all_command_glob;
            VAR base_rec  : tak_baserecord);
      (* this procedure describe named indexes as stack entries *)
      (* in the message buffer. Information about these indexes *)
      (* is stored in the show-file for SHOW DATA FOR DOMAIN,   *)
      (* which is used by the DOMAIN-Tool.                      *)
 
VAR
      schema             : tsp00_KnlIdentifier;
      index_name         : tsp00_KnlIdentifier;
      index_scan_rec     : tak_index_scan_record;
 
BEGIN
WITH acv, a_mblock, mb_qual^, index_scan_rec DO
    BEGIN
    IF  base_rec.bindexexist
    THEN (* there are named indexes to drop *)
        BEGIN
        a24init_index_scan (acv, base_rec.bsurrogate,
              index_scan_rec);
        WHILE a24next_named_index (acv, index_scan_rec) DO
            BEGIN
            WITH isr_buf^.smindex.indexdef[isr_index] DO
                IF  (indexno <> 0)
                THEN
                    BEGIN
                    (* insert information about dropped     *)
                    (* named index for SHOW DATA FOR DOMAIN *)
                    (* into show-file                       *)
                    a103GetSchemaName (acv, base_rec.bschema, schema);
                    a24get_indexname (acv, isr_buf, isr_index,
                          index_name);
                    a38index_drop (acv, schema, base_rec.btablen^,
                          a01_il_b_identifier, index_name);
                    (* multiple column index *)
                    mmult_pos              := 1;
                    mmult_cnt              := mmult_cnt + 1;
                    mb_st^ [mmult_cnt] := icolstack[ 1 ];
                    IF  mcol_cnt = 0
                    THEN
                        mfirst_free := mmult_cnt + 1;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            END;
        (*ENDWHILE*) 
        a24finish_index_scan (acv, index_scan_rec)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1111576 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak111new_table_fileversion (
            VAR acv           : tak_all_command_glob;
            VAR base_rec      : tak_baserecord);
 
VAR
      ok       : boolean;
      b_err    : tgg00_BasisError;
      base_ptr : tak_sysbufferaddress;
      tabid    : tgg00_Surrogate;
 
BEGIN
WITH acv DO
    IF  a_returncode = 0
    THEN
        IF  (base_rec.btablekind <> tcatalog_table)
        THEN
            BEGIN
            WITH base_rec DO
                BEGIN
                tabid := btreeid.fileTabId_gg00;
                END;
            (*ENDWITH*) 
            a10_version (acv, base_rec, m_succ_file_version, true);
            IF  a_returncode = 0
            THEN
                BEGIN
                a06_systable_get (acv, d_release, tabid, base_ptr, true, ok);
                IF  ok
                THEN
                    BEGIN
                    WITH base_ptr^.sbase DO
                        BEGIN
                        END;
                    (*ENDWITH*) 
                    a10_add_repl_sysinfo (acv, base_ptr, false, b_err);
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, 1);
                    (*ENDIF*) 
                    END
                ELSE
                    a07ak_system_error (acv, 11, 2);
                (*ENDIF*) 
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak111cnt_long_cols (
            VAR acv          : tak_all_command_glob;
            VAR base_rec     : tak_baserecord;
            VAR new_long_cnt : tsp00_Int2;
            VAR old_long_cnt : tsp00_Int2);
 
VAR
      basecolindex       : integer;
      recindex           : integer;
 
BEGIN
WITH acv, a_mblock, mb_qual^ DO
    BEGIN
    (* count new and old longs seperately *)
    recindex := 1;
    new_long_cnt := 0;
    old_long_cnt := 0;
    WITH base_rec  DO
        BEGIN
        basecolindex := bfirstindex;
        WHILE (basecolindex <= blastindex) AND
              (a_returncode = 0) DO
            BEGIN
            WITH bcolumn[basecolindex]^ DO
                IF  NOT (ctdropped in ccolpropset)
                THEN
                    BEGIN
                    IF  cdatatyp in [ dlonga, dlongb, dlonguni ]
                    THEN
                        new_long_cnt := succ(new_long_cnt)
                    ELSE     (* PTS 1115206 M.Ki. *)
                        IF  cdatatyp in [ dstra, dstrb, dstruni ]
                        THEN
                            old_long_cnt := succ(old_long_cnt)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
            basecolindex := succ(basecolindex);
            END;
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
