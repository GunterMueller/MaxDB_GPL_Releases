.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-10-05
*****************************************************
modname : VAK06
changed : 2000-10-05
module  : AK_universal_semantic_tools
 
Author  : ElkeZ
Created : 1987-09-22
*****************************************************
 
Purpose :
 
Define  :
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv      : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06char_retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06check_username (
                    VAR acv    : tak_all_command_glob;
                    VAR auth   : tsp00_KnlIdentifier;
                    VAR is_dba : boolean;
                    VAR ok     : boolean);
 
        PROCEDURE
              a06colname_retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4;
                    src_codeset : tsp00_Int2);
 
        PROCEDURE
              a06cpy_mblock (
                    VAR acv        : tak_all_command_glob;
                    VAR src_mblock : tgg00_MessBlock;
                    VAR dst_mblock : tgg00_MessBlock;
                    withoutData    : boolean;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              a06drop_ex_fieldlist_refs (VAR fieldlists : tgg00_FieldLists);
 
        PROCEDURE
              a06drop_fieldlist_references (VAR fieldlists : tgg00_FieldLists);
 
        PROCEDURE
              a06drop_pars_fieldlist_refs (VAR fieldlists : tgg00_FieldLists);
 
        FUNCTION
              a06exist_user (
                    VAR acv          : tak_all_command_glob;
                    VAR user_name    : tsp00_KnlIdentifier;
                    dstate           : tak_directory_state;
                    VAR user_rec_ptr : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06find_colinfo (
                    base_ptr        : tak_sysbufferaddress;
                    VAR stack_entry : tgg00_StackEntry;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06_c_send_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR b_err   : tgg00_BasisError);
 
        FUNCTION
              a06is_table_empty (
                    VAR acv          : tak_all_command_glob;
                    VAR file_id      : tgg00_FileId) : BOOLEAN;
 
        PROCEDURE
              a06get_page_cnt (
                    VAR acv          : tak_all_command_glob;
                    VAR file_id      : tgg00_FileId;
                    do_sample        : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR b_err        : tgg00_BasisError);
 
        PROCEDURE
              a06_get_priv  (
                    VAR acv     : tak_all_command_glob;
                    VAR brec    : tak_sysbufferaddress;
                    VAR priv    : tak_privilege);
 
        PROCEDURE
              a06get_priv  (
                    VAR acv       : tak_all_command_glob;
                    VAR brec      : tak_sysbufferaddress;
                    required_priv : tak00_PrivilegeSet;
                    VAR priv      : tak_privilege);
 
        PROCEDURE
              a06move_file_content (
                    VAR acv    : tak_all_command_glob;
                    VAR old_id : tgg00_FileId;
                    VAR new_id : tgg00_FileId;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR schema   : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR sparr    : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06_view_get_basetable (
                    VAR acv      : tak_all_command_glob;
                    VAR view_id  : tgg00_Surrogate;
                    tabno        : integer;
                    VAR base_id  : tgg00_Surrogate);
 
        PROCEDURE
              a06destroy_temp (
                    VAR acv     : tak_all_command_glob;
                    VAR temp_id : tgg00_FileId;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a06get_username_from_buffer (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR SourceBuffer: tsp00_MoveObj;
                    BufferLength   : tsp00_Int4;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06get_username (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06det_user_id (
                    VAR acv      : tak_all_command_glob;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR authid   : tgg00_Surrogate);
 
        PROCEDURE
              a06dml_send_mess_buf (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock;
                    VAR dmli   : tak_dml_info;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a06eval_page_count (
                    VAR acv          : tak_all_command_glob;
                    VAR file_id      : tgg00_FileId;
                    VAR startkey     : tgg00_Lkey;
                    VAR stopkey      : tgg00_Lkey;
                    do_sample        : boolean;
                    count_records    : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR min_page_cnt : tsp00_Int4;
                    VAR record_cnt   : tsp00_Int4;
                    VAR b_err        : tgg00_BasisError);
 
        PROCEDURE
              a06GetBaseTreeid (
                    VAR acv     : tak_all_command_glob;
                    VAR baseRec : tak_baserecord;
                    VAR tree    : tgg00_FileId);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06InvalidateMessBlock (
                    VAR acv     : tak_all_command_glob);
 
        PROCEDURE
              a06pred_linkage (VAR linkage : tsp00_C2);
 
        FUNCTION
              a06role_exist (
                    VAR acv          : tak_all_command_glob;
                    VAR role_name    : tsp00_KnlIdentifier;
                    dstate           : tak_directory_state;
                    VAR role_rec_ptr : tak_sysbufferaddress) : boolean;
 
        FUNCTION
              a06_role_excluded (
                    VAR acv     : tak_all_command_glob;
                    VAR role_id : tgg00_Surrogate) : boolean;
 
        PROCEDURE
              a06lsend_mess_buf (
                    VAR acv         : tak_all_command_glob;
                    VAR mblock      : tgg00_MessBlock;
                    call_from_rsend : boolean;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              a06public_priv  (
                    VAR acv  : tak_all_command_glob;
                    VAR brec : tak_baserecord;
                    VAR priv : tak_privilege);
 
        PROCEDURE
              a06put_errtext (
                    VAR acv       : tak_all_command_glob;
                    b_err_in      : tgg00_BasisError;
                    err_type      : tgg04_ErrorText;
                    errtext_len   : integer;
                    VAR errtext   : tsp00_C256;
                    VAR b_err_out : tgg00_BasisError);
 
        PROCEDURE
              a06remove_locked_state (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06reset_currpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06reset_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR mblock  : tgg00_MessBlock;
                    return_req  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a06set_mtree (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock;
                    VAR tree   : tgg00_FileId);
 
        PROCEDURE
              a06subquery_del_result (
                    VAR acv           : tak_all_command_glob;
                    VAR dmli          : tak_dml_info;
                    VAR subquery_tree : tgg00_FileId;
                    prefix_len        : integer);
 
        PROCEDURE
              a06systable_state (
                    VAR acv           : tak_all_command_glob;
                    tablename         : tsp00_KnlIdentifier;
                    VAR tree          : tgg00_FileId);
 
        FUNCTION
              a06uid (VAR user_id : tgg00_Surrogate) : tsp00_Int4;
 
        PROCEDURE
              a06userid_get (
                    VAR acv    : tak_all_command_glob;
                    VAR userid : tgg00_Surrogate;
                    VAR ok     : boolean);
&       IFDEF TRACE
 
        PROCEDURE
              a06td_priv (
                    p        : tak_privilege;
                    id       : tsp00_C18;
                    unpacked : boolean);
&       ENDIF
 
        PROCEDURE
              a06tempfile_empty (
                    VAR acv     : tak_all_command_glob;
                    VAR temp_id : tgg00_FileId;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a06unpack_priv (
                    VAR packed_priv   : tak_privilege;
                    VAR unpacked_priv : tak_privilege);
 
        PROCEDURE
              a06user_get_priv  (
                    VAR acv  : tak_all_command_glob;
                    VAR brec : tak_sysbufferaddress;
                    VAR user : tgg00_Surrogate;
                    VAR priv : tak_privilege);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              SQLManager : vak101;
 
        PROCEDURE
              a101_CopyMessBlockShallow (
                    VAR acv         : tak_all_command_glob;
                    VAR Source      : tgg00_MessBlock;
                    VAR Destination : tgg00_MessBlock;
                    withoutData     : boolean;
                    VAR e           : tgg00_BasisError);
 
        PROCEDURE
              a101_DestroyGroupedTempFiles(
                    VAR trans      : tgg00_TransContext;
                    fileType       : tgg00_TfnTemp(*ptocConst*);
                    level          : tsp00_Int4(*ptocConst*);
                    subLevel       : tsp00_Int2(*ptocConst*);
                    VAR fileName   : tgg00_Filename);
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        FUNCTION
              a101_GetTempFileLevel(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              SequenceWrapper : VAK104;
 
        FUNCTION
              ak104_CreateIncrementalMemorySequence (
                    allocator    : tgg00_VoidPtr;
                    refMode      : tak104_refcountMode;
                    VAR sequence : tsp00_MoveObjPtr;
                    msglist      : tak104_MsgList) : boolean;
 
        PROCEDURE
              ak104_DropReference_MS (
                    VAR sequence     : tsp00_MoveObjPtr);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51build_userkey (
                    VAR user_name : tsp00_KnlIdentifier;
                    VAR userkey : tgg00_SysInfoKey);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542pop_packet (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_show_syntax : VAK41;
 
        PROCEDURE
              a41execute_show (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              a41get_table (
                    VAR acv      : tak_all_command_glob;
                    show_kind    : tgg00_ShowKind;
                    VAR base_ptr : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a41table_exist (
                    VAR acv    : tak_all_command_glob;
                    VAR tablen : tsp00_KnlIdentifier;
                    VAR p_arr  : tak_syspointerarr;
                    VAR ok     : boolean);
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        PROCEDURE
              a40ignore_down_error (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Catalog_Migration_2 : VAK362;
 
        VAR
              a362OnlineTaskId : tsp00_TaskId;
 
      ------------------------------ 
 
        FROM
              AK_Synonym : VAK23;
 
        FUNCTION
              a23is_sequence_synonym (VAR synrec : tak_synonymrecord) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_usertab_tools : VAK19;
 
        FUNCTION
              a19user_knows_role (VAR acv : tak_all_command_glob;
                    VAR user_id : tgg00_Surrogate;
                    VAR role_id : tgg00_Surrogate) : boolean;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10_key_del  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103CatalogSchemaId (
                    VAR catalogSchemaId : tgg00_Surrogate);
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
        PROCEDURE
              a103GetSchemaId (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer;
                    VAR schemaId   : tgg00_Surrogate);
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_hex_uni_error (
                    VAR acv     : tak_all_command_glob;
                    uni_err     : tsp8_uni_error;
                    err_code    : tsp00_Int4;
                    to_unicode  : boolean;
                    bytestr     : tsp00_MoveObjPtr;
                    len         : tsp00_Int4 );
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061td_colinfo (
                    VAR colinfo : tak00_columninfo;
                    index : integer);
 
      ------------------------------ 
 
        FROM
              Syntax-Tree-Printer : VAK99;
 
        PROCEDURE
              a99priv (
                    layer    : tgg00_Debug;
                    p        : tak_privilege;
                    id       : tsp00_C18;
                    unpacked : boolean);
 
        PROCEDURE
              a99_priv_all_set (
                    layer              : tgg00_Debug;
                    priv_all_set       : tak00_PrivilegeSet;
                    priv_all_grant_set : tak00_PrivilegeSet);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05_identifier_get_from_buffer(
                    VAR acv            : tak_all_command_glob;
                    VAR SourceBuffer   : tsp00_MoveObj;
                    BufferLength       : tsp00_Int4;
                    IdentifierPosition : tsp00_Int4;
                    IdentifierLength   : tsp00_Int2;
                    ComplexStringID    : boolean;
                    ObjLength          : integer;
                    VAR MoveObj        : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05return_serial (
                    VAR acv          : tak_all_command_glob;
                    VAR first_serial : tsp00_Number;
                    VAR last_serial  : tsp00_Number);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey          : tgg00_SysInfoKey;
              a01diag_monitor_on     : boolean;
              a01emptypriv           : tak_privilege;
              a01controluser         : tsp00_KnlIdentifier;
              a01_i_dbarole          : tsp00_KnlIdentifier;
              a01_i_current_schema   : tsp00_KnlIdentifier;
              a01_i_domain           : tsp00_KnlIdentifier;
              a01_i_dual             : tsp00_KnlIdentifier;
              a01_i_public           : tsp00_KnlIdentifier;
              a01_i_queryrewriterules: tsp00_KnlIdentifier;
              a01_i_sys              : tsp00_KnlIdentifier;
              a01_i_syschecktablelog : tsp00_KnlIdentifier;
              a01_i_sysmonitor       : tsp00_KnlIdentifier;
              a01_i_sysmondata       : tsp00_KnlIdentifier;
              a01_i_syscmd_analyze   : tsp00_KnlIdentifier;
              a01_i_sysdata_analyze  : tsp00_KnlIdentifier;
              a01_i_sysdba           : tsp00_KnlIdentifier;
              a01_i_sysdd            : tsp00_KnlIdentifier;
              a01_i_sysparseid       : tsp00_KnlIdentifier;
              a01_i_sysupdstatwanted : tsp00_KnlIdentifier;
              a01_i_temp             : tsp00_KnlIdentifier;
              a01_i_user             : tsp00_KnlIdentifier;
              a01_i_usergroup        : tsp00_KnlIdentifier;
              a01_il_b_identifier    : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              Build_Strategy : VAK70;
 
        VAR
              a70glob_fetch_strats      : tgg07_StratEnumSet;
 
      ------------------------------ 
 
        FROM
              Build_Strategy_2 : VAK71;
 
        (* PTS 1118666 M.Ki. *)
        FUNCTION
              a71GetKeyFromKeystrat (
                    VAR mblock      : tgg00_MessBlock;
                    VAR key         : tgg00_Lkey;
                    VAR b_err       : tgg00_BasisError) : boolean;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1  : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
              b01fullkey    : tsp00_Key;
 
        PROCEDURE
              b01filestate (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : vbd02;
 
        PROCEDURE
              b02calculate_page_count (
                    VAR t            : tgg00_TransContext;
                    VAR file_id      : tgg00_FileId;
                    VAR startkey     : tgg00_Lkey;
                    VAR stopkey      : tgg00_Lkey;
                    VAR page_count   : tsp00_Int4);
 
        PROCEDURE
              b02eval_page_count (
                    VAR t            : tgg00_TransContext;
                    VAR file_id      : tgg00_FileId;
                    VAR startkey     : tgg00_Lkey;
                    VAR stopkey      : tgg00_Lkey;
                    count_records    : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR min_page_cnt : tsp00_Int4;
                    VAR record_cnt   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_3 : VBD03;
 
        PROCEDURE
              b03calculate_page_count (
                    VAR t            : tgg00_TransContext;
                    VAR file_id      : tgg00_FileId;
                    VAR startkey     : tgg00_Lkey;
                    VAR stopkey      : tgg00_Lkey;
                    count_records    : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR min_page_cnt : tsp00_Int4;
                    VAR record_cnt   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              error_text_handling : VBD06;
 
        PROCEDURE
              b06put_errtxt (
                    VAR t         : tgg00_TransContext;
                    pid           : tsp00_TaskId;
                    errlen        : integer;
                    etexttype     : tgg04_ErrorText;
                    b_err_in      : tgg00_BasisError;
                    VAR errtxt    : tsp00_C256;
                    VAR b_err_out : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : vbd998;
 
        FUNCTION
              bd998IsTempFile(
                    VAR trans  : tgg00_TransContext;
                    VAR fileId : tgg00_FileId) : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
&       ifdef TRACE
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
&       endif
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    src_upb  : tsp00_Int4;
                    dest_upb : tsp00_Int4;
                    src      : tsp00_MoveObjPtr;
                    src_pos  : tsp00_Int4;
                    dest     : tsp00_MoveObjPtr;
                    dest_pos : tsp00_Int4;
                    length   : tsp00_Int4;
                    VAR err  : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26new_part_init (
                    packet_ptr             : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
        PROCEDURE
              s26finish_part (
                    packet_ptr           : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        FUNCTION
              s26size_new_part (
                    packet_ptr : tsp1_packet_ptr;
                    VAR segm : tsp1_segment) : tsp00_Int4;
 
        PROCEDURE
              s26find_part (VAR segm : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
        PROCEDURE
              s26reset_part (VAR segm : tsp1_segment;
                    VAR part_ptr : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30cmp (
                    VAR buf1     : tsp00_Key;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_Key;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01vtrace        : tgg00_VtraceState;
              g01glob          : tgg00_KernelGlobals;
              g01unicode       : boolean;
 
        PROCEDURE
              g01datapart_init (
                    VAR mblock    : tgg00_MessBlock;
                    datapart_ptr  : tgg00_DataPartPtr;
                    datapart_size : tsp00_Int4);
 
        PROCEDURE
              g01stratpart_init (
                    VAR mblock     : tgg00_MessBlock;
                    stratpart_ptr  : tsp00_MoveObjPtr;
                    stratpart_size : tsp00_Int4);
 
        FUNCTION
              g01maxuserstack : tsp00_Int4;
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              g01qual_init (
                    VAR mblock : tgg00_MessBlock;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
        PROCEDURE
              g01stack_init (
                    VAR mblock : tgg00_MessBlock;
                    stack_ptr  : tgg00_StackListPtr;
                    stack_size : tsp00_Int4;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        FUNCTION
              g04inv_tfn (tfn : tgg00_Tfn) : boolean;
 
      ------------------------------ 
 
        FROM
              KB_functions : VKB05;
 
        PROCEDURE
              k05functions (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              k05cold_functions (VAR mblock : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53wait (VAR t  : tgg00_TransContext;
                    MessType  : tgg00_MessType;
                    MessType2 : tgg00_MessType2);
 
        PROCEDURE
              k53row_lock_by_key (VAR t : tgg00_TransContext;
                    VAR FileId      : tgg00_FileId;
                    VAR k           : tsp00_Key (*ptocSynonym tsp00_KeyPtr*);
                    KeyLen          : tsp00_Int4;
                    MessType        : tgg00_MessType;
                    ResultCount     : tsp00_Int4;
                    VAR GrantedMode : tgg00_LockReqMode);
 
      ------------------------------ 
 
        FROM
              KB_Logging : vkb560;
 
        FUNCTION
              kb560IsCatalogTable(VAR tabId : tgg00_Surrogate) : boolean;
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (
                    VAR Trans  : tgg00_TransContext;
                    TraceLayer : tgg00_Debug;
                    TraceType  : tgg00_VtraceType;
                    BodyLen    : tsp00_Int2;
                    pEntry     : tgg11_VtraceBodyPtr);
 
        PROCEDURE
              b120MessBlockTrace (
                    VAR Trans     : tgg00_TransContext;
                    TraceType     : tgg00_VtraceType;
                    VAR MessBlock : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans (
                    src_ptr         : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vsleft (VAR freestacksize : tsp00_Int4);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01sname (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname);
 
        PROCEDURE
              t01messtype (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    mess_type    : tgg00_MessType);
 
        PROCEDURE
              t01mess2type (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    mess2_type    : tgg00_MessType2);
 
        PROCEDURE
              t01basis_error (
                    layer : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01c18 (
                    layer : tgg00_Debug;
                    msg : tsp00_C18);
 
        PROCEDURE
              t01lidentifier (
                    layer      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01handling (
                    layer : tgg00_Debug;
                    nam : tsp00_Sname;
                    s   : tgg00_HandlingSet);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01surrogate (
                    layer     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01moveobj (
                    layer    : tgg00_Debug;
                    VAR buf  : tak00_columninfo;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    bufaddr  : tsp00_MoveObjPtr);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        FUNCTION
              ak104_CreateIncrementalMemorySequence;
 
              tak104_Allocator tgg00_VoidPtr
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        PROCEDURE
              ak104_DropReference_MS;
 
              tak104_MemorySequence tsp00_MoveObjPtr
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              a05_identifier_get_from_buffer;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s30cmp;
 
              tsp00_MoveObj tsp00_Key
              tsp00_MoveObj tsp00_Key
&             ifdef trace
 
        PROCEDURE
              t01moveobj;
 
              tsp00_MoveObj tak00_columninfo
 
        PROCEDURE
              t01addr;
 
              tsp00_BufAddr tsp00_MoveObjPTR
&             endif
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Description:
 
PROCEDURE  A06_VIEW_GET_BASETABLE :
 
Bei einer View mit mehreren Fromtabellen wird
aus der Viewqualification ?uber die tabno der
zugeh?orige Baistabellennamen mit Location
geholt.
 
 
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      cak_call_from_rsend  = true (* a06lsend_mess_buf *);
      c_check_roles        = true;
      (*                                             *)
      c_trans_to_uni    = true (* a07_hex_uni_error  *);
      c_unicode_wid     = 2    (* a07_hex_uni_error  *);
 
 
(*------------------------------*) 
 
PROCEDURE
      ak06proc_privileges (
            VAR acv  : tak_all_command_glob;
            tab_ptr  : tak_sysbufferaddress;
            VAR priv : tak_privilege);
 
VAR
      is_ddl          : tak_ddl_descriptor;
      proc_owner_priv : tak_privilege;
      m_is_ddl        : tak_ddl_descriptor;
 
BEGIN
WITH acv DO
    (* determine privileges the owner of the dbproc may grant *)
    IF  a_curr_user_id <> a_proc_userid
    THEN
        BEGIN
        is_ddl       := acv.a_is_ddl;
        acv.a_is_ddl := ddl_create_procedure; (* disable role privileges *)
        a06user_get_priv  (acv, tab_ptr,
              a_proc_userid, proc_owner_priv);
        priv.priv_all_set := priv.priv_all_set +
              proc_owner_priv.priv_all_grant_set;
        priv.priv_col_exist := priv.priv_col_exist +
              proc_owner_priv.priv_col_exist;
        priv.priv_sel_set := priv.priv_sel_set +
              proc_owner_priv.priv_grant_sel_set;
        priv.priv_upd_set := priv.priv_upd_set +
              proc_owner_priv.priv_grant_upd_set;
        acv.a_is_ddl := is_ddl;
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06role_privileges (
            VAR acv       : tak_all_command_glob;
            VAR brec      : tak_sysbufferaddress;
            required_priv : tak00_PrivilegeSet;
            VAR priv      : tak_privilege);
 
VAR
      b_err       : tgg00_BasisError;
      ix          : integer;
      found       : boolean;
      roletab_ptr : tak_sysbufferaddress;
      roleId      : tgg00_Surrogate;
      sysk        : tgg00_SysInfoKey;
      initPriv    : tak_privilege;
 
BEGIN
&ifdef trace
a99priv (ak_sem, priv, 'initial privilege ', true);
&endif
initPriv := priv;
found    := false;
IF  acv.a_role_info in [role_all, role_except] (* PTS 1104065 *)
THEN
    BEGIN
    IF  acv.a_current_user_kind in [udba, usysdba]
    THEN
        IF  a06role_exist (acv, a01_i_dbarole, d_release, roletab_ptr)
        THEN
            BEGIN
            roleId := roletab_ptr^.suser.usurrogate;
            IF  NOT a06_role_excluded (acv, roleId)
            THEN
                BEGIN
                ak06one_role_privilege (acv, roleId,
                      brec, required_priv, priv, found);
                IF  NOT found
                THEN
                    ak06scan_roles (acv, roleId,
                          brec, required_priv, priv, found);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT found AND (acv.a_returncode = 0)
    THEN
        BEGIN
        sysk           := a01defaultkey;
        sysk.sauthid   := acv.a_curr_user_id;
        sysk.sentrytyp := cak_eroletab;
        REPEAT
            a10get_sysinfo (acv, sysk, d_fix,
                  roletab_ptr, b_err);
            IF  b_err = e_ok
            THEN
                WITH roletab_ptr^.susertab DO
                    BEGIN
                    ix := 1;
                    WHILE (ix <= usertabcount) AND NOT found DO
                        WITH usertabdef[ix] DO
                            BEGIN
                            IF  NOT ut_empty
                            THEN
                                IF  NOT a06_role_excluded (acv, ut_surrogate)
                                THEN
                                    BEGIN
                                    ak06one_role_privilege (acv, ut_surrogate,
                                          brec, required_priv, priv, found);
                                    IF  NOT found
                                    THEN
                                        ak06scan_roles (acv, ut_surrogate,
                                              brec, required_priv, priv, found);
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            ix := ix + 1;
                            END;
                        (*ENDWITH*) 
                    (*ENDWHILE*) 
                    a10rel_sysinfo (roletab_ptr);
                    IF  NOT found AND
                        roletab_ptr^.susertab.usertabnext_exist
                    THEN
                        a06inc_linkage (sysk.slinkage)
                    ELSE
                        b_err := e_sysinfo_not_found
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  (b_err = e_sysinfo_not_found  ) AND
                (sysk.sauthid <> cak_public_id) AND
                NOT found
            THEN
                BEGIN
                b_err         := e_ok;
                sysk.sauthid  := cak_public_id;
                sysk.slinkage := cak_init_linkage
                END;
            (*ENDIF*) 
        UNTIL
            b_err <> e_ok;
        (*ENDREPEAT*) 
        IF  b_err <> e_sysinfo_not_found
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
ELSE
    IF  acv.a_role_ptr <> NIL
    THEN
        BEGIN
        ix := 1;
        WHILE (ix <= acv.a_role_ptr^.rctxt_cnt) AND NOT found DO
            BEGIN
            IF  a19user_knows_role (acv, acv.a_curr_user_id, acv.a_role_ptr^.rctxt_roles[ix])
            THEN
                BEGIN
                ak06one_role_privilege (acv, acv.a_role_ptr^.rctxt_roles[ix],
                      brec, required_priv, priv, found);
                IF  NOT found
                THEN
                    ak06scan_roles (acv,
                          acv.a_role_ptr^.rctxt_roles[ix],
                          brec, required_priv, priv, found);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            ix := ix + 1
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  (initPriv.priv_all_set <> priv.priv_all_set) OR
    (initPriv.priv_sel_set <> priv.priv_sel_set) OR
    (initPriv.priv_upd_set <> priv.priv_upd_set)
THEN (* role has been used ==> don't store statement as shared sql statement *)
    BEGIN
    acv.a_parsingForSharedSql := false;
&   ifdef trace
    t01c18 (ak_sem, 'disable shared sql');
&   endif
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06one_role_privilege  (
            VAR acv       : tak_all_command_glob;
            VAR role_id   : tgg00_Surrogate;
            brec          : tak_sysbufferaddress;
            required_priv : tak00_PrivilegeSet;
            VAR priv      : tak_privilege;
            VAR found     : boolean);
 
VAR
      role_priv    : tak_privilege;
      curr_user_id : tgg00_Surrogate;
 
BEGIN
curr_user_id       := acv.a_curr_user_id;
acv.a_curr_user_id := role_id;
ak06get_priv (acv, brec, required_priv, NOT c_check_roles, role_priv);
acv.a_curr_user_id := curr_user_id;
priv.priv_all_set := priv.priv_all_set + role_priv.priv_all_set;
priv.priv_all_grant_set :=
      priv.priv_all_grant_set + role_priv.priv_all_grant_set;
priv.priv_col_exist :=
      priv.priv_col_exist + role_priv.priv_col_exist;
priv.priv_sel_set       :=
      priv.priv_sel_set + role_priv.priv_sel_set;
priv.priv_upd_set       :=
      priv.priv_upd_set + role_priv.priv_upd_set;
priv.priv_grant_sel_set :=
      priv.priv_grant_sel_set + role_priv.priv_grant_sel_set;
priv.priv_grant_upd_set :=
      priv.priv_grant_upd_set + role_priv.priv_grant_upd_set;
priv.priv_ref_set       :=
      priv.priv_ref_set + role_priv.priv_ref_set;
priv.priv_grant_ref_set :=
      priv.priv_grant_ref_set + role_priv.priv_grant_ref_set;
found := required_priv - priv.priv_all_set = []
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06scan_roles (
            VAR acv       : tak_all_command_glob;
            role_id       : tgg00_Surrogate;
            VAR brec      : tak_sysbufferaddress;
            required_priv : tak00_PrivilegeSet;
            VAR priv      : tak_privilege;
            VAR found     : boolean);
 
VAR
      b_err       : tgg00_BasisError;
      index       : integer;
      roletab_ptr : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
 
BEGIN
found          := required_priv - priv.priv_all_set = [];
index          := 0;
sysk           := a01defaultkey;
sysk.sauthid   := role_id;
sysk.sentrytyp := cak_eroletab;
REPEAT
    index := index + 1;
    a10get_sysinfo (acv, sysk, d_release,
          roletab_ptr, b_err);
    IF  b_err = e_ok
    THEN
        IF  index > roletab_ptr^.susertab.usertabcount
        THEN
            IF  roletab_ptr^.susertab.usertabnext_exist
            THEN
                a06inc_linkage (sysk.slinkage)
            ELSE
                b_err := e_sysinfo_not_found
            (*ENDIF*) 
        ELSE
            WITH roletab_ptr^.susertab.usertabdef[index] DO
                IF  NOT ut_empty
                THEN
                    BEGIN
                    ak06one_role_privilege (acv,
                          ut_surrogate, brec, required_priv, priv, found);
                    IF  NOT found
                    THEN
                        ak06scan_roles (acv, ut_surrogate,
                              brec, required_priv, priv, found);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    b_err <> e_ok;
(*ENDREPEAT*) 
IF  b_err <> e_sysinfo_not_found
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06trigger_result (
            VAR acv    : tak_all_command_glob;
            VAR mblock : tgg00_MessBlock);
 
BEGIN
acv.a_execute_trigger                  := true;
acv.a_trigger_tree.fileTriggerKey_gg00 := mblock.mb_qual^.mr_restree.fileTriggerKey_gg00;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06trigger (
            VAR acv    : tak_all_command_glob;
            VAR mblock : tgg00_MessBlock);
 
BEGIN
IF  (mblock.mb_type = m_insert)        OR
    (mblock.mb_type = m_insert_select) OR
    (mblock.mb_type = m_update)        OR
    (mblock.mb_type = m_delete)
THEN
    BEGIN
    WITH mblock.mb_qual^.mtrigger_info DO
        BEGIN
        IF  NOT acv.a_execute_trigger
        THEN
            tiqb_tree_id.fileHandling_gg00 :=
                  tiqb_tree_id.fileHandling_gg00 + [ hsCreateFile_egg00 ]
        ELSE
            tiqb_tree_id.fileHandling_gg00 :=
                  tiqb_tree_id.fileHandling_gg00 - [ hsCreateFile_egg00 ];
        (*ENDIF*) 
&       IFDEF TRACE
        t01int4 (ak_sem, 'a_exec_trigg', ord(acv.a_execute_trigger));
&       ENDIF
        IF  NOT acv.a_execute_trigger
        THEN
            BEGIN
            (* first kb05 order of current sql order which *)
            (* may cause a trigger call                    *)
            tiqb_key  := cgg_zero_c4;
            acv.a_trigger_tree.fileTriggerKey_gg00 := cgg_zero_c4;
            END
        ELSE
            tiqb_key := acv.a_trigger_tree.fileTriggerKey_gg00;
        (*ENDIF*) 
        tiqb_init_key                 := tiqb_key;
        a101_SetTempFileIndex (acv, tiqb_tree_id, acv.a_trigger_level);
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06vtrace (
            VAR acv           : tak_all_command_glob;
            VAR mblock        : tgg00_MessBlock;
            VAR return_vtrace : boolean);
 
VAR
      trace_object : tgg00_VtraceType;
 
BEGIN
WITH acv DO
    BEGIN
    trace_object := td_none;
    IF  return_vtrace
    THEN
        trace_object := ak_receive
    ELSE
        IF  ((mblock.mb_type in [ m_insert, m_insert_select ])
            AND g01vtrace.vtrAkInsert_gg00) OR
            ((mblock.mb_type in [ m_update, m_update_rec ])
            AND g01vtrace.vtrAkUpdate_gg00) OR
            ((mblock.mb_type = m_delete)
            AND g01vtrace.vtrAkDelete_gg00) OR
            ((mblock.mb_type in [ m_select, m_select_row,
            m_union, m_get, m_fetch ])
            AND g01vtrace.vtrAkSelect_gg00)
        THEN
            BEGIN
            return_vtrace:= true;
            trace_object := ak_send
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  return_vtrace
    THEN
        b120MessBlockTrace (a_transinf.tri_trans, trace_object, mblock)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06a_mblock_init (
            VAR acv      : tak_all_command_glob;
            mtype        : tgg00_MessType;
            m2type       : tgg00_MessType2;
            VAR tree     : tgg00_FileId);
 
VAR
      datalen : integer;
      msglist : tak104_MsgList;
 
BEGIN
WITH acv DO
    BEGIN
&   ifdef trace
    t01messtype( ak_sem, 'mtype       ', mtype );
    t01mess2type( ak_sem, 'm2type      ', m2type );
&   endif
    datalen := a_mblock.mb_data_len;
    (* for internal sql *)
    g01mblock_init   (a_transinf.tri_trans, mtype, m2type, a_mblock);
    g01datapart_init (a_mblock, a_mb_data_addr, a_mb_data_size);
    a_mblock.mb_data_len := cgg_rec_key_offset;
    g01stack_init    (a_mblock, a_stack_addr, a_stack_size,
          a_mb_qual_addr, a_mb_qual_size);
    g01stratpart_init (a_mblock, a_mb_strat_addr, a_mb_strat_size);
    IF  a_variable_input                AND
        (a_ex_kind <> only_executing)   AND
        (a_init_ddl = no_ddl)           AND
        (a_count_literals > 0)          AND
        NOT (mtype in [ m_invalid, m_nil, m_fetch, m_get, m_insert_select ])
        (* m_get : i.e. vak56, foreign key *)
    THEN
        BEGIN
        msglist := NIL;
        IF  NOT ak104_CreateIncrementalMemorySequence ( a_transinf.tri_trans.trAllocator_gg00,
            sessionCount_eak104, a_mblock.mb_fieldlists[cgg_idx_literal_valuefieldlist], msglist)
        THEN
            a07_b_put_error (acv, e_no_more_memory, 1);
&       ifdef TRACE
        (*ENDIF*) 
        t01addr (ak_sem, 'newfieldlist',
              a_mblock.mb_fieldlists[cgg_idx_literal_valuefieldlist]);
&       endif
        END;
    (*ENDIF*) 
    a06set_mtree (acv, a_mblock, tree);
    CASE  mtype OF
        m_commit, m_rollback :
            IF  m2type = mm_keep_lock
            THEN
                a_mblock.mb_struct := mbs_lock
            ELSE
                a_mblock.mb_struct := mbs_buf;
            (*ENDIF*) 
        m_show :
            IF  (m2type <> mm_with_join) AND
                (m2type <> mm_first_join_select)
            THEN
                a_mblock.mb_struct := mbs_buf;
            (*ENDIF*) 
        m_connect, m_destroy_temp, m_down,
        (* PTS 1114833 UJ m_inquire *) m_move, m_nextval, (* PTS 1114833 UJ m_notify, *)
        m_release, (* PTS 1114833 UJ m_signal_commit, *) m_stamp, m_union :
            a_mblock.mb_struct := mbs_buf;
        (* PTS 1107952 E.Z. *)
        m_create_table, m_succ_file_version :
            a_mblock.mb_struct := mbs_tree_id;
        m_end, m_flush, (* PTS 1114833 UJ m_insert_trans *) m_mend, m_set :
            a_mblock.mb_struct := mbs_nil;
        m_column :
            BEGIN
            a_mblock.mb_struct := mbs_long;
            IF  (m2type = mm_write) OR (m2type = mm_new_write)
            THEN
                a_mblock.mb_data_len := datalen
            (*ENDIF*) 
            END;
        m_lock, m_unlock :
            a_mblock.mb_struct := mbs_lock;
        (* PTS 1125096 E.Z. *)
        m_verify :
            a_mblock.mb_struct := mbs_verify;
        OTHERWISE ;
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06_c_send_mess_buf (
            VAR acv     : tak_all_command_glob;
            VAR b_err   : tgg00_BasisError);
 
BEGIN
WITH acv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        a_mblock.mb_work_st      := a_work_st_addr;
        a_mblock.mb_work_st_max  := a_work_st_max;
        a_mblock.mb_workbuf      := a_work_buf_addr;
        a_mblock.mb_workbuf_size := a_work_buf_size;
        a_mblock.mb_trns         := @a_transinf.tri_trans;
        k05cold_functions (a_mblock);
        b_err := a_transinf.tri_trans.trError_gg00
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06char_retpart_move (
            VAR acv     : tak_all_command_glob;
            moveobj_ptr : tsp00_MoveObjPtr;
            move_len    : tsp00_Int4);
 
BEGIN
IF  NOT acv.a_retpart_locked
THEN
    BEGIN
    (*============================================
          check for command_segment IN = OUT *)
    ak06destroy_input_ptr (acv);
    (*=============================================*)
    IF  acv.a_curr_retpart = NIL
    THEN
        a06init_curr_retpart (acv);
    (*ENDIF*) 
    IF  acv.a_curr_retpart <> NIL
    THEN
        WITH acv.a_curr_retpart^ DO
            BEGIN
            IF  (sp1p_buf_size >= sp1p_buf_len + move_len) AND (move_len >= 0)
            THEN
                BEGIN
                SAPDB_PascalMove ('VAK06 ',   1,    
                      move_len, sp1p_buf_size,
                      moveobj_ptr, 1, @sp1p_buf, sp1p_buf_len + 1, move_len, acv.a_returncode);
                sp1p_buf_len := sp1p_buf_len + move_len
                END
            ELSE
                a07_b_put_error (acv, e_too_small_packet_size, 1)
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(* PTS 1113268 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a06colname_retpart_move (
            VAR acv     : tak_all_command_glob;
            moveobj_ptr : tsp00_MoveObjPtr;
            move_len    : tsp00_Int4;
            src_codeset : tsp00_Int2);
 
VAR
      error       : tsp8_uni_error;
      namelen     : integer;
      length      : tsp00_Int4;
      err_char_no : tsp00_Int4;
      name_ptr    : tsp00_MoveObjPtr;
      aux         : tsp00_C256;
 
BEGIN
WITH acv DO
    IF  NOT a_retpart_locked
    THEN
        BEGIN
        (*============================================
              check for command_segment IN = OUT *)
        ak06destroy_input_ptr (acv);
        (*=============================================*)
        namelen := move_len;
        IF  g01unicode
        THEN
            BEGIN
            IF  src_codeset >= csp_unicode_swap
            THEN
                length := (namelen DIV 2) * a_max_codewidth
            ELSE
                length := namelen * a_max_codewidth;
            (*ENDIF*) 
            s80uni_trans (moveobj_ptr, namelen, src_codeset, @aux, length,
                  a_out_packet^.sp1_header.sp1h_mess_code,
                  [ ], error, err_char_no);
            IF  error <> uni_ok
            THEN
                a07_hex_uni_error (acv, error, 1, NOT c_trans_to_uni,
                      @(moveobj_ptr^ [err_char_no]), c_unicode_wid);
            (*ENDIF*) 
            namelen  := length;
            name_ptr := @aux
            END
        ELSE
            BEGIN
            name_ptr := moveobj_ptr;
            END;
        (*ENDIF*) 
        IF  a_curr_retpart = NIL
        THEN
            a06init_curr_retpart (acv);
        (*ENDIF*) 
        IF  a_curr_retpart <> NIL
        THEN
            WITH a_curr_retpart^ DO
                IF  (sp1p_buf_size >= sp1p_buf_len + 1 + namelen) AND (namelen >= 0)
                THEN
                    BEGIN
                    sp1p_buf[sp1p_buf_len + 1] := chr(namelen);
                    SAPDB_PascalMove ('VAK06 ',   2,    
                          namelen, sp1p_buf_size,
                          name_ptr, 1, @sp1p_buf, sp1p_buf_len + 2,
                          namelen, acv.a_returncode);
                    sp1p_buf_len := sp1p_buf_len + 1 + namelen
                    END
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06cpy_mblock (
            VAR acv        : tak_all_command_glob;
            VAR src_mblock : tgg00_MessBlock;
            VAR dst_mblock : tgg00_MessBlock;
            withoutData    : boolean;
            VAR e          : tgg00_BasisError);
 
BEGIN
&ifdef trace
t01messblock (ak_sem, 'src_mblock  ', src_mblock);
t01int4 (ak_sem, 'mb_qual_size', dst_mblock.mb_qual_size);
t01int4 (ak_sem, 'mb_st_size  ', dst_mblock.mb_st_size);
t01int4 (ak_sem, 'mb_data_size', dst_mblock.mb_data_size);
t01int4 (ak_sem, 'mb_strat_siz', dst_mblock.mb_strat_size);
&endif
a101_CopyMessBlockShallow (acv, src_mblock, dst_mblock, withoutData, e);
&ifdef trace
t01sname( ak_sem, '+----------+' );
t01messblock (ak_sem, 'dst_mblock  ', dst_mblock);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      a06exist_user (
            VAR acv          : tak_all_command_glob;
            VAR user_name    : tsp00_KnlIdentifier;
            dstate           : tak_directory_state;
            VAR user_rec_ptr : tak_sysbufferaddress) : boolean;
 
BEGIN
IF  ak06exist_user (acv, user_name, dstate, user_rec_ptr)
THEN
    a06exist_user := NOT (is_role_rec in user_rec_ptr^.suser.urecordtyp) AND
          NOT (is_schema_rec in user_rec_ptr^.suser.urecordtyp)
ELSE
    a06exist_user := false
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a06role_exist (
            VAR acv          : tak_all_command_glob;
            VAR role_name    : tsp00_KnlIdentifier;
            dstate           : tak_directory_state;
            VAR role_rec_ptr : tak_sysbufferaddress) : boolean;
 
BEGIN
IF  ak06exist_user (acv, role_name, dstate, role_rec_ptr)
THEN
    a06role_exist := is_role_rec in role_rec_ptr^.suser.urecordtyp
ELSE
    a06role_exist := false
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a06_role_excluded (
            VAR acv     : tak_all_command_glob;
            VAR role_id : tgg00_Surrogate) : boolean;
 
VAR
      ix    : integer;
      found : boolean;
 
BEGIN
IF  (acv.a_role_info = role_except) AND
    (acv.a_role_ptr  <> NIL)
THEN
    BEGIN
    found := false;
    ix    := 1;
    WHILE ix <= acv.a_role_ptr^.rctxt_cnt DO
        IF  acv.a_role_ptr^.rctxt_roles[ix] = role_id
        THEN
            BEGIN
            found := true;
            ix    := csp_maxint2
            END
        ELSE
            ix := ix + 1;
        (*ENDIF*) 
    (*ENDWHILE*) 
    a06_role_excluded := found
    END
ELSE
    a06_role_excluded := acv.a_returncode <> 0
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak06exist_user (
            VAR acv          : tak_all_command_glob;
            VAR user_name    : tsp00_KnlIdentifier;
            dstate           : tak_directory_state;
            VAR user_rec_ptr : tak_sysbufferaddress) : boolean;
 
VAR
      b_err : tgg00_BasisError;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
a51build_userkey (user_name, sysk);
a10get_sysinfo (acv, sysk, d_release,
      user_rec_ptr, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    sysk           := a01defaultkey;
    sysk.sauthid   := user_rec_ptr^.suserref.ru_user_id;
    sysk.sentrytyp := cak_euser;
    a10get_sysinfo (acv, sysk, dstate,
          user_rec_ptr, b_err)
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    ak06exist_user := true
ELSE
    BEGIN
    ak06exist_user := false;
    IF  b_err <> e_sysinfo_not_found
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06extcolno (
            VAR baserec     : tak_baserecord;
            extcolno        : integer;
            VAR colinfo_ptr : tak00_colinfo_ptr);
 
VAR
      colindex : integer;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'extcolno    ', extcolno);
&endif
WITH baserec DO
    colindex := bextcolindex[extcolno] + bfirstindex;
(*ENDWITH*) 
&ifdef trace
t01int4 (ak_sem, 'colindex    ', colindex);
&endif
colinfo_ptr := a103GetColumn (baserec, colindex);
&ifdef trace
;
t01int4 (ak_sem, 'bextcolindex', baserec.bextcolindex[extcolno]);
WITH colinfo_ptr^ DO
    BEGIN
    t01int4 (ak_sem, 'cextcolno   ', cextcolno);
    t01moveobj (ak_sem, colinfo_ptr^, 1, sizeof (colinfo_ptr^) -
          sizeof (colinfo_ptr^.ccolumnn) +
          ord(colinfo_ptr^.ccolumnn_len));
    END;
(*ENDWITH*) 
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06find_colinfo (
            base_ptr        : tak_sysbufferaddress;
            VAR stack_entry : tgg00_StackEntry;
            VAR colinfo_ptr : tak00_colinfo_ptr);
 
VAR
      col_index : integer;
      pCol      : tak00_colinfo_ptr;
 
BEGIN
colinfo_ptr := NIL;
WITH base_ptr^.sbase DO
    BEGIN
    CASE stack_entry.etype OF
        st_fixkey :
            col_index := bfirstcolind;
        st_varkey :
            col_index := blastkeyind;
        OTHERWISE
            IF  bkeycolcount > 0
            THEN
                col_index := blastkeyind
            ELSE
                col_index := bfirstcolind;
            (*ENDIF*) 
        END;
    (*ENDCASE*) 
    WHILE col_index <> 0 DO
        BEGIN
        pCol := a103GetColumn (base_ptr^.sbase, col_index);
        IF  (pCol^.ccolstack.etype = stack_entry.etype   )
            AND
            (pCol^.ccolstack.epos  = stack_entry.epos    )
        THEN
            BEGIN
&           ifdef trace
            a061td_colinfo (pCol^, col_index);
&           endif
            colinfo_ptr := pCol;
            col_index   := 0
            END
        ELSE
            col_index := pCol^.cnextind
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06_get_priv  (
            VAR acv     : tak_all_command_glob;
            VAR brec    : tak_sysbufferaddress;
            VAR priv    : tak_privilege);
 
BEGIN
ak06get_priv (acv, brec,
      [r_sel, r_upd, r_ins, r_del, r_alter, r_owner, r_index, r_link],
      c_check_roles, priv)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06get_priv  (
            VAR acv       : tak_all_command_glob;
            VAR brec      : tak_sysbufferaddress;
            required_priv : tak00_PrivilegeSet;
            VAR priv      : tak_privilege);
 
BEGIN
&ifdef trace
a99_priv_all_set (ak_sem, required_priv, []);
&endif
ak06get_priv (acv, brec, required_priv, c_check_roles, priv)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06GetSequencePriv (
            VAR acv       : tak_all_command_glob;
            VAR Sequence  : tak_sequencerecord;
            VAR priv      : tak_privilege);
 
VAR
      ok      : boolean;
      loopCnt : integer;
      userId  : tgg00_Surrogate;
      b_err   : tgg00_BasisError;
      sysk    : tgg00_SysInfoKey;
      sysp    : tak_sysbufferaddress;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'dbproc level',  acv.a_dbproc_level + acv.a_trigger_level);
t01surrogate (ak_sem, 'curr user   ', acv.a_curr_user_id);
t01surrogate (ak_sem, 'proc user   ', acv.a_proc_userid);
&endif
IF  Sequence.seq_owner = acv.a_curr_user_id
THEN
    BEGIN
    priv.priv_all_set       := [r_sel, r_owner];
    priv.priv_all_grant_set := [r_sel];
    END
ELSE
    IF  Sequence.seq_public
    THEN
        priv.priv_all_set := [r_sel]
    ELSE
        BEGIN
        (* PTS 1113579 E.Z. *)
        a06userid_get (acv, Sequence.seq_owner, ok);
        userId  := acv.a_curr_user_id;
        loopCnt := 0;
        REPEAT
            loopCnt := loopCnt + 1;
            ok      := true;
            IF  ok
            THEN
                BEGIN
                sysk            := a01defaultkey;
                sysk.sauthid    := Sequence.seq_surrogate;
                sysk.suserid    := userId;
                sysk.sentrytyp  := cak_esequencepriv;
                sysk.skeylen    := mxak_standard_sysk + SURROGATE_MXGG00;
                a10get_sysinfo (acv, sysk, d_release,
                      sysp, b_err);
                IF  b_err = e_ok
                THEN
                    BEGIN
                    priv.priv_all_set := [r_sel];
                    IF  sysp^.sprocseqpriv.psp_grantOption
                    THEN
                        priv.priv_all_grant_set := [r_sel];
                    (*ENDIF*) 
                    END
                ELSE
                    IF  b_err <> e_sysinfo_not_found
                    THEN
                        a07_b_put_error (acv, b_err, 1)
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (acv.a_dbproc_level + acv.a_trigger_level > 0) AND
                ( priv.priv_all_set = [])                      AND
                (acv.a_proc_userid <> acv.a_curr_user_id)
            THEN
                IF  Sequence.seq_owner = acv.a_proc_userid
                THEN
                    BEGIN
                    priv.priv_all_set := [r_sel];
                    loopCnt           := loopCnt + 1;
                    END
                ELSE
                    userId := acv.a_proc_userid
                (*ENDIF*) 
            ELSE
                loopCnt := loopCnt + 1;
            (*ENDIF*) 
        UNTIL
            (loopCnt >= 2);
        (*ENDREPEAT*) 
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06get_priv  (
            VAR acv       : tak_all_command_glob;
            VAR brec      : tak_sysbufferaddress;
            required_priv : tak00_PrivilegeSet;
            check_roles   : boolean;
            VAR priv      : tak_privilege);
 
CONST
      c_exit_loop = csp_maxint2;
 
VAR
      sys_table_priv  : boolean;
      is_view         : boolean;
      control_priv    : boolean;
      ok              : boolean;
      b_err           : tgg00_BasisError;
      ix              : integer;
      jx              : integer;
      sys_priv        : tak00_PrivilegeSet;
      sysp            : tak_sysbufferaddress;
      sysdba          : tgg00_Surrogate;
      catalogSchemaId : tgg00_Surrogate;
      sysdba_name     : tsp00_KnlIdentifier;
      schema          : tsp00_KnlIdentifier;
      sysk            : tgg00_SysInfoKey;
 
BEGIN
priv := a01emptypriv;
IF  acv.a_returncode = 0
THEN
    IF  brec^.syskey.sentrytyp = cak_esequence
    THEN
        ak06GetSequencePriv (acv, brec^.ssequence, priv)
    ELSE
        WITH acv, brec^, sbase, syskey DO
            BEGIN
            a103CatalogSchemaId (catalogSchemaId);
            sys_table_priv := false;
            is_view        := btablekind in [tonebase, tview, tcomplexview];
            control_priv   := (a_current_user_kind = ucontroluser) AND
                  (r_owner in required_priv);
            sysdba      := g01glob.sysuser_id;
            sysdba_name := g01glob.sysuser_name;
            IF  (bschema = sysdba) AND (btablen^ = a01_i_queryrewriterules)
            THEN
                BEGIN
                IF  (acv.a_initial_segment_header.sp1c_producer = sp1pr_installation) OR
                    acv.a_in_ddl_trigger
                THEN
                    priv.priv_all_set :=
                          [r_sel, r_del, r_upd, r_ins, r_owner]
                ELSE
                    priv.priv_all_set :=
                          [r_sel, r_upd, r_owner];
                (*ENDIF*) 
                priv.priv_all_grant_set := priv.priv_all_set - [r_owner];
                END
            ELSE
                IF  (NOT g01unicode AND
                    (btablen^[1] = 'S')            AND
                    (btablen^[2] = 'Y')            AND
                    (btablen^[3] = 'S'))
                    OR
                    (g01unicode       AND
                    (btablen^[1] = csp_unicode_mark) AND
                    (btablen^[2] = 'S')              AND
                    (btablen^[3] = csp_unicode_mark) AND
                    (btablen^[4] = 'Y')              AND
                    (btablen^[5] = csp_unicode_mark) AND
                    (btablen^[6] = 'S'))
                THEN
                    BEGIN
                    sys_table_priv := (a_returncode = 0) AND
                          ((btablen^ = a01_i_sysparseid ) OR
                          (* PTS 1115978 E.Z. *)
                          ( btablen^ = a01_i_sysmonitor ) OR
                          ( btablen^ = a01_i_sysmondata ) OR
                          ( btablen^ = a01_i_syscmd_analyze  ) OR
                          ( btablen^ = a01_i_sysdata_analyze ) OR
                          ( btablen^ = a01_i_sysupdstatwanted)) AND
                          (acv.a_command_kind <> internal_create_tab_command);
                    IF  sys_table_priv AND NOT a_in_ddl_trigger (* PTS 1111578 *)
                    THEN
                        IF  (a_initial_segment_header.sp1c_producer = sp1pr_installation) AND
                            (sysdba = a_curr_user_id)
                        THEN
                            BEGIN
                            priv.priv_all_set :=
                                  [r_sel, r_del, r_upd, r_index, r_owner];
                            priv.priv_all_grant_set := [r_sel, r_del]
                            END
                        ELSE
                            IF  ((btablen^ = a01_i_sysmonitor) OR
                                (btablen^ = a01_i_sysmondata))
                                AND
                                NOT a01diag_monitor_on
                                AND
                                (bschema = sysdba)
                            THEN
                                BEGIN
                                priv.priv_all_set       := [r_sel, r_del, r_owner];
                                priv.priv_all_grant_set := [r_sel, r_del]
                                END
                            ELSE
                                IF  (btablen^ = a01_i_sysupdstatwanted)
                                    AND (a_current_user_kind in [udba, usysdba])
                                THEN
                                    BEGIN
                                    IF  a_initial_segment_header.sp1c_producer
                                        = sp1pr_installation
                                    THEN
                                        priv.priv_all_set := [r_sel, r_ins, r_del, r_owner]
                                    ELSE
                                        priv.priv_all_set := [r_sel, r_ins, r_del];
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    BEGIN
                                    priv.priv_all_set := [r_sel, r_del];
                                    priv.priv_all_grant_set := [r_sel, r_del]
                                    END
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    ELSE
                        IF  (btablen^ = a01_i_syschecktablelog) AND
                            (bschema <> a_curr_user_id        ) AND
                            (a_current_user_kind in [udba, usysdba, ucontroluser])
                        THEN (* allow access to all DBAs *)
                            priv.priv_all_set := [r_sel, r_del];
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
&               IFDEF TRACE
                (*ENDIF*) 
            (*ENDIF*) 
            t01lidentifier (ak_sem, btablen^);
&           ENDIF
            IF  ((a_curr_user_id = bauthid) OR
                ( control_priv            ) OR
                ( a_in_ddl_trigger        ))
                AND
                NOT is_view
                AND
                (bschema <> cak_temp_user_id)
            THEN
                BEGIN
                (* current user is owner of this table or the current *)
                (* command is within a store procedure                *)
                IF  (btablen^ = a01_i_dual ) AND
                    (bauthid = sysdba)       AND
                    (bschema = sysdba)       AND
                    NOT a_in_ddl_trigger
                THEN
                    BEGIN
                    IF  a_initial_segment_header.sp1c_producer = sp1pr_installation
                    THEN
                        BEGIN
                        priv.priv_all_set       := [ r_sel, r_ins, r_owner ];
                        priv.priv_all_grant_set := [ r_sel ]
                        END
                    ELSE
                        priv.priv_all_set := [ r_sel ]
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  priv.priv_all_set = [  ]
                THEN
                    BEGIN
                    CASE btablekind OF
                        tdb2view :
                            BEGIN
                            priv.priv_all_set := [ r_ins, r_del, r_upd,
                                  r_sel, r_owner ];
                            priv.priv_all_grant_set := [ r_ins, r_del,
                                  r_upd, r_sel ]
                            END;
                        tcatalog_table :
                            BEGIN
                            priv.priv_all_set       := [r_sel, r_owner];
                            priv.priv_all_grant_set := [r_sel, r_owner]
                            END;
                        OTHERWISE
                            BEGIN
                            priv.priv_all_set := [r_ins, r_del, r_upd,
                                  r_sel, r_owner, r_alter, r_index, r_link];
                            priv.priv_all_grant_set := [r_ins, r_del,
                                  r_upd, r_sel, r_alter, r_index, r_link];
                            ix := bfirstindex;
                            WHILE ix <= blastindex DO
                                IF  ctserial in a103GetColumn (brec^.sbase, ix)^.ccolpropset
                                THEN
                                    BEGIN
                                    priv.priv_all_set := priv.priv_all_set -
                                          [r_upd];
                                    priv.priv_all_grant_set :=
                                          priv.priv_all_grant_set - [r_upd];
                                    priv.priv_col_exist :=
                                          [priv_col_upd, priv_col_upd_grant];
                                    FOR jx := bfirstindex TO blastindex DO
                                        IF  ix <> jx
                                        THEN
                                            priv.priv_upd_set :=
                                                  priv.priv_upd_set +
                                                  [a103GetColumn (brec^.sbase, jx)^.cextcolno];
                                        (*ENDIF*) 
                                    (*ENDFOR*) 
                                    priv.priv_grant_upd_set := priv.priv_upd_set;
                                    ix := c_exit_loop
                                    END
                                ELSE
                                    ix := ix + 1;
                                (*ENDIF*) 
                            (*ENDWHILE*) 
                            END;
                        END;
                    (*ENDCASE*) 
                    IF  (a_initial_segment_header.sp1c_producer <> sp1pr_installation) AND
                        (a362OnlineTaskId = UNDEF_SP00)                                AND
                        (bschema = catalogSchemaId)
                    THEN
                        priv.priv_all_set := priv.priv_all_set - [r_owner];
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                IF  btablekind = tcatalog_table
                THEN
                    BEGIN
                    priv.priv_all_set       := [ r_sel ];
                    priv.priv_all_grant_set := [ r_sel ]
                    END
                ELSE
                    IF  bschema = cak_temp_user_id
                    THEN
                        priv.priv_all_set := [r_ins, r_del, r_upd, r_sel]
                    ELSE
                        BEGIN
                        IF  (a_sqlmode = sqlm_oracle)
                            AND
                            ((NOT g01unicode  AND
                            (btablen^[1] = 'D')              AND
                            (btablen^[2] = 'B')              AND
                            (btablen^[3] = 'A')              AND
                            (btablen^[4] = '_'))                OR
                            (g01unicode       AND
                            (btablen^[1] = csp_unicode_mark) AND
                            (btablen^[2] = 'D')              AND
                            (btablen^[3] = csp_unicode_mark) AND
                            (btablen^[4] = 'B')              AND
                            (btablen^[5] = csp_unicode_mark) AND
                            (btablen^[6] = 'A')              AND
                            (btablen^[7] = csp_unicode_mark) AND
                            (btablen^[8] = '_')))
                            AND
                            is_view
                            AND
                            (a_current_user_kind in [udba, usysdba, ucontroluser])
                        THEN
                            BEGIN
                            a103GetSchemaName (acv, bschema, schema);
                            IF  schema = a01_i_sys
                            THEN
                                IF  bauthid = a_curr_user_id
                                THEN
                                    BEGIN
                                    (* PTS 1105367 E.Z. *)
                                    priv.priv_all_set       := [r_sel, r_owner];
                                    priv.priv_all_grant_set := [r_sel]
                                    END
                                ELSE
                                    priv.priv_all_set := [r_sel]
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  (a_initial_segment_header.sp1c_producer = sp1pr_installation)          AND
                            ((a_curr_user_name  = a01_i_domain) OR (a_curr_user_name = a01_i_sys)) AND
                            (bschema <> a_curr_user_id)                                            AND
                            (priv.priv_all_set = [])
                        THEN
                            BEGIN
                            priv.priv_all_set       := [r_sel];
                            priv.priv_all_grant_set := [r_sel]
                            END
                        ELSE
                            IF  (acv.a_initial_segment_header.sp1c_producer = sp1pr_internal_cmd)
                                OR
                                (acv.a_cmd_segment_header.sp1c_producer = sp1pr_complex_view_handling)
                            THEN
                                BEGIN
                                IF  bschema = catalogSchemaId
                                THEN
                                    priv.priv_all_set := [r_sel];
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        IF  priv.priv_all_set = []
                        THEN
                            BEGIN
                            IF  sys_table_priv AND
                                (acv.a_current_user_kind = udba)
                            THEN
                                priv.priv_all_set := sys_priv
                            ELSE
                                ak06get_public_priv (acv,
                                      brec^.sbase, required_priv, priv);
                            (*ENDIF*) 
                            IF  bauthid = a_curr_user_id
                            THEN
                                priv.priv_all_set :=
                                      priv.priv_all_set + [ r_owner ];
                            (*ENDIF*) 
                            IF  required_priv - priv.priv_all_set <> []
                            THEN
                                BEGIN
                                sysk := syskey;
                                WITH sysk DO
                                    BEGIN
                                    sentrytyp := cak_epriv;
                                    IF  (a_in_ddl_trigger    ) OR
                                        (control_priv        )
                                    THEN
                                        (* privileges of the owner if called  *)
                                        (* in the course of a system stored   *)
                                        (* proc or i current user is control  *)
                                        (* user                               *)
                                        suserid := bauthid
                                    ELSE
                                        suserid := a_curr_user_id;
                                    (*ENDIF*) 
                                    skeylen   := mxak_standard_sysk +
                                          SURROGATE_MXGG00
                                    END;
                                (*ENDWITH*) 
                                a10get_sysinfo (acv,
                                      sysk, d_release, sysp, b_err);
                                IF  b_err = e_ok
                                THEN
                                    a06unpack_priv(sysp^.spriv.pr_priv,
                                          priv)
                                ELSE
                                    IF  b_err <> e_sysinfo_not_found
                                    THEN
                                        a07_b_put_error (acv, b_err, 1);
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                IF  (a_dbproc_level + a_trigger_level > 0) AND
                                    (a_returncode = 0)                     AND
                                    (required_priv-priv.priv_all_set <> [])
                                THEN
                                    ak06proc_privileges (acv,
                                          brec, priv)
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            (* PTS 1111576 E.Z. *)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  ((acv.a_role_info <> role_none) OR (acv.a_role_ptr <> NIL)) AND
    (required_priv - priv.priv_all_set <> [])                   AND
    check_roles                                                 AND
    (acv.a_is_ddl = no_ddl)                                     AND
    (acv.a_returncode = 0)
THEN
    ak06role_privileges (acv, brec, required_priv, priv);
&IFDEF TRACE
(*ENDIF*) 
a99priv (ak_sem, priv, 'return a06get_priv', true);
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06move_file_content (
            VAR acv    : tak_all_command_glob;
            VAR old_id : tgg00_FileId;
            VAR new_id : tgg00_FileId;
            VAR b_err  : tgg00_BasisError);
 
VAR
      mblock  : tgg00_MessBlock;
      qual    : tgg00_QualBuf;
 
BEGIN
WITH acv DO
    BEGIN
    new_id.fileResultSite_gg00 := old_id.fileResultSite_gg00;
    g01mblock_init (acv.a_transinf.tri_trans, m_move, mm_nil, mblock);
    mblock.mb_qual        := @qual;
    mblock.mb_qual_size   := sizeof (qual);
    mblock.mb_qual^.mtree := old_id;
    SAPDB_PascalForcedMove (
          sizeof (new_id), mblock.mb_qual_size,
          @new_id, 1, @mblock.mb_qual^.buf,
          sizeof (tgg00_FileId) + 1, sizeof (new_id));
    mblock.mb_qual_len := 2 * FILE_ID_MXGG00;
    a06rsend_mess_buf (acv, mblock, true, b_err);
    new_id.fileRoot_gg00 := NIL_PAGE_NO_GG00
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06_systable_get (
            VAR acv      : tak_all_command_glob;
            dstate       : tak_directory_state;
            VAR tableid  : tgg00_Surrogate;
            VAR base_ptr : tak_sysbufferaddress;
            get_all      : boolean;
            VAR ok       : boolean);
 
VAR
      b_err     : tgg00_BasisError;
      ix        : integer;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
ok := false;
IF  acv.a_returncode = 0
THEN
    BEGIN
    sysk            := a01defaultkey;
    sysk.stableid   := tableid;
    IF  sysk.ssite = cak_show_table_site
    THEN
        a41get_table (acv, sysk.sshowkind, base_ptr, b_err)
    ELSE
        BEGIN
        IF  sysk.ssite = cak_temp_table_site
        THEN (* temp table *)
            sysk.sentrytyp := cak_eresult;
        (*ENDIF*) 
        a10get_sysinfo (acv, sysk, dstate, base_ptr, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            WITH base_ptr^, sbase DO
                BEGIN
                IF  btablekind = tsynonym
                THEN
                    acv.a_error_tableid := ssynonym.syn_tableid
                ELSE
                    BEGIN
                    IF  (btreeid.fileLeafNodes_gg00 = cak_is_undefined)
                        AND
                        (acv.a_command_kind <> show_command)
                    THEN
                        BEGIN
                        (* record may have been cached   *)
                        (* by a catalog select, i.e      *)
                        (* root and treeleafnodes        *)
                        (* have not been determined      *)
                        a10_key_del (acv, sysk);
                        a10get_sysinfo (acv, sysk, dstate, base_ptr, b_err);
                        END;
                    (*ENDIF*) 
                    acv.a_error_tableid := syskey.stableid;
                    END;
                (*ENDIF*) 
                END
            (*ENDWITH*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        BEGIN
        IF  (b_err = e_sysinfo_not_found) AND
            (acv.a_init_ex_kind = only_executing)
        THEN
            b_err := e_old_fileversion;
        (*ENDIF*) 
        IF  b_err <> e_sysinfo_not_found
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        ok := true;
&       ifdef trace
        IF  base_ptr^.sbase.btablekind <> tsynonym
        THEN
            WITH base_ptr^.sbase DO
                BEGIN
                t01int4 (ak_sem, 'bfirstindex ', bfirstindex);
                FOR ix := bfirstindex TO blastindex DO
                    a061td_colinfo (a103GetColumn (base_ptr^.sbase, ix)^, ix);
                (*ENDFOR*) 
                END;
            (*ENDWITH*) 
&       endif
        (* PTS 1116801 E.Z. *)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06get_public_priv  (
            VAR acv       : tak_all_command_glob;
            VAR brec      : tak_baserecord;
            required_priv : tak00_PrivilegeSet;
            VAR priv      : tak_privilege);
 
VAR
      b_err : tgg00_BasisError;
      privp : tak_sysbufferaddress;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
priv.priv_all_set := brec.bpriv_all_set;
IF  ((acv.a_is_ddl <> no_ddl)              OR
    (acv.a_command_kind = show_command   ) OR (* PTS 1117409 *)
    (priv_col_sel in brec.bpriv_col_exist) OR
    (priv_col_upd in brec.bpriv_col_exist))
    AND
    (required_priv - priv.priv_all_set <> [])
THEN
    BEGIN
    sysk            := a01defaultkey;
    sysk.sauthid    := brec.bsurrogate;
    sysk.sentrytyp  := cak_epriv;
    sysk.suserid    := cak_public_id;
    sysk.skeylen    := sysk.skeylen + SURROGATE_MXGG00;
    a10get_sysinfo (acv, sysk, d_release, privp, b_err);
    IF  b_err = e_ok
    THEN
        a06unpack_priv (privp^.spriv.pr_priv, priv)
    ELSE
        IF  b_err <> e_sysinfo_not_found
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak06table_exists (
            VAR acv      : tak_all_command_glob;
            dstate       : tak_directory_state;
            public_syn   : boolean;
            VAR schema   : tsp00_KnlIdentifier;
            VAR tablen   : tsp00_KnlIdentifier;
            VAR sparr    : tak_syspointerarr;
            ignore_down  : boolean;
            get_all      : boolean) : boolean;
 
VAR
      temp_table     : boolean;
      ok             : boolean;
      b_err          : tgg00_BasisError;
      tabrefbuf      : tak_sysbufferaddress;
      synbuf         : tak_sysbufferaddress;
      sysk           : tgg00_SysInfoKey;
      auth_id        : tgg00_Surrogate;
      tableid        : tgg00_Surrogate;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'public_syn  ', ord (public_syn));
&endif
temp_table := schema = a01_i_temp ;
IF  temp_table
THEN
    auth_id := cak_temp_user_id
ELSE
    IF  public_syn
    THEN
        auth_id := cak_public_id
    ELSE
        a103GetSchemaId (acv, schema,  0, auth_id);
    (*ENDIF*) 
(*ENDIF*) 
tabrefbuf := NIL;
IF  auth_id = cgg_zero_id
THEN
    ak06table_exists := false
ELSE
    BEGIN
    ok := false;
    WITH sysk DO
        BEGIN
        sauthid := auth_id;
        IF  temp_table
        THEN
            sentrytyp := cak_etemptableref
        ELSE
            sentrytyp := cak_etableref;
        (*ENDIF*) 
        slinkage    := cak_init_linkage;
        sidentifier := tablen;
        skeylen     := mxak_standard_sysk + sizeof (tablen)
        END;
    (*ENDWITH*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        IF  ((acv.a_is_ddl = ddl_create_view)     AND
            (sysk.sauthid  = acv.a_viewSchemaId)  AND
            (tablen        = acv.a_viewname))
        THEN
            (* current table is view to be created *)
            (* or result table                     *)
            b_err := e_sysinfo_not_found
        ELSE
            a10get_sysinfo (acv,
                  sysk, d_release, tabrefbuf, b_err);
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            WITH tabrefbuf^.stableref DO
                BEGIN
                sparr.psystable := rsystable AND
                      (acv.a_session_sqlmode <> sqlm_oracle);
                IF  rtablekind = tsynonym
                THEN
                    BEGIN
                    IF  ((tabrefbuf^.syskey.sauthid <>
                        acv.a_curr_user_id) AND
                        (tabrefbuf^.syskey.sauthid <>
                        cak_public_id))
                    THEN
                        b_err := e_sysinfo_not_found
                    ELSE
                        BEGIN
                        sparr.psynid    := rsynid;
                        sysk            := a01defaultkey;
                        sysk.stableid   := rsynid;
                        a10get_sysinfo (acv, sysk, d_release,
                              synbuf, b_err);
                        IF  b_err = e_ok
                        THEN
                            BEGIN
                            IF  a23is_sequence_synonym (synbuf^.ssynonym)
                            THEN
                                b_err := e_sysinfo_not_found
                            (*ENDIF*) 
                            END
                        ELSE
                            a07_b_put_error (acv, b_err, 1);
                        (*ENDIF*) 
                        sparr.psynfound := true
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            tableid := tabrefbuf^.stableref.rtableid;
            a06_systable_get (acv, dstate, tableid,
                  sparr.pbasep, get_all, ok);
            IF  NOT ok
            THEN
                BEGIN (* PTS 1125106 *)
                IF  tabrefbuf^.stableref.rtablekind <> tempty
                THEN
                    BEGIN
                    (* tableref record identifies a table, but the table could not be found ==> *)
                    (* tableref record may be outdated                                          *)
                    a10_key_del  (acv, tabrefbuf^.syskey);
                    a07_b_put_error (acv, e_old_fileversion, 1)
                    END
                (*ENDIF*) 
                END
            ELSE
                WITH sparr.pbasep^.sbase DO
                    IF  btreeid.fileHandling_gg00 = [ hsWithoutLock_egg00 ]
                    THEN (* system table *)
                        IF  kb560IsCatalogTable (btreeid.fileTabId_gg00)
                            AND
                            (acv.a_initial_segment_header.sp1c_producer <> sp1pr_installation)
                            AND
                            ((acv.a_comp_type <> at_util) OR
                            ( acv.a_is_ddl    <> no_ddl))
                            AND
                            ((acv.a_comp_type <> at_load) OR
                            (acv.a_initial_segment_header.sp1c_producer <> sp1pr_internal_cmd))
                        THEN
                            ok := false
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            ok := false;
            IF  b_err <> e_sysinfo_not_found
            THEN
                BEGIN
                a07_b_put_error (acv, b_err, 1);
                IF  ignore_down
                THEN
                    a40ignore_down_error (acv)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    ak06table_exists := ok
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a06_table_exist (
            VAR acv      : tak_all_command_glob;
            dstate       : tak_directory_state;
            VAR schema   : tsp00_KnlIdentifier;
            VAR tablen   : tsp00_KnlIdentifier;
            VAR sparr    : tak_syspointerarr;
            get_all      : boolean) : boolean;
 
CONST
      c_ignore_down = true;
      c_public_syn  = true;
 
VAR
      ok         : boolean;
      user_spec  : boolean;
      schemaName : tsp00_KnlIdentifier;
 
BEGIN
ok                 := false;
sparr.psynfound    := false;
sparr.psystable    := false;
sparr.pcount       := 0;
&IFDEF TRACE
t01lidentifier (ak_sem, schema);
t01lidentifier (ak_sem, tablen);
&ENDIF
user_spec := schema <> a01_il_b_identifier;
IF  user_spec
THEN
    BEGIN
    IF  schema = a01_i_sysdd
    THEN
        BEGIN
        a41table_exist (acv, tablen, sparr, ok);
        sparr.psystable := true
        END;
    (*ENDIF*) 
    END
ELSE
    schema := acv.a_curr_schema;
(*ENDIF*) 
IF  NOT ok AND (schema <> a01_i_sysdd)
THEN
    ok := ak06table_exists (acv, dstate, (schema = a01_i_public), schema,
          tablen, sparr, NOT user_spec, get_all);
(*ENDIF*) 
IF  NOT ok AND NOT user_spec
THEN
    BEGIN
    (* no user has been specified, check if *)
    (* public synonym exists                *)
    ok  := ak06table_exists (acv,
          dstate, c_public_syn, schema, tablen,
          sparr, c_ignore_down, get_all);
    END;
(*ENDIF*) 
IF  NOT ok AND NOT user_spec AND NOT acv.a_curr_schema_set
THEN
    BEGIN
    (* no user has been specified, check if *)
    (* table of current dba exists          *)
    IF  acv.a_acc_dbaname <> a01_il_b_identifier
    THEN
        BEGIN
        schema := acv.a_acc_dbaname;
        ok     := ak06table_exists (acv,
              dstate, NOT c_public_syn, schema, tablen,
              sparr, c_ignore_down, get_all);
        END;
    (*ENDIF*) 
    IF  NOT ok
    THEN
        BEGIN
        (* table not found yet, check if table of sysdba *)
        (* exists                                        *)
        (* PTS 1111577 E.Z. *)
        (* PTS 1111797 E.Z. *)
        schema := g01glob.sysuser_name;
        ok     := ak06table_exists (acv, dstate,
              NOT c_public_syn, g01glob.sysuser_name, tablen,
              sparr, c_ignore_down, get_all);
        END;
    (*ENDIF*) 
    IF  NOT ok
    THEN
        BEGIN
        (* table not found yet, check if table of public *)
        (* exists                                        *)
        schema := a01_i_public ;
        ok     := ak06table_exists (acv,
              dstate, NOT c_public_syn, schema, tablen,
              sparr, c_ignore_down, get_all);
        END;
    (* PTS 1104106 E.Z. *)
    (*
          IF  (NOT ok) AND (acv.a_sqlmode = sqlm_oracle)
          THEN      ( * the data dictionary views in oracle * )
          BEGIN ( * can be accessed without username    * )
          schema   := a01_i_sys ;
          ok       := ak06table_exists (acv,
          dstate, NOT c_public_syn, schema, tablen,
          sparr, c_ignore_down, get_all)
          END;
          *)
    (*ENDIF*) 
    IF  (NOT ok) AND
        ((acv.a_sqlmode = sqlm_internal) OR
        g01glob.db_is_for_sapr3)
    THEN
        BEGIN
        (* table not found yet, check if table of *)
        (* user DOMAIN exists                     *)
        schema := a01_i_domain ;
        ok     := ak06table_exists (acv,
              dstate, NOT c_public_syn, schema, tablen,
              sparr, c_ignore_down, get_all)
        END;
    (*ENDIF*) 
    END;
(* PTS 1104180 E.Z. *)
(*ENDIF*) 
IF  ok
    AND
    NOT (acv.a_current_user_kind in
    [ udba, usysdba, ucontroluser ])
THEN (* No access for normal users on some SYS tables. *)
    BEGIN
    a103GetSchemaName (acv, sparr.pbasep^.sbase.bschema, schemaName);
    IF  schemaName = a01_i_sys
    THEN
        ok := ak06orasys_access_ok (tablen);
    (*ENDIF*) 
    END;
(*ENDIF*) 
a06_table_exist := ok
END;
 
(*------------------------------*) 
 
FUNCTION
      ak06orasys_access_ok (VAR tablen : tsp00_KnlIdentifier) : boolean;
 
VAR
      access_ok : boolean;
      i  : integer;
 
BEGIN
access_ok := true;
(* PTS 1105101 E.Z. *)
IF  (NOT g01unicode  AND
    (tablen[1] = 'D')              AND
    (tablen[2] = 'B')              AND
    (tablen[3] = 'A')              AND
    (tablen[4] = '_'))
    OR
    (g01unicode      AND
    (tablen[1] = csp_unicode_mark) AND
    (tablen[2] = 'D')              AND
    (tablen[3] = csp_unicode_mark) AND
    (tablen[4] = 'B')              AND
    (tablen[5] = csp_unicode_mark) AND
    (tablen[6] = 'A')              AND
    (tablen[7] = csp_unicode_mark) AND
    (tablen[8] = '_'))
THEN (* Access to SYS.DBA_* denied. *)
    access_ok := false
ELSE
    BEGIN
    i := 1;
    WHILE access_ok AND (i <= sizeof (tablen)) DO
        IF  tablen[ i ] = '$'
        THEN (* Access to SYS.*$ denied. *)
            access_ok := false
        ELSE
            i := succ (i)
        (*ENDIF*) 
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
ak06orasys_access_ok := access_ok
END;
 
(* end of PTS 1104180 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a06check_username (
            VAR acv    : tak_all_command_glob;
            VAR auth   : tsp00_KnlIdentifier;
            VAR is_dba : boolean;
            VAR ok     : boolean);
 
VAR
      sysp  : tak_sysbufferaddress;
 
BEGIN
is_dba := false;
ok     := false;
WITH acv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ok     := true;
        IF  auth = a_curr_user_name
        THEN
            is_dba := (a_current_user_kind = udba) OR
                  (a_current_user_kind = usysdba)
        ELSE
            IF  auth = a01_i_temp
            THEN
                is_dba := false
            ELSE
                BEGIN
                IF  a06exist_user (acv, auth, d_release, sysp)
                THEN
                    is_dba := sysp^.suser.userkind = udba
                ELSE
                    ok := false
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
&   IFDEF TRACE
    (*ENDIF*) 
(*ENDWITH*) 
t01lidentifier (ak_sem, auth);
t01int4  (ak_sem,'is_dba      ', ord(is_dba));
&ENDIF
END;
 
(*------------------------------*) 
 
FUNCTION
      a06uid (VAR user_id : tgg00_Surrogate) : tsp00_Int4;
 
VAR
      ix   : integer;
      expo : integer;
      uid  : tsp00_Int4;
 
BEGIN
uid  := 0;
expo := 1;
FOR ix := SURROGATE_MXGG00 DOWNTO SURROGATE_MXGG00 - mxsp_c4 + 1 DO
    BEGIN
    uid  := (ord(user_id [ix]) * expo) + uid;
    expo := expo * 256
    END;
(*ENDFOR*) 
a06uid := uid
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06userid_get (
            VAR acv    : tak_all_command_glob;
            VAR userid : tgg00_Surrogate;
            VAR ok     : boolean);
 
VAR
      b_err : tgg00_BasisError;
      sysp  : tak_sysbufferaddress;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ok     := true;
        IF  userid <> a_curr_user_id
        THEN
            BEGIN
            sysk           := a01defaultkey;
            sysk.sauthid   := userid;
            sysk.sentrytyp := cak_euser;
            a10get_sysinfo (acv, sysk, d_release, sysp, b_err);
            IF  b_err <> e_ok
            THEN
                BEGIN
                ok := false;
                IF  b_err <> e_sysinfo_not_found
                THEN
                    a07_b_put_error (acv, b_err, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    (* PTS 1113579 E.Z. *)
    ELSE
        ok := false;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06_view_get_basetable (
            VAR acv      : tak_all_command_glob;
            VAR view_id  : tgg00_Surrogate;
            tabno        : integer;
            VAR base_id  : tgg00_Surrogate);
 
VAR
      syskey : tgg00_SysInfoKey;
      sysbuf : tak_sysbufferaddress;
      b_err  : tgg00_BasisError;
 
BEGIN
WITH acv, syskey DO
    IF  a_returncode = 0
    THEN
        BEGIN
        syskey     := a01defaultkey;
        stableid   := view_id;
        sentrytyp  := cak_eviewqual_basis;
        a10get_sysinfo (acv, syskey, d_release, sysbuf, b_err);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        ELSE
            WITH sysbuf^.sviewqual_basis.vtable[ tabno ] DO
                base_id  := vttableid;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06destroy_temp (
            VAR acv     : tak_all_command_glob;
            VAR temp_id : tgg00_FileId;
            VAR b_err   : tgg00_BasisError);
 
VAR
      m    : tgg00_MessBlock;
      qual : tgg00_QualBuf;
 
BEGIN
g01mblock_init (acv.a_transinf.tri_trans, m_destroy_temp, mm_nil, m);
g01qual_init (m, @qual, sizeof (qual));
m.mb_qual_len    := sizeof (temp_id);
m.mb_qual^.mtree := temp_id;
a06rsend_mess_buf (acv, m, NOT cak_return_req, b_err)
END;
 
(* PTS 1128197 D.T. *)
(*------------------------------*) 
 
PROCEDURE
      a06get_username_from_buffer (
            VAR acv        : tak_all_command_glob;
            VAR tree_index : integer;
            VAR SourceBuffer: tsp00_MoveObj;
            BufferLength   : tsp00_Int4;
            VAR username   : tsp00_KnlIdentifier);
 
BEGIN
WITH acv DO
    BEGIN
    WITH a_ap_tree^[ tree_index ] DO
        IF  n_symb = s_authid
        THEN
            BEGIN
            a05_identifier_get_from_buffer(acv, SourceBuffer, BufferLength,
                  n_pos, n_length, (ni_complex_string_id in n_special),
                  sizeof (username), username);
            IF  (username = a01_i_sysdba) AND NOT (ni_complex_string_id in n_special)
            THEN  (* PTS 1128197 D.T. *)
                username := g01glob.sysuser_name
            ELSE
                IF  (username = a01_i_user) AND NOT (ni_complex_string_id in n_special)
                THEN  (* PTS 1128197 D.T. *)
                    username := a_acc_user
                ELSE
                    IF  (username = a01_i_usergroup) AND NOT (ni_complex_string_id in n_special)
                    THEN
                        username := a_connected_name
                    ELSE
                        IF  (username = a01_i_current_schema) AND NOT (ni_complex_string_id in n_special)
                        THEN
                            username := a_curr_schema;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            tree_index := n_sa_level
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06get_username (
            VAR acv        : tak_all_command_glob;
            VAR tree_index : integer;
            VAR username   : tsp00_KnlIdentifier);
 
BEGIN
a06get_username_from_buffer(acv, tree_index,
      acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_size,
      username);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06determine_username (
            VAR acv       : tak_all_command_glob;
            VAR userid    : tgg00_Surrogate;
            VAR user_name : tsp00_KnlIdentifier);
 
VAR
      b_err : tgg00_BasisError;
      sysp  : tak_sysbufferaddress;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
&IFDEF TRACE
t01surrogate (ak_sem, 'user_id     ', userid);
t01surrogate (ak_sem, 'curr_user_id', acv.a_curr_user_id);
&ENDIF
IF  userid = acv.a_curr_user_id
THEN
    user_name := acv.a_curr_user_name
ELSE
    IF  userid = cak_public_id
    THEN
        user_name := a01_i_public
    ELSE
        IF  userid = cak_temp_user_id
        THEN
            user_name := a01_i_temp
        ELSE
            IF  userid = cak_util_user_id
            THEN
                user_name := a01controluser
            ELSE
                IF  userid = cak_sys_user_id
                THEN
                    user_name := a01_i_sysdd
                ELSE
                    BEGIN
                    sysk           := a01defaultkey;
                    sysk.sauthid   := userid;
                    sysk.sentrytyp := cak_euser;
                    a10get_sysinfo (acv, sysk,
                          d_release, sysp, b_err);
                    IF  b_err = e_ok
                    THEN
                        user_name := sysp^.suser.username
                    ELSE
                        user_name := a01_il_b_identifier
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
&IFDEF TRACE
t01lidentifier (ak_sem, user_name);
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06det_user_id (
            VAR acv      : tak_all_command_glob;
            VAR authname : tsp00_KnlIdentifier;
            VAR authid   : tgg00_Surrogate);
 
VAR
      b_err     : tgg00_BasisError;
      sysp      : tak_sysbufferaddress;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
&IFDEF TRACE
t01lidentifier (ak_sem, authname);
&ENDIF
WITH acv DO
    BEGIN
    authid := cgg_zero_id;
    IF  authname = a_curr_user_name
    THEN
        authid := a_curr_user_id
    ELSE
        IF  authname = a01_i_sysdd
        THEN (* PTS 1131169 *)
            authid := cak_sys_user_id
        ELSE
            BEGIN
            a51build_userkey (authname, sysk);
            a10get_sysinfo (acv, sysk, d_release, sysp, b_err);
            IF  b_err = e_ok
            THEN
                authid := sysp^.suserref.ru_user_id
            ELSE
                IF  b_err <> e_sysinfo_not_found
                THEN
                    a07_b_put_error (acv, b_err, 1);
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&IFDEF TRACE
t01surrogate (ak_sem, 'user_id     ', authid)
&     ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06dml_send_mess_buf (
            VAR acv    : tak_all_command_glob;
            VAR mblock : tgg00_MessBlock;
            VAR dmli   : tak_dml_info;
            VAR b_err  : tgg00_BasisError);
 
BEGIN
b_err       := e_ok;
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  mblock.mb_type = m_show
    THEN
        BEGIN
        a41execute_show (acv, mblock);
        a06drop_fieldlist_references (mblock.mb_fieldlists);
        END
    ELSE
        a06lsend_mess_buf (acv,
              mblock, NOT cak_call_from_rsend, b_err);
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        IF  mblock.mb_type  = m_return_result
        THEN
            CASE mblock.mb_type2 OF
                mm_key :
                    acv.a_temp_tablekey :=
                          mblock.mb_data^.mbp_info.rb_tempkey;
                OTHERWISE;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a06is_table_empty (
            VAR acv          : tak_all_command_glob;
            VAR file_id      : tgg00_FileId) : BOOLEAN;
 
CONST
      c_count_records = true;
      c_do_sample     = true;
 
VAR
      _min_page_cnt : tsp00_Int4;
      _page_count   : tsp00_Int4;
      _startkey     : tgg00_Lkey;
      _stopkey      : tgg00_Lkey;
      _record_cnt   : tsp00_Int4;
      _b_err        : tgg00_BasisError;
 
BEGIN
a06is_table_empty := false;
_startkey.len     := 0;
_stopkey.len      := 0;
_b_err            := e_ok;
a06eval_page_count (acv, file_id, _startkey, _stopkey, c_do_sample,
      c_count_records, _page_count, _min_page_cnt, _record_cnt,
      _b_err);
IF  (_b_err <> e_ok)
THEN
    a07_b_put_error (acv, _b_err, 1)
ELSE
    a06is_table_empty := (_record_cnt = 0);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06get_page_cnt (
            VAR acv          : tak_all_command_glob;
            VAR file_id      : tgg00_FileId;
            do_sample        : boolean;
            VAR page_count   : tsp00_Int4;
            VAR b_err        : tgg00_BasisError);
 
CONST
      c_count_records = true;
 
VAR
      min_page_cnt : tsp00_Int4;
      startkey     : tgg00_Lkey;
      stopkey      : tgg00_Lkey;
      record_cnt   : tsp00_Int4;
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'do_sample   ', ord(do_sample));
&endif
startkey.len := 0;
stopkey.len  := 0;
page_count   := csp_maxint4;
a06eval_page_count (acv, file_id, startkey, stopkey, do_sample,
      NOT c_count_records, page_count, min_page_cnt, record_cnt,
      b_err);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06eval_page_count (
            VAR acv          : tak_all_command_glob;
            VAR file_id      : tgg00_FileId;
            VAR startkey     : tgg00_Lkey;
            VAR stopkey      : tgg00_Lkey;
            do_sample        : boolean;
            count_records    : boolean;
            VAR page_count   : tsp00_Int4;
            VAR min_page_cnt : tsp00_Int4;
            VAR record_cnt   : tsp00_Int4;
            VAR b_err        : tgg00_BasisError);
 
VAR
      l_result : tsp00_LcompResult;
 
BEGIN
IF  stopkey.len > 0
THEN
    s30cmp  (startkey.k, 1, startkey.len,
          stopkey.k, 1, stopkey.len, l_result)
ELSE
    BEGIN
    l_result    := l_equal;
    stopkey.k   := b01fullkey;
    IF  (ftsPerm_egg00       in file_id.fileType_gg00) OR
        (ftsConcurrent_egg00 in file_id.fileType_gg00) OR
        (ftsShared_egg00     in file_id.fileType_gg00)
    THEN
        stopkey.len := PERM_KEY_MXSP00
    ELSE
        stopkey.len := KEY_MXSP00
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  l_result = l_greater
THEN
    BEGIN
    page_count   := 1;
    min_page_cnt := 1;
    IF  count_records
    THEN
        record_cnt := 0
    ELSE
        record_cnt := -1;
    (*ENDIF*) 
    b_err        := e_ok
    END
ELSE
    BEGIN
    IF  g04inv_tfn (file_id.fileTfn_gg00)
    THEN
        b03calculate_page_count  (acv.a_transinf.tri_trans, file_id,
              startkey, stopkey, count_records, page_count,
              min_page_cnt, record_cnt)
    ELSE
        IF  do_sample
        THEN
            b02eval_page_count (acv.a_transinf.tri_trans, file_id,
                  startkey, stopkey, count_records, page_count,
                  min_page_cnt, record_cnt)
        ELSE
            b02calculate_page_count (acv.a_transinf.tri_trans,
                  file_id, startkey, stopkey, page_count);
        (*ENDIF*) 
    (*ENDIF*) 
    b_err := acv.a_transinf.tri_trans.trError_gg00;
    END;
(*ENDIF*) 
&IFDEF TRACE
t01int4 (ak_sem, 'page_count  ', page_count);
t01int4 (ak_sem, 'min page cnt', min_page_cnt);
t01int4 (ak_sem, 'record cnt  ', record_cnt)
&     ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06GetBaseTreeid (
            VAR acv     : tak_all_command_glob;
            VAR baseRec : tak_baserecord;
            VAR tree    : tgg00_FileId);
 
VAR
      e     : tgg00_BasisError;
      pBase : tak_sysbufferaddress;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
IF  (baseRec.btablekind in [twithkey, twithoutkey])
    OR
    (baseRec.bshowkind <> sh_no_kind)
THEN
    tree := baseRec.btreeid
ELSE
    IF  baseRec.btablekind = tonebase
    THEN
        BEGIN
        sysk          := a01defaultkey;
        sysk.stableid := baseRec.btreeid.fileTabId_gg00;
        a10get_sysinfo (acv, sysk, d_release, pBase, e);
        IF  e <> e_ok
        THEN
            a07_b_put_error (acv, e, 1)
        ELSE
            tree := pBase^.sbase.btreeid
        (*ENDIF*) 
        END
    ELSE
        tree := b01niltree_id
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06rsend_mess_buf (
            VAR acv     : tak_all_command_glob;
            VAR mblock  : tgg00_MessBlock;
            return_req  : boolean;
            VAR b_err   : tgg00_BasisError);
 
VAR
      vtrace_back : boolean;
      aux_m_type  : tgg00_MessType;
      aux_m2_type : tgg00_MessType2;
      local_error : tgg00_BasisError;
      i           : integer;
 
BEGIN
WITH acv DO
    BEGIN
&   IFDEF TRACE
    WITH mblock DO
        IF  (mb_data <> NIL) AND
            NOT ((mb_type = m_column) AND ((mb_type2 = mm_write) OR
            (mb_type2 = mm_new_write)))
        THEN
            SAPDB_PascalForcedFill (mb_data_size, @mb_data^.mbp_buf,
                  mb_data_len + 1, mb_data_size - mb_data_len , chr(0));
&       ENDIF
        (*ENDIF*) 
    (*ENDWITH*) 
    b_err := e_ok;
    IF  (mblock.mb_type2 = mm_qual)
    THEN
        BEGIN
        IF  (mblock.mb_type = m_update) OR
            (mblock.mb_type = m_delete)
        THEN
            mblock.mb_qual^.mtree.fileHandling_gg00 :=
                  mblock.mb_qual^.mtree.fileHandling_gg00 +
                  [ hsIntentExcl_egg00 ];
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  mblock.mb_struct = mbs_stack_addr
    THEN
        mblock.mb_qual^.msqlmode := a_sqlmode;
&   IFDEF TRACE
    (*ENDIF*) 
    t01messblock (ak_sem, 'a06rsend    ', mblock);
&   ENDIF
    vtrace_back := false;
    IF  g01vtrace.vtrAny_gg00
    THEN
        ak06vtrace (acv, mblock, vtrace_back);
    (*ENDIF*) 
    aux_m_type  := mblock.mb_type;
    aux_m2_type := mblock.mb_type2;
    (* database is in stand alone state *)
    (* PTS 1116837 E.Z. *)
    IF  (mblock.mb_qual <> NIL)
        AND
        ((mblock.mb_type = m_insert)        OR
        ( mblock.mb_type = m_insert_select) OR
        ( mblock.mb_type = m_update)        OR
        ( mblock.mb_type = m_delete))
    THEN
        IF  (mblock.mb_qual^.mtrigger_cnt > 0) AND
            (mblock.mb_qual^.mtree.fileName_gg00 <> b01niltree_id.fileName_gg00)
        THEN
            ak06trigger (acv, mblock);
        (*ENDIF*) 
    (*ENDIF*) 
    local_error  := e_ok;
    a06lsend_mess_buf (acv, mblock, cak_call_from_rsend, local_error);
    IF  local_error <> e_ok
    THEN
        IF  (b_err <> e_work_rolled_back) AND
            (b_err <> e_rollb_log_full)
        THEN
            b_err := local_error
        ELSE
            a_rollback_info := a_rollback_info + [ new_trans ];
        (*ENDIF*) 
    (* PTS 1107952 E.Z. *)
    (*ENDIF*) 
    IF  g01vtrace.vtrAny_gg00
    THEN
        IF  vtrace_back
        THEN
            ak06vtrace (acv, mblock, vtrace_back);
        (*ENDIF*) 
    (*ENDIF*) 
    a_transinf.tri_trans.trError_gg00 := b_err
    END;
(*ENDWITH*) 
&IFDEF TRACE
t01basis_error (ak_sem, 'rsend return', b_err);
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06inc_linkage (VAR linkage : tsp00_C2);
 
BEGIN
IF  linkage[ 2 ] = chr(255)
THEN
    BEGIN
    linkage[ 1 ] := chr(ord(linkage[ 1 ])+1);
    linkage[ 2 ] := chr(1)
    END
ELSE
    linkage[ 2 ] := chr(ord(linkage[ 2 ])+1);
(*ENDIF*) 
&IFDEF TRACE
t01int4 (ak_sem, 'linkage 1   ', ord(linkage[ 1 ]));
t01int4 (ak_sem, 'linkage 2   ', ord(linkage[ 2 ]));
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06InvalidateMessBlock (
            VAR acv     : tak_all_command_glob);
 
BEGIN
acv.a_mblock.mb_type := m_invalid;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06pred_linkage (VAR linkage : tsp00_C2);
 
BEGIN
IF  linkage[ 2 ] = chr(1)
THEN
    BEGIN
    linkage[ 1 ] := chr( ord( linkage[ 1 ] ) - 1 );
    linkage[ 2 ] := chr( 255 );
    END
ELSE
    linkage[ 2 ] := chr( ord( linkage[ 2 ] ) - 1 );
(*ENDIF*) 
&IFDEF TRACE
t01int4 (ak_sem, 'linkage 1   ', ord(linkage[ 1 ]));
t01int4 (ak_sem, 'linkage 2   ', ord(linkage[ 2 ]));
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06retpart_move (
            VAR acv     : tak_all_command_glob;
            moveobj_ptr : tsp00_MoveObjPtr;
            move_len    : tsp00_Int4);
 
BEGIN
WITH acv DO
    IF  NOT a_retpart_locked AND (move_len >= 0)
    THEN
        BEGIN
        (*============================================
              check for command_segment IN = OUT *)
        ak06destroy_input_ptr (acv);
        (*=============================================*)
        IF  a_curr_retpart = NIL
        THEN
            a06init_curr_retpart (acv);
        (*ENDIF*) 
        IF  a_curr_retpart <> NIL
        THEN
            WITH a_curr_retpart^ DO
                IF  sp1p_buf_size >= sp1p_buf_len + move_len
                THEN
                    BEGIN
                    SAPDB_PascalOverlappingMove ('VAK06 ',   3,    
                          sizeof (moveobj_ptr^), sp1p_buf_size,
                          moveobj_ptr, 1, @sp1p_buf, sp1p_buf_len+1,
                          move_len, acv.a_returncode);
                    sp1p_buf_len := sp1p_buf_len + move_len
                    END
                ELSE
                    a07_b_put_error (acv, e_too_small_packet_size, 1)
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06lsend_mess_buf (
            VAR acv         : tak_all_command_glob;
            VAR mblock      : tgg00_MessBlock;
            call_from_rsend : boolean;
            VAR b_err       : tgg00_BasisError);
 
CONST
      c_kb_stack_usage = 63000;
      msg_size_lt_len  = 'SIZE LESS THAN LEN      ';
 
VAR
      return_vtrace     : boolean;
      call_kb           : boolean;
      aux_m_type        : tgg00_MessType;
      aux_m2_type       : tgg00_MessType2;
      i                 : integer;
      stack_free        : tsp00_Int4;
      trace             : tgg11_KbTrace;
      grantedMode       : tgg00_LockReqMode; (* PTS 1118666 M.Ki. *)
      rec_key           : tgg00_Lkey;        (* PTS 1118666 M.Ki. *)
      gg_strategy_ptr   : ^tgg07_StrategyInfo;
 
BEGIN
WITH acv DO
    BEGIN
    aux_m_type  := mblock.mb_type;
    aux_m2_type := mblock.mb_type2;
&   IFDEF TRACE
    IF  NOT call_from_rsend
    THEN
        t01messblock (ak_sem, 'a06lsend    ', mblock);
&   ENDIF
    (*ENDIF*) 
    return_vtrace := false;
    IF  NOT call_from_rsend
    THEN
        BEGIN
        IF  g01vtrace.vtrAny_gg00
        THEN
            ak06vtrace (acv, mblock, return_vtrace);
        (*ENDIF*) 
        IF  (mblock.mb_type2 = mm_qual)
        THEN
            BEGIN
            IF  (mblock.mb_type = m_update) OR
                (mblock.mb_type = m_delete)
            THEN
                mblock.mb_qual^.mtree.fileHandling_gg00 :=
                      mblock.mb_qual^.mtree.fileHandling_gg00 +
                      [ hsIntentExcl_egg00 ];
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        mblock.mb_trns^.trWarning_gg00 := a_transinf.tri_trans.trWarning_gg00;
        IF  mblock.mb_struct = mbs_stack_addr
        THEN
            mblock.mb_qual^.msqlmode := a_sqlmode;
        (*ENDIF*) 
        END;
&   IFDEF TRACE
    (*ENDIF*) 
    t01int4 (ak_sem, 'maxuserstack', g01maxuserstack);
&   ENDIF
    (* PTS 1116837 E.Z. *)
    IF  (mblock.mb_qual <> NIL)
        AND
        (NOT call_from_rsend)
        AND
        ((mblock.mb_type = m_insert)        OR
        ( mblock.mb_type = m_insert_select) OR
        ( mblock.mb_type = m_update)        OR
        ( mblock.mb_type = m_delete))
    THEN
        IF  (mblock.mb_qual^.mtrigger_cnt > 0) AND
            (mblock.mb_qual^.mtree.fileName_gg00 <> b01niltree_id.fileName_gg00)
        THEN
            ak06trigger (acv, mblock);
        (*ENDIF*) 
    (*ENDIF*) 
    call_kb := true;
    (* PTS 1118666 M.Ki. *)
    b_err := e_ok;
    IF  ((acv.a_iso_level = 2) OR (acv.a_iso_level = 20)) AND
        (mblock.mb_type = m_select)                       AND
        NOT (bd998IsTempFile (mblock.mb_trns^, mblock.mb_qual^.mtree))
    THEN
        BEGIN
        acv.a_transinf.tri_trans.trError_gg00 := e_ok;
        IF  a71GetKeyFromKeystrat (mblock, rec_key, b_err)
        THEN      (* complete primary key was specified     *)
            BEGIN (* do not lock whole table, just lock row *)
&           IFDEF TRACE
            t01int4 (ak_sem, 'is_keystrat ', 1);
&           ENDIF
            mblock.mb_qual^.mtree.fileHandling_gg00 :=
                  mblock.mb_qual^.mtree.fileHandling_gg00 - [ hsTempLock_egg00 ];
            k53row_lock_by_key (acv.a_transinf.tri_trans,
                  mblock.mb_qual^.mtree,
                  rec_key.keyVal_gg00, rec_key.keyLen_gg00,
                  mblock.mb_type, 1, grantedMode);
            b_err := acv.a_transinf.tri_trans.trError_gg00;
            IF  b_err = e_wait_for_lock_release
            THEN
                REPEAT
                    IF  (g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00)
                    THEN
                        BEGIN
                        trace.kbMessType_gg11  := aux_m_type;
                        trace.kbMessType2_gg11 := aux_m2_type;
                        trace.kbError_gg11     := b_err;
                        b120InsertTrace (acv.a_transinf.tri_trans,
                              kb, vttKbLockWait_egg00,
                              sizeof (trace), @trace)
                        END;
                    (*ENDIF*) 
                    k53wait (acv.a_transinf.tri_trans, aux_m_type, aux_m2_type);      (* PTS 1106270 JA 2000-04-06 *)
                    b_err := acv.a_transinf.tri_trans.trError_gg00;                   (* PTS 1106270 JA 2000-04-06 *)
                    IF  (g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00)
                    THEN
                        BEGIN
                        trace.kbError_gg11 := b_err;
                        b120InsertTrace (acv.a_transinf.tri_trans,
                              kb, vttKbLockWaitResume_egg00,
                              sizeof (trace), @trace);
                        END;
                    (*ENDIF*) 
                    IF  b_err = e_ok
                    THEN
                        BEGIN
                        k53row_lock_by_key (acv.a_transinf.tri_trans,
                              mblock.mb_qual^.mtree,
                              rec_key.keyVal_gg00, rec_key.keyLen_gg00,
                              mblock.mb_type, 1, grantedMode);
                        b_err := acv.a_transinf.tri_trans.trError_gg00;
                        END;
&                   IFDEF TRACE
                    (*ENDIF*) 
                    t01basis_error (kb_dist, 'b_err select', b_err);
&                   ENDIF
                UNTIL
                    b_err <> e_wait_for_lock_release;
                (*ENDREPEAT*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (b_err <> e_ok)
    THEN
        call_kb := false;
    (*ENDIF*) 
    mblock.mb_trns^.trState_gg00 := a_transinf.tri_trans.trState_gg00;
    IF  a_dbproc_level + a_trigger_level > 0
    THEN
        BEGIN
        (* call from a dbproc or trigger, check stack usage *)
        (* to avoid kernel crashing                         *)
        vsleft(stack_free);
&       ifdef trace
        t01int4 (ak_sem, 'stack_free  ', stack_free);
&       endif
        IF  (stack_free < c_kb_stack_usage)
            AND
            NOT a_in_ddl_trigger
        THEN
            BEGIN
            (* stack usage too high to call kb layer,   *)
            (* try to call a server to process kb order *)
            call_kb := false;
            b_err   := e_program_stack_overflow;
            END
        (*ENDIF*) 
        END;
    (* PTS 1120382 *)
    (*ENDIF*) 
    IF  (mblock.mb_struct = mbs_stack_addr)                      AND
        (mblock.mb_qual <> NIL)                                  AND
        a101_IsExtendedTempFile (acv, mblock.mb_qual^.mtree)     AND
        (a101_GetExtendedTempFileType (acv, mblock.mb_qual^.mtree)
        = ttfnTempTable_egg00)
    THEN
        mblock.mb_qual^.mtree.fileRoot_gg00 := NIL_PAGE_NO_GG00;
    (*ENDIF*) 
    IF  call_kb
    THEN
        BEGIN
        mblock.mb_work_st      := a_work_st_addr;
        mblock.mb_work_st_max  := a_work_st_max;
        mblock.mb_workbuf      := a_work_buf_addr;
        mblock.mb_workbuf_size := a_work_buf_size;
        mblock.mb_trns         := @a_transinf.tri_trans;
&       IFDEF TRACE
        IF  (mblock.mb_data_size  < mblock.mb_data_len) OR
            (mblock.mb_qual_size  < mblock.mb_qual_len) OR
            (mblock.mb_strat_size < mblock.mb_strat_len)
        THEN
            g01abort (csp3_a07_system_error, csp3_n_size_check,
                  msg_size_lt_len, 0);
&       ENDIF
        (*ENDIF*) 
        k05functions (mblock);
&       IFDEF TRACE
        t01messblock (ak_sem, 'a06lsend ret', mblock);
        IF  (mblock.mb_data_size  < mblock.mb_data_len) OR
            (mblock.mb_qual_size  < mblock.mb_qual_len) OR
            (mblock.mb_strat_size < mblock.mb_strat_len)
        THEN
            g01abort (csp3_a07_system_error, csp3_n_size_check,
                  msg_size_lt_len, 0);
&       ENDIF
        (*ENDIF*) 
        b_err := mblock.mb_trns^.trError_gg00;
        WHILE b_err = e_wait_for_lock_release DO
            BEGIN
            IF  (g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00)
            THEN
                BEGIN
                trace.kbMessType_gg11  := aux_m_type;
                trace.kbMessType2_gg11 := aux_m2_type;
                trace.kbError_gg11     := b_err;
                b120InsertTrace (mblock.mb_trns^, kb, vttKbLockWait_egg00, sizeof (trace), @trace)
                END;
            (*ENDIF*) 
            k53wait (mblock.mb_trns^, aux_m_type, aux_m2_type);      (* PTS 1106270 JA 2000-04-06 *)
            b_err := mblock.mb_trns^.trError_gg00;                   (* PTS 1106270 JA 2000-04-06 *)
            IF  (g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00)
            THEN
                BEGIN
                trace.kbError_gg11 := b_err;
                b120InsertTrace (mblock.mb_trns^, kb, vttKbLockWaitResume_egg00, sizeof (trace), @trace)
                END;
            (*ENDIF*) 
            IF  b_err = e_ok                                         (* PTS 1106270 JA 2000-04-06 *)
            THEN
                BEGIN
                mblock.mb_type         := aux_m_type;
                mblock.mb_type2        := aux_m2_type;
                mblock.mb_trns^.trError_gg00 := e_ok;
                mblock.mb_trns         := @a_transinf.tri_trans;
                k05functions (mblock);
                b_err := mblock.mb_trns^.trError_gg00
                END
            (*ENDIF*) 
            END
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    IF  mblock.mb_type2 = mm_trigger
    THEN
        ak06trigger_result (acv, mblock);
    (*ENDIF*) 
    IF  NOT call_from_rsend
    THEN
        BEGIN
        IF  g01vtrace.vtrAny_gg00 AND return_vtrace
        THEN
            ak06vtrace (acv, mblock, return_vtrace)
        (*ENDIF*) 
        END;
    (* PTS 1107952 E.Z. *)
    (* PTS 1118423 E.Z. *)
    (*ENDIF*) 
    IF  (aux_m_type = m_insert_select)
        AND
        (mblock.mb_type  = m_return_result)
    THEN
        a05return_serial (acv, mblock.mb_qual^.mr_first_serial,
              mblock.mb_qual^.mr_last_serial);
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        IF  b_err = e_rollback_wanted
        THEN
            BEGIN
            a_rollback_info        := [ trans_rollback, new_trans ];
            mblock.mb_trns^.trError_gg00 := e_work_rolled_back;
            b_err                  := e_work_rolled_back
            END
        ELSE
            IF  (b_err = e_file_not_found) AND (aux_m_type = m_column)
            THEN
                b_err := e_lob_not_found;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    FOR i := 0 TO cgg_idx_max_valuefieldlist DO
        IF  (mblock.mb_fieldlists[i] <> NIL)
        THEN
            BEGIN
&           ifdef TRACE
            t01addr (ak_sem, 'dr_fieldlist', mblock.mb_fieldlists[i]);
&           endif
            ak104_DropReference_MS( mblock.mb_fieldlists[i]);
            mblock.mb_fieldlists[i] := NIL
            END
        (*ENDIF*) 
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06public_priv  (
            VAR acv  : tak_all_command_glob;
            VAR brec : tak_baserecord;
            VAR priv : tak_privilege);
 
VAR
      b_err : tgg00_BasisError;
      privp : tak_sysbufferaddress;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
priv := a01emptypriv;
sysk            := a01defaultkey;
sysk.sauthid    := brec.bsurrogate;
sysk.sentrytyp  := cak_epriv;
sysk.suserid    := cak_public_id;
sysk.skeylen    := sysk.skeylen + sizeof (sysk.suserid);
a10get_sysinfo (acv, sysk, d_release, privp, b_err);
IF  b_err = e_ok
THEN
    a06unpack_priv (privp^.spriv.pr_priv, priv)
ELSE
    IF  b_err <> e_sysinfo_not_found
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06put_errtext (
            VAR acv       : tak_all_command_glob;
            b_err_in      : tgg00_BasisError;
            err_type      : tgg04_ErrorText;
            errtext_len   : integer;
            VAR errtext   : tsp00_C256;
            VAR b_err_out : tgg00_BasisError);
 
BEGIN
b06put_errtxt (acv.a_transinf.tri_trans,
      acv.a_transinf.tri_trans.trTaskId_gg00, errtext_len,
      err_type, b_err_in, errtext, b_err_out);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06remove_locked_state (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv, a_transinf.tri_trans DO
    BEGIN
    trState_gg00 :=
          trState_gg00 - [ tsLocked_egg00, tsSubUpdated_egg00, tsUpdated_egg00 ];
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06reset_retpart (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv DO
    IF  NOT a_retpart_locked
    THEN
        BEGIN
        IF  a_return_segm <> NIL
        THEN
            BEGIN
            a_return_segm^.sp1s_segm_len    := sizeof (tsp1_segment_header);
            a_return_segm^.sp1s_no_of_parts := 0;
            END;
        (*ENDIF*) 
        a_curr_retpart                  := NIL
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06reset_currpart (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv DO
    IF  (NOT a_retpart_locked) AND
        (a_return_segm <> NIL) AND
        (a_curr_retpart <> NIL)
    THEN
        s26reset_part (a_return_segm^, a_curr_retpart);
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06set_mtree (
            VAR acv    : tak_all_command_glob;
            VAR mblock : tgg00_MessBlock;
            VAR tree   : tgg00_FileId);
 
BEGIN
IF  mblock.mb_qual <> NIL
THEN
    WITH mblock.mb_qual^ DO
        BEGIN
        mtree := tree;
&       IFDEF TRACE
        t01handling (ak_sem, 'handling_set', mtree.fileHandling_gg00);
&       ENDIF
        CASE mblock.mb_type OF
            m_column:
                BEGIN
                IF  ((tree.fileHandling_gg00 <> [hsWithoutLock_egg00, hsNoLog_egg00]) AND
                    ( tree.fileHandling_gg00 <> [hsWithoutLock_egg00]))
                THEN
                    mtree.fileHandling_gg00 := acv.a_transinf.tri_global_state;
                (*ENDIF*) 
                END;
            m_create_table :
                IF  NOT a101_IsExtendedTempFile (acv, tree)
                THEN
                    mtree.fileHandling_gg00 := [  ];
                (*ENDIF*) 
            m_begin, m_create_index,
            m_drop,  m_end,                    m_outcopy,
            m_partial_rollback,      m_reload, m_save,
            m_unload :
                mtree.fileHandling_gg00 := [  ];
            (* PTS 1107952 E.Z. *)
            m_succ_file_version :
                BEGIN
                mtree.fileLeafNodes_gg00 := cgg_nil_leafnodes;
                mtree.fileHandling_gg00  := [  ]
                END;
            m_table_statistic :
                BEGIN
                mtree.fileLeafNodes_gg00 := cgg_nil_leafnodes;
                mtree.fileHandling_gg00  := [ hsWithoutLock_egg00 ]
                END;
            m_insert, m_update, m_delete :
                IF  NOT a101_IsExtendedTempFile (acv, tree)
                THEN
                    BEGIN
                    mtree.fileHandling_gg00 := acv.a_transinf.tri_global_state;
                    (* PTS 1118661 M.Ki. *)
                    IF  ((acv.a_iso_level = 2) OR (acv.a_iso_level = 20))
                    THEN
                        mtree.fileHandling_gg00 := mtree.fileHandling_gg00 -
                              [ hsTempLock_egg00 ];
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            OTHERWISE
                BEGIN
                IF  ((tree.fileHandling_gg00 <> [hsWithoutLock_egg00, hsNoLog_egg00]) AND
                    ( tree.fileHandling_gg00 <> [hsWithoutLock_egg00]))
                THEN
                    mtree.fileHandling_gg00 := acv.a_transinf.tri_global_state;
                (*ENDIF*) 
                END;
            END;
        (*ENDCASE*) 
&       IFDEF TRACE
        t01handling (ak_sem, 'handling_set', mtree.fileHandling_gg00);
&       ENDIF
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(* PTS 1111576 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a06subquery_del_result (
            VAR acv           : tak_all_command_glob;
            VAR dmli          : tak_dml_info;
            VAR subquery_tree : tgg00_FileId;
            prefix_len        : integer);
 
VAR
      b_err         : tgg00_BasisError;
 
BEGIN
WITH acv, dmli DO
    BEGIN
&   IFDEF TRACE
    t01int4 (ak_sem, 'return_code ', a_returncode);
&   ENDIF
    CASE prefix_len OF
        TEMP_PREFIX_MXGG00 + 1:
            g01abort (csp3_a07_system_error, csp3_n_size_check,
                  'INVALID PREFIX LENGTH   ', 0);
        TEMP_PREFIX_MXGG00 + 2:
            a101_DestroyGroupedTempFiles (a_transinf.tri_trans,
                  a101_GetExtendedTempFileType (acv, subquery_tree),
                  -1,
                  -1,
                  subquery_tree.fileName_gg00);
        TEMP_PREFIX_MXGG00 + 3:
            a101_DestroyGroupedTempFiles (a_transinf.tri_trans,
                  a101_GetExtendedTempFileType (acv, subquery_tree),
                  a101_GetTempFileLevel (acv, subquery_tree),
                  -1,
                  subquery_tree.fileName_gg00);
        END;
    (*ENDCASE*) 
    b_err := a_transinf.tri_trans.trError_gg00
    END;
(*ENDWITH*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06systable_state (
            VAR acv           : tak_all_command_glob;
            tablename         : tsp00_KnlIdentifier;
            VAR tree          : tgg00_FileId);
      (* tablename may not be VAR because this procedure *)
      (* is called by VAK07/51 using constant filenames  *)
 
VAR
      p_arr      : tak_syspointerarr;
 
BEGIN
tree.fileRoot_gg00 := NIL_PAGE_NO_GG00;
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  a06_table_exist (acv,
        d_release, g01glob.sysuser_name, tablename, p_arr, false)
    THEN
        WITH acv.a_transinf.tri_trans DO
            BEGIN
            tree := p_arr.pbasep^.sbase.btreeid;
            b01filestate (acv.a_transinf.tri_trans, tree);
            IF  (trError_gg00 <> e_file_read_only) AND (trError_gg00 <> e_ok)
            THEN
                a07_b_put_error (acv, trError_gg00, 1)
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
&IFDEF TRACE
(*------------------------------*) 
 
PROCEDURE
      a06td_priv (
            p        : tak_privilege;
            id       : tsp00_C18;
            unpacked : boolean);
 
BEGIN
a99priv (ak_sem, p, id, unpacked);
END;
 
&ENDIF
(*------------------------------*) 
 
PROCEDURE
      a06tempfile_empty (
            VAR acv     : tak_all_command_glob;
            VAR temp_id : tgg00_FileId;
            VAR b_err   : tgg00_BasisError);
 
VAR
      m    : tgg00_MessBlock;
      qual : tgg00_QualBuf;
 
BEGIN
g01mblock_init (acv.a_transinf.tri_trans,
      m_destroy_temp, mm_empty, m);
m.mb_qual        := @qual;
m.mb_qual_size   := sizeof (qual);
m.mb_qual_len    := sizeof (qual);
m.mb_qual^.mtree := temp_id;
a06rsend_mess_buf (acv, m, NOT cak_return_req, b_err)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv DO
    IF  NOT a_retpart_locked
    THEN
        BEGIN
        (*============================================
              check for command_segment IN = OUT *)
        ak06destroy_input_ptr (acv);
        (*=============================================*)
        IF  s26size_new_part (a_out_packet, a_return_segm^) > 0
        THEN
            s26new_part_init (a_out_packet,
                  a_return_segm^, a_curr_retpart);
        (*ENDIF*) 
        IF  a_curr_retpart = NIL
        THEN
            a07_b_put_error (acv, e_too_small_packet_size, 1)
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak06destroy_input_ptr (VAR acv : tak_all_command_glob);
 
VAR
      part_ptr : tsp1_part_ptr;
 
BEGIN
WITH acv DO
    BEGIN
    (*============================================
          check for command_segment IN = OUT *)
    (* D.T. : QueryRewrite *)
    IF  (a_cmd_segm <> NIL)
    THEN
        BEGIN
        IF  ( a_cmd_segm^.sp1c_producer = sp1pr_queryrewrite )
        THEN
            a542pop_packet(acv);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (a_cmd_segm <> NIL) AND (a_data_ptr <> NIL)
    THEN
        BEGIN
        s26find_part (a_cmd_segm^, sp1pk_data, part_ptr);
        IF  part_ptr <> NIL
        THEN
            IF  @(part_ptr^) = a_data_ptr
            THEN
                a_data_ptr := NIL;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_in_packet <> NIL
    THEN
        BEGIN
        a_in_packet := NIL;
        END;
    (*ENDIF*) 
    a_cmd_segm := NIL;
    a_cmd_part := NIL;
    a_data_part := NIL;
    a_abap_part := NIL;
    a_rescount_part := NIL;
    a_resname_part := NIL;
    (* a_uni_cmd_part := NIL; do NOT do this ! *)
    (*=============================================*)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06finish_curr_retpart (
            VAR acv   : tak_all_command_glob;
            part_kind : tsp1_part_kind;
            arg_count : tsp00_Int2);
 
BEGIN
(* We should have an open retpart here; but we can't be shure,    *)
(* since due to a malicious application and exhausted space while *)
(* allocating a new part a buf_limit error could be set instead.  *)
IF  (NOT acv.a_retpart_locked) AND
    (acv.a_curr_retpart <> NIL)
THEN
    WITH acv, a_curr_retpart^ DO
        BEGIN
        (* We have to fill the part header, modify the      *)
        (* segment header and update the information in acv *)
        IF  (part_kind = sp1pk_shortinfo) AND acv.a_variable_input
        THEN
            sp1p_part_kind := sp1pk_vardata_shortinfo
        ELSE
            sp1p_part_kind := part_kind;
        (*ENDIF*) 
        sp1p_arg_count := arg_count;
        s26finish_part (a_out_packet, a_curr_retpart^);
        (* Signal in acv, that the next return_part is still to open. *)
        a_curr_retpart := NIL;
        (*============================================
              check for command_segment IN = OUT *)
        ak06destroy_input_ptr (acv);
        (*=============================================*)
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06unpack_priv (
            VAR packed_priv   : tak_privilege;
            VAR unpacked_priv : tak_privilege);
 
VAR
      i : tak_priv_descriptors;
      j : tak_priv_descriptors;
 
BEGIN
unpacked_priv.priv_all_set := unpacked_priv.priv_all_set +
      packed_priv.priv_all_set;
unpacked_priv.priv_all_grant_set :=
      unpacked_priv.priv_all_grant_set + packed_priv.priv_all_grant_set;
j := priv_col_sel;
FOR i := priv_col_sel TO priv_col_ref_grant DO
    BEGIN
    IF  i in packed_priv.priv_col_exist
    THEN
        BEGIN
        unpacked_priv.priv_col[ i ] :=
              unpacked_priv.priv_col[ i ] + packed_priv.priv_col[ j ];
        unpacked_priv.priv_col_exist :=
              unpacked_priv.priv_col_exist + [ i ];
        IF  j < priv_col_ref_grant
        THEN
            j := succ(j)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06user_get_priv  (
            VAR acv  : tak_all_command_glob;
            VAR brec : tak_sysbufferaddress;
            VAR user : tgg00_Surrogate;
            VAR priv : tak_privilege);
 
VAR
      curr_user : tgg00_Surrogate;
 
BEGIN
&ifdef trace
t01surrogate (ak_sem, 'user        ', user);
t01surrogate (ak_sem, 'bauthid     ', brec^.sbase.bauthid);
&endif
curr_user          := acv.a_curr_user_id;
acv.a_curr_user_id := user;
a06_get_priv (acv, brec, priv);
acv.a_curr_user_id := curr_user
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06drop_fieldlist_references (VAR fieldlists : tgg00_FieldLists);
 
VAR
      i : integer;
 
BEGIN
FOR i := 0 TO cgg_idx_max_valuefieldlist DO
    IF  (fieldlists[i] <> NIL)
    THEN
        BEGIN
&       ifdef TRACE
        t01addr (ak_sem, 'dr_fieldlist', fieldlists[i]);
&       endif
        ak104_DropReference_MS(fieldlists[i]);
        fieldlists[i] := NIL
        END;
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06drop_pars_fieldlist_refs (VAR fieldlists : tgg00_FieldLists);
 
VAR
      i : integer;
 
BEGIN
IF  fieldlists[cgg_idx_literal_valuefieldlist] <> NIL
THEN
    BEGIN
    ak104_DropReference_MS(fieldlists[cgg_idx_literal_valuefieldlist]);
    fieldlists[cgg_idx_literal_valuefieldlist] := NIL
    END;
(*ENDIF*) 
IF  fieldlists[cgg_idx_pars_result_valuefieldlist] <> NIL
THEN
    BEGIN
    ak104_DropReference_MS(fieldlists[cgg_idx_pars_result_valuefieldlist]);
    fieldlists[cgg_idx_pars_result_valuefieldlist] := NIL
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a06drop_ex_fieldlist_refs (VAR fieldlists : tgg00_FieldLists);
 
VAR
      i : integer;
 
BEGIN
IF  fieldlists[cgg_idx_param_valuefieldlist] <> NIL
THEN
    BEGIN
    ak104_DropReference_MS(fieldlists[cgg_idx_param_valuefieldlist]);
    fieldlists[cgg_idx_param_valuefieldlist] := NIL
    END;
(*ENDIF*) 
IF  fieldlists[cgg_idx_ex_result_valuefieldlist] <> NIL
THEN
    BEGIN
    ak104_DropReference_MS(fieldlists[cgg_idx_ex_result_valuefieldlist]);
    fieldlists[cgg_idx_ex_result_valuefieldlist] := NIL
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
