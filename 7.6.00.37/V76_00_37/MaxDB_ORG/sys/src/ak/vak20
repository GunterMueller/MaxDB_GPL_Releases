.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-22
*****************************************************
modname : VAK20
changed : 2000-11-22
module  : AK_DDL_Syntax
 
Author  : ThomasA
Created : 1985-10-16
*****************************************************
 
Purpose : Computes the syntax tree for all DDl commands.
 
Define  :
 
        PROCEDURE
              a20aalter_statement (
                    VAR acv          : tak_all_command_glob;
                    VAR put_node     : tsp00_Int2;
                    symbindex        : integer);
 
        PROCEDURE
              a20acomment_statement (
                    VAR acv           : tak_all_command_glob;
                    VAR put_node      : tsp00_Int2);
 
        PROCEDURE
              a20adiagnose_alter (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a20adiagnose_drop_file_statement(VAR acv : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a20acreate_statement (
                    VAR acv           : tak_all_command_glob;
                    VAR put_node      : tsp00_Int2;
                    symbindex         : integer;
                    res_kw            : boolean);
 
        PROCEDURE
              a20adata_type (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2;
                    isDBFunction  : boolean;
                    keyw          : integer);
 
        PROCEDURE
              a20adrop_statement (
                    VAR acv         : tak_all_command_glob;
                    VAR put_node    : tsp00_Int2;
                    symbindex       : integer);
 
        PROCEDURE
              a20agrant_revoke_statement (
                    VAR acv         : tak_all_command_glob;
                    VAR put_node    : tsp00_Int2;
                    kw_index        : integer);
 
        PROCEDURE
              a20atable_drop (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a20_aexist_table (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2);
 
        PROCEDURE
              a20_arename_statement (
                    VAR acv            : tak_all_command_glob;
                    VAR put_node       : tsp00_Int2);
 
        PROCEDURE
              a20_asave_restore (
                    VAR acv               : tak_all_command_glob;
                    keyword_index         : integer;
                    VAR put_node          : tsp00_Int2);
 
        PROCEDURE
              a20_abegin_end_load_stmt (
                    VAR acv               : tak_all_command_glob;
                    VAR put_node          : tsp00_Int2;
                    kw_index              : integer);
 
        PROCEDURE
              a20check_table_stmt (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a20create_table_stmt (VAR acv : tak_all_command_glob;
                    inDBProcCompile : boolean; (* PTS 1109247 *)
                    VAR put_node    : tsp00_Int2);
 
        PROCEDURE
              a20describe (
                    VAR acv      : tak_all_command_glob;
                    kw_index     : integer;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a20end_statement (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a20info_node (VAR acv : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2;
                    VAR info_n : tsp00_Int2);
 
        PROCEDURE
              a20unload_statistics (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Where_Part : VAK63;
 
        PROCEDURE
              a63_asearch_condition (
                    VAR acv            : tak_all_command_glob;
                    VAR put_node       : tsp00_Int2;
                    VAR last_node      : tsp00_Int2);
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
&       endif
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60_aquery_spec (
                    VAR acv       : tak_all_command_glob;
                    stamp_allowed : boolean;
                    from_select   : boolean;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2;
                    last_n        : tsp00_Int2;
                    fromselnode_built : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51a_alter_session_statement (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542reset_packet (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              DBProc_DDL_Syntax : VAK201;
 
        PROCEDURE
              a201alter_dbproc (VAR acv  : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a201alter_trigger_statement (VAR acv     : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a201create_dbproc  (VAR acv : tak_all_command_glob;
                    kw_index       : integer;
                    is_replace     : boolean;
                    VAR put_node   : tsp00_Int2);
 
        PROCEDURE
              a201CreateSystemTriggerStatement (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a201create_trigger_stmt (VAR acv : tak_all_command_glob;
                    is_replace   : boolean;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a201drop_trigger (VAR acv  : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (VAR acv : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_syntax_values_tools : VAK03;
 
        PROCEDURE
              a03_aunsigned_integer (
                    VAR acv            : tak_all_command_glob;
                    VAR put_node       : tsp00_Int2;
                    VAR last_node      : tsp00_Int2);
 
        PROCEDURE
              a03_ainteger (
                    VAR acv            : tak_all_command_glob;
                    VAR put_node       : tsp00_Int2;
                    VAR last_node      : tsp00_Int2);
 
        PROCEDURE
              a03_aliteral (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a03_astring_literal (
                    VAR acv          : tak_all_command_glob;
                    VAR put_node     : tsp00_Int2;
                    VAR last_node    : tsp00_Int2);
 
        PROCEDURE
              a03_l_aexpression_list (
                    VAR acv         : tak_all_command_glob;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02_atablename (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_adomain_name (
                    VAR acv       : tak_all_command_glob;
                    checkReserved : boolean;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_n_acolumnname  (
                    VAR acv         : tak_all_command_glob;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
        PROCEDURE
              a02_aauthid (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_acolumnspec (
                    VAR acv        : tak_all_command_glob;
                    table_required : boolean;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
        PROCEDURE
              a02_l_acolumn_list (
                    VAR acv         : tak_all_command_glob;
                    VAR put_node    : tsp00_Int2;
                    VAR last_node   : tsp00_Int2);
 
        PROCEDURE
              a02_aindexname (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_asynonymname (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_put_identifier (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02comment_spec (
                    VAR acv         : tak_all_command_glob;
                    put_node        : tsp00_Int2;
                    VAR last_n      : tsp00_Int2);
 
        PROCEDURE
              a02procedure (
                    VAR acv        : tak_all_command_glob;
                    VAR put_node   : tsp00_Int2;
                    VAR last_n     : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size         : integer;
              a01kw                : tak_keywordtab;
              a01_i_domain         : tsp00_KnlIdentifier;
 
        FUNCTION
              a01is_whitespace_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4) : boolean;
 
        PROCEDURE
              a01_get_password (
                    VAR acv        : tak_all_command_glob;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
        PROCEDURE
              a01info_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2;
                    VAR info_n : tsp00_Int2);
 
        PROCEDURE
              a01_init_command (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_is_end_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_force_symbol (
                    VAR acv         : tak_all_command_glob;
                    expected_symbol : tak_sc_symbol;
                    VAR node1       : tsp00_Int2;
                    VAR node2       : tsp00_Int2);
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_compact_cmd (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_put_node (
                    VAR acv    : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_get_keyword (
                    VAR acv      : tak_all_command_glob;
                    VAR index    : integer;
                    VAR reserved : boolean);
 
        FUNCTION
              a01_eqkey (
                    VAR a      : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
        FUNCTION
              a01mandatory_keyword (
                    VAR acv          : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_error (
                    VAR acv   : tak_all_command_glob;
                    err      : tgg00_BasisError;
                    VAR nod1 : tsp00_Int2;
                    VAR nod2 : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv      : tak_all_command_glob;
                    b_err        : tgg00_BasisError;
                    err_code      : tsp00_Int4);
 
        PROCEDURE
              a07_kw_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
      ------------------------------ 
 
        FROM
              Catalog_Migration_2 : VAK362;
 
        VAR
              a362OnlineTaskId : tsp00_TaskId;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01glob          : tgg00_KernelGlobals;
              g01unicode       : boolean;
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
 
.nf
.cp 10
PROCEDURE  A20_ACINDEX
.sp 1
PROCEDURE  AK20_A_CREATE_INDEX
.sp
PROCEDURE  A20_AINDEX_CLAUSE
.sp
.sp 1
Die Prozduren dienen zur Syntax-Erkennung der Create Index Befehle :
.sp
    'CREATE'
       / [  'UNIQUE'  ] 'INDEX' <index_spec>
.sp
.cp 3
<index_spec> ::=
      <single_index_spec>
    / <multiple_index_spec>;
.sp;.cp 3
<single_index_spec> ::=
      <table_name> '.' <column_name> [  'ASC' / 'DESC'  ];
 
<multiple_index_spec> ::=
    <index_name> 'ON' <table_name>
    '(' <index_clause> (* ',' <index_clause> *) ')';
.sp;.cp 3
<index_clause> ::=
      <column_name> [  'ASC' / 'DESC'  ];
.sp 4
.cp 7
PROCEDURE  A20_ADINDEX
.sp;.fo
Erkennt die Syntax des Drop Index Befehles und baut den Syntaxbaum
auf :
.sp;.nf
'DROP'  'INDEX'  <columnspec>
               / <indexname> 'ON' <tablename>;
.sp 4
.cp 7
PROCEDURE  A20_ACSYNONYM
.sp; .fo
Erkennt die Syntax des Create Synonym Befehles und baut den
Syntaxbaum auf :
.sp; .nf
     'CREATE'
         'SYNONYM' <synonym_name> 'FOR' <table_name>
.sp 4
.cp 7
PROCEDURE  A20_ADSYNONYM
.sp;.fo
Erkennt die Syntax des Drop Synonym Befehles und baut den
Syntaxbaum auf :
.sp; .nf
     'DROP'
         'SYNONYM' <synonym_name>
.sp 4
.cp 8
PROCEDURE a20_acuser
.sp;.fo
Erkennt die Syntax des Create User Befehles und baut den
Syntaxbaum auf :
.sp; .nf
     'CREATE'
         'USER' <auth_id> [  <user_mode>  ]
         [  'PASSWORD'  <password> ]
         [  < user_mode >  ]
         [  'LOCATION' <location_name>  ]
.sp 4
.cp 10
PROCEDURE  A20_AAUSER
.sp;.fo
Erkennt die Syntax des Alter User Befehles und baut den
Syntaxbaum auf :
.sp; .nf
     'ALTER'
         'USER' <auth_id> [  <user_mode>  ]
.sp 4
.cp 8
PROCEDURE A20_ADUSER  (VAR acv : all_command_glob;
.sp;.fo
Erkennt die Syntax des Drop User Befehles und baut den
Syntaxbaum auf :
.sp; .nf
     'DROP' 'USER' <auth_id>
.sp 4
.cp 8
PROCEDURE  A20_ACGRANT
.sp;.fo
Erkennt die Syntax des Grant Befehles und baut den
Syntaxbaum auf :
.sp; .nf
    <grant_statement> ::=
         'GRANT' <priv_spec_list> 'TO' <grant_list>;
.sp4
.cp 8
PROCEDURE  A20_ACREVOKE
.sp;.fo
Erkennt die Syntax des Revoke Befehles und baut den
Syntaxbaum auf :
.sp; .nf
    <revoke_statement> ::=
         'REVOKE' <priv_spec_list> 'FROM' <grant_list>;
.sp4
<priv_spec_list> ::=
    <priv_spec> (* ',' <priv_spec> *);
 
<priv_spec> ::=
    <table_priv_list> 'ON' <table_list>;
 
<table_list> ::= <tablename> (*',' <tablename> *);
 
<table_priv_list> ::=
      'ALL' [  'PRIVILEGES'  ]
    / 'OWNER'
    / <op_spec> (* ',' <op_spec> *);
 
<op_spec> ::=
      'INSERT'
    / 'DELETE'
    / 'UPDATE' [  '(' <column_list> ')'  ]
    / 'SELECT' [  '(' <column_list> ')'  ]
    / 'SELUPD' [  '(' <column_list> ')'  ];
 
<grant_list> ::=
      <auth_id> (* ',' <auth_id> *);
.cp 21
Syntaxbaum bei Grant / Revoke :
 
+-------+
|  a22  |
+-------+
    |
    |
+-------+                   +-------+    +-------+       +-------+
| a22 3 |-> ............. ->| a22 3 | -> |authid1| -> .. |authidn|
+-------+                   +-------+    +-------+       +-------+
    |                            .
    |                            .
+-------+        +-------+  +-------+
| select|-> .. ->| insert|->|tablen |
+-------+        +-------+  +-------+
    |
    |
+-------+          +-------+
| col 1 |-> .... ->| col n |
+-------+          +-------+
.sp
.sp 2
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      x_no_from_user      = 11;
      x_alter             = 1;
      c_datatype_required = true;
      c_check_reserved    = true;
      c_in_dbproc         = true; (* PTS 1109713 *)
      c_isDBFunction      = true;
 
TYPE
      tconstraint_type  = (c_null, c_not_null, c_check,
            c_impl_key, c_key, c_ref, c_unique);
      tkeywordset       = ARRAY[ 0..cak_maxkeyword ] OF boolean;
      tconstraint_nodes = ARRAY[tconstraint_type] OF tsp00_Int2;
 
 
(*------------------------------*) 
 
PROCEDURE
      a20agrant_revoke_statement (
            VAR acv                 : tak_all_command_glob;
            VAR put_node            : tsp00_Int2;
            kw_index                : integer);
 
VAR
      symbindex : integer;
      ret_code  : tsp00_Int2;
      last_node : tsp00_Int2;
      res_kw    : boolean;
 
BEGIN
ret_code := 0;
WITH acv, a_scv DO
    BEGIN
    a01_next_symbol (acv);
    IF  a01_eqkey (a01kw[ cak_i_execute ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv) AND
        (acv.a_sqlmode = sqlm_internal)
    THEN
        ak20execute_grant_revoke (acv, kw_index, put_node)
    ELSE
        BEGIN
        a01_get_keyword (acv, symbindex, res_kw);
        CASE symbindex OF
            cak_i_user, cak_i_usergroup :
                IF  (acv.a_sqlmode = sqlm_internal) AND
                    (kw_index = cak_i_grant)
                THEN
                    BEGIN
                    IF  (a_proc_compile <> pct_none) OR (a_dbproc_level > 0)
                    THEN
                        (* command is not allowed in a DB Procedure *)
                        a07_b_put_error (acv, e_invalid_command, 1)
                    ELSE
                        ak20grant_user (acv,
                              a_ap_tree^[ 0 ].n_lo_level, symbindex)
                    (*ENDIF*) 
                    END
                ELSE
                    a07_error (acv, e_invalid_end_of_command,
                          last_node, last_node);
                (*ENDIF*) 
            cak_i_all, cak_i_alter, cak_i_delete, cak_i_index, cak_i_insert,
            cak_i_references, cak_i_update, cak_i_select, cak_i_selupd :
                ak20grant_revoke_privilege (acv,
                      a_ap_tree^[ 0 ].n_lo_level, kw_index);
            cak_i_alterin, cak_i_createin, cak_i_dropin :
                ak20schema_privileges (acv,
                      a_ap_tree^[ 0 ].n_lo_level, kw_index);
            OTHERWISE
                ak20role_grant_revoke (acv, kw_index,
                      a_ap_tree^[ 0 ].n_lo_level);
            END;
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20execute_grant_revoke (
            VAR acv          : tak_all_command_glob;
            kw_index         : integer;
            VAR put_node     : tsp00_Int2);
 
VAR
      first          : boolean;
      curr_n         : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_call_put (acv, a261, kw_index, curr_n);
    put_node := curr_n;
    a01_next_symbol (acv);
    IF  a01mandatory_keyword (acv, cak_i_on)
    THEN
        BEGIN
        a02procedure (acv,
              a_ap_tree^[ curr_n ].n_sa_level, curr_n);
        IF  kw_index = cak_i_grant
        THEN
            BEGIN
            a_is_ddl := ddl_grant_execute;
            kw_index := cak_i_to
            END
        ELSE
            BEGIN
            a_is_ddl := ddl_revoke_execute;
            kw_index := cak_i_from
            END;
        (*ENDIF*) 
        first := true;
        IF  a01mandatory_keyword (acv, kw_index)
        THEN
            BEGIN
            REPEAT
                IF  first
                THEN
                    first := false
                ELSE
                    a01_next_symbol (acv);
                (*ENDIF*) 
                (* grant ... to <dba>.*
                      dba_spec := false;
                      IF  a01_eqkey (a01kw[ cak_i_dba ], a_sqlmode,
                      a_cmd_part^.sp1p_buf, a_scv)
                      THEN
                      BEGIN
                      dba_spec := true;
                      a01_next_symbol (acv);
                      END;
                      *)
                a02_aauthid (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n);
                (*
                      IF  dba_spec
                      THEN
                      a_ap_tree^[ curr_n ].n_symb := s_dba;
                      *)
            UNTIL
                sc_symb <> s_comma;
            (*ENDREPEAT*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20aalter_statement (
            VAR acv          : tak_all_command_glob;
            VAR put_node     : tsp00_Int2;
            symbindex        : integer);
 
CONST
      c_isDiagnose = true;
 
VAR
      last_node : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  (((a_proc_compile <> pct_none) OR (a_dbproc_level > 0))
        AND
        (symbindex <> cak_i_table))
        OR
        ((a_sqlmode = sqlm_oracle) AND
        ((symbindex = cak_i_password) OR
        ( symbindex = cak_i_usergroup)))
        OR
        ((a_sqlmode <> sqlm_internal) AND
        ( a_sqlmode <> sqlm_oracle))
        OR
        ((symbindex = cak_i_session) AND
        ( a_sqlmode <> sqlm_oracle))
    THEN
        BEGIN
        (* the current command is not allowed in a DB Procedure *)
        (* or in current sql mode                               *)
        put_node := 0;
        a07_b_put_error (acv, e_invalid_command, 1)
        END
    ELSE
        CASE symbindex OF
            cak_i_dbproc, cak_i_dbprocedure, cak_i_procedure (* PTS 1132753 *) :
                a201alter_dbproc (acv, a_ap_tree^[0].n_lo_level);
            cak_i_index :
                ak20alter_index (acv, a_ap_tree^[0].n_lo_level, NOT c_isDiagnose);
            cak_i_password :
                ak20alter_password (acv, a_ap_tree^[0].n_lo_level);
            cak_i_table  :
                ak20alter_table_statement (acv,
                      a_ap_tree^[ 0 ].n_lo_level, NOT c_isDiagnose);
            cak_i_session  : (* oracle: ALTER SESSION SET NLS_.... *)
                BEGIN
                a01_next_symbol (acv); (* skip session *)
                a51a_alter_session_statement (acv,
                      a_ap_tree^[ 0 ].n_lo_level);
                END;
            cak_i_trigger :
                a201alter_trigger_statement (acv,
                      a_ap_tree^[ 0 ].n_lo_level);
            cak_i_user, cak_i_usergroup  :
                ak20alter_user  (acv,
                      a_ap_tree^[ 0 ].n_lo_level, symbindex);
            OTHERWISE
                a07_error (acv, e_wanted_keyword, put_node, last_node);
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20acomment_statement (
            VAR acv           : tak_all_command_glob;
            VAR put_node      : tsp00_Int2);
 
VAR
      last_n      : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_next_symbol (acv);
    IF  a01mandatory_keyword (acv, cak_i_on)
    THEN
        BEGIN
        a_return_segm^.sp1r_function_code := csp1_insert_fc;
        a01_call_put (acv, a26, cak_i_on, put_node);
        a02comment_spec   (acv, put_node, last_n);
        a01_is_end_symbol (acv)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20acreate_statement (
            VAR acv           : tak_all_command_glob;
            VAR put_node      : tsp00_Int2;
            symbindex         : integer;
            res_kw            : boolean);
 
VAR
      is_invalid   : boolean;
      is_replace   : boolean;
      ret_code     : tsp00_Int2;
      ikw          : integer;
      start_pos    : integer;
      last_node    : tsp00_Int2;
      errpos_offs  : integer;
      aux_scv      : tak_scanner_glob;
 
BEGIN
is_replace   := false;
errpos_offs  := 0;
IF  (symbindex = cak_i_or) (* PTS 1117498 M.Ki. *)
THEN
    BEGIN
    start_pos := acv.a_scv.sc_sypos;
    a01_next_symbol (acv);
    IF  a01mandatory_keyword (acv, cak_i_replace)
    THEN
        BEGIN
        is_replace := true;
        aux_scv    := acv.a_scv;
        a01_get_keyword (acv, ikw, res_kw);
        IF  ikw = cak_i_view
        THEN
            BEGIN
            (* remove 'or replace' from definition string *)
            symbindex       := ikw;
            IF  acv.a_ex_kind <> only_parsing
            THEN
                BEGIN
                a01_next_symbol (acv);
                acv.a_scv := aux_scv;
                IF  g01unicode
                THEN
                    BEGIN
                    SAPDB_PascalUnicodeFill ('VAK20 ',   1,    
                          acv.a_cmd_part^.sp1p_buf_size,
                          @acv.a_cmd_part^.sp1p_buf, start_pos,
                          acv.a_scv.sc_sypos - start_pos, csp_unicode_blank,
                          acv.a_returncode)
                    END
                ELSE
                    SAPDB_PascalFill ('VAK20 ',   2,    
                          acv.a_cmd_part^.sp1p_buf_size,
                          @acv.a_cmd_part^.sp1p_buf, start_pos,
                          acv.a_scv.sc_sypos - start_pos, bsp_c1,
                          acv.a_returncode);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            IF  ikw <> cak_i_package
            THEN
                a07_error (acv,
                      e_wanted_keyword, put_node, last_node)
            ELSE
                symbindex := ikw;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    is_invalid := false;
    ret_code   := 0;
    CASE symbindex OF
        cak_i_package :
            IF  acv.a_sqlmode in [sqlm_internal, sqlm_oracle]
            THEN
                ak20create_package (acv, is_replace, put_node)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_function,
        cak_i_dbproc,
        cak_i_dbprocedure,
        cak_i_procedure (* PTS 1132753 *) :
            IF  acv.a_sqlmode in [ sqlm_internal, sqlm_oracle ]
            THEN
                a201create_dbproc (acv, symbindex, is_replace, put_node)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_domain :
            IF  acv.a_sqlmode = sqlm_internal
            THEN
                ak20create_domain_stmt (acv, put_node)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_index, cak_i_unique :
            IF  acv.a_sqlmode <> sqlm_ansi
            THEN
                ak20create_index_stmt (acv,
                      put_node, symbindex = cak_i_unique)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_role :
            IF  acv.a_sqlmode in [sqlm_internal, sqlm_oracle]
            THEN
                ak20create_role_stmt (acv, put_node)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_schema :
            IF  acv.a_sqlmode = sqlm_ansi
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  acv.a_scv.sc_symb = s_identifier
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    IF  acv.a_scv.sc_symb = s_identifier
                    THEN
                        BEGIN
                        a01_next_symbol (acv);
                        a01_call_put (acv, a10, 0, put_node);
                        acv.a_is_ddl := ddl_create_schema;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                ak20CreateSchema (acv, put_node);
            (*ENDIF*) 
        cak_i_sequence :
            IF  acv.a_sqlmode in [sqlm_oracle, sqlm_internal]
            THEN
                ak20create_sequence_stmt (acv, put_node)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_synonym :
            IF  (acv.a_sqlmode = sqlm_internal) OR
                (acv.a_sqlmode = sqlm_db2)    OR
                (acv.a_sqlmode = sqlm_oracle)
            THEN
                ak20create_synonym_stmt (acv,
                      cak_i_synonym, put_node)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_system :
            a201CreateSystemTriggerStatement (acv, put_node);
        cak_i_table :
            a20create_table_stmt (acv, NOT c_in_dbproc (* PTS 1109713 *), put_node);
        cak_i_trigger :
            IF  acv.a_sqlmode in [sqlm_internal, sqlm_oracle]
            THEN
                a201create_trigger_stmt (acv, is_replace, put_node)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_type :
            IF  acv.a_sqlmode = sqlm_internal
            THEN
                ak20create_type (acv, put_node)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_user, cak_i_usergroup :
            IF  (acv.a_sqlmode = sqlm_internal)
                OR
                ((acv.a_sqlmode = sqlm_oracle) AND
                ( symbindex = cak_i_user))
            THEN
                ak20create_user_stmt (acv, put_node, symbindex)
            ELSE
                is_invalid := true;
            (*ENDIF*) 
        cak_i_view :
            ak20create_view_stmt (acv,
                  NOT (acv.a_ex_kind in [only_syntax, only_parsing]), is_replace, errpos_offs, put_node);
        cak_i_public, cak_i_rollback, cak_i_tablespace :
            IF  acv.a_sqlmode in [sqlm_internal, sqlm_oracle]
            THEN
                BEGIN
                a01_next_symbol (acv);
                a01_get_keyword (acv, ikw, res_kw);
                CASE  ikw OF
                    cak_i_function :
                        IF  symbindex <> cak_i_public (* PTS 1130492 *)
                        THEN
                            is_invalid := true
                        ELSE
                            IF  acv.a_sqlmode in [ sqlm_internal, sqlm_oracle ]
                            THEN
                                a201create_dbproc (acv, cak_i_public, false, put_node);
                            (*ENDIF*) 
                        (*ENDIF*) 
                    cak_i_synonym :
                        IF  symbindex <> cak_i_public (* PTS 1130492 *)
                        THEN
                            is_invalid := true
                        ELSE
                            ak20create_synonym_stmt (acv,
                                  cak_i_public, put_node);
                        (*ENDIF*) 
                    OTHERWISE
                        IF  acv.a_sqlmode <> sqlm_oracle
                        THEN
                            is_invalid := true
                        ELSE
                            BEGIN
                            a01_call_put (acv, a10, 0, put_node);
                            acv.a_is_ddl            := ddl_db2;
                            acv.a_scv.sc_symb       := s_eof
                            END
                        (*ENDIF*) 
                    END
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
        OTHERWISE
            is_invalid := true;
        END;
    (*ENDCASE*) 
    IF  is_invalid
    THEN
        a07_error (acv, e_wanted_keyword, put_node, last_node)
    ELSE
        a01_is_end_symbol (acv);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_procedure (
            VAR acv      : tak_all_command_glob;
            kw_index     : integer;
            VAR put_node : tsp00_Int2);
 
VAR
      curr_n         : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  kw_index = cak_i_procedure
    THEN
        kw_index := cak_i_dbproc;
    (*ENDIF*) 
    a01_next_symbol (acv);
    a_is_ddl := ddl_drop_procedure;
    IF  kw_index = cak_i_system
    THEN
        IF  a01mandatory_keyword (acv, cak_i_trigger)
        THEN
            BEGIN
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    a01_call_put (acv, a261, cak_i_drop, put_node);
    a_ap_tree^[put_node].n_pos    := kw_index;
    a_ap_tree^[put_node].n_length := 0;
    a02procedure (acv,
          a_ap_tree^[put_node].n_sa_level, curr_n);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20adiagnose_alter (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
CONST
      c_isDiagnose = true;
 
BEGIN
IF  a01_eqkey (a01kw[ cak_i_index], acv.a_sqlmode,
    acv.a_cmd_part^.sp1p_buf, acv.a_scv)
THEN
    ak20alter_index (acv, put_node, c_isDiagnose)
ELSE
    IF  a01_eqkey (a01kw[ cak_i_table], acv.a_sqlmode,
        acv.a_cmd_part^.sp1p_buf, acv.a_scv)
    THEN
        ak20alter_table_statement (acv, put_node, c_isDiagnose)
    ELSE
        a07_error (acv, e_wanted_keyword, put_node, put_node);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE (* PTS 1115972 *)
      a20adiagnose_drop_file_statement(VAR acv : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
a01_next_symbol (acv);
IF  a01mandatory_keyword (acv, cak_i_file)
THEN
    BEGIN
    IF  acv.a_scv.sc_symb = s_byte_string
    THEN
        BEGIN
        a01_call_put (acv, a18, cak_i_diagnose, curr_n);
        put_node := curr_n;
        a03_astring_literal (acv, acv.a_ap_tree^[curr_n].n_lo_level, curr_n);
        END
    ELSE
        a01_force_symbol (acv, s_byte_string, put_node, curr_n)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20adrop_statement (
            VAR acv         : tak_all_command_glob;
            VAR put_node    : tsp00_Int2;
            symbindex       : integer);
 
VAR
      is_invalid : boolean;
      last_node  : tsp00_Int2;
 
BEGIN
WITH acv, a_scv  DO
    BEGIN
    IF  ((a_proc_compile <> pct_none) OR (a_dbproc_level > 0))
        AND
        NOT acv.a_in_ddl_trigger
        AND
        NOT acv.a_dynamic_sql
        AND
        NOT (symbindex in [ cak_i_table, cak_i_synonym,
        cak_i_system, (* PTS 1133300 UH 2005-01-11 *)
        cak_i_view, cak_i_index, cak_i_domain ])
    THEN
        (* the current command is not allowed in a DB Procedure *)
        a07_b_put_error (acv, e_invalid_command, 1)
    ELSE
        BEGIN
        is_invalid := false;
        IF  a_statement_kind = isql_commands
        THEN
            a_statement_kind := idrops;
        (*ENDIF*) 
        CASE symbindex OF
            cak_i_container :
                ak20drop_container (acv,  a_ap_tree^[0].n_lo_level);
            cak_i_domain :
                IF  acv.a_sqlmode = sqlm_internal
                THEN
                    ak20drop_domain (acv,
                          a_ap_tree^[ 0 ].n_lo_level)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_index :
                ak20aindex_drop (acv, a_ap_tree^[ 0 ].n_lo_level);
            cak_i_package :
                ak20drop_package (acv, a_ap_tree^[0].n_lo_level);
            cak_i_public :
                IF  (acv.a_sqlmode = sqlm_internal) OR
                    (acv.a_sqlmode = sqlm_oracle)
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    IF  a01_eqkey (a01kw[cak_i_synonym], a_sqlmode,
                        a_cmd_part^.sp1p_buf,a_scv)
                    THEN
                        ak20drop_synonym (acv,
                              a_ap_tree^[0].n_lo_level, cak_i_public)
                    ELSE
                        IF  a01_eqkey (a01kw[cak_i_function], a_sqlmode,
                            a_cmd_part^.sp1p_buf,a_scv)
                        THEN
                            ak20drop_procedure (acv, cak_i_public,
                                  a_ap_tree^[0].n_lo_level)
                        ELSE
                            a07_error (acv,
                                  e_wanted_keyword, put_node, last_node)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_role :
                IF  acv.a_sqlmode in [sqlm_internal, sqlm_oracle]
                THEN
                    ak20drop_role_stmt (acv, a_ap_tree^[0].n_lo_level)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_schema :
                IF  acv.a_sqlmode <> sqlm_ansi
                THEN
                    ak20DropSchemaStatement (acv, a_ap_tree^[0].n_lo_level)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_synonym :
                IF  (acv.a_sqlmode = sqlm_internal) OR
                    (acv.a_sqlmode = sqlm_db2   ) OR
                    (acv.a_sqlmode = sqlm_oracle)
                THEN
                    BEGIN
                    acv.a_scv.sc_states := acv.a_scv.sc_states +
                          [ scs_reserved_check ];  (* PTS: 1117941 *)
                    ak20drop_synonym (acv,
                          a_ap_tree^[ 0 ].n_lo_level, cak_i_synonym);
                    acv.a_scv.sc_states := acv.a_scv.sc_states -
                          [ scs_reserved_check ];  (* PTS: 1117941 *)
                    END
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_sequence :
                IF  acv.a_sqlmode in [sqlm_internal, sqlm_oracle]
                THEN
                    ak20drop_sequence (acv,
                          a_ap_tree^[ 0 ].n_lo_level)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_table :
                BEGIN
                IF  acv.a_sqlmode <> sqlm_ansi
                THEN
                    BEGIN
                    acv.a_scv.sc_states := acv.a_scv.sc_states +
                          [ scs_reserved_check ];  (* PTS: 1117941 *)
                    a20atable_drop (acv,
                          a_ap_tree^[ 0 ].n_lo_level);
                    acv.a_scv.sc_states := acv.a_scv.sc_states -
                          [ scs_reserved_check ];  (* PTS: 1117941 *)
                    END
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
                END;
            cak_i_type :
                IF  acv.a_sqlmode = sqlm_internal
                THEN
                    ak20drop_domain (acv,
                          a_ap_tree^[ 0 ].n_lo_level)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_user :
                IF  acv.a_sqlmode in [sqlm_internal, sqlm_oracle]
                THEN
                    ak20drop_user (acv,
                          a_ap_tree^[ 0 ].n_lo_level, symbindex)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_usergroup :
                IF  acv.a_sqlmode = sqlm_internal
                THEN
                    ak20drop_user (acv,
                          a_ap_tree^[ 0 ].n_lo_level, symbindex)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_view :
                BEGIN
                IF  (acv.a_sqlmode = sqlm_internal) OR
                    (acv.a_sqlmode = sqlm_db2   ) OR
                    (acv.a_sqlmode = sqlm_oracle)
                THEN
                    BEGIN
                    acv.a_scv.sc_states := acv.a_scv.sc_states +
                          [ scs_reserved_check ];  (* PTS: 1117941 *)
                    ak20drop_view (acv, symbindex,
                          a_ap_tree^[ 0 ].n_lo_level);
                    acv.a_scv.sc_states := acv.a_scv.sc_states -
                          [ scs_reserved_check ];  (* PTS: 1117941 *)
                    END
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
                END;
            cak_i_procedure (* PTS 1132753 *), cak_i_dbproc, cak_i_dbprocedure, cak_i_function, cak_i_system :
                IF  acv.a_sqlmode in [ sqlm_internal, sqlm_oracle ]
                THEN
                    ak20drop_procedure (acv, symbindex,
                          a_ap_tree^[0].n_lo_level)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_trigger :
                IF  a_sqlmode in [sqlm_internal, sqlm_oracle]
                THEN
                    a201drop_trigger (acv,
                          a_ap_tree^[ 0 ].n_lo_level)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            OTHERWISE
                is_invalid := true;
            END;
        (*ENDCASE*) 
        IF  is_invalid
        THEN
            a07_error (acv, e_wanted_keyword, put_node, last_node)
        ELSE
            a01_is_end_symbol (acv)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1111576 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a20_arename_statement (
            VAR acv            : tak_all_command_glob;
            VAR put_node       : tsp00_Int2);
 
VAR
      res_kw : boolean;
      curr_n : tsp00_Int2;
      last_n : tsp00_Int2;
      ikw    : integer;
      scv    : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    IF  (acv.a_sqlmode <> sqlm_internal) AND
        (acv.a_sqlmode <> sqlm_oracle)
    THEN
        a07_b_put_error (acv, e_invalid_command, 1)
    ELSE
        BEGIN
        scv := a_scv;
        a01_next_symbol (acv);
        a01_get_keyword (acv, ikw, res_kw);
        IF  acv.a_sqlmode = sqlm_oracle
        THEN
            BEGIN
            IF  ikw <> cak_i_index
            THEN
                BEGIN
                a_scv := scv;
                ikw   := cak_i_table
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        CASE ikw OF
            cak_i_synonym, cak_i_table, cak_i_view :
                BEGIN
                a01_call_put (acv, a18, ikw, curr_n);
                put_node := curr_n;
                a01_next_symbol (acv);
                acv.a_scv.sc_states := acv.a_scv.sc_states +
                      [ scs_reserved_check ];  (* PTS: 1117941 *)
                a02_atablename (acv,
                      a_ap_tree^[ curr_n ].n_lo_level, last_n);
                (* 1105520 *)
                acv.a_scv.sc_states := acv.a_scv.sc_states -
                      [ scs_reserved_check ];  (* PTS: 1117941 *)
                IF  ikw = cak_i_view (* PTS 1105019, T.A. 14.12.1999 *)
                THEN
                    a_is_ddl := ddl_rename_view
                ELSE
                    IF  ikw = cak_i_synonym
                    THEN
                        a_is_ddl := ddl_rename_synonym
                    ELSE
                        a_is_ddl := ddl_rename_table;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  a01mandatory_keyword (acv, cak_i_to)
                THEN
                    BEGIN
                    acv.a_scv.sc_states := acv.a_scv.sc_states +
                          [ scs_reserved_check ];  (* PTS: 1117941 *)
                    a02_atablename (acv,
                          a_ap_tree^[ last_n ].n_lo_level, last_n);
                    acv.a_scv.sc_states := acv.a_scv.sc_states -
                          [ scs_reserved_check ];  (* PTS: 1117941 *)
                    END
                (*ENDIF*) 
                END;
            cak_i_column :
                BEGIN
                a_is_ddl := ddl_rename_column;
                a01_call_put (acv, a18, cak_i_column, curr_n);
                put_node := curr_n;
                a01_next_symbol (acv);
                a02_acolumnspec (acv, true,
                      a_ap_tree^[ curr_n ].n_lo_level, last_n);
                IF  a01mandatory_keyword (acv, cak_i_to)
                THEN
                    BEGIN
                    a01_get_keyword (acv, ikw, res_kw);
                    IF  res_kw
                    THEN
                        a07_error (acv, e_reserved_identifier,
                              put_node, last_n);
                    (*ENDIF*) 
                    a02_n_acolumnname (acv,
                          a_ap_tree^[ last_n ].n_lo_level, last_n);
                    END
                (*ENDIF*) 
                END;
            cak_i_index :
                BEGIN (* ADIS change request 1000032 *)
                (* PTS 1111229 E.Z. *)
                a_is_ddl := ddl_rename_index;
                a01_call_put    (acv, a24, cak_i_rename, put_node);
                a01_next_symbol (acv);
                a02_aindexname  (acv, a_ap_tree^[put_node].n_lo_level,
                      last_n);
                IF  a01_eqkey (a01kw[ cak_i_on ], a_sqlmode,
                    a_cmd_part^.sp1p_buf,a_scv)
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    a02_atablename (acv, a_ap_tree^[last_n].n_sa_level,
                          last_n)
                    END;
                (*ENDIF*) 
                IF  a01mandatory_keyword (acv, cak_i_to)
                THEN
                    a02_aindexname (acv, a_ap_tree^[put_node].n_sa_level,
                          last_n);
                (*ENDIF*) 
                END;
            cak_i_public :
                BEGIN
                a_is_ddl := ddl_rename_synonym;
                a01_call_put (acv, a18, cak_i_public, put_node);
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_synonym)
                THEN
                    BEGIN
                    a02_atablename (acv,
                          a_ap_tree^[put_node].n_lo_level, last_n);
                    IF  a01mandatory_keyword (acv, cak_i_to)
                    THEN
                        a02_atablename (acv,
                              a_ap_tree^[ last_n ].n_lo_level, last_n);
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            cak_i_user, cak_i_usergroup, cak_i_schema :
                BEGIN
                a_is_ddl := ddl_rename_user;
                (* h.b. PTS 1001663 *)
                IF  (ikw = cak_i_usergroup)
                THEN
                    a01_call_put (acv, a21, cak_x_rename_user
                          + cak_x_user_group, put_node)
                ELSE
                    a01_call_put (acv, a21, cak_x_rename_user, put_node);
                (*ENDIF*) 
                acv.a_ap_tree^[put_node].n_length := ikw;
                a01_next_symbol (acv);
                a02_aauthid (acv,
                      a_ap_tree^[put_node].n_sa_level, last_n);
                IF  a01mandatory_keyword (acv, cak_i_to)
                THEN
                    a02_aauthid (acv,
                          a_ap_tree^[last_n].n_sa_level, last_n)
                (*ENDIF*) 
                END;
            OTHERWISE
                a07_error (acv, e_wanted_keyword, put_node, last_n);
            END;
        (*ENDCASE*) 
        a01_is_end_symbol (acv)
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20_aexist_table (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_next_symbol (acv);
    IF  a01mandatory_keyword (acv, cak_i_table)
    THEN
        BEGIN
        a_return_segm^.sp1r_function_code := csp1_exists_table_fc;
        a01_call_put (acv, a18, cak_i_exists, put_node);
        a02_atablename (acv,
              a_ap_tree^[put_node].n_lo_level, last_n);
        a01_is_end_symbol (acv)
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20_asave_restore (
            VAR acv               : tak_all_command_glob;
            keyword_index         : integer;
            VAR put_node          : tsp00_Int2);
 
VAR
      restore_table  : boolean;
      restore_column : boolean;
      restore_long   : boolean;
      last_n         : tsp00_Int2;
      kw_index       : integer;
      kw             : integer;
      res_kw         : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_save_restore_cmd;
    a01_next_symbol (acv);
    a01_get_keyword (acv, kw_index, res_kw);
    restore_table  := kw_index = cak_i_table;
    restore_column := kw_index = cak_i_column;
    restore_long   := kw_index = cak_i_long;
    IF  restore_table  OR
        restore_column OR restore_long
    THEN
        IF  (a_cmd_segment_header.sp1c_producer = sp1pr_internal_cmd)
        THEN
            BEGIN
            a01_next_symbol (acv);
            IF  NOT restore_column
            THEN
                BEGIN
                IF  restore_long
                THEN
                    a01_call_put (acv,
                          a11, cak_x_restore_string, put_node)
                ELSE
                    a01_call_put (acv, a11, cak_x_restore, put_node);
                (*ENDIF*) 
                a02_atablename (acv,
                      a_ap_tree^[ put_node ].n_lo_level, last_n);
                END
            ELSE
                a01_call_put (acv, a17, cak_x_restore, put_node);
            (*ENDIF*) 
            END
        ELSE
            a07_b_put_error (acv, e_invalid_command, 1)
        (*ENDIF*) 
    ELSE
        IF  a01mandatory_keyword (acv, cak_i_catalog)
        THEN
            BEGIN
            a_is_ddl := ddl_restore_schema;
            a01_call_put (acv, a15, keyword_index, put_node);
            a01_get_keyword (acv, kw, res_kw);
            CASE kw OF
                cak_i_all, cak_i_user :
                    IF    keyword_index = cak_i_save
                    THEN
                        BEGIN
                        IF  kw = cak_i_all
                        THEN
                            sc_symb := s_asterisk
                        ELSE
                            sc_symb := s_user;
                        (*ENDIF*) 
                        a01_put_node (acv, last_n);
                        a_ap_tree^[ put_node ].n_lo_level := last_n;
                        a01_next_symbol (acv)
                        END
                    ELSE
                        a07_error (acv,
                              e_wanted_keyword, put_node, last_n);
                    (*ENDIF*) 
                cak_i_from, cak_i_of :
                    IF  ((keyword_index = cak_i_save) AND
                        (kw = cak_i_of))
                        OR
                        ((keyword_index = cak_i_restore) AND
                        (kw = cak_i_from))
                    THEN
                        BEGIN
                        a01_next_symbol(acv);
                        IF  a01_eqkey (a01kw[ cak_i_schema ], acv.a_sqlmode,
                            acv.a_cmd_part^.sp1p_buf, acv.a_scv)
                        THEN
                            BEGIN
                            a01_next_symbol (acv);
                            a02_aauthid (acv, a_ap_tree^[put_node].n_lo_level, last_n);
                            END
                        ELSE
                            a02_atablename (acv,
                                  a_ap_tree^[put_node].n_lo_level, last_n)
                        (*ENDIF*) 
                        END
                    ELSE
                        a07_error (acv,
                              e_wanted_keyword, put_node, last_n);
                    (*ENDIF*) 
                OTHERWISE
                    a07_error (acv,
                          e_wanted_keyword, put_node, last_n);
                END;
            (*ENDCASE*) 
            IF  keyword_index = cak_i_save
            THEN
                IF  a01mandatory_keyword (acv, cak_i_into)
                THEN
                    a02_atablename (acv,
                          a_ap_tree^[ last_n ].n_lo_level,last_n);
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20check_table_stmt (VAR acv : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      res_kw      : boolean;
      extend      : boolean;
      checkSystab : boolean;
      ikw         : integer;
      last_n      : tsp00_Int2;
      scvh        : tak_scanner_glob;
 
BEGIN
IF  a01mandatory_keyword (acv, cak_i_table)
THEN
    BEGIN
    checkSystab := false;
    IF  (a01_eqkey (a01kw[ cak_i_as ], acv.a_sqlmode,
        acv.a_cmd_part^.sp1p_buf, acv.a_scv))
        AND
        ((acv.a_sqlmode  = sqlm_internal) OR
        (g01glob.db_is_for_sapr3 AND (acv.a_sqlmode = sqlm_oracle)))
    THEN
        BEGIN
        scvh := acv.a_scv;
        a01_next_symbol (acv);
        IF  a01_eqkey (a01kw[ cak_i_per ], acv.a_sqlmode,
            acv.a_cmd_part^.sp1p_buf, acv.a_scv)
        THEN
            BEGIN
            checkSystab := true;
            a01_next_symbol (acv);
            IF  a01mandatory_keyword (acv, cak_i_system)
            THEN
                IF  a01mandatory_keyword (acv, cak_i_table)
                THEN
                    BEGIN
                    a01_call_put (acv, a18, cak_x_check_table_system_table, put_node);
                    IF  acv.a_scv.sc_symb <> s_eof
                    THEN
                        a07_error (acv, e_invalid_end_of_command,
                              last_n, last_n);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            acv.a_scv := scvh;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT checkSystab
    THEN
        BEGIN
        (* assign any ddl_kind to allow parse/execute *)
        acv.a_is_ddl := ddl_alter_tab_alter;
        a01_call_put (acv, a18, cak_i_check, put_node);
        a02_atablename (acv,
              acv.a_ap_tree^[put_node].n_lo_level, last_n);
        extend := false;
        END;
    (*ENDIF*) 
    IF  acv.a_scv.sc_symb <> s_eof
    THEN
        IF  a01_eqkey (a01kw[ cak_i_extended ], acv.a_sqlmode,
            acv.a_cmd_part^.sp1p_buf, acv.a_scv)
        THEN
            BEGIN
            extend := true;
            a01_call_put (acv, a30, cak_x_extended_check,
                  acv.a_ap_tree^[put_node].n_sa_level);
            a01_next_symbol (acv);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  acv.a_scv.sc_symb <> s_eof
    THEN
        BEGIN
        a01_get_keyword (acv, ikw, res_kw);
        CASE ikw OF
            cak_i_no :
                BEGIN
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_savepoint)
                THEN
                    acv.a_ap_tree^[put_node].n_subproc := cak_i_savepoint
                (*ENDIF*) 
                END;
            cak_i_catalog :
                IF  extend
                THEN
                    a01_is_end_symbol (acv)
                ELSE
                    BEGIN
                    a01_next_symbol (acv);
                    acv.a_ap_tree^[put_node].n_subproc := cak_i_catalog;
                    END;
                (*ENDIF*) 
            (* PTS 1108979 E.Z. *)
            cak_i_with :
                BEGIN
                a01_next_symbol (acv);
                IF  a01_eqkey (a01kw[ cak_i_share ], acv.a_sqlmode,
                    acv.a_cmd_part^.sp1p_buf, acv.a_scv)
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    IF  a01mandatory_keyword (acv, cak_i_lock)
                    THEN
                        acv.a_ap_tree^[put_node].n_subproc := cak_i_lock;
                    (*ENDIF*) 
                    IF  a01_eqkey (a01kw[ cak_i_extended ], acv.a_sqlmode,
                        acv.a_cmd_part^.sp1p_buf, acv.a_scv)
                    THEN
                        BEGIN
                        a01_call_put (acv, a30, cak_x_extended_check,
                              acv.a_ap_tree^[put_node].n_sa_level);
                        a01_next_symbol (acv);
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  a01mandatory_keyword (acv, cak_i_long)
                    THEN
                        IF  a01mandatory_keyword (acv, cak_i_check)
                        THEN
                            acv.a_ap_tree^[put_node].n_subproc := cak_i_lock;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            OTHERWISE
                BEGIN
                END;
            END;
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20describe (
            VAR acv      : tak_all_command_glob;
            kw_index     : integer;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  (a_cmd_segment_header.sp1c_producer = sp1pr_user_cmd) (* h.b. PTS 1107071 *)
    THEN
        a07_b_put_error (acv, e_invalid_command, 1)
    ELSE
        BEGIN
        a01_next_symbol (acv);
        (* PTS 1111576 E.Z. *)
        a01_call_put (acv, a11, cak_x_describe_table, curr_n);
        a_ap_tree^[ curr_n ].n_length := kw_index;
        put_node := curr_n;
        a02_atablename (acv,
              a_ap_tree^[ curr_n ].n_lo_level, last_n);
        IF  (a_scv.sc_symb <> s_eof) AND (kw_index = cak_i_table)
        THEN
            BEGIN
            IF  a01_eqkey (a01kw[ cak_i_except ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  a01_eqkey (a01kw[ cak_i_constraint ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    a_ap_tree^[ curr_n ].n_length:= cak_i_except
                    END;
                (*ENDIF*) 
                IF  a01_eqkey (a01kw[ cak_i_restore ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    a_ap_tree^[ curr_n ].n_sa_level :=
                          cak_i_restore
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a01_is_end_symbol (acv)
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20end_statement (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      res_kw  : boolean;
      ikw     : integer;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_next_symbol (acv);
    a01_get_keyword (acv, ikw, res_kw);
    CASE ikw OF
        (* PTS 1120287 E.Z. *)
        cak_i_restore :
            IF  a_cmd_segment_header.sp1c_producer in
                [sp1pr_internal_cmd, sp1pr_installation]
            THEN
                BEGIN
                a01_next_symbol (acv);
                a01_call_put (acv, a17, cak_x_end_restore, put_node)
                END
            ELSE
                a07_b_put_error (acv, e_invalid_command, 1);
            (*ENDIF*) 
        OTHERWISE
            a07_error (acv, e_wanted_keyword, put_node, put_node)
        END;
    (*ENDCASE*) 
    a01_is_end_symbol (acv)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20create_view_stmt (
            VAR acv             : tak_all_command_glob;
            removeLeadingBlanks : boolean;
            is_replace          : boolean;
            errpos_offs         : integer;
            VAR put_node        : tsp00_Int2);
 
VAR
      dummy_bool : boolean;
      res_kw     : boolean;
      ikw        : integer;
      len        : integer;
      curr_n     : tsp00_Int2;
      last_n     : tsp00_Int2;
      aux_n      : tsp00_Int2;
      key_node   : tsp00_Int2;
      scvh       : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_create_view;
    IF  removeLeadingBlanks
    THEN
        BEGIN
        (*  remove leading blanks *)
        a01_init_command (acv);
        a_errpos_offset := a_errpos_offset + errpos_offs;
        a01_next_symbol  (acv)
        END;
    (*ENDIF*) 
    IF  a_ex_kind = pars_then_execute
    THEN
        a_ex_kind := parsing_executing;
    (*ENDIF*) 
    a01_get_keyword (acv, ikw, res_kw);
    a01_call_put (acv, a16, ikw, put_node);
    a_ap_tree^[put_node].n_pos := ord (is_replace);
    a01_next_symbol (acv);
    acv.a_scv.sc_states := acv.a_scv.sc_states + [ scs_reserved_check ];
    a02_atablename (acv, a_ap_tree^[put_node].n_lo_level, last_n);
    IF  acv.a_returncode = 0
    THEN
        a05identifier_get (acv, last_n,
              sizeof (acv.a_viewname), acv.a_viewname);
    (*ENDIF*) 
    acv.a_scv.sc_states := acv.a_scv.sc_states - [ scs_reserved_check ];
    IF  a_scv.sc_symb = s_leftpar
    THEN
        BEGIN
        a01_call_put (acv, a16, cak_x_column_list, curr_n);
        a_ap_tree^[ last_n ].n_lo_level := curr_n;
        last_n   := curr_n;
        key_node := 0;
        REPEAT
            a01_next_symbol (acv);
            a01_get_keyword (acv, ikw, res_kw);
            IF  res_kw
            THEN
                a07_error (acv, e_reserved_identifier,
                      put_node, last_n)
            ELSE
                a02_n_acolumnname (acv,
                      a_ap_tree^[ curr_n ].n_sa_level, curr_n);
            (*ENDIF*) 
        UNTIL
            sc_symb <> s_comma;
        (*ENDREPEAT*) 
        IF  key_node <> 0
        THEN
            BEGIN
            aux_n := a_ap_tree^[last_n].n_sa_level;
            a01_call_put (acv, a16, cak_i_key, curr_n);
            a_ap_tree^[last_n].n_sa_level := curr_n;
            a_ap_tree^[curr_n].n_sa_level := aux_n;
            a01_call_put (acv, a16, cak_i_key, aux_n);
            a_ap_tree^[aux_n ].n_length   := cak_i_alter;
            a_ap_tree^[curr_n].n_lo_level := aux_n;
            a_ap_tree^[aux_n ].n_sa_level := key_node
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_n)
        END;
    (*ENDIF*) 
    IF  a01mandatory_keyword (acv, cak_i_as)
    THEN
        BEGIN
        scvh := a_scv;
        WHILE sc_symb = s_leftpar DO
            a01_next_symbol(acv);
        (*ENDWHILE*) 
        IF  a01mandatory_keyword (acv, cak_i_select)
        THEN
            BEGIN
            a_scv             := scvh;
            a_rowno_allowed   := false;
            a_rowno_found     := false;
            a_allow_functions := tf_unknown;
            a_from_select     := false;
            (* PTS 1122971 E.Z. *)
            a_oneval_subq_allowed := true;
            a_ap_tree^[ put_node ].n_length := sc_sypos;
&           ifdef trace
            t01int4 (ak_sem, 'sc_symb     ', ord (sc_symb));
&           endif
            (* PTS 1138343 D.T. *)
            a60_aquery_spec (acv, false, false,
                  a_ap_tree^[ last_n ].n_lo_level, last_n, cak_is_undefined, false);
            END;
        (*ENDIF*) 
        IF  sc_symb <> s_eof
        THEN
            BEGIN
            IF  a01_eqkey (a01kw[ cak_i_with], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_check)
                THEN
                    IF  a01mandatory_keyword (acv, cak_i_option)
                    THEN
                        BEGIN
                        a_ap_tree^[ put_node ].n_symb := s_plus;
                        ak20skip_oracle_constraint (acv, dummy_bool)
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  sc_symb <> s_eof
        THEN
            IF  a01_eqkey (a01kw[cak_i_no], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv) (* PTS 1109081 *)
            THEN
                BEGIN
                len := acv.a_scv.sc_sypos - 1;
                a01_next_symbol(acv);
                IF  a01mandatory_keyword (acv, cak_i_references)
                THEN
                    BEGIN
                    a_ap_tree^[put_node].n_subproc := cak_i_no;
                    IF  (acv.a_init_ex_kind <> only_parsing)
                    THEN
                        a_cmd_part^.sp1p_buf_len := len;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                (* for Oracle-systemviews with INTERNAL, although INTERNAL is no keyword *)
                IF  a01_eqkey (a01kw[cak_i_internal], sqlm_internal,
                    a_cmd_part^.sp1p_buf, a_scv)
                    AND
                    (
                    (a_initial_segment_header.sp1c_producer in
                    [sp1pr_internal_cmd, sp1pr_installation]) OR
                    (a_internal_sql <> no_internal_sql)
                    OR
                    (a362OnlineTaskId = acv.a_transinf.tri_trans.trTaskId_gg00)
                    )
                THEN
                    BEGIN
                    a_ap_tree^[put_node].n_subproc := cak_i_internal;
                    a01_next_symbol (acv)
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_container (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      res_kw : boolean;
      last_n : tsp00_Int2;
      kw     : integer;
 
BEGIN
acv.a_is_ddl := ddl_drop_table;
a01_next_symbol (acv);
a01_get_keyword (acv, kw, res_kw);
IF  kw = cak_i_all
THEN
    BEGIN
    a01_call_put (acv, a34, cak_i_all, put_node);
    a01_next_symbol (acv)
    END
ELSE
    BEGIN
    a01_call_put (acv, a34, cak_i_drop, put_node);
    a03_aunsigned_integer (acv, acv.a_ap_tree^[put_node].n_sa_level, last_n)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_dbfunc (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
 
BEGIN
acv.a_is_ddl := ddl_drop_procedure;
a01_call_put (acv, a264, cak_i_drop, put_node);
a01_next_symbol (acv);
a02_put_identifier  (acv,
      acv.a_ap_tree^[ put_node ].n_lo_level, last_n)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_view (
            VAR acv      : tak_all_command_glob;
            kw_index     : integer;
            VAR put_node : tsp00_Int2);
 
VAR
      res_kw   : boolean;
      last_n   : tsp00_Int2;
      ref_n    : tsp00_Int2;
      kw       : integer;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_call_put (acv, a11, cak_x_drop_view, put_node);
    a_ap_tree^[put_node].n_length :=  kw_index;
    a_is_ddl := ddl_drop_view;
    a01_next_symbol (acv);
    a02_atablename (acv, a_ap_tree^[ put_node ].n_lo_level, last_n);
    IF  (sc_symb <> s_eof) AND (a_sqlmode in [sqlm_internal, sqlm_ansi])
    THEN
        BEGIN
        a01_get_keyword (acv, kw, res_kw);
        IF  (kw = cak_i_cascade) OR (kw = cak_i_restrict)
        THEN
            BEGIN
            a01_call_put (acv, a11, kw, last_n);
            a_ap_tree^[put_node].n_sa_level := last_n;
            a01_next_symbol (acv);
            END;
        (*ENDIF*) 
        END;
    (* PTS 1111432 *)
    (*ENDIF*) 
    last_n := put_node;
    IF  sc_symb <> s_eof
    THEN
        IF  a01_eqkey (a01kw[cak_i_no], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            a01_next_symbol(acv);
            IF  a01mandatory_keyword (acv, cak_i_references)
            THEN
                BEGIN
                a01_call_put (acv, a11, kw_index, ref_n);
                a_ap_tree^[last_n].n_sa_level := ref_n;
                a_ap_tree^[ref_n ].n_length   := cak_i_no;
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20adata_type (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            isDBFunction  : boolean;
            keyw          : integer);
 
VAR
      is_invalid  : boolean;
      code_spec   : boolean;
      is_ddl      : tak_ddl_descriptor;
      curr_n      : tsp00_Int2;
      sypos_save  : tsp00_Int2;
      symb_save   : tak_sc_symbol;
      symb        : tak_sc_symbol;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        sypos_save := sc_sypos;
        a01_next_symbol (acv);
        symb_save  := sc_symb;
        is_invalid := false;
        CASE keyw  OF
            cak_i_nchar :
                IF  (a_sqlmode = sqlm_internal) AND
                    g01unicode
                THEN
                    ak20integer_datatype (acv,
                          put_node, last_node, cak_i_nchar, s_character)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_boolean :
                BEGIN
                sc_symb := s_boolean;
                a01_put_node (acv, put_node);
                last_node := put_node;
                sc_symb   := symb_save;
                END;
            cak_i_char, cak_i_character :
                ak20integer_datatype (acv, put_node,
                      last_node, cak_i_char, s_character);
            cak_i_date :
                BEGIN
                IF  a_sqlmode = sqlm_ansi
                THEN
                    is_invalid := true
                ELSE
                    IF  a_sqlmode = sqlm_oracle
                    THEN
                        (* PTS 1000313 E.Z. *)
                        (* PTS 1105820 E.Z. *)
                        sc_symb := s_timestamp
                    ELSE
                        sc_symb := s_date;
                    (*ENDIF*) 
                (*ENDIF*) 
                a01_put_node (acv, put_node);
                last_node := put_node;
                sc_symb   := symb_save;
                END;
            cak_i_dec, cak_i_decimal, cak_i_fixed, cak_i_zoned,
            cak_i_packed, cak_i_binary, cak_i_numeric :
                ak20fixed_data  (acv, put_node,
                      last_node, is_invalid, keyw);
            cak_i_double :
                BEGIN
                IF  a01_eqkey (a01kw[ cak_i_precision ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    sc_symb := s_double_precision;
                    a01_put_node (acv, put_node);
                    last_node := put_node;
                    sc_symb   := symb_save;
                    a01_next_symbol (acv);
                    END
                ELSE
                    is_invalid := true
                (*ENDIF*) 
                END;
            cak_i_graphic :
                IF  a_sqlmode = sqlm_db2
                THEN
                    ak20integer_datatype (acv, put_node,
                          last_node, cak_i_graphic, s_graphic)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_long, cak_i_longfile :
                BEGIN
                code_spec := false;
                symb      := s_unknown;
                IF  a_sqlmode = sqlm_ansi
                THEN
                    is_invalid := true
                ELSE
                    IF  a_sqlmode = sqlm_db2
                    THEN
                        BEGIN
                        IF  a01_eqkey (a01kw[ cak_i_varchar ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv)
                        THEN
                            sc_symb := s_long_varchar
                        ELSE
                            IF  a01_eqkey (a01kw[ cak_i_vargraphic ], a_sqlmode,
                                a_cmd_part^.sp1p_buf, a_scv)
                            THEN
                                sc_symb := s_long_vargraphic
                            ELSE
                                is_invalid := true;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        IF  a01_eqkey (a01kw[ cak_i_raw ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv)
                            AND (a_sqlmode = sqlm_oracle)
                        THEN
                            BEGIN
                            a01_next_symbol (acv);
                            symb_save := sc_symb;
                            symb      := s_byte
                            END
                        ELSE
                            BEGIN
                            IF  a01_eqkey (a01kw[ cak_i_varchar ], a_sqlmode,
                                a_cmd_part^.sp1p_buf, a_scv)
                            THEN
                                BEGIN
                                a01_next_symbol (acv);
                                symb_save := sc_symb
                                END;
                            (*ENDIF*) 
                            code_spec := true
                            END;
                        (*ENDIF*) 
                        IF  keyw = cak_i_longfile
                        THEN
                            sc_symb := s_file
                        ELSE
                            sc_symb := s_old_long;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  NOT is_invalid
                THEN
                    BEGIN
                    a01_put_node (acv, put_node);
                    a_ap_tree^[ put_node ].n_length := ord(symb);
                    last_node := put_node;
                    curr_n    := put_node;
                    IF  (sc_symb = s_long_varchar) OR
                        (sc_symb = s_long_vargraphic)
                    THEN
                        a01_next_symbol (acv)
                    ELSE
                        BEGIN
                        sc_symb   := symb_save;
                        IF  code_spec AND
                            ((a_sqlmode = sqlm_internal) OR g01glob.db_is_for_sapr3)
                        THEN
                            BEGIN
                            is_ddl := acv.a_is_ddl;
                            acv.a_is_ddl := no_ddl; (* allow code spec *)
                            ak20acode_spec (acv, curr_n);
                            acv.a_is_ddl := is_ddl;
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            cak_i_raw :
                IF  a_sqlmode = sqlm_oracle
                THEN
                    BEGIN
                    (* PTS 1122344 E.Z. *)
                    ak20integer_datatype (acv, put_node,
                          last_node, cak_i_raw, s_character);
                    a_ap_tree^[ put_node ].n_length := ord (s_byte)
                    END
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_float :
                ak20integer_datatype (acv, put_node,
                      last_node, keyw, s_float);
            cak_i_int, cak_i_integer :
                BEGIN
                sc_symb := s_integer;
                a01_put_node (acv, put_node);
                last_node := put_node;
                sc_symb   := symb_save;
                END;
            cak_i_number :
                IF  isDBFunction
                THEN
                    BEGIN
                    sc_symb := s_number;
                    a01_put_node (acv, put_node);
                    last_node := put_node;
                    sc_symb   := symb_save;
                    END
                ELSE
                    IF  a_sqlmode = sqlm_oracle
                    THEN
                        ak20fixed_data  (acv, put_node,
                              last_node, is_invalid, cak_i_number)
                    ELSE
                        is_invalid := true;
                    (*ENDIF*) 
                (*ENDIF*) 
            cak_i_real :
                ak20integer_datatype (acv, put_node,
                      last_node, keyw, s_real);
            cak_i_rowid :
                IF  (a_sqlmode = sqlm_oracle)
                THEN
                    BEGIN
                    sc_symb := s_rowid;
                    a01_put_node (acv, put_node);
                    last_node := put_node;
                    sc_symb   := symb_save
                    END
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_smallint :
                BEGIN
                sc_symb := s_smallint;
                a01_put_node (acv, put_node);
                last_node := put_node;
                sc_symb   := symb_save;
                END;
            cak_i_serial :
                IF  a_sqlmode = sqlm_internal
                THEN
                    ak20serial_datatype (acv, put_node, last_node)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_time :
                IF  (a_sqlmode = sqlm_db2) OR
                    (a_sqlmode = sqlm_internal)
                THEN
                    BEGIN
                    sc_symb := s_time;
                    a01_put_node (acv, put_node);
                    last_node := put_node;
                    sc_symb   := symb_save;
                    END
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_timestamp :
                IF  (a_sqlmode = sqlm_db2) OR
                    (a_sqlmode = sqlm_internal)
                THEN
                    BEGIN
                    sc_symb := s_timestamp;
                    a01_put_node (acv, put_node);
                    last_node := put_node;
                    sc_symb   := symb_save;
                    END
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            cak_i_varchar, cak_i_varchar2 :
                IF  (a_sqlmode = sqlm_ansi)
                    OR
                    ((a_sqlmode <> sqlm_oracle) AND
                    ( keyw = cak_i_varchar2))
                THEN
                    is_invalid := true
                ELSE
                    IF  isDBFunction
                    THEN
                        BEGIN
                        sc_symb := s_varchar;
                        a01_put_node (acv, put_node);
                        acv.a_ap_tree^[put_node].n_pos := -1;
                        last_node := put_node;
                        sc_symb   := symb_save;
                        ak20acode_spec (acv, last_node)
                        END
                    ELSE
                        ak20integer_datatype (acv, put_node,
                              last_node, cak_i_varchar, s_varchar);
                    (*ENDIF*) 
                (*ENDIF*) 
            cak_i_vargraphic :
                IF  a_sqlmode = sqlm_db2
                THEN
                    ak20integer_datatype (acv, put_node,
                          last_node, cak_i_vargraphic, s_vargraphic)
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            OTHERWISE
                is_invalid := true;
            END;
        (*ENDCASE*) 
        IF  is_invalid
        THEN
            a07_b_put_error (acv, e_invalid_datatype, sypos_save)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20acode_spec (
            VAR acv   : tak_all_command_glob;
            put_node  : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  a01_eqkey (a01kw[ cak_i_ascii ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            a_ap_tree^[ put_node ].n_length := ord(s_ascii)
        ELSE
            (* PTS 1122828 E.Z. *)
            IF  a01_eqkey (a01kw[ cak_i_byte ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                a_ap_tree^[ put_node ].n_length := ord(s_byte)
            ELSE
                IF  a01_eqkey (a01kw[ cak_i_unicode ], a_sqlmode,
                    a_cmd_part^.sp1p_buf,
                    a_scv)
                THEN
                    a_ap_tree^[ put_node ].n_length := ord(s_unicode)
                ELSE
                    a_ap_tree^[ put_node ].n_length := ord(s_unknown);
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a_ap_tree^[ put_node ].n_length <> ord (s_unknown)
        THEN
            IF  ((a_sqlmode <> sqlm_internal) AND
                NOT g01glob.db_is_for_sapr3)
                OR
                ((a_is_ddl in [ddl_create_dbfunc, ddl_create_procedure, ddl_create_trigger]) AND
                (a_ap_tree^[ put_node ].n_length <> ord(s_byte)))
            THEN
                a07_error (acv, e_invalid_keyword, put_node, put_node)
            ELSE
                a01_next_symbol (acv)
            (*ENDIF*) 
        ELSE
            IF  g01unicode
                AND
                (a_is_ddl in [ddl_create_dbfunc, ddl_create_procedure, ddl_create_trigger])
            THEN
                a_ap_tree^[ put_node ].n_length := ord(s_unicode)
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20default_val_spec (
            VAR acv        : tak_all_command_glob;
            VAR put_node   : tsp00_Int2;
            VAR last_node  : tsp00_Int2);
 
VAR
      res_kw      : boolean;
      is_function : boolean;
      skip        : boolean;
      kw_index    : integer;
      curr_n      : tsp00_Int2;
      last_n      : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        IF  a01_eqkey (a01kw[ cak_i_default ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            is_function := false;
            skip        := false;
            a01_next_symbol (acv);
            a01_get_keyword (acv, kw_index, res_kw);
            CASE kw_index OF
                cak_i_true :
                    IF  a_sqlmode = sqlm_internal
                    THEN
                        is_function := true;
                    (*ENDIF*) 
                cak_i_false :
                    IF  a_sqlmode = sqlm_internal
                    THEN
                        is_function := true;
                    (*ENDIF*) 
                cak_i_null :
                    IF  a_is_ddl = ddl_create_table
                    THEN
                        BEGIN
                        skip := true;
                        a01_next_symbol (acv)
                        END
                    ELSE
                        IF  (a_is_ddl <> ddl_create_table) AND
                            (a_sqlmode in [sqlm_internal, sqlm_oracle])
                        THEN
                            is_function := true;
                        (*ENDIF*) 
                    (*ENDIF*) 
                cak_i_user :
                    IF  a_sqlmode in [ sqlm_internal, sqlm_ansi, sqlm_oracle ]
                    THEN
                        is_function := true;
                    (*ENDIF*) 
                cak_i_date :
                    (* PTS 1000313 E.Z. *)
                    (* PTS 1105820 E.Z. *)
                    IF  a_sqlmode = sqlm_internal
                    THEN
                        is_function := true;
                    (* PTS 1105319 E.Z. *)
                    (*ENDIF*) 
                cak_i_stamp :
                    IF  a_sqlmode in [ sqlm_internal, sqlm_oracle ]
                    THEN
                        is_function := true;
                    (*ENDIF*) 
                cak_i_time,
                cak_i_usergroup, cak_i_timestamp :
                    IF  a_sqlmode = sqlm_internal
                    THEN
                        is_function := true;
                    (*ENDIF*) 
                cak_i_sysdate :
                    IF  a_sqlmode = sqlm_oracle
                    THEN
                        BEGIN
                        kw_index    := cak_i_timestamp;
                        is_function := true
                        END;
                    (*ENDIF*) 
                cak_i_serial :
                    IF  a_sqlmode = sqlm_internal
                    THEN
                        is_function := true;
                    (*ENDIF*) 
                cak_i_transaction :
                    IF  a_sqlmode = sqlm_internal
                    THEN
                        BEGIN
                        kw_index    := cak_i_transaction;
                        is_function := true
                        END;
                    (*ENDIF*) 
                cak_i_uid :
                    (* h.b. PTS 1103055 *)
                    IF  a_sqlmode in [ sqlm_internal, sqlm_oracle ]
                    THEN
                        BEGIN
                        kw_index    := cak_i_uid;
                        is_function := true
                        END;
                    (* PTS 1122484 E.Z. *)
                    (*ENDIF*) 
                cak_i_utcdate, cak_i_utcdiff,
                cak_i_timezone, cak_i_sysdba :
                    IF  a_sqlmode = sqlm_internal
                    THEN
                        is_function := true;
                    (*ENDIF*) 
                OTHERWISE ;
                END;
            (*ENDCASE*) 
            IF  NOT skip
            THEN
                BEGIN
                a01_call_put (acv, a14, cak_x_default_def, curr_n);
                put_node  := curr_n;
                last_node := curr_n;
                IF  is_function
                THEN
                    BEGIN
                    a01_call_put (acv, a14, kw_index, last_n);
                    a_ap_tree^[ curr_n ].n_lo_level := last_n;
                    a01_next_symbol (acv);
                    IF  kw_index = cak_i_serial
                    THEN
                        ak20serial_datatype (acv,
                              a_ap_tree^[last_n].n_lo_level, last_n)
                    (*ENDIF*) 
                    END
                ELSE
                    a03_aliteral (acv,
                          a_ap_tree^[ curr_n ].n_lo_level, last_n)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20rel30_range (
            VAR acv       : tak_all_command_glob;
            col_node      : tsp00_Int2;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      notexist   : boolean;
      constraint : boolean;
      curr_n     : tsp00_Int2;
      last_n     : tsp00_Int2;
      first_n    : tsp00_Int2;
      info_n     : tsp00_Int2;
      aux_scv    : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        IF  a01_eqkey (a01kw[ cak_i_range ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
            AND
            ((a_is_ddl = ddl_create_table)  OR
            ( a_is_ddl = ddl_create_domain) OR
            ( a_is_ddl = ddl_alter_tab_add))
        THEN
            BEGIN
            (* Rel 2.4 range defintion, map to new representation *)
            a01_next_symbol (acv);
            a20info_node (acv, a64, sc_sypos, first_n, info_n);
            put_node := first_n;
            last_n   := first_n;
            IF  a01_eqkey (a01kw[ cak_i_not ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                notexist := true;
                a01_next_symbol (acv)
                END
            ELSE
                notexist := false;
            (*ENDIF*) 
            IF  a01_eqkey (a01kw[ cak_i_in ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN (* RANGE /NOT/ IN (<value list>) *)
                IF  notexist
                THEN
                    BEGIN
                    sc_symb                         := s_not;
                    a01_put_node (acv, curr_n);
                    a_ap_tree^[ first_n ].n_lo_level := curr_n;
                    last_n                          := curr_n
                    END;
                (*ENDIF*) 
                a01_call_put (acv, a64, cak_x_in_pred, curr_n);
                a_ap_tree^[ curr_n ].n_symb := s_in;
                IF  notexist
                THEN
                    a_ap_tree^[ last_n ].n_sa_level := curr_n
                ELSE
                    a_ap_tree^[ last_n ].n_lo_level := curr_n;
                (*ENDIF*) 
                last_n := curr_n;
                a01_next_symbol (acv);
                a01_force_symbol (acv,
                      s_leftpar, put_node, last_node);
                a01_call_put (acv, a64, cak_x_in_pred, curr_n);
                a_ap_tree^[ curr_n ] := a_ap_tree^[ col_node ];
                a_ap_tree^[ curr_n ].n_symb     := s_columnname;
                a_ap_tree^[ curr_n ].n_sa_level := 0;
                a_ap_tree^[ last_n ].n_lo_level := curr_n;
                last_n := curr_n;
                a01_call_put (acv, a64, cak_x_in_pred_list, curr_n);
                a_ap_tree^[ last_n ].n_sa_level := curr_n;
                a03_l_aexpression_list (acv,
                      a_ap_tree^[ curr_n ].n_lo_level, last_n);
                a01_force_symbol (acv, s_rightpar, put_node, last_node)
                END
            ELSE  (* RANGE /NOT/ BETWEEN <lwb> AND <upb> *)
                IF  a01mandatory_keyword (acv, cak_i_between)
                THEN
                    BEGIN
                    a01_call_put (acv, a64, cak_x_between_pred, curr_n);
                    IF  notexist
                    THEN
                        a_ap_tree^[ curr_n ].n_symb := s_notbetween
                    ELSE
                        a_ap_tree^[ curr_n ].n_symb := s_between;
                    (*ENDIF*) 
                    a_ap_tree^[ last_n ].n_lo_level := curr_n;
                    last_n := curr_n;
                    a01_call_put (acv, a64, cak_x_between_pred, curr_n);
                    a_ap_tree^[ curr_n ] := a_ap_tree^[ col_node ];
                    a_ap_tree^[ curr_n ].n_symb     := s_columnname;
                    a_ap_tree^[ curr_n ].n_sa_level := 0;
                    a_ap_tree^[ curr_n ].n_lo_level := 0;
                    a_ap_tree^[ last_n ].n_lo_level := curr_n;
                    a03_aliteral (acv,a_ap_tree^[ curr_n ].n_sa_level,
                          last_n);
                    IF  a01mandatory_keyword (acv, cak_i_and)
                    THEN
                        a03_aliteral (acv,
                              a_ap_tree^[ last_n ].n_sa_level,
                              last_n)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            WITH a_ap_tree^[ info_n ] DO
                BEGIN
                IF  sc_symb = s_eof
                THEN
                    BEGIN
                    n_pos := a_cmd_part^.sp1p_buf_len;
                    WHILE a01is_whitespace_char (a_cmd_part^.sp1p_buf,
                          n_pos - a01char_size + 1) DO
                        n_pos := n_pos - a01char_size
                    (*ENDWHILE*) 
                    END
                ELSE
                    n_pos := sc_sypos - 1
                (*ENDIF*) 
                END
            (*ENDWITH*) 
            END
        ELSE  (* REL 3.x.x constraint definition *)
            BEGIN
            constraint := false;
            IF  a01_eqkey (a01kw[ cak_i_constraint], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                constraint := true;
                aux_scv    := a_scv;
                a01_next_symbol (acv);
                IF  sc_symb = s_identifier
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    IF  NOT (a01_eqkey (a01kw[ cak_i_check ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv))
                    THEN
                        a_scv := aux_scv
                    ELSE
                        IF  a_is_ddl = ddl_create_domain
                        THEN
                            a07_error (acv, e_invalid_keyword,
                                  put_node, last_node)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    a_scv := aux_scv
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a01_eqkey (a01kw[ cak_i_check ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
                OR constraint
            THEN
                BEGIN
                a20info_node (acv, a63,
                      sc_sypos + sc_sylength, curr_n, info_n);
                put_node := curr_n;
                a_ap_tree^[put_node].n_pos := sc_sypos + sc_sylength;
                a01_next_symbol (acv);
                a_rowno_allowed   := false;
                a_rowno_found     := false;
                a_allow_functions := tf_unknown;
                a_from_select     := false;
                a63_asearch_condition (acv,
                      a_ap_tree^[ curr_n ].n_lo_level, last_node);
                WITH a_ap_tree^[ info_n ] DO
                    BEGIN
                    IF  sc_symb = s_eof
                    THEN
                        BEGIN
                        n_pos := a_cmd_part^.sp1p_buf_len;
                        WHILE a01is_whitespace_char (a_cmd_part^.sp1p_buf,
                              n_pos - a01char_size + 1) DO
                            n_pos := n_pos - a01char_size
                        (*ENDWHILE*) 
                        END
                    ELSE
                        n_pos := sc_sypos - 1
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20info_node (
            VAR acv    : tak_all_command_glob;
            proc       : tak_procs;
            subproc    : tsp00_Int2;
            VAR curr_n : tsp00_Int2;
            VAR info_n : tsp00_Int2);
 
VAR
      do_opt : boolean;
      is_ddl : tak_ddl_descriptor;
 
BEGIN
is_ddl                            := acv.a_is_ddl;
do_opt                            := acv.a_optimize_info.o_do_optimize;
acv.a_is_ddl                      := no_ddl;
acv.a_optimize_info.o_do_optimize := true;
a01info_call_put (acv, proc, subproc, curr_n, info_n);
acv.a_is_ddl                      := is_ddl;
acv.a_optimize_info.o_do_optimize := do_opt
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20integer_datatype   (
            VAR acv          : tak_all_command_glob;
            VAR put_node     : tsp00_Int2;
            VAR last_node    : tsp00_Int2;
            kw_index         : integer;
            symb             : tak_sc_symbol);
 
VAR
      allow_codespec : boolean;
      curr_n         : tsp00_Int2;
      last_n         : tsp00_Int2;
      save_symb      : tak_sc_symbol;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  (symb = s_varchar)
            OR
            ((symb = s_character)         AND
            ( kw_index <> cak_i_nchar)    AND
            ( kw_index <> cak_i_raw))
        THEN
            allow_codespec := true
        ELSE
            allow_codespec := false;
        (*ENDIF*) 
        IF  sc_symb <> s_leftpar
        THEN
            BEGIN
            save_symb := sc_symb;
            sc_symb   := symb;
            a01_put_node (acv, curr_n);
            put_node  := curr_n;
            last_node := curr_n;
            sc_symb   := save_symb;
            IF  allow_codespec
                AND
                (sc_symb = s_identifier)
                AND
                ((a01_eqkey (a01kw[cak_i_ascii], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)) OR
                ( a01_eqkey (a01kw[cak_i_byte], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)) OR
                ( a01_eqkey (a01kw[cak_i_unicode], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)))
            THEN
                BEGIN
                ak20acode_spec (acv, curr_n);
                allow_codespec := false;
                IF  sc_symb = s_leftpar
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    a03_aunsigned_integer (acv,
                          a_ap_tree^[ curr_n ].n_lo_level, last_n);
                    a01_force_symbol (acv, s_rightpar, put_node, last_node)
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            sc_symb   := symb;
            a01_put_node (acv, curr_n);
            put_node  := curr_n;
            last_node := curr_n;
            a01_next_symbol (acv);
            IF  (sc_symb   = s_asterisk)  AND
                (a_sqlmode = sqlm_oracle) AND
                (kw_index  = cak_i_float)
            THEN
                BEGIN
                a01_put_node (acv, last_n);
                a_ap_tree^[ curr_n ].n_lo_level := last_n;
                a01_next_symbol (acv)
                END
            ELSE
                a03_aunsigned_integer (acv,
                      a_ap_tree^[ curr_n ].n_lo_level, last_n);
            (*ENDIF*) 
            a01_force_symbol (acv, s_rightpar, put_node, last_node)
            END;
        (*ENDIF*) 
        IF  allow_codespec
        THEN
            ak20acode_spec (acv, curr_n)
        ELSE
            IF  ((symb = s_character) AND (kw_index = cak_i_nchar))
            THEN
                a_ap_tree^[ curr_n ].n_length := ord(s_unicode)
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20fixed_data   (
            VAR acv        : tak_all_command_glob;
            VAR put_node   : tsp00_Int2;
            VAR last_node  : tsp00_Int2;
            VAR is_invalid : boolean;
            kw_index       : integer);
 
VAR
      curr_n : tsp00_Int2;
      last_n : tsp00_Int2;
      symb   : tak_sc_symbol;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        symb := sc_symb;
        CASE kw_index OF
            cak_i_fixed :
                IF  a_sqlmode = sqlm_internal
                THEN
                    sc_symb := s_fixed
                ELSE
                    is_invalid := true;
                (*ENDIF*) 
            (* PTS 1114081 E.Z. *)
            cak_i_numeric,
            cak_i_dec, cak_i_decimal, cak_i_number :
                sc_symb := s_fixed;
            cak_i_zoned  :
                sc_symb := s_vs_zoned;
            cak_i_packed :
                sc_symb := s_packed;
            cak_i_binary :
                sc_symb := s_binary;
            END;
        (*ENDCASE*) 
        a01_put_node (acv, curr_n);
        sc_symb   := symb;
        put_node  := curr_n;
        last_node := curr_n;
        IF  symb <> s_leftpar
        THEN
            BEGIN
            IF  kw_index = cak_i_number
            THEN
                a_ap_tree^[ curr_n ].n_symb := s_float
            ELSE
                IF  (kw_index <> cak_i_decimal) AND
                    (kw_index <> cak_i_dec)     AND
                    (kw_index <> cak_i_fixed)   AND
                    (kw_index <> cak_i_numeric)
                THEN
                    a07_error (acv,e_wanted_keyword, put_node, last_node)
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            a01_next_symbol (acv);
            IF  (sc_symb   = s_asterisk   ) AND
                ((kw_index = cak_i_dec   ) OR (kw_index = cak_i_decimal) OR
                ( kw_index = cak_i_number) OR (kw_index = cak_i_numeric))
                AND
                (a_sqlmode = sqlm_oracle)
            THEN
                BEGIN
                a01_put_node (acv, last_n);
                a_ap_tree^[ curr_n ].n_lo_level := last_n;
                a01_next_symbol (acv);
                IF  (sc_symb <> s_comma) AND (kw_index = cak_i_number)
                THEN
                    a_ap_tree^[ curr_n ].n_symb := s_float
                (*ENDIF*) 
                END
            ELSE
                a03_aunsigned_integer (acv,
                      a_ap_tree^[ curr_n ].n_lo_level, last_n);
            (*ENDIF*) 
            IF  sc_symb = s_rightpar
            THEN
                a01_next_symbol (acv)
            ELSE
                BEGIN
                a01_force_symbol (acv, s_comma, put_node, last_node);
                a03_aunsigned_integer (acv,
                      a_ap_tree^[ last_n ].n_sa_level,last_n);
                a01_force_symbol (acv, s_rightpar, put_node, last_node)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20serial_datatype (
            VAR acv        : tak_all_command_glob;
            VAR put_node   : tsp00_Int2;
            VAR last_node  : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
      symb   : tak_sc_symbol;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    symb    := sc_symb;
    sc_symb := s_serial;
    a01_put_node (acv, put_node);
    sc_symb   := symb;
    IF  symb = s_leftpar
    THEN
        BEGIN
        a01_next_symbol (acv);
        a01_call_put (acv, a23, cak_i_start, curr_n);
        a_ap_tree^[put_node].n_lo_level := curr_n;
        a03_aunsigned_integer (acv,
              a_ap_tree^[curr_n].n_lo_level, last_node);
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END;
    (*ENDIF*) 
    last_node := put_node
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20alter_table_statement (
            VAR acv            : tak_all_command_glob;
            VAR put_node       : tsp00_Int2;
            isDiagnose         : boolean);
 
VAR
      ok      : boolean;
      kwindex : integer;
      res_kw  : boolean;
      last_n  : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  NOT isDiagnose
    THEN
        BEGIN
        a01_compact_cmd (acv);
        IF  a_returncode = 0
        THEN
            BEGIN
            sc_newpos := 1;
            a01_next_symbol (acv);
            a01_next_symbol (acv);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a_is_ddl := ddl_alter_table;
        IF  a_ex_kind = pars_then_execute
        THEN
            a_ex_kind := parsing_executing;
        (*ENDIF*) 
        a01_call_put (acv, a13, x_alter, put_node);
        a_ap_tree^[put_node].n_length := 0;
        a01_next_symbol (acv);
        a02_atablename (acv, a_ap_tree^[ put_node ].n_lo_level, last_n);
        a01_get_keyword (acv, kwindex, res_kw);
        ok := (a_sqlmode = sqlm_internal) OR g01glob.db_is_for_sapr3;
        WITH a_ap_tree^[ last_n ] DO
            CASE kwindex  OF
                cak_i_add :
                    BEGIN
                    ok := true;
                    ak20add_definition (acv, n_sa_level)
                    END;
                cak_i_bad :
                    IF  isDiagnose
                    THEN
                        BEGIN
                        a01_call_put (acv, a13, cak_x_alter_bad, n_sa_level);
                        a01_next_symbol (acv);
                        END
                    ELSE
                        ok := false;
                    (*ENDIF*) 
                cak_i_alter :
                    IF  ok
                    THEN
                        ak20alter_constraint_or_key (acv, n_sa_level);
                    (*ENDIF*) 
                cak_i_cluster :
                    IF  ok
                    THEN
                        ak20cluster_definition (acv, n_sa_level);
                    (*ENDIF*) 
                cak_i_column :
                    IF  ok
                    THEN
                        ak20alter_definition (acv, n_sa_level);
                    (*ENDIF*) 
                cak_i_drop :
                    BEGIN
                    ok := ok OR (a_sqlmode = sqlm_oracle);
                    IF  ok
                    THEN
                        ak20drop_definition (acv, n_sa_level);
                    (*ENDIF*) 
                    END;
                cak_i_set :                                            (* PTS: 1117847 *)
                    BEGIN
                    ok := (a_sqlmode = sqlm_oracle);
                    IF  ok
                    THEN
                        BEGIN
                        a01_next_symbol (acv);
                        a01_get_keyword (acv, kwindex, res_kw);
                        IF  kwindex = cak_i_unused
                        THEN
                            ak20drop_definition (acv, n_sa_level)
                        ELSE
                            ok := false;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                cak_i_dynamic, cak_i_not,
                cak_i_fact, cak_i_dimension,
                cak_i_bwhierarchy :
                    IF  ok
                    THEN
                        ak20dynamic_and_attribute_definition (acv,
                              kwindex, n_sa_level);
                    (*ENDIF*) 
                cak_i_foreign :
                    IF  ok
                    THEN
                        ak20alter_fk_definition (acv, 0);
                    (*ENDIF*) 
                cak_i_modify :
                    IF  a_sqlmode in [sqlm_oracle, sqlm_internal]
                    THEN
                        BEGIN
                        ok := true;
                        ak20modify_definition (acv, n_sa_level)
                        END
                    ELSE
                        ok := false;
                    (*ENDIF*) 
                cak_i_sample :
                    IF  ok
                    THEN
                        ak20sample_definition (acv, n_sa_level);
                    (*ENDIF*) 
                cak_i_type :
                    ak20table_type_definition (acv, n_sa_level); (* PTS 1105802 *)
                OTHERWISE
                    ok := false
                END;
            (*ENDCASE*) 
        (*ENDWITH*) 
        IF  isDiagnose AND (kwindex <> cak_i_bad)
        THEN
            ok := false;
        (*ENDIF*) 
        IF  NOT ok
        THEN
            a07_error (acv, e_wanted_keyword,
                  last_n, last_n);
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20add_definition (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2);
 
VAR
      res_kw          : boolean;
      add_constraint  : boolean;
      left_par        : boolean;
      constraint_node : tsp00_Int2;
      curr_n          : tsp00_Int2;
      last_n          : tsp00_Int2;
      dummy           : tsp00_Int2;
      ikw             : integer;
      aux_scv         : tak_scanner_glob;
      error_scv       : tak_scanner_glob;
      allow_disable   : boolean;
      found           : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    allow_disable := false;
    found         := true;
    a01_next_symbol (acv);
    error_scv := a_scv;
    IF  sc_symb = s_leftpar
    THEN
        BEGIN
        left_par := true;
        a01_next_symbol (acv)
        END
    ELSE
        left_par := false;
    (*ENDIF*) 
    a01_get_keyword (acv, ikw, res_kw);
    IF  left_par AND (a_sqlmode <> sqlm_oracle)
        AND
        ((ikw = cak_i_check       ) OR
        ( ikw = cak_i_constraint  ) OR
        ( ikw = cak_i_foreign     ) OR
        ( ikw = cak_i_primary     ))
    THEN
        BEGIN
        a_scv := error_scv;
        a07_error (acv, e_invalid_keyword, put_node, last_n)
        END;
    (*ENDIF*) 
    CASE ikw OF
        cak_i_check, cak_i_constraint :
            BEGIN (* add constraint *)
            add_constraint := true;
            (* PTS 1112166 M.Ki *)
            IF  ((a_sqlmode = sqlm_oracle) OR (a_sqlmode = sqlm_internal))
                AND
                (ikw = cak_i_constraint)
            THEN
                BEGIN
                (* ORACLE 7 constraint syntax *)
                add_constraint := false;
                allow_disable  := true;
                aux_scv := a_scv;
                a01_next_symbol (acv);
                a02_put_identifier  (acv,
                      constraint_node, constraint_node);
                a01_get_keyword (acv, ikw, res_kw);
                CASE ikw OF
                    cak_i_foreign :
                        ak20alter_fk_definition (acv, constraint_node);
                    cak_i_primary :
                        BEGIN
                        acv.a_is_ddl := ddl_alter_key;
                        a01_call_put (acv, a13,
                              cak_x_primary_key, put_node);
                        a_ap_tree^[put_node].n_length := cak_i_add;
                        ak20key_spec (acv,
                              a_ap_tree^[put_node].n_sa_level,
                              last_n, found)
                        END;
                    cak_i_unique :
                        ak20add_unique (acv, put_node, constraint_node)
                    OTHERWISE
                        BEGIN
                        a_scv          := aux_scv;
                        add_constraint := true
                        END;
                    END;
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
            IF  add_constraint
            THEN
                BEGIN
                a_is_ddl := ddl_alter_tab_alter;
                a01_call_put (acv, a13,
                      cak_x_add_constraint, put_node);
                ak20check_clause (acv, cak_i_constraint, false, 0, 0,
                      a_ap_tree^[ put_node ].n_sa_level, last_n)
                END
            (*ENDIF*) 
            END;
        cak_i_foreign :
            IF  (a_sqlmode = sqlm_oracle) OR
                (a_sqlmode = sqlm_internal)
            THEN
                BEGIN
                allow_disable := a_sqlmode = sqlm_oracle;
                ak20alter_fk_definition (acv, 0)
                END
            ELSE
                a07_error (acv, e_wanted_keyword, put_node, last_n);
            (*ENDIF*) 
        cak_i_primary :
            BEGIN
            allow_disable := a_sqlmode = sqlm_oracle;
            acv.a_is_ddl  := ddl_alter_key;
            a01_call_put (acv, a13, cak_x_primary_key, put_node);
            a_ap_tree^[put_node].n_length := cak_i_add;
            ak20key_spec (acv,
                  acv.a_ap_tree^[put_node].n_sa_level, last_n, found);
            IF  a01_eqkey (a01kw[cak_i_constraint], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
                AND (a_sqlmode = sqlm_oracle) AND found
            THEN
                BEGIN
                a01_next_symbol (acv);
                a02_put_identifier (acv, dummy, last_n)
                END;
            (*ENDIF*) 
            END;
        cak_i_unique :
            IF  a_sqlmode = sqlm_oracle
            THEN
                ak20add_unique (acv, put_node, 0)
            ELSE
                a07_error (acv, e_wanted_keyword, put_node, last_n);
            (*ENDIF*) 
        OTHERWISE
            BEGIN (* add <column definition list> *)
            a_is_ddl := ddl_alter_tab_add;
            a01_call_put (acv, a13, cak_x_alter_add, curr_n);
            put_node := curr_n;
            IF  left_par
            THEN
                ak20column_l_definition_list (acv, c_datatype_required,
                      a_ap_tree^[ curr_n ].n_lo_level, last_n)
            ELSE
                IF  a_sqlmode = sqlm_oracle
                THEN
                    (* PTS 1105366 E.Z. *)
                    ak20column_definition (acv, c_datatype_required,
                          a_ap_tree^[ curr_n ].n_lo_level, last_n)
                ELSE
                    ak20column_l_definition_list (acv,
                          c_datatype_required,
                          a_ap_tree^[ curr_n ].n_lo_level, last_n);
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        END;
    (*ENDCASE*) 
    IF  NOT found
    THEN
        a07_error (acv, e_wanted_keyword,
              put_node, last_n)
    ELSE
        BEGIN
        IF  allow_disable
        THEN
            IF  a01_eqkey (a01kw[cak_i_disable], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                a01_next_symbol (acv);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  left_par
        THEN
            a01_force_symbol (acv, s_rightpar, put_node, last_n)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20cluster_definition (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2);
 
VAR
      symb      : tak_sc_symbol;
      last_node : tsp00_Int2;
 
BEGIN
acv.a_is_ddl  := ddl_alter_key;
a01_next_symbol  (acv);
IF  acv.a_scv.sc_symb <> s_leftpar
THEN
    BEGIN
    a01_call_put (acv, a13, cak_x_alter_cluster, put_node);
    acv.a_ap_tree^[put_node].n_length := cak_i_cluster;
    END
ELSE
    BEGIN
    symb := acv.a_scv.sc_symb;
    a01_call_put (acv, a13, cak_x_cluster, put_node);
    acv.a_ap_tree^[put_node].n_length := cak_i_cluster;
    acv.a_scv.sc_symb := s_key;
    a01_put_node (acv, last_node);
    acv.a_scv.sc_symb := symb;
    acv.a_ap_tree^[put_node].n_sa_level := last_node;
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        a02_l_acolumn_list (acv,
              acv.a_ap_tree^[last_node].n_sa_level, last_node);
        a01_force_symbol (acv, s_rightpar, put_node, last_node);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_scv.sc_symb <> s_eof
THEN
    IF  a01mandatory_keyword (acv, cak_i_packed)
    THEN
        acv.a_ap_tree^[put_node].n_length := cak_i_packed;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20add_unique (
            VAR acv         : tak_all_command_glob;
            VAR put_node    : tsp00_Int2;
            constraint_node : tsp00_Int2);
 
VAR
      dummy   : boolean;
      last_n  : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_proc    := a24;
    a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc :=
          cak_x_create_unique_index;
    IF  constraint_node = 0
    THEN
        a01_call_put (acv, a24, 0, constraint_node);
    (*ENDIF*) 
    a_ap_tree^[constraint_node].n_sa_level :=
          a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_lo_level;
    a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_lo_level := constraint_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_n);
    IF  a_returncode = 0
    THEN
        BEGIN
        ak20index_clause (acv, put_node, last_n);
        WHILE sc_symb = s_comma DO
            BEGIN
            a01_next_symbol (acv);
            ak20index_clause (acv,
                  a_ap_tree^[ last_n ].n_sa_level,
                  last_n);
            END;
        (*ENDWHILE*) 
        a01_force_symbol (acv, s_rightpar, put_node, last_n)
        END;
    (*ENDIF*) 
    a_is_ddl := ddl_create_index (* must not be set before *)
          ;                      (* ak20index_clause !!    *)
    ak20using_index_clause (acv, dummy)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20alter_constraint_or_key (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2);
 
VAR
      aux_scv : tak_scanner_glob;
      last_n  : tsp00_Int2;
      found   : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_next_symbol (acv);
    IF  a01_eqkey (a01kw[ cak_i_constraint ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        BEGIN
        a_is_ddl := ddl_alter_tab_alter;
        a01_call_put (acv, a13, cak_x_alter_constraint, put_node);
        a_ap_tree^[ put_node ].n_length := cak_i_alter;
        a01_next_symbol (acv);
        a02_n_acolumnname (acv,
              a_ap_tree^[ put_node ].n_lo_level, last_n);
        aux_scv := a_scv;
        IF  a01mandatory_keyword (acv, cak_i_check)
        THEN
            BEGIN
            a_scv := aux_scv;
            ak20rel30_range (acv, last_n,
                  a_ap_tree^[ last_n ].n_lo_level, last_n)
            END
        (*ENDIF*) 
        END
    ELSE
        IF  a01_eqkey (a01kw[ cak_i_primary ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            acv.a_is_ddl := ddl_alter_key;
            a01_call_put (acv, a13, cak_x_primary_key, put_node);
            a_ap_tree^[put_node].n_length := cak_i_alter;
            ak20key_spec (acv,
                  acv.a_ap_tree^[put_node].n_sa_level, last_n, found);
            IF  NOT found
            THEN
                a07_error (acv, e_wanted_keyword, put_node, last_n)
            ELSE
                IF  a01_eqkey (a01kw[ cak_i_indexname ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    a02_aindexname (acv,
                          a_ap_tree^[put_node].n_lo_level, last_n)
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            a07_error (acv, e_wanted_keyword, put_node, last_n)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20alter_fk_definition (
            VAR acv         : tak_all_command_glob;
            constraint_node : tsp00_Int2);
 
VAR
      curr_node : tsp00_Int2;
      last_node : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl                := ddl_create_link;
    a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_proc    := a25;
    a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc := cak_x_create_link;
    a01_next_symbol (acv);
    IF  a01mandatory_keyword (acv, cak_i_key)
    THEN
        BEGIN
        IF  sc_symb = s_identifier
        THEN
            a02_put_identifier (acv,
                  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_sa_level,
                  curr_node)
        ELSE
            BEGIN
            IF  constraint_node = 0
            THEN
                a01_call_put (acv, a25, 0, constraint_node);
            (*ENDIF*) 
            a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_sa_level := constraint_node;
            curr_node                      := constraint_node
            END;
        (*ENDIF*) 
        a_ap_tree^[ curr_node ].n_lo_level :=
              a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
        last_node := a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
        IF  a_ap_tree^[ last_node ].n_sa_level <> 0
        THEN
            last_node := a_ap_tree^[ last_node ].n_sa_level;
        (*ENDIF*) 
        ak20foreign_key_spec (acv, a_ap_tree^[last_node].n_lo_level,
              last_node, curr_node, 1);
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_definition (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2);
 
VAR
      res_kw   : boolean;
      curr_n   : tsp00_Int2;
      last_n   : tsp00_Int2;
      kw_index : integer;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_alter_tab_drop;
    a01_call_put (acv, a13, cak_x_alter_drop, curr_n);
    a_ap_tree^[curr_n].n_length := 0;
    a_ap_tree^[curr_n].n_pos    := 0;
    put_node := curr_n;
    a01_next_symbol (acv);
    a01_get_keyword (acv, kw_index, res_kw);
    IF  (a_sqlmode = sqlm_oracle      ) AND
        (kw_index  <> cak_i_constraint) AND
        (kw_index  <> cak_i_primary)    AND
        (* PTS 1105929 E.Z. *)
        (kw_index  <> cak_i_column)     AND
        (sc_symb   <> s_leftpar)
    THEN
        a07_error (acv, e_wanted_keyword, put_node, last_n)
    ELSE
        CASE kw_index OF
            cak_i_foreign :
                BEGIN (* alter table .. drop foreign key *)
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_key)
                THEN
                    BEGIN
                    a_is_ddl                  := ddl_drop_link;
                    a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc    := a25;
                    a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc :=
                          cak_x_drop_foreign_key;
                    a02_put_identifier (acv,
                          a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_sa_level, curr_n);
                    IF  sc_symb <> s_eof
                    THEN
                        BEGIN
                        IF  a01_eqkey (a01kw[ cak_i_references ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv)
                        THEN
                            BEGIN
                            a01_next_symbol (acv);
                            a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_subproc := cak_x_drop_link;
                            a02_atablename (acv,
                                  a_ap_tree^[curr_n].n_sa_level, last_n)
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        a_ap_tree^[ curr_n ].n_sa_level :=
                              a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
                    (*ENDIF*) 
                    a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level := 0;
                    END
                (*ENDIF*) 
                END;
            cak_i_constraint :
                BEGIN
                a_ap_tree^[ curr_n ].n_subproc := cak_x_drop_constraint;
                a_ap_tree^[ curr_n ].n_length  := cak_i_drop;
                a01_next_symbol (acv);
                a02_put_identifier  (acv,
                      a_ap_tree^[ curr_n ].n_lo_level, last_n)
                END;
            cak_i_primary :
                BEGIN (* alter table .. drop primary key *)
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_key)
                THEN
                    BEGIN
                    acv.a_is_ddl := ddl_alter_key;
                    a01_call_put (acv,
                          a13, cak_x_primary_key, put_node);
                    a_ap_tree^[put_node].n_length := cak_i_drop;
                    IF  a01_eqkey (a01kw[ cak_i_indexname ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        BEGIN
                        a01_next_symbol (acv);
                        a02_aindexname (acv,
                              a_ap_tree^[put_node].n_lo_level, last_n)
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            cak_i_column :
                BEGIN
                a01_next_symbol (acv);
                a02_n_acolumnname (acv,
                      a_ap_tree^[ curr_n ].n_lo_level, last_n);
                (* PTS 1105929 E.Z. *)
                IF  (sc_symb <> s_eof) AND
                    (a_sqlmode <> sqlm_oracle)
                THEN
                    BEGIN
                    a01_get_keyword (acv, kw_index, res_kw);
                    CASE kw_index OF
                        cak_i_cascade, cak_i_restrict :
                            BEGIN
                            a_ap_tree^[put_node].n_length :=
                                  kw_index;
                            a01_next_symbol (acv)
                            END;
                        OTHERWISE ;
                        END
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
                IF  sc_symb <> s_eof
                THEN
                    IF  a01mandatory_keyword (acv, cak_i_release)
                    THEN
                        IF  a01mandatory_keyword (acv, cak_i_space)
                        THEN
                            a_ap_tree^[put_node].n_pos := cak_i_release;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            OTHERWISE (* alter table .. drop /(/ <column list> /)/ *)
                BEGIN
                IF  sc_symb = s_leftpar
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    a02_l_acolumn_list (acv,
                          a_ap_tree^[ curr_n ].n_lo_level, last_n);
                    a01_force_symbol (acv, s_rightpar, put_node, last_n)
                    END
                ELSE
                    a02_l_acolumn_list (acv,
                          a_ap_tree^[ curr_n ].n_lo_level, last_n);
                (*ENDIF*) 
                (* PTS 1105929 E.Z. *)
                IF  (sc_symb <> s_eof) AND
                    (a_sqlmode <> sqlm_oracle)
                THEN
                    BEGIN
                    a01_get_keyword (acv, kw_index, res_kw);
                    CASE kw_index OF
                        cak_i_cascade, cak_i_restrict :
                            BEGIN
                            a_ap_tree^[put_node].n_length :=
                                  kw_index;
                            a01_next_symbol (acv)
                            END;
                        OTHERWISE ;
                        END
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
                IF  sc_symb <> s_eof
                THEN
                    IF  a01mandatory_keyword (acv, cak_i_release)
                    THEN
                        IF  a01mandatory_keyword (acv, cak_i_space)
                        THEN
                            a_ap_tree^[put_node].n_pos := cak_i_release;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20dynamic_and_attribute_definition (
            VAR acv : tak_all_command_glob;
            kw_index  : integer;
            VAR put_node  : tsp00_Int2);
 
VAR
      not_found : boolean;
      res_kw    : boolean;
 
BEGIN
not_found := false;
WITH acv, a_scv DO
    BEGIN
    IF  (kw_index = cak_i_not)
    THEN
        BEGIN
        not_found := true;
        a01_next_symbol (acv);
        a01_get_keyword (acv, kw_index, res_kw);
        END;
    (*ENDIF*) 
    CASE kw_index OF
        cak_i_dynamic :
            a01_call_put (acv, a13, cak_x_alter_dynamic, put_node);
        cak_i_fact :
            a01_call_put (acv, a13, cak_x_alter_fact, put_node);
        cak_i_dimension :
            a01_call_put (acv, a13, cak_x_alter_dimension, put_node);
        cak_i_bwhierarchy :
            a01_call_put (acv, a13, cak_x_alter_bwhierarchy, put_node);
        cak_i_cluster :
            a01_call_put (acv, a13, cak_x_alter_cluster, put_node);
        OTHERWISE:
            BEGIN
            END;
        END;
    (*ENDCASE*) 
    IF  not_found
    THEN
        a_ap_tree^[put_node].n_length := cak_i_not
    ELSE
        a_ap_tree^[put_node].n_length := kw_index;
    (*ENDIF*) 
    a01_next_symbol (acv);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20sample_definition (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2);
 
VAR
      res_kw    : boolean;
      last_n    : tsp00_Int2;
      sample_kw : integer;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_call_put (acv, a13, cak_x_sample, put_node);
    a01_next_symbol (acv);
    a03_aunsigned_integer (acv,
          last_n, a_ap_tree^[put_node].n_sa_level);
    a01_get_keyword (acv, sample_kw, res_kw);
    CASE sample_kw OF
        cak_i_rows, cak_i_percent :
            BEGIN
            a_ap_tree^[put_node].n_length :=
                  sample_kw;
            a01_next_symbol (acv);
            END;
        OTHERWISE
            a07_error (acv, e_wanted_keyword,
                  put_node, last_n)
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1105802 *)
(*------------------------------*) 
 
PROCEDURE
      ak20table_type_definition (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_call_put (acv, a13, cak_x_alter_type, put_node);
    a01_next_symbol (acv);
    IF  a01mandatory_keyword (acv, cak_i_table)
    THEN
        BEGIN
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20alter_definition (
            VAR acv        : tak_all_command_glob;
            VAR put_node   : tsp00_Int2);
 
VAR
      res_kw   : boolean;
      parens   : boolean;
      first    : tsp00_Int2;
      curr_n   : tsp00_Int2;
      last_n   : tsp00_Int2;
      pos      : integer;
      kw_index : integer;
      index    : integer;
      aux_scv  : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        aux_scv := a_scv;
        a01_next_symbol (acv);
        parens := (a_sqlmode = sqlm_oracle) AND (sc_symb = s_leftpar);
        IF  parens
        THEN
            a01_next_symbol (acv);
        (*ENDIF*) 
        a_is_ddl := ddl_alter_tab_alter;
        a01_call_put (acv, a13, cak_x_alter_alter, curr_n);
        first    := curr_n;
        put_node := curr_n;
        a02_n_acolumnname (acv,
              a_ap_tree^[ curr_n ].n_lo_level, last_n);
        curr_n   := last_n;
        a01_get_keyword (acv, kw_index, res_kw);
        CASE kw_index OF
            cak_i_alter, cak_i_add, cak_i_drop :
                BEGIN
                a_ap_tree^[ first ].n_length := kw_index;
                pos := sc_newpos;
                a01_next_symbol (acv);
                a01_get_keyword (acv, index, res_kw);
                IF  index <> cak_i_default
                THEN
                    a07_kw_put_error (acv, e_wanted_keyword,
                          acv.a_scv.sc_sypos, cak_i_default)
                ELSE
                    IF  kw_index = cak_i_drop
                    THEN
                        BEGIN
                        a01_next_symbol (acv);
                        a_ap_tree^[ first ].n_length := cak_i_default
                        END
                    ELSE
                        ak20default_val_spec (acv,
                              a_ap_tree^[ last_n ].n_lo_level, last_n);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            cak_i_default :
                IF  a_sqlmode = sqlm_oracle
                THEN
                    BEGIN
                    a_ap_tree^[ first ].n_length := cak_i_modify;
                    ak20default_val_spec (acv,
                          a_ap_tree^[ last_n ].n_lo_level, last_n)
                    END
                ELSE
                    BEGIN
                    a01_next_symbol (acv);
                    IF  a01mandatory_keyword (acv, cak_i_null)
                    THEN
                        a_ap_tree^[ first ].n_length := cak_i_null
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            cak_i_not :
                BEGIN
                a_ap_tree^[ first ].n_length := cak_i_not;
                ak20not_null_spec (acv,
                      a_ap_tree^[ last_n ].n_sa_level, last_n)
                END;
            cak_i_references :
                IF  a_curr_user_name = a01_i_domain
                THEN
                    BEGIN
                    a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_length       :=
                          cak_i_references;
                    a_ap_tree^[ first ].n_length := cak_i_references;
                    a01_next_symbol (acv);
                    a02_adomain_name (acv, NOT c_check_reserved,
                          a_ap_tree^[ last_n ].n_sa_level,last_n)
                    END;
                (*ENDIF*) 
            OTHERWISE
                BEGIN
                a_scv  := aux_scv;
                parens := false;
                ak20modify_definition (acv, put_node)
                END
            END;
        (*ENDCASE*) 
        IF  parens
        THEN
            a01_force_symbol (acv, s_rightpar, put_node, last_n)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20modify_definition (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n         : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_alter_tab_alter;
    a01_next_symbol (acv);
    a01_call_put (acv, a13, cak_x_modify, put_node);
    IF  sc_symb = s_leftpar
    THEN
        BEGIN
        a01_next_symbol (acv);
        ak20column_l_definition_list (acv, NOT c_datatype_required,
              a_ap_tree^[put_node].n_lo_level, last_n);
        a01_force_symbol (acv, s_rightpar, put_node, last_n)
        END
    ELSE
        (* PTS 1105366 E.Z. *)
        ak20column_definition (acv, NOT c_datatype_required,
              a_ap_tree^[put_node].n_lo_level, last_n)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20create_table_stmt (
            VAR acv         : tak_all_command_glob;
            inDBProcCompile : boolean; (* PTS 1109713 *)
            VAR put_node    : tsp00_Int2);
 
VAR
      check_as    : boolean;
      ignore_rollb: boolean;
      cluster     : boolean;
      dynamic     : boolean;
      rowid       : boolean;
      sample      : boolean;
      system      : boolean;
      fact        : boolean;
      dimension   : boolean;
      bwhierarchy : boolean;
      packedAttr  : boolean;
      for_archive : boolean;  (* PTS 1117381 E.Z. *)
      varcolumns  : boolean;  (* PTS 1126711 E.Z. *)
      aux_pos     : integer;
      ikw         : integer;
      kw          : integer;
      sample_kw   : integer;
      last_n      : tsp00_Int2;
      curr_n      : tsp00_Int2;
      lo_level    : tsp00_Int2;
      cmd_len     : tsp00_Int4;
      res_kw      : boolean;
      aux_scv     : tak_scanner_glob;
 
BEGIN
cmd_len := acv.a_cmd_part^.sp1p_buf_len;
IF  NOT inDBProcCompile AND NOT acv.a_compact_varpart AND (acv.a_ex_kind <> only_syntax)
THEN
    BEGIN
    a01_compact_cmd (acv);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        acv.a_scv.sc_newpos := 1;
        a01_next_symbol (acv);
        a01_next_symbol (acv)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  acv.a_ex_kind = pars_then_execute
    THEN
        acv.a_ex_kind := parsing_executing;
    (*ENDIF*) 
    IF  acv.a_is_ddl <> ddl_create_as_select
    THEN
        acv.a_is_ddl := ddl_create_table;
    (*ENDIF*) 
    a01_call_put (acv, a11, cak_x_create_table, put_node);
    a01_next_symbol (acv);
    acv.a_scv.sc_states := acv.a_scv.sc_states + [ scs_reserved_check ];
    a02_atablename (acv,
          acv.a_ap_tree^[ put_node ].n_lo_level, last_n);
    acv.a_scv.sc_states := acv.a_scv.sc_states - [ scs_reserved_check ];
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    ak20table_description (acv,
          acv.a_ap_tree^[ last_n ].n_sa_level, last_n);
&   ifdef trace
    t01int4 (ak_sem, 'last_n      ', last_n);
&   endif
    check_as := (acv.a_returncode <> 0) AND
          (acv.a_sqlmode in [ sqlm_internal, sqlm_oracle ]);
    aux_pos  := acv.a_scv.sc_sypos;
    IF  (acv.a_scv.sc_symb <> s_eof) AND
        (acv.a_sqlmode in [sqlm_internal, sqlm_oracle])
    THEN
        BEGIN
        cluster      := false;
        ignore_rollb := false;
        dynamic      := false;
        sample       := false;
        system       := false;
        rowid        := false;
        fact         := false;
        packedAttr   := false;
        dimension    := false;
        bwhierarchy  := false;
        (* PTS 1117381 E.Z. *)
        for_archive  := false;
        (* PTS 1126711 E.Z. *)
        varcolumns   := false;
        lo_level     := acv.a_ap_tree^[put_node].n_lo_level;
        REPEAT
            a01_get_keyword (acv, ikw, res_kw);
            CASE ikw OF
                cak_i_cluster :
                    IF  NOT cluster
                    THEN
                        BEGIN (* cluster attribute *)
                        aux_scv := acv.a_scv;
                        a01_next_symbol (acv);
                        IF  acv.a_scv.sc_symb = s_leftpar
                        THEN
                            BEGIN
                            acv.a_scv := aux_scv;
                            ak20cluster_spec (acv, acv.a_ap_tree^[last_n].n_lo_level, last_n, cluster);
                            END
                        ELSE
                            IF  a01mandatory_keyword (acv, cak_i_primary)
                            THEN
                                BEGIN
                                a01_get_keyword (acv, kw, res_kw);
                                IF  kw <> cak_i_key
                                THEN
                                    a07_error (acv, e_wanted_keyword, put_node, last_n);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        cluster := true
                        END
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                cak_i_ignore :
                    IF  NOT ignore_rollb
                        AND (acv.a_sqlmode = sqlm_internal)
                    THEN
                        BEGIN (* ignore rollback *)
                        a01_next_symbol (acv);
                        IF  a01_eqkey (a01kw[ cak_i_rollback ], acv.a_sqlmode,
                            acv.a_cmd_part^.sp1p_buf,
                            acv.a_scv)
                        THEN
                            ignore_rollb := true
                        (*ENDIF*) 
                        END
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                cak_i_dynamic :
                    IF  NOT dynamic
                        AND
                        (* PTS 1107080 E.Z. *)
                        ((acv.a_sqlmode = sqlm_internal) OR
                        ( acv.a_sqlmode = sqlm_oracle))
                    THEN
                        BEGIN (* dynamic attribute *)
                        dynamic := true
                        END
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                cak_i_fact :
                    IF  NOT fact
                    THEN
                        BEGIN (* fact attribute *)
                        fact := true
                        END
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                cak_i_dimension :
                    IF  NOT dimension
                    THEN
                        BEGIN (* dimension attribute *)
                        dimension := true
                        END
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                cak_i_bwhierarchy :
                    IF  NOT bwhierarchy
                    THEN
                        BEGIN (* dimension attribute *)
                        bwhierarchy := true
                        END
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                cak_i_packed :
                    IF  NOT packedAttr
                    THEN
                        BEGIN (* packed attribute *)
                        packedAttr := true
                        END
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                cak_i_sample :
                    IF  NOT sample
                        AND (acv.a_sqlmode = sqlm_internal)
                    THEN
                        sample := true
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                cak_i_internal :
                    IF  NOT system AND
                        (((acv.a_initial_segment_header.sp1c_producer in
                        [sp1pr_internal_cmd, sp1pr_installation])
                        AND (acv.a_sqlmode in [ sqlm_internal, sqlm_oracle ]))
                        OR
                        (acv.a_command_kind = internal_create_tab_command)
                        OR
                        (a362OnlineTaskId = acv.a_transinf.tri_trans.trTaskId_gg00))
                    THEN
                        system := true
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                cak_i_rowid :
                    IF  NOT rowid AND
                        (acv.a_sqlmode = sqlm_oracle)
                    THEN
                        rowid := true
                    ELSE
                        ikw := cak_i_no_keyword;
                    (*ENDIF*) 
                (* PTS 1117381 E.Z. *)
                cak_i_for :
                    BEGIN
                    aux_scv := acv.a_scv;
                    a01_next_symbol (acv);
                    IF  a01_eqkey (a01kw[ cak_i_archive ], acv.a_sqlmode,
                        acv.a_cmd_part^.sp1p_buf, acv.a_scv)
                    THEN
                        IF  (g01glob.kglInstanceType_gg00 = itARCHIVE_egg00) AND
                            NOT for_archive                                  AND
                            (acv.a_sqlmode in [ sqlm_internal, sqlm_oracle ])
                        THEN
                            BEGIN
                            for_archive := true;
                            ikw := cak_i_archive
                            END
                        ELSE
                            BEGIN
                            ikw := cak_i_no_keyword;
                            acv.a_scv := aux_scv
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (* PTS 1126711 E.Z. *)
                cak_i_no :
                    BEGIN
                    aux_scv := acv.a_scv;
                    a01_next_symbol (acv);
                    IF  a01_eqkey (a01kw[ cak_i_fixed ], sqlm_internal,
                        acv.a_cmd_part^.sp1p_buf, acv.a_scv)
                    THEN
                        BEGIN
                        a01_next_symbol (acv);
                        IF  a01mandatory_keyword (acv, cak_i_length)
                        THEN
                            IF  a01mandatory_keyword (acv, cak_i_column)
                            THEN
                                BEGIN
                                varcolumns := true;
                                ikw := cak_i_length
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        ikw := cak_i_no_keyword;
                        acv.a_scv := aux_scv
                        END;
                    (*ENDIF*) 
                    END;
                OTHERWISE
                    ikw := cak_i_no_keyword;
                END;
            (*ENDCASE*) 
            IF  ikw <> cak_i_no_keyword
            THEN
                BEGIN
                a01_call_put (acv, a11, ikw, curr_n);
                acv.a_ap_tree^[put_node].n_lo_level := curr_n;
                acv.a_ap_tree^[curr_n  ].n_lo_level := lo_level;
                lo_level := curr_n;
                a01_next_symbol (acv);
                IF  ikw = cak_i_sample
                THEN
                    BEGIN
                    a03_aunsigned_integer (acv,
                          last_n,acv.a_ap_tree^[curr_n].n_sa_level);
                    a01_get_keyword (acv, sample_kw, res_kw);
                    CASE sample_kw OF
                        cak_i_rows, cak_i_percent :
                            BEGIN
                            acv.a_ap_tree^[curr_n].n_length :=
                                  sample_kw;
                            a01_next_symbol (acv);
                            END;
                        OTHERWISE
                            a07_error (acv, e_wanted_keyword,
                                  put_node, curr_n)
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            (ikw = cak_i_no_keyword) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    IF  check_as AND
        (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc <> cak_x_like)
    THEN
        BEGIN
        (* try to skip to keyword 'as'   *)
        (* for create table .. as select *)
        WHILE (acv.a_scv.sc_symb <> s_eof) AND NOT
              (a01_eqkey (a01kw[ cak_i_as ], acv.a_sqlmode,
              acv.a_cmd_part^.sp1p_buf, acv.a_scv)) DO
            a01_next_symbol (acv);
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    IF  acv.a_scv.sc_symb <> s_eof
    THEN
        IF  (a01_eqkey (a01kw[ cak_i_as ], acv.a_sqlmode,
            acv.a_cmd_part^.sp1p_buf, acv.a_scv)) AND
            (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc <> cak_x_like)
        THEN
            BEGIN
            acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_pos := acv.a_scv.sc_sypos;
            IF  acv.a_cmd_segment_header.sp1c_mess_type <> sp1m_syntax
            THEN
                acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level].n_pos := acv.a_ap_tree^[1].n_pos +
                      cmd_len - acv.a_cmd_part^.sp1p_buf_len;
&           ifdef trace
            (*ENDIF*) 
            t01int4 (ak_sem, 'as n_pos    ',
                  acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level].n_pos);
&           endif
            acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length   :=
                  acv.a_cmd_part^.sp1p_buf_len;
            a01_next_symbol (acv);
            IF  a01_eqkey (a01kw[ cak_i_select ], acv.a_sqlmode,
                acv.a_cmd_part^.sp1p_buf,
                acv.a_scv)
            THEN
                BEGIN
                acv.a_returncode       := 0;
                acv.a_rowno_allowed   := false;
                acv.a_rowno_found     := false;
                acv.a_allow_functions := tf_unknown;
                acv.a_from_select     := false;
                acv.a_is_ddl          := no_ddl;
                (* PTS 1138343 D.T. *)
                a60_aquery_spec (acv, false, false,
                      acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_sa_level,
                      last_n, cak_is_undefined, false); (* PTS 1118851 *)
                IF  acv.a_scv.sc_symb <> s_eof
                THEN
                    BEGIN
                    acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level := 2;
                    acv.a_ap_tree^[ 2 ].n_pos      := acv.a_scv.sc_sypos;
                    acv.a_ap_tree^[ 2 ].n_sa_level := 0;
                    acv.a_ap_tree^[ 2 ].n_lo_level := 0;
                    ak20duplicates_clause (acv)
                    END
                ELSE
                    acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level := 0;
                (*ENDIF*) 
                acv.a_is_ddl  := ddl_create_as_select;
                acv.a_ex_kind := only_syntax
                END
            ELSE
                a07_error (acv,
                      e_wanted_keyword, put_node, last_n)
            (*ENDIF*) 
            END
        ELSE
            IF  check_as
            THEN
                acv.a_scv.sc_sypos := aux_pos
            ELSE
                ak20rest_syntax (acv)
            (*ENDIF*) 
        (*ENDIF*) 
    ELSE
        IF  check_as
        THEN
            acv.a_scv.sc_sypos := aux_pos
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20table_description (
            VAR acv         : tak_all_command_glob;
            VAR put_node    : tsp00_Int2;
            VAR last_node   : tsp00_Int2);
 
VAR
      last_n  : tsp00_Int2;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  acv.a_scv.sc_symb = s_leftpar
    THEN
        BEGIN
        a01_next_symbol (acv);
        ak20column_l_definition_list (acv,
              c_datatype_required, put_node, last_node);
&       ifdef trace
        t01int4 (ak_syn, 'sc_symb     ', ord (acv.a_scv.sc_symb));
&       endif
        a01_force_symbol (acv, s_rightpar, put_node, last_node)
        END
    ELSE
        IF  (a01_eqkey (a01kw[ cak_i_like ], acv.a_sqlmode,
            acv.a_cmd_part^.sp1p_buf, acv.a_scv)) AND
            (* PTS 1109196 E.Z. *)
            (acv.a_sqlmode in [ sqlm_internal, sqlm_db2, sqlm_oracle ])
        THEN
            BEGIN
            acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc := cak_x_like;
            a01_next_symbol (acv);
            a02_atablename (acv, put_node, last_n);
            END
        ELSE
            IF  acv.a_is_ddl <> ddl_create_as_select
            THEN
                a07_error (acv,
                      e_missing_keyword, put_node, last_node)
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20atable_drop (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      res_kw         : boolean;
      last_n         : tsp00_Int2;
      kw             : integer;
 
BEGIN
acv.a_is_ddl := ddl_drop_table;
a01_call_put (acv, a11, cak_x_drop_table, put_node);
a01_next_symbol (acv);
a02_atablename (acv, acv.a_ap_tree^[ put_node ].n_lo_level,last_n);
IF  (acv.a_scv.sc_symb <> s_eof) AND
    (acv.a_sqlmode in [sqlm_internal, sqlm_ansi, sqlm_oracle])
THEN
    BEGIN
    a01_get_keyword (acv, kw, res_kw);
    IF  (kw = cak_i_cascade)
        OR
        ((kw = cak_i_restrict) AND (acv.a_sqlmode <> sqlm_oracle))
    THEN
        BEGIN
        a01_call_put (acv, a11, kw, last_n);
        acv.a_ap_tree^[put_node].n_sa_level := last_n;
        a01_next_symbol (acv);
        IF  acv.a_sqlmode = sqlm_oracle
        THEN
            BEGIN
            IF  a01_eqkey (a01kw[cak_i_constraints], acv.a_sqlmode,
                acv.a_cmd_part^.sp1p_buf, acv.a_scv)
            THEN
                a01_next_symbol (acv)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
a01_is_end_symbol (acv);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20create_domain_stmt (
            VAR acv         : tak_all_command_glob;
            VAR put_node    : tsp00_Int2);
 
VAR
      ikw    : integer;
      res_kw : boolean;
      last_n : tsp00_Int2;
      dtnode : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_compact_cmd (acv);
    IF  a_returncode = 0
    THEN
        BEGIN
        sc_newpos := 1;
        a01_next_symbol (acv);
        a01_next_symbol (acv);
        a_is_ddl := ddl_create_domain;
        a01_call_put (acv, a12, cak_x_create_domain, put_node);
        a01_next_symbol (acv);
        IF  a_returncode = 0
        THEN
            BEGIN
            a02_adomain_name (acv, c_check_reserved,
                  a_ap_tree^[ put_node ].n_lo_level, last_n);
            dtnode := last_n;
            a01_get_keyword (acv, ikw, res_kw);
            a20adata_type (acv,
                  a_ap_tree^[ last_n ].n_sa_level,last_n, NOT c_isDBFunction, ikw);
            ak20column_key_spec (acv,
                  a_ap_tree^[ last_n ].n_sa_level, last_n);
            ak20not_null_spec (acv,
                  a_ap_tree^[ last_n ].n_sa_level, last_n);
            ak20default_val_spec (acv,
                  a_ap_tree^[ last_n ].n_sa_level, last_n);
            ak20rel30_range (acv, dtnode,
                  a_ap_tree^[ put_node ].n_sa_level, last_n)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_domain  (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_drop_domain;
    a01_call_put (acv, a12, cak_x_drop_domain, put_node);
    a01_next_symbol (acv);
    a02_adomain_name (acv, NOT c_check_reserved, a_ap_tree^[ put_node ].n_lo_level, last_n);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a20_abegin_end_load_stmt (
            VAR acv               : tak_all_command_glob;
            VAR put_node          : tsp00_Int2;
            kw_index              : integer);
 
VAR
      res_kw     : boolean;
      proc       : tak_procs;
      index_spec : boolean;
      last_n     : tsp00_Int2;
      save_kw    : integer;
 
BEGIN
put_node := 0;
WITH acv, a_scv DO
    IF  a_cmd_segment_header.sp1c_producer in
        [sp1pr_internal_cmd, sp1pr_installation]
    THEN
        BEGIN
        proc                := a11;
        a_precomp_info_byte := csp1_p_not_allowed_for_program;
        a_is_ddl            := ddl_begin_end_load;
        index_spec          := false;
        IF  kw_index = cak_i_save
        THEN
            BEGIN
            a01_next_symbol (acv);
            IF  a01mandatory_keyword (acv, cak_i_save)
            THEN
                BEGIN
                a01_get_keyword (acv, save_kw, res_kw);
                CASE save_kw OF
                    cak_i_table :
                        last_n := cak_x_save_init;
                    cak_i_index :
                        BEGIN
                        index_spec := true;
                        last_n := cak_x_save_init
                        END;
                    cak_i_column :
                        BEGIN
                        proc   := a17;
                        last_n := cak_x_save_string
                        END;
                    cak_i_long :
                        BEGIN
                        proc   := a11;
                        last_n := cak_x_save_short_string
                        END;
                    OTHERWISE
                        a07_error (acv,
                              e_wanted_keyword, last_n, put_node);
                    END;
                (*ENDCASE*) 
                END
            (*ENDIF*) 
            END
        ELSE
            IF  kw_index = cak_i_beginload
            THEN
                last_n := cak_x_beginload
            ELSE
                last_n := cak_x_end_load;
            (*ENDIF*) 
        (*ENDIF*) 
        a01_call_put (acv, proc, last_n, put_node);
        a_ap_tree^[put_node].n_length := 0;
        a01_next_symbol (acv);
        IF  proc = a11
        THEN
            BEGIN
            a02_atablename (acv,
                  a_ap_tree^[ put_node ].n_lo_level, last_n);
            IF  (kw_index = cak_i_beginload) AND (sc_symb <> s_eof)
            THEN
                IF  a01mandatory_keyword (acv, cak_i_with)
                THEN
                    IF  a01mandatory_keyword (acv, cak_i_stamp)
                    THEN
                        a_ap_tree^[put_node].n_length := cak_i_stamp
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  index_spec
        THEN
            a03_aunsigned_integer (acv,
                  last_n, a_ap_tree^[ last_n ].n_sa_level);
        (*ENDIF*) 
        a01_is_end_symbol (acv)
        END
    ELSE
        a07_b_put_error (acv, e_invalid_command, 1)
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20rest_syntax (VAR acv : tak_all_command_glob);
 
VAR
      found     : boolean;
      last_n    : tsp00_Int2;
      symbindex : integer;
      res_kw    : boolean;
 
BEGIN
WITH acv, a_scv DO
    IF  (sc_symb <> s_eof) AND (a_returncode = 0)
    THEN
        CASE a_sqlmode OF
            sqlm_db2 :
                BEGIN
                a01_get_keyword (acv, symbindex, res_kw);
                CASE symbindex OF
                    (* PTS 1111576 E.Z. *)
                    cak_i_in :
                        BEGIN
                        REPEAT
                            a01_next_symbol (acv);
                            a01_get_keyword (acv, symbindex, res_kw);
                            IF  (symbindex = cak_i_data     ) OR
                                (symbindex = cak_i_editproc ) OR
                                (symbindex = cak_i_obid     ) OR
                                (symbindex = cak_i_validproc)
                            THEN
                                a07_error (acv,
                                      e_invalid_keyword, last_n, last_n);
                            (*ENDIF*) 
                        UNTIL
                            (sc_symb = s_eof) OR (a_returncode <> 0);
                        (*ENDREPEAT*) 
                        END;
                    OTHERWISE ;
                    END;
                (*ENDCASE*) 
                END;
            sqlm_oracle :
                BEGIN
                REPEAT
                    found := true;
                    a01_get_keyword (acv, symbindex, res_kw);
                    IF  (symbindex = cak_i_pctfree)
                        OR
                        ((symbindex = cak_i_pctused) AND
                        (a_is_ddl <> ddl_create_index))
                        OR
                        (symbindex =  cak_i_initrans)
                        OR
                        (symbindex =  cak_i_maxtrans)
                        OR
                        (symbindex =  cak_i_tablespace)
                    THEN
                        BEGIN
                        a01_next_symbol (acv);
                        a01_next_symbol (acv)
                        END
                    ELSE
                        CASE symbindex OF
                            cak_i_storage :
                                BEGIN
                                REPEAT
                                    a01_next_symbol (acv);
                                UNTIL
                                    (sc_symb in [ s_rightpar, s_eof ]);
                                (*ENDREPEAT*) 
                                IF  sc_symb = s_eof
                                THEN
                                    a07_error (acv,
                                          e_invalid_end_of_command,
                                          last_n, last_n)
                                ELSE
                                    a01_next_symbol (acv)
                                (*ENDIF*) 
                                END;
                            cak_i_nosort :
                                IF  a_is_ddl = ddl_create_index
                                THEN
                                    a01_next_symbol (acv)
                                ELSE
                                    found := false;
                                (*ENDIF*) 
                            OTHERWISE
                                found := false;
                            END;
                        (*ENDCASE*) 
                    (*ENDIF*) 
                UNTIL
                    NOT found OR (a_returncode <> 0)
                (*ENDREPEAT*) 
                END;
            OTHERWISE ;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20column_l_definition_list (
            VAR acv                  : tak_all_command_glob;
            datatype_required        : boolean;
            VAR put_node             : tsp00_Int2;
            VAR last_node            : tsp00_Int2);
 
VAR
      first          : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    first          := true;
    (* PTS 1105366 E.Z. *)
    REPEAT
        IF  first
        THEN
            ak20column_definition (acv, datatype_required,
                  put_node, last_node)
        ELSE
            BEGIN
            a01_next_symbol (acv);
            ak20column_definition (acv, datatype_required,
                  acv.a_ap_tree^[ last_node ].n_lo_level,
                  last_node);
            END;
        (*ENDIF*) 
        first := false;
    UNTIL
        (acv.a_scv.sc_symb <> s_comma) OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20column_definition (
            VAR acv            : tak_all_command_glob;
            datatype_required  : boolean;
            VAR put_node       : tsp00_Int2;
            VAR last_node      : tsp00_Int2);
 
VAR
      res_kw           : boolean;
      domain           : boolean;
      constraint_found : boolean;
      table_constraint : boolean;
      columnkey_found  : boolean;
      ikw              : integer;
      last_n           : tsp00_Int2;
      curr_n           : tsp00_Int2;
      col_node         : tsp00_Int2;
      dt_node          : tsp00_Int2;
      lo_level_node    : tsp00_Int2;
      not_null_node    : tsp00_Int2;
      default_node     : tsp00_Int2;
      ix               : tconstraint_type;
      c_nodes          : tconstraint_nodes;
      aux_scv          : tak_scanner_glob;
 
BEGIN
a01_get_keyword (acv, ikw, res_kw);
CASE ikw OF
    cak_i_check, cak_i_constraint, cak_i_foreign,
    cak_i_primary,
    (* PTS 1120004 E.Z. *)
    cak_i_unique :
        IF  (acv.a_is_ddl = ddl_create_table) OR
            (acv.a_is_ddl = ddl_create_as_select)
        THEN
            ak20table_constraint (acv, ikw, put_node, last_node,
                  table_constraint)
        ELSE
            table_constraint := false;
        (*ENDIF*) 
    OTHERWISE
        table_constraint := false;
    END;
(*ENDCASE*) 
columnkey_found := false;
IF  NOT table_constraint
THEN
    BEGIN
    default_node := 0;
    IF  res_kw
    THEN
        a07_error (acv, e_reserved_identifier,
              put_node, last_node);
    (*ENDIF*) 
    a02_n_acolumnname (acv, put_node, col_node);
    a01_get_keyword (acv, ikw, res_kw);
    last_n        := col_node;
    lo_level_node := col_node;
    IF  (acv.a_is_ddl <> ddl_create_as_select) AND
        (acv.a_returncode = 0)
    THEN
        BEGIN
        FOR ix := c_null TO c_unique DO
            c_nodes[ix] := 0;
        (*ENDFOR*) 
        IF  ((ikw = cak_i_no_keyword) OR NOT res_kw) AND
            ( ikw <> cak_i_null     )                AND
            (acv.a_sqlmode = sqlm_internal)
        THEN
            BEGIN
            domain := true;
            a02_adomain_name (acv, NOT c_check_reserved,
                  acv.a_ap_tree^[ last_n ].n_sa_level,last_n);
            END
        ELSE
            (* PTS 1105366 E.Z. *)
            BEGIN
            domain  := false;
            dt_node := last_n;
            IF  (ikw = cak_i_null) AND NOT datatype_required
            THEN
                BEGIN
                acv.a_scv.sc_symb := s_null;
                a01_put_node (acv, acv.a_ap_tree^[last_n].n_sa_level);
                last_n := acv.a_ap_tree^[last_n].n_sa_level;
                c_nodes[c_null] := 1;
                a01_next_symbol (acv)
                END
            ELSE
                IF  datatype_required OR
                    ((ikw <> cak_i_not) AND (ikw <> cak_i_default))
                THEN
                    a20adata_type (acv,
                          acv.a_ap_tree^[ last_n ].n_sa_level,
                          last_n, NOT c_isDBFunction, ikw);
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND
            (acv.a_sqlmode = sqlm_internal)
        THEN
            BEGIN
            IF  a01_eqkey (a01kw[ cak_i_key ], acv.a_sqlmode,
                acv.a_cmd_part^.sp1p_buf, acv.a_scv)
            THEN
                BEGIN
                ak20column_key_spec (acv,
                      acv.a_ap_tree^[ last_n ].n_sa_level,
                      last_n);
                columnkey_found := true;
                (* PTS 1113069 E.Z. *)
                IF  c_nodes[c_null] <> 0
                THEN
                    a07_error (acv, e_invalid_keyword, put_node, last_node)
                ELSE
                    c_nodes[c_key] := last_n;
                (*ENDIF*) 
                END;
            (* PTS 1113069 E.Z. *)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (acv.a_returncode = 0) AND
            ((acv.a_sqlmode = sqlm_internal) OR
            (acv.a_sqlmode = sqlm_oracle))
        THEN
            BEGIN            (* PTS 1117947 D.T. *)
            aux_scv := acv.a_scv;
            ak20not_null_spec (acv,
                  acv.a_ap_tree^[ last_n ].n_sa_level,
                  c_nodes[c_not_null]);
            IF  c_nodes[c_not_null] <> 0
            THEN
                (* PTS 1113069 E.Z. *)
                IF  c_nodes[c_null] <> 0
                THEN
                    BEGIN
                    acv.a_scv := aux_scv;
                    a07_error (acv, e_invalid_keyword, put_node, last_node)
                    END
                ELSE
                    last_n := c_nodes[c_not_null]
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            IF  acv.a_sqlmode = sqlm_db2
            THEN
                BEGIN
                ak20for_bit_data_spec (acv,
                      acv.a_ap_tree^[ dt_node ].n_sa_level);
                ak20not_null_spec (acv,
                      acv.a_ap_tree^[ last_n ].n_sa_level,
                      last_n)
                END
            ELSE
                ak20default_val_spec (acv,
                      default_node, curr_n);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (acv.a_sqlmode <> sqlm_db2)
        THEN
            BEGIN
            (* check column constraints *)
            not_null_node := 0;
            REPEAT
                ak20column_constraint (acv,
                      col_node, not_null_node,
                      c_nodes, constraint_found);
            UNTIL
                (NOT constraint_found) OR
                (acv.a_returncode <> 0);
            (*ENDREPEAT*) 
            IF  columnkey_found
            THEN
                c_nodes[c_key] := 0;
            (*ENDIF*) 
            IF  not_null_node <> 0
            THEN
                BEGIN
                acv.a_ap_tree^[last_n].n_sa_level := not_null_node;
                last_n := not_null_node;
                END;
            (*ENDIF*) 
            IF  default_node <> 0
            THEN
                acv.a_ap_tree^[last_n].n_sa_level := default_node;
            (*ENDIF*) 
            FOR ix := c_check TO c_unique DO
                IF  c_nodes[ix] <> 0
                THEN
                    BEGIN
                    acv.a_ap_tree^[lo_level_node].n_lo_level :=
                          c_nodes[ix];
                    lo_level_node := c_nodes[ix]
                    END;
                (*ENDIF*) 
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    last_node := lo_level_node;
&   ifdef TRACE
    t01int4 (ak_sem, 'last_node   ', last_node);
&   endif
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20column_constraint (
            VAR acv           : tak_all_command_glob;
            col_node          : tsp00_Int2;
            VAR not_null_node : tsp00_Int2;
            VAR c_nodes       : tconstraint_nodes;
            VAR c_found       : boolean);
 
VAR
      res_kw             : boolean;
      using_clause_found : boolean;
      kw_constraint      : boolean;
      error              : tgg00_BasisError;
      curr_n             : tsp00_Int2;
      dummy_node         : tsp00_Int2;
      constraint_node    : tsp00_Int2;
      constraint_quote   : tsp00_Int2;
      last_n             : tsp00_Int2;
      rule_node          : tsp00_Int2;
      name_n             : tsp00_Int2;
      kw                 : integer;
      aux_scv            : tak_scanner_glob;
 
BEGIN
c_found          := true;
error            := e_ok;
constraint_node  := 0;
constraint_quote := 0;
aux_scv          := acv.a_scv;
kw_constraint := a01_eqkey (a01kw[cak_i_constraint], acv.a_sqlmode,
      acv.a_cmd_part^.sp1p_buf, acv.a_scv);
IF  kw_constraint
THEN
    BEGIN
    a01_next_symbol (acv);
    IF  acv.a_scv.sc_symb = s_identifier
    THEN
        BEGIN
        constraint_quote := acv.a_scv.sc_double_quote;
        a02_put_identifier (acv, dummy_node, constraint_node)
        END
    (* PTS 1121138 E.Z. *)
    ELSE
        IF  acv.a_sqlmode = sqlm_oracle
        THEN
            error := e_missing_identifier;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
a01_get_keyword (acv, kw, res_kw);
IF  error = e_ok
THEN
    CASE kw OF
        cak_i_check, cak_i_range :
            IF  (c_nodes[c_check] <> 0)
                OR
                ((kw = cak_i_range) AND
                ((constraint_node <> 0) OR (acv.a_sqlmode <> sqlm_internal)))
            THEN
                error := e_wanted_keyword
            ELSE
                BEGIN
                IF  kw = cak_i_range
                THEN
                    c_nodes[c_not_null] := 1;
                (*ENDIF*) 
                acv.a_scv := aux_scv;
                ak20check_clause (acv, kw, true,
                      constraint_node, constraint_quote,
                      c_nodes[c_check], col_node)
                END;
            (*ENDIF*) 
        cak_i_not :
            (* PTS 1113069 E.Z. *)
            IF  (c_nodes[c_null] <> 0) OR
                (c_nodes[c_not_null] <> 0)
            THEN
                error := e_invalid_keyword
            ELSE
                IF  (acv.a_sqlmode in [sqlm_internal, sqlm_ansi]) AND
                    (constraint_node <> 0)
                THEN
                    error := e_invalid_keyword
                ELSE
                    BEGIN
                    ak20not_null_spec (acv,
                          not_null_node, c_nodes[c_not_null]);
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        cak_i_null :
            (* PTS 1113069 E.Z. *)
            IF  (c_nodes[c_null] <> 0)     OR
                (c_nodes[c_not_null] <> 0) OR
                (c_nodes[c_key] <> 0)      OR
                NOT (acv.a_sqlmode in [sqlm_internal, sqlm_oracle])
            THEN
                error := e_invalid_keyword
            ELSE (* skip null *)
                BEGIN
                c_nodes[c_null] := 1;
                a01_next_symbol (acv)
                END;
            (*ENDIF*) 
        cak_i_primary :
            (* PTS 1103853 E.Z. *)
            (* PTS 1112986 E.Z. *)
            IF  (c_nodes[c_null] <> 0)     OR
                (c_nodes[c_key] <> 0)
            THEN
                error := e_invalid_keyword
            ELSE
                BEGIN
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_key)
                THEN
                    BEGIN
                    aux_scv := acv.a_scv;
                    acv.a_scv.sc_symb := s_key;
                    a01_put_node (acv, c_nodes[c_key]);
                    a01_put_node (acv, last_n);
                    acv.a_scv              := aux_scv;
                    acv.a_ap_tree^[last_n] := acv.a_ap_tree^[col_node];
                    acv.a_ap_tree^[last_n].n_sa_level     := 0;
                    acv.a_ap_tree^[last_n].n_lo_level     := 0;
                    acv.a_ap_tree^[c_nodes[c_key]].n_sa_level := last_n;
                    ak20using_index_clause (acv, using_clause_found);
                    IF  using_clause_found
                    THEN
                        ak20unique_info (acv,
                              constraint_node,
                              col_node, c_nodes[c_impl_key])
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        cak_i_references :
            IF  c_nodes[c_ref] <> 0
            THEN
                error := e_invalid_keyword
            ELSE
                BEGIN (* REFERENCES CLAUSE *)
                acv.a_scv.sc_symb := s_reference_name;
                a01_put_node (acv, c_nodes[c_ref]);
                a01_call_put (acv, a25,
                      cak_x_create_link, last_n);
                rule_node := last_n;
                acv.a_ap_tree^[c_nodes[c_ref]].n_sa_level := last_n;
                IF  constraint_node <> 0
                THEN
                    name_n := constraint_node
                ELSE
                    a01_call_put (acv, a25, 0, name_n);
                (*ENDIF*) 
                acv.a_ap_tree^[ rule_node ].n_sa_level := name_n;
                a01_put_node (acv, curr_n);
                acv.a_ap_tree^[curr_n] := acv.a_ap_tree^[col_node];
                acv.a_ap_tree^[curr_n].n_lo_level := 0;
                acv.a_ap_tree^[curr_n].n_sa_level := 0;
                acv.a_ap_tree^[name_n].n_lo_level := curr_n;
                a01_next_symbol (acv);
                ak20pk_rule_spec (acv,
                      curr_n, name_n, rule_node);
                IF  a01_eqkey (a01kw[ cak_i_constraint ], acv.a_sqlmode,
                    acv.a_cmd_part^.sp1p_buf, acv.a_scv)
                    AND
                    (constraint_node <> 0)
                    AND
                    (acv.a_sqlmode = sqlm_oracle)
                THEN
                    BEGIN (* allow oracle 6 syntax *)
                    a01_next_symbol (acv);
                    a02_put_identifier (acv, curr_n, last_n);
                    WITH acv.a_ap_tree^[name_n] DO
                        BEGIN
                        n_symb    := acv.a_ap_tree^[last_n].n_symb;
                        n_pos     := acv.a_ap_tree^[last_n].n_pos;
                        n_length  := acv.a_ap_tree^[last_n].n_length;
                        n_subproc := acv.a_ap_tree^[last_n].n_length
                        END;
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                acv.a_ap_tree^[c_nodes[c_ref]].n_length := acv.a_scv.sc_sypos
                END;
            (*ENDIF*) 
        cak_i_unique :
            IF  c_nodes[c_unique] <> 0
            THEN
                error := e_invalid_keyword
            ELSE
                BEGIN (* UNIQUE INDEX *)
                ak20unique_info (acv,
                      constraint_node, col_node, c_nodes[c_unique]);
                a01_next_symbol (acv);
                ak20using_index_clause (acv, using_clause_found)
                END;
            (*ENDIF*) 
        OTHERWISE
            IF  kw_constraint          AND
                (c_nodes[c_check] = 0) AND
                (acv.a_sqlmode = sqlm_internal)
            THEN
                BEGIN
                acv.a_scv := aux_scv;
                ak20check_clause (acv, cak_i_constraint,
                      true, constraint_node, constraint_quote,
                      c_nodes[c_check], col_node)
                END
            ELSE (* PTS 1118655 M.Ki. *)
                IF  kw_constraint          AND
                    (c_nodes[c_check] = 0) AND
                    (acv.a_sqlmode = sqlm_oracle)
                THEN
                    BEGIN
                    last_n := 0;
                    error  := e_missing_keyword;
                    END
                ELSE
                    BEGIN
                    acv.a_scv := aux_scv;
                    c_found := false;
                    END
                (*ENDIF*) 
            (*ENDIF*) 
        END;
    (*ENDCASE*) 
(*ENDIF*) 
IF  error <> e_ok
THEN
    BEGIN
    c_found := false;
    a07_error (acv, error, last_n, last_n)
    END
ELSE
    IF  acv.a_sqlmode = sqlm_oracle
    THEN
        IF  a01_eqkey (a01kw[cak_i_disable], acv.a_sqlmode,
            acv.a_cmd_part^.sp1p_buf, acv.a_scv)
        THEN
            a01_next_symbol (acv);
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(* PTS 1104914 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak20fk_spec (
            VAR acv        : tak_all_command_glob;
            VAR name_node  : tsp00_Int2;
            VAR put_node   : tsp00_Int2;
            VAR col_node   : tsp00_Int2;
            VAR found      : boolean);
 
VAR
      curr_node : tsp00_Int2;
      last_node : tsp00_Int2;
      rule_node : tsp00_Int2;
      aux_scv   : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    aux_scv := a_scv;      (* If FOREIGN is no reserved keyword, we check *)
    a01_next_symbol (acv); (* first, whether the following word is KEY.   *)
    found := a01_eqkey (a01kw[ cak_i_key ], a_sqlmode,
          a_cmd_part^.sp1p_buf, a_scv);
    a_scv := aux_scv;
    IF  found
    THEN
        BEGIN
        sc_symb := s_reference_name;
        a01_put_node (acv, last_node);
        col_node := last_node;
        put_node := last_node;
        a01_call_put (acv, a25, cak_x_create_link, curr_node);
        rule_node := curr_node;
        a_ap_tree^[ last_node ].n_sa_level := curr_node;
        a01_next_symbol (acv);
        IF  a01mandatory_keyword (acv, cak_i_key)
        THEN
            BEGIN
            a_ap_tree^[ col_node ].n_pos := sc_sypos;
            IF  (sc_symb = s_identifier) AND
                (a_sqlmode in [ sqlm_internal, sqlm_db2 ])
            THEN
                IF  name_node <> 0
                THEN
                    a07_error (acv,
                          e_missing_keyword, put_node, put_node)
                ELSE
                    a02_put_identifier (acv,
                          a_ap_tree^[curr_node].n_sa_level,
                          curr_node)
                (*ENDIF*) 
            ELSE
                BEGIN
                IF  name_node = 0
                THEN
                    a01_call_put (acv, a25, 0, name_node);
                (*ENDIF*) 
                a_ap_tree^[ curr_node ].n_sa_level := name_node;
                curr_node := name_node
                END;
            (*ENDIF*) 
            ak20foreign_key_spec (acv,
                  a_ap_tree^[ curr_node ].n_lo_level,
                  last_node, curr_node, rule_node);
            IF  a01_eqkey (a01kw[ cak_i_constraint ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
                AND
                (a_sqlmode = sqlm_oracle)
                AND
                (name_node = 0)
            THEN
                BEGIN
                a01_next_symbol (acv);
                a02_put_identifier (acv, curr_node, last_node);
                WITH a_ap_tree^[ name_node ] DO
                    BEGIN
                    n_symb    := a_ap_tree^[ last_node ].n_symb;
                    n_pos     := a_ap_tree^[ last_node ].n_pos;
                    n_length  := a_ap_tree^[ last_node ].n_length;
                    n_subproc := a_ap_tree^[ last_node ].n_subproc
                    END;
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            a_ap_tree^[ col_node ].n_length := sc_sypos
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20check_clause (
            VAR acv          : tak_all_command_glob;
            kw_index         : integer;
            col_check_clause : boolean;
            name_node        : integer;
            quote            : tsp00_Int2;
            VAR put_node     : tsp00_Int2;
            VAR col_node     : tsp00_Int2);
 
VAR
      check_clause : boolean;
      curr_node    : tsp00_Int2;
      info_node    : tsp00_Int2;
      last_node    : tsp00_Int2;
      aux_node     : tsp00_Int2;
      aux_scv      : tak_scanner_glob;
      with_check   : boolean;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
&       ifdef trace
        IF  name_node <> 0
        THEN
            BEGIN
            t01int4 (ak_sem, 'name_node   ', name_node);
            t01int4 (ak_sem, 'double_quote', quote);
            t01int4 (ak_sem, 'n_pos       ', a_ap_tree^[name_node].n_pos);
            END;
&       endif
        (*ENDIF*) 
        aux_scv := a_scv;
        sc_symb  := s_between;
        a01_put_node (acv, last_node);
        put_node := last_node;
        a_scv := aux_scv;
        IF  kw_index = cak_i_range
        THEN
            BEGIN
            aux_node := last_node;
            a01_call_put (acv, a11, sc_sypos, last_node);
            a_ap_tree^[ aux_node ].n_sa_level := last_node;
            a_ap_tree^[ last_node ] := a_ap_tree^[ col_node ];
            a_ap_tree^[ last_node ].n_lo_level := 0;
            ak20rel30_range (acv, col_node,
                  a_ap_tree^[ last_node ].n_sa_level, last_node);
            col_node := put_node;
            END
        ELSE
            BEGIN
            with_check := a01_eqkey (a01kw[ cak_i_check], a_sqlmode,
                  a_cmd_part^.sp1p_buf, a_scv) OR
                  (col_check_clause AND (kw_index = cak_i_check));
            a01_next_symbol (acv);
            aux_scv      := a_scv;
            check_clause := true;
            IF  (kw_index = cak_i_constraint) OR (name_node <> 0)
            THEN
                BEGIN
                aux_node := last_node;
                IF  name_node = 0
                THEN
                    a02_put_identifier (acv,
                          a_ap_tree^[last_node].n_sa_level,
                          last_node)
                ELSE
                    BEGIN
&                   ifdef trace
                    t01int4 (ak_sem, 'sc_sypos   V', sc_sypos);
&                   endif
                    IF  with_check
                    THEN
                        BEGIN
                        a_ap_tree^[last_node].n_sa_level := name_node;
                        last_node := name_node
                        END;
                    (*ENDIF*) 
                    a01_next_symbol (acv)
                    END;
                (*ENDIF*) 
&               ifdef trace
                t01int4 (ak_sem, 'sc_sypos    ', sc_sypos);
&               endif
                IF  a01_eqkey (a01kw[ cak_i_check ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                    AND (a_returncode = 0)
                THEN
                    BEGIN
                    check_clause := false;
                    a01_next_symbol (acv);
                    IF  sc_symb = s_identifier
                    THEN
                        quote := sc_double_quote
                    ELSE
                        IF  sc_symb = s_string_literal
                        THEN
                            quote := 1
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    a_returncode := 0;
                    a_scv       := aux_scv;
&                   ifdef trace
                    t01int4 (ak_sem, 'sc_newpos   ', sc_newpos);
&                   endif
                    IF  col_check_clause OR (name_node = 0)
                    THEN (* This mustn't happen for: CONSTRAINT a CHECK a <> 0 *)
                        last_node := aux_node
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                IF  sc_symb = s_identifier
                THEN
                    quote := sc_double_quote
                ELSE
                    IF  sc_symb = s_string_literal
                    THEN
                        quote := 1;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  check_clause AND col_check_clause
            THEN
                BEGIN
                (* no constraint name for column check clause    *)
                (* specified, use column name as constraint name *)
                aux_node := last_node;
                a01_call_put (acv, a11, sc_sypos, last_node);
                a_ap_tree^[ aux_node ].n_sa_level := last_node;
                a_ap_tree^[ last_node ] := a_ap_tree^[ col_node ];
                a_ap_tree^[ last_node ].n_lo_level := 0;
                END;
            (*ENDIF*) 
            col_node := put_node;
&           ifdef trace
            t01int4 (ak_syn, 'double_quote', quote);
&           endif
            a20info_node (acv, a63,
                  sc_sypos - quote, curr_node, info_node);
            a_ap_tree^[ curr_node ].n_pos      := sc_sypos - quote;
            a_ap_tree^[ last_node ].n_sa_level := curr_node;
            a_rowno_allowed   := false;
            a_rowno_found     := false;
            a_allow_functions := tf_unknown;
            a_from_select     := false;
            IF  a_sqlmode = sqlm_oracle
            THEN
                BEGIN
                aux_scv := a_scv;
                a01_force_symbol (acv, s_leftpar, put_node, last_node);
                a_scv := aux_scv
                END;
            (*ENDIF*) 
            a63_asearch_condition (acv,
                  a_ap_tree^[ curr_node ].n_lo_level, last_node);
            a_ap_tree^[info_node].n_pos := sc_sypos - 1;
            (* PTS 1121138 E.Z. *)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20for_bit_data_spec (
            VAR acv         : tak_all_command_glob;
            VAR dtype_node  : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
&       ifdef trace
        t01int4 (ak_syn, 'dtype_node  ', dtype_node);
        t01int4 (ak_syn, 's_symb      ',
              ord (a_ap_tree^[ dtype_node ].n_symb));
        t01int4 (ak_syn, 'n_length    ',
              a_ap_tree^[ dtype_node ].n_length);
&       endif
        IF  ((a_ap_tree^[ dtype_node ].n_symb = s_character) OR
            ( a_ap_tree^[ dtype_node ].n_symb = s_varchar)   OR
            ( a_ap_tree^[ dtype_node ].n_symb = s_long_varchar))
            AND
            (a_ap_tree^[ dtype_node ].n_length = ord(s_unknown))
        THEN
            IF  a01_eqkey (a01kw[ cak_i_for ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  a01_eqkey (a01kw[ cak_i_bit ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    IF  a01_eqkey (a01kw[ cak_i_data ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        BEGIN
                        a_ap_tree^[ dtype_node ].n_length := ord(s_byte);
                        a01_next_symbol (acv);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20column_key_spec (
            VAR acv            : tak_all_command_glob;
            VAR put_node       : tsp00_Int2;
            VAR last_node      : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  a01_eqkey (a01kw[ cak_i_key ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        BEGIN
        sc_symb := s_key;
        a01_put_node (acv, put_node);
        last_node := put_node;
        a_ap_tree^[ last_node ].n_length := cak_i_key;
        a01_next_symbol (acv);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20not_null_spec (
            VAR acv            : tak_all_command_glob;
            VAR put_node       : tsp00_Int2;
            VAR last_node      : tsp00_Int2);
 
VAR
      symb : tak_sc_symbol;
 
BEGIN
WITH acv, a_scv DO
    IF  a01_eqkey (a01kw[ cak_i_not ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        BEGIN
        a01_next_symbol (acv);
        IF  a01mandatory_keyword (acv, cak_i_null)
        THEN
            BEGIN
            symb    := sc_symb;
            sc_symb := s_not_null;
            a01_put_node (acv, put_node);
            sc_symb   := symb;
            last_node := put_node;
            a_ap_tree^[ last_node ].n_length := 0;
            IF  (a01_eqkey (a01kw[ cak_i_with ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)) AND
                (a_sqlmode in [ sqlm_internal, sqlm_db2 ])
                (* PTS 1121018 M.Ki. *)
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_default)
                THEN
                    WITH a_ap_tree^[ last_node ] DO
                        BEGIN
                        n_pos    := sc_sypos;
                        n_length := cak_i_with
                        END
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (* PTS 1121138 E.Z. *)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20key_spec (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2;
            VAR col_node : tsp00_Int2;
            VAR found    : boolean);
 
VAR
      using_clause_found : boolean;
      dummy_bool         : boolean;
      aux_symb           : tak_sc_symbol;
      last_node          : tsp00_Int2;
      aux_scv            : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    aux_scv := a_scv;      (* If PRIMARY is no reserved keyword, we check *)
    a01_next_symbol (acv); (* first, whether the following word is KEY.   *)
    found := a01_eqkey (a01kw[ cak_i_key ], a_sqlmode,
          a_cmd_part^.sp1p_buf, a_scv);
    a_scv := aux_scv;
    IF  found
    THEN
        WITH acv, a_scv DO
            BEGIN
            sc_symb := s_key;
            a01_put_node (acv, last_node);
            col_node := last_node;
            put_node := last_node;
            a01_next_symbol (acv);
            IF  a01mandatory_keyword (acv, cak_i_key)
            THEN
                BEGIN
                a01_force_symbol (acv, s_leftpar, put_node, last_node);
                IF  a_returncode = 0
                THEN
                    BEGIN
                    a02_l_acolumn_list (acv,
                          a_ap_tree^[last_node].n_sa_level, last_node);
                    a01_force_symbol (acv, s_rightpar, put_node, last_node);
                    ak20using_index_clause (acv, using_clause_found);
                    IF  using_clause_found
                    THEN
                        BEGIN
                        aux_symb := sc_symb;
                        sc_symb  := s_index;
                        a01_put_node (acv, last_node);
                        sc_symb  := aux_symb;
                        a_ap_tree^[col_node].n_lo_level := last_node;
                        col_node := last_node;
                        WITH a_ap_tree^[last_node] DO
                            BEGIN
                            n_subproc := cak_i_unique;
                            END;
                        (*ENDWITH*) 
                        a_ap_tree^[last_node].n_sa_level :=
                              a_ap_tree^[put_node].n_sa_level
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20cluster_spec (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2;
            VAR col_node : tsp00_Int2;
            VAR found    : boolean);
 
VAR
      last_node : tsp00_Int2;
      aux_scv   : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    found   := true;
    sc_symb := s_stamp;
    a01_put_node (acv, last_node);
    col_node := last_node;
    put_node := last_node;
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_leftpar, put_node, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        a02_l_acolumn_list (acv,
              a_ap_tree^[last_node].n_sa_level, last_node);
        aux_scv := acv.a_scv;
        a01_force_symbol (acv, s_rightpar, put_node, last_node);
        acv.a_scv := aux_scv;
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20unique_spec (
            VAR acv       : tak_all_command_glob;
            kw_index      : integer;
            name_node     : integer;
            VAR put_node  : tsp00_Int2;
            VAR col_node  : tsp00_Int2;
            VAR found     : boolean);
 
VAR
      dummy_bool : boolean;
      last_node  : tsp00_Int2;
      aux_scv    : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    aux_scv := a_scv;      (* If UNIQUE is no reserved keyword, we check *)
    a01_next_symbol (acv); (* first, whether the following word is '('.  *)
    found := sc_symb = s_leftpar;
    a_scv := aux_scv;
    IF  found
    THEN
        BEGIN
        sc_symb := s_index;
        a01_put_node (acv, last_node);
        a_ap_tree^[last_node].n_subproc := kw_index;
        col_node := last_node;
        put_node := last_node;
        a01_next_symbol (acv);
        IF  name_node <> 0
        THEN
            BEGIN
            a_ap_tree^[name_node].n_symb     := s_reference_name;
            a_ap_tree^[last_node].n_sa_level := name_node;
            last_node := name_node
            END;
        (*ENDIF*) 
        a01_force_symbol (acv, s_leftpar, put_node, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            a02_l_acolumn_list (acv,
                  a_ap_tree^[ last_node ].n_sa_level, last_node);
            a01_force_symbol (acv, s_rightpar, put_node, last_node);
            ak20using_index_clause (acv, dummy_bool)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20unique_info (
            VAR acv         : tak_all_command_glob;
            constraint_node : tsp00_Int2;
            col_node        : tsp00_Int2;
            VAR put_node    : tsp00_Int2);
 
VAR
      init_symb : tak_sc_symbol;
      last_n    : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    init_symb := sc_symb;
    sc_symb   := s_index;
    a01_put_node (acv, put_node);
    a_ap_tree^[put_node].n_subproc := cak_i_unique;
    a01_put_node (acv, last_n);
    a_ap_tree^[last_n] := a_ap_tree^[col_node];
    WITH a_ap_tree^[last_n] DO
        BEGIN
        n_sa_level := 0;
        n_lo_level := 0
        END;
    (*ENDWITH*) 
    IF  constraint_node <> 0
    THEN
        WITH a_ap_tree^[constraint_node] DO
            BEGIN
            n_symb     := s_reference_name;
            n_sa_level := last_n;
            last_n     := constraint_node
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    a_ap_tree^[put_node].n_sa_level := last_n;
    sc_symb := init_symb
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20using_index_clause (
            VAR acv   : tak_all_command_glob;
            VAR found : boolean);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    found := false;
    IF  sc_symb <> s_eof
    THEN
        IF  a_sqlmode = sqlm_oracle
        THEN
            IF  a01_eqkey (a01kw[cak_i_using], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_index)
                THEN
                    BEGIN
                    found := true;
                    ak20rest_syntax (acv)
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20create_index_stmt  (
            VAR acv         : tak_all_command_glob;
            VAR put_node    : tsp00_Int2;
            unique          : boolean);
 
VAR
      kw_index  : integer;
      indicator : tsp00_Int2;
      curr_n    : tsp00_Int2;
      last_n    : tsp00_Int2;
      res_kw    : boolean;
 
BEGIN
acv.a_is_ddl := ddl_create_index;
IF  unique
THEN
    BEGIN
    indicator := cak_x_create_unique_index;
    a01_next_symbol (acv);
    a01_get_keyword (acv, kw_index, res_kw);
    IF  kw_index <> cak_i_index
    THEN
        a07_error (acv, e_wanted_keyword,
              put_node, last_n);
    (*ENDIF*) 
    END
ELSE
    indicator := cak_x_create_index;
(*ENDIF*) 
a01_next_symbol (acv);
a01_get_keyword (acv, kw_index, res_kw);
IF  (kw_index = cak_i_restart) AND NOT unique
THEN
    BEGIN
    a01_next_symbol (acv);
    a01_call_put (acv, a24, cak_x_recreate_bad_index, curr_n);
    END
ELSE
    BEGIN
    a01_call_put (acv, a24, indicator, curr_n);
    put_node := curr_n;
    IF  acv.a_scv.sc_symb <> s_identifier
    THEN
        a07_error (acv, e_missing_identifier, put_node, last_n)
    ELSE
        BEGIN
        ak20_a_create_index (acv, acv.a_ap_tree^[ curr_n ].n_lo_level,
              last_n);
        IF  acv.a_scv.sc_symb <> s_eof
        THEN
            CASE acv.a_sqlmode OF
                sqlm_db2 :
                    ak20rest_db2_index_syntax (acv);
                sqlm_oracle :
                    ak20rest_syntax (acv);
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20rest_db2_index_syntax (VAR acv : tak_all_command_glob);
 
VAR
      symbindex : integer;
      res_kw    : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_get_keyword (acv, symbindex, res_kw);
    CASE symbindex OF
        cak_i_bufferpool, cak_i_close, cak_i_cluster,
        cak_i_dsetpass, cak_i_freepage, cak_i_in, cak_i_pctfree,
        cak_i_subpages, cak_i_using :
            sc_symb := s_eof;
        OTHERWISE ;
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20_a_create_index (
            VAR acv         : tak_all_command_glob;
            VAR put_node    : tsp00_Int2;
            VAR last_node   : tsp00_Int2);
 
VAR
      next    : boolean;
      last_n  : tsp00_Int2;
      ikw     : integer;
      res_kw  : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    a01_get_keyword (acv, ikw, res_kw);
    IF  res_kw
    THEN
        a07_error (acv, e_reserved_identifier,
              put_node, last_node)
    ELSE
        BEGIN
        a02_aindexname (acv, put_node, last_node);
        IF  a01mandatory_keyword (acv, cak_i_on)
        THEN
            BEGIN
            a02_atablename (acv,
                  acv.a_ap_tree^[ last_node ].n_sa_level,
                  last_n);
            a01_force_symbol (acv, s_leftpar,
                  put_node, last_n);
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                next := false;
                REPEAT
                    IF  next
                    THEN
                        a01_next_symbol (acv);
                    (*ENDIF*) 
                    next := true;
                    ak20index_clause (acv,
                          acv.a_ap_tree^[ last_n ].n_sa_level,
                          last_n);
                UNTIL
                    (acv.a_scv.sc_symb <> s_comma);
                (*ENDREPEAT*) 
                a01_force_symbol (acv, s_rightpar,
                      put_node, last_n)
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20index_clause  (
            VAR acv         : tak_all_command_glob;
            VAR put_node    : tsp00_Int2;
            VAR last_node   : tsp00_Int2);
 
VAR
      next   : boolean;
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        a02_n_acolumnname (acv, put_node, last_node);
        IF  sc_symb = s_leftpar
        THEN
            BEGIN (* user defined function *)
            a_ap_tree^[last_node].n_symb := s_user_func;
            a01_next_symbol (acv);
            a02_l_acolumn_list (acv, acv.a_ap_tree^[last_node].n_lo_level, last_node);
            a01_force_symbol (acv, s_rightpar, put_node, last_node);
            END
        ELSE
            a_ap_tree^[last_node].n_symb := s_columnname;
        (*ENDIF*) 
        next := false;
        IF  sc_symb = s_identifier
        THEN
            BEGIN
            IF  a01_eqkey (a01kw[ cak_i_desc ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                sc_symb := s_desc;
                next    := true;
                END
            ELSE
                IF  a01_eqkey (a01kw[ cak_i_asc ], a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    BEGIN
                    sc_symb := s_asc;
                    next    := true;
                    END
                ELSE
                    sc_symb := s_asc;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                a01_put_node (acv, curr_n);
                a_ap_tree^ [ last_node ].n_lo_level := curr_n;
                IF  next
                THEN
                    IF  a_is_ddl <> ddl_create_index
                    THEN
                        a07_error (acv,
                              e_invalid_keyword, put_node, last_node)
                    ELSE
                        a01_next_symbol (acv);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20aindex_drop (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_drop_index;
    a01_next_symbol (acv);
    a01_call_put (acv, a24, cak_x_drop_index, curr_n);
    put_node := curr_n;
    a02_aindexname (acv, a_ap_tree^[ curr_n ].n_lo_level,
          last_n);
    IF  a01_eqkey (a01kw[ cak_i_on], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        BEGIN
        a01_next_symbol (acv);
        a02_atablename (acv, a_ap_tree^[ last_n ].n_sa_level,
              last_n)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20create_role_stmt (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      res_kw   : boolean;
      kw_index : integer;
      last_n   : tsp00_Int2;
      aux_scv  : tak_scanner_glob;
 
BEGIN
WITH acv DO
    BEGIN
    a_is_ddl := ddl_create_role;
    a01_call_put       (acv, a21, cak_x_create_role, put_node);
    a01_next_symbol    (acv);
    a02_put_identifier (acv, a_ap_tree^[put_node].n_lo_level, last_n);
    IF  a_scv.sc_symb <> s_eof
    THEN
        BEGIN
        a01_get_keyword (acv, kw_index, res_kw);
        CASE kw_index OF
            cak_i_not :
                IF  a01mandatory_keyword (acv, cak_i_identified)
                THEN
                    BEGIN
                    END;
                (*ENDIF*) 
            cak_i_identified :
                BEGIN
                a01_next_symbol (acv);
                aux_scv := a_scv;
                IF  a01mandatory_keyword (acv, cak_i_by)
                THEN
                    BEGIN
                    a_scv := aux_scv;
                    a01_get_password (acv,
                          a_ap_tree^[last_n].n_lo_level, last_n);
                    a01_next_symbol (acv)
                    END;
                (*ENDIF*) 
                END;
            OTHERWISE
                a07_error (acv, e_wanted_keyword, put_node, last_n);
            END;
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_role_stmt (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n   : tsp00_Int2;
 
BEGIN
WITH acv DO
    BEGIN
    a_is_ddl := ddl_drop_role;
    a01_call_put       (acv, a21, cak_x_drop_role, put_node);
    a01_next_symbol    (acv);
    a02_put_identifier (acv, a_ap_tree^[put_node].n_lo_level, last_n);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20DropSchemaStatement (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      res_kw : boolean;
      kw     : integer;
      last_n : tsp00_Int2;
 
BEGIN
acv.a_is_ddl := ddl_drop_schema;
a01_call_put       (acv, a21, cak_x_drop_schema, put_node);
acv.a_ap_tree^[put_node].n_length := cak_i_cascade;
a01_next_symbol    (acv);
a02_put_identifier (acv, acv.a_ap_tree^[put_node].n_lo_level, last_n);
IF  acv.a_scv.sc_symb <> s_eof
THEN
    BEGIN
    a01_get_keyword (acv, kw, res_kw);
    IF  (kw = cak_i_cascade) OR
        (kw = cak_i_restrict)
    THEN
        BEGIN
        a01_next_symbol (acv);
        acv.a_ap_tree^[put_node].n_length := kw
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak21SchemaName (
            VAR acv           : tak_all_command_glob;
            VAR put_node      : tsp00_Int2;
            VAR last_node     : tsp00_Int2);
 
VAR
      res_kw   : boolean;
      kw_index : integer;
 
BEGIN
a01_next_symbol (acv);
a01_get_keyword (acv, kw_index, res_kw);
IF  res_kw OR (kw_index = cak_i_temp)
THEN
    a07_error (acv, e_reserved_identifier,
          put_node, last_node)
ELSE
    a02_aauthid (acv, put_node, last_node);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20CreateSchema (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2);
 
CONST
      c_is_replace = true;
 
VAR
      res_kw     : boolean;
      startPos   : integer;
      kw_index   : integer;
      last_node  : tsp00_Int2;
      dummy_node : tsp00_Int2;
 
BEGIN
a01_call_put    (acv, a21, cak_x_create_schema, put_node);
acv.a_is_ddl := ddl_create_schema;
(*a01_compact_cmd (acv);*)
acv.a_scv.sc_newpos := 1;
a01_next_symbol (acv);
a01_next_symbol (acv);
ak21SchemaName (acv, acv.a_ap_tree^[put_node].n_lo_level, last_node);
IF  acv.a_scv.sc_symb <> s_eof
THEN
    IF  a01_eqkey (a01kw[cak_i_authorization], acv.a_sqlmode,
        acv.a_cmd_part^.sp1p_buf, acv.a_scv)
    THEN
        BEGIN
        a01_next_symbol (acv);
        a02_aauthid (acv, acv.a_ap_tree^[put_node].n_sa_level, dummy_node);
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_scv.sc_symb <> s_eof
THEN
    BEGIN
    REPEAT
        startPos := acv.a_scv.sc_sypos;
&       ifdef trace
        t01int4 (ak_syn, 'startPos    ', startPos);
&       endif
        IF  a01mandatory_keyword (acv, cak_i_create)
        THEN
            BEGIN
            a01_call_put   (acv, a21, cak_x_create_schema,
                  acv.a_ap_tree^[last_node].n_lo_level);
            last_node := acv.a_ap_tree^[last_node].n_lo_level;
            a01_get_keyword (acv, kw_index, res_kw);
            acv.a_scv.sc_eof_kw := cak_i_create;
            CASE kw_index OF
                cak_i_function,
                cak_i_dbproc,
                cak_i_dbprocedure,
                cak_i_procedure (* PTS 1132753 *) :
                    a201create_dbproc (acv, kw_index, NOT c_is_replace, acv.a_ap_tree^[last_node].n_sa_level);
                cak_i_sequence :
                    ak20create_sequence_stmt (acv, acv.a_ap_tree^[last_node].n_sa_level);
                cak_i_table :
                    a20create_table_stmt (acv, true, acv.a_ap_tree^[last_node].n_sa_level);
                cak_i_view :
                    ak20create_view_stmt (acv, false, NOT c_is_replace, 0, acv.a_ap_tree^[last_node].n_sa_level);
                OTHERWISE :
                    a07_error (acv,
                          e_wanted_keyword, put_node, last_node);
                END;
            (*ENDCASE*) 
            acv.a_ap_tree^[last_node].n_pos    := startPos;
            acv.a_ap_tree^[last_node].n_length := acv.a_scv.sc_newpos - startPos;
            acv.a_scv.sc_eof_kw := cak_i_no_keyword;
            a01_next_symbol (acv);
            END;
        (*ENDIF*) 
    UNTIL
        (acv.a_scv.sc_symb = s_eof) OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20create_sequence_stmt (
            VAR acv           : tak_all_command_glob;
            VAR put_node      : tsp00_Int2);
 
TYPE
      seq_param_type = (
            increment,
            cache,
            cycle,
            maxvalue,
            minvalue,
            nocache,
            nocycle,
            nomaxvalue,
            nominvalue,
            noorder,
            order,
            start,
            end_mark);
 
VAR
      res_kw    : boolean;
      found     : boolean;
      kw_index  : integer;
      last_n    : tsp00_Int2;
      curr_n    : tsp00_Int2;
      seq_index : seq_param_type;
 
      seq_params: ARRAY[seq_param_type] OF RECORD
            snode  : tsp00_Int2;
            sfound : boolean;
      END;
 
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_create_sequence;
    a01_call_put (acv, a23, cak_x_create_sequence, put_node);
    a01_next_symbol (acv);
    a02_atablename  (acv,
          a_ap_tree^[ put_node ].n_lo_level, last_n);
    IF  (a_returncode = 0) AND (sc_symb <> s_eof)
    THEN
        BEGIN
        FOR seq_index := increment TO start DO
            BEGIN
            seq_params[seq_index].snode  := 0;
            seq_params[seq_index].sfound := false;
            END;
        (*ENDFOR*) 
        REPEAT
            seq_index := increment;
            found     := true;
            a01_get_keyword (acv, kw_index, res_kw);
            CASE kw_index OF
                cak_i_increment :
                    seq_index := increment;
                cak_i_cache :
                    seq_index := cache;
                cak_i_cycle :
                    seq_index := cycle;
                cak_i_maxvalue :
                    seq_index := maxvalue;
                cak_i_minvalue :
                    seq_index := minvalue;
                cak_i_nocache  :
                    seq_index := nocache;
                cak_i_nocycle :
                    seq_index := nocycle;
                cak_i_nomaxvalue :
                    seq_index := nomaxvalue;
                cak_i_nominvalue :
                    seq_index := nominvalue;
                cak_i_noorder    :
                    seq_index := noorder;
                cak_i_order      :
                    seq_index := order;
                cak_i_start      :
                    seq_index := start;
                OTHERWISE
                    found := false
                END;
            (*ENDCASE*) 
            IF  found
            THEN
                IF  seq_params[seq_index].sfound
                THEN
                    found := false;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  found
            THEN
                WITH seq_params[seq_index] DO
                    BEGIN
                    sfound := true;
                    a01_next_symbol (acv);
                    CASE seq_index OF
                        increment :
                            IF  a01mandatory_keyword (acv, cak_i_by)
                            THEN
                                BEGIN
                                a01_call_put (acv, a23,
                                      cak_i_increment, snode);
                                a03_ainteger (acv, curr_n,
                                      a_ap_tree^[ snode ].n_lo_level)
                                END;
                            (*ENDIF*) 
                        minvalue, maxvalue, cache :
                            BEGIN
                            a01_call_put (acv,
                                  a23, kw_index, snode);
                            a03_ainteger (acv, curr_n,
                                  a_ap_tree^[ snode ].n_lo_level)
                            END;
                        nocache :
                            a01_call_put (acv,
                                  a23, kw_index, snode);
                        cycle :
                            a_ap_tree^[ put_node ].n_length :=
                                  cak_i_round;
                        start :
                            IF  a01mandatory_keyword (acv, cak_i_with)
                            THEN
                                BEGIN
                                a01_call_put (acv,
                                      a23, cak_i_start, snode);
                                a03_ainteger (acv, curr_n,
                                      a_ap_tree^[ snode ].n_lo_level)
                                END;
                            (*ENDIF*) 
                        OTHERWISE ;
                        END;
                    (*ENDCASE*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
        UNTIL
            NOT found OR (sc_symb = s_eof) OR
            (a_returncode <> 0);
        (*ENDREPEAT*) 
        IF  NOT found
        THEN
            a07_error (acv,
                  e_wanted_keyword, put_node, last_n)
        ELSE
            FOR seq_index := increment TO pred (end_mark) DO
                WITH seq_params[seq_index] DO
                    IF  snode <> 0
                    THEN
                        BEGIN
                        a_ap_tree^[last_n].n_sa_level := snode;
                        last_n := snode
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDFOR*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20create_synonym_stmt  (
            VAR acv           : tak_all_command_glob;
            kw_index          : integer;
            VAR put_node      : tsp00_Int2);
 
VAR
      last_n   : tsp00_Int2;
      first_n  : tsp00_Int2;
      ikw      : integer;
      res_kw   : boolean;
      aux_scv  : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_create_synonym;
    a01_call_put (acv, a23, cak_x_create_synonym, put_node);
    a_ap_tree^[put_node].n_length := kw_index;
    first_n := put_node;
    a01_next_symbol (acv);
    a02_asynonymname  (acv,
          a_ap_tree^[put_node].n_lo_level, last_n);
    IF  a01mandatory_keyword (acv, cak_i_for)
    THEN
        a02_atablename  (acv,
              a_ap_tree^[last_n].n_lo_level, last_n);
    (* for Oracle-systemviews with INTERNAL, although INTERNAL is no keyword *)
    (*ENDIF*) 
    IF  a01_eqkey (a01kw[cak_i_internal], sqlm_internal, (* 1109071 *)
        a_cmd_part^.sp1p_buf, a_scv)
        AND
        (a_initial_segment_header.sp1c_producer in
        [sp1pr_internal_cmd, sp1pr_installation])
    THEN
        BEGIN
        a01_call_put (acv, a23, cak_i_internal, last_n);
        a_ap_tree^[last_n].n_lo_level := a_ap_tree^[first_n].n_lo_level;
        a_ap_tree^[first_n].n_lo_level := last_n;
        a01_next_symbol (acv)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_sequence (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_drop_sequence;
    a01_call_put (acv, a23, cak_x_drop_sequence, put_node);
    a01_next_symbol (acv);
    a02_atablename  (acv, a_ap_tree^[ put_node ].n_lo_level, last_n)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_package (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
 
BEGIN
(* PTS 1115155 E.Z. *)
acv.a_is_ddl := ddl_drop_package;
a01_next_symbol (acv);
a01_call_put       (acv, a12, cak_x_drop_package, put_node);
a02_put_identifier (acv, acv.a_ap_tree^[put_node].n_lo_level, last_n)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_synonym  (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2;
            kw_index     : integer);
 
VAR
      last_n : tsp00_Int2;
 
BEGIN
WITH acv DO
    BEGIN
    a_is_ddl := ddl_drop_synonym;
    a01_call_put (acv, a23, cak_x_drop_synonym, put_node);
    a_ap_tree^[put_node].n_length := kw_index;
    a01_next_symbol (acv);
    a02_asynonymname  (acv, a_ap_tree^[ put_node ].n_lo_level, last_n)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20create_package  (
            VAR acv        : tak_all_command_glob;
            is_replace     : boolean;
            VAR put_node   : tsp00_Int2);
 
VAR
      indicator : integer;
      res_kw    : boolean;
      kw_index  : integer;
      last_n    : tsp00_Int2;
 
BEGIN
indicator    := cak_x_create_package;
acv.a_is_ddl := ddl_create_package;
a01_call_put (acv, a12, indicator, put_node);
acv.a_ap_tree^[put_node].n_length := cak_i_local;
acv.a_ap_tree^[put_node].n_pos    := ord(is_replace);
a01_next_symbol (acv);
a02procedure (acv, acv.a_ap_tree^[put_node].n_lo_level, last_n);
a01_get_keyword (acv, kw_index, res_kw);
CASE kw_index OF
    cak_i_file :
        BEGIN
        a01_next_symbol (acv);
        a03_astring_literal (acv, acv.a_ap_tree^[put_node].n_sa_level, last_n);
        acv.a_ap_tree^[last_n].n_symb := s_hostfilename;
        END;
    OTHERWISE
        a07_error (acv, e_wanted_keyword, put_node, last_n);
    END;
(*ENDCASE*) 
IF  acv.a_scv.sc_symb <> s_eof
THEN
    BEGIN
    a01_get_keyword (acv, kw_index, res_kw);
    acv.a_ap_tree^[put_node].n_length := kw_index;
    CASE kw_index OF
        cak_i_inproc, cak_i_local :
            BEGIN
            a01_next_symbol (acv);
            END;
        cak_i_remote :
            BEGIN
            a01_next_symbol (acv);
            IF  a01mandatory_keyword (acv, cak_i_at)
            THEN
                a03_astring_literal (acv, acv.a_ap_tree^[last_n].n_sa_level, last_n);
            (*ENDIF*) 
            END;
        OTHERWISE
            a07_error (acv, e_wanted_keyword, put_node, last_n);
        END;
    (*ENDCASE*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20create_type  (
            VAR acv        : tak_all_command_glob;
            VAR put_node   : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
 
BEGIN
a01_call_put    (acv, a12, cak_x_create_type, put_node);
a01_next_symbol (acv);
a02_put_identifier (acv, acv.a_ap_tree^[put_node].n_lo_level, last_n);
IF  a01mandatory_keyword (acv, cak_i_as)
THEN
    BEGIN
    a03_astring_literal (acv, acv.a_ap_tree^[put_node].n_sa_level, last_n)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20create_user_stmt  (
            VAR acv        : tak_all_command_glob;
            VAR put_node   : tsp00_Int2;
            symbindex      : integer);
 
VAR
      stop       : boolean;
      i          : integer;
      kw_index   : integer;
      res_kw     : boolean;
      indicator  : integer;
      last_n     : tsp00_Int2;
      curr_n     : tsp00_Int2;
      keywordset : tkeywordset;
      aux_scv    : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_create_user;
    IF  symbindex <> cak_i_user
    THEN
        indicator := cak_x_user_group
    ELSE
        indicator := 0;
    (*ENDIF*) 
    a01_call_put (acv, a21, cak_x_create_user + indicator, curr_n);
    a01_next_symbol (acv);
    put_node := curr_n;
    a01_get_keyword (acv, kw_index, res_kw);
    IF  res_kw OR (kw_index = cak_i_temp)
    THEN
        a07_error (acv, e_reserved_identifier,
              curr_n, curr_n);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        a02_aauthid (acv, a_ap_tree^[ curr_n ].n_lo_level, last_n);
    (*ENDIF*) 
    IF  (a_returncode = 0) AND (a_sqlmode = sqlm_internal)
    THEN
        BEGIN
        stop := false;
        IF  (a01_eqkey (a01kw[ cak_i_password ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)) AND (symbindex = cak_i_user)
        THEN
            BEGIN
            a01_get_password (acv,
                  a_ap_tree^[last_n].n_lo_level, last_n);
            a01_next_symbol (acv)
            END
        ELSE
            IF  (symbindex <> cak_i_usergroup) AND
                (a_data_length < csp_attr_byte + CRYPTPW_MXSP00)
            THEN
                BEGIN
                stop := true;
                a07_error (acv, e_wanted_keyword,
                      put_node, last_n);
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  sc_symb = s_eof
        THEN
            (* PTS 1107952 E.Z. *)
            kw_index := cak_i_cachelimit
        ELSE
            a01_get_keyword (acv, kw_index, res_kw);
        (*ENDIF*) 
        CASE kw_index OF
            cak_i_like :
                BEGIN
                a_ap_tree^[ curr_n ].n_subproc :=
                      cak_x_user_like + indicator;
                a01_next_symbol (acv);
                a01_get_keyword (acv, kw_index, res_kw);
                IF  res_kw
                THEN
                    a07_error (acv, e_reserved_identifier,
                          curr_n, curr_n);
                (*ENDIF*) 
                a02_aauthid (acv, a_ap_tree^[ last_n ].n_sa_level,
                      curr_n);
                stop := true;
                END;
            cak_i_usergroup :
                IF  symbindex = cak_i_user
                THEN
                    BEGIN
                    a01_call_put (acv, a21, cak_i_usergroup, curr_n);
                    a_ap_tree^[ last_n ].n_sa_level := curr_n;
                    last_n := curr_n;
                    a01_next_symbol (acv);
                    a02_aauthid (acv, a_ap_tree^[last_n].n_lo_level,
                          curr_n);
                    stop := true;
                    END;
                (*ENDIF*) 
            cak_i_dba, cak_i_resource, cak_i_standard :
                BEGIN
                a01_call_put (acv, a21, kw_index, curr_n);
                a01_next_symbol (acv);
                END;
            (* PTS 1107952 E.Z. *)
            cak_i_costlimit, cak_i_costwarning,
            cak_i_exclusive, cak_i_not,
            cak_i_timeout,
            cak_i_cachelimit,
            cak_i_replication :
                a01_call_put (acv, a21, cak_i_standard, curr_n);
            OTHERWISE
                a07_error (acv, e_wanted_keyword, put_node, last_n);
            END;
        (*ENDCASE*) 
        IF  NOT (stop)
        THEN
            BEGIN
            FOR i := 0 TO cak_maxkeyword DO
                keywordset[ i ] := false;
            (*ENDFOR*) 
            a_ap_tree^[ last_n ].n_sa_level := curr_n;
            ak20userpar (acv, false, curr_n, keywordset);
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        (* sqlmode oracle *)
        IF  a01mandatory_keyword (acv, cak_i_identified)
        THEN
            BEGIN
            aux_scv := a_scv;
            IF  a01mandatory_keyword (acv, cak_i_by)
            THEN
                BEGIN
                a_scv := aux_scv;
                a01_get_password (acv,
                      a_ap_tree^[last_n].n_lo_level, last_n);
                a01_call_put (acv, a21, cak_i_resource,
                      a_ap_tree^[last_n].n_sa_level);
                (* skip oracle user attributes without checking *)
                REPEAT
                    a01_next_symbol (acv);
                UNTIL
                    sc_symb = s_eof;
                (*ENDREPEAT*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20userpar (
            VAR acv        : tak_all_command_glob;
            null_allowed   : boolean;
            VAR put_node   : tsp00_Int2;
            VAR keywordset : tkeywordset);
 
VAR
      not_allowed : boolean;
      kw_index    : integer;
      curr_n      : tsp00_Int2;
      last_n      : tsp00_Int2;
      p_error     : tgg00_BasisError;
      res_kw      : boolean;
      scvh        : tak_scanner_glob;
 
BEGIN
p_error     := e_ok;
not_allowed := true;
WITH acv, a_scv DO
    BEGIN
    WHILE (sc_symb <> s_eof) AND (p_error = e_ok) DO
        BEGIN
        a01_get_keyword (acv, kw_index, res_kw);
        IF  keywordset[ kw_index ]
        THEN
            p_error := e_invalid_keyword
        ELSE
            BEGIN
            keywordset[ kw_index ] := true;
            a01_call_put (acv, a21, kw_index, curr_n);
            a_ap_tree^[ put_node ].n_sa_level := curr_n;
            put_node := curr_n;
            scvh := a_scv;
            a01_next_symbol (acv);
            CASE kw_index OF
                cak_i_not :
                    IF  not_allowed
                    THEN
                        IF  a01_eqkey (a01kw[ cak_i_exclusive ], a_sqlmode,
                            a_cmd_part^.sp1p_buf,
                            a_scv)
                        THEN
                            BEGIN
                            keywordset[ cak_i_exclusive ] := true;
                            not_allowed := false;
                            a01_next_symbol (acv)
                            END
                        ELSE
                            p_error := e_invalid_keyword
                        (*ENDIF*) 
                    ELSE
                        p_error := e_invalid_keyword;
                    (*ENDIF*) 
                (* PTS 1107952 E.Z. *)
                cak_i_costlimit,
                cak_i_costwarning, cak_i_timeout, cak_i_cachelimit :
                    IF  a01_eqkey (a01kw[ cak_i_null ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                        AND (null_allowed)
                    THEN
                        a01_next_symbol (acv)
                    ELSE
                        a03_aunsigned_integer (acv, curr_n,
                              a_ap_tree^[ put_node ].n_lo_level);
                    (*ENDIF*) 
                cak_i_exclusive :
                    not_allowed := false;
                (* PTS 1117216 E.Z. *)
                cak_i_defaultcode :
                    BEGIN
                    IF  a01_eqkey (a01kw[ cak_i_ascii ], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        a_ap_tree^[ put_node ].n_length := csp_ascii
                    ELSE
                        (* PTS 1122828 E.Z. *)
                        IF  g01unicode AND
                            (a01_eqkey (a01kw[ cak_i_unicode ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv))
                        THEN
                            a_ap_tree^[ put_node ].n_length := csp_unicode
                        ELSE
                            a07_error (acv, e_invalid_keyword, put_node, put_node);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    a01_next_symbol (acv)
                    END;
                cak_i_replication :
                    IF  acv.a_current_user_kind <> usysdba
                    THEN
                        BEGIN
                        a_scv   := scvh;
                        p_error := e_invalid_keyword;
                        END;
                    (*ENDIF*) 
                cak_i_enable, cak_i_disable :
                    BEGIN
                    IF  kw_index = cak_i_enable
                    THEN
                        keywordset[ cak_i_disable ] := true
                    ELSE
                        keywordset[ cak_i_enable  ] := true;
                    (*ENDIF*) 
                    IF  a01mandatory_keyword (acv, cak_i_connect)
                    THEN ;
                    (*ENDIF*) 
                    END;
                OTHERWISE
                    BEGIN
                    a_scv   := scvh;
                    p_error := e_invalid_keyword;
                    END
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  p_error <> e_ok
    THEN
        a07_error (acv, p_error, put_node, put_node)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20alter_user  (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2;
            symbindex    : integer);
 
VAR
      i          : integer;
      pos        : integer;
      kw_index   : integer;
      indicator  : integer;
      last_n     : tsp00_Int2;
      curr_n     : tsp00_Int2;
      dummy_n    : tsp00_Int2;
      keywordset : tkeywordset;
      res_kw     : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl   := ddl_alter_user;
    indicator  := cak_x_alter_user;
    IF  symbindex = cak_i_usergroup
    THEN
        indicator := indicator + cak_x_user_group;
    (*ENDIF*) 
    a01_call_put (acv, a21, indicator, curr_n);
    put_node := curr_n;
    a01_next_symbol (acv);
    a02_aauthid (acv, a_ap_tree^[ curr_n ].n_lo_level, last_n);
    IF  sc_symb = s_eof
    THEN
        a07_error (acv, e_invalid_end_of_command, put_node, put_node)
    ELSE
        BEGIN
        a01_get_keyword (acv, kw_index, res_kw);
        IF  a_sqlmode = sqlm_oracle
        THEN
            BEGIN
            IF  a01mandatory_keyword (acv, cak_i_identified)
            THEN
                IF  a01mandatory_keyword (acv, cak_i_by)
                THEN
                    BEGIN
                    a_is_ddl := ddl_alter_password;
                    a_ap_tree^[put_node].n_subproc :=
                          cak_x_alter_password;
                    pos       := sc_newpos;
                    sc_newpos := sc_sypos;
                    a01_get_password (acv,
                          a_ap_tree^[last_n].n_sa_level, last_n);
                    sc_newpos := pos;
                    a01_next_symbol (acv)
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            CASE kw_index OF
                cak_i_dba, cak_i_resource, cak_i_standard :
                    BEGIN
                    a01_call_put (acv, a21, kw_index, curr_n);
                    a01_next_symbol (acv);
                    END;
                cak_i_default :
                    BEGIN
                    a01_next_symbol (acv);
                    IF  a01mandatory_keyword (acv, cak_i_role)
                    THEN
                        BEGIN
                        a01_call_put (acv, a21, cak_i_role, curr_n);
                        a01_get_keyword (acv, kw_index, res_kw);
                        a_ap_tree^[curr_n].n_length := kw_index;
                        CASE kw_index OF
                            cak_i_all :
                                BEGIN
                                a01_next_symbol (acv);
                                IF  sc_symb <> s_eof
                                THEN
                                    IF  a01mandatory_keyword(acv, cak_i_except)
                                    THEN
                                        BEGIN
                                        a_ap_tree^[curr_n].n_length :=
                                              cak_i_except;
                                        a02_l_acolumn_list (acv,
                                              a_ap_tree^[curr_n].n_lo_level,
                                              dummy_n)
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END;
                            cak_i_none :
                                BEGIN
                                a01_next_symbol (acv);
                                END;
                            OTHERWISE
                                a02_l_acolumn_list (acv,
                                      a_ap_tree^[curr_n].n_lo_level,
                                      dummy_n);
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDIF*) 
                    END;
                cak_i_add, cak_i_drop :
                    (* PTS 1115025 E.Z. *)
                    IF  (a_comp_type <> at_db_manager) OR
                        (symbindex = cak_i_usergroup)
                    THEN
                        a07_error (acv, e_missing_keyword, put_node, put_node)
                    ELSE
                        BEGIN
                        a01_next_symbol (acv);
                        IF  a01_eqkey (a01kw[ cak_i_password ], a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv)
                        THEN
                            BEGIN
                            a01_call_put (acv, a21, kw_index, curr_n);
                            a_ap_tree^[ last_n ].n_sa_level := curr_n;
                            a01_get_password (acv, a_ap_tree^[ curr_n ].n_lo_level, curr_n);
                            a01_next_symbol (acv);
                            IF  sc_symb <> s_eof
                            THEN
                                a07_error (acv, e_invalid_end_of_command,
                                      put_node, put_node);
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                OTHERWISE
                    a01_call_put (acv, a21, 0, curr_n);
                END;
            (*ENDCASE*) 
            IF  (kw_index <> cak_i_add) AND
                (kw_index <> cak_i_drop)
            THEN
                BEGIN
                a_ap_tree^[ last_n ].n_sa_level := curr_n;
                last_n := curr_n;
                FOR i := 0 TO cak_maxkeyword DO
                    keywordset[ i ] := false;
                (*ENDFOR*) 
                keywordset [cak_i_replication] := true;
                ak20userpar (acv, true, last_n, keywordset)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20drop_user  (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2;
            symbindex    : integer);
 
VAR
      res_kw    : boolean;
      indicator : integer;
      last_n    : tsp00_Int2;
      curr_n    : tsp00_Int2;
      kw        : integer;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl  := ddl_drop_user;
    indicator := cak_x_drop_user;
    IF  symbindex = cak_i_usergroup
    THEN
        indicator := indicator + cak_x_user_group;
    (*ENDIF*) 
    a01_call_put (acv, a21, indicator, curr_n);
    put_node := curr_n;
    IF  a_sqlmode = sqlm_internal
    THEN
        a_ap_tree^[put_node].n_length := cak_i_cascade
    ELSE
        a_ap_tree^[put_node].n_length := cak_i_restrict;
    (*ENDIF*) 
    a01_next_symbol (acv);
    a02_aauthid (acv, a_ap_tree^[ curr_n ].n_lo_level, last_n);
    IF  sc_symb <> s_eof
    THEN
        BEGIN
        a01_get_keyword (acv, kw, res_kw);
        IF  (kw = cak_i_cascade) OR
            ((kw = cak_i_restrict) AND (a_sqlmode = sqlm_internal))
        THEN
            BEGIN
            a01_next_symbol (acv);
            a_ap_tree^[put_node].n_length := kw
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20alter_index (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2;
            isDiagnose   : boolean);
 
VAR
      res_kw   : boolean;
      kw_index : integer;
      last_n   : tsp00_Int2;
 
BEGIN
a01_call_put    (acv, a24, cak_i_alter, put_node);
a01_next_symbol (acv);
a02_aindexname (acv, acv.a_ap_tree^[put_node].n_lo_level, last_n);
IF  a01_eqkey (a01kw[ cak_i_on ], acv.a_sqlmode,
    acv.a_cmd_part^.sp1p_buf, acv.a_scv)
THEN
    BEGIN
    a01_next_symbol (acv);
    a02_atablename  (acv, acv.a_ap_tree^[last_n].n_sa_level, last_n)
    END;
(*ENDIF*) 
a01_get_keyword (acv, kw_index, res_kw);
IF  NOT isDiagnose AND (kw_index = cak_i_bad)
THEN
    kw_index := 0;
(*ENDIF*) 
CASE kw_index OF
    cak_i_bad, cak_i_enable, cak_i_disable :
        BEGIN
        acv.a_ap_tree^[put_node].n_pos := kw_index;
        a01_next_symbol (acv);
        END;
    cak_i_init :
        BEGIN
        a01_next_symbol (acv);
        IF  a01_eqkey (a01kw[ cak_i_usage ], acv.a_sqlmode,
            acv.a_cmd_part^.sp1p_buf, acv.a_scv)
        THEN
            BEGIN
            acv.a_ap_tree^[put_node].n_pos := kw_index;
            a01_next_symbol (acv);
            END
        ELSE
            a07_error (acv, e_wanted_keyword, put_node, last_n);
        (*ENDIF*) 
        END;
    OTHERWISE
        a07_error (acv, e_wanted_keyword, put_node, last_n);
    END;
(*ENDCASE*) 
acv.a_return_segm^.sp1r_function_code := csp1_alter_index_fc;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20alter_password (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      kw_index : integer;
      last_n   : tsp00_Int2;
      curr_n   : tsp00_Int2;
      pos      : integer;
      userpos  : integer;
      pwPos    : integer;
      res_kw   : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_alter_password;
    a01_call_put (acv, a21, cak_x_alter_password, curr_n);
    put_node := curr_n;
    userpos := sc_newpos;
    a01_next_symbol (acv);
    IF  sc_symb <> s_eof
    THEN
        BEGIN
        (* PTS 1112485 PTS 1124383 *)
        a01_next_symbol (acv);
        a01_get_keyword (acv, kw_index, res_kw);
        sc_newpos := userpos;
        a01_next_symbol (acv);
        pwPos := sc_newpos;
        IF  kw_index = cak_i_to
        THEN
            BEGIN
            sc_newpos := userpos;
            a01_get_password (acv, a_ap_tree^[ curr_n ].n_lo_level, last_n);
            a01_next_symbol  (acv);
            END
        ELSE
            BEGIN
            a02_aauthid (acv, a_ap_tree^[ curr_n ].n_lo_level, last_n);
            sc_newpos := pwPos;
            END;
        (*ENDIF*) 
        IF  sc_symb <> s_eof
        THEN
            BEGIN
            a01_get_password (acv, a_ap_tree^[ last_n ].n_sa_level, last_n);
            a01_next_symbol (acv);
            END
        ELSE
            IF  a_data_length < csp_attr_byte + CRYPTPW_MXSP00
            THEN
                a07_error (acv, e_invalid_end_of_command,
                      last_n, last_n);
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        IF  a_data_length < 2 * (csp_attr_byte + CRYPTPW_MXSP00)
        THEN
            a07_error (acv, e_invalid_end_of_command, last_n, last_n);
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20grant_user (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2;
            symbindex    : integer);
 
VAR
      stop      : boolean;
      kw_index  : integer;
      indicator : integer;
      curr_n    : tsp00_Int2;
      last_n    : tsp00_Int2;
      res_kw    : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_is_ddl := ddl_grant_user;
    IF  symbindex = cak_i_usergroup
    THEN
        indicator := cak_x_user_group
    ELSE
        indicator := 0;
    (*ENDIF*) 
    a01_call_put (acv, a21, cak_x_grant_user + indicator, last_n);
    put_node := last_n;
    curr_n   := last_n;
    a01_next_symbol (acv);
    IF  sc_symb = s_asterisk
    THEN
        a01_next_symbol (acv)
    ELSE
        BEGIN
        stop := false;
        REPEAT
            a02_aauthid (acv,
                  a_ap_tree^[ last_n ].n_sa_level, last_n);
            IF  sc_symb <> s_comma
            THEN
                stop := true
            ELSE
                a01_next_symbol (acv);
            (*ENDIF*) 
        UNTIL
            (stop) OR (a_returncode <> 0);
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    a01_get_keyword (acv, kw_index, res_kw);
    IF  kw_index = cak_i_from
    THEN
        BEGIN
        a01_next_symbol (acv);
        a02_aauthid (acv, a_ap_tree^[ curr_n ].n_lo_level, last_n);
        END
    ELSE
        BEGIN
        a01_call_put (acv, a21, x_no_from_user, last_n);
        a_ap_tree^[ curr_n ].n_lo_level := last_n;
        END;
    (*ENDIF*) 
    IF  a01mandatory_keyword (acv, cak_i_to)
    THEN
        a02_aauthid (acv, a_ap_tree^[ last_n ].n_lo_level, last_n);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20schema_privileges (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2;
            kw_index     : integer);
 
VAR
      exit_loop : boolean;
      res_kw    : boolean;
      curr_kw   : integer;
      curr_node : tsp00_Int2;
      last_node : tsp00_Int2;
 
BEGIN
a01_call_put (acv, a22, cak_i_schema, put_node);
acv.a_ap_tree^[put_node].n_length := kw_index;
last_node := put_node;
IF  kw_index = cak_i_grant
THEN
    BEGIN
    acv.a_is_ddl := ddl_grant_privilege;
    kw_index     := cak_i_to
    END
ELSE
    BEGIN
    acv.a_is_ddl := ddl_revoke_privilege;
    kw_index     := cak_i_from
    END;
(*ENDIF*) 
exit_loop := false;
REPEAT
    a01_get_keyword (acv, curr_kw, res_kw);
    CASE curr_kw OF
        cak_i_alterin, cak_i_createin, cak_i_dropin :
            BEGIN
            a01_call_put (acv, a22, curr_kw, curr_node);
            acv.a_ap_tree^[last_node].n_sa_level := curr_node;
            last_node := curr_node;
            a01_next_symbol(acv);
            IF  acv.a_scv.sc_symb = s_comma
            THEN
                a01_next_symbol(acv)
            ELSE
                exit_loop := true;
            (*ENDIF*) 
            END;
        OTHERWISE
            a07_error (acv, e_wanted_keyword, put_node, put_node);
        END;
    (*ENDCASE*) 
UNTIL
    exit_loop OR (acv.a_returncode <> 0);
(*ENDREPEAT*) 
IF  a01mandatory_keyword (acv, cak_i_on)
THEN
    BEGIN
    a01_call_put (acv, a22, 0, last_node);
    acv.a_ap_tree^[put_node].n_lo_level := last_node;
    curr_node := last_node;
    exit_loop := false;
    REPEAT
        a02_put_identifier (acv, acv.a_ap_tree^[last_node].n_sa_level, last_node);
        IF  acv.a_scv.sc_symb = s_comma
        THEN
            a01_next_symbol(acv)
        ELSE
            exit_loop := true;
        (*ENDIF*) 
    UNTIL
        exit_loop OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    IF  a01mandatory_keyword (acv, kw_index)
    THEN
        BEGIN
        exit_loop := false;
        REPEAT
            a02_aauthid (acv, acv.a_ap_tree^[curr_node].n_lo_level, curr_node);
            IF  acv.a_scv.sc_symb = s_comma
            THEN
                a01_next_symbol(acv)
            ELSE
                exit_loop := true;
            (*ENDIF*) 
        UNTIL
            exit_loop OR (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20grant_revoke_privilege (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2;
            kw_index     : integer);
 
VAR
      res_kw : boolean;
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_call_put (acv, a22, kw_index, curr_n);
    a_ap_tree^[curr_n].n_length := 0;
    put_node                        := curr_n;
    IF  kw_index = cak_i_grant
    THEN
        BEGIN
        a_is_ddl := ddl_grant_privilege;
        kw_index := cak_i_to
        END
    ELSE
        BEGIN
        a_is_ddl := ddl_revoke_privilege;
        kw_index := cak_i_from
        END;
    (*ENDIF*) 
    ak20privileges (acv, a_ap_tree^[ curr_n ].n_lo_level, kw_index);
    IF  sc_symb <> s_eof
    THEN
        IF  kw_index = cak_i_to
        THEN
            BEGIN
            IF  a01_eqkey (a01kw[ cak_i_with ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  a01mandatory_keyword (acv, cak_i_grant)
                THEN
                    IF  a01mandatory_keyword (acv, cak_i_option)
                    THEN
                        a_ap_tree^[ curr_n ].n_length := cak_i_grant
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (* PTS 1113293 E.Z. *)
            (*ENDIF*) 
            END
        ELSE
            IF  a_sqlmode = sqlm_internal
            THEN
                BEGIN
                a01_get_keyword (acv, kw_index, res_kw);
                CASE kw_index OF
                    cak_i_cascade, cak_i_restrict :
                        BEGIN
                        a_ap_tree^[put_node].n_length :=
                              kw_index;
                        a01_next_symbol (acv)
                        END;
                    OTHERWISE ;
                    END
                (*ENDCASE*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20privileges (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            i_ind         : integer);
 
VAR
      (*dba_spec : boolean;*)
      first    : boolean;
      last_n   : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    ak20priv_spec_list (acv, put_node, last_n);
    first := true;
    IF  a01mandatory_keyword (acv, i_ind)
    THEN
        BEGIN
        REPEAT
            IF  NOT first
            THEN
                a01_next_symbol (acv)
            ELSE
                first := false;
            (*ENDIF*) 
            (*
                  dba_spec := false;
                  IF  a01_eqkey (a01kw[ cak_i_dba ], a_sqlmode,
                  a_cmd_part^.sp1p_buf, a_scv)
                  THEN
                  BEGIN
                  dba_spec := true;
                  a01_next_symbol (acv);
                  END;
                  *)
            a02_aauthid (acv,
                  a_ap_tree^[ last_n ].n_sa_level, last_n);
            (*
                  IF  dba_spec
                  THEN
                  a_ap_tree^[ last_n ].n_symb := s_dba;
                  *)
        UNTIL
            sc_symb <> s_comma;
        (*ENDREPEAT*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20priv_spec_list (
            VAR acv         : tak_all_command_glob;
            VAR put_node    : tsp00_Int2;
            VAR last_node   : tsp00_Int2);
 
VAR
      ikw : integer;
      res_kw : boolean;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak20priv_spec (acv, put_node, last_node);
        WHILE (sc_symb = s_comma) AND (a_returncode = 0) DO
            BEGIN
            a01_next_symbol (acv);
            a01_get_keyword (acv, ikw, res_kw);
            IF  (ikw = cak_i_all)        OR
                (ikw = cak_i_select)     OR
                (ikw = cak_i_update)     OR
                (ikw = cak_i_delete)     OR
                (ikw = cak_i_selupd)     OR
                (ikw = cak_i_insert)     OR
                (ikw = cak_i_index)      OR
                (ikw = cak_i_index)      OR
                (ikw = cak_i_alter)      OR
                (ikw = cak_i_references)
            THEN
                ak20priv_spec (acv, a_ap_tree^[ last_node ].n_sa_level,
                      last_node)
            ELSE
                ak20table_list (acv, last_node);
            (*ENDIF*) 
            END
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20priv_spec (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      last_n : tsp00_Int2;
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        a01_call_put (acv, a22, cak_x_one_grant_spec, curr_n);
        put_node  := curr_n;
        last_node := curr_n;
        ak20op1_spec (acv, a_ap_tree^[ curr_n ].n_lo_level,
              last_n);
        IF  a01mandatory_keyword (acv, cak_i_on)
        THEN
            BEGIN
            IF  a01_eqkey (a01kw[ cak_i_table ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                a01_next_symbol (acv);
            (*ENDIF*) 
            a02_atablename (acv, a_ap_tree^[last_n].n_sa_level,last_n)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20role_grant_revoke (
            VAR acv      : tak_all_command_glob;
            kw           : integer;
            VAR put_node : tsp00_Int2);
 
VAR
      exit_loop   : boolean;
      last_n      : tsp00_Int2;
      required_kw : integer;
 
BEGIN
IF  kw = cak_i_grant
THEN
    BEGIN
    acv.a_is_ddl := ddl_grant_privilege;
    required_kw  := cak_i_to
    END
ELSE
    BEGIN
    acv.a_is_ddl := ddl_revoke_privilege;
    required_kw  := cak_i_from
    END;
(*ENDIF*) 
a01_call_put (acv, a22, cak_i_role, put_node);
acv.a_ap_tree^[put_node].n_length := kw;
last_n    := put_node;
exit_loop := false;
REPEAT
    a02_put_identifier (acv, acv.a_ap_tree^[last_n].n_lo_level, last_n);
    IF  acv.a_scv.sc_symb = s_comma
    THEN
        a01_next_symbol (acv)
    ELSE
        exit_loop := true;
    (*ENDIF*) 
UNTIL
    exit_loop;
(*ENDREPEAT*) 
IF  a01mandatory_keyword (acv, required_kw)
THEN
    BEGIN
    last_n    := put_node;
    exit_loop := false;
    REPEAT
        a02_aauthid (acv,
              acv.a_ap_tree^[last_n].n_sa_level, last_n);
        IF  acv.a_scv.sc_symb = s_comma
        THEN
            a01_next_symbol (acv)
        ELSE
            exit_loop := true;
        (*ENDIF*) 
    UNTIL
        exit_loop;
    (*ENDREPEAT*) 
    IF  acv.a_scv.sc_symb <> s_eof
    THEN
        a01_force_symbol (acv, s_comma, put_node, last_n)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20skip_oracle_constraint (
            VAR acv              : tak_all_command_glob;
            VAR constraint_found : boolean);
 
VAR
      dummy : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    constraint_found := false;
    IF  (a_returncode = 0) AND (sc_symb <> s_eof)
    THEN
        IF  (a_sqlmode = sqlm_oracle) AND
            a01_eqkey (a01kw[ cak_i_constraint ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            a01_next_symbol (acv);
            constraint_found := true;
            IF  sc_symb = s_identifier
            THEN
                a01_next_symbol (acv)
            ELSE
                a07_error (acv, e_missing_identifier, dummy, dummy)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20table_constraint (
            VAR acv       : tak_all_command_glob;
            keyword       : integer;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            VAR found     : boolean);
 
VAR
      res_kw           : boolean;
      dummy_node       : tsp00_Int2;
      constraint_node  : tsp00_Int2;
      constraint_quote : tsp00_Int2;
      aux_scv          : tak_scanner_glob;
 
BEGIN
found            := false;
aux_scv          := acv.a_scv;
constraint_node  := 0;
constraint_quote := 0;
IF  keyword = cak_i_constraint
THEN
    BEGIN
    a01_next_symbol (acv);
    IF  acv.a_scv.sc_symb = s_identifier
    THEN
        BEGIN
        constraint_quote := acv.a_scv.sc_double_quote;
        a02_put_identifier (acv, dummy_node, constraint_node)
        END
    ELSE
        acv.a_scv := aux_scv
    (*ENDIF*) 
    END;
(*ENDIF*) 
a01_get_keyword (acv, keyword, res_kw);
CASE keyword OF
    cak_i_check, cak_i_constraint :
        BEGIN
        found := true;
        ak20check_clause (acv, keyword, false,
              constraint_node, constraint_quote,
              put_node, last_node);
        END;
    cak_i_foreign :
        ak20fk_spec (acv, constraint_node, put_node, last_node, found);
    cak_i_primary :
        ak20key_spec (acv, put_node, last_node, found);
    cak_i_unique :
        ak20unique_spec (acv, keyword,
              constraint_node, put_node, last_node, found);
    OTHERWISE
        IF  (constraint_node <> 0) AND (acv.a_sqlmode = sqlm_internal)
        THEN
            BEGIN
            acv.a_scv := aux_scv;
            found := true;
            ak20check_clause (acv, cak_i_check, false,
                  constraint_node, constraint_quote,
                  put_node, last_node)
            END
        (*ENDIF*) 
    END;
(*ENDCASE*) 
IF  (acv.a_returncode = 0) AND (acv.a_sqlmode = sqlm_oracle)
THEN
    IF  a01_eqkey (a01kw[cak_i_disable], acv.a_sqlmode,
        acv.a_cmd_part^.sp1p_buf, acv.a_scv)
    THEN
        a01_next_symbol (acv);
    (*ENDIF*) 
(*ENDIF*) 
IF  NOT found
THEN
    acv.a_scv := aux_scv;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20table_list (
            VAR acv       : tak_all_command_glob;
            VAR last_node : tsp00_Int2);
 
VAR
      first_priv     : boolean;
      first_col      : boolean;
      curr1_n        : tsp00_Int2;
      curr2_n        : tsp00_Int2;
      curr3_n        : tsp00_Int2;
      curr_priv_list : tsp00_Int2;
      prev_priv_list : tsp00_Int2;
      curr_col_list  : tsp00_Int2;
      prev_col_list  : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_call_put (acv, a22, cak_x_one_grant_spec, curr1_n);
    a_ap_tree^[ last_node ].n_sa_level := curr1_n;
    prev_priv_list := a_ap_tree^[ last_node ].n_lo_level;
    first_priv := true;
    last_node := curr1_n;
    WHILE NOT(a_ap_tree^[ prev_priv_list ].n_symb in
          [ s_authid, s_tablename ]) DO
        BEGIN
        a01_put_node (acv, curr2_n);
        a_ap_tree^[ curr2_n ] := a_ap_tree^[ prev_priv_list ];
        IF  first_priv
        THEN
            BEGIN
            a_ap_tree^[ curr1_n ].n_lo_level := curr2_n;
            first_priv := false;
            END
        ELSE
            a_ap_tree^[ curr_priv_list ].n_sa_level := curr2_n;
        (*ENDIF*) 
        prev_col_list := a_ap_tree^[ prev_priv_list ].n_lo_level;
        curr_priv_list := curr2_n;
        first_col := true;
        WHILE prev_col_list <> 0 DO
            BEGIN
            a01_put_node (acv, curr3_n);
            a_ap_tree^[ curr3_n ] := a_ap_tree^[ prev_col_list ];
            IF  first_col
            THEN
                BEGIN
                a_ap_tree^[ curr_priv_list ].n_lo_level :=
                      curr3_n;
                first_col := false;
                END
            ELSE
                a_ap_tree^[ curr_col_list ].n_sa_level:= curr3_n;
            (*ENDIF*) 
            curr_col_list := curr3_n;
            prev_col_list :=
                  a_ap_tree^[ prev_col_list ].n_sa_level;
            END;
        (*ENDWHILE*) 
        prev_priv_list := a_ap_tree^[ prev_priv_list ].n_sa_level;
        END;
    (*ENDWHILE*) 
    a02_atablename (acv, a_ap_tree^[ curr_priv_list ].n_sa_level,
          curr_priv_list);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20op1_spec (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      indk   : integer;
      curr_n : tsp00_Int2;
      res_kw : boolean;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        a01_get_keyword (acv, indk, res_kw);
        CASE indk OF
            cak_i_all :
                BEGIN
                sc_symb := s_all_priv;
                a01_put_node (acv, curr_n);
                put_node := curr_n;
                last_node := curr_n;
                a01_next_symbol (acv);
                IF  (a01_eqkey (a01kw[ cak_i_privileges ], a_sqlmode,
                    a_cmd_part^.sp1p_buf,
                    a_scv)) OR
                    (a01_eqkey (a01kw[ cak_i_priv ], a_sqlmode,
                    a_cmd_part^.sp1p_buf,
                    a_scv) AND
                    (a_sqlmode = sqlm_internal))
                THEN
                    a01_next_symbol (acv)
                ELSE
                    IF  a_sqlmode = sqlm_ansi
                    THEN
                        a07_error (acv, e_wanted_keyword,
                              put_node, last_node);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            OTHERWISE
                ak20l_op2_spec (acv, put_node, last_node, indk);
            END;
        (*ENDCASE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20l_op2_spec (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            indk          : integer);
 
VAR
      res_kw : boolean;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak20op2_spec (acv, put_node, last_node, indk);
        WHILE  (sc_symb = s_comma) AND (a_returncode = 0) DO
            BEGIN
            a01_next_symbol (acv);
            a01_get_keyword (acv, indk, res_kw);
            ak20op2_spec (acv, a_ap_tree^[ last_node ].n_sa_level,
                  last_node, indk);
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20op2_spec (
            VAR acv       : tak_all_command_glob;
            VAR put_node  : tsp00_Int2;
            VAR last_node : tsp00_Int2;
            indk          : integer);
 
VAR
      curr_n : tsp00_Int2;
      last_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        CASE indk OF
            cak_i_alter :
                BEGIN
                sc_symb := s_alter;
                a01_put_node (acv, put_node);
                a01_next_symbol (acv);
                last_node := put_node;
                END;
            cak_i_index :
                BEGIN
                sc_symb := s_index;
                a01_put_node (acv, put_node);
                a01_next_symbol (acv);
                last_node := put_node;
                END;
            cak_i_insert :
                BEGIN
                sc_symb := s_insert;
                a01_put_node (acv, put_node);
                a01_next_symbol (acv);
                last_node := put_node;
                END;
            cak_i_delete :
                BEGIN
                sc_symb := s_delete;
                a01_put_node (acv, put_node);
                a01_next_symbol (acv);
                last_node := put_node;
                END;
            OTHERWISE
                BEGIN
                CASE indk OF
                    cak_i_references :
                        sc_symb := s_link;
                    cak_i_select :
                        sc_symb := s_select;
                    cak_i_update :
                        sc_symb := s_update;
                    cak_i_selupd :
                        sc_symb := s_selupd;
                    OTHERWISE
                        a07_error (acv, e_wanted_keyword,
                              put_node, last_node);
                    END;
                (*ENDCASE*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    a01_put_node (acv, curr_n);
                    put_node := curr_n;
                    a01_next_symbol (acv);
                    last_node := put_node;
                    IF  NOT ((a_is_ddl = ddl_revoke_privilege) AND
                        (a_sqlmode = sqlm_oracle))
                    THEN
                        IF  sc_symb = s_leftpar
                        THEN
                            BEGIN
                            a01_next_symbol (acv);
                            a02_l_acolumn_list (acv,
                                  a_ap_tree^[ curr_n ].n_lo_level,
                                  last_n);
                            a01_force_symbol (acv, s_rightpar,
                                  put_node, last_node)
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20foreign_key_spec (
            VAR acv            : tak_all_command_glob;
            VAR put_node       : tsp00_Int2;
            VAR last_node      : tsp00_Int2;
            curr_n             : tsp00_Int2;
            rule_node          : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_force_symbol (acv, s_leftpar, curr_n, last_node);
    IF  a_returncode = 0
    THEN
        BEGIN
        a02_l_acolumn_list (acv, put_node, last_node);
        a01_force_symbol (acv, s_rightpar, curr_n, last_node);
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  a01mandatory_keyword (acv, cak_i_references)
            THEN
                ak20pk_rule_spec (acv, last_node, curr_n, rule_node)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20pk_rule_spec (
            VAR acv            : tak_all_command_glob;
            VAR last_node      : tsp00_Int2;
            curr_n             : tsp00_Int2;
            rule_node          : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a02_atablename (acv, a_ap_tree^[ curr_n ].n_sa_level,
          last_node);
    IF  sc_symb = s_leftpar
    THEN
        BEGIN
        a01_next_symbol (acv);
        a02_l_acolumn_list (acv,
              a_ap_tree^[ last_node ].n_lo_level,
              last_node);
        a01_force_symbol (acv, s_rightpar, curr_n, last_node)
        END;
    (*ENDIF*) 
    IF  (sc_symb <> s_eof)
        AND
        ((a_sqlmode <> sqlm_oracle) OR
        NOT a01_eqkey (a01kw[cak_i_constraint], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv))
    THEN
        ak20delete_rule (acv,
              rule_node, last_node)
    ELSE
        a_ap_tree^[ rule_node ].n_length := cak_i_restrict;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20delete_rule (
            VAR acv       : tak_all_command_glob;
            VAR rule_node : tsp00_Int2;
            VAR last_node : tsp00_Int2);
 
VAR
      kw_index : integer;
      res_kw   : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  NOT a01_eqkey (a01kw[ cak_i_on ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        BEGIN
        IF  (a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_proc = a25) AND
            (a_sqlmode <> sqlm_oracle)
        THEN
            a07_error (acv, e_wanted_keyword, rule_node, last_node)
        ELSE
            a_ap_tree^[ rule_node ].n_length := cak_i_restrict
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        a01_next_symbol (acv);
        IF  a01mandatory_keyword (acv, cak_i_delete)
        THEN
            BEGIN
            a01_get_keyword (acv, kw_index, res_kw);
            CASE kw_index OF
                cak_i_set :
                    BEGIN
                    a01_next_symbol (acv);
                    a01_get_keyword (acv, kw_index, res_kw);
                    IF  (kw_index = cak_i_null)
                        OR
                        ((kw_index = cak_i_default) AND
                        ( a_sqlmode = sqlm_internal))
                    THEN
                        a_ap_tree^[ rule_node ].n_length := kw_index
                    ELSE
                        a07_error (acv,
                              e_wanted_keyword, rule_node, last_node);
                    (*ENDIF*) 
                    END;
                cak_i_cascade, cak_i_restrict :
                    a_ap_tree^[ rule_node ].n_length := kw_index;
                OTHERWISE
                    a07_error (acv,
                          e_wanted_keyword, rule_node, last_node);
                END;
            (*ENDCASE*) 
            (* PTS 1113262 E.Z. *)
            IF  (a_sqlmode = sqlm_oracle)   AND
                (kw_index <> cak_i_cascade) AND
                (kw_index <> cak_i_null)
            THEN
                a07_error (acv,
                      e_invalid_keyword, rule_node, last_node);
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                a01_next_symbol (acv);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1111576 E.Z. *)
(* PTS 1120287 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a20unload_statistics (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
BEGIN
a01_next_symbol (acv);
WITH acv, a_scv DO
    IF  a01_eqkey (a01kw[ cak_i_statistics ], a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        BEGIN
        a_is_ddl := ddl_update_statistics;
        a01_next_symbol (acv);
        a01_call_put (acv, a28, cak_i_unload, put_node);
        END
    ELSE
        (* PTS 1120287 E.Z. *)
        a07_b_put_error (acv, e_invalid_command, 1);
    (*ENDIF*) 
(*ENDWITH*) 
a01_is_end_symbol (acv)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak20duplicates_clause (VAR acv : tak_all_command_glob);
 
VAR
      res_kw   : boolean;
      kw_index : integer;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_get_keyword (acv, kw_index, res_kw);
    CASE kw_index OF
        cak_i_ignore, cak_i_reject, cak_i_update :
            BEGIN
            a01_next_symbol (acv);
            IF  a01mandatory_keyword (acv, cak_i_duplicates)
            THEN ;
            (*ENDIF*) 
            END;
        OTHERWISE;
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
