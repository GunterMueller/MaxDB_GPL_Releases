.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-16
*****************************************************
modname : VAK15
changed : 2000-11-16
module  : AK_save_scheme
 
Author  : ThomasA
Created : 1987-09-22
*****************************************************
 
Purpose : Semantik der Save und Restore Schema Befehle
 
Define  :
 
        PROCEDURE
              a15save_restore_catalog (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a15restore_catalog (
                    VAR acv         : tak_all_command_glob;
                    VAR treeid      : tgg00_FileId;
                    VAR viewscanpar : tak_save_viewscan_par);
 
        PROCEDURE
              a15catalog_save (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_save_viewscan_par);
 
        PROCEDURE
              a15one_table_catalog (
                    VAR acv          : tak_all_command_glob;
                    viewlevel_cnt    : integer;
                    unknown_sequence : boolean;
                    VAR viewscanpar  : tak_save_viewscan_par);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52end_rollback_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier;
                    m_type            : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        PROCEDURE
              a40init_table_scan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob;
                    scan_temp        : boolean;
                    scan_private     : boolean;
                    scan_non_private : boolean;
                    scan_public      : boolean;
                    use_synonyms     : boolean;
                    all_base         : boolean);
 
        PROCEDURE
              a40FinishTableScan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob);
 
        FUNCTION
              a40next_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_show_syntax : VAK41;
 
        PROCEDURE
              a41init_show_glob (
                    VAR a41v  : tak40_show_glob;
                    mess_code : tsp00_CodeType);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures  : VTA01;
 
        PROCEDURE
              t01moveobj (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01surrogate (
                    layer     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01lidentifier (
                    debug      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier (*ptocSynonym const char**));
&       endif
 
      ------------------------------ 
 
        FROM
              AK_VIEW_SCAN : VAK27;
 
        PROCEDURE
              a27init_viewscanpar (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_save_viewscan_par;
                    v_type          : tak_viewscantype);
 
        PROCEDURE
              a27view_scan   (
                    VAR acv         : tak_all_command_glob;
                    VAR tableid     : tgg00_Surrogate;
                    VAR viewscanpar : tak_save_viewscan_par);
 
      ------------------------------ 
 
        FROM
              AK_distributor : VAK35;
 
        PROCEDURE
              a35_asql_statement (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Grant_Revoke : VAK22;
 
        FUNCTION
              a22exist_user  (
                    VAR acv       : tak_all_command_glob;
                    VAR user      : tsp00_KnlIdentifier;
                    errorpos      : integer;
                    VAR user_info : tak_user_info) : boolean;
 
        PROCEDURE
              a22add_priv_rec (
                    VAR acv         : tak_all_command_glob;
                    base_ptr        : tak_sysbufferaddress;
                    VAR new_priv    : tak_privilege;
                    priv_buf        : tak_sysbufferaddress;
                    add_sysinfo     : boolean;
                    VAR revoke_casc : boolean);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10_all_release (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10release_table (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    dstate     : tak_directory_state;
                    syslen     : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_cache_delete (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        PROCEDURE
              a101_CreateGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId;
                    tempFileType   : tgg00_TfnTemp);
 
        PROCEDURE
              a101_DestroyGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103ExistsSchema (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *)) : tak_sysbufferaddress;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
        PROCEDURE
              a103GetSchemaId (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer;
                    VAR schemaId   : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542char_to_packet (
                    VAR acv : tak_all_command_glob;
                    c       : char);
 
        PROCEDURE
              a542identifier_to_packet (
                    VAR acv        : tak_all_command_glob;
                    VAR identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542move_to_packet (
                    VAR acv    : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
        PROCEDURE
              a542pop_packet (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Build_Strategy_2 : VAK71;
 
        PROCEDURE
              a71add_default_strat (VAR mess_buf : tgg00_MessBlock);
 
        PROCEDURE
              a71default_strat (VAR gg_strategy : tgg07_StrategyInfo);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06get_username (
                    VAR acv        : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authname : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR sparr    : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv    : tak_all_command_glob;
                    VAR mbuf   : tgg00_MessBlock;
                    result_req : boolean;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        PROCEDURE
              a06unpack_priv (
                    VAR packed_priv     : tak_privilege;
                    VAR unpacked_priv   : tak_privilege);
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv         : tak_all_command_glob;
                    mtype           : tgg00_MessType;
                    m2type          : tgg00_MessType2;
                    VAR tree        : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01kw                : tak_keywordtab;
              a01defaultkey        : tgg00_SysInfoKey;
              a01emptypriv         : tak_privilege;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
              a01_i_temp           : tsp00_KnlIdentifier;
              a01char_size         : integer;
 
        FUNCTION
              a01is_whitespace_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4) : boolean;
 
        FUNCTION
              a01equal_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    cmp_char : char) : boolean;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1  : VBD01;
 
        PROCEDURE
              b01empty_file (
                    VAR t       : tgg00_TransContext;
                    VAR current : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cadd_record (
                    VAR t    : tgg00_TransContext;
                    VAR curr : tgg00_FileId;
                    VAR b    : tgg00_Rec);
 
        PROCEDURE
              b07cget_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Rec;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cnext_record (
                    VAR t            : tgg00_TransContext;
                    VAR curr         : tgg00_FileId;
                    VAR rk           : tgg00_Lkey;
                    VAR set_result   : tgg00_BdSetResultRecord;
                    VAR tree_pos     : tgg00_FilePos;
                    VAR b            : tsp00_Buf);
 
        PROCEDURE
              b07crepl_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01unicode        : boolean;
 
        FUNCTION
              g01packet_size : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Record_Encapsulate_Procedures : VGG09;
 
        PROCEDURE
              g09StratStackentry (
                    VAR NewStackEntry : tgg00_StackEntry;
                    inp_startpos      : tsp00_Int2;
                    inp_len           : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (
                    intval    : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_C8);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv     : tak_all_command_glob;
                    b_err       : tgg00_BasisError;
                    err_code    : tsp00_Int4);
 
        PROCEDURE
              a07const_param (
                    VAR acv    : tak_all_command_glob;
                    param_no   : integer;
                    param_addr : tsp00_MoveObjPtr;
                    param_len  : integer);
 
        PROCEDURE
              a07put_param (
                    VAR acv   : tak_all_command_glob;
                    param_no  : integer;
                    param_ptr : tsp00_MoveObjPtr;
                    param_len : integer);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11get_check_table (
                    VAR acv          : tak_all_command_glob;
                    new_table        : boolean;
                    basetable        : boolean;
                    unload_allowed   : boolean;
                    required_priv    : tak00_PrivilegeSet;
                    any_priv         : boolean;
                    all_base_rec     : boolean;
                    d_state          : tak_directory_state;
                    VAR act_tree_ind : tsp00_Int4;
                    VAR authname     : tsp00_KnlIdentifier;
                    VAR tablen       : tsp00_KnlIdentifier;
                    VAR sparr        : tak_syspointerarr);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40gsint (
                    VAR buf     : tsp00_Buf;
                    pos         : tsp00_Int4;
                    len         : integer;
                    VAR dest    : tsp00_Int2;
                    VAR res     : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf     : tsp00_Buf;
                    pos         : tsp00_Int4;
                    len         : integer;
                    frac        : integer;
                    source      : tsp00_Int4;
                    VAR res     : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (
                    val        : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tsp00_C4;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              b07cget_record;
 
              tgg00_Lkey tgg00_Rec
 
        PROCEDURE
              b07cnext_record;
 
              tsp00_MoveObj tsp00_Buf
 
        FUNCTION
              a103ExistsSchema;
 
              tgg00_VoidPtr tak_sysbufferaddress
 
        PROCEDURE
              a27init_viewscanpar;
 
              tak_viewscan_par tak_save_viewscan_par
 
        PROCEDURE
              a27view_scan;
 
              tak_viewscan_par tak_save_viewscan_par
 
        PROCEDURE
              g17int4to_line;
 
              tsp00_Line tsp00_C8
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tsp00_C4
 
        PROCEDURE
              s41plint;
 
              tsp00_MoveObj tsp00_Buf;
 
        PROCEDURE
              s40gsint;
 
              tsp00_MoveObj tsp00_Buf;
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
 
 
 
PROCEDURE  A15SAVE_RESTORE_CATALOG
                           (VAR acv : all_command_glob);
-----------------------------------------------------------
 
The procedure ensures the semantic processing of the commands Save and Restore
Schema. On entry into the procedure, merely the syntax tree has been built.
 
By means of a11get_check_table, the system information of type tbaserecord of
the table that is to be saved or restored is loaded into the cache. The
procedure also takes care of the necessary privilege checks.
 
In the further course of the procedure, a distinction is made between a Save
command and a Restore command:
In the case of a Save command, first of all, the name of the table is
determined into which the Save information is to be inserted. This table is
then implicitly created. For this purpose, the corresponding Create Table
Statement is transferred to part 1 of the SQL packet and the creation of the
table is initiated by a35_asql_statement. The table has the
following structure:
 
  LEVEL FIXED(6) KEY , CMD_NO FIXED(6) KEY,
  SEQ_NO FIXED(6) KEY, ERROR_CODE FIXED(4), OWNERNAME CHAR(8),
  AUTHNAME CHAR(8), TABLENAME CHAR(18) , CMD  CHAR(254)
 
This key structure guarantees that the SQL commands are sequentialized, i.e.
that, after execution of the Save Schema command, they are in the order in the
Save Schema table in which they must be executed for Restore. Since special
privileges apply to the Save Schema tables, the tbaserecords are manipulated by
a15_build_view_description in such a way that the table is both a base table
and also a view. Furthermore, the system information additionally required for
a view is created.
 
The calling of a15_save_catalog then ensures that all view, synonym and grant
definitions dependent on the initial table are entered in the Save Schema table
that has been created.
 
In the case of a Restore Schema command, the SQL commands that have been read
from the table are to be executed again. It must, therefore, first of all be
checked whether the table specified by the user is a Save Schema table. Since,
as described above, Save Schema tables are both base tables and also views,
this test is very simple. It is recorded in the flag acv_internal_sql that a
Restore Schema command is now being executed, since, in this case, no rollbacks
may be made in the individual DDL commands in the case of an error. By means of
a15_restore_catalog, the individual SQL commands are then read from the table
and are executed.
 
PROCEDURE  A15_BUILD_VIEW_DESCRIPTION (
                  VAR acv         : all_command_glob;
                  VAR viewscanpar : save_viewscan_par);
-----------------------------------------------------------
 
The base table vsc_into_authname.vsc_into_tablen is made by this procedure into a
view that references itself as a base table. This constellation can be achieved
only by the Save Schema command; this is not possible by means of DDL SQL
commands. The table is made into a view, because the owner of the table may
only see the lines of the tables in which the owner field contains his user
name.
 
In the first base record of the table, the table type is set to tonebase View
and the table itself if entered as the referenced base table
bv_autid.bv_tablen.
 
Then, system information of type tviewqual is built with the qualification
where ownername = USER and system information of type tprivrecord is built with
the privileges of the owner of the table. Usually, the owner-name field is
marked as not updatable. An exception to this is made only if the Save Schema
command is issued by the LOAD component in Schema Extract.
 
All sysinfo records that have been created or altered are inserted into system
file 1.
 
PROCEDURE  A15CATALOG_SAVE (VAR acv : all_command_glob;
                  VAR authname    : user_id;
                  VAR tablen      : name;
                  VAR viewscanpar : viewscan_par);
-----------------------------------------------------------
 
The procedure ensures that the definitions of the views and synonyms dependent
on the table authname.tablen are saved. There are two possibilities:
 
i)The procedure is called as the result of a DDL command, i.e. the sysinfos
of all dependent views are to be re-built on the table authname.tablen after a
DDL command. In this case (vsc_save_into = FALSE), their definitions are
written to a temporary file (vsc_filename).
 
ii)The procedure is called as the result of a Save Schema command. In this
case, the definitions of all dependent views, privileges and synonyms are
written to the previously created Save Schema table
vsc_into_authname.vsc_into_tablen.
 By means of a15one_table_catalog, it is ensured
first of all that the privileges granted on the initial table authname.tablen ar
inserted into the Save Schema table.
 
The insertion of the definitions of the views and synonyms dependent on the
table authname.tablen is then accomplished in both cases by the procedure
a27view_scan, which calls a15one_table_catalog for each view that is found. If
an error occurs in the execution of a Save Schema command, the insertions that
have been made up to that point must again be cancelled.
(a52end_rollback_subtrans).
 
PROCEDURE  A15RESTORE_CATALOG (VAR acv : all_command_glob;
                  VAR authname    : user_id;
                  VAR tablen      : name;
                  versionno       : integer;
                  VAR viewscanpar : save_viewscan_par);
-----------------------------------------------------------
 
When the procedure is called, SQL commands that are executed by the procedure
are stored in a permanent Save Schema table or in a temporary file. If the
parameter restore_from = TRUE, this means that the entries of the permanent
table authname.tablen must be read. In this case, the Restore operation must be
continued even if one single SQL command fails. The corresponding error message
must then be inserted into the ERROR_CODE field of the corresponding line. Only
after the execution of the last SQL command of the table are the sysinfo
alterations that have been made then cancelled. If, therefore, an Update of the
ERROR_CODE field in the relevant lines were to be performed immediately after
each failed command, these, too, would finally by reset. For this reason, a
temporary file is created into which the error number is inserted with the
corresponding key. If vsc_save_into = FALSE, the temporary file vsc_filename is
read. In this case, execution is terminated immediately if an SQL command
fails.
 
The corresponding temporary or permanent file is then processed in a loop. The
next line is read by a KB request or by a b07cnext_record. The owner of the
object to be created is read from the record and is transferred to the
corresponding variables in the acv (current_auth_id, current_name). This is
necessary so that, when the object is created, the correct privilege checks are
performed and the correct names are created. The CMD column of the record is
transferred to part 1 of the SQL packet. Since a SQL command may possibly be
described by more than one line, the command built in the SQL packet may only
be executed after the last part has been transferred. If this is the case,
prior to execution of the command, it is also checked whether the user
performing the command still in fact exists. Only if this is the case is the
command executed by a35_asql_statement. If the command cannot be successfully
executed, in the case of a Restore Schema command, the key of the corresponding
record and the error number are inserted into the error file
(a15_add_errorfile).
 
If, after completion of the above-described loop, it is found that not all
commands have been correctly executed, a distinction must be made between two
cases:
 
i)A Restore Schema command has been processed:
 
The successfully executed commands must be cancelled again
(a52end_rollback_subtrans). The error numbers of the commands that have not been
successfully executed must be entered in the corresponding lines of the Save
Schema table. For this purpose, the ERROR_CODE field is first of all set to 0
on all lines of the table (a15_set_error_code_zero). By means of a15_rollback,
an Update of the ERROR_CODE field is performed with the corresponding error
number for all commands that have not been correctly executed.
 
ii)The procedure has been called in the course of a DDL command
 
In this case, a rollback need not be performed, because this is done at the end
of the respective DDL command.
 
 
At the end of the procedure, the original values of current_auth_id and
current_user must be restored and the save_schema_file must, if necessary, be
deleted.
 
PROCEDURE  A15_SET_ERROR_CODE_ZERO (
                  VAR acv      : all_command_glob;
                  VAR authname : tsp00_KnlIdentifier;
                  VAR tablen   : tsp00_KnlIdentifier;
                  versionno    : int2);
-----------------------------------------------------------
 
The procedure builds the command
 
UPDATE authname.tablen SET ERROR_CODE = 0
 
as a message buffer and sends it for execution to KB. authname.tablen is a Save
Schema table.
 
PROCEDURE  A15_ADD_ERRORFILE (VAR acv : all_command_glob;
                  VAR prevkey       : lkey;
                  ret_code          : int2;
                  VAR errorfile     : univ_fn;
                  VAR error_tree_id : tree_id);
-----------------------------------------------------------
 
An SQL command that was built from a record with Key prekey has failed in the
course of execution with error number ret_code. A record with Key prevkey and
Info part ret_code is now built as a SQL-DB number and is inserted into
errorfile.
 
PROCEDURE  A15_ROLLBACK (VAR acv : all_command_glob;
                  VAR authname      : tsp00_KnlIdentifier;
                  VAR tablen        : tsp00_KnlIdentifier;
                  versionno         : int2;
                  VAR errorfile     : univ_fn;
                  VAR error_tree_id : tree_id);
-----------------------------------------------------------
 
For each SQL command of the Save Schema table authname.tablen that has not run
correctly, the procedure writes the error number to the corresponding lines.
 
For each of the records of the errorfile, an Update command of form Update
authid.tablen set ERROR_CODE = error number where Key(authname.tablen) =
Key(Record) is built in the message buffer and is sent to KB for execution.
 
PROCEDURE  A15ONE_TABLE_CATALOG (VAR acv : all_command_glob;
                  viewlevel_cnt    : integer;
                  VAR viewscanpar  : save_viewscan_par);
-----------------------------------------------------------
 
The procedure creates the definition strings of the view or of the synonym
usa_authname.usa_tablen, built from them a record for a Save Schema table or a
temporary Save Schema file and then appropriately inserts this record. In the
case of a Save Schema command, in addition, all privileges granted for the view
in question are built as a Grant command and are likewise inserted. If the
parameter only_privileges is TRUE, only the privileges of the table are stored.
This is precisely the case if the procedure is called for the initial table of
a Save Schema command in order to save its privileges.
 
All records inserted by the procedure have the value view_level_cnt in the key
field LEVEL. The owner name of the table  usa_authname.usa_tablen is entered in
the OWNER_NAME field. Entries are made in the fields ERROR_CODE, AUTHNAME and
TABLEN only in the case of a Save Schema command, these entries being 0,
usa_authname and usa_tablen. In this case, 254 bytes are available as the length
for the CMD field. If an internal Save Schema invoked by a DDL command is being
executed, the "CMD Field" has a maximum length of 3992 bytes. In a loop, first
of all, the SQL command to be stored is built in part 1 of the SQL packet. This
command is then transferred to the CMD part of the record(s); entries are made
in the fields CMD_NO and SEQ_NO, and the record is inserted either into the
temporary Save Schema file or, by a KB Insert command, into the Save Schema
table. Several inserts may be necessary in order to store the entire command.
Within the loop, a distinction must be made between the following three states:
 
i)The command to be built is a Create View command:
 
In this case, the view-definition string is transferred from the system
information of type tviewtext to the SQL packet. GRANT is entered as the next
state to be executed on the next run through the loop.
 
 
ii)The command to be built is a Create Synonym command:
 
In the case of a Save Schema command, the synonym-definition string is built in
the SQL packet by the procedure ak15synonym_command.
 
iii)The command to be built is a GRANT command:
 
The Grant command is built in the SQL packet by the procedure
ak15build_priv_command. Since it may happen that a Grant command is not fully
built until in the next run through the loop, in this case, the SQL packet must
not yet be written away (add_command = FALSE).
 
 
When an SQL command has been built in the SQL packet (add_command = TRUE), the
command is inserted into the corresponding file by possibly several records.
The loop terminates either when a Synonym command has been issued or when all
Grant commands have been built (b_no_next_record).
 
PROCEDURE  A15_SYNONYM_COMMAND (VAR acv : all_command_glob;
                  VAR synonymname : tsp00_KnlIdentifier;
                  VAR authname    : tsp00_KnlIdentifier;
                  VAR tablen      : tsp00_KnlIdentifier);
-----------------------------------------------------------
 
The procedure builds the command CREATE SYNONYM <synonymname> FOR
<authname.tablen> in part 1 of the SQL packet.
 
PROCEDURE  AK15BUILD_PRIV_COMMAND (VAR acv : all_command_glob;
                  VAR p_arr       : tsyspointerarr;
                  VAR viewprivkey : tsysinfokey;
                  VAR privbuf     : tsysbufferaddress;
                  VAR add_command : boolean;
                  VAR priv_mode   : tak15_priv_gen_mode;
                  VAR col_no      : integer;
                  VAR b_err       : basis_error);
-----------------------------------------------------------
 
The procedure builds a Grant command in part 1 of the SQL packet for the
table/view specified by p_arr.
 
The parameter priv_mode determines which type of Grant command is to be built.
If the type is all_priv, this means that, first of all, the next privilege
sysinfo must be determined from viewprivkey. It must be ensured in this
connection that this is not the privilege description of the owner of the
table. If a privilege record of the table is not found, the Basis_error
b_no_next_record is reported. By means of a27_put_privileges, all privileges
applying to the entire table are written to the SQL packet. If the priv_mode =
col_sel_priv or = col_upd_priv, the corresponding system information has
already been loaded and, by means of a27_put_privileges, the GRANT SELECT and
UPDATE commands are built for individual columns in part 1 of the SQL packet.
 
If a GRANT command has been partially built by a27_put_privileges, the rest "ON
<authname.tablen> TO <username>" is built.
If the priv_mode has been set to
next_priv by a27_put_privileges, this means that the current tprivrecord has
been executed and that the next privilege of the table must be determined, i.e.
the priv_mode is again set to all_priv. This leads in the Repeat loop in
a15one_table_catalog to the re-calling of the procedure and thus to the
processing of the next granted privilege.
 
PROCEDURE  A15_PUT_PRIVILEGES (VAR acv : all_command_glob;
                  VAR p_arr       : tsyspointerarr;
                  VAR priv_mode   : tak15_priv_gen_mode;
                  VAR priv        : tprivilege;
                  VAR col_no      : integer;
                  VAR add_command : boolean);
-----------------------------------------------------------
 
The procedure has the task of building the part of a Grant command before the
table name in part 1 of the SQL packet. The keyword 'GRANT' was already written
to part 1 when the procedure was called. The tbaserecords of the table on which
the privileges were granted are specified by p_arr. The description of the
privilege is in priv. The parameter priv_mode specifies which granted
privileges are to be transferred. If priv_mode = all_priv, all privileges that
have been granted on the entire table are transferred. If priv_mode =
col_upd_priv, Update privileges that have been granted only on certain columns
are transferred beginning at the column with external column number col_no. If
priv_mode = col_sel_priv, Select privileges that have been granted only on
certain columns are transferred beginning at the column with external column
number col_no. The procedure switches to the next priv_mode when all privileges
of the current priv_mode have been transferred. It becomes clear from the above
description that at least 3 calls of the procedure are necessary in order to
translate the privilege description into GRANT commands.
.CM *-END-* specification -------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      cak15_level_cmd_no_len   = 10;
      cak15_fixed4_size        = 4;
      cak15_fixed6_size        = 5;
      save_scheme_keylen       = 15;
      pos_cmd_cnt              = cgg_rec_key_offset+7;
      pos_context              = cgg_rec_key_offset+16;
      pos_errorcode            = cgg_rec_key_offset+18;
      pos_sqlcmd               = cgg_rec_key_offset+22; (* PTS 1107988 *)
      pos_type                 = cgg_rec_key_offset+24; (* PTS 1110528 *)
      pos_tabletype            = cgg_rec_key_offset+33; (* PTS 1110528 *)
      pos_owner                = cgg_rec_key_offset+42; (* PTS 1110528 *)
      c_release_packet         = true;
      c_unknown_sequence       = true;
      c_is_rollback            = true;
      (*
      1. LEVEL
      2. CMD_NO
      3. SEQ_NO,
      4. DT_FORMAT
      5. OWNER
      6. SCHEMA
      7. SCHEMACONTEXT
      8. TABLENAME
      9. ERROR_CODE
      10. SQLCMD
      11. TYPE
      12. TABLETYPE
      13. CMD
      *)
      into_table1 = ' (LEVEL FIXED(6), CMD_NO FIXED(6), SEQ_NO FIXED(6)';
      into_table2 = ', CONSTRAINT SCHEM_SAV_PK PRIMARY KEY (LEVEL,     ';
      into_table3 = 'CMD_NO, SEQ_NO), DT_FORMAT CHAR BYTE, OWNER CHAR(6';
      into_table4 = '4) ASCII, SCHEMA CHAR(64) ASCII, SCHEMACONTEXT CHA';
      into_table5 = 'R(64) ASCII, TABLENAME CHAR(64) ASCII, ERROR_CODE ';
      into_table6 = 'FIXED(4), SQLCMD CHAR(1) ASCII, TYPE CHAR(8) ASCII'; (* PTS 1107988 *)
      into_table7 = ',TABLETYPE CHAR(8) ASCII, CMD  CHAR(254) ASCII   )'; (* PTS 1110528 *)
      into_utable1 = '     (LEVEL FIXED(6), CMD_NO FIXED(6), SEQ_NO     ';
      into_utable2 = 'FIXED(6), CONSTRAINT SCHEM_SAV_PK PRIMARY KEY     ';
      into_utable3 = '(LEVEL,CMD_NO,SEQ_NO), DT_FORMAT CHAR BYTE, OWNER ';
      into_utable4 = ' CHAR (32) UNICODE, SCHEMA CHAR(32) UNICODE,SCHEMA';
      into_utable5 = 'CONTEXT CHAR(32) UNICODE,TABLENAME CHAR(32) UNICOD';
      into_utable6 = 'E,ERROR_CODE FIXED (4),SQLCMD CHAR(1) ASCII,TYPE C';
      into_utable7 = 'HAR(8) ASCII,TABLETYPE CHAR(8) ASCII,             ';
      into_utable8 = 'CMD  CHAR(127) UNICODE )                          ';
 
TYPE
      tak15_priv_gen_mode = (all_priv,
            all_grant_priv,
            col_sel_priv,
            col_sel_grant_priv,
            col_upd_priv,
            col_upd_grant_priv,
            next_priv);
 
      tak15_top_sort_info = RECORD
            CASE integer OF
                1 :
                    (rec_buf : tgg00_Rec);
                2 :
                    (rec1_len      : tsp00_Int2;
                    key1_len       : tsp00_Int2;
                    varcol_offset1 : tsp00_Int2;
                    varcol_cnt1    : tsp00_Int2;
                    pk_tabid       : tgg00_Surrogate;
                    fk_tabid       : tgg00_Surrogate);
                3 :
                    (rec2_len      : tsp00_Int2;
                    key2_len       : tsp00_Int2;
                    varcol_offset2 : tsp00_Int2;
                    varcol_cnt2    : tsp00_Int2;
                    mask           : tsp00_C4;
                    tabid          : tgg00_Surrogate;
                    pred_cnt       : tsp00_Int4;
                    tabsite        : tgg00_ServerdbNo);
                END;
            (*ENDCASE*) 
 
 
      tak15_top_sort_record = RECORD
            tps_queue_tree : tgg00_FileId;
            tps_queue_cnt  : tsp00_Int4;
            tps_pos        : integer;
            tps_set_result : tgg00_BdSetResultRecord;
            tps_tree_pos   : tgg00_FilePos;
            tps_rec        : tak15_top_sort_info;
      END;
 
 
 
(*------------------------------*) 
 
PROCEDURE
      a15save_restore_catalog (VAR acv : tak_all_command_glob);
 
VAR
      isInternalCmd  : boolean;
      b_err          : tgg00_BasisError;
      ti             : tsp00_Int4;
      i              : integer;
      packet_size    : integer;
      parts          : integer;
      authname       : tsp00_KnlIdentifier;
      treeid         : tgg00_FileId;
      tablen         : tsp00_KnlIdentifier;
      schema         : tsp00_KnlIdentifier;
      p_arr          : tak_syspointerarr;
      sql_stmt       : ARRAY[1..8] OF tsp00_C50;
      viewscanpar    : tak_save_viewscan_par;
 
BEGIN
isInternalCmd := acv.a_cmd_segment_header.sp1c_producer = sp1pr_internal_cmd; (* PTS 1110554 *)
WITH acv, viewscanpar DO
    BEGIN
    a27init_viewscanpar(acv, viewscanpar, v_save_scheme);
    ti := 2;
    a10_cache_delete (acv, NOT c_is_rollback);
    CASE  a_ap_tree^[ti].n_symb OF
        s_asterisk :
            vsc_all_save := true;
        s_user :
            BEGIN
            vsc_all_save  := true;
            vsc_user_save := true;
            END;
        OTHERWISE
            IF  (a_ap_tree^[ti].n_symb = s_authid) AND (a_ap_tree^[ti].n_sa_level = 0)
            THEN
                BEGIN (* no table, just schema specified *)
                vsc_ti := ti;
                i      := ti;
                a06get_username (acv, i, schema);
                vsc_all_save    := true;
                vsc_schema_save := true;
                END
            ELSE
                a11get_check_table (acv, false,false,true, [ r_owner ],
                      false, false, d_fix, ti, authname, tablen, p_arr);
            (*ENDIF*) 
        END;
    (*ENDCASE*) 
    vsc_save_into := true;
    IF  acv.a_returncode = 0
    THEN
        IF  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc =
            cak_i_save
        THEN
            BEGIN
            IF  NOT vsc_all_save
            THEN
                WITH p_arr.pbasep^ DO
                    BEGIN
                    vsc_base_tabid := syskey.stableid;
                    vsc_tablekind  := sbase.btablekind;
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            ti := a_ap_tree^[ ti ].n_lo_level;
            a11get_check_table (acv, true, true, true, [  ],
                  false, false, d_fix, ti,
                  vsc_into_authname, vsc_into_tablen, a_p_arr1);
            IF  (vsc_into_authname = a01_i_temp) AND NOT isInternalCmd (* PTS 1110554*)
            THEN
                a07_b_put_error (acv, e_temp_table_not_allowed, 1);
            (*ENDIF*) 
            packet_size := 13 + 2 * (sizeof (tsp00_KnlIdentifier) + 2) + 1 +
                  sizeof (sql_stmt);
            IF  g01unicode
            THEN
                packet_size := packet_size * 2;
&           ifdef trace
            (*ENDIF*) 
            t01int4 (ak_sem, 'packet_size ', packet_size);
&           endif
            IF  a_returncode = 0
            THEN
                a542internal_packet (acv, NOT c_release_packet,
                      packet_size);
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                a_cmd_part^.sp1p_buf_len := 0;
                a542move_to_packet (acv, @a01kw[cak_i_create], 7);
                a542move_to_packet (acv, @a01kw[cak_i_table ], 6);
                a542identifier_to_packet (acv, vsc_into_authname);
                a542char_to_packet       (acv, '.');
                a542identifier_to_packet (acv, vsc_into_tablen);
                IF  g01unicode
                THEN
                    BEGIN
                    sql_stmt[1]  := into_utable1;
                    sql_stmt[2]  := into_utable2;
                    sql_stmt[3]  := into_utable3;
                    sql_stmt[4]  := into_utable4;
                    sql_stmt[5]  := into_utable5;
                    sql_stmt[6]  := into_utable6; (* PTS 1107988 *)
                    sql_stmt[7]  := into_utable7; (* PTS 1110528 *)
                    sql_stmt[8]  := into_utable8;
                    parts        := 8;
                    END
                ELSE
                    BEGIN
                    sql_stmt[1]  := into_table1;
                    sql_stmt[2]  := into_table2;
                    sql_stmt[3]  := into_table3;
                    sql_stmt[4]  := into_table4;
                    sql_stmt[5]  := into_table5;
                    sql_stmt[6]  := into_table6; (* PTS 1107988 *)
                    sql_stmt[7]  := into_table7; (* PTS 1110528 *)
                    parts        := 7;
                    END;
                (*ENDIF*) 
                FOR i := 1 TO parts DO
                    a542move_to_packet (acv,
                          @sql_stmt[i], sizeof (sql_stmt[i]));
                (*ENDFOR*) 
                acv.a_try_again := false;
&               ifdef trace
                t01moveobj (ak_sem,
                      a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len);
&               endif
                a35_asql_statement (acv);
                IF  a_returncode = 0
                THEN
                    ak15build_view_description (acv, viewscanpar);
                (*ENDIF*) 
                a542pop_packet (acv);
                END
            ELSE
                IF  (a_returncode =
                    a071_return_code (e_duplicate_tablename,
                    a_sqlmode))
                    AND (a_cmd_segment_header.sp1c_producer = sp1pr_internal_cmd)
                THEN
                    WITH a_p_arr1.pbasep^.sbase DO
                        BEGIN
                        (* delete existing table in case of a load    *)
                        (* call ==> load don't have to drop the table *)
                        a_returncode := 0;
                        a06a_mblock_init (acv,
                              m_delete, mm_trunc, btreeid);
                        a06rsend_mess_buf (acv, a_mblock,
                              cak_return_req, b_err);
                        IF  b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, b_err, 1)
                        ELSE
                            BEGIN
                            vsc_filevers          := btreeid.fileVersion_gg00;
                            btreeid.fileRoot_gg00 := NIL_PAGE_NO_GG00;
                            vsc_into_treeid       := btreeid
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
            (*ENDIF*) 
            vsc_last_save := true;
            vsc_cmd_cnt   := 0;
            IF  a_returncode = 0
            THEN
                IF  vsc_all_save
                THEN
                    ak15all_catalog_save (acv, viewscanpar, schema)
                ELSE
                    a15catalog_save (acv, viewscanpar);
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (a_returncode =  0) AND
                (a_show_data_cnt <> 0)
            THEN
                a_init_ddl := ddl_create_table;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            WITH p_arr.pbasep^, syskey, sbase DO
                IF  (btablekind <> tonebase) OR
                    (stableid   <> btreeid.fileTabId_gg00)
                THEN
                    a07_b_put_error (acv,
                          e_invalid_table_content,1)
                ELSE
                    a_internal_sql := sql_restore_schema;
                (*ENDIF*) 
            (*ENDWITH*) 
            treeid         := p_arr.pbasep^.sbase.btreeid;
            a15restore_catalog (acv, treeid, viewscanpar);
            a_internal_sql := no_internal_sql
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15all_catalog_save (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_save_viewscan_par;
            VAR schema      : tsp00_KnlIdentifier);
 
VAR
      next_err   : tgg00_BasisError;
      rec_len    : tsp_int_map_c2;
      key_len    : tsp_int_map_c2;
      pos        : integer;
      site_pos   : integer;
      set_result : tgg00_BdSetResultRecord;
      tree_pos   : tgg00_FilePos;
      prevkey    : tgg00_Lkey;
      rec_buf    : tgg00_Rec;
      ins_buf    : tgg00_Rec;
      tree_id    : tgg00_FileId;
 
BEGIN
ak15all_base_tables (acv, viewscanpar, schema);
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  viewscanpar.vsc_user_save OR viewscanpar.vsc_schema_save
    THEN
        tree_id := acv.a_into_tree
    ELSE
        BEGIN
        tree_id             := acv.a_intern_res_tree;
        a101_CreateGroupedTempFile (acv.a_transinf.tri_trans, tree_id,
              ttfnSaveScheme_egg00);
        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    prevkey.len    := 0;
    tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
    WITH set_result DO
        BEGIN
        bd_key_check_len:= 0;
        bd_max_rec_cnt  := csp_maxint2;
        bd_max_fill_len := sizeof (rec_buf);
        bd_next         := false;
        END;
    (*ENDWITH*) 
    IF  viewscanpar.vsc_user_save OR viewscanpar.vsc_schema_save
    THEN
        next_err := e_no_next_record
    ELSE
        next_err := e_buffer_limit;
    (*ENDIF*) 
    WHILE next_err = e_buffer_limit DO
        BEGIN
        (* sort content of into file by view level *)
        b07cnext_record (acv.a_transinf.tri_trans, acv.a_into_tree,
              prevkey, set_result, tree_pos, rec_buf.buf);
        next_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  (next_err = e_ok           ) OR
            (next_err = e_key_not_found) OR
            (next_err = e_buffer_limit )
        THEN
            BEGIN
            pos  := 1;
            acv.a_transinf.tri_trans.trError_gg00 := e_ok;
            WHILE pos < set_result.bd_fill_len DO
                BEGIN
                rec_len.map_c2[1] := rec_buf.buf[pos  ];
                rec_len.map_c2[2] := rec_buf.buf[pos+1];
                key_len.map_c2[1] := rec_buf.buf[pos+2];
                key_len.map_c2[2] := rec_buf.buf[pos+3];
                ins_buf.info[1]   :=
                      rec_buf.buf[pos+cgg_rec_key_offset+key_len.map_int];
                SAPDB_PascalMove ('VAK15 ',   1,    
                      sizeof (rec_buf.buf), sizeof (ins_buf.buf),
                      @rec_buf.buf, pos + cgg_rec_key_offset,
                      @ins_buf.buf, cgg_rec_key_offset + 2,
                      key_len.map_int, acv.a_transinf.tri_trans.trError_gg00);
                ins_buf.keylen := 1 + key_len.map_int;
                SAPDB_PascalMove ('VAK15 ',   2,    
                      sizeof (rec_buf.buf), sizeof (ins_buf.buf),
                      @rec_buf.buf, pos + cgg_rec_key_offset + key_len.map_int + 1,
                      @ins_buf.buf, cgg_rec_key_offset+ins_buf.keylen+1,
                      sizeof (tgg00_ServerdbNo),
                      acv.a_transinf.tri_trans.trError_gg00);
                ins_buf.recLen_gg00          := cgg_rec_key_offset + ins_buf.recKeyLen_gg00 + 2;
                ins_buf.recVarcolOffset_gg00 := 2;
                ins_buf.recVarcolCnt_gg00    := 0;
                IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
                THEN
                    b07cadd_record (acv.a_transinf.tri_trans,
                          tree_id, ins_buf);
                (*ENDIF*) 
                IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                THEN
                    BEGIN
                    next_err := acv.a_transinf.tri_trans.trError_gg00;
                    pos := set_result.bd_fill_len
                    END
                ELSE
                    pos := pos + rec_len.map_int
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            IF  next_err <> e_buffer_limit
            THEN
                next_err := e_no_next_record
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  next_err <> e_no_next_record
    THEN
        a07_b_put_error (acv, next_err, 1);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        (* View definitions are in correct order now, insert *)
        (* into table                                        *)
        tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
        REPEAT
            b07cnext_record (acv.a_transinf.tri_trans, tree_id,
                  prevkey, set_result, tree_pos, rec_buf.buf);
            next_err := acv.a_transinf.tri_trans.trError_gg00;
            IF  (next_err = e_ok           ) OR
                (next_err = e_key_not_found) OR
                (next_err = e_buffer_limit )
            THEN
                BEGIN
                pos   := 1;
                WHILE (pos < set_result.bd_fill_len) AND
                      (acv.a_returncode = 0) DO
                    BEGIN
                    rec_len.map_c2[1] := rec_buf.buf[pos  ];
                    rec_len.map_c2[2] := rec_buf.buf[pos+1];
                    key_len.map_c2[1] := rec_buf.buf[pos+2];
                    key_len.map_c2[2] := rec_buf.buf[pos+3];
                    site_pos          := pos +
                          cgg_rec_key_offset + key_len.map_int;
                    WITH viewscanpar.vsc_usagedef DO
                        BEGIN
                        SAPDB_PascalMove ('VAK15 ',   3,    
                              sizeof (rec_buf.buf),
                              sizeof (usa_tableid),
                              @rec_buf.buf, pos + cgg_rec_key_offset + 1,
                              @usa_tableid, 1, sizeof (usa_tableid),
                              acv.a_returncode);
                        usa_tablekind := tview;
                        END;
                    (*ENDWITH*) 
                    a15one_table_catalog (acv,
                          ord (rec_buf.info[pos]),
                          NOT c_unknown_sequence, viewscanpar);
                    pos := pos + rec_len.map_int
                    END;
                (*ENDWHILE*) 
                END;
            (*ENDIF*) 
        UNTIL
            (next_err <> e_buffer_limit) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
        IF  (next_err <> e_no_next_record) AND
            (next_err <> e_key_not_found ) AND
            (next_err <> e_ok            )
        THEN
            a07_b_put_error (acv, next_err, 1);
        (*ENDIF*) 
        b01empty_file   (acv.a_transinf.tri_trans, acv.a_into_tree);
        IF  NOT viewscanpar.vsc_user_save AND NOT viewscanpar.vsc_schema_save
        THEN
            a101_DestroyGroupedTempFile (acv.a_transinf.tri_trans, tree_id)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15all_base_tables (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_save_viewscan_par;
            VAR schema      : tsp00_KnlIdentifier);
 
CONST
      scan_temp        = true;
      scan_private     = true;
      scan_non_private = true;
      scan_public      = true;
 
VAR
      exitLoop        : boolean;
      useTable        : boolean;
      use_catalog_tab : boolean;
      use_synonyms    : boolean;
      fk_found        : boolean;
      isSchemaOwner   : boolean;
      session_sqlmode : tsp00_SqlMode;
      pSchema         : tak_sysbufferaddress;
      wantedSchema    : tgg00_Surrogate;
      top_sort_tree   : tgg00_FileId;
      a41v            : tak40_show_glob;
 
BEGIN
use_synonyms    := viewscanpar.vsc_user_save;
session_sqlmode := acv.a_session_sqlmode;
a41init_show_glob (a41v, acv.a_cmd_packet_header.sp1h_mess_code);
a40init_table_scan (acv, a41v, NOT scan_temp,
      scan_private, scan_non_private, NOT scan_public,
      use_synonyms, false);
IF  NOT viewscanpar.vsc_user_save
THEN
    a41v.a4all_objects := true
ELSE (* force a40next_table to return oracle system views *)
    acv.a_session_sqlmode := sqlm_oracle;
(*ENDIF*) 
IF  viewscanpar.vsc_schema_save
THEN
    BEGIN
    a41v.a4all_objects  := true;
    a41v.a4authname     := schema;
    pSchema := a103ExistsSchema (acv, schema);
    IF  pSchema = NIL
    THEN
        a07_nb_put_error (acv, e_unknown_name, acv.a_ap_tree^[viewscanpar.vsc_ti].n_pos, schema)
    ELSE
        BEGIN
        isSchemaOwner := pSchema^.suser.userowner_id = acv.a_curr_user_id;
        wantedSchema  := pSchema^.suser.usurrogate
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
top_sort_tree.fileRoot_gg00 := NIL_PAGE_NO_GG00;
exitLoop := false;
WHILE a40next_table (acv, a41v) AND NOT exitLoop DO
    WITH viewscanpar, a41v.a4p_arr.pbasep^ DO
        IF  syskey.sentrytyp <> cak_esequence
        THEN
            BEGIN
            IF  sbase.bv_tablekind = tcatalog_table
            THEN
                use_catalog_tab := ak15is_level1_catalog_tab (acv, a41v)
            ELSE
                use_catalog_tab := false;
            (*ENDIF*) 
            IF  viewscanpar.vsc_schema_save
            THEN
                useTable := (acv.a_current_user_kind = usysdba) OR isSchemaOwner OR
                      (sbase.bauthid = acv.a_curr_user_id)
            ELSE
                useTable := NOT viewscanpar.vsc_user_save OR
                      (NOT a41v.a4is_synonym AND (sbase.bauthid = acv.a_curr_user_id));
            (*ENDIF*) 
            IF  ((sbase.btablekind in [twithkey, twithoutkey]) AND
                (vsc_into_treeid.fileTabId_gg00 <> syskey.stableid)    AND
                NOT a41v.a4is_synonym AND useTable)
                OR
                (use_catalog_tab AND NOT a41v.a4is_synonym)
            THEN
                BEGIN
                acv.a_p_arr1   := a41v.a4p_arr;
                vsc_base_tabid := syskey.stableid;
                vsc_usagedef.usa_tableid   := vsc_base_tabid;
                vsc_usagedef.usa_tablekind := sbase.btablekind;
                (* PTS 1116837 E.Z. *)
                vsc_usagedef.usa_filler    := 0;
                vsc_usagedef.usa_empty     := false;
                vsc_type                   := v_save_scheme;
                vsc_col_dropped            := false;
                fk_found                   := false;
                IF  [is_primary_table, unique_pk_table]
                    * sbase.blinkexist <> []
                THEN
                    ak15scan_foreign_key_tables (acv, viewscanpar,
                          a41v.a4p_arr.pbasep, wantedSchema,
                          top_sort_tree, fk_found);
                (*ENDIF*) 
                IF  is_secondary_table in sbase.blinkexist
                THEN
                    ak15foreign_tab_enter (acv,
                          top_sort_tree, a41v.a4p_arr.pbasep)
                ELSE
                    IF  NOT fk_found
                    THEN
                        BEGIN
                        a15one_table_catalog (acv, 0,
                              NOT c_unknown_sequence, viewscanpar);
                        IF  NOT viewscanpar.vsc_user_save AND NOT viewscanpar.vsc_schema_save
                        THEN
                            a27view_scan (acv, vsc_base_tabid, viewscanpar)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                IF  viewscanpar.vsc_user_save OR viewscanpar.vsc_schema_save
                THEN
                    BEGIN
                    IF  a41v.a4is_synonym
                    THEN
                        ak15store_table (acv, a41v.a4usertab_buf^.sbase)
                    ELSE
                        IF  (sbase.btablekind in
                            [tonebase, tview, tcomplexview])
                            AND
                            useTable
                            AND
                            ((sbase.btablekind <> tonebase) OR
                            (syskey.stableid <> sbase.btreeid.fileTabId_gg00))
                        THEN
                            ak15store_table (acv, sbase);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  viewscanpar.vsc_schema_save    AND
                (sbase.btablekind <> tsynonym) AND
                (sbase.bschema <> wantedSchema)
            THEN
                exitLoop := true
            ELSE
                IF  viewscanpar.vsc_user_save AND NOT a41v.a4nonprivate
                THEN (* don't scan tables granted to public *)
                    exitLoop := true;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDWHILE*) 
a40FinishTableScan (acv, a41v);
acv.a_session_sqlmode := session_sqlmode;
ak15top_sort (acv, viewscanpar, top_sort_tree)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15build_view_description (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_save_viewscan_par);
 
VAR
      _buildViewDesc: boolean;
      _dummy_bool   : boolean;
      _b_err        : tgg00_BasisError;
      _i            : integer;
      _rest_len     : integer;
      _move_len     : integer;
      _qualp        : tak_sysbufferaddress;
      _base_arr     : tak_syspointerarr;
      _sysk         : tgg00_SysInfoKey;
      _priv         : tak_privilege;
      _pred_stack   : tgg00_StackEntry;
 
BEGIN
_buildViewDesc := false;
(*=====================================================*)
(* Define save scheme table as view with qualification *)
(* WHERE USERID = USERGROUP                            *)
(*=====================================================*)
IF  a06_table_exist( acv, d_fix, viewscanpar.vsc_into_authname,
    viewscanpar.vsc_into_tablen, _base_arr, false )
THEN
    BEGIN
    WITH _base_arr.pbasep^, sbase, syskey DO
        BEGIN
        _b_err := e_ok;
        viewscanpar.vsc_into_treeid := btreeid;
        viewscanpar.vsc_filevers    := btreeid.fileVersion_gg00;
        _buildViewDesc              := (viewscanpar.vsc_into_authname <> a01_i_temp) AND
              NOT viewscanpar.vsc_all_save; (* PTS 1110554 *)
        IF  _buildViewDesc
        THEN
            BEGIN
            bv_tablekind    := twithkey;
            bv_qualexist    := true;
            bv_tabcount     := 1;
            bv_checkopt     := true;
            btablekind      := tonebase;
            a10repl_sysinfo (acv, _base_arr.pbasep, _b_err);
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  ( _b_err = e_ok ) AND _buildViewDesc (* PTS 1110554 *)
    THEN
        BEGIN
        _sysk.sstandardkey:=_base_arr.pbasep^.syskey.sstandardkey;
        _sysk.sentrytyp   := cak_eviewqual_basis;
        _sysk.skeylen     := mxak_standard_sysk;
        a10_nil_get_sysinfo( acv, _sysk, d_release,
              sizeof( tak_viewqual_basis_record ), _qualp, _b_err );
        IF  _b_err = e_ok
        THEN
            BEGIN
            (* write base information *)
            _qualp^.sviewqual_basis.vjoin_exists    := false;
            _qualp^.sviewqual_basis.vstack_exists   := true;
            _qualp^.sviewqual_basis.vderived_exists := false;
            _qualp^.sviewqual_basis.vfiller         := false;
            _qualp^.sviewqual_basis.vbasetabcnt     := 1;
            _qualp^.sviewqual_basis.vtable[ 1 ].vttableid :=
                  _base_arr.pbasep^.sbase.btreeid.fileTabId_gg00;
            _qualp^.sviewqual_basis.vtable[ 1 ].vtins_for_upd    := true;
            _qualp^.sviewqual_basis.vtable[ 1 ].vtnot_used_links := [  ];
            _qualp^.b_sl := sizeof ( _qualp^.sviewqual_basis ) -
                  sizeof( _qualp^.sviewqual_basis.vtable ) +
                  sizeof( _qualp^.sviewqual_basis.vtable[ 1 ] );
            a10add_sysinfo( acv, _qualp, _b_err );
            END;
        (*ENDIF*) 
        ;
        _sysk.sentrytyp   := cak_eviewqual_stack;
        a10_nil_get_sysinfo( acv, _sysk, d_release,
              sizeof( tak_viewqual_stack_record ), _qualp, _b_err );
        IF  _b_err = e_ok
        THEN
            BEGIN
            _i := 1;
            (* write stack information *)
            (* we assume et least one stack entry fit on record *)
            ak15init_vqual_stack( _qualp );
            _qualp^.sviewqual_stack.vstack[ _i ].etype    := st_varcol;
            _qualp^.sviewqual_stack.vstack[ _i ].eop      := op_none;
            _qualp^.sviewqual_stack.vstack[ _i ].ecolno   := 1;
            _qualp^.sviewqual_stack.vstack[ _i ].elen_var :=
                  succ( sizeof( tsp00_KnlIdentifier ) );
            _qualp^.sviewqual_stack.vstack[ _i ].ecol_tab[ 1 ] := chr( 0 );
            _qualp^.sviewqual_stack.vstack[ _i ].ecol_tab[ 2 ] := chr( 0 );
            _qualp^.b_sl := _qualp^.b_sl +
                  sizeof( _qualp^.sviewqual_stack.vstack [ 1 ] );
            ;
            _pred_stack := _qualp^.sviewqual_stack.vstack[ _i ];
            _i := succ( _i );
            IF  _i > cak_max_viewqual_stack
            THEN
                BEGIN
                _i := 1;
                a10add_sysinfo( acv, _qualp, _b_err );
                a06inc_linkage( _sysk.slinkage );
                a10_nil_get_sysinfo( acv, _sysk, d_release,
                      sizeof( tak_viewqual_stack_record ), _qualp, _b_err );
                IF  _b_err = e_ok
                THEN
                    ak15init_vqual_stack( _qualp );
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  _b_err = e_ok
            THEN
                BEGIN
                _qualp^.sviewqual_stack.vstack[ _i ] := _pred_stack;
                _qualp^.sviewqual_stack.vstack[ _i ].etype := st_usergroup;
                IF  g01unicode
                THEN
                    _qualp^.sviewqual_stack.vstack[ _i ].ecol_tab[ 2 ] :=
                          csp_unicode_def_byte
                ELSE
                    _qualp^.sviewqual_stack.vstack[ _i ].ecol_tab[ 2 ] :=
                          bsp_c1;
                (*ENDIF*) 
                _qualp^.b_sl := _qualp^.b_sl +
                      sizeof( _qualp^.sviewqual_stack.vstack [ 1 ] );
                END;
            (*ENDIF*) 
            ;
            _i := succ( _i );
            IF  _i > cak_max_viewqual_stack
            THEN
                BEGIN
                _i := 1;
                a10add_sysinfo( acv, _qualp, _b_err );
                a06inc_linkage( _sysk.slinkage );
                a10_nil_get_sysinfo( acv, _sysk, d_release,
                      sizeof( tak_viewqual_stack_record ), _qualp, _b_err );
                IF  _b_err = e_ok
                THEN
                    ak15init_vqual_stack( _qualp );
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  _b_err = e_ok
            THEN
                BEGIN
                _qualp^.sviewqual_stack.vstack[ _i ].etype         := st_op;
                _qualp^.sviewqual_stack.vstack[ _i ].eop           := op_eq;
                _qualp^.sviewqual_stack.vstack[ _i ].epos          := 0;
                _qualp^.sviewqual_stack.vstack[ _i ].elen_var      := 0;
                _qualp^.sviewqual_stack.vstack[ _i ].ecol_tab[ 1 ] := chr( 0 );
                _qualp^.sviewqual_stack.vstack[ _i ].ecol_tab[ 2 ] := chr( 0 );
                _qualp^.b_sl := _qualp^.b_sl +
                      sizeof( _qualp^.sviewqual_stack.vstack [ 1 ] );
                END;
            (*ENDIF*) 
            ;
            (* write stack data *)
            (* calculate relative record data position *)
            _i := _qualp^.sviewqual_stack.vdatapos MOD cak_max_viewqual_data;
            IF  _i = 0
            THEN
                _i := cak_max_viewqual_data;
            (*ENDIF*) 
            ;
            (* check, if we need a new record *)
            IF  _i = 1
            THEN
                BEGIN
                a10add_sysinfo( acv, _qualp, _b_err );
                a06inc_linkage( _sysk.slinkage );
                a10_nil_get_sysinfo( acv, _sysk, d_release,
                      sizeof( tak_viewqual_stack_record ), _qualp, _b_err );
                IF  _b_err = e_ok
                THEN
                    ak15init_vqual_stack( _qualp );
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            _rest_len := _qualp^.sviewqual_stack.vdatalen;
            WHILE ( _rest_len > 0 ) AND ( _b_err = e_ok ) DO
                BEGIN
                IF  _rest_len > sizeof( _qualp^.sviewqual_stack.vdata ) -
                    ( _i - 1 )
                THEN
                    _move_len   := sizeof( _qualp^.sviewqual_stack.vdata ) -
                          ( _i - 1 )
                ELSE
                    _move_len := _rest_len;
                (*ENDIF*) 
&               ifdef trace
                t01int4( ak_sem, '_rest_len   ', _rest_len );
                t01int4( ak_sem, '_move_len   ', _move_len );
&               endif
                (* we don't move real data *)
                _qualp^.b_sl := _qualp^.b_sl + _move_len;
                _rest_len := _rest_len - _move_len;
                IF  _rest_len > 0
                THEN
                    BEGIN
                    _i := 1;
                    a10add_sysinfo( acv, _qualp, _b_err );
                    a06inc_linkage( _sysk.slinkage );
                    a10_nil_get_sysinfo( acv, _sysk, d_release,
                          sizeof( tak_viewqual_stack_record ), _qualp, _b_err );
                    IF  _b_err = e_ok
                    THEN
                        ak15init_vqual_stack( _qualp );
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            (* add last record *)
            a10add_sysinfo( acv, _qualp, _b_err );
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  ( _b_err = e_ok ) AND _buildViewDesc (* PTS 1110554 *)
    THEN
        BEGIN
        _sysk.slinkage   := cak_init_linkage;
        _sysk.sentrytyp  := cak_eprivuser;
        _sysk.suserid    := acv.a_curr_user_id;
        _sysk.sgrantuser := acv.a_curr_user_id;
        _sysk.skeylen    := mxak_standard_sysk + 2 * SURROGATE_MXGG00;
        a10_nil_get_sysinfo( acv, _sysk, d_release,
              sizeof( tak_privuserrecord ), _qualp, _b_err );
        IF  _b_err = e_ok
        THEN
            WITH _qualp^.sprivuser DO
                BEGIN
                pru_segmentid  := cak00_local_segment_id;
                pru_date       := _base_arr.pbasep^.sbase.bdatecreate;
                pru_time       := _base_arr.pbasep^.sbase.bdatecreate;
                _priv                 := a01emptypriv;
                _priv.priv_all_set    := [ r_sel, r_owner, r_ins, r_del ];
                _priv.priv_all_grant_set := _priv.priv_all_set;
                IF  acv.a_cmd_segment_header.sp1c_producer = sp1pr_internal_cmd
                THEN
                    _priv.priv_upd_set   := [ 4,5,6,7,8,9,10,13 ] (* PTS 1110528 *)
                ELSE
                    _priv.priv_upd_set   := [ 8,9,10,13 ]; (* PTS 1110528 *)
                (*ENDIF*) 
                _priv.priv_grant_upd_set := _priv.priv_upd_set;
                a22add_priv_rec( acv, _base_arr.pbasep, _priv,
                      _qualp, true, _dummy_bool );
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  _b_err <> e_ok
    THEN
        a07_b_put_error( acv, _b_err, 1 );
    (*ENDIF*) 
    END
ELSE
    a07ak_system_error( acv, 15, 1 );
(*ENDIF*) 
a10_all_release( acv );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15init_vqual_stack (vqual_stack : tak_sysbufferaddress);
 
BEGIN
vqual_stack^.sviewqual_stack.vfiller    := '00';
vqual_stack^.sviewqual_stack.vview_offs := 0;
vqual_stack^.sviewqual_stack.vstcount   := 3;
vqual_stack^.sviewqual_stack.vdatapos   :=
      3 * sizeof( vqual_stack^.sviewqual_stack.vstack [ 1 ] ) + 1;
vqual_stack^.sviewqual_stack.vdatalen   := succ( sizeof( tsp00_KnlIdentifier ) );
vqual_stack^.b_sl := sizeof( vqual_stack^.sviewqual_stack ) -
      sizeof( vqual_stack^.sviewqual_stack.vstack );
END;
 
(*------------------------------*) 
 
PROCEDURE
      a15catalog_save (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_save_viewscan_par);
 
VAR
      init_cmd_part : tsp1_part_ptr;
 
BEGIN
WITH acv, viewscanpar DO
    IF  a_returncode = 0
    THEN
        BEGIN
        init_cmd_part := a_cmd_part;
        IF  NOT(vsc_save_into)
        THEN
            BEGIN
&           ifdef trace
            t01int4 (ak_sem, 'first_save  ', ord(vsc_first_save));
            t01int4 (ak_sem, 'last_save   ', ord(vsc_last_save));
&           endif
            IF  vsc_first_save
            THEN
                BEGIN
                vsc_tree_id             := a_intern_res_tree;
                a101_CreateGroupedTempFile (a_transinf.tri_trans, vsc_tree_id,
                      ttfnSaveScheme_egg00);
                IF  a_transinf.tri_trans.trError_gg00 <> e_ok
                THEN
                    a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            vsc_usagedef.usa_tableid   := vsc_base_tabid;
            vsc_usagedef.usa_tablekind := vsc_tablekind;
            (* PTS 1116837 E.Z. *)
            vsc_usagedef.usa_filler    := 0;
            vsc_usagedef.usa_empty     := false;
            a15one_table_catalog (acv, 0,
                  NOT c_unknown_sequence, viewscanpar)
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  vsc_save_into
            THEN
                vsc_type := v_save_scheme
            ELSE
                vsc_type := v_intern_save_scheme;
            (*ENDIF*) 
            vsc_col_dropped := false;
            a27view_scan (acv, vsc_base_tabid, viewscanpar);
            END;
        (*ENDIF*) 
        IF  vsc_last_save
        THEN
            BEGIN
            b01empty_file (acv.a_transinf.tri_trans, a_into_tree);
            IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv,
                      acv.a_transinf.tri_trans.trError_gg00, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT (vsc_save_into) AND (init_cmd_part <> acv.a_cmd_part)
        THEN
            a542pop_packet (acv);
        (*ENDIF*) 
        IF  acv.a_returncode <> 0
        THEN
            BEGIN
            IF  vsc_save_into
            THEN
                BEGIN
                a_part_rollback := true
                END
            ELSE
                a101_DestroyGroupedTempFile (a_transinf.tri_trans,
                      vsc_tree_id);
            (*ENDIF*) 
            a10_cache_delete (acv, NOT c_is_rollback);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a15restore_catalog (
            VAR acv         : tak_all_command_glob;
            VAR treeid      : tgg00_FileId;
            VAR viewscanpar : tak_save_viewscan_par);
 
CONST
      c_with_zero = true;
 
VAR
      set_result        : tgg00_BdSetResultRecord;
      first             : boolean;
      get_next          : boolean;
      rollback          : boolean;
      found             : boolean;
      new_cmd           : boolean;
      res               : tsp00_NumError;
      b_err             : tgg00_BasisError;
      cmd_cnt           : tsp00_Int2;
      current_cmd_cnt   : integer;
      move_len          : integer;
      pos               : integer;
      curr_dt_format    : tgg00_DateTimeFormat;
      curr_sqlmode      : tsp00_SqlMode;
      curr_user_kind    : tak_usertyp;
      rc                : tsp00_C8;
      curr_user_id      : tgg00_Surrogate;
      curr_user_name    : tsp00_KnlIdentifier;
      curr_dba_id       : tgg00_Surrogate;
      curr_dba_name     : tsp00_KnlIdentifier;
      curr_schema       : tsp00_KnlIdentifier;
      curr_schema_id    : tgg00_Surrogate;
      schemaName        : tsp00_KnlIdentifier;
      schemaContextName : tsp00_KnlIdentifier;
      user_info         : tak_user_info;
      tree_pos          : tgg00_FilePos;
      prevkey           : tgg00_Lkey;
      error_tree_id     : tgg00_FileId;
      old_ddl_kind      : tak_ddl_descriptor; (* necessary to get the
      right system-stored-procedure-call for the DOMAIN-Tool in vak26 *)
 
      dt_format : RECORD
            CASE boolean OF
                true :
                    (map_c2 : tsp00_C2);
                false :
                    (map_dt : tgg00_DateTimeFormat);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH acv DO
    BEGIN
    old_ddl_kind := a_is_ddl; (* store the kind of the external
          sql_call for system-procedure-call *)
    a542internal_packet (acv,
          NOT c_release_packet, g01packet_size);
    IF  a_returncode = 0
    THEN
        BEGIN
        prevkey.len    := 0;
        SAPDB_PascalForcedFill (PERM_KEY_MXSP00, @prevkey.k, 1, save_scheme_keylen, chr(0));
        curr_dt_format := a_dt_format;
        curr_sqlmode   := a_sqlmode;
        curr_user_id   := a_curr_user_id;
        curr_user_name := a_curr_user_name;
        curr_user_kind := a_current_user_kind;
        curr_dba_id    := a_acc_dba_id;
        curr_dba_name  := a_acc_dbaname;
        curr_schema    := a_curr_schema;
        curr_schema_id := a_curr_schema_id;
        b_err          := e_ok;
        IF  viewscanpar.vsc_save_into
        THEN
            BEGIN
            error_tree_id             := a_intern_res_tree;
            a101_CreateGroupedTempFile (acv.a_transinf.tri_trans,
                  error_tree_id, ttfnLink_egg00);
            b_err := acv.a_transinf.tri_trans.trError_gg00
            END;
        (*ENDIF*) 
        first    := true;
        rollback := false;
        get_next := true;
        current_cmd_cnt := 1;
        acv.a_try_again := false;
        found           := false;
        new_cmd         := true;
        WHILE (b_err = e_ok) AND (a_returncode = 0) DO
            BEGIN
            IF  new_cmd
            THEN
                new_cmd := false;
            (*ENDIF*) 
            acv.a_command_sequence := acv.a_command_sequence + 1;
            acv.a_command_id       := acv.a_command_sequence;
            a06a_mblock_init (acv,
                  m_select_row, mm_next, treeid);
            IF  viewscanpar.vsc_save_into
            THEN
                BEGIN
                a_mblock.mb_qual^.mqual_pos := 1;
                a_mblock.mb_qual^.mqual_cnt := 1;
                WITH  a_mblock.mb_st^ [1] DO
                    BEGIN
                    etype          := st_rec_output;
                    eop            := op_none;
                    epos           := 0;
                    elen_var       := 0;
                    ecol_tab [ 1 ] := chr(0);
                    ecol_tab [ 2 ] := chr(0);
                    END;
                (*ENDWITH*) 
                (* startkey buildup: *)
                a_mblock.mb_qual^.mstrat_pos  := 2;
                WITH a_mblock.mb_st^ [2] DO
                    BEGIN
                    etype    := st_strat;
                    eop      := op_none;
                    epos     := cgg_rec_key_offset + 1;
                    elen_var := save_scheme_keylen;
                    ecol_pos := 0;
                    END;
                (*ENDWITH*) 
                SAPDB_PascalForcedMove (sizeof (prevkey.k),
                      a_mblock.mb_data_size, @prevkey.k, 1,
                      @a_mblock.mb_data^.mbp_buf, cgg_rec_key_offset
                      + 1, save_scheme_keylen);
                (* stopkey buildup: *)
                WITH a_mblock.mb_st^ [3] DO
                    BEGIN
                    etype    := st_strat;
                    eop      := op_none;
                    epos     := 0;
                    elen_var := 0;
                    ecol_pos := 0
                    END;
                (*ENDWITH*) 
                a_mblock.mb_qual^.mfirst_free := 4;
                a_mblock.mb_qual^.mstrat_cnt  := 2;
                a_mblock.mb_data_len  :=
                      cgg_rec_key_offset+save_scheme_keylen;
                a06rsend_mess_buf (acv,
                      a_mblock, cak_return_req, b_err);
                END
            ELSE
                BEGIN
                WITH set_result DO
                    BEGIN
                    bd_key_check_len := 0;
                    bd_max_rec_cnt   := 1;
                    bd_max_fill_len  := a_mblock.mb_data_size;
                    bd_next          := true;
                    END;
                (*ENDWITH*) 
                tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
                b07cnext_record (acv.a_transinf.tri_trans,
                      viewscanpar.vsc_tree_id, prevkey, set_result,
                      tree_pos, a_mblock.mb_data^.mbp_4kbuf);
                b_err := acv.a_transinf.tri_trans.trError_gg00
                END;
            (*ENDIF*) 
            IF  (b_err = e_ok) OR
                ((first) AND (b_err = e_key_not_found))
            THEN
                BEGIN
                found := true;
                s40gsint (a_mblock.mb_data^.mbp_4kbuf, pos_cmd_cnt, 5,
                      cmd_cnt, res);
                IF  cmd_cnt <> current_cmd_cnt
                THEN
                    BEGIN
                    get_next        := false;
                    current_cmd_cnt := cmd_cnt
                    END
                ELSE
                    BEGIN
                    first    := false;
                    get_next := true;
                    b_err    := e_ok;
                    SAPDB_PascalMove ('VAK15 ',   4,    
                          a_mblock.mb_data_size,
                          sizeof (prevkey.k),
                          @a_mblock.mb_data^.mbp_4kbuf,
                          cgg_rec_key_offset + 1,
                          @prevkey.k, 1, save_scheme_keylen,
                          a_returncode);
                    prevkey.len := save_scheme_keylen;
                    CASE ord (
                          a_mblock.mb_data^.mbp_buf[pos_context+1])
                          DIV 10 OF
                        0 :
                            a_sqlmode := sqlm_internal;
                        1 :
                            a_sqlmode := sqlm_ansi;
                        2 :
                            a_sqlmode := sqlm_db2;
                        3 :
                            a_sqlmode := sqlm_oracle;
                        END;
                    (*ENDCASE*) 
                    dt_format.map_c2[ 1 ] := chr ( ord (
                          a_mblock.mb_data^.mbp_buf[pos_context+1])
                          MOD 10);
                    IF  dt_format.map_c2[ 1 ] <> chr(0)
                    THEN
                        (* restore date time format *)
                        a_dt_format := dt_format.map_dt;
&                   ifdef trace
                    (*ENDIF*) 
                    t01int4 (ak_sem, 'a_sqlmode   ', ord (a_sqlmode));
                    t01int4 (ak_sem, 'dt_format   ', ord (a_dt_format));
&                   endif
                    move_len := ord(a_mblock.mb_data^.mbp_4kbuf[pos_owner]) - 1;
                    a_curr_user_name := a01_il_b_identifier;
                    SAPDB_PascalForcedMove (a_mblock.mb_data_size,
                          sizeof (a_curr_user_name),
                          @a_mblock.mb_data^.mbp_4kbuf, pos_owner + 2,
                          @a_curr_user_name, 1, move_len);
                    pos := pos_owner + 1 + move_len + 1;
                    (* schema name *)
                    move_len   := ord(a_mblock.mb_data^.mbp_4kbuf[pos]) - 1;
&                   ifdef trace
                    t01int4 (ak_sem, 'pos         ', pos);
                    t01int4 (ak_sem, 'move_len    ', move_len);
&                   endif
                    schemaName := a01_il_b_identifier;
                    SAPDB_PascalForcedMove (a_mblock.mb_data_size,
                          sizeof (schemaName),
                          @a_mblock.mb_data^.mbp_4kbuf, pos + 2,
                          @schemaName, 1, move_len);
                    pos := pos + 1 + move_len + 1;
                    (* schema context name *)
                    move_len   := ord(a_mblock.mb_data^.mbp_4kbuf[pos]) - 1;
&                   ifdef trace
                    t01int4 (ak_sem, 'pos         ', pos);
                    t01int4 (ak_sem, 'move_len    ', move_len);
&                   endif
                    schemaContextName := a01_il_b_identifier;
                    SAPDB_PascalForcedMove (a_mblock.mb_data_size,
                          sizeof (schemaContextName),
                          @a_mblock.mb_data^.mbp_4kbuf, pos + 2,
                          @schemaContextName, 1, move_len);
                    pos := pos + 1 + move_len + 1;
                    IF  viewscanpar.vsc_save_into
                    THEN
                        BEGIN
                        (* skip table name *)
                        pos := pos + 1 + ord (a_mblock.mb_data^.mbp_4kbuf[pos])
                        END;
                    (*ENDIF*) 
                    move_len := a_mblock.mb_data^.mbp_reclen - pos - 1;
&                   ifdef trace
                    t01int4 (ak_sem, 'pos         ', pos);
                    t01int4 (ak_sem, 'move_len    ', move_len);
&                   endif
                    IF  NOT viewscanpar.vsc_save_into  OR  (* PTS 1107988 *)
                        (a_cmd_part^.sp1p_buf_len > 0) OR
                        (acv.a_mblock.mb_data^.mbp_4kbuf[pos_sqlcmd + 1] = 'Y')
                    THEN
                        BEGIN
                        IF  a_cmd_part^.sp1p_buf_len + move_len >
                            a_cmd_part^.sp1p_buf_size
                        THEN
                            a07_b_put_error (acv, e_too_small_packet_size, 1)
                        ELSE
                            SAPDB_PascalMove ('VAK15 ',   5,    
                                  a_mblock.mb_data_size,
                                  a_cmd_part^.sp1p_buf_size,
                                  @a_mblock.mb_data^.mbp_4kbuf,
                                  pos + 2, @a_cmd_part^.sp1p_buf,
                                  a_cmd_part^.sp1p_buf_len + 1,
                                  move_len, a_returncode);
                        (*ENDIF*) 
                        a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len
                              + move_len
                        END
                    ELSE
                        a_cmd_part^.sp1p_buf_len := 0;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (NOT (get_next) OR (b_err = e_no_next_record))
                AND (a_cmd_part^.sp1p_buf_len > 0)
            THEN
                BEGIN
                IF  a22exist_user (acv, a_curr_user_name, 1, user_info)
                THEN
                    BEGIN
                    a_curr_user_id      := user_info.ui_id;
                    a_current_user_kind := user_info.ui_kind;
                    a_acc_dba_id        := user_info.ui_owner;
                    a06determine_username (acv,
                          a_acc_dba_id, a_acc_dbaname);
                    a103GetSchemaId (acv, schemaContextName, 1, a_curr_schema_id);
                    a_curr_schema := schemaContextName;
&                   ifdef trace
                    t01surrogate (ak_sem, 'curr user id', a_curr_user_id);
                    t01lidentifier (ak_sem, a_curr_user_name);
                    t01surrogate (ak_sem, 'curr schema ', a_curr_schema_id);
                    t01lidentifier (ak_sem, a_curr_schema);
                    t01moveobj (ak_sem, a_cmd_part^.sp1p_buf,
                          1, a_cmd_part^.sp1p_buf_len);
&                   endif
                    a35_asql_statement (acv);
                    new_cmd := true
                    END;
                (*ENDIF*) 
                a10_all_release (acv);
                IF  a_returncode = 0
                THEN
                    a_cmd_part^.sp1p_buf_len := 0
                ELSE
                    IF  viewscanpar.vsc_save_into
                    THEN
                        BEGIN
                        a15_add_errorfile (acv, prevkey,
                              a_returncode,
                              error_tree_id);
                        a_returncode  := 0;
                        rollback     := true;
                        a_cmd_part^.sp1p_buf_len := 0;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  b_err <> e_no_next_record
        THEN
            BEGIN
            a07_b_put_error (acv, b_err, 1);
            rollback := true;
            END;
        (*ENDIF*) 
        IF  viewscanpar.vsc_save_into
        THEN
            BEGIN
            IF  rollback
            THEN
                BEGIN
                a07_b_put_error (acv, e_restore_catalog_error, 1);
                a_internal_sql := no_internal_sql;
                a52end_rollback_subtrans (acv, a01_il_b_identifier, m_rollback)
                END;
            (*ENDIF*) 
            IF  NOT found
            THEN
                a07_b_put_error (acv, e_key_not_found, 1)
            ELSE
                ak15_set_error_code_zero (acv, treeid);
            (*ENDIF*) 
            IF  rollback
            THEN
                ak15_rollback (acv, treeid, error_tree_id);
            (*ENDIF*) 
            a101_DestroyGroupedTempFile (acv.a_transinf.tri_trans,
                  error_tree_id);
            END;
        (*ENDIF*) 
        a_curr_user_name     := curr_user_name;
        a_curr_user_id       := curr_user_id;
        a_current_user_kind  := curr_user_kind;
        a_curr_schema        := curr_schema;
        a_curr_schema_id     := curr_schema_id;
        a_acc_dba_id         := curr_dba_id;
        a_acc_dbaname        := curr_dba_name;
        a_dt_format          := curr_dt_format;
        a_sqlmode            := curr_sqlmode;
        a542pop_packet (acv);
        IF  a_returncode <> 0
        THEN
            BEGIN
            a10_cache_delete (acv, NOT c_is_rollback);
            IF  NOT viewscanpar.vsc_save_into
            THEN
                BEGIN
                rc := bsp_c8;
                g17int4to_line (a_returncode, NOT c_with_zero, 6, 1, rc);
                a_returncode := 0;
                a07_b_put_error (acv, e_internal_recreate_failed, 1);
                a07const_param (acv, 1, @rc, sizeof(rc));
                a07put_param   (acv, 2, @acv.a_viewname, sizeof(acv.a_viewname));
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT(viewscanpar.vsc_save_into)
        AND (viewscanpar.vsc_tree_id.fileName_gg00 <> cgg_zero_fn)
    THEN
        BEGIN
        a101_DestroyGroupedTempFile (acv.a_transinf.tri_trans,
              viewscanpar.vsc_tree_id);
        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a_is_ddl := old_ddl_kind; (* restore the kind of the external
          sql_call for system-procedure-call *)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15_set_error_code_zero (
            VAR acv     : tak_all_command_glob;
            VAR treeid  : tgg00_FileId);
 
VAR
      b_err  : tgg00_BasisError;
      res    : tsp00_NumError;
 
BEGIN
a06a_mblock_init (acv, m_update, mm_qual, treeid);
WITH acv, a_mblock, mb_qual^ DO
    BEGIN
    mcol_pos := 1;
    mcol_cnt := 1;
    WITH mb_st^ [1] DO
        BEGIN
        etype         := st_fixcol;
        eop           := op_none;
        epos          := pos_errorcode -
              save_scheme_keylen - cgg_rec_key_offset;
        elen_var      := 4;
        ecol_tab[ 1 ] := chr(0);
        ecol_tab[ 2 ] := chr(0);
        END;
    (*ENDWITH*) 
    mb_data^.mbp_buf[cgg_rec_key_offset+1] := chr(4);
    mb_data^.mbp_buf[cgg_rec_key_offset+2] := chr(0);
    s41plint (mb_data^.mbp_4kbuf, cgg_rec_key_offset+3, 4, 0, 0, res);
    mb_data_len         := cgg_rec_key_offset+5;
    mfirst_free         := 2;
    a71add_default_strat (a_mblock);
    a06rsend_mess_buf (acv, a_mblock, NOT cak_return_req, b_err);
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a15_add_errorfile (
            VAR acv           : tak_all_command_glob;
            VAR prevkey       : tgg00_Lkey;
            ret_code          : tsp00_Int2;
            VAR error_tree_id : tgg00_FileId);
 
VAR
      res   : tsp00_NumError;
 
BEGIN
WITH acv, a_mblock DO
    BEGIN
    SAPDB_PascalForcedMove (sizeof (prevkey.k), mb_data_size,
          @prevkey.k, 1, @mb_data^.mbp_buf, cgg_rec_key_offset+1, cak15_level_cmd_no_len);
    mb_data^.mbp_keylen        := cak15_level_cmd_no_len;
    mb_data^.mbp_reclen        := cgg_rec_key_offset + mb_data^.mbp_keylen + cak15_fixed4_size;
    mb_data^.mbp_varcol_offset := cak15_fixed4_size;
    mb_data^.mbp_varcol_cnt    := 0;
    mb_data^.mbp_4kbuf[ cgg_rec_key_offset + mb_data^.mbp_keylen + 1 ] := chr(0);
&   ifdef trace
    t01int4 (ak_sem, 'returncode= ', ret_code);
&   endif
    s41plint (mb_data^.mbp_4kbuf, cgg_rec_key_offset + mb_data^.mbp_keylen + 2,
          cak15_fixed4_size, 0, ret_code, res);
    b07cadd_record (a_transinf.tri_trans,
          error_tree_id, mb_data^.mbp_rec);
    IF  a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15_rollback (
            VAR acv           : tak_all_command_glob;
            VAR treeid        : tgg00_FileId;
            VAR error_tree_id : tgg00_FileId);
 
VAR
      b_err      : tgg00_BasisError;
      qualValPos : tsp00_Int4;
      set_result : tgg00_BdSetResultRecord;
      tree_pos   : tgg00_FilePos;
      prevkey    : tgg00_Lkey;
      gg_strategy: tgg07_StrategyInfo;
      rec_buf    : tgg00_Rec;
 
BEGIN
WITH acv, a_mblock DO
    BEGIN
    prevkey.len    := 0;
    tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
    WITH set_result DO
        BEGIN
        bd_key_check_len:= 0;
        bd_max_rec_cnt  := 1;
        bd_max_fill_len := sizeof (rec_buf);
        bd_next         := true;
        END;
    (*ENDWITH*) 
    REPEAT
        tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
        b07cnext_record (acv.a_transinf.tri_trans, error_tree_id,
              prevkey, set_result, tree_pos, rec_buf.buf);
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  (b_err = e_ok) OR (b_err = e_key_not_found)
        THEN
            BEGIN
            b_err := e_ok;
            SAPDB_PascalMove ('VAK15 ',   6,    
                  sizeof (rec_buf.buf), sizeof(prevkey.k),
                  @rec_buf.buf, cgg_rec_key_offset + 1, @prevkey.k, 1,
                  rec_buf.keylen, b_err);
            prevkey.len := rec_buf.keylen;
            a06a_mblock_init (acv,
                  m_update, mm_qual, treeid);
            mb_data_len                   := cgg_rec_key_offset + 1;
            mb_data^.mbp_buf[mb_data_len] := chr(cak15_fixed4_size);
            SAPDB_PascalMove ('VAK15 ',   7,    
                  sizeof (rec_buf.buf), mb_data_size,
                  @rec_buf.buf, cgg_rec_key_offset + rec_buf.keylen + 1,
                  @mb_data^.mbp_4kbuf, mb_data_len + 1, cak15_fixed4_size , b_err);
            mb_data_len := mb_data_len + cak15_fixed4_size;
            qualValPos  := mb_data_len + 1;
            SAPDB_PascalMove ('VAK15 ',   8,    
                  sizeof (rec_buf.buf), mb_data_size,
                  @rec_buf.buf, cgg_rec_key_offset + 1, @mb_data^.mbp_4kbuf,
                  qualValPos, rec_buf.keylen, b_err);
            mb_data_len := mb_data_len + rec_buf.keylen;
            WITH mb_qual^ DO
                BEGIN
                mcol_pos := 1;
                mcol_cnt := 1;
                WITH mb_st^ [1] DO
                    BEGIN
                    etype         := st_fixcol;
                    eop           := op_none;
                    epos          := pos_errorcode -
                          save_scheme_keylen - cgg_rec_key_offset;
                    elen_var      := cak15_fixed4_size;
                    ecol_tab[ 1 ] := chr(0);
                    ecol_tab[ 2 ] := chr(0);
                    END;
                (*ENDWITH*) 
                WITH mb_st^ [2] DO
                    BEGIN
                    etype    := st_jump_output;
                    eop      := op_none;
                    epos     := 2;
                    elen_var := 0;
                    ecol_pos := 0;
                    END;
                (*ENDWITH*) 
                WITH mb_st^ [3] DO
                    BEGIN
                    etype         := st_fixkey;
                    eop           := op_none;
                    epos          := 1;
                    elen_var      := cak15_fixed6_size;
                    ecol_tab[ 1 ] := chr(0);
                    ecol_tab[ 2 ] := chr(0);
                    END;
                (*ENDWITH*) 
                WITH mb_st^ [4] DO
                    BEGIN
                    etype         := st_value;
                    eop           := op_eq;
                    epos          := qualValPos;
                    elen_var      := cak15_fixed6_size;
                    ecol_tab[ 1 ] := chr(0);
                    ecol_tab[ 2 ] := chr(0);
                    END;
                (*ENDWITH*) 
                WITH mb_st^ [5] DO
                    BEGIN
                    etype    := st_jump_false;
                    eop      := op_none;
                    epos     := 4;
                    elen_var := 0;
                    ecol_pos := 0;
                    END;
                (*ENDWITH*) 
                mb_st^ [6]      := mb_st^ [3];
                mb_st^ [6].epos := mb_st^ [3].epos + mb_st^[3].elen_var;
                mb_st^ [7]      := mb_st^ [4];
                mb_st^ [7].epos := qualValPos + cak15_fixed6_size;
                mqual_pos       := 2;
                mqual_cnt       := 6;
                g09StratStackentry( mb_st^[ 8 ], mb_strat_len + 1,
                      STRATEGY_START_MXGG07 +
                      sizeof( gg_strategy.str_key_in_range ));
                mstrat_pos   := 8;
                mstrat_cnt   := 1;
                a71default_strat( gg_strategy );
                gg_strategy.str_ordering     := true;
                gg_strategy.str_key_len      := 4;
                gg_strategy.str_rec_len      := 8;
                gg_strategy.str_key_in_range.skir_keystart[ 0 ] := 3;
                gg_strategy.str_key_in_range.skir_keystart[ 1 ] := 6;
                gg_strategy.str_key_in_range.skir_keystop [ 0 ] := 3;
                gg_strategy.str_key_in_range.skir_keystop [ 1 ] := 6;
                SAPDB_PascalMove ('VAK15 ',   9,    
                      sizeof( gg_strategy ), mb_strat_size,
                      @gg_strategy, 1,
                      @mb_strat^, mb_strat_len + 1,
                      STRATEGY_START_MXGG07 + sizeof( gg_strategy.str_key_in_range ),
                      b_err );
                mb_strat_len  := mb_strat_len +
                      STRATEGY_START_MXGG07 + sizeof( gg_strategy.str_key_in_range );
                mb_qual^.mfirst_free := 9;
                IF  b_err = e_ok
                THEN
                    a06rsend_mess_buf( acv, a_mblock, NOT cak_return_req, b_err );
                (*ENDIF*) 
                END
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
    UNTIL
        b_err <> e_ok;
    (*ENDREPEAT*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a15one_table_catalog (
            VAR acv          : tak_all_command_glob;
            viewlevel_cnt    : integer;
            unknown_sequence : boolean;
            VAR viewscanpar  : tak_save_viewscan_par);
 
CONST
      c_exit_loop = -2;
 
TYPE
      tak15_commandtype = (create_view, create_synonym, grant, table_info);
 
VAR
      ok                : boolean;
      add_command       : boolean;
      is_systable       : boolean;
      res               : tsp00_NumError;
      b_err             : tgg00_BasisError;
      command_type      : tak15_commandtype;
      priv_mode         : tak15_priv_gen_mode;
      len               : integer;
      vt_pos            : integer;
      count             : integer;
      start_pos         : integer;
      col_no            : integer;
      maxlen            : integer;
      pos               : integer;
      viewtextpos       : integer;
      move_len          : integer;
      viewtextbuf       : tak_sysbufferaddress;
      privbuf           : tak_sysbufferaddress;
      tableref          : tak_sysbufferaddress;
      tablekind         : tsp00_C8;
      tabletype         : tsp00_C8;
      first_base        : ^tak_baserecord;
      user_name         : tsp00_KnlIdentifier;
      schemaName        : tsp00_KnlIdentifier;
      schemaContextName : tsp00_KnlIdentifier;
      table_name        : tsp00_KnlIdentifier;
      internal          : tak_keyword;
      sysk              : tgg00_SysInfoKey;
      viewtextkey       : tgg00_SysInfoKey;
      viewprivkey       : tgg00_SysInfoKey;
 
BEGIN
is_systable  := false;
WITH viewscanpar.vsc_usagedef DO
    a06_systable_get (acv, d_fix, usa_tableid,
          acv.a_p_arr2.pbasep, true, ok);
(*ENDWITH*) 
IF  NOT ok
THEN
    a07ak_system_error (acv, 15, 3)
ELSE
    BEGIN
    first_base := @acv.a_p_arr2.pbasep^.sbase;
    IF  first_base^.btablekind = tsynonym
    THEN
        BEGIN
        command_type := create_synonym;
        a06determine_username (acv,
              acv.a_p_arr2.pbasep^.ssynonym.syn_authid, user_name);
        schemaName        := user_name;
        schemaContextName := user_name;
        table_name        := acv.a_p_arr2.pbasep^.ssynonym.syn_tablen;
        tablekind         := 'SYNONYM ';
        IF  acv.a_p_arr2.pbasep^.ssynonym.syn_internal (* PTS 1110528 *)
        THEN
            tabletype := 'SYSTEM  '
        ELSE
            tabletype := tablekind;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        table_name := first_base^.btablen^;
        command_type     := create_view;
        sysk             := a01defaultkey;
        sysk.sauthid     := first_base^.bschema;
        sysk.sentrytyp   := cak_etableref;
        sysk.sidentifier := first_base^.btablen^;
        sysk.skeylen     := sysk.skeylen + sizeof (sysk.sidentifier);
        a10get_sysinfo (acv, sysk, d_release,
              tableref, b_err);
        IF  b_err = e_ok
        THEN
            is_systable := tableref^.stableref.rsystable
        ELSE
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        CASE first_base^.btablekind OF (* PTS 1110528 *)
            twithkey, twithoutkey :
                tablekind := 'TABLE   ';
            OTHERWISE :
                tablekind := 'VIEW    ';
            END;
        (*ENDCASE*) 
        IF  is_systable (* PTS 1110528 *)
        THEN
            tabletype := 'SYSTEM  '
        ELSE
            tabletype := tablekind;
        (*ENDIF*) 
        a06determine_username (acv, first_base^.bauthid, user_name);
        a103GetSchemaName     (acv, first_base^.bschema, schemaName);
        a103GetSchemaName     (acv, first_base^.bschemacontext, schemaContextName);
        IF  first_base^.btablekind in [twithkey, twithoutkey]
        THEN
            BEGIN (* base table *)
            IF  (viewscanpar.vsc_all_save) OR (viewscanpar.vsc_save_into) (* PTS 1107988 *)
            THEN
                BEGIN
                command_type := table_info
                END
            ELSE
                command_type := grant;
            (*ENDIF*) 
            priv_mode    := all_priv
            END
        ELSE
            IF  NOT viewscanpar.vsc_all_save AND
                (viewscanpar.vsc_usagedef.usa_tableid =
                viewscanpar.vsc_base_tabid)
            THEN
                BEGIN
                command_type := grant;
                priv_mode    := all_priv
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (acv.a_cmd_segment_header.sp1c_producer <> sp1pr_kernel)
            OR
            (acv.a_cmd_part^.sp1p_buf_size < g01packet_size)
        THEN
            a542internal_packet (acv,
                  NOT c_release_packet, g01packet_size)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ok AND (acv.a_returncode = 0)
THEN
    BEGIN
    b_err := e_ok;
    acv.a_mblock.mb_data^.mbp_4kbuf[cgg_rec_key_offset+1] := chr(0);
    s41plint (acv.a_mblock.mb_data^.mbp_4kbuf,
          cgg_rec_key_offset + 2, 6, 0, viewlevel_cnt, res);
    count := 0;
    acv.a_mblock.mb_data^.mbp_4kbuf[pos_context  ] := csp_undef_byte;
    acv.a_mblock.mb_data^.mbp_4kbuf[pos_context+1] := chr(0);
    (* store owner name *)
    move_len := a061identifier_len (user_name);
    IF  move_len = 0
    THEN
        a07_b_put_error (acv, e_unknown_name, 1);
    (*ENDIF*) 
    acv.a_mblock.mb_data^.mbp_4kbuf[pos_owner] := chr (move_len + 1);
    IF  g01unicode
    THEN
        acv.a_mblock.mb_data^.mbp_4kbuf[pos_owner+1] := csp_unicode_def_byte
    ELSE
        acv.a_mblock.mb_data^.mbp_4kbuf[pos_owner+1] := bsp_c1;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK15 ',  10,    
          sizeof (user_name), acv.a_mblock.mb_data_size,
          @user_name, 1, @acv.a_mblock.mb_data^.mbp_4kbuf,
          pos_owner  + 2, move_len, acv.a_returncode);
    vt_pos := pos_owner + 1 + 1 + move_len;
    (* store schema name *)
    move_len := a061identifier_len (schemaName);
    acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos] := chr (move_len + 1);
    IF  g01unicode
    THEN
        acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos+1] := csp_unicode_def_byte
    ELSE
        acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos+1] := bsp_c1;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK15 ',  11,    
          sizeof (schemaName), acv.a_mblock.mb_data_size,
          @schemaName, 1, @acv.a_mblock.mb_data^.mbp_4kbuf,
          vt_pos  + 2, move_len, acv.a_returncode);
    vt_pos := vt_pos + 1 + 1 + move_len;
    (* store schema context *)
    move_len := a061identifier_len (schemaContextName);
    acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos] := chr (move_len + 1);
    IF  g01unicode
    THEN
        acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos+1] := csp_unicode_def_byte
    ELSE
        acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos+1] := bsp_c1;
    (*ENDIF*) 
    SAPDB_PascalMove ('VAK15 ',  12,    
          sizeof (schemaContextName), acv.a_mblock.mb_data_size,
          @schemaContextName, 1, @acv.a_mblock.mb_data^.mbp_4kbuf,
          vt_pos  + 2, move_len, acv.a_returncode);
    vt_pos := vt_pos + 1 + 1 + move_len;
    IF  viewscanpar.vsc_save_into
    THEN
        BEGIN
        acv.a_mblock.mb_data^.mbp_4kbuf[ pos_errorcode ] := chr(0);
        s41plint (acv.a_mblock.mb_data^.mbp_4kbuf,
              pos_errorcode + 1, 4, 0, 0, res);
        acv.a_mblock.mb_data^.mbp_4kbuf[ pos_sqlcmd] := bsp_c1; (* PTS 1107988 *)
        acv.a_mblock.mb_data^.mbp_4kbuf[ pos_type  ] := bsp_c1; (* PTS 1110528 *)
        SAPDB_PascalMove ('VAK15 ',  13,    
              sizeof (tabletype), acv.a_mblock.mb_data_size,
              @tabletype, 1,
              @acv.a_mblock.mb_data^.mbp_4kbuf, pos_type + 1, sizeof(tabletype),
              acv.a_returncode);
        acv.a_mblock.mb_data^.mbp_4kbuf[ pos_tabletype] := bsp_c1;
        SAPDB_PascalMove ('VAK15 ',  14,    
              sizeof (tabletype), acv.a_mblock.mb_data_size,
              @tablekind, 1,
              @acv.a_mblock.mb_data^.mbp_4kbuf, pos_tabletype + 1, sizeof(tablekind),
              acv.a_returncode);
        (* END PTS 1110528 *)
        move_len := a061identifier_len (table_name);
        acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos] := chr (move_len + 1);
        IF  g01unicode
        THEN
            acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos + 1] := csp_unicode_def_byte
        ELSE
            acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos + 1] := bsp_c1;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK15 ',  15,    
              sizeof (table_name), acv.a_mblock.mb_data_size,
              @table_name, 1,
              @acv.a_mblock.mb_data^.mbp_4kbuf, vt_pos + 2, move_len,
              acv.a_returncode);
        vt_pos := vt_pos + 1 + 1 + move_len;
        maxlen := 254;
        END
    ELSE
        maxlen := MAX_RECLEN_GG00 - vt_pos - 1;
    (*ENDIF*) 
    (* PTS 1117815 M.Ki *)
    IF  g01unicode AND ((maxlen MOD 2) = 1)
    THEN
        maxlen := pred (maxlen);
    (*ENDIF*) 
    IF  command_type in [ create_view, grant, table_info ]
    THEN
        BEGIN
        viewtextkey           := a01defaultkey;
        viewtextkey.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
        viewtextkey.sentrytyp := cak_eviewtext;
        viewprivkey           := viewtextkey;
        viewprivkey.sentrytyp := cak_eprivuser;
        viewtextpos           := 1;
        END;
    (*ENDIF*) 
    REPEAT
        acv.a_cmd_part^.sp1p_buf_len := 0;
        add_command                  := false;
        IF  command_type in [create_view, grant, create_synonym] (* PTS 1107988 *)
        THEN
            acv.a_mblock.mb_data^.mbp_4kbuf[ pos_sqlcmd + 1 ] := 'Y'
        ELSE
            acv.a_mblock.mb_data^.mbp_4kbuf[ pos_sqlcmd + 1 ] := 'N';
        (*ENDIF*) 
        CASE command_type OF
            create_view :
                BEGIN
                REPEAT
                    a10get_sysinfo (acv, viewtextkey, d_release,
                          viewtextbuf, b_err);
                    IF  b_err = e_ok
                    THEN
                        WITH acv, a_mblock,
                             viewtextbuf^.sviewtext DO
                            BEGIN
                            IF  viewtextkey.slinkage = cak_init_linkage
                            THEN
                                BEGIN
                                mb_data^.mbp_4kbuf[pos_context  ] :=
                                      chr(0);
                                mb_data^.mbp_4kbuf[pos_context+1] :=
                                      chr(ord(vtcontext))
                                END;
                            (*ENDIF*) 
                            IF  acv.a_cmd_part^.sp1p_buf_len +
                                vttextlength >
                                acv.a_cmd_part^.sp1p_buf_size
                            THEN
                                b_err := e_too_small_packet_size
                            ELSE
                                BEGIN
                                SAPDB_PascalMove ('VAK15 ',  16,    
                                      sizeof (vttbuf),
                                      acv.a_cmd_part^.sp1p_buf_size,
                                      @vttbuf,
                                      vttabcount * mxak_vttabdef + 1,
                                      @acv.a_cmd_part^.sp1p_buf,
                                      acv.a_cmd_part^.sp1p_buf_len + 1,
                                      vttextlength, b_err);
                                acv.a_cmd_part^.sp1p_buf_len :=
                                      acv.a_cmd_part^.sp1p_buf_len +
                                      vttextlength;
                                IF  vtnextexist
                                THEN
                                    a06inc_linkage(viewtextkey.slinkage)
                                ELSE
                                    b_err := e_no_next_record
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                UNTIL
                    b_err <> e_ok;
                (*ENDREPEAT*) 
                IF  b_err <> e_no_next_record
                THEN
                    a07_b_put_error (acv, b_err, 1)
                ELSE
                    BEGIN
                    IF  is_systable
                    THEN
                        BEGIN
                        WHILE a01is_whitespace_char (acv.a_cmd_part^.sp1p_buf,
                              acv.a_cmd_part^.sp1p_buf_len - (a01char_size - 1)) DO
                            acv.a_cmd_part^.sp1p_buf_len :=
                                  acv.a_cmd_part^.sp1p_buf_len - a01char_size;
                        (*ENDWHILE*) 
                        (* PTS 1105418 G.G.*)
                        internal := a01kw[ cak_i_internal ];
                        len      := acv.a_cmd_part^.sp1p_buf_len;
                        pos      := 8 (* sizeof('INTERNAL') *);
                        WHILE pos > 0 DO
                            IF  a01equal_char (acv.a_cmd_part^.sp1p_buf,
                                len - (a01char_size - 1), internal[pos])
                            THEN
                                BEGIN
                                pos := pos - 1;
                                len := len - a01char_size;
                                END
                            ELSE
                                pos := c_exit_loop;
                            (*ENDIF*) 
                        (*ENDWHILE*) 
                        IF  ( pos = c_exit_loop ) OR
                            (( pos <> c_exit_loop) AND
                            ( NOT (
                            a01is_whitespace_char(acv.a_cmd_part^.sp1p_buf,
                            len - (a01char_size - 1) ) OR
                            ( acv.a_cmd_part^.sp1p_buf[ len ] = ')'  ) OR
                            ( acv.a_cmd_part^.sp1p_buf[ len ] = '"'  ) OR
                            ( acv.a_cmd_part^.sp1p_buf[ len ] = '''' ))))
                        THEN
                            BEGIN
                            a542char_to_packet (acv, bsp_c1);
                            a542move_to_packet (acv,
                                  @a01kw[cak_i_internal], 8)
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    b_err        := e_ok;
                    add_command  := true;
                    IF  viewscanpar.vsc_save_into
                    THEN
                        BEGIN
                        command_type := grant;
                        priv_mode    := all_priv;
                        END
                    ELSE
                        command_type := create_synonym;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            create_synonym :
                IF  (acv.a_internal_sql = sql_alter_table) OR
                    acv.a_p_arr2.pbasep^.ssynonym.syn_internal (* PTS 1109647 *)
                THEN
                    b_err := e_no_next_record
                ELSE
                    BEGIN
                    add_command := true;
                    ak15synonym_command (acv,
                          acv.a_p_arr2.pbasep^.ssynonym);
                    END;
                (*ENDIF*) 
            grant :
                ak15build_priv_command (acv,  viewscanpar.vsc_save_into,
                      acv.a_p_arr2.pbasep, viewprivkey, privbuf,
                      add_command, priv_mode, col_no, vt_pos, b_err);
            table_info :
                BEGIN
                ak15table_info (acv,
                      is_systable, unknown_sequence);
                command_type := grant;
                add_command  := true
                END;
            END;
        (*ENDCASE*) 
        IF  add_command
        THEN
            WITH acv, viewscanpar DO
                BEGIN
                vsc_cmd_cnt                  := succ(vsc_cmd_cnt);
                count                        := 0;
                acv.a_mblock.mb_data^.mbp_4kbuf[cgg_rec_key_offset+6]
                      := chr(0);
                s41plint (acv.a_mblock.mb_data^.mbp_4kbuf,
                      cgg_rec_key_offset+7, 6, 0, vsc_cmd_cnt, res);
                start_pos := 1;
                b_err     := e_ok;
                REPEAT
                    len := a_cmd_part^.sp1p_buf_len - start_pos + 1;
                    IF  len > maxlen
                    THEN
                        BEGIN
                        len := maxlen;
                        pos := start_pos + len - 1;
                        IF  g01unicode
                        THEN
                            (* PTS 1105437 GG *)
                            WHILE NOT(
                                  ((a_cmd_part^.sp1p_buf[pos ] in [ ',','.' ])
                                  OR
                                  (* PTS 1112747 E.Z. *)
                                  a01is_whitespace_char( a_cmd_part^.sp1p_buf,
                                  pos-1 ))
                                  AND
                                  (a_cmd_part^.sp1p_buf[pos-1] =
                                  csp_unicode_mark)) DO
                                BEGIN
                                pos := pos - 2;
                                len := len - 2
                                END
                            (*ENDWHILE*) 
                        ELSE
                            (* PTS 1105437 GG *)
                            WHILE NOT( (a_cmd_part^.sp1p_buf[pos]
                                  in [ ',','.' ]) OR
                                  a01is_whitespace_char( a_cmd_part^.sp1p_buf,
                                  pos ) ) DO
                                BEGIN
                                pos := pred(pos);
                                len := pred(len);
                                END;
                            (*ENDWHILE*) 
                        (*ENDIF*) 
                        (* PTS 1112747 E.Z. *)
                        IF  len = 0
                        THEN
                            len := maxlen;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    a06a_mblock_init (acv,
                          m_insert, mm_nil, vsc_into_treeid);
                    a_mblock.mb_data^.mbp_4kbuf[cgg_rec_key_offset+11]
                          := chr(0);
                    s41plint (a_mblock.mb_data^.mbp_4kbuf,
                          cgg_rec_key_offset+12,6,0,count,res);
                    IF  viewscanpar.vsc_save_into
                    THEN
                        BEGIN (* no of variable columns *)
                        a_mblock.mb_data^.mbp_rec.recVarcolOffset_gg00 := pos_owner - 1 -
                              cgg_rec_key_offset - save_scheme_keylen;
                        a_mblock.mb_data^.mbp_rec.recVarcolCnt_gg00 := 5;
                        a_mblock.mb_data^.mbp_4kbuf[vt_pos     ] :=
                              chr(len+1)
                        END;
                    (*ENDIF*) 
                    IF  g01unicode
                    THEN
                        a_mblock.mb_data^.mbp_4kbuf[vt_pos+1] :=
                              csp_unicode_def_byte
                    ELSE
                        a_mblock.mb_data^.mbp_4kbuf[vt_pos+1] :=
                              bsp_c1;
                    (*ENDIF*) 
                    SAPDB_PascalMove ('VAK15 ',  17,    
                          a_cmd_part^.sp1p_buf_size,
                          a_mblock.mb_data_size,
                          @a_cmd_part^.sp1p_buf, start_pos,
                          @a_mblock.mb_data^.mbp_4kbuf,
                          vt_pos + 2, len, b_err);
                    a_mblock.mb_data^.mbp_reclen :=
                          vt_pos + len + 1;
                    a_mblock.mb_data^.mbp_keylen :=
                          save_scheme_keylen;
                    a_mblock.mb_data_len         :=
                          vt_pos + len + 1;
                    IF  b_err = e_ok
                    THEN
                        IF  viewscanpar.vsc_save_into
                        THEN
                            a06rsend_mess_buf (acv, a_mblock,
                                  NOT cak_return_req, b_err)
                        ELSE
                            BEGIN
                            b07cadd_record (a_transinf.tri_trans,
                                  vsc_tree_id, a_mblock.mb_data^.mbp_rec);
                            b_err := a_transinf.tri_trans.trError_gg00
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    start_pos := start_pos + len;
                    count     := count + 10;
                UNTIL
                    (start_pos >= a_cmd_part^.sp1p_buf_len) OR
                    (b_err <> e_ok);
                (*ENDREPEAT*) 
                IF  (b_err = e_ok) AND
                    (command_type = create_synonym)
                THEN
                    b_err := e_no_next_record;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok);
    (*ENDREPEAT*) 
    IF  b_err <> e_no_next_record
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    a10release_table (acv, viewscanpar.vsc_usagedef.usa_tableid);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15synonym_command (
            VAR acv    : tak_all_command_glob;
            VAR synrec : tak_synonymrecord);
 
VAR
      b_err     : tgg00_BasisError;
      sysp      : tak_sysbufferaddress;
      owner     : tsp00_KnlIdentifier;
      sysk      : tgg00_SysInfoKey;
      p         : ^tsp00_KnlIdentifier;
 
BEGIN
WITH acv DO
    BEGIN
    sysk          := a01defaultkey;
    sysk.stableid := synrec.syn_tableid;
    a10get_sysinfo (acv, sysk, d_fix, sysp, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        a_cmd_part^.sp1p_buf_len := 0;
        a542move_to_packet       (acv, @a01kw[cak_i_create ], 7);
        IF  synrec.syn_authid = cak_public_id
        THEN
            a542move_to_packet (acv, @a01kw[cak_i_public], 7);
        (*ENDIF*) 
        a542move_to_packet       (acv, @a01kw[cak_i_synonym], 8);
        p := @synrec.syn_tablen;
        a542identifier_to_packet (acv, p^);
        a542char_to_packet       (acv, bsp_c1);
        a542move_to_packet       (acv, @a01kw[cak_i_for], 4);
        a06determine_username    (acv, sysp^.sbase.bauthid, owner);
        IF  owner = a01_il_b_identifier
        THEN
            a07ak_system_error (acv, 15, 2)
        ELSE
            BEGIN
            a542identifier_to_packet (acv, owner);
            a542char_to_packet       (acv, '.');
            a542identifier_to_packet (acv, sysp^.sbase.btablen^);
            a10_rel_sysinfo (acv, sysk)
            END;
        (*ENDIF*) 
        END
    ELSE
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15build_priv_command (
            VAR acv         : tak_all_command_glob;
            save_into       : boolean;
            base_ptr        : tak_sysbufferaddress;
            VAR viewprivkey : tgg00_SysInfoKey;
            VAR privbuf     : tak_sysbufferaddress;
            VAR add_command : boolean;
            VAR priv_mode   : tak15_priv_gen_mode;
            VAR col_no      : integer;
            VAR vt_pos      : integer;
            VAR b_err       : tgg00_BasisError);
 
VAR
      grant_option      : boolean;
      stop              : boolean;
      ix                : integer;
      move_len          : integer;
      grantor           : tsp00_KnlIdentifier;
      grantee           : tsp00_KnlIdentifier;
      schemaName        : tsp00_KnlIdentifier;
      schemaContextName : tsp00_KnlIdentifier;
      priv              : tak_privilege;
      save_buf_len      : integer;
 
BEGIN
a542move_to_packet (acv, @a01kw[cak_i_grant], 6);
save_buf_len := acv.a_cmd_part^.sp1p_buf_len;
IF  priv_mode = all_priv
THEN
    BEGIN
    col_no := 1;
    stop   := false;
    REPEAT
        a10next_sysinfo (acv, viewprivkey, SURROGATE_MXGG00+2, d_fix,
              cak_eprivuser, privbuf, b_err);
        IF  b_err = e_ok
        THEN
            IF  (privbuf^.syskey.stableid = base_ptr^.syskey.stableid)
            THEN
                BEGIN
                IF  privbuf^.syskey.suserid <> base_ptr^.sbase.bauthid
                THEN
                    stop := true
                (*ENDIF*) 
                END
            ELSE
                b_err := e_no_next_record;
            (*ENDIF*) 
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR stop
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    WITH acv DO
        BEGIN
        priv := a01emptypriv;
        a06unpack_priv (privbuf^.sprivuser.pru_priv, priv);
        a06determine_username (acv,
              privbuf^.syskey.sgrantuser, grantor);
        move_len := a061identifier_len (grantor);
        acv.a_mblock.mb_data^.mbp_4kbuf[pos_owner] := chr (move_len + 1);
        IF  g01unicode
        THEN
            acv.a_mblock.mb_data^.mbp_4kbuf[pos_owner+1] := csp_unicode_def_byte
        ELSE
            acv.a_mblock.mb_data^.mbp_4kbuf[pos_owner+1] := bsp_c1;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK15 ',  18,    
              sizeof (grantor), acv.a_mblock.mb_data_size,
              @grantor, 1, @acv.a_mblock.mb_data^.mbp_4kbuf,
              pos_owner  + 2, move_len,  acv.a_returncode);
        vt_pos := pos_owner + 1 + 1 + move_len;
        a103GetSchemaName     (acv, base_ptr^.sbase.bschema, schemaName);
        move_len := a061identifier_len (schemaName);
        acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos  ] := chr (move_len + 1);
        acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos+1] := acv.a_mblock.mb_data^.mbp_4kbuf[pos_owner+1];
        SAPDB_PascalMove ('VAK15 ',  19,    
              sizeof (schemaName), acv.a_mblock.mb_data_size,
              @schemaName, 1, @acv.a_mblock.mb_data^.mbp_4kbuf,
              vt_pos  + 2, move_len,  acv.a_returncode);
        vt_pos := vt_pos + 1 + 1 + move_len;
        a103GetSchemaName     (acv, base_ptr^.sbase.bschemacontext, schemaContextName);
        move_len := a061identifier_len (schemaContextName);
        acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos  ] := chr (move_len + 1);
        acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos+1] := acv.a_mblock.mb_data^.mbp_4kbuf[pos_owner+1];
        SAPDB_PascalMove ('VAK15 ',  20,    
              sizeof (schemaContextName), acv.a_mblock.mb_data_size,
              @schemaContextName, 1, @acv.a_mblock.mb_data^.mbp_4kbuf,
              vt_pos  + 2, move_len,  acv.a_returncode);
        vt_pos := vt_pos + 1 + 1 + move_len;
        IF  save_into
        THEN
            BEGIN
            move_len := a061identifier_len (base_ptr^.sbase.btablen^);
            acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos] := chr (move_len + 1);
            IF  g01unicode
            THEN
                acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos + 1] := csp_unicode_def_byte
            ELSE
                acv.a_mblock.mb_data^.mbp_4kbuf[vt_pos + 1] := bsp_c1;
            (*ENDIF*) 
            SAPDB_PascalMove ('VAK15 ',  21,    
                  sizeof (base_ptr^.sbase.btablen^),
                  acv.a_mblock.mb_data_size,
                  @base_ptr^.sbase.btablen^, 1,
                  @acv.a_mblock.mb_data^.mbp_4kbuf, vt_pos + 2, move_len,
                  acv.a_returncode);
            vt_pos := vt_pos + 1 + 1 + move_len
            END;
        (*ENDIF*) 
        acv.a_mblock.mb_data_len := vt_pos - 1;
        REPEAT
&           ifdef TRACE
            t01int4 (ak_sem, 'priv_mode = ', ord(priv_mode));
&           endif
            grant_option := (priv_mode = all_grant_priv) OR
                  (priv_mode = col_sel_grant_priv) OR
                  (priv_mode = col_upd_grant_priv);
            ak15put_privileges (acv, base_ptr, priv_mode,
                  priv, col_no, add_command);
            IF  add_command
            THEN
                BEGIN
                a542char_to_packet       (acv, bsp_c1);
                a542move_to_packet       (acv, @a01kw[cak_i_on], 3);
                a542identifier_to_packet (acv, schemaName);
                a542char_to_packet       (acv, '.');
                a542identifier_to_packet (acv, base_ptr^.sbase.btablen^);
                a542char_to_packet       (acv, bsp_c1);
                a542move_to_packet       (acv, @a01kw[cak_i_to], 3);
                a06determine_username    (acv,
                      privbuf^.syskey.suserid, grantee);
                a542identifier_to_packet (acv, grantee);
                IF  grant_option
                THEN
                    BEGIN
                    a542char_to_packet (acv, bsp_c1);
                    a542move_to_packet (acv, @a01kw[cak_i_with  ], 5);
                    a542move_to_packet (acv, @a01kw[cak_i_grant ], 6);
                    a542move_to_packet (acv, @a01kw[cak_i_option], 6)
                    END;
                (*ENDIF*) 
                END
            ELSE
                a_cmd_part^.sp1p_buf_len := save_buf_len;
            (*ENDIF*) 
        UNTIL
            (add_command) OR (priv_mode = next_priv);
        (*ENDREPEAT*) 
        IF  priv_mode = next_priv
        THEN
            priv_mode := all_priv;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15put_privileges (
            VAR acv         : tak_all_command_glob;
            base_ptr        : tak_sysbufferaddress;
            VAR priv_mode   : tak15_priv_gen_mode;
            VAR priv        : tak_privilege;
            VAR col_no      : integer;
            VAR add_command : boolean);
 
VAR
      kw_index  : integer;
      colptr    : tak00_colinfo_ptr;
      priv_set  : tak00_PrivilegeSet;
      colname   : tsp00_KnlIdentifier;
      colpriv   : tak_columnset;
 
BEGIN
&ifdef TRACE
t01int4 (ak_sem, 'priv_mode=  ', ord(priv_mode));
&endif
WITH acv DO
    CASE priv_mode OF
        all_priv, all_grant_priv :
            BEGIN
            IF  priv_mode = all_priv
            THEN
                priv_set := priv.priv_all_set
            ELSE
                priv_set := priv.priv_all_grant_set;
            (*ENDIF*) 
            priv_mode := succ(priv_mode);
            IF  priv_set <> [  ]
            THEN
                BEGIN
                add_command := true;
                IF  r_alter in priv_set
                THEN
                    BEGIN
                    a542move_to_packet (acv, @a01kw[cak_i_alter], 5);
                    a542char_to_packet (acv, ',')
                    END;
                (*ENDIF*) 
                IF  r_index in priv_set
                THEN
                    BEGIN
                    a542move_to_packet (acv, @a01kw[cak_i_index], 5);
                    a542char_to_packet (acv, ',')
                    END;
                (*ENDIF*) 
                IF  r_sel in priv_set
                THEN
                    BEGIN
                    a542move_to_packet (acv, @a01kw[cak_i_select], 6);
                    a542char_to_packet (acv, ',')
                    END;
                (*ENDIF*) 
                IF  r_ins in priv_set
                THEN
                    BEGIN
                    a542move_to_packet (acv, @a01kw[cak_i_insert], 6);
                    a542char_to_packet (acv, ',')
                    END;
                (*ENDIF*) 
                IF  r_upd in priv_set
                THEN
                    BEGIN
                    a542move_to_packet (acv, @a01kw[cak_i_update], 6);
                    a542char_to_packet (acv, ',')
                    END;
                (*ENDIF*) 
                IF  r_del in priv_set
                THEN
                    BEGIN
                    a542move_to_packet (acv, @a01kw[cak_i_delete], 6);
                    a542char_to_packet (acv, ',')
                    END;
                (*ENDIF*) 
                IF  r_link in priv_set
                THEN
                    BEGIN
                    a542move_to_packet (acv,
                          @a01kw[cak_i_references], 10);
                    a542char_to_packet (acv, ',')
                    END;
                (*ENDIF*) 
                col_no := 1;
                END;
            (*ENDIF*) 
            IF  g01unicode
            THEN
                a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len - 2
            ELSE
                a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len - 1
            (*ENDIF*) 
            END;
        col_upd_priv, col_upd_grant_priv,
        col_sel_priv, col_sel_grant_priv :
            BEGIN
            colpriv  := [  ];
            kw_index := cak_i_update;
            CASE priv_mode OF
                col_upd_priv :
                    IF  priv_col_upd in priv.priv_col_exist
                    THEN
                        colpriv := priv.priv_upd_set;
                    (*ENDIF*) 
                col_upd_grant_priv :
                    IF  priv_col_upd_grant in priv.priv_col_exist
                    THEN
                        colpriv := priv.priv_grant_upd_set;
                    (*ENDIF*) 
                col_sel_priv :
                    BEGIN
                    kw_index := cak_i_select;
                    IF  priv_col_sel in priv.priv_col_exist
                    THEN
                        colpriv := priv.priv_sel_set
                    (*ENDIF*) 
                    END;
                col_sel_grant_priv :
                    BEGIN
                    kw_index := cak_i_select;
                    IF  priv_col_sel_grant in priv.priv_col_exist
                    THEN
                        colpriv := priv.priv_grant_sel_set
                    (*ENDIF*) 
                    END;
                END;
            (*ENDCASE*) 
            add_command := colpriv <> [  ];
            a542move_to_packet (acv, @a01kw[kw_index], 6);
            a542char_to_packet (acv, '(');
            WHILE (col_no <= base_ptr^.sbase.bmaxcol) AND
                  (a_cmd_part^.sp1p_buf_len < sizeof (tsp00_Buf)) DO
                BEGIN
&               ifdef TRACE
                t01int4 (ak_sem, 'colno=      ',col_no);
&               endif
                IF  col_no in colpriv
                THEN
                    BEGIN
                    a06extcolno (base_ptr^.sbase, col_no, colptr);
                    WITH colptr^ DO
                        IF  NOT (ctdropped in ccolpropset) AND
                            NOT (ctinvisible in ccolpropset)
                        THEN
                            BEGIN
                            a061get_colname (colptr^, colname);
                            a542identifier_to_packet (acv,
                                  colname);
                            a542char_to_packet (acv, ',')
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END;
                (*ENDIF*) 
                col_no := col_no + 1;
                END;
            (*ENDWHILE*) 
            IF  col_no > base_ptr^.sbase.bmaxcol
            THEN
                BEGIN
                col_no := 1;
                priv_mode := succ (priv_mode);
                END;
            (*ENDIF*) 
            IF  g01unicode
            THEN
                a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len - 2
            ELSE
                a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len - 1;
            (*ENDIF*) 
            a542char_to_packet (acv, ')');
            END;
        OTHERWISE
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak15is_level1_catalog_tab (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob) : boolean;
 
CONST
      c_exit_loop = csp_maxint2;
 
VAR
      b_err        : tgg00_BasisError;
      ix           : integer;
      sysdd_tab_id : tsp00_C2;
      sysp         : tak_sysbufferaddress;
      sysk         : tgg00_SysInfoKey;
 
BEGIN
ak15is_level1_catalog_tab := false;
sysk                      := a41v.a4p_arr.pbasep^.syskey;
sysk.sentrytyp            := cak_eviewtext;
a10get_sysinfo (acv, sysk, d_release, sysp, b_err);
IF  b_err = e_ok
THEN
    WITH sysp^.sviewtext DO
        BEGIN
        ak15is_level1_catalog_tab := true;
        sysdd_tab_id := cak_show_table_site;
        ix := 1;
        WHILE ix <= vttabcount DO
            WITH vttab[ix] DO
                BEGIN
                IF  (vtttableid[1] <> sysdd_tab_id[1]) OR
                    (vtttableid[2] <> sysdd_tab_id[2])
                THEN
                    BEGIN
                    ix := c_exit_loop;
                    ak15is_level1_catalog_tab := false;
                    END
                ELSE
                    ix := ix + 1
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15table_info (
            VAR acv          : tak_all_command_glob;
            is_systable      : boolean;
            unknown_sequence : boolean);
 
VAR
      index_exist : boolean;
      info        : tsp00_C18;
 
BEGIN
acv.a_cmd_part^.sp1p_buf_len := 0;
a542move_to_packet (acv, @a01kw[cak_i_table], 6);
index_exist := acv.a_p_arr2.pbasep^.sbase.bindexexist;
IF  acv.a_p_arr2.pbasep^.sbase.btablekind = twithkey
THEN
    BEGIN
    info := ' + USERKEY        ';
    a542move_to_packet (acv, @info, 10)
    END;
(*ENDIF*) 
IF  index_exist
THEN
    BEGIN
    info := ' + INDEX          ';
    a542move_to_packet (acv, @info, 8)
    END;
(*ENDIF*) 
IF  [is_primary_table, unique_pk_table] *
    acv.a_p_arr2.pbasep^.sbase.blinkexist <> []
THEN
    BEGIN
    info := ' + PRIMARY KEY    ';
    a542move_to_packet (acv, @info, 14)
    END;
(*ENDIF*) 
IF  is_secondary_table in
    acv.a_p_arr2.pbasep^.sbase.blinkexist
THEN
    BEGIN
    info := ' + FOREIGN KEY    ';
    a542move_to_packet (acv, @info, 14)
    END;
(*ENDIF*) 
IF  acv.a_p_arr2.pbasep^.sbase.bnamed_constr > 0
THEN
    BEGIN
    info :=  ' + CONSTRAINT     ';
    a542move_to_packet (acv, @info, 13)
    END;
(*ENDIF*) 
IF  [del_trigger, ins_trigger, upd_trigger] *
    acv.a_p_arr2.pbasep^.sbase.blinkexist <> []
THEN
    BEGIN
    info := ' + TRIGGER        ';
    a542move_to_packet (acv, @info, 10)
    END;
(*ENDIF*) 
IF  acv.a_p_arr2.pbasep^.sbase.bsegmentid = cak00_public_segment_id
THEN
    BEGIN
    info := ' + REPLICATION    ';
    a542move_to_packet (acv, @info, 14)
    END;
(*ENDIF*) 
IF  is_systable
THEN
    BEGIN
    info := ' + INTERNAL       ';
    a542move_to_packet (acv, @info, 11)
    END;
(*ENDIF*) 
IF  unknown_sequence
THEN
    BEGIN
    info := ' + NO SEQUENCE    ';
    a542move_to_packet (acv, @info, 14)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15scan_foreign_key_tables (
            VAR acv           : tak_all_command_glob;
            VAR viewscanpar   : tak_save_viewscan_par;
            VAR pk_ptr        : tak_sysbufferaddress;
            VAR wantedSchema  : tgg00_Surrogate;
            VAR top_sort_tree : tgg00_FileId;
            VAR fk_found      : boolean);
 
VAR
      ok        : boolean;
      doEnter   : boolean;
      b_err     : tgg00_BasisError;
      sysp      : tak_sysbufferaddress;
      index     : integer;
      scanned   : integer;
      count     : integer;
      succ_cnt  : integer;
      fk_ptr    : tak_sysbufferaddress;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
succ_cnt       := 0;
sysk           := pk_ptr^.syskey;
sysk.sentrytyp := cak_eprimarykey;
count          := cak_is_undefined;
index          := 1;
scanned        := 0;
fk_found       := false;
REPEAT
    a10get_sysinfo (acv, sysk, d_release, sysp, b_err);
    IF  b_err = e_ok
    THEN
        WITH sysp^.slink, linkdef[index] DO
            BEGIN
            IF  count = cak_is_undefined
            THEN
                count := linkcount;
            (*ENDIF*) 
            scanned := scanned + 1;
            a06_systable_get (acv, d_fix, ltableid,
                  fk_ptr, false, ok);
            IF  ok
            THEN
                WITH fk_ptr^, sbase, viewscanpar DO
                    BEGIN
                    doEnter := false;
                    IF  vsc_user_save
                    THEN
                        BEGIN
                        doEnter := bauthid = acv.a_curr_user_id
                        END
                    ELSE
                        IF  vsc_schema_save
                        THEN
                            BEGIN
                            doEnter :=  bschema = wantedSchema;
                            END
                        ELSE
                            doEnter := true;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  doEnter AND (ltableid <> sysk.stableid)
                    THEN
                        BEGIN
                        fk_found := true;
                        ak15enter_succ_list (acv, top_sort_tree,
                              pk_ptr, fk_ptr)
                        END;
                    (*ENDIF*) 
                    a10_rel_sysinfo (acv, fk_ptr^.syskey)
                    END
                (*ENDWITH*) 
            ELSE
                a07ak_system_error (acv, 15, 4);
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    ELSE
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    index := index + 1;
    IF  index > cak_maxlinkdef
    THEN
        BEGIN
        index := 1;
        a06inc_linkage (sysk.slinkage)
        END;
    (*ENDIF*) 
UNTIL
    (acv.a_returncode <> 0) OR (scanned = count);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15enter_succ_list (
            VAR acv           : tak_all_command_glob;
            VAR top_sort_tree : tgg00_FileId;
            VAR pk_ptr        : tak_sysbufferaddress;
            VAR fk_ptr        : tak_sysbufferaddress);
 
VAR
      rec : tak15_top_sort_info;
 
BEGIN
WITH acv, rec, rec_buf DO
    BEGIN
    rec.pk_tabid         := pk_ptr^.syskey.stableid;
    rec.fk_tabid         := fk_ptr^.syskey.stableid;
    recKeyLen_gg00       :=  2 * SURROGATE_MXGG00;
    recLen_gg00          := cgg_rec_key_offset + recKeyLen_gg00;
    recVarcolOffset_gg00 := 0;
    recVarcolCnt_gg00    := 0;
    ak15add_top_sort_tree (acv, top_sort_tree, rec.rec_buf);
    IF  a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        BEGIN
        ak15enter_tab_list (acv, top_sort_tree, pk_ptr, 0, rec);
        IF  a_returncode = 0
        THEN
            ak15inc_pred_cnt (acv, top_sort_tree, fk_ptr, rec);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (a_transinf.tri_trans.trError_gg00 <> e_ok) AND
        (a_transinf.tri_trans.trError_gg00 <> e_duplicate_key)
    THEN
        a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15foreign_tab_enter (
            VAR acv           : tak_all_command_glob;
            VAR top_sort_tree : tgg00_FileId;
            base_ptr          : tak_sysbufferaddress);
 
VAR
      rec : tak15_top_sort_info;
 
BEGIN
ak15enter_tab_list (acv, top_sort_tree, base_ptr, 0, rec)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15enter_tab_list (
            VAR acv           : tak_all_command_glob;
            VAR top_sort_tree : tgg00_FileId;
            base_ptr          : tak_sysbufferaddress;
            predcnt           : integer;
            VAR rec           : tak15_top_sort_info);
 
BEGIN
WITH acv, rec, rec_buf DO
    BEGIN
    mask                 := cgg_nil_session;
    rec.tabid            := base_ptr^.syskey.stableid;
    tabsite              := cgg_zero_c2;
    pred_cnt             := predcnt;
    recKeyLen_gg00       := mxsp_c4 + SURROGATE_MXGG00;
    recLen_gg00          := cgg_rec_key_offset + keylen + 2 + 4;
    recVarcolOffset_gg00 := recLen_gg00 - cgg_rec_key_offset - recKeyLen_gg00;
    recVarcolCnt_gg00    := 0;
    ak15add_top_sort_tree (acv, top_sort_tree, rec.rec_buf);
    IF  (a_transinf.tri_trans.trError_gg00 <> e_ok) AND
        (a_transinf.tri_trans.trError_gg00 <> e_duplicate_key)
    THEN
        a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15dec_pred_cnt (
            VAR acv           : tak_all_command_glob;
            VAR top_sort_tree : tgg00_FileId;
            VAR rec           : tak15_top_sort_info;
            VAR pred_cnt      : integer);
 
VAR
      tableid : tgg00_Surrogate;
 
BEGIN
tableid            := rec.fk_tabid;
rec.mask           := cgg_nil_session;
rec.tabid          := tableid;
rec.rec_buf.keylen := mxsp_c4 + SURROGATE_MXGG00;
b07cget_record (acv.a_transinf.tri_trans,
      top_sort_tree, rec.rec_buf, rec.rec_buf);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    rec.pred_cnt := rec.pred_cnt - 1;
    pred_cnt     := rec.pred_cnt;
    b07crepl_record (acv.a_transinf.tri_trans,
          top_sort_tree, rec.rec_buf)
    END;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15inc_pred_cnt (
            VAR acv           : tak_all_command_glob;
            VAR top_sort_tree : tgg00_FileId;
            base_ptr          : tak_sysbufferaddress;
            VAR rec           : tak15_top_sort_info);
 
BEGIN
WITH acv, rec, rec_buf DO
    BEGIN
    mask   := cgg_nil_session;
    tabid  := base_ptr^.syskey.stableid;
    keylen := mxsp_c4 + SURROGATE_MXGG00;
    b07cget_record (a_transinf.tri_trans,
          top_sort_tree, rec.rec_buf, rec.rec_buf);
    IF  a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        BEGIN
        pred_cnt := pred_cnt + 1;
        b07crepl_record (a_transinf.tri_trans,
              top_sort_tree, rec.rec_buf)
        END
    ELSE
        IF  a_transinf.tri_trans.trError_gg00 = e_key_not_found
        THEN
            ak15enter_tab_list (acv, top_sort_tree,
                  base_ptr, 1, rec)
        ELSE
            a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15add_top_sort_tree (
            VAR acv           : tak_all_command_glob;
            VAR top_sort_tree : tgg00_FileId;
            VAR rec_buf       : tgg00_Rec);
 
BEGIN
IF  top_sort_tree.fileRoot_gg00 = NIL_PAGE_NO_GG00
THEN
    BEGIN
    top_sort_tree             := acv.a_intern_res_tree;
    a101_CreateGroupedTempFile (acv.a_transinf.tri_trans, top_sort_tree,
          ttfnSaveScheme_egg00)
    END;
(*ENDIF*) 
b07cadd_record (acv.a_transinf.tri_trans,
      top_sort_tree, rec_buf)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15top_sort (
            VAR acv           : tak_all_command_glob;
            VAR viewscanpar   : tak_save_viewscan_par;
            VAR top_sort_tree : tgg00_FileId);
 
CONST
      c_non_pred_tables = true;
 
VAR
      next_err   : tgg00_BasisError;
      prev_key   : integer;
      tabid      : tgg00_Surrogate;
 
      prevkey    : RECORD
            CASE boolean OF
                true  :
                    (lkey : tgg00_Lkey);
                false :
                    (reclen    : tsp00_Int2;
                    keyLen     : tsp00_Int2;
                    keyvaroff  : tsp00_Int2;
                    keyvarcnt  : tsp00_Int2;
                    int4       : tsp00_C4);
                END;
            (*ENDCASE*) 
 
      tps : tak15_top_sort_record;
 
BEGIN
IF  top_sort_tree.fileRoot_gg00 <> NIL_PAGE_NO_GG00
THEN
    BEGIN
    tps.tps_queue_cnt                   := 0;
    tps.tps_queue_tree                  := acv.a_intern_res_tree;
    tps.tps_queue_tree.fileRoot_gg00    := NIL_PAGE_NO_GG00;
    a101_CreateGroupedTempFile (acv.a_transinf.tri_trans, tps.tps_queue_tree,
          ttfnLink_egg00);
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        BEGIN
        ak15non_pred_tables (acv, viewscanpar,
              c_non_pred_tables, top_sort_tree, tps);
        prev_key := 0;
        REPEAT
            prevkey.lkey.len          := 4;
            prev_key                  := prev_key + 1;
            s20int4_to_buf_swap (prev_key, g01code.kernel_swap,
                  prevkey.int4, 1, sw_normal);
            tps.tps_set_result.bd_max_rec_cnt := 1;
            tps.tps_tree_pos.tpsPno_gg00            := NIL_PAGE_NO_GG00;
            b07cnext_record (acv.a_transinf.tri_trans,
                  tps.tps_queue_tree,
                  prevkey.lkey, tps.tps_set_result, tps.tps_tree_pos,
                  acv.a_mblock.mb_data^.mbp_4kbuf);
            next_err := acv.a_transinf.tri_trans.trError_gg00;
            IF  (next_err = e_ok           ) OR
                (next_err = e_key_not_found)
            THEN
                BEGIN
                next_err         := e_ok;
                prevkey.lkey.len := acv.a_mblock.mb_data^.mbp_keylen;
                SAPDB_PascalMove ('VAK15 ',  22,    
                      acv.a_mblock.mb_data_size,
                      sizeof (tabid), @acv.a_mblock.mb_data^.mbp_4kbuf,
                      cgg_rec_key_offset + 5, @tabid, 1, sizeof (tabid),
                      next_err);
                ak15scan_succ_list (acv,
                      viewscanpar, tabid, top_sort_tree, tps)
                END;
            (*ENDIF*) 
        UNTIL
            (next_err <> e_ok) OR
            (acv.a_returncode <> 0);
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        ak15non_pred_tables (acv, viewscanpar,
              NOT c_non_pred_tables, top_sort_tree, tps);
    (*ENDIF*) 
    IF  top_sort_tree.fileRoot_gg00 <> NIL_PAGE_NO_GG00
    THEN
        a101_DestroyGroupedTempFile (acv.a_transinf.tri_trans, top_sort_tree);
    (*ENDIF*) 
    IF  tps.tps_queue_tree.fileRoot_gg00 <> NIL_PAGE_NO_GG00
    THEN
        a101_DestroyGroupedTempFile (acv.a_transinf.tri_trans,
              tps.tps_queue_tree)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15non_pred_tables (
            VAR acv           : tak_all_command_glob;
            VAR viewscanpar   : tak_save_viewscan_par;
            non_pred_tables   : boolean;
            VAR top_sort_tree : tgg00_FileId;
            VAR tps           : tak15_top_sort_record);
 
VAR
      rec_len  : tsp_int_map_c2;
      next_err : tgg00_BasisError;
      ix       : integer;
      prevkey  : tgg00_Lkey;
 
BEGIN
(* find tables without predecessor, enter them into result queue *)
prevkey.len := 4;
FOR ix := 1 TO prevkey.len DO
    prevkey.k[ix] := chr(255);
(*ENDFOR*) 
tps.tps_tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
WITH tps.tps_set_result DO
    BEGIN
    bd_key_check_len:= 0;
    bd_max_rec_cnt  := csp_maxint2;
    bd_max_fill_len := sizeof (acv.a_mblock.mb_data^.mbp_4kbuf);
    bd_next         := false;
    END;
(*ENDWITH*) 
next_err := e_buffer_limit;
WHILE next_err = e_buffer_limit DO
    BEGIN
    b07cnext_record (acv.a_transinf.tri_trans, top_sort_tree,
          prevkey, tps.tps_set_result, tps.tps_tree_pos,
          acv.a_mblock.mb_data^.mbp_4kbuf);
    next_err := acv.a_transinf.tri_trans.trError_gg00;
    IF  (next_err = e_ok           ) OR
        (next_err = e_key_not_found) OR
        (next_err = e_buffer_limit )
    THEN
        BEGIN
        tps.tps_pos := 1;
        WHILE (tps.tps_pos < tps.tps_set_result.bd_fill_len) AND
              (acv.a_returncode = 0) DO
            BEGIN
            rec_len.map_c2[1] :=
                  acv.a_mblock.mb_data^.mbp_4kbuf[tps.tps_pos  ];
            rec_len.map_c2[2] :=
                  acv.a_mblock.mb_data^.mbp_4kbuf[tps.tps_pos+1];
            SAPDB_PascalMove ('VAK15 ',  23,    
                  acv.a_mblock.mb_data_size,
                  sizeof (tps.tps_rec.rec_buf.buf),
                  @acv.a_mblock.mb_data^.mbp_4kbuf, tps.tps_pos,
                  @tps.tps_rec.rec_buf.buf, 1, rec_len.map_int,
                  acv.a_returncode);
            tps.tps_pos := tps.tps_pos + rec_len.map_int;
            IF  (non_pred_tables AND
                (tps.tps_rec.pred_cnt = 0)) OR
                (NOT non_pred_tables AND
                (tps.tps_rec.pred_cnt <> 0))
            THEN
                (* table has no predecessor *)
                (* or could not be sorted   *)
                ak15enter_tab_into_res (acv, viewscanpar,
                      NOT non_pred_tables, tps)
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  next_err <> e_buffer_limit
        THEN
            next_err := e_no_next_record
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15enter_tab_into_res (
            VAR acv           : tak_all_command_glob;
            VAR viewscanpar   : tak_save_viewscan_par;
            unknown_sequence  : boolean;
            VAR tps           : tak15_top_sort_record);
 
VAR
      ok : boolean;
 
BEGIN
tps.tps_rec.rec_buf.recLen_gg00 :=
      cgg_rec_key_offset + tps.tps_rec.rec_buf.recKeyLen_gg00;
tps.tps_rec.rec_buf.recVarcolOffset_gg00 := 0;
tps.tps_rec.rec_buf.recVarcolCnt_gg00    := 0;
tps.tps_queue_cnt := tps.tps_queue_cnt + 1;
s20int4_to_buf_swap (tps.tps_queue_cnt, g01code.kernel_swap,
      tps.tps_rec.mask, 1, sw_normal);
b07cadd_record (acv.a_transinf.tri_trans,
      tps.tps_queue_tree, tps.tps_rec.rec_buf);
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv,
          acv.a_transinf.tri_trans.trError_gg00, 1)
ELSE
    WITH viewscanpar DO
        BEGIN
&       ifdef trace
        t01moveobj (ak_sem, acv.a_mblock.mb_data^.mbp_buf, 1,
              tps.tps_set_result.bd_fill_len);
        t01int4 (ak_sem, 'tps.tps_pos ', tps.tps_pos);
&       endif
        vsc_base_tabid  := tps.tps_rec.tabid;
        SAPDB_PascalMove ('VAK15 ',  24,    
              acv.a_mblock.mb_data_size,
              sizeof (tps.tps_rec.rec_buf.buf),
              @acv.a_mblock.mb_data^.mbp_4kbuf, tps.tps_pos,
              @tps.tps_rec.rec_buf.buf, tps.tps_pos,
              tps.tps_set_result.bd_fill_len - tps.tps_pos + 1,
              acv.a_returncode);
        vsc_usagedef.usa_tableid   := vsc_base_tabid;
        vsc_usagedef.usa_tablekind := twithkey;
        (* PTS 1116837 E.Z. *)
        vsc_usagedef.usa_filler    := 0;
        vsc_usagedef.usa_empty     := false;
        vsc_type                   := v_save_scheme;
        vsc_col_dropped            := false;
        a15one_table_catalog (acv, 0,
              unknown_sequence, viewscanpar);
        IF  NOT vsc_user_save AND NOT vsc_schema_save (* PTS 1134748 *)
        THEN
            BEGIN
            a06_systable_get (acv, d_fix, vsc_base_tabid,
                  acv.a_p_arr1.pbasep, true, ok);
            IF  ok
            THEN
                BEGIN
                a27view_scan (acv, vsc_base_tabid, viewscanpar);
                a10_rel_sysinfo (acv, acv.a_p_arr1.pbasep^.syskey);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK15 ',  25,    
              sizeof (tps.tps_rec.rec_buf.buf),
              acv.a_mblock.mb_data_size,
              @tps.tps_rec.rec_buf.buf, tps.tps_pos,
              @acv.a_mblock.mb_data^.mbp_4kbuf, tps.tps_pos,
              tps.tps_set_result.bd_fill_len - tps.tps_pos + 1,
              acv.a_returncode)
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15scan_succ_list (
            VAR acv           : tak_all_command_glob;
            VAR viewscanpar   : tak_save_viewscan_par;
            VAR prev_tabid    : tgg00_Surrogate;
            VAR top_sort_tree : tgg00_FileId;
            VAR tps           : tak15_top_sort_record);
 
VAR
      b_err     : tgg00_BasisError;
      rec_len   : tsp_int_map_c2;
      pred_cnt  : integer;
      ix        : integer;
      prevkey   : tgg00_Lkey;
 
BEGIN
tps.tps_set_result.bd_max_rec_cnt := csp_maxint2;
tps.tps_tree_pos.tpsPno_gg00            := NIL_PAGE_NO_GG00;
prevkey.len                       := SURROGATE_MXGG00;
FOR ix := 1 TO sizeof(prev_tabid) DO
    prevkey.k[ix] := prev_tabid[ix];
(*ENDFOR*) 
REPEAT
    b07cnext_record (acv.a_transinf.tri_trans,
          top_sort_tree, prevkey, tps.tps_set_result, tps.tps_tree_pos,
          acv.a_mblock.mb_data^.mbp_4kbuf);
    b_err := acv.a_transinf.tri_trans.trError_gg00;
    IF  (b_err = e_ok           ) OR
        (b_err = e_key_not_found) OR
        (b_err = e_buffer_limit )
    THEN
        BEGIN
        tps.tps_pos := 1;
        WHILE (tps.tps_pos < tps.tps_set_result.bd_fill_len) AND
              (acv.a_returncode = 0) DO
            BEGIN
            rec_len.map_c2[1] :=
                  acv.a_mblock.mb_data^.mbp_4kbuf[tps.tps_pos  ];
            rec_len.map_c2[2] :=
                  acv.a_mblock.mb_data^.mbp_4kbuf[tps.tps_pos+1];
            SAPDB_PascalMove ('VAK15 ',  26,    
                  acv.a_mblock.mb_data_size,
                  sizeof (tps.tps_rec.rec_buf.buf),
                  @acv.a_mblock.mb_data^.mbp_4kbuf, tps.tps_pos,
                  @tps.tps_rec.rec_buf.buf, 1, rec_len.map_int,
                  acv.a_returncode);
            IF  tps.tps_rec.pk_tabid <> prev_tabid
            THEN
                BEGIN (* end of current list *)
                b_err       := e_no_next_record;
                tps.tps_pos := csp_maxint2
                END
            ELSE
                BEGIN
                pred_cnt := 12;
                (* just to avoid warnings: uninitialized pred_cnt *)
                tps.tps_pos := tps.tps_pos + rec_len.map_int;
                ak15dec_pred_cnt (acv, top_sort_tree,
                      tps.tps_rec, pred_cnt);
                IF  pred_cnt = 0
                THEN
                    ak15enter_tab_into_res (acv, viewscanpar,
                          NOT c_unknown_sequence, tps);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  b_err <> e_buffer_limit
        THEN
            b_err := e_no_next_record
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    b_err <> e_buffer_limit;
(*ENDREPEAT*) 
IF  b_err <> e_no_next_record
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak15store_table (
            VAR acv     : tak_all_command_glob;
            VAR baserec : tak_baserecord);
 
VAR
      syn_p : ^tak_synonymrecord;
      site  : tgg00_ServerdbNo;
 
BEGIN
WITH acv, a_mblock, mb_data^, baserec DO
    BEGIN
    mbp_rec.info[1] := chr (1);
    SAPDB_PascalForcedMove (sizeof (bsurrogate), mb_data_size,
          @bsurrogate, 1, @mbp_4kbuf, cgg_rec_key_offset + 2,
          sizeof (bsurrogate));
    mbp_keylen := 1 + SURROGATE_MXGG00;
    IF  btablekind = tsynonym
    THEN
        syn_p := @baserec;
    (*ENDIF*) 
    site := cgg_zero_c2;
    mbp_rec.info[1+SURROGATE_MXGG00+1] := site[1];
    mbp_rec.info[1+SURROGATE_MXGG00+2] := site[2];
    mbp_reclen := cgg_rec_key_offset + mbp_keylen + mxsp_c2;
    mbp_varcol_offset := 2;
    mbp_varcol_cnt    := 0;
    b07cadd_record (a_transinf.tri_trans, a_into_tree, mbp_rec);
    IF  a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
