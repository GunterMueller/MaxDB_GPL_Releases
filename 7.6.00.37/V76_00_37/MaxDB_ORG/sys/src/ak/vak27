.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-16
*****************************************************
modname : VAK27
changed : 2000-11-16
module  : AK_VIEW_SCAN
 
Author  : ThomasA
Created : 1987-09-22
*****************************************************
 
Purpose : Modifizieren der Systeminformationen von abhaengigen
          Views und Synonymen.
 
Define  :
 
        PROCEDURE
              a27init_viewscanpar (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_viewscan_par;
                    v_type          : tak_viewscantype);
 
        PROCEDURE
              a27ModifyAppendSchemas (
                    VAR acv     : tak_all_command_glob;
                    viewtextbuf : tak_sysbufferaddress;
                    viewdescbuf : tak_sysbufferaddress);
 
        PROCEDURE
              a27rename_user (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_viewscan_par);
 
        PROCEDURE
              a27substitute_synonyms (
                    VAR acv     : tak_all_command_glob;
                    viewtextbuf : tak_sysbufferaddress;
                    viewdescbuf : tak_sysbufferaddress);
 
        PROCEDURE
              a27view_scan   (
                    VAR acv         : tak_all_command_glob;
                    VAR tableid     : tgg00_Surrogate;
                    VAR viewscanpar : tak_viewscan_par);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              AK_distributor : VAK35;
 
        PROCEDURE
              a35_asql_statement (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_data_dictionary : VAK38;
 
        PROCEDURE
              a38column_drop (
                    VAR acv         : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR schemaName  : tsp00_KnlIdentifier;
                    VAR table_name  : tsp00_KnlIdentifier;
                    VAR column_name : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Comment : VAK26;
 
        PROCEDURE
              a26drop_comment (
                    VAR acv      : tak_all_command_glob;
                    comment_type : tak_comment_type;
                    VAR id1      : tgg00_Surrogate;
                    VAR id2      : tgg00_Surrogate;
                    colno        : integer);
 
      ------------------------------ 
 
        FROM
              AK_Grant_Revoke : VAK22;
 
        PROCEDURE
              a22add_priv_rec (
                    VAR acv         : tak_all_command_glob;
                    base_ptr        : tak_sysbufferaddress;
                    VAR new_priv    : tak_privilege;
                    priv_buf        : tak_sysbufferaddress;
                    add_sysinfo     : boolean;
                    VAR revoke_casc : boolean);
 
        PROCEDURE
              a22revoke_cascade (
                    VAR acv         : tak_all_command_glob;
                    base_ptr        : tak_sysbufferaddress;
                    VAR all_col_set : tak_columnset;
                    rev_user        : tgg00_Surrogate;
                    VAR rev_priv    : tak_privilege);
 
      ------------------------------ 
 
        FROM
              AK_View_semantic : VAK16;
 
        PROCEDURE
              a16constraint_check (
                    VAR acv      : tak_all_command_glob;
                    VAR view_rec : tak_baserecord;
                    qualbuf      : tak_sysbufferaddress);
 
        PROCEDURE
              a16new_bextcolindex (VAR base_rec : tak_baserecord);
 
        PROCEDURE
              a16privrec_build (
                    VAR acv      : tak_all_command_glob;
                    view_ptr     : tak_sysbufferaddress;
                    VAR base_ptr : tak_sysbufferaddress;
                    viewtextbuf  : tak_sysbufferaddress;
                    qualbuf      : tak_sysbufferaddress;
                    VAR viewpriv : tak_privilege;
                    release      : boolean);
 
      ------------------------------ 
 
        FROM
              AK_save_scheme : VAK15;
 
        PROCEDURE
              a15one_table_catalog (
                    VAR acv          : tak_all_command_glob;
                    viewlevel_cnt    : integer;
                    unknown_sequence : boolean;
                    VAR viewscanpar  : tak_viewscan_par);
 
      ------------------------------ 
 
        FROM
              AK_Alter_Table : VAK13;
 
        PROCEDURE
              a13repl_priv_column   (
                    VAR acv       : tak_all_command_glob;
                    base_ptr      : tak_sysbufferaddress;
                    VAR extcolset : tak_columnset);
 
        PROCEDURE
              a13add_dropped_columns (
                    VAR acv         : tak_all_command_glob;
                    view_level      : integer;
                    VAR viewscanpar : tak_viewscan_par);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10_copy_catalog_rec (
                    VAR acv         : tak_all_command_glob;
                    VAR old_key     : tgg00_SysInfoKey;
                    del_old_rec     : boolean;
                    VAR new_key     : tgg00_SysInfoKey;
                    new_segment_id  : tsp00_C2;
                    add_new_rec     : boolean;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              a10release_table (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    dstate     : tak_directory_state;
                    syslen     : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate (* ptocConst *);
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06extcolno (
                    VAR baserec  : tak_baserecord;
                    extcolno     : integer;
                    VAR col_ptr  : tak00_colinfo_ptr);
 
        PROCEDURE
              a06user_get_priv  (
                    VAR acv  : tak_all_command_glob;
                    VAR brec : tak_sysbufferaddress;
                    VAR user : tgg00_Surrogate;
                    VAR priv : tak_privilege);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        PROCEDURE
              a06unpack_priv (
                    VAR packed_priv   : tak_privilege;
                    VAR unpacked_priv : tak_privilege);
&       IFDEF TRACE
 
        PROCEDURE
              a06td_priv (
                    p        : tak_privilege;
                    id       : tsp00_C18;
                    unpacked : boolean);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061app_columnname (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    VAR column            : tsp00_KnlIdentifier;
                    VAR index             : integer);
 
        PROCEDURE
              a061copy_colinfo (
                    VAR src_col : tak00_columninfo;
                    VAR dst_col : tak00_columninfo);
 
        FUNCTION
              a061exist_columnname (
                    VAR base_rec    : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
        PROCEDURE
              a061sort (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    last_used_expr_no     : integer;
                    VAR duplicate_column  : boolean;
                    VAR duplicate_colname : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05put_identifier (
                    VAR id      : tsp00_KnlIdentifier;
                    VAR moveobj : tsp00_MoveObj;
                    moveobj_size: tsp00_Int4;
                    VAR pos     : tsp00_Int4;
                    VAR retcode : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01char_size         : integer;
              a01defaultkey        : tgg00_SysInfoKey;
              a01emptypriv         : tak_privilege;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
              a01_i_current_schema : tsp00_KnlIdentifier;
              a01_i_user           : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        FUNCTION
              a01equal_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    cmp_char : char) : boolean;
 
        FUNCTION
              a01is_identifier (
                    VAR identifier  : tsp00_KnlIdentifier;
                    len             : integer;
                    sqlmode         : tsp00_SqlMode) : boolean;
 
        FUNCTION
              a01is_whitespace_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv     : tak_all_command_glob;
                    b_err       : tgg00_BasisError;
                    err_code    : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11drop_table  (
                    VAR acv       : tak_all_command_glob;
                    VAR tableid   : tgg00_Surrogate;
                    tablart       : tgg00_TableKind;
                    succ_filevers : boolean);
 
        PROCEDURE
              a11put_date_time (
                    VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
        PROCEDURE
              a11sort (VAR base_rec : tak_baserecord);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_InvalidateListAppend (
                    VAR acv       : tak_all_command_glob;
                    VAR SchemaId  : tgg00_Surrogate;
                    VAR Tablename : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542char_to_packet (
                    VAR acv : tak_all_command_glob;
                    c       : char);
 
        PROCEDURE
              a542fill_packet (
                    VAR acv     : tak_all_command_glob;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              a542identifier_to_packet (
                    VAR acv         : tak_all_command_glob;
                    VAR identifier  : tsp00_KnlIdentifier);
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542pop_packet (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a542release_packet (
                    VAR acv  : tak_all_command_glob;
                    segm_ptr : tsp1_segment_ptr);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1  : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
        PROCEDURE
              b01empty_file (
                    VAR t       : tgg00_TransContext;
                    VAR current : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cadd_record (
                    VAR t    : tgg00_TransContext;
                    VAR curr : tgg00_FileId;
                    VAR b    : tgg00_Rec);
 
        PROCEDURE
              b07cget_record (
                    VAR t    : tgg00_TransContext;
                    VAR curr : tgg00_FileId;
                    VAR rk   : tgg00_Lkey;
                    VAR b    : tgg00_Rec);
 
        PROCEDURE
              b07cdel_record (
                    VAR t           : tgg00_TransContext;
                    VAR act_tree_id : tgg00_FileId;
                    VAR rk          : tgg00_Lkey);
 
        PROCEDURE
              b07crepl_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01unicode        : boolean;
 
        FUNCTION
              g01packet_size : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Syntax-tree-Printer  : VAK99;
 
        VAR
              a99blankline : tsp00_Line;
 
      ------------------------------ 
 
        FROM
              Test_Procedures  : VTA01;
 
        PROCEDURE
              t01line (debug : tgg00_Debug;
                    VAR ln : tsp00_Line);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01tabid (
                    layer     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01p4int4 (
                    layer : tgg00_Debug;
                    nam   : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    int_2 : tsp00_Int4;
                    int_3 : tsp00_Int4;
                    int_4 : tsp00_Int4);
 
        PROCEDURE
              t01moveobj  (
                    layer   : tgg00_Debug;
                    VAR buf : tsp00_MoveObj;
                    startpos: tsp00_Int4;
                    endpos  : tsp00_Int4);
 
        PROCEDURE
              t01buf1 (
                    layer   : tgg00_Debug;
                    VAR buf : tak_systembuffer;
                    startpos: integer;
                    endpos  : integer);
 
        PROCEDURE
              t01stackentry (
                    layer       : tgg00_Debug;
                    VAR st      : tgg00_StackEntry;
                    entry_index : integer);
 
        PROCEDURE
              t01lidentifier (
                    layer      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
&       endif
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30klen (
                    VAR str : tsp00_KnlIdentifier;
                    val     : char; cnt : integer) : integer;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
&       ifdef TRACE
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tak_systembuffer
&             endif
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              a15one_table_catalog;
 
              tak_save_viewscan_par tak_viewscan_par
 
        PROCEDURE
              a01is_identifier;
 
              tsp00_MoveObj tsp00_KnlIdentifier;
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj   tsp00_KnlIdentifier
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
 
.pa
.fo
The module makes available the procedure a27view_scan. The procedure must be
called whenever, through a DDL command on a table or view x, it is also
necessary to modify the catalog information of the views and synonyms dependent
on x.
.br
A DDL command on a table or view always means that either the file version of
the table or that of a base table of the view is increased. For this reason,
the initial table for a27view_scan is always a base table and at least the file
version is updated in all views dependent on this base table. Depending on the
type of DDL command used, it may be necessary for further modifications to be
performed in the catalog information of the views and synonyms. The information
required by a27view_scan is passed in a parameter viewscan_par, which has the
following record structure:
.sp;.nf
      viewscan_par = RECORD
            vsc_baseauthid    : user_id;
            vsc_basetablen    : name;
            vsc_filevers      : int2;
            vsc_key           : tsysinfokey;
            vsc_buf           : tsysbufferaddress;
            vsc_tabno         : integer;
            vsc_type          : viewscantype;
            vsc_delete_view   : boolean;
            vsc_filler        : boolean;
            vsc_modified      : boolean;
            vsc_from_authid   : user_id;
            vsc_from_tablen   : name;
            vsc_col_list      : boolean;
            vsc_col_dropped   : boolean;
            vsc_p_arr         : tsyspointerarr;
            vsc_viewtbuf      : tsysbufferaddress;
            vsc_viewdescbuf   : tsysbufferaddress;
            CASE viewscantype OF
                 v_statistics    :
                      (vsc_page_cnt_info : upd_stat_info);
                 v_alter_drop, v_revoke_priv :
                      (vsc_drop_set     : tcolumnset;
                      vsc_rev_authid    : user_id;
                      vsc_rev_tablen    : name;
                      vsc_start_revoke  : boolean;
                      vsc_dr_col        : tdropcol;
                      vsc_valid_cols    : tcolindex;
                      vsc_valid_cnt     : integer;
                      vsc_extcol_set    : tcolumnset;
                      vsc_qualbuf       : tsysbufferaddress;
                      vsc_privbuf       : tsysbufferaddress;
                      vsc_rev_user      : user_id;
                      vsc_userkind      : usertyp);
                 v_index :
                      (vsc_index_info : tiviewreplcolinfo);
                 v_rename_column :
                      (vsc_rename_set  : tcolumnset;
                      vsc_info_cnt     : integer;
                      vsc_pos_info     : tcolinteger;
                      vsc_newcolname   : name;
                      vsc_newcol_len   : integer;
                      vsc_oldcolname   : name;
                      vsc_oldcol_len   : integer;
                      vsc_colbuf       : tsysbufferaddress;
                      vsc_colind       : integer;
                      vsc_renamed      : boolean;
                      vsc_renamed_cols : integer;
                      vsc_col_in_qual  : boolean);
                 v_rename_table :
                      (vsc_dummy_set  : tcolumnset;
                      vsc_new_authid  : user_id;
                      vsc_old_tablen  : name;
                      vsc_ren_started : boolean;
                      vsc_new_tablen  : name;
                      vsc_old_len     : integer;
                      vsc_new_len     : integer);
                 v_save_scheme, v_intern_save_scheme :
                      (vsc_filename   : univ_fn;
                      vsc_tree_id     : tree_id;
                      vsc_into_authid : user_id;
                      vsc_into_tablen : name;
                      vsc_save_into   : boolean;
                      vsc_tablekind   : ttablekind;
                      vsc_cmd_cnt     : integer;
                      vsc_location    : location);
                 END;
.sp;.fo
When the procedure is called, there need not be any entries in the components
vsc_base_authid, vsc_basetablen, vsc_key, vsc_buf, vsc_tabno, vsc_delete_view,
vsc_modified, vsc_from_authid, vsc_from_tablen, vsc_col_list, vsc_p_arr,
vsc_viewtbuf, vsc_viewdescbuf, because these entries are made in the course of
a27view_scan. When the procedure is called, entries must have been made as
follows in the following components:
.sp;.nf
vsc_filevers    : File version of the initial table.
vsc_type        : Description of the initiating DDL command
                  v_version : only the file version has been
                  increased.
v_alter_drop    : Deletion of columns from the initial table.
v_index         : Creation/deletion of an index in the initial
                  table.
v_rename_column : Renaming of a column.
v_rename_table  : Renaming of a table.
v_save_schema   : Save Schema
v_revoke_priv   : Revocation of a privilege.
vsc_col_dropped : TRUE if information regarding deleted/
                  renamed columns is in the Into file;
                  otherwise FALSE.
.fo
.CM *-END-* specification -------------------------------
***********************************************************
 
Description:
 
 
 
PROCEDURE  A27VIEW_SCAN
-----------------------------------------------------------
 
Parameter : VAR acv         : all_command_glob;
            VAR auth        : user_id;
            VAR tabl        : name;
            VAR viewscanpar : viewscan_par;
 
The procedure performs all modifications in the catalog of all views
and synonyms that become necessary through the modification of a base table or
view. The following modifications make it necessary to call a27view_scan:
 
  i)    Renaming of a table
  ii)   Renaming of a column
  iii)  Revocation of a privilege
  iv)   Creation or deletion of an index
  v)    Save Scheme
  vi)   Creation or deletion of a link
  vii)  Update Statistics
  viii) Increasing of the file version
 
The determination of all dependent views and synonyms always proceeds from the
base table auth.tabl. By calling the recursive procedure ak27view_scan, all
relevant views and synonyms are determined and the modifications dependent on
the reason for the call are performed in the catalog. In the course
of processing, use is made in the renaming or deleting of columns or in the
revocation of privileges of the Into file, with the result that the latter must
be deleted again at the end.
 
PROCEDURE  AK27BASE_REC_HANDLING
-----------------------------------------------------------
 
Parameter : VAR acv         : all_command_glob;
            VAR usagedef    : tusagedef;
            VAR viewscanpar : viewscan_par;
 
The procedure is required in order to perform in the catalog descriptions of
type tbaserecord the modifications that have become necessary through DDL
activities in a table/view on which the view usa_authid.usa_tablen is based.
 
For this purpose, the tbaserecord(s) of the view are first of all loaded into
the cache. The file version is updated in any case.
 
If the procedure has been called as the result of an update statistics command,
the current date and the time are recorded in the first tbaserecord. In
addition, in all columns of the view that reference indexed columns of the
corresponding base table, the index page count cspages is set to the
corresponding value from the vsc_page_cnt_info.
 
If the procedure has been called as a result of a create or drop index command,
the index flag in the relevant column descriptions is set or reset by the
calling of ==> ak27ci_repl_index_in_view_col.
 
 
If columns of a view/table on which the view is based have been deleted
(vsc_col_dropped = TRUE), it may be necessary to delete columns in the view.
This is then done in the procedure ==> ak27dc_col_in_view_drop.
 
If the procedure has been called as the result of a rename column command, it
may be necessary to rename a column of the view. This is then done in the
procedure ak27rc_rename_in_base_rec.
 
The base records either then have their final appearance, or it has been found
that the view usa_authid.usa_tablen must be deleted. In the former case, the
tbaserecords are written back to system file 1.
 
PROCEDURE  AK27CI_ANALYZE_QUAL
-----------------------------------------------------------
 
Parameter : VAR acv         : all_command_glob;
            VAR qual        : tviewqualrecord;
            VAR usagedef    : tusagedef;
            VAR viewscanpar : viewscan_par;
 
The procedure checks whether the column of a base table described by
vsc_index_info is referenced by the qualification of the view
usa_authid.usa_tablen. If this is the case, the index flag (ecol_tab[ 2 ]) of
the corresponding stack entry of the qualification is set to the corresponding
value of the column description. After the qualification has been processed,
==> ak27base_rec_handling is called in order to update the index information
and the file version in the tbaserecords of the view.
 
FUNCTION  AK27CI_EQUAL_STACKENTRIES
-----------------------------------------------------------
 
Parameter : VAR qual_stack_entry  : stack_entry;
            VAR base_stack_entry  : stack_entry;
            tabno                 : integer;
 
The function returns TRUE if the stack entries qual_stack_entry and
base_stack_entry describe the same column of the table tabno; otherwise FALSE.
 
PROCEDURE  AK27CI_REPL_INDEX_IN_VIEW_COL
-----------------------------------------------------------
 
Parameter : VAR viewscanpar : viewscan_par;
            VAR col_info    : tcolumninfo;
 
If a column of the base table described in vsc_index_info is referenced by the
column described by col_info, the index flags in ccolpropset are brought to the
status of the ccolpropset of the base table with regard to the index
information.
 
PROCEDURE  AK27DC_COL_IN_VIEW_DROP
-----------------------------------------------------------
 
Parameter : VAR acv         : all_command_glob;
            VAR viewscanpar : viewscan_par;
 
In the view whose tbaserecords are allocated in the cache (vsc_p_arr), the
columns described by vsc_drop_set must be marked as deleted. It is therefore
checked for each column of the view whether the external column number is
contained in the vsc_drop_set. If this is the case, the number of deleted
columns is incremented, this number is used to form a new unique column name,
the column is marked as deleted, and the column is removed from the sets of the
mandatory columns (bmantoryset) and default columns. In the case of a complex
view, the column positions of all columns lying after the deleted column must
be reduced by the length of the deleted column (==> ak27new_complex_view_pos).
 
In vsc_valid_cols, an entry is made in the image current valid column number --
> external column number. This image is later required in order to be able to
remove the columns from the view definition strings.
 
In rest_col, the number of still visible columns is counted. If this number is
= 0 at the end, the view must be deleted. Otherwise, the column descriptions in
the tbaserecords must, if necessary, be sorted again according to the column
names and the deleted columns must be deleted from all privilege system
descriptions of the view.
 
PROCEDURE  AK27DC_DROP_COL
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR usagedef      : tusagedef
            viewlevel_cnt     : integer;
            low_level_dropped : boolean;
            VAR viewscanpar   : viewscan_par;
 
At least one column of the table/view forming the basis of view
usa_authid.usa_tablen has been deleted. The procedure now checks whether,
because of this, it is also necessary for columns of the view or the entire
view to be deleted. This decision is taken by the procedure
ak27dcrc_analyze_columns.
 
If the view need not be deleted, ak27base_rec_handling marks as deleted in the
tbaserecords of the view all the columns that are to be deleted and updates the
version number. If the view is a join view, ak27qual_handling is then called in
order to update the version number in the tqualrecord of the view.
 
A27_dc_viewtext_drop then ensures that the deleted columns are removed from the
view definition strings.
 
PROCEDURE  A27_DC_VIEWTEXT_DROP
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR usagedef      : tusagedef
            viewlevel_cnt     : integer;
            low_level_dropped : boolean;
            VAR viewscanpar   : viewscan_par;
 
The procedure deletes definitions of view columns from the view  definition
string of view usa_authid.usa_tablen. The column numbers of the view column
definitions that are to be removed are in vsc_extcol_set.
 
The view definition string is first of all transferred from the tviewtextrecords
of the view to the variab_part of the acv.command (==>
ak27viewtext_into_messbuf). If the column names of the view have been defined
by means of column-names list (name1, name2, .. ], the columns to be removed
are first of all deleted in this part. For this purpose, a search is made first
of all for '(' and, proceeding from here, a search is made in a loop for the
next comma. At the same time, a column counter is kept, so that it can be
decided whether the column name currently under consideration has to be
removed. If this is the case, the column name is removed and the column-
position information in the tviewdescrecord of the view is updated (==>
ak27new_view_pos_info). This method is used until ')' is found.
 
In any case, the column definitions in the Select List of the view must be
deleted. In a loop, the position of the respective column to be deleted in
variab_part is determined by a27_get_col_pos. Proceeding from this position, a
search is made to the left for the beginning and to the right for the end of
the column definition and the corresponding part in variab_part is removed.
Then, the column-position information in the tviewdescrecords of the view is
updated (==> ak27new_view_pos_info). If the position found is = 0, but the
column was nevertheless found in the tviewdescrecord, the column was defined by
means of '*'. In this case, the information regarding the column in
tviewdescrecord is removed without changing the position information.
 
If the view-definition string has been changed, the variab_part is transferred
back to tviewtextrecords and is written back to the system file. If only one
column has been deleted without changing the view-definition string ('*'
definition), only one update of the tviewdescrecord is performed.
 
PROCEDURE  A27_DCRC_VIEWTEXT_DROP
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR usagedef      : tusagedef
            viewlevel_cnt     : integer;
            low_level_dropped : boolean;
            VAR viewscanpar   : viewscan_par;
 
The procedure decides which columns of the view usa_authid.usa_atablen must be
deleted or renamed because columns of a base table/view have been deleted or
renamed. If deleted columns of the base table/view occur in the qualification
of usa_authid.usa_tablen or if usa_authid.usa_tablen no longer has any visible
columns after the deletion of the columns, usa_authid.usa_tablen must be
deleted.
 
First of all, the catalog information of type tviewtext is allocated in the
cache. If table/view columns have been deleted or renamed in the base
table/view, the external column numbers of these columns are read from the
Into_File and the catalog record of type tviewdescrecord is allocated in
the cache. By means of a27_test_columns, the columns of the view
usa_authid.usa_tablen that are to be deleted or renamed are determined and are
stored in vsc_drop_set. If the procedure has been called as a result of the
renaming of a column, the procedure ak27rc_rename_columns_in_view takes care of
any necessary renaming of the column in usa_authid.usa_tablen. If columns have
been deleted or renamed in usa_authid.usa_tablen, the external column numbers
of these columns are stored in the Into_File; otherwise, the request type
vsc_typ is set to v_version, which means that, in the views dependent
on_authid.usa_tablen, only the version number is updated.
 
PROCEDURE  AK27DEL_DROPCOL_INFO
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            level_cnt         : integer;
 
Information on deleted or renamed columns is deleted in the Into file. The key
is formed from level_cnt.
 
PROCEDURE  A27_DEL_DROPCOL_INFO
-----------------------------------------------------------
 
Parameter : viewdescbuf       : tsysbufferaddress;
            extcolno          : integer;
            VAR pos           : integer;
            VAR found         : boolean;
 
A search is made in its tviewdescrecord for the description of the column with
external column number extconlo of the current view. If the description is
found, found is set to TRUE and the position of the associated column
definition in the view-definition string is returned in pos. If pos = 0 and
found= TRUE, this means that the column has been defined by means of '*".
 
PROCEDURE  AK27NEW_COMPLEX_VIEW_POS
-----------------------------------------------------------
 
Parameter : VAR p_arr         : tsyspointerarr;
            inoutlen          : integer;
            extcolno          : integer;
 
In a complex view, the column with external column number extcolno has been
marked as deleted. Since complex views are always built in select, the starting
position of the following columns in the result records is reduced by the
length of the deleted column. This is entered in the corresponding stack
entries.
 
PROCEDURE  AK27NEW_VIEW_POS_INFO
-----------------------------------------------------------
 
Parameter : VAR p_arr         : tsyspointerarr;
            drop_col_no       : integer;
            start_pos         : integer;
            offset            : integer;
 
Through the deletion of a column or the renaming of a column or table, column-
position information in the tviewdescrecords must be updated. This relates to
the column information whose position is greater than startpos. The position is
increased by offset.
 
PROCEDURE  AK27NEW_VIEW_POS_INFO
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR viewscanpar   : viewscan_par;
            VAR usage_index   : int2;
            VAR seqno         : int2;
            VAR b_err         : basis_error;
 
Proceeding from usage_index, the next dependent view/synonym to be handled is
determined in the catalog information of type tusagerecord of the table/view
under consideration in a27_view_scan. If a tusage entry is found that describes
a complex view, the view need be processed only if the procedure has been
called as the result of a SAVE SCHEMA, RENAME COLUMN, REVOKE PRIVILEGE, RENAME
TABLE or DROP COLUMN command. If a tusage entry is found that describes a
synonym, this synonym need be processed only if the procedure has been called
as a result of a SAVE SCHEMA, REVOKE PRIVILEGE or RENAME TABLE command. Views
of type tonebase or tview must be processed in all cases. If an entry that is
to be processed has been found, b_err = is_more_files is returned and the index
found in tusage_record is returned in usage_index.
 
If, during the search for a view that is to be processed, the end of the
tusagerecord is reached, a distinction must be made between two cases:
 .br
i)@@If a follow-up tusagerecord exists, b_buffer_limit is returned in b_err,
which means that, in a27_view_scan, the follow-up tusagerecord is loaded into
the cache and a27_next_usage_record is then called with usage_index = 0.
 
ii)@If no follow-up tusagerecord exists, b_key_not_found is returned in b_err,
which leads in a27_view_scan to the termination of the recursion.
 
PROCEDURE  AK27QUAL_HANDLING
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR usagedef      : tusagedef;
            VAR viewscanpar   : viewscan_par;
 
The procedure loads the catalog information of type tviewqual of view
usa_authid.usa_tablen into the cache and searches for the initial table
usc_baseauthid.vsc_basetablen in the vtab part of the record. The file version
is updated for each entry that is found. The modified tviewqualrecord is
written back to the system file. In the case of the revocation of a privilege,
vsc_qualbuf is set to the cache address of the record; otherwise the record is
released in the cache.
 
PROCEDURE  AK27RC_RENAME_IN_BASE_REC
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR viewscanpar   : viewscan_par;
 
It is checked whether, in the view specified by vsc_p_arr, a column has to be
renamed because a column has been renamed in the base table/view.
 
A corresponding column may be renamed only if the column name has been
implicitly specified in the view definition. This is the case only if neither
bv_viewlist is TRUE nor ctviewname is in the ccolpropset of the relevant
column.
 
 
PROCEDURE  A27_RENAME_IN_VARIABPART
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR viewscanpar   : viewscan_par;
            pos               : integer;
            old_len           : integer;
            VAR new_name      : name;
            new_len           : integer;
            VAR diff          : integer;
 
In the variab_part of the SQL_PACKET, a text of length old_len beginning at
position pos is replaced by new_name of length new_len. Depending on diff, the
text following the text that has been replaced must be shifted either to the
left or to the right. If diff <> 0, the position information in the associated
tviewdescrecord is updated by ak27new_view_pos_info.
 
PROCEDURE  A27_RP_HANDLING
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR usagedef      : tusagedef;
            viewlevel         : integer;
            low_level_dropped : boolean;
            VAR viewscanpar   : viewscan_par;
 
The procedure handles the view usa_authid.usa_tablen in the case of the
revocation of a privilege. First of all, it is checked which catalog information
alterations have to be made. Since a27view_scan is called for a base table also
in cases where a privilege is revoked on a view, it is possible that the
current view is not at all based on the view on which privileges have been
revoked. In this case (vsc_start_revoke = FALSE), therefore, only the version
number needs to be updated.
 
In the other case (vsc_start_revoke = TRUE), it is possible that, through the
revocation of the privileges, columns of the view must be deleted and that
there is an alteration to the privileges of the view with regard to the owner.
If usa_authid.usa_tablen is a synonym, it must be checked whether the owner of
the synonym still has a privilege on the table/view. If this is not the case,
the synonym must be deleted (vsc_delete_view = TRUE).
 
If usa_authid.usa_tablen is a view, it must be checked first of all whether
something may have changed in the characteristics of the view. If this is the
case (check_table = TRUE), by means of a27_dc_drop_col, those columns are
removed from the view that must no longer be visible to the owner of the view
because of the revocation of the select privilege. It may also be found that
the view has to be deleted.
 
If this is not the case, the privilege of the owner of the view is re-
determined by a27_rp_revoke_privilege.
 
PROCEDURE  A27_RP_NEW_PRIVREC
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR view_arr      : tsyspointer_arr;
            VAR viewscanpar   : viewscan_par;
 
The privilege record of the owner of the view specified by view_arr is re-built
in the cache. For this purpose, as in the creation of the view, the
corresponding procedures from VAK16 are used. If the new privilege record
differs from the old one, the old one is replaced by the new one in the cache.
 
PROCEDURE  A27_RP_REVOKE_PRIVILEGE
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR usagedef      : tusagedef;
            VAR view_arr      : tsyspointerarr;
            VAR viewscanpar   : viewscan_par;
 
The privilege of the owner of the view specified by view usa_authid.usa_tablen
is determined with regard to this view. For this purpose, first of all, the
privilege record of the owner of the view specified by view_arr is loaded into
the cache. The variables current_auth_id as well as current_name are, for this
purpose, set to the owner of the view, so that the privilege checks in
a27_rp_new_priv_record are performed for the owner of the view. At the end of
the procedure, this conversion must be cancelled again.
 
PROCEDURE  A27_RT_ANALYZE_COL_DEFINITIONS
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR viewscanpar   : viewscan_par;
            tabno             : integer;
 
The procedure checks whether columns of the renamed table specified by tabno
occur in the view-definition string of the view usa_authid.usa_tablen in the
form <tablename>.<columnname>. In this case, the table name must in each case
be replaced by the new table name. The positions of the relevant columns are
determined from the tviewdescrecord of the view. Then it is checked whether
there is a '.' in front of the column name. If this is the case, the table name
that has been found is compared with the old table name. This comparison is
necessary, because reference names may occur. If they are identical, the old
table name is replaced by the new one (a27_rename_in_variabpart).
 
PROCEDURE  A27_RT_HANDLING
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR usagedef      : tusagedef;
            VAR viewscanpar   : viewscan_par;
 
The table usa_authid.usa_tablen is dependent on a base table that has been
renamed. If usa_authid.usa_tablen is a synonym, the renaming is performed in
the tsynonymrecord by a27_rt_synonym_rename.
 
If usa_authid.usa_tablen is a view that references only one base table
(tonebase), then bv_tablen as well as the file version must be updated in the
tbaserecords of the view. If usa_authid.usa_tablen is a view, the view-
definition string (a27_rt_tabletext_rename) and the catalog information
of type tviewqual (a27_rt_ren_in_qual_rec) must be updated.
 
PROCEDURE  A27_RT_REN_IN_QUAL_REC
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR view_authid   : user_id;
            VAR view_tablen   : name;
            VAR view_loc      : location;
            VAR viewscanpar   : viewscan_par;
 
The table vsc_baseauthid.vsc_basetablen, which is referenced by the view
view_authid.view_tablen has been renamed. The procedure updates the table name
and the file version in the system information of type tviewqual of
view_authid.view_tablen.
 
PROCEDURE  A27_RT_SYNONYM_RENAME
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR usagedef      : tusagedef;
            VAR viewscanpar   : viewscan_par;
 
The table vsc_baseauthid.vsc_basetablen, which is referenced by the synonym
usa_authid.usa_tablen, has been renamed. The renaming of the base table is
performed in the catalog information of type tsynonymrecord.
 
PROCEDURE  A27_RT_TABLETEXT_RENAME
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR view_authid   : user_id;
            VAR view_tablen   : name;
            VAR view_location : location;
            VAR viewscanpar   : viewscan_par;
 
The table vsc_baseauthid.vsc_basetablen, which is referenced by the view
view_authid.view_tablen, has been renamed. If the table name occurs in the
view-definition string of the view, each occurrence is replaced by the new
table name.
 
Whether the table name occurs in the FROM part of the view is checked with the
aid of the catalog record of type tviewtext. If the name is found, the
position in the variab_part is given by vtttab_n_pos and the old table name in
the FROM part is replaced by the new one by a27_rename_in_variabpart. Then, the
table name is renamed in all column definitions of form
<tablename>.<columnname> by a27_rt_analyze_col_definitions.
 
The modified variab_part is then converted again into catalog information of
type tviewtext by ak27view_definition_to_sysinfo.
 
PROCEDURE  AK27VIEW_DEFINITION_TO_SYSINFO
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR viewscanpar   : viewscan_par;
            bufcnt            : integer;
            loc               : location;
 
A view-definition string that is stored
in the message_buffer of the acv is
inserted again into catalog information of type tviewtext. The view-definition
string has been transferred by means of ak27viewtext_into_messbuf from the
catalog to the variab_part and may then have been shortened or
lengthened. bufcnt specifies the number of tviewtextrecords that have been
found in the ak27viewtext_into_messbuf. If the string length has increased,
more tviewtextrecords than bufcnt may be necessary - conversely, if the string
has been shortened, fewer tviewtextrecords than bufcnt may be necessary - to
transfer the string to the catalog, i.e. the superfluous
tviewtextrecords must in this case be deleted.
 
PROCEDURE  A27_TEST_COLUMNS
-----------------------------------------------------------
 
Parameter : VAR viewscanpar   : viewscan_par;
            tabno             : integer;
            VAR from_col_set  : tcolumnset;
            VAR col_count     : integer;
 
Through the renaming or deletion of columns of a table, it may be necessary to
delete or to rename columns in the current dependent view, too, or even to
delete the entire view. This is determined by the procedure. When the procedure
is called, the catalog information of type tviewtextrecord and tviewdescrecord
of the dependent view has already been allocated in the cache. Tabno specifies
the table under consideration in the FROM part of the view. The external column
numbers of the deleted or renamed columns are in from_col_set. For each of
these columns, it is now checked whether it is referenced by the view. This is
the case if an entry with this external column number is found in
tviewdescrecord. If the associated external column number = 0, the column
occurs in the qualification of the view and the view must be deleted if the
referenced column has been deleted. If the view need not be deleted, the
external column numbers of the columns that are to be deleted or renamed in the
view are subsequently in vsc_drop_set.
 
FUNCTION  AK27UNIQUE : BOOLEAN
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR usagedef      : tusagedef;
 
By means of the procedure, it is checked in a27view_scan whether the view
usa_authid.usa_tablen is occurring for the first time in the course or the
recursion. Only in this case need the view be  considered in save schema. The
check for uniqueness is implemented by insertion of the view name into the Into
file (b_duplicate_key ==> view has already been handled).
 
PROCEDURE AK27VIEW_SCAN
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            auth              : user_id;
            tabl              : name;
            viewlevel_cnt     : integer;
            VAR viewscanpar   : viewscan_par;
 
This recursive procedure forms the main procedure of the module. All
views/synonyms dependent on the table/view auth.tabl are determined and the
modifications, dependent on request type vsc_type, to the catalog information of
the dependent views/synonyms are performed. The synonyms/views that are
directly dependent on auth.tabl are determined by means of the catalog
information of type tusagerecord of the table. The next table to be handled
(view or synonym) is determined by the procedure ak27next_usage_entry.
Depending on the reason for the call (vsc_type), the necessary catalog
modifications for this view are performed.
 
If it is found that the table must be deleted, the table is deleted by
a11drop_table together with all views and synonyms dependent on it.
 
Otherwise, the procedure ak27view_scan is called for the current dependent
table, as a result of which all views and synonyms dependent on the dependent
table are handled.
 
PROCEDURE A27_VIEWTEXT_TO_SQLPACKET
-----------------------------------------------------------
 
Parameter : VAR acv           : all_command_glob;
            VAR viewauth      : user_id;
            VAR viewtabl      : name;
            viewloc           : location;
            VAR viewscanpar   : viewscan_par;
            VAR bufcnt        : integer;
 
The view-definition string of the view viewauth.viewtabl is transferred from
the catalog information of type tviewtextrecord to the variab_part of the
SQL_PACKET. The number of tviewtextrecords that have been read is specified in
bufcnt.
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_no_col_drop             = MAX_COL_PER_TAB_GG00 + 1;
      c_get_all                 = true;
      c_release_internal_packet = true; (* a542internal_packet *)
 
TYPE
      tak27_call_reason = (
            vtalter_table_drop,
            vtrename_column,
            vtrename_table,
            vtrename_user,
            vtrename_view,
            vtrename_view_column);
      (**)
      tak27_vdesc_sc_reason = (
            sc_inc_1,
            sc_get_pos,
            sc_new_pos,
            sc_test_columns);
 
      tak27_vdesc_scan_record = RECORD
            CASE sc_reason : tak27_vdesc_sc_reason OF
                sc_inc_1 :
                    (sc_index       : integer);
                sc_get_pos :
                    (sc_pos         : integer;
                    sc_extcolno     : integer;
                    sc_found        : boolean);
                sc_new_pos :
                    (sc_drop_col    : integer;
                    sc_startpos     : integer;
                    sc_offset       : integer);
                sc_test_columns :
                    (sc_tabno       : integer;
                    sc_colcnt       : integer;
                    sc_from_col_set : tak_columnset);
                END;
            (*ENDCASE*) 
 
 
      tak27_own_tab_col_info = RECORD
            otc_own_pos : integer;
            otc_tab_pos : integer;
            otc_col_pos : integer;
      END;
 
 
 
(*------------------------------*) 
 
PROCEDURE
      a27view_scan   (
            VAR acv         : tak_all_command_glob;
            VAR tableid     : tgg00_Surrogate;
            VAR viewscanpar : tak_viewscan_par);
 
VAR
      _empty_file : boolean;
 
BEGIN
_empty_file := false;
IF  acv.a_returncode = 0
THEN
    BEGIN
    _empty_file := ( viewscanpar.vsc_type = v_alter_drop ) OR
          ( viewscanpar.vsc_type = v_revoke_priv )         OR
          ( viewscanpar.vsc_type = v_rename_column );
    IF  viewscanpar.vsc_type <> v_alter_drop
    THEN
        (* possible: vak13 set vsc_type = v_alter_drop, *)
        (* vsc_init_type = v_version                    *)
        viewscanpar.vsc_init_type := viewscanpar.vsc_type;
    (*ENDIF*) 
    viewscanpar.vsc_mult_index  := acv.a_p_arr1.pbasep^.sbase.bindexexist;
    viewscanpar.vsc_rows        := acv.a_p_arr1.pbasep^.sbase.brows;
    viewscanpar.vsc_base_tabid  := tableid;
    END;
(*ENDIF*) 
ak27view_scan( acv, tableid, 1, viewscanpar );
IF  _empty_file
THEN
    b01empty_file( acv.a_transinf.tri_trans, acv.a_into_tree );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27add_column_list (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            rename_colno    : integer);
 
VAR
      _ok                   : boolean;
      _ix                   : integer;
      _col_ptr              : tak00_colinfo_ptr;
      _pos                  : integer;
      _ti                   : integer;
      _init_cmd_part        : tsp1_part_ptr;
      _col_list_part        : tsp1_part_ptr;
      _init_cmd_part_header : tsp1_part_header;
      _col_name             : tsp00_KnlIdentifier;
      _buf                  : tsp00_Buf;
 
BEGIN
a06_systable_get( acv, d_release, viewscanpar.vsc_usagedef.usa_tableid,
      acv.a_p_arr2.pbasep, c_get_all, _ok );
IF  NOT ( _ok )
THEN
    a07ak_system_error( acv, 27, 2 )
ELSE
    BEGIN
    _init_cmd_part             := acv.a_cmd_part;
    _init_cmd_part_header      := acv.a_cmd_part^.sp1p_part_header;
    _col_list_part             := @_buf;
    acv.a_cmd_part                := _col_list_part;
    acv.a_cmd_part^.sp1p_buf_size :=
          sizeof( _buf ) - sizeof( acv.a_cmd_part^.sp1p_part_header );
    acv.a_cmd_part^.sp1p_buf_len  := 0;
    a542char_to_packet( acv, '(');
    FOR _ix := 1 TO acv.a_p_arr2.pbasep^.sbase.bmaxcol DO
        BEGIN
        a06extcolno( acv.a_p_arr2.pbasep^.sbase, _ix, _col_ptr );
        WITH _col_ptr^ DO
            IF  NOT ( ctinvisible in ccolpropset ) AND
                NOT ( ctdropped   in ccolpropset )
            THEN
                BEGIN
                IF  _ix > 1
                THEN
                    a542char_to_packet( acv, ',');
                (*ENDIF*) 
                IF  _ix = rename_colno
                THEN
                    _col_name := viewscanpar.vsc_newcolname
                ELSE
                    a061get_colname( _col_ptr^, _col_name );
                (*ENDIF*) 
                a542identifier_to_packet( acv, _col_name )
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        END;
    (*ENDFOR*) 
    a542char_to_packet( acv, ')');
    a542char_to_packet( acv, bsp_c1 );
&   ifdef trace
    t01moveobj( ak_sem, _col_list_part^.sp1p_buf,
          1, _col_list_part^.sp1p_buf_len );
&   endif
    acv.a_cmd_part                   := _init_cmd_part;
    acv.a_cmd_part^.sp1p_part_header := _init_cmd_part_header;
    IF  acv.a_cmd_part^.sp1p_buf_len + _col_list_part^.sp1p_buf_len >
        acv.a_cmd_part^.sp1p_buf_size
    THEN
        a07_b_put_error( acv, e_too_small_packet_size, 1 )
    ELSE
        BEGIN
        acv.a_p_arr2.pbasep^.sbase.bv_viewlist := true;
        _ti := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
        WITH acv.a_ap_tree^[ _ti ] DO
            IF  n_symb = s_authid
            THEN
                _ti := n_sa_level;
            (* _ti points to view name now *)
            (*ENDIF*) 
        (*ENDWITH*) 
        WITH acv.a_ap_tree^[ _ti ] DO
            _pos := n_pos + n_length;
        (*ENDWITH*) 
        IF  a01equal_char( acv.a_cmd_part^.sp1p_buf, _pos, '"')
        THEN
            _pos := _pos + a01char_size;
        (*ENDIF*) 
        SAPDB_PascalOverlappingMove('VAK27 ',   1,    
              acv.a_cmd_part^.sp1p_buf_size,
              acv.a_cmd_part^.sp1p_buf_size,
              @acv.a_cmd_part^.sp1p_buf, _pos + 1, @acv.a_cmd_part^.sp1p_buf,
              _pos + 1 + _col_list_part^.sp1p_buf_len,
              acv.a_cmd_part^.sp1p_buf_len - ( _pos + 1 ) + 1,
              acv.a_returncode );
        SAPDB_PascalMove('VAK27 ',   2,    
              _col_list_part^.sp1p_buf_size,
              acv.a_cmd_part^.sp1p_buf_size,
              @_col_list_part^.sp1p_buf, 1,
              @acv.a_cmd_part^.sp1p_buf, _pos + 1,
              _col_list_part^.sp1p_buf_len,
              acv.a_returncode );
        acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len +
              _col_list_part^.sp1p_buf_len
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27base_rec_handling (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par);
 
VAR
      _col_ptr     : tak00_colinfo_ptr;
      _vqual_ptr   : tak_sysbufferaddress;
      _vqual_key   : tgg00_SysInfoKey;
      _j           : integer;
      _ok          : boolean;
      _b_err       : tgg00_BasisError;
 
BEGIN
a06_systable_get( acv, d_fix, viewscanpar.vsc_usagedef.usa_tableid,
      acv.a_p_arr2.pbasep, c_get_all, _ok );
IF  NOT ( _ok )
THEN
    a07ak_system_error( acv, 27, 3 );
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    viewscanpar.vsc_col_list := acv.a_p_arr2.pbasep^.sbase.bv_viewlist;
    WITH acv.a_p_arr2.pbasep^.sbase DO
        BEGIN
        a101_InvalidateListAppend (acv, bschema, btablen^);
        IF  acv.a_init_ddl = ddl_drop_domain
        THEN
            FOR _j := bfirstindex TO blastindex DO
                IF  ( ctdomain in bcolumn[ _j ]^.ccolpropset ) AND
                    ( bcolumn[ _j ]^.ctabno in viewscanpar.vsc_tabno_set )
                THEN
                    BEGIN
                    a06extcolno( acv.a_p_arr1.pbasep^.sbase,
                          bcolumn[ _j ]^.creccolno, _col_ptr );
                    IF  NOT ( ctdomain in _col_ptr^.ccolpropset )
                    THEN
                        bcolumn[ _j ]^.ccolpropset :=
                              bcolumn[ _j ]^.ccolpropset - [ ctdomain ]
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDFOR*) 
        (*ENDIF*) 
        btreeid.fileVersion_gg00 := viewscanpar.vsc_filevers;
        IF  btablekind = tonebase
        THEN
            BEGIN
            CASE acv.a_is_ddl OF
                ddl_create_link :
                    IF  acv.a_init_ddl = ddl_create_table
                    THEN
                        blinkexist :=
                              acv.a_p_arr1.pbasep^.sbase.blinkexist;
                    (*ENDIF*) 
                ddl_create_trigger, ddl_drop_trigger :
                    blinkexist :=
                          acv.a_p_arr1.pbasep^.sbase.blinkexist;
                ddl_add_constraint, ddl_drop_constraint :
                    bnamed_constr :=
                          acv.a_p_arr1.pbasep^.sbase.bnamed_constr;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
            bindexexist := viewscanpar.vsc_mult_index;
            brows       := viewscanpar.vsc_rows
            END;
        (*ENDIF*) 
        CASE  viewscanpar.vsc_type OF
            v_statistics :
                BEGIN
                IF  viewscanpar.vsc_base_page_cnt >= 0
                THEN
                    BEGIN
                    bpages := viewscanpar.vsc_base_page_cnt;
                    brows  := viewscanpar.vsc_base_rec_cnt;
                    a11put_date_time( bupdstatdate, bupdstattime );
                    END;
                (*ENDIF*) 
                END;
            v_index :
                FOR _j := bfirstindex TO blastindex DO
                    ak27ci_repl_index_in_view_col( viewscanpar, bcolumn[ _j ]^ );
                (*ENDFOR*) 
            v_revoke_priv :
                BEGIN
                viewscanpar.vsc_valid_colset := [  ];
                FOR _j := bfirstindex TO blastindex DO
                    WITH bcolumn[ _j ]^ DO
                        IF  NOT ( ctdropped in ccolpropset ) AND
                            NOT ( ctinvisible in ccolpropset )
                        THEN
                            viewscanpar.vsc_valid_colset :=
                                  viewscanpar.vsc_valid_colset + [ cextcolno ];
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDFOR*) 
                viewscanpar.vsc_valid_colset :=
                      viewscanpar.vsc_valid_colset - viewscanpar.vsc_drop_set
                END;
            OTHERWISE ;
            END;
        (*ENDCASE*) 
        END;
    (*ENDWITH*) 
    IF  viewscanpar.vsc_col_dropped
    THEN
        ak27dc_col_in_view_drop( acv, viewscanpar )
    ELSE
        IF  ( viewscanpar.vsc_type = v_rename_column ) AND
            ( viewscanpar.vsc_rp_rt_handling OR
            ( viewscanpar.vsc_usagedef.usa_tableid =
            viewscanpar.vsc_start_tabid ) )
        THEN
            ak27rc_rename_in_base_rec( acv, viewscanpar );
        (*ENDIF*) 
    (*ENDIF*) 
    IF  acv.a_init_ddl = ddl_add_constraint
    THEN
        BEGIN
        _vqual_key           := a01defaultkey;
        _vqual_key.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
        _vqual_key.sentrytyp := cak_eviewqual_basis;
        a10get_sysinfo( acv, _vqual_key, d_fix, _vqual_ptr, _b_err );
        IF  _b_err = e_ok
        THEN
            BEGIN
            a16constraint_check( acv, acv.a_p_arr2.pbasep^.sbase, _vqual_ptr );
            a10_rel_sysinfo( acv, _vqual_key );
            END
        ELSE
            a07_b_put_error( acv, _b_err, 1 );
        (*ENDIF*) 
        END
    ELSE
        IF  ( acv.a_returncode = 0 ) AND
            NOT ( viewscanpar.vsc_delete_view )
        THEN
            BEGIN
            a10repl_sysinfo( acv, acv.a_p_arr2.pbasep, _b_err );
            IF  _b_err <> e_ok
            THEN
                a07_b_put_error( acv, _b_err, 1 );
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27ci_analyze_qual (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            VAR b_err       : tgg00_BasisError);
 
VAR
      _scatalog_key  : tgg00_SysInfoKey;
      _scatalog_ptr  : tak_sysbufferaddress;
      _arr_idx      : integer;
      _st_index     : integer;
      _stcnt        : integer;
      _i            : integer;
      _rec_modified : boolean;
 
BEGIN
&ifdef TRACE
t01int4( ak_sem, 'tabno=      ', viewscanpar.vsc_tabno );
&endif
_scatalog_key           := a01defaultkey;
_scatalog_key.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
_scatalog_key.sentrytyp := cak_eviewqual_stack;
a10get_sysinfo( acv, _scatalog_key, d_fix, _scatalog_ptr, b_err );
IF  b_err = e_ok
THEN
    BEGIN
    _rec_modified := false;
    _arr_idx  := 1;
    _stcnt    := 1;
    _st_index := 0;
&   ifdef trace
    t01int4( ak_sem, 'vstcount    ', _scatalog_ptr^.sviewqual_stack.vstcount );
&   endif
    WHILE ( _stcnt <= _scatalog_ptr^.sviewqual_stack.vstcount ) AND
          ( b_err = e_ok ) DO
        BEGIN
        _st_index := _st_index + 1;
        IF  _arr_idx > cak_max_viewqual_stack
        THEN
            (* record overflow handling *)
            BEGIN
            IF  _rec_modified
            THEN
                a10repl_sysinfo( acv, _scatalog_ptr, b_err );
            (*ENDIF*) 
            a10_rel_sysinfo( acv, _scatalog_key );(* release actual record *)
            a06inc_linkage( _scatalog_key.slinkage );
            a10get_sysinfo( acv, _scatalog_key, d_fix, _scatalog_ptr, b_err );
            _rec_modified := false;
            _arr_idx := 1;
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01stackentry( ak_sem,
                  _scatalog_ptr^.sviewqual_stack.vstack[ _arr_idx ], _arr_idx );
&           endif
            IF  _scatalog_ptr^.sviewqual_stack.vstack[ _arr_idx ].etype in
                [ st_op, st_fixkey, st_varkey, st_fixcol, st_varcol ]
            THEN
                FOR _i := 1 TO viewscanpar.vsc_index_col_count DO
                    IF  ak27ci_equal_stackentries( _scatalog_ptr^.
                        sviewqual_stack.vstack[ _arr_idx ],
                        viewscanpar.vsc_col_info[ _i ]^.ccolstack,
                        viewscanpar.vsc_tabno )
                    THEN
                        BEGIN
                        (*============================*)
                        (* store or delete Index Flag *)
                        (* in Stack Entry             *)
                        (*============================*)
                        _rec_modified := true;
                        ak27ci_mult_index_stack_entry( _scatalog_ptr^.
                              sviewqual_stack.vstack[ _arr_idx ],
                              viewscanpar.vsc_col_info[ _i ]^ );
                        END;
                    (*ENDIF*) 
                (*ENDFOR*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        _stcnt   := succ( _stcnt );
        _arr_idx := succ( _arr_idx );
        END;
    (*ENDWHILE*) 
    ;
    (* update last record *)
    IF  _rec_modified
    THEN
        a10repl_sysinfo( acv, _scatalog_ptr, b_err );
    (*ENDIF*) 
    a10_rel_sysinfo( acv, _scatalog_key );(* release last record *)
    END;
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error( acv, b_err, 1 );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27ci_mult_index_stack_entry (
            VAR st_entry : tgg00_StackEntry;
            VAR col_info : tak00_columninfo);
 
BEGIN
IF  ctmulti in col_info.ccolpropset
THEN
    BEGIN
    IF  st_entry.ecol_tab[ 1 ] = chr(0)
    THEN
        st_entry.ecol_tab[ 1 ] := chr(cak00_col_with_inv);
    (*ENDIF*) 
    END
ELSE
    IF  st_entry.ecol_tab[ 1 ] = chr(cak00_col_with_inv)
    THEN
        st_entry.ecol_tab[ 1 ] := chr(0);
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak27ci_equal_stackentries (
            VAR qual_stack_entry : tgg00_StackEntry;
            VAR base_stack_entry : tgg00_StackEntry;
            tab_no               : integer) : boolean;
 
BEGIN
&ifdef TRACE
t01stackentry( ak_sem, qual_stack_entry, 1 );
t01stackentry( ak_sem, base_stack_entry, 2 );
t01int4( ak_sem, 'tabno =     ', tab_no );
&endif
ak27ci_equal_stackentries :=
      ( qual_stack_entry.etype    = base_stack_entry.etype )    AND
      ( qual_stack_entry.epos     = base_stack_entry.epos )     AND
      ( qual_stack_entry.elen_var = base_stack_entry.elen_var ) AND
      ( ord( qual_stack_entry.ecol_tab[ 2 ] ) = tab_no );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27ci_repl_index_in_view_col (
            VAR viewscanpar : tak_viewscan_par;
            VAR col_info    : tak00_columninfo);
 
VAR
      _col_index : integer;
 
BEGIN
FOR _col_index := 1 TO viewscanpar.vsc_index_col_count DO
    BEGIN
    IF  ( col_info.creccolno = viewscanpar.vsc_col_info[ _col_index ]^.creccolno )
        AND ( col_info.ctabno in viewscanpar.vsc_tabno_set )
        AND NOT ( ctexpression in col_info.ccolpropset )
    THEN
        BEGIN
        CASE viewscanpar.vsc_mode OF
            cmd_create_index :
                col_info.ccolpropset := col_info.ccolpropset +
                      viewscanpar.vsc_col_info[ _col_index ]^.ccolpropset;
            cmd_drop_index :
                IF  NOT ( ctmulti in
                    viewscanpar.vsc_col_info[ _col_index ]^.ccolpropset )
                THEN
                    col_info.ccolpropset := col_info.ccolpropset -
                          [ ctmulti ];
                (*ENDIF*) 
            END;
        (*ENDCASE*) 
        col_info.ccolstack := viewscanpar.vsc_col_info[ _col_index ]^.ccolstack;
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27dc_col_in_view_drop (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par);
 
VAR
      _sort             : boolean;
      _owner_determined : boolean;
      _i                : integer;
      _rest_col_cnt     : integer;
      _col_ptr          : tak00_colinfo_ptr;
      _owner            : tsp00_KnlIdentifier;
      _dummy_name       : tsp00_KnlIdentifier;
      _dropped_col      : tsp00_KnlIdentifier;
      _schema_name      : tsp00_KnlIdentifier;
 
BEGIN
viewscanpar.vsc_valid_cnt := 0;
_rest_col_cnt     := 0;
viewscanpar.vsc_extcol_set := [  ];
_sort := false;
_owner_determined := false;
_i    := 1;
WHILE ( _i <= acv.a_p_arr2.pbasep^.sbase.bmaxcol ) AND
      ( acv.a_returncode = 0 ) DO
    BEGIN
    a06extcolno( acv.a_p_arr2.pbasep^.sbase, _i, _col_ptr );
    WITH _col_ptr^ DO
        BEGIN
        IF  NOT ( ctdropped in ccolpropset ) AND
            NOT ( ctinvisible in ccolpropset )
        THEN
            BEGIN
            viewscanpar.vsc_valid_cnt := succ( viewscanpar.vsc_valid_cnt );
            viewscanpar.vsc_valid_cols[ viewscanpar.vsc_valid_cnt ] :=
                  cextcolno;
            IF  cextcolno in viewscanpar.vsc_drop_set
            THEN
                WITH acv.a_p_arr2.pbasep^.sbase DO
                    BEGIN
                    IF  NOT _owner_determined
                    THEN
                        BEGIN
                        a06determine_username( acv, bauthid, _owner );
                        _owner_determined := true
                        END;
                    (*ENDIF*) 
                    a061get_colname( _col_ptr^, _dropped_col );
                    (* PTS 1132495 M.Ki *)
                    a103GetSchemaName (acv, bschema, _schema_name);
                    IF  acv.a_returncode = 0
                    THEN
                        a38column_drop( acv,
                              _owner, _schema_name, btablen^, _dropped_col );
                    (*ENDIF*) 
                    IF  ctcomment in ccolpropset
                    THEN
                        a26drop_comment( acv,
                              cm_column, bsurrogate, bsurrogate,
                              cextcolno );
                    (*ENDIF*) 
                    _sort          := true;
                    bcntdropcol   := succ( bcntdropcol );
                    ccolumnn[ 1 ] := chr( 255 );
                    ccolumnn_len  := chr( 1 );
                    viewscanpar.vsc_extcol_set := viewscanpar.vsc_extcol_set +
                          [ viewscanpar.vsc_valid_cnt ];
                    ccolpropset := ccolpropset + [ ctdropped ]
                          + [ ctopt ] - [ ctdefault ];
                    IF  btablekind = tcomplexview
                    THEN
                        ak27new_complex_view_pos( acv.a_p_arr2.pbasep,
                              cinoutlen, cextcolno );
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            ELSE
                _rest_col_cnt := succ( _rest_col_cnt );
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    _i := succ( _i );
    END;
(*ENDWHILE*) 
WITH acv.a_p_arr2.pbasep^.sbase DO
    IF  _rest_col_cnt = 0
    THEN
        viewscanpar.vsc_delete_view := true
    ELSE
        BEGIN
        IF  _sort
        THEN
            BEGIN
            a061sort( acv, acv.a_p_arr2.pbasep^.sbase, 0, _sort, _dummy_name );
            a16new_bextcolindex( acv.a_p_arr2.pbasep^.sbase );
            a11sort( acv.a_p_arr2.pbasep^.sbase )
            END;
        (*ENDIF*) 
        IF  viewscanpar.vsc_type = v_alter_drop
        THEN
            a13repl_priv_column( acv, acv.a_p_arr2.pbasep,
                  viewscanpar.vsc_drop_set );
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
&ifdef TRACE
t01int4( ak_sem, 'rest_col_cnt', _rest_col_cnt );
FOR _i := 1 TO MAX_COL_PER_TAB_GG00 DO
    IF  _i in viewscanpar.vsc_extcol_set
    THEN
        t01int4( ak_sem, 'extcolset   ' , _i );
&   endif
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27dc_drop_col (
            VAR acv           : tak_all_command_glob;
            viewlevel_cnt     : integer;
            low_level_dropped : boolean;
            VAR viewscanpar   : tak_viewscan_par);
 
VAR
      _b_err   : tgg00_BasisError;
      _tabno   : integer;
      _qualbuf : tak_sysbufferaddress;
      _qualkey : tgg00_SysInfoKey;
 
BEGIN
IF  viewlevel_cnt <> cak_is_undefined
THEN
    ak27dcrc_analyze_columns( acv, viewlevel_cnt, low_level_dropped,
          viewscanpar );
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  NOT ( viewscanpar.vsc_delete_view )
    THEN
        BEGIN
        IF  viewscanpar.vsc_init_type = v_alter_drop
        THEN
            IF  viewscanpar.vsc_usagedef.usa_tablekind = tview
            THEN
                BEGIN
                (* get tables of view *)
                _qualkey           := a01defaultkey;
                _qualkey.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
                _qualkey.sentrytyp := cak_eviewqual_basis;
                a10get_sysinfo( acv, _qualkey, d_release, _qualbuf, _b_err );
                IF  _b_err <> e_ok
                THEN
                    a07_b_put_error( acv, _b_err, 1 )
                ELSE
                    BEGIN
                    viewscanpar.vsc_tabno_set := [  ];
                    FOR _tabno := 1 TO _qualbuf^.sviewqual_basis.vbasetabcnt DO
                        IF  _qualbuf^.sviewqual_basis.vtable[ _tabno ].
                            vttableid = viewscanpar.vsc_base_tabid
                        THEN
                            viewscanpar.vsc_tabno_set :=
                                  viewscanpar.vsc_tabno_set + [ _tabno ]
                        (*ENDIF*) 
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                viewscanpar.vsc_tabno_set := [ 1 ];
            (*ENDIF*) 
        (* PTS 1111576 E.Z. *)
        (*ENDIF*) 
        ak27base_rec_handling( acv, viewscanpar );
        END;
    (*ENDIF*) 
    IF  NOT ( viewscanpar.vsc_delete_view )
    THEN
        BEGIN
        IF  viewscanpar.vsc_usagedef.usa_tablekind = tview
        THEN
            ak27qual_handling( acv, viewscanpar );
        (*ENDIF*) 
        IF  viewscanpar.vsc_col_dropped
        THEN
            ak27dcrcrt_viewtext_manipulat( acv,
                  vtalter_table_drop, viewscanpar );
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27dcrcrt_viewtext_manipulat (
            VAR acv         : tak_all_command_glob;
            call_reason     : tak27_call_reason;
            VAR viewscanpar : tak_viewscan_par);
 
VAR
      _asterisk_found : boolean;
      _text_modified  : boolean;
      _col_dropped    : boolean;
      _found          : boolean;
      _internal_packet: boolean;
      _do_optimize    : boolean;
      _init_sqlmode   : tsp00_SqlMode;
      _internal_sql   : tak_internal_sql_kind;
      _init_ddl       : tak_ddl_descriptor;
      _init_ex_kind   : tak_execution_kind;
      _cmd_len        : integer;
      _i              : integer;
      _j              : integer;
      _add            : integer;
      _ti             : integer;
      _col_ti         : integer;
      _del            : integer;
      _colno          : integer;
      _extno          : integer;
      _first_colno    : integer;
      _last_colno     : integer;
      _pos            : integer;
      _startpos       : integer;
      _endpos         : integer;
      _diff           : integer;
      _sum_diff       : integer;
      _buf_count      : integer;
      _pos_info       : tak27_own_tab_col_info;
      _viewtext_ptr   : tak_sysbufferaddress;
      _pTable         : tak_sysbufferaddress;
 
BEGIN
WITH viewscanpar DO
    BEGIN
    _text_modified   := false;
    _col_dropped     := false;
    _internal_packet := false;
    ak27viewtext_into_cmd_part( acv, viewscanpar, _viewtext_ptr, _buf_count );
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        a06_systable_get (acv, d_release,
              viewscanpar.vsc_usagedef.usa_tableid, _pTable, false, _found);
        IF  NOT _found
        THEN
            a07ak_system_error( acv, 27, 10 )
        ELSE
            BEGIN
            _init_sqlmode         := acv.a_sqlmode;
            acv.a_sqlmode         := _pTable^.sbase.bsqlmode;
            _internal_packet      := true;
            _init_ex_kind         := acv.a_ex_kind;
            _init_ddl             := acv.a_is_ddl;
            acv.a_ex_kind         := only_syntax;
            _do_optimize          := acv.a_optimize_info.o_do_optimize;
            (* info nodes in syntax tree are required *)
            acv.a_optimize_info.o_do_optimize := true;
            _internal_sql         := acv.a_internal_sql;
            acv.a_internal_sql    := sql_restore_schema;
            a35_asql_statement( acv );
            acv.a_internal_sql    := _internal_sql;
            acv.a_optimize_info.o_do_optimize := _do_optimize;
            acv.a_ex_kind         := _init_ex_kind;
            acv.a_is_ddl          := _init_ddl;
            acv.a_sqlmode         := _init_sqlmode;
&           ifdef TRACE
            t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf, 1,
                  acv.a_cmd_part^.sp1p_buf_len );
            FOR _colno := 1 TO MAX_COL_PER_TAB_GG00 DO
                BEGIN
                IF  _colno in vsc_drop_set
                THEN
                    t01int4( ak_sem, 'drop_column ', _colno );
                (*ENDIF*) 
                END;
            (*ENDFOR*) 
&           endif
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        WITH _viewtext_ptr^.sviewtext DO
            BEGIN
            _ti := acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_lo_level;
            IF  acv.a_ap_tree^[ _ti ].n_symb = s_authid
            THEN (* create view <authid>. ... *)
                _ti := acv.a_ap_tree^[ _ti ].n_sa_level;
&           ifdef trace
            (*ENDIF*) 
            t01int4( ak_sem, 'ti          ', _ti );
&           endif
            IF  vsc_col_list
            THEN
                IF  ( call_reason = vtalter_table_drop ) OR
                    ( call_reason = vtrename_view_column )
                THEN
                    BEGIN (* find syntax tree entry of first column *)
                    _ti     := acv.a_ap_tree^[ _ti ].n_lo_level;
                    _col_ti := acv.a_ap_tree^[ _ti ].n_sa_level
                    END;
&               ifdef trace
                (*ENDIF*) 
            (*ENDIF*) 
            t01int4( ak_sem, 'ti          ', _ti );
&           endif
            CASE call_reason OF
                vtalter_table_drop :
                    BEGIN
                    _ti := acv.a_ap_tree^[ _ti ].n_lo_level;
                    WITH acv.a_ap_tree^[ _ti ] DO
                        vsc_delete_view :=
                              ( n_subproc = cak_x_start_union ) OR
                              ( n_subproc = cak_x_union       ) OR
                              ( n_subproc = cak_x_union_all   ) OR
                              ( n_subproc = cak_x_except      ) OR
                              ( n_subproc = cak_x_except_all  ) OR
                              ( n_subproc = cak_x_intersect   ) OR
                              ( n_subproc = cak_x_intersect_all );
                    (*ENDWITH*) 
&                   ifdef trace
                    t01int4( ak_sem, 'ti          ', _ti );
&                   endif
                    _sum_diff := 0;
                    IF  vsc_col_list AND NOT vsc_delete_view
                    THEN
                        BEGIN (* view defined with column name list *)
                        _del      := 0;
                        _colno    := 1;
                        WHILE _col_ti <> 0 DO
                            WITH acv.a_ap_tree^[ _col_ti ] DO
                                BEGIN
                                IF  _colno in vsc_extcol_set
                                THEN
                                    BEGIN (* delete column name *)
                                    IF  a01equal_char(
                                        acv.a_cmd_part^.sp1p_buf,
                                        n_pos - _del - a01char_size, '"' )
                                    THEN
                                        _startpos :=
                                              n_pos - _del - a01char_size
                                    ELSE
                                        _startpos := n_pos - _del;
                                    (*ENDIF*) 
                                    IF  n_sa_level <> 0
                                    THEN (* curr column not last column *)
                                        BEGIN
                                        _endpos :=
                                              acv.a_ap_tree^[ n_sa_level ].n_pos
                                              - _del;
                                        IF  a01equal_char(
                                            acv.a_cmd_part^.sp1p_buf,
                                            _endpos - a01char_size, '"')
                                        THEN
                                            _endpos :=
                                                  _endpos - a01char_size
                                        (*ENDIF*) 
                                        END
                                    ELSE
                                        BEGIN
                                        _endpos := _startpos + n_length;
&                                       ifdef trace
                                        t01int4( ak_sem, 'startpos    ',
                                              _startpos );
                                        t01int4( ak_sem, 'endpos      ',
                                              _endpos );
&                                       endif
                                        WHILE NOT a01equal_char(
                                              acv.a_cmd_part^.sp1p_buf,
                                              _endpos, ')' ) DO
                                            _endpos := _endpos +
                                                  a01char_size;
                                        (*ENDWHILE*) 
                                        WHILE NOT a01equal_char(
                                              acv.a_cmd_part^.sp1p_buf,
                                              _startpos, ',' ) DO
                                            _startpos := _startpos -
                                                  a01char_size;
                                        (*ENDWHILE*) 
                                        END;
                                    (*ENDIF*) 
                                    SAPDB_PascalOverlappingMove('VAK27 ',   3,    
                                          acv.a_cmd_part^.sp1p_buf_size,
                                          acv.a_cmd_part^.sp1p_buf_size,
                                          @acv.a_cmd_part^.sp1p_buf, _endpos,
                                          @acv.a_cmd_part^.sp1p_buf, _startpos,
                                          acv.a_cmd_part^.sp1p_buf_len -
                                          _endpos + 1,
                                          acv.a_returncode );
                                    _diff := _endpos - _startpos;
                                    ak27new_view_pos_info( acv,
                                          viewscanpar, _viewtext_ptr,
                                          c_no_col_drop, _startpos, -_diff );
                                    acv.a_cmd_part^.sp1p_buf_len  :=
                                          acv.a_cmd_part^.sp1p_buf_len - _diff;
                                    _sum_diff      := _sum_diff + _diff;
                                    vtselect_pos  := vtselect_pos - _diff;
                                    _del           := _del + _diff;
                                    _text_modified := true
                                    END;
                                (*ENDIF*) 
                                _colno  := succ( _colno );
                                _col_ti := n_sa_level
                                END;
                            (*ENDWITH*) 
                        (*ENDWHILE*) 
                        END;
&                   ifdef TRACE
                    (*ENDIF*) 
                    t01int4( ak_sem, 'select_pos  ', vtselect_pos );
&                   endif
                    _first_colno := 1;
                    IF  vsc_delete_view
                    THEN
                        _last_colno := 0
                    ELSE
                        _last_colno := vsc_valid_cols[ vsc_valid_cnt ];
                    (*ENDIF*) 
                    _colno := _first_colno;
&                   ifdef trace
                    t01int4( ak_sem, 'ti          ', _ti );
&                   endif
                    WHILE _colno <= _last_colno DO
                        BEGIN
                        _pos   := 0;
                        _found := false;
                        IF  _colno in vsc_drop_set
                        THEN
                            ak27get_col_pos( acv, viewscanpar,
                                  _colno, _pos, _found );
                        (*ENDIF*) 
                        IF  _pos > 0
                        THEN
                            BEGIN (* column must be dropped *)
                            ak27find_select_column( acv, _ti, _pos,
                                  _sum_diff, _startpos, _endpos );
                            IF  acv.a_returncode = 0
                            THEN
                                BEGIN
                                SAPDB_PascalOverlappingMove('VAK27 ',   4,    
                                      acv.a_cmd_part^.sp1p_buf_size,
                                      acv.a_cmd_part^.sp1p_buf_size,
                                      @acv.a_cmd_part^.sp1p_buf, _endpos,
                                      @acv.a_cmd_part^.sp1p_buf, _startpos,
                                      acv.a_cmd_part^.sp1p_buf_len - _endpos + 1,
                                      acv.a_returncode );
                                _diff         := _endpos - _startpos;
                                ak27new_view_pos_info( acv, viewscanpar,
                                      _viewtext_ptr, _colno, _startpos, -_diff );
                                _sum_diff      := _sum_diff + _diff;
                                acv.a_cmd_part^.sp1p_buf_len  :=
                                      acv.a_cmd_part^.sp1p_buf_len - _diff;
                                _text_modified := true
                                END;
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  _found
                            THEN
                                BEGIN
                                _col_dropped := true;
                                ak27new_view_pos_info( acv, viewscanpar,
                                      _viewtext_ptr, _colno, csp_maxint2, 0 );
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        _colno := _colno + 1;
                        END;
                    (*ENDWHILE*) 
                    END;
                vtrename_column :
                    BEGIN
                    FOR _i := 1 TO vsc_info_cnt DO
                        BEGIN
                        ak27get_pos_info( acv,
                              vsc_pos_info[ _i ], _pos_info );
                        IF  _pos_info.otc_col_pos = cak_is_undefined
                        THEN
                            a07ak_system_error( acv, 27, 4 )
                        ELSE
                            BEGIN
                            ak27rename_in_buf( acv, viewscanpar, _viewtext_ptr,
                                  _pos_info.otc_col_pos, vsc_newcolname,
                                  _add );
                            FOR _j := _i + 1 TO vsc_info_cnt DO
                                IF  vsc_pos_info[ _j ] > vsc_pos_info[ _i ]
                                THEN
                                    vsc_pos_info[ _j ] :=
                                          vsc_pos_info[ _j ] + _add;
                                (*ENDIF*) 
                            (*ENDFOR*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDFOR*) 
                    _text_modified := true
                    END;
                vtrename_table :
                    FOR _i:= 1 TO vttabcount DO
                        WITH vttab[ _i ] DO
                            BEGIN
                            IF  vtttableid = vsc_ren_tabid
                            THEN
                                BEGIN
                                ak27get_pos_info( acv,
                                      vtttab_n_pos, _pos_info );
                                IF  _pos_info.otc_col_pos = cak_is_undefined
                                THEN
                                    a07ak_system_error( acv, 27, 5 )
                                ELSE
                                    BEGIN
                                    IF  (vsc_new_authname <> a01_il_b_identifier  ) AND
                                        (_pos_info.otc_tab_pos <> cak_is_undefined)
                                    THEN
                                        BEGIN
                                        ak27rename_in_buf( acv,
                                              viewscanpar, _viewtext_ptr,
                                              _pos_info.otc_tab_pos,
                                              vsc_new_authname, _add );
                                        _pos_info.otc_col_pos := _pos_info.otc_col_pos + _add;
                                        END;
                                    (*ENDIF*) 
                                    ak27rename_in_buf( acv,
                                          viewscanpar, _viewtext_ptr,
                                          _pos_info.otc_col_pos,
                                          vsc_new_tablen, _add );
                                    IF  NOT vttrefname
                                    THEN
                                        ak27rt_analyze_col_definitions( acv,
                                              viewscanpar, _viewtext_ptr,  _i );
                                    (*ENDIF*) 
                                    _text_modified := true
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    (*ENDFOR*) 
                vtrename_user :
                    ak27rename_user( acv, viewscanpar, _viewtext_ptr,
                          _text_modified );
                vtrename_view :
                    BEGIN
                    _add := 0;
                    IF  viewscanpar.vsc_new_authname <> a01_il_b_identifier
                    THEN
                        IF  acv.a_ap_tree^[ _ti ].n_symb = s_authid
                        THEN
                            BEGIN
                            ak27rename_in_buf( acv,  viewscanpar, _viewtext_ptr,
                                  acv.a_ap_tree^[ _ti ].n_pos, vsc_new_authname,
                                  _add );
                            _ti := acv.a_ap_tree^[ _ti ].n_sa_level;
                            END
                        ELSE
                            BEGIN
                            IF  ( acv.a_cmd_part^.sp1p_buf_len + 2 * a01char_size >
                                acv.a_cmd_part^.sp1p_buf_size )
                            THEN
                                a07_b_put_error( acv,
                                      e_too_small_packet_size, 1 )
                            ELSE
                                BEGIN
                                _endpos := acv.a_ap_tree^[ _ti ].n_pos;
                                FOR _i := acv.a_cmd_part^.sp1p_buf_len
                                      DOWNTO _endpos DO
                                    acv.a_cmd_part^.sp1p_buf[
                                          _i + 2 * a01char_size ] :=
                                          acv.a_cmd_part^.sp1p_buf[ _i ];
                                (*ENDFOR*) 
                                _cmd_len :=
                                      acv.a_cmd_part^.sp1p_buf_len +
                                      2 * a01char_size;
                                acv.a_cmd_part^.sp1p_buf_len := _endpos - 1;
                                a542char_to_packet( acv, 'A');
                                a542char_to_packet( acv, '.' );
                                acv.a_cmd_part^.sp1p_buf_len := _cmd_len;
                                ak27new_view_pos_info( acv,
                                      viewscanpar, _viewtext_ptr,
                                      c_no_col_drop,
                                      _endpos, a01char_size + 1 );
                                ak27rename_in_buf( acv, viewscanpar,
                                      _viewtext_ptr,
                                      _endpos, vsc_new_authname, _add );
                                _add := 2 * a01char_size + _add;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    vtselect_pos  := vtselect_pos + _add;
                    ak27rename_in_buf( acv,  viewscanpar, _viewtext_ptr,
                          acv.a_ap_tree^[ _ti ].n_pos + _add, vsc_new_tablen,
                          _add );
                    vtselect_pos  := vtselect_pos + _add;
                    _text_modified := true
                    END;
                vtrename_view_column :
                    BEGIN
                    _ti := acv.a_ap_tree^[ _ti ].n_lo_level;
                    IF  vsc_usagedef.usa_tablekind = tcomplexview
                    THEN
                        _extno := vsc_col_extcolno - 1
                    ELSE
                        _extno := vsc_col_extcolno;
                    (*ENDIF*) 
&                   ifdef trace
                    t01int4( ak_sem, 'extno       ', _extno );
                    t01int4( ak_sem, 'vsc_collist ', ord( vsc_col_list ) );
&                   endif
                    IF  vsc_col_list
                    THEN
                        BEGIN (* View defined with column list *)
                        FOR _i := 1 TO _extno - 1 DO
                            _col_ti := acv.a_ap_tree^[ _col_ti ].n_sa_level;
                        (*ENDFOR*) 
                        ak27rename_in_buf( acv, viewscanpar, _viewtext_ptr,
                              acv.a_ap_tree^[ _col_ti ].n_pos,
                              vsc_newcolname, _add );
                        vtselect_pos  := vtselect_pos + _add;
                        _text_modified := true
                        END
                    ELSE
                        BEGIN
                        IF  ak27reference_name_found( acv, _ti, _extno,
                            _asterisk_found, _startpos, _endpos )
                        THEN
                            BEGIN (* rename reference name *)
                            ak27rename_in_buf( acv, viewscanpar, _viewtext_ptr,
                                  _startpos, vsc_newcolname, _add );
                            END
                        ELSE
                            BEGIN (* insert reference name *)
                            IF  _asterisk_found
                            THEN
                                ak27add_column_list( acv,
                                      viewscanpar, _extno )
                            ELSE
                                IF  ( acv.a_cmd_part^.sp1p_buf_len + 2 >
                                    acv.a_cmd_part^.sp1p_buf_size )
                                    OR
                                    ( acv.a_returncode <> 0 )
                                THEN
                                    a07_b_put_error( acv,
                                          e_too_small_packet_size, 1 )
                                ELSE
                                    BEGIN
                                    FOR _i := acv.a_cmd_part^.sp1p_buf_len
                                          DOWNTO _endpos + 1 DO
                                        acv.a_cmd_part^.sp1p_buf[
                                              _i + 2 * a01char_size ] :=
                                              acv.a_cmd_part^.sp1p_buf[ _i ];
                                    (*ENDFOR*) 
                                    _cmd_len :=
                                          acv.a_cmd_part^.sp1p_buf_len +
                                          2 * a01char_size;
                                    acv.a_cmd_part^.sp1p_buf_len := _endpos;
                                    a542char_to_packet( acv, bsp_c1 );
                                    a542char_to_packet( acv, 'A' );
                                    acv.a_cmd_part^.sp1p_buf_len := _cmd_len;
                                    ak27new_view_pos_info( acv,
                                          viewscanpar, _viewtext_ptr,
                                          c_no_col_drop,
                                          _startpos, a01char_size + 1 );
                                    ak27rename_in_buf( acv, viewscanpar,
                                          _viewtext_ptr,
                                          _endpos + a01char_size + 1,
                                          vsc_newcolname, _add );
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        _text_modified := true;
                        END;
                    (*ENDIF*) 
                    END;
                END;
            (*ENDCASE*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        IF  _text_modified
        THEN
            ak27view_definition_to_sysinfo( acv, viewscanpar, _viewtext_ptr,
                  _buf_count )
        ELSE
            BEGIN
            IF  _internal_packet
            THEN
                a542pop_packet( acv );
            (*ENDIF*) 
            IF  _col_dropped
            THEN
                ak27store_vdesc( acv, viewscanpar );
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a10_rel_sysinfo( acv, _viewtext_ptr^.syskey ); (* PTS 1133416 *)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27dcrc_analyze_columns (
            VAR acv           : tak_all_command_glob;
            view_level        : integer;
            low_level_dropped : boolean;
            VAR viewscanpar   : tak_viewscan_par);
 
VAR
      _i2c2               : tsp_int_map_c2;
      _colno              : integer;
      _viewtext_ptr       : tak_sysbufferaddress;
      _viewtext_key       : tgg00_SysInfoKey;
      _vdesc_scan_info    : tak27_vdesc_scan_record;
      _k                  : tgg00_Lkey;
      _rec                : tgg00_Rec;
      _b_err              : tgg00_BasisError;
 
BEGIN
_viewtext_key           := a01defaultkey;
_viewtext_key.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
_viewtext_key.sentrytyp := cak_eviewtext;
a10get_sysinfo( acv, _viewtext_key, d_fix, _viewtext_ptr, _b_err );
IF  ( _b_err = e_ok ) AND ( low_level_dropped )
THEN
    BEGIN
    _k.len        := 2;
    _i2c2.map_int := view_level - 1;
    _k.k[ 1 ]     := _i2c2.map_c2[ 1 ];
    _k.k[ 2 ]     := _i2c2.map_c2[ 2 ];
    b07cget_record( acv.a_transinf.tri_trans, acv.a_into_tree, _k, _rec );
    _b_err := acv.a_transinf.tri_trans.trError_gg00;
    IF  _b_err = e_ok
    THEN
        BEGIN
        SAPDB_PascalForcedMove( sizeof( _rec.info ), sizeof( _vdesc_scan_info.sc_from_col_set ),
              @_rec.info, 3, @_vdesc_scan_info.sc_from_col_set, 1,
              sizeof( _vdesc_scan_info.sc_from_col_set ));
&       ifdef TRACE
        FOR _colno := 1 TO MAX_COL_PER_TAB_GG00 DO
            IF  _colno in _vdesc_scan_info.sc_from_col_set
            THEN
                t01int4( ak_sem, 'dropped cols', _colno );
&           endif
            (*ENDIF*) 
        (*ENDFOR*) 
        ak27get_viewdesc( acv, viewscanpar, _b_err )
        END;
    (*ENDIF*) 
    IF  _b_err = e_ok
    THEN
        BEGIN
        _vdesc_scan_info.sc_tabno  := 1;
        viewscanpar.vsc_drop_set   := [  ];
        viewscanpar.vsc_info_cnt   := 0;
        _vdesc_scan_info.sc_reason := sc_test_columns;
        _vdesc_scan_info.sc_colcnt := 0;
        WITH _viewtext_ptr^.sviewtext DO
            WHILE ( _vdesc_scan_info.sc_tabno <= vttabcount ) AND
                  NOT ( viewscanpar.vsc_delete_view ) DO
                BEGIN
                IF  vttab[ _vdesc_scan_info.sc_tabno ].vtttableid =
                    viewscanpar.vsc_from_tableid
                THEN
                    ak27scan_vdesc( acv, viewscanpar, _vdesc_scan_info );
                (*ENDIF*) 
                _vdesc_scan_info.sc_tabno := succ( _vdesc_scan_info.sc_tabno );
                END;
            (*ENDWHILE*) 
        (*ENDWITH*) 
&       ifdef TRACE
        t01int4( ak_sem, 'cnt_drop_col', _vdesc_scan_info.sc_colcnt );
        FOR _colno := 1 TO MAX_COL_PER_TAB_GG00 DO
            IF  _colno in viewscanpar.vsc_drop_set
            THEN
                t01int4( ak_sem, 'drop columns', _colno );
&           endif
            (*ENDIF*) 
        (*ENDFOR*) 
        IF  viewscanpar.vsc_type = v_rename_column
        THEN
            ak27rc_rename_columns_in_view( acv,
                  viewscanpar, _vdesc_scan_info.sc_colcnt );
        (*ENDIF*) 
        IF  _vdesc_scan_info.sc_colcnt > 0
        THEN
            a13add_dropped_columns( acv, view_level, viewscanpar )
        ELSE
            BEGIN
            viewscanpar.vsc_type        := v_version;
            viewscanpar.vsc_col_dropped := false
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
a10_rel_sysinfo( acv, _viewtext_key );
IF  _b_err <> e_ok
THEN
    a07_b_put_error( acv, _b_err, 1 );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27del_dropcol_info (
            VAR acv     : tak_all_command_glob;
            level_cnt   : integer);
 
VAR
      _i2c2  : tsp_int_map_c2;
      _k     : tgg00_Lkey;
 
BEGIN
_i2c2.map_int := level_cnt;
_k.k[ 1 ]     := _i2c2.map_c2[ 1 ];
_k.k[ 2 ]     := _i2c2.map_c2[ 2 ];
_k.len        := 2;
b07cdel_record( acv.a_transinf.tri_trans, acv.a_into_tree, _k );
IF  ( acv.a_transinf.tri_trans.trError_gg00 <> e_ok ) AND
    ( acv.a_transinf.tri_trans.trError_gg00 <> e_key_not_found )
THEN
    a07_b_put_error( acv, acv.a_transinf.tri_trans.trError_gg00, 1 );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27find_select_column (
            VAR acv      : tak_all_command_glob;
            ti           : integer;
            pos          : integer;
            diff         : integer;
            VAR startpos : integer;
            VAR endpos   : integer);
 
BEGIN
&ifdef trace
t01int4( ak_sem, 'ti          ', ti );
t01int4( ak_sem, 'pos         ', pos );
t01int4( ak_sem, 'diff        ', diff );
&endif
ti := acv.a_ap_tree^[ ti ].n_lo_level;
IF  ( acv.a_ap_tree^[ ti ].n_proc = a63 ) AND
    ( acv.a_ap_tree^[ ti ].n_subproc = cak_x_distinct )
THEN
    ti := acv.a_ap_tree^[ ti ].n_lo_level;
(*ENDIF*) 
IF  ( acv.a_ap_tree^[ ti ].n_proc = a60 ) AND
    ( acv.a_ap_tree^[ ti ].n_subproc = cak_x_select_list )
THEN
    ti := acv.a_ap_tree^[ ti ].n_lo_level
ELSE
    a07ak_system_error( acv, 27, 6 );
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    (* ti points to first select column of view *)
    pos      := pos + diff;
    startpos := cak_is_undefined;
    WHILE ti <> 0 DO
        BEGIN
&       ifdef trace
        t01int4( ak_sem, 'ti loop     ', ti );
&       endif
        (* go to info node *)
        WITH acv.a_ap_tree^[ ti + 1 ] DO
            IF  ( n_pos <= pos ) AND ( pos <= n_pos + n_length - 1 )
            THEN
                BEGIN
                startpos := n_pos - diff;
                endpos   := n_pos + n_length - diff;
&               ifdef trace
                t01int4( ak_sem, 'startpos    ', startpos );
                t01int4( ak_sem, 'endpos      ', endpos );
&               endif
                IF  acv.a_ap_tree^[ ti ].n_sa_level <> 0
                THEN
                    BEGIN
                    (* found column isn't last select column *)
                    (* find start of next select column      *)
                    WHILE NOT a01equal_char( acv.a_cmd_part^.sp1p_buf,
                          endpos, ',' ) DO
                        endpos := endpos + a01char_size;
                    (*ENDWHILE*) 
                    REPEAT
                        endpos := endpos + a01char_size;
                    UNTIL
                        NOT a01is_whitespace_char( acv.a_cmd_part^.sp1p_buf,
                        endpos );
                    (*ENDREPEAT*) 
                    END
                ELSE
                    BEGIN
                    WHILE NOT a01equal_char( acv.a_cmd_part^.sp1p_buf,
                          startpos, ',' ) DO
                        startpos := startpos - a01char_size;
                    (*ENDWHILE*) 
                    (* PTS 1119315 E.Z. *)
                    (* select refname = colname is possible ! *)
                    IF  acv.a_ap_tree^[ acv.a_ap_tree^[ ti ].n_lo_level ].n_symb = s_reference_name
                    THEN
                        IF  endpos <
                            acv.a_ap_tree^[ acv.a_ap_tree^[ ti ].n_lo_level ].n_pos    +
                            acv.a_ap_tree^[ acv.a_ap_tree^[ ti ].n_lo_level ].n_length - diff
                        THEN
                            endpos :=
                                  acv.a_ap_tree^[ acv.a_ap_tree^[ ti ].n_lo_level ].n_pos    +
                                  acv.a_ap_tree^[ acv.a_ap_tree^[ ti ].n_lo_level ].n_length - diff;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                ti := 0; (* exit loop *)
                END
            ELSE
                ti := acv.a_ap_tree^[ ti ].n_sa_level;
            (*ENDIF*) 
        (*ENDWITH*) 
        END;
    (*ENDWHILE*) 
    IF  startpos = cak_is_undefined
    THEN
        a07ak_system_error( acv, 27, 7 );
    (*ENDIF*) 
    END;
&ifdef trace
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    t01moveobj ( ak_sem, acv.a_cmd_part^.sp1p_buf, startpos, endpos )
&         endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak27reference_name_found (
            VAR acv            : tak_all_command_glob;
            ti                 : integer;
            extcolno           : integer;
            VAR asterisk_found : boolean;
            VAR startpos       : integer;
            VAR endpos         : integer) : boolean;
 
VAR
      _ix : integer;
      _ci : integer;
 
BEGIN
asterisk_found := false;
ak27reference_name_found := false;
ti := acv.a_ap_tree^[ ti ].n_lo_level;
WITH acv.a_ap_tree^[ ti ] DO
    IF  ( n_proc = a63 ) AND ( n_subproc = cak_x_distinct )
    THEN
        ti := n_lo_level;
    (*ENDIF*) 
(*ENDWITH*) 
WITH acv.a_ap_tree^[ ti ] DO
    IF  ( n_proc = a60 ) AND ( n_subproc = cak_x_select_list )
    THEN
        ti := n_lo_level
    ELSE
        a07ak_system_error( acv, 27, 8 );
    (*ENDIF*) 
(*ENDWITH*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    (* ti points to first select column of view *)
    startpos := cak_is_undefined;
    _ix       := 1;
    WHILE ( _ix <= extcolno ) AND ( ti > 0 ) DO
        BEGIN
        _ci := acv.a_ap_tree^[ ti ].n_lo_level;
        WITH acv.a_ap_tree^[ _ci ] DO
            IF  n_symb = s_authid
            THEN
                _ci := n_sa_level;
            (*ENDIF*) 
        (*ENDWITH*) 
        WITH acv.a_ap_tree^[ _ci ] DO
            IF  n_symb = s_tablename
            THEN
                _ci := n_sa_level;
            (*ENDIF*) 
        (*ENDWITH*) 
        IF  acv.a_ap_tree^[ _ci ].n_symb = s_asterisk
        THEN
            BEGIN
            asterisk_found := true;
            ti             := 0
            END
        ELSE
            BEGIN
            IF  _ix < extcolno
            THEN
                ti := acv.a_ap_tree^[ ti ].n_sa_level;
            (*ENDIF*) 
            _ix := succ( _ix );
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  ti = 0
    THEN
        BEGIN
        IF  NOT asterisk_found
        THEN
            a07ak_system_error( acv, 27, 9 )
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        WITH acv.a_ap_tree^[ ti+1 ] DO
            BEGIN
            startpos := n_pos;
            endpos   := n_pos + n_length - 1
            END;
        (*ENDWITH*) 
        ti := acv.a_ap_tree^[ ti ].n_lo_level;
        WITH  acv.a_ap_tree^[ ti ] DO
            IF  n_symb = s_reference_name
            THEN
                BEGIN
                ak27reference_name_found :=true;
                startpos := n_pos;
                endpos   := n_pos + n_length - 1
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
&ifdef trace
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf, startpos, endpos );
&endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27get_col_pos (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            extcolno        : integer;
            VAR pos         : integer;
            VAR found       : boolean);
 
VAR
      _vdesc_scan_info : tak27_vdesc_scan_record;
 
BEGIN
WITH _vdesc_scan_info DO
    BEGIN
    sc_reason   := sc_get_pos;
    sc_found    := false;
    sc_extcolno := extcolno;
    ak27scan_vdesc( acv, viewscanpar, _vdesc_scan_info );
    found := sc_found;
    pos   := sc_pos;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27get_pos_info (
            VAR acv      : tak_all_command_glob;
            pos          : integer;
            VAR pos_info : tak27_own_tab_col_info);
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef trace
    t01int4( ak_sem, 'pos         ', pos );
&   endif
    pos_info.otc_own_pos := cak_is_undefined;
    pos_info.otc_tab_pos := cak_is_undefined;
    pos_info.otc_col_pos := cak_is_undefined;
    acv.a_scv.sc_newpos := pos;
    a01_next_symbol( acv );
    IF  acv.a_scv.sc_symb = s_identifier
    THEN
        BEGIN
        pos_info.otc_col_pos := acv.a_scv.sc_sypos;
        a01_next_symbol( acv );
        IF  acv.a_scv.sc_symb = s_point
        THEN
            (* tablename.colname or authid.tablen.colname *)
            BEGIN
            a01_next_symbol( acv );
            pos_info.otc_tab_pos := pos_info.otc_col_pos;
            pos_info.otc_col_pos := acv.a_scv.sc_sypos;
            IF  acv.a_scv.sc_symb = s_identifier
            THEN
                BEGIN
                a01_next_symbol( acv );
                IF  acv.a_scv.sc_symb = s_point
                THEN
                    BEGIN (* authid.tablen.columnname *)
                    a01_next_symbol( acv );
                    pos_info.otc_own_pos := pos_info.otc_tab_pos;
                    pos_info.otc_tab_pos := pos_info.otc_col_pos;
                    pos_info.otc_col_pos := acv.a_scv.sc_sypos;
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    ;
&   ifdef trace
    t01int4( ak_sem, 'owner_pos   ', pos_info.otc_own_pos );
    t01int4( ak_sem, 'table_pos   ', pos_info.otc_tab_pos );
    t01int4( ak_sem, 'col_pos     ', pos_info.otc_col_pos );
&   endif
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27insert_tablen (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            viewtext_ptr    : tak_sysbufferaddress;
            VAR owner       : tsp00_KnlIdentifier;
            VAR tablen      : tsp00_KnlIdentifier;
            tab_pos         : integer);
 
VAR
      _orig_segm      : tsp1_segment_ptr;
      _orig_cmd_part  : tsp1_part_ptr;
      _orig_len       : tsp00_Int4;
      _add_len        : tsp00_Int4;
 
BEGIN
&ifdef trace
t01int4( ak_sem, 'tab_pos     ', tab_pos );
&endif
_orig_segm      := acv.a_cmd_segm;
_orig_cmd_part  := acv.a_cmd_part;
_orig_len       := acv.a_cmd_part^.sp1p_buf_len;
a542internal_packet( acv, NOT c_release_internal_packet,
      _orig_len + 2 * ( sizeof( tsp00_KnlIdentifier ) + 2 ) + 1 );
IF  acv.a_returncode = 0
THEN
    BEGIN
    SAPDB_PascalMove('VAK27 ',   5,    
          _orig_len, acv.a_cmd_part^.sp1p_buf_size,
          @_orig_cmd_part^.sp1p_buf, 1,
          @acv.a_cmd_part^.sp1p_buf, 1,
          tab_pos-1, acv.a_returncode );
    acv.a_cmd_part^.sp1p_buf_len := tab_pos - 1;
    a542identifier_to_packet( acv, owner );
    a542char_to_packet       ( acv, '.');
    a542identifier_to_packet( acv, tablen );
    a542char_to_packet       ( acv, bsp_c1 );
    _add_len := acv.a_cmd_part^.sp1p_buf_len - tab_pos + 1;
    SAPDB_PascalMove('VAK27 ',   6,    
          _orig_len, acv.a_cmd_part^.sp1p_buf_size,
          @_orig_cmd_part^.sp1p_buf, tab_pos,
          @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
          _orig_len - tab_pos + 1, acv.a_returncode );
    a542release_packet( acv, _orig_segm );
    ak27new_view_pos_info( acv, viewscanpar, viewtext_ptr,
          c_no_col_drop, tab_pos, _add_len );
    acv.a_cmd_part^.sp1p_buf_len := _orig_len + _add_len;
&   ifdef trace
    t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf,
          1, acv.a_cmd_part^.sp1p_buf_len );
&   endif
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27new_complex_view_pos (
            view_ptr  : tak_sysbufferaddress;
            inoutlen  : integer;
            extcolno  : integer);
 
VAR
      _i       : integer;
      _col_ptr : tak00_colinfo_ptr;
 
BEGIN
FOR _i := extcolno + 1 TO view_ptr^.sbase.bmaxcol DO
    BEGIN
    a06extcolno( view_ptr^.sbase, _i, _col_ptr );
    WITH _col_ptr^ DO
        BEGIN
        ccolstack.epos := ccolstack.epos - inoutlen;
&       ifdef TRACE
        t01int4    ( ak_sem, 'cinoutlen   ', cinoutlen );
        t01int4    ( ak_sem, 'epos        ', ccolstack.epos );
&       endif
        END;
    (*ENDWITH*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27new_view_pos_info (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            viewtext_ptr    : tak_sysbufferaddress;
            drop_colno      : integer;
            start_pos       : integer;
            offset          : integer);
 
VAR
      _i               : integer;
      _vdesc_scan_info : tak27_vdesc_scan_record;
 
BEGIN
&ifdef trace
t01int4( ak_sem, 'start_pos   ', start_pos );
t01int4( ak_sem, 'offset      ', offset );
&endif
WITH _vdesc_scan_info DO
    BEGIN
    sc_reason   := sc_new_pos;
    sc_drop_col := drop_colno;
    sc_startpos := start_pos;
    sc_offset   := offset;
    ak27scan_vdesc( acv, viewscanpar, _vdesc_scan_info );
    FOR _i := 1 TO viewtext_ptr^.sviewtext.vttabcount DO
        BEGIN
&       ifdef trace
        t01int4( ak_sem, 'vtttab_n_pos',
              viewtext_ptr^.sviewtext.vttab[ _i ].vtttab_n_pos );
&       endif
        IF  viewtext_ptr^.sviewtext.vttab[ _i ].vtttab_n_pos > start_pos
        THEN
            viewtext_ptr^.sviewtext.vttab[ _i ].vtttab_n_pos :=
                  viewtext_ptr^.sviewtext.vttab[ _i ].vtttab_n_pos + offset;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a27rename_user (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par);
 
BEGIN
acv.a_ptr8 := NIL; (* PTS 1133416 *)
IF  viewscanpar.vsc_usagedef.usa_tablekind <> tsynonym
THEN
    IF  ak27unique( acv, viewscanpar, 0 )
    THEN
        BEGIN
        ak27dcrcrt_viewtext_manipulat( acv, vtrename_user, viewscanpar );
        IF  acv.a_ptr8 <> NIL
        THEN
            a10_rel_sysinfo (acv, acv.a_ptr8^.syskey);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27rename_user (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            viewtext_ptr    : tak_sysbufferaddress;
            VAR modified    : boolean);
 
VAR
      _ix             : integer;
      _diff           : integer;
      _sum            : integer;
      _curr_user_name : tsp00_KnlIdentifier;
 
BEGIN
acv.a_ap_tree^[ 0 ].n_refback  := 1;
acv.a_ap_tree^[ 1 ].n_pos      := csp_maxint4;
ak27scan_syntax_tree( acv, viewscanpar, _curr_user_name,
      acv.a_ap_tree^[ 1 ].n_lo_level );
(* a list of syntax tree nodes pointing   *)
(* to usernames to be renamed is returned *)
_sum := 0;
_ix  := acv.a_ap_tree^[ 0 ].n_refback;
WHILE _ix <> 1 DO
    BEGIN
    modified := true;
    ak27rename_in_buf( acv, viewscanpar, viewtext_ptr,
          acv.a_ap_tree^[ _ix ].n_pos + _sum,
          viewscanpar.vsc_new_user_name, _diff );
    _sum := _sum + _diff;
    _ix  := acv.a_ap_tree^[ _ix ].n_refback
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a27substitute_synonyms (
            VAR acv     : tak_all_command_glob;
            viewtextbuf : tak_sysbufferaddress;
            viewdescbuf : tak_sysbufferaddress);
 
VAR
      _ok          : boolean;
      _specialId   : boolean;
      _i           : integer;
      _j           : integer;
      _k           : integer;
      _diff        : integer;
      _idLength    : integer;
      _pos         : integer;
      _b_err       : tgg00_BasisError;
      _schema      : tsp00_KnlIdentifier;
      _synbuf      : tak_sysbufferaddress;
      _synkey      : tgg00_SysInfoKey;
      _pos_info    : tak27_own_tab_col_info;
      _viewscanpar : tak_viewscan_par;
      _pbasep      : tak_sysbufferaddress;
 
BEGIN
(* substitutes all occurences of synonyms in the from part of a view *)
(* definition string by the corresponding tables                     *)
(* If no reference name is assigend to the synonym name, the         *)
(* synonym name is used as a reference name, i.e.                    *)
(* <synonym name> becomes <table name> <synonym name>                *)
(* if a owner is specified in <synonym name> he must be removed      *)
a27init_viewscanpar( acv, _viewscanpar, v_rename_table );
acv.a_ptr8 := viewdescbuf;
_synkey := a01defaultkey;
&ifdef trace
FOR _k := 1 TO viewtextbuf^.sviewtext.vttabcount DO
    t01int4( ak_sem, 'vtttab_n_pos',
          viewtextbuf^.sviewtext.vttab[ _k ].vtttab_n_pos );
(*ENDFOR*) 
t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len );
&endif
FOR _i := 1 TO viewtextbuf^.sviewtext.vttabcount DO
    IF  viewtextbuf^.sviewtext.vttab[ _i ].vttfromTableInfo = fti_synonym
    THEN
        (* work for all synonyms *)
        BEGIN
        _synkey.stableid := viewtextbuf^.sviewtext.vttab[ _i ].vtttableid;
        a10get_sysinfo( acv, _synkey, d_release, _synbuf, _b_err );
        IF  _b_err = e_ok
        THEN
            BEGIN
            (* get synonym name *)
            _viewscanpar.vsc_new_tablen := _synbuf^.sbase.btablen^;
            IF  g01unicode
            THEN
                _viewscanpar.vsc_new_len :=
                      s30unilnr(@_viewscanpar.vsc_new_tablen,
                      csp_unicode_blank, 1,
                      sizeof( _viewscanpar.vsc_new_tablen ))
            ELSE
                _viewscanpar.vsc_new_len :=
                      s30klen( _viewscanpar.vsc_new_tablen,
                      bsp_c1, sizeof( _viewscanpar.vsc_new_tablen ));
            (*ENDIF*) 
            _viewscanpar.vsc_quotes     :=
                  NOT a01is_identifier( _viewscanpar.vsc_new_tablen,
                  _viewscanpar.vsc_new_len, acv.a_sqlmode );
            (* get user of this synonym *)
            a06determine_username( acv, _synbuf^.sbase.bschema, _schema);
            ak27get_pos_info( acv,
                  viewtextbuf^.sviewtext.vttab[ _i ].vtttab_n_pos, _pos_info );
            _pos_info.otc_own_pos := _pos_info.otc_tab_pos;
            _pos_info.otc_tab_pos := _pos_info.otc_col_pos;
            IF  a01equal_char( acv.a_cmd_part^.sp1p_buf,
                _pos_info.otc_tab_pos - a01char_size, '"')
            THEN
                _pos_info.otc_tab_pos :=
                      _pos_info.otc_tab_pos - a01char_size;
            (*ENDIF*) 
            IF  ( _pos_info.otc_own_pos <> cak_is_undefined ) OR
                ( viewtextbuf^.sviewtext.vttab[ _i ].vttrefname )
            THEN
                BEGIN
                IF  _pos_info.otc_own_pos = cak_is_undefined
                THEN
                    _pos_info.otc_own_pos :=
                          _pos_info.otc_tab_pos;
                (*ENDIF*) 
                IF  a01equal_char( acv.a_cmd_part^.sp1p_buf,
                    _pos_info.otc_own_pos - a01char_size, '"')
                THEN
                    _pos_info.otc_own_pos :=
                          _pos_info.otc_own_pos - a01char_size;
                (*ENDIF*) 
                IF  viewtextbuf^.sviewtext.vttab[ _i ].vttrefname
                THEN
                    BEGIN
                    acv.a_scv.sc_newpos := _pos_info.otc_tab_pos;
                    a01_next_symbol( acv );
                    IF  (acv.a_scv.sc_newpos <= acv.a_cmd_part^.sp1p_buf_len)
                        AND
                        (a01equal_char( acv.a_cmd_part^.sp1p_buf, acv.a_scv.sc_newpos, ' ') OR
                        a01equal_char( acv.a_cmd_part^.sp1p_buf, acv.a_scv.sc_newpos, ','))
                    THEN
                        acv.a_scv.sc_newpos := acv.a_scv.sc_newpos + a01char_size;
                    (*ENDIF*) 
                    _pos_info.otc_tab_pos := acv.a_scv.sc_newpos;
                    END;
&               ifdef trace
                (*ENDIF*) 
                t01int4( ak_sem, 'tab_pos     ', _pos_info.otc_tab_pos );
                t01int4( ak_sem, 'own_pos     ', _pos_info.otc_own_pos );
&               endif
                _diff := _pos_info.otc_tab_pos - _pos_info.otc_own_pos;
                SAPDB_PascalOverlappingMove('VAK27 ',   7,    
                      acv.a_cmd_part^.sp1p_buf_size,
                      acv.a_cmd_part^.sp1p_buf_size,
                      @acv.a_cmd_part^.sp1p_buf,
                      _pos_info.otc_tab_pos, @acv.a_cmd_part^.sp1p_buf,
                      _pos_info.otc_own_pos,
                      acv.a_cmd_part^.sp1p_buf_len -
                      _pos_info.otc_tab_pos + 1,
                      acv.a_returncode );
                acv.a_cmd_part^.sp1p_buf_len :=
                      acv.a_cmd_part^.sp1p_buf_len - _diff;
&               ifdef trace
                t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf, 1,
                      acv.a_cmd_part^.sp1p_buf_len );
&               endif
                ak27new_view_pos_info( acv, _viewscanpar, viewtextbuf,
                      c_no_col_drop, _pos_info.otc_own_pos, -_diff );
                _pos_info.otc_tab_pos := _pos_info.otc_own_pos
                END;
&           ifdef trace
            (*ENDIF*) 
            FOR _k := 1 TO viewtextbuf^.sviewtext.vttabcount DO
                t01int4( ak_sem, 'vtttab_n_pos',
                      viewtextbuf^.sviewtext.vttab[ _k ].vtttab_n_pos );
            (*ENDFOR*) 
&           endif
            ak27insert_tablen( acv, _viewscanpar, viewtextbuf, _schema,
                  _synbuf^.sbase.btablen^, _pos_info.otc_tab_pos );
&           ifdef trace
            FOR _k := 1 TO viewtextbuf^.sviewtext.vttabcount DO
                t01int4( ak_sem, 'vtttab_n_pos',
                      viewtextbuf^.sviewtext.vttab[ _k ].vtttab_n_pos );
            (*ENDFOR*) 
&           endif
            IF  viewtextbuf^.sviewtext.vttab[ _i ].vttfromTableInfo = fti_synonym
            THEN
                BEGIN
                viewtextbuf^.sviewtext.vttab[ _i ].vttrefname := true;
                FOR _j := 1 TO acv.a_ptr8^.sviewdesc.vdesc_cnt DO
                    WITH acv.a_ptr8^.sviewdesc.vdescription[ _j ] DO
                        IF  ( vfromtabno = _i ) AND ( vn_pos <> 0 )
                        THEN
                            BEGIN (* vn_pos points to column name *)
                            ak27get_pos_info( acv, abs( vn_pos ), _pos_info );
                            IF  _pos_info.otc_own_pos <> cak_is_undefined
                            THEN
                                BEGIN
                                IF  a01equal_char( acv.a_cmd_part^.
                                    sp1p_buf, _pos_info.otc_own_pos -
                                    a01char_size, '"')
                                THEN
                                    _pos_info.otc_own_pos :=
                                          _pos_info.otc_own_pos - a01char_size;
                                (*ENDIF*) 
                                acv.a_scv.sc_newpos := _pos_info.otc_own_pos;
                                (*====== skip owner ======*)
                                a01_next_symbol( acv );
                                (*====== go to dot  ======*)
                                a01_next_symbol( acv );
                                (* substitute owner and dot by blanks *)
                                a542fill_packet( acv, _pos_info.otc_own_pos,
                                      acv.a_scv.sc_sypos + 1 -
                                      _pos_info.otc_own_pos, bsp_c1 );
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*
          acv.a_ap_tree^[ 0 ].n_refback  := 1;
          acv.a_ap_tree^[ 1 ].n_pos      := csp_maxint4;
          viewscanpar.vsc_old_user_name  := a01_i_user;
          ak27scan_syntax_tree( acv, viewscanpar, _schema, acv.a_ap_tree^[ 1 ].n_lo_level );
          _i  := acv.a_ap_tree^[ 0 ].n_refback;
          _j  := 0;
          WHILE _i <> 1 DO
          BEGIN
          modified := true;
          ak27rename_in_buf( acv, viewscanpar, viewtext_ptr,
          acv.a_ap_tree^[ _ix ].n_pos + _sum,
          viewscanpar.vsc_new_user_name, _diff );
          _sum := _sum + _diff;
          _j  := _j + 1;
          _i  := acv.a_ap_tree^[ _i ].n_refback
          END;
          *)
    (*ENDIF*) 
(*ENDFOR*) 
;
&ifdef trace
t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len );
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a27ModifyAppendSchemas (
            VAR acv     : tak_all_command_glob;
            viewtextbuf : tak_sysbufferaddress;
            viewdescbuf : tak_sysbufferaddress);
 
CONST
      c_user_len       =  4;
      c_currschema_len = 14;
 
VAR
      _ok             : boolean;
      _substUser      : boolean;
      _substSchema    : boolean;
      _ix             : integer;
      _jx             : integer;
      _kx             : integer;
      _sx             : integer;
      _pos            : integer;
      _prevPos        : integer;
      _supplement     : integer;
      _sortCnt        : integer;
      _moveLen        : integer;
      _substUserCnt   : integer;
      _substSchemaCnt : integer;
      _userIdx        : integer;
      _schemaIdx      : integer;
      _sortIdx        : integer;
      _delta          : integer;
      _globalDelta    : integer;
      _orig_segm      : tsp1_segment_ptr;
      _orig_cmd_part  : tsp1_part_ptr;
      _orig_len       : tsp00_Int4;
      _schema         : tsp00_KnlIdentifier;
      _c80            : tsp00_C80;
      _pC80           : tsp00_MoveObjPtr;
      _pTable         : tak_sysbufferaddress;
      _viewscanpar    : tak_viewscan_par;
      _sortMap        : ARRAY[1..1024] OF tsp00_Int2;
      _posInfo        : ARRAY[1..1024] OF tsp00_Int4;
 
BEGIN
a27init_viewscanpar( acv, _viewscanpar, v_rename_table );
acv.a_ptr8  := viewdescbuf;
acv.a_ap_tree^[ 0 ].n_refback   := 1;
acv.a_ap_tree^[ 1 ].n_pos       := csp_maxint4;
_viewscanpar.vsc_old_user_name  := a01_i_user;
ak27scan_syntax_tree( acv, _viewscanpar, _schema, acv.a_ap_tree^[ 1 ].n_lo_level );
_substUserCnt := 0;
_userIdx      := acv.a_ap_tree^[ 0 ].n_refback;
_ix           := acv.a_ap_tree^[ 0 ].n_refback;
WHILE _ix <> 1 DO
    BEGIN
    IF  NOT (ni_complex_string_id in acv.a_ap_tree^[_ix].n_special)
    THEN
        _substUserCnt := _substUserCnt + 1;
    (*ENDIF*) 
    _ix  := acv.a_ap_tree^[ _ix ].n_refback
    END;
(*ENDWHILE*) 
_pC80       := @_c80;
IF  _substUserCnt > 0
THEN
    BEGIN
    _pos := 1;
    a05put_identifier (acv.a_curr_user_name, _pC80^, sizeof(_c80), _pos, acv.a_returncode);
    _supplement := ((_pos - 1) - c_user_len * a01char_size (*USER*)) * _substUserCnt;
    END
ELSE
    _supplement := 0;
(*ENDIF*) 
acv.a_ap_tree^[ 0 ].n_refback   := 1;
acv.a_ap_tree^[ 1 ].n_pos       := csp_maxint4;
_viewscanpar.vsc_old_user_name  := a01_i_current_schema;
ak27scan_syntax_tree( acv, _viewscanpar, _schema, acv.a_ap_tree^[ 1 ].n_lo_level );
_substSchemaCnt := 0;
_schemaIdx      := acv.a_ap_tree^[ 0 ].n_refback;
_ix             := acv.a_ap_tree^[ 0 ].n_refback;
WHILE _ix <> 1 DO
    BEGIN
    IF  NOT (ni_complex_string_id in acv.a_ap_tree^[_ix].n_special)
    THEN
        _substSchemaCnt := _substSchemaCnt + 1;
    (*ENDIF*) 
    _ix  := acv.a_ap_tree^[ _ix ].n_refback
    END;
(*ENDWHILE*) 
_pC80 := @_c80;
IF  _substSchemaCnt > 0
THEN
    BEGIN
    _pos := 1;
    a05put_identifier (acv.a_curr_schema, _pC80^, sizeof(_c80), _pos, acv.a_returncode);
    _supplement := _supplement +
          ((_pos - 1) - c_currschema_len * a01char_size (*CURRENT_SCHEMA*)) * _substSchemaCnt;
    END
ELSE
    _supplement := _supplement + 0;
(*ENDIF*) 
_sortCnt    := 0;
FOR _ix := 1 TO viewtextbuf^.sviewtext.vttabcount DO
    IF  viewtextbuf^.sviewtext.vttab[_ix].vttfromTableInfo = fti_withoutSchema
    THEN
        BEGIN
        a06_systable_get (acv, d_release, viewtextbuf^.sviewtext.vttab[ _ix ].vtttableid,
              _pTable, true, _ok);
        IF  _ok
        THEN
            BEGIN
            a103GetSchemaName (acv, _pTable^.sbase.bschema, _schema);
&           ifdef trace
            t01lidentifier (ak_sem, _schema);
            t01lidentifier (ak_sem, _pTable^.sbase.btablen^);
            t01int4        (ak_sem, 'vtttab_n_pos', viewtextbuf^.sviewtext.vttab[_ix].vtttab_n_pos);
&           endif
            _pos := 1;
            _jx  := 1;
            _ok  := true;
            WHILE (_jx <= _sortCnt) AND _ok DO
                IF  viewtextbuf^.sviewtext.vttab[ _sortMap[_jx] ].vtttab_n_pos <
                    viewtextbuf^.sviewtext.vttab[_ix].vtttab_n_pos
                THEN
                    _jx := _jx + 1
                ELSE
                    BEGIN
                    _ok := false;
                    FOR _kx := _sortCnt DOWNTO _jx DO
                        _sortMap[_kx+1] := _sortMap[_kx];
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
            (*ENDWHILE*) 
            _sortMap[_jx] := _ix;
            _posInfo[_ix] := viewtextbuf^.sviewtext.vttab[ _ix ].vtttab_n_pos;
            _sortCnt := _sortCnt + 1;
            a05put_identifier (_schema, _pC80^, sizeof(_c80), _pos, acv.a_returncode);
            _supplement := _supplement + _pos - 1 + a01char_size;
&           ifdef trace
            t01int4 (ak_sem, 'supplement  ', _supplement);
            FOR _kx := 1 TO _sortCnt DO
                t01int4 (ak_sem, 'sortMap     ', _sortMap[_kx]);
            (*ENDFOR*) 
&           endif
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDFOR*) 
IF  (acv.a_returncode = 0) AND (_sortCnt + _substUserCnt + _substSchemaCnt > 0)
THEN
    BEGIN
    _orig_segm      := acv.a_cmd_segm;
    _orig_cmd_part  := acv.a_cmd_part;
    _orig_len       := acv.a_cmd_part^.sp1p_buf_len;
    a542internal_packet( acv, NOT c_release_internal_packet, _orig_len + _supplement );
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        _globalDelta := 0;
        _prevPos     := 1;
        _sortIdx     := 1;
        FOR _ix := 1 TO _sortCnt + _substUserCnt + _substSchemaCnt DO
            BEGIN
            IF  _substUserCnt > 0
            THEN
                _jx := acv.a_ap_tree^[_userIdx].n_pos
            ELSE
                _jx := csp_maxint4;
            (*ENDIF*) 
            IF  _substSchemaCnt > 0
            THEN
                _sx := acv.a_ap_tree^[_schemaIdx].n_pos
            ELSE
                _sx := csp_maxint4;
            (*ENDIF*) 
            IF  _sortIdx <= _sortCnt
            THEN
                BEGIN
                _pos  := _posInfo[_sortMap[_sortIdx]];
&               ifdef trace
                t01int4 (ak_sem, 'sortIdx     ',  _sortIdx);
                t01int4 (ak_sem, '_pos        ',  _pos);
&               endif
                END
            ELSE
                _pos := csp_maxint4;
            (*ENDIF*) 
            _substUser   := (_jx < _pos) AND (_jx < _sx);
            _substSchema := (_sx < _pos) AND (_sx < _jx);
            IF  _substUser
            THEN
                BEGIN
                _pos          := _jx;
                _substUserCnt := _substUserCnt - 1;
                _userIdx      := acv.a_ap_tree^[_userIdx].n_refback;
                END
            ELSE
                IF  _substSchema
                THEN
                    BEGIN
                    _pos            := _sx;
                    _substSchemaCnt := _substSchemaCnt - 1;
                    _schemaIdx      := acv.a_ap_tree^[_schemaIdx].n_refback;
                    END
                ELSE
                    _sortIdx := _sortIdx + 1;
                (*ENDIF*) 
            (*ENDIF*) 
            _moveLen := _pos - _prevPos;
&           ifdef trace
            t01int4 (ak_sem, '_pos        ', _pos);
            t01int4 (ak_sem, '_moveLen    ', _moveLen);
&           endif
            SAPDB_PascalMove('VAK27 ',   8,    
                  _orig_len, acv.a_cmd_part^.sp1p_buf_size,
                  @_orig_cmd_part^.sp1p_buf, _prevPos,
                  @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
                  _moveLen, acv.a_returncode );
            acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + _moveLen;
            _prevPos                     := acv.a_cmd_part^.sp1p_buf_len;
            IF  _substUser
            THEN
                BEGIN
                a542identifier_to_packet( acv, acv.a_curr_user_name);
                _delta := acv.a_cmd_part^.sp1p_buf_len - _prevPos - c_user_len * a01char_size
                END
            ELSE
                IF  _substSchema
                THEN
                    BEGIN
                    a542identifier_to_packet( acv, acv.a_curr_schema);
                    _delta := acv.a_cmd_part^.sp1p_buf_len - _prevPos - c_currschema_len * a01char_size
                    END
                ELSE
                    BEGIN
                    a06_systable_get (acv, d_release, viewtextbuf^.sviewtext.vttab[ _sortMap[_sortIdx-1] ].vtttableid,
                          _pTable, true, _ok);
                    IF  _ok
                    THEN
                        BEGIN
                        a103GetSchemaName (acv, _pTable^.sbase.bschema, _schema);
                        a542identifier_to_packet( acv, _schema );
                        a542char_to_packet      ( acv, '.');
                        _delta := acv.a_cmd_part^.sp1p_buf_len - _prevPos;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            ak27new_view_pos_info( acv, _viewscanpar, viewtextbuf, c_no_col_drop, _pos + _globalDelta, _delta );
            _globalDelta := _globalDelta + _delta;
            IF  _substUser
            THEN
                _pos := _pos + c_user_len * a01char_size
            ELSE
                IF  _substSchema
                THEN
                    _pos := _pos + c_currschema_len * a01char_size;
&               ifdef trace
                (*ENDIF*) 
            (*ENDIF*) 
            t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len );
&           endif
            _prevPos := _pos
            END;
        (*ENDFOR*) 
        _moveLen := _orig_cmd_part^.sp1p_buf_len - _prevPos + 1;
        SAPDB_PascalMove('VAK27 ',   9,    
              _orig_len, acv.a_cmd_part^.sp1p_buf_size,
              @_orig_cmd_part^.sp1p_buf, _prevPos,
              @acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len + 1,
              _moveLen, acv.a_returncode );
        acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + _moveLen;
        a542release_packet( acv, _orig_segm );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27next_usage_entry (
            VAR acv           : tak_all_command_glob;
            VAR viewscanpar   : tak_viewscan_par;
            VAR usage_index   : tsp00_Int2;
            VAR linkage       : tsp00_C2;
            VAR b_err         : tgg00_BasisError);
 
BEGIN
IF  b_err = e_ok
THEN
    BEGIN
    REPEAT
        usage_index := succ( usage_index );
        IF  usage_index > acv.a_ptr6^.susage.usagecount
        THEN
            IF  acv.a_ptr6^.susage.usagenext_exist
            THEN
                (* next record exists *)
                BEGIN
                a06inc_linkage( linkage );
                usage_index := 0;
                b_err       := e_buffer_limit;
                END
            ELSE
                BEGIN
                b_err := e_sysinfo_not_found;
                END
            (*ENDIF*) 
        ELSE
            CASE  acv.a_ptr6^.susage.usagedef[ usage_index ].usa_tablekind OF
                tcomplexview :
                    BEGIN
                    IF  ( viewscanpar.vsc_type = v_alter_drop )
                        OR
                        ( viewscanpar.vsc_type = v_intern_save_scheme )
                        OR
                        ( viewscanpar.vsc_type = v_rename_column )
                        OR
                        ( viewscanpar.vsc_type = v_rename_table )
                        AND
                        (( acv.a_ptr6^.susage.usagedef[ usage_index ].
                        usa_tableid = viewscanpar.vsc_start_tabid ) OR
                        ( acv.a_ptr6^.syskey.stableid =
                        viewscanpar.vsc_start_tabid ))
                        OR
                        ( viewscanpar.vsc_type = v_revoke_priv ) AND
                        (( acv.a_ptr6^.susage.usagedef[ usage_index ].
                        usa_tableid = viewscanpar.vsc_start_tabid ) OR
                        viewscanpar.vsc_rp_rt_handling )
                        OR
                        ( viewscanpar.vsc_type = v_save_scheme )
                    THEN
                        b_err := e_use_fetch_rest;
                    (*ENDIF*) 
                    END;
                (* PTS 1111576 E.Z. *)
                tsynonym :
                    BEGIN
                    IF  ( viewscanpar.vsc_type = v_save_scheme )
                        OR
                        (( viewscanpar.vsc_type = v_revoke_priv )
                        AND viewscanpar.vsc_rp_rt_handling )
                    THEN
                        b_err := e_use_fetch_rest
                    (*ENDIF*) 
                    END
                OTHERWISE
                    b_err := e_use_fetch_rest
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
    UNTIL
        b_err <> e_ok;
    (*ENDREPEAT*) 
    IF  b_err = e_use_fetch_rest
    THEN
        IF  ( acv.a_ptr6^.susage.usagedef[ usage_index ].usa_tableid =
            viewscanpar.vsc_base_tabid )
            AND
            ( acv.a_is_ddl = ddl_create_view )
        THEN
            a07_b_put_error( acv, e_too_many_differences, 1 )
        ELSE
            b_err := e_ok
        (*ENDIF*) 
    ELSE
        a10_rel_sysinfo( acv, viewscanpar.vsc_key );
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27qual_handling (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par);
 
VAR
      _buf         : tak_sysbufferaddress;
      _vqual_ptr   : tak_sysbufferaddress;
      _vqual_key   : tgg00_SysInfoKey;
      _messkey     : tgg00_SysInfoKey;
      _i           : integer;
      _j           : integer;
      _b_err       : tgg00_BasisError;
      _upd_jv      : boolean;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    _vqual_key           := a01defaultkey;
    _vqual_key.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
    _vqual_key.sentrytyp := cak_eviewqual_basis;
    a10get_sysinfo( acv, _vqual_key, d_fix, _vqual_ptr, _b_err );
    IF  _b_err <> e_ok
    THEN
        a07_b_put_error( acv, _b_err, 1 )
    ELSE
        BEGIN
        _messkey           := _vqual_key;
        _messkey.sentrytyp := cak_epermmessblock;
        _messkey.slinkage  := cak_init_linkage;
        viewscanpar.vsc_tabno     := 1;
        viewscanpar.vsc_tabno_set := [  ];
        _upd_jv := false;
        WHILE ( viewscanpar.vsc_tabno <=
              _vqual_ptr^.sviewqual_basis.vbasetabcnt )
              AND ( NOT viewscanpar.vsc_delete_view ) AND ( _b_err = e_ok ) DO
            BEGIN
            IF  _vqual_ptr^.sviewqual_basis.vtable[ viewscanpar.vsc_tabno ].
                vtnot_used_links <> [  ]
            THEN
                _upd_jv := true;
            (*ENDIF*) 
            IF  _vqual_ptr^.sviewqual_basis.vtable[ viewscanpar.vsc_tabno ].
                vttableid = viewscanpar.vsc_base_tabid
            THEN
                BEGIN
                viewscanpar.vsc_tabno_set := viewscanpar.vsc_tabno_set +
                      [ viewscanpar.vsc_tabno ];
                IF  ( viewscanpar.vsc_type = v_index )
                THEN
                    BEGIN
                    IF  _vqual_ptr^.sviewqual_basis.vstack_exists
                    THEN
                        ak27ci_analyze_qual( acv, viewscanpar, _b_err );
                    (*ENDIF*) 
                    IF  _vqual_ptr^.sviewqual_basis.vjoin_exists
                    THEN
                        ak27vjoin_update( acv, viewscanpar, _b_err );
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            viewscanpar.vsc_tabno := succ( viewscanpar.vsc_tabno );
            END;
        (*ENDWHILE*) 
        IF  _upd_jv AND NOT viewscanpar.vsc_delete_view
        THEN
            BEGIN
            (* current view is an updatable join view ==> *)
            (* fileversion in evmessbuf records must be   *)
            (* updated                                    *)
            _i := 1;
            WHILE  ( _i <= _vqual_ptr^.sviewqual_basis.vbasetabcnt ) AND
                  ( acv.a_returncode = 0 ) DO
                BEGIN
                IF  _vqual_ptr^.sviewqual_basis.vtable[ _i ].
                    vttableid = viewscanpar.vsc_base_tabid
                THEN
                    BEGIN
                    _messkey.slinkage[ 1 ] := chr( 0 );
                    _messkey.slinkage[ 2 ] := chr( _i );
                    _j := 1;
                    WHILE ( _j <= 2 ) AND ( _b_err = e_ok ) DO
                        BEGIN
                        a10get_sysinfo( acv, _messkey, d_release, _buf, _b_err );
                        IF  _b_err = e_ok
                        THEN
                            BEGIN
                            _buf^.smessblock.mbr_mess_block.
                                  mb_qual^.mtree.fileVersion_gg00 :=
                                  viewscanpar.vsc_filevers;
                            a10repl_sysinfo( acv, _buf, _b_err );
                            END
                        ELSE
                            IF  _b_err = e_sysinfo_not_found
                            THEN
                                _b_err := e_ok;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        _messkey.slinkage[ 1 ] := chr( 1 );
                        _j := succ( _j );
                        END;
                    (*ENDWHILE*) 
                    IF  _b_err <> e_ok
                    THEN
                        a07_b_put_error( acv, _b_err, 1 );
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                _i := succ( _i );
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        IF  ( viewscanpar.vsc_type = v_statistics )
            OR
            ( viewscanpar.vsc_type = v_index )
            OR
            ( viewscanpar.vsc_type = v_rename_table )
            OR
            (( viewscanpar.vsc_type = v_version ) AND
            (( viewscanpar.vsc_init_type = v_alter_drop ) OR
            ( acv.a_init_ddl in [ ddl_add_constraint, ddl_drop_domain ] ) ) )
        THEN
            ak27base_rec_handling( acv, viewscanpar );
        (*ENDIF*) 
        a10_rel_sysinfo( acv, _vqual_key );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27vjoin_update (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            VAR b_err       : tgg00_BasisError);
 
VAR
      _jcatalog_key  : tgg00_SysInfoKey;
      _jcatalog_ptr  : tak_sysbufferaddress;
      _scatalog_key  : tgg00_SysInfoKey;
      _scatalog_ptr  : tak_sysbufferaddress;
      _i             : integer;
      _index         : integer;
      _joincnt       : integer;
      _arr_idx       : integer;
      _rec_modified  : boolean;
 
BEGIN
_jcatalog_key           := a01defaultkey;
_jcatalog_key.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
_jcatalog_key.sentrytyp := cak_eviewqual_join;
a10get_sysinfo( acv, _jcatalog_key, d_fix, _jcatalog_ptr, b_err );
IF  b_err = e_ok
THEN
    BEGIN
    (* Information about multiple index are stored in viewscanpar *)
    FOR _i := 1 TO viewscanpar.vsc_index_col_count DO
        BEGIN
        _rec_modified := false;
        _arr_idx := 1;
        _joincnt := 1;
&       ifdef trace
        t01int4( ak_sem, 'vjoincount  ', _jcatalog_ptr^.sviewqual_join.vjoincount );
&       endif
        WHILE ( _joincnt <= _jcatalog_ptr^.sviewqual_join.vjoincount ) AND
              ( b_err = e_ok ) DO
            BEGIN
            IF  _arr_idx > cak_max_viewqual_join
            THEN
                (* record overflow handling *)
                BEGIN
                IF  _rec_modified
                THEN
                    a10repl_sysinfo( acv, _jcatalog_ptr, b_err );
                (*ENDIF*) 
                a10_rel_sysinfo( acv, _jcatalog_key ); (* release actual record *)
                a06inc_linkage( _jcatalog_key.slinkage );
                a10get_sysinfo( acv, _jcatalog_key, d_fix, _jcatalog_ptr, b_err );
                _rec_modified := false;
                _arr_idx := 1;
                END;
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                BEGIN
                IF  _jcatalog_ptr^.sviewqual_join.vjoin[ _arr_idx ].
                    j1cntstack = 1
                THEN
                    BEGIN
                    _index :=  _jcatalog_ptr^.sviewqual_join.
                          vjoin[ _arr_idx ].j1startstack;
&                   ifdef trace
                    t01int4( ak_sem, '_index      ', _index );
&                   endif
                    (* get stack entry catalog record *)
                    _scatalog_key           := _jcatalog_key;
                    _scatalog_key.slinkage  := cak_init_linkage;
                    _scatalog_key.sentrytyp := cak_eviewqual_stack;
                    WHILE _index > cak_max_viewqual_stack DO
                        BEGIN
                        a06inc_linkage( _scatalog_key.slinkage );
                        _index := _index - cak_max_viewqual_stack;
                        END;
                    (*ENDWHILE*) 
                    a10get_sysinfo( acv, _scatalog_key, d_release,
                          _scatalog_ptr, b_err );
                    IF  ( b_err = e_ok ) AND
                        ak27ci_equal_stackentries(
                        _scatalog_ptr^.sviewqual_stack.vstack[ _index ],
                        viewscanpar.vsc_col_info[ _i ]^.ccolstack,
                        viewscanpar.vsc_tabno )
                    THEN
                        BEGIN
                        IF  ctmulti in
                            viewscanpar.vsc_col_info[ _i ]^.ccolpropset
                        THEN
                            _jcatalog_ptr^.sviewqual_join.vjoin[ _arr_idx ].
                                  j1propset := _jcatalog_ptr^.sviewqual_join.
                                  vjoin[ _arr_idx ].j1propset + [ jtmulti ]
                        ELSE
                            _jcatalog_ptr^.sviewqual_join.vjoin[ _arr_idx ].
                                  j1propset := _jcatalog_ptr^.sviewqual_join.
                                  vjoin[ _arr_idx ].j1propset - [ jtmulti ];
                        (*ENDIF*) 
                        _rec_modified := true;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  _jcatalog_ptr^.sviewqual_join.vjoin[ _arr_idx ].
                    j2cntstack = 1
                THEN
                    BEGIN
                    _index := _jcatalog_ptr^.sviewqual_join.vjoin[ _arr_idx ].
                          j1startstack + _jcatalog_ptr^.sviewqual_join.
                          vjoin[ _arr_idx ].j1cntstack;
                    (* get stack entry catalog record *)
                    _scatalog_key           := _jcatalog_key;
                    _scatalog_key.slinkage  := cak_init_linkage;
                    _scatalog_key.sentrytyp := cak_eviewqual_stack;
                    WHILE _index > cak_max_viewqual_stack DO
                        BEGIN
                        a06inc_linkage( _scatalog_key.slinkage );
                        _index := _index - cak_max_viewqual_stack;
                        END;
                    (*ENDWHILE*) 
                    a10get_sysinfo( acv, _scatalog_key, d_release,
                          _scatalog_ptr, b_err );
                    IF  ( b_err = e_ok ) AND
                        ak27ci_equal_stackentries(
                        _scatalog_ptr^.sviewqual_stack.vstack[ _index ],
                        viewscanpar.vsc_col_info[ _i ]^.ccolstack,
                        viewscanpar.vsc_tabno )
                    THEN
                        BEGIN
                        IF  ctmulti in
                            viewscanpar.vsc_col_info[ _i ]^.ccolpropset
                        THEN
                            _jcatalog_ptr^.sviewqual_join.vjoin[ _arr_idx ].
                                  j2propset := _jcatalog_ptr^.sviewqual_join.
                                  vjoin[ _arr_idx ].j2propset + [ jtmulti ]
                        ELSE
                            _jcatalog_ptr^.sviewqual_join.vjoin[ _arr_idx ].
                                  j2propset := _jcatalog_ptr^.sviewqual_join.
                                  vjoin[ _arr_idx ].j2propset - [ jtmulti ];
                        (*ENDIF*) 
                        _rec_modified := true;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            _arr_idx := succ( _arr_idx );
            _joincnt := succ( _joincnt );
            END;
        (*ENDWHILE*) 
        ;
        (* update last record *)
        IF  _rec_modified
        THEN
            a10repl_sysinfo( acv, _jcatalog_ptr, b_err );
        (*ENDIF*) 
        a10_rel_sysinfo( acv, _jcatalog_key );(* release last record *)
        END;
    (*ENDFOR*) 
    END;
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error( acv, b_err, 1 );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27rc_rename_columns_in_view (
            VAR acv            : tak_all_command_glob;
            VAR viewscanpar    : tak_viewscan_par;
            VAR rename_col_cnt : integer);
 
BEGIN
viewscanpar.vsc_renamed_cols := 0;
ak27base_rec_handling( acv, viewscanpar );
rename_col_cnt := viewscanpar.vsc_renamed_cols;
IF  viewscanpar.vsc_usagedef.usa_tablekind = tview
THEN
    ak27qual_handling( acv, viewscanpar );
(*ENDIF*) 
IF  viewscanpar.vsc_info_cnt > 0
THEN
    ak27dcrcrt_viewtext_manipulat( acv, vtrename_column, viewscanpar )
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27rc_rename_in_base_rec (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par);
 
VAR
      _dupl_col         : boolean;
      _owner_determined : boolean;
      _new_index        : integer;
      _col_index        : integer;
      _col_ptr          : tak00_colinfo_ptr;
      _dupl_colname     : tsp00_KnlIdentifier;
      _owner            : tsp00_KnlIdentifier;
      _colname          : tsp00_KnlIdentifier;
 
BEGIN
WITH viewscanpar, acv.a_p_arr2 DO
    BEGIN
    vsc_type          := v_version;
    _owner_determined := false;
    IF  NOT ( pbasep^.sbase.bv_viewlist )
        OR
        ( vsc_usagedef.usa_tableid = vsc_start_tabid )
    THEN
        IF  a061exist_columnname( acv.a_p_arr2.pbasep^.sbase,
            vsc_oldcolname, _col_ptr )
        THEN
            WITH _col_ptr^ DO
                IF  ( NOT ( ctviewname in ccolpropset ) AND
                    ( cextcolno in vsc_rename_set ) )
                    OR
                    ( vsc_usagedef.usa_tableid = vsc_start_tabid )
                THEN
                    BEGIN
                    IF  NOT _owner_determined
                    THEN
                        BEGIN
                        a06determine_username( acv,
                              pbasep^.sbase.bauthid, _owner );
                        _owner_determined := true
                        END;
                    (*ENDIF*) 
                    a061get_colname( _col_ptr^, _colname );
                    a061app_columnname( acv, pbasep^.sbase,
                          vsc_newcolname, _new_index );
                    IF  acv.a_returncode = 0
                    THEN
                        WITH pbasep^.sbase DO
                            BEGIN
                            a061copy_colinfo( _col_ptr^, bcolumn[ _new_index ]^);
                            _col_index := bextcolindex[ cextcolno ] +
                                  bfirstindex;
                            bcolumn[ _col_index ] := bcolumn[ _new_index ];
                            bmaxcol            := bmaxcol - 1;
                            blastindex         := blastindex - 1;
                            vsc_renamed_cols   := 1;
                            vsc_type           := v_rename_column;
                            vsc_rename_set     := [ cextcolno ];
                            a061sort( acv, acv.a_p_arr2.pbasep^.sbase, 0,
                                  _dupl_col, _dupl_colname );
                            IF  _dupl_col
                            THEN
                                a07_nb_put_error( acv,
                                      e_duplicate_columnname,
                                      1, _dupl_colname )
                            ELSE
                                BEGIN
                                a16new_bextcolindex( pbasep^.sbase );
                                a11sort( pbasep^.sbase );
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27rename_in_buf (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            viewtext_ptr    : tak_sysbufferaddress;
            pos             : integer;
            VAR new_name    : tsp00_KnlIdentifier;
            VAR diff        : integer);
 
VAR
      _i          : integer;
      _old_len    : integer;
      _new_len    : tsp00_Int4;
      _id_pos     : tsp00_Int4;
      _vp_ptr     : tsp00_MoveObjPtr;
      _aux        : tsp00_Buf;
 
BEGIN
&ifdef TRACE
t01int4( ak_sem, 'pos=        ', pos );
t01lidentifier( ak_sem, new_name );
&endif
_vp_ptr := @_aux;
IF  a01equal_char( acv.a_cmd_part^.sp1p_buf, pos - a01char_size, '"')
THEN
    (* identifier defined with quotes *)
    pos := pos - a01char_size;
(*ENDIF*) 
acv.a_scv.sc_newpos := pos;
a01_next_symbol( acv );
_old_len := acv.a_scv.sc_sylength + 2 * acv.a_scv.sc_double_quote;
_new_len := 1;
a05put_identifier( new_name, _vp_ptr^, sizeof( _aux ), _new_len,
      acv.a_returncode );
_new_len := _new_len - 1;
diff    := _new_len - _old_len;
&ifdef trace
t01int4( ak_sem, 'old_len     ', _old_len );
t01int4( ak_sem, 'new_len     ', _new_len );
t01int4( ak_sem, 'diff        ', diff );
&endif
IF  acv.a_cmd_part^.sp1p_buf_len + diff > acv.a_cmd_part^.sp1p_buf_size
THEN
    a07_b_put_error( acv, e_too_small_packet_size, 1 )
ELSE
    BEGIN
    IF  diff < 0
    THEN
        SAPDB_PascalOverlappingMove('VAK27 ',  10,    
              acv.a_cmd_part^.sp1p_buf_size, acv.a_cmd_part^.sp1p_buf_size,
              @acv.a_cmd_part^.sp1p_buf, pos + _old_len,
              @acv.a_cmd_part^.sp1p_buf, pos + _new_len,
              acv.a_cmd_part^.sp1p_buf_len - ( pos + _old_len ) + 1,
              acv.a_returncode )
    ELSE
        IF  diff > 0
        THEN(* movcback is defined on buffer => *)
            (* cannot be used on variab_part     *)
            FOR _i := acv.a_cmd_part^.sp1p_buf_len DOWNTO pos DO
                acv.a_cmd_part^.sp1p_buf [ _i + diff ] :=
                      acv.a_cmd_part^.sp1p_buf [ _i ];
            (*ENDFOR*) 
        (*ENDIF*) 
    (*ENDIF*) 
    _id_pos := pos;
    a05put_identifier( new_name, acv.a_cmd_part^.sp1p_buf,
          acv.a_cmd_part^.sp1p_buf_size, _id_pos,
          acv.a_returncode );
    acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len + diff;
&   ifdef trace
    t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf, 1,
          acv.a_cmd_part^.sp1p_buf_len );
&   endif
    ak27new_view_pos_info( acv, viewscanpar, viewtext_ptr, c_no_col_drop,
          pos, diff )
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27scan_syntax_tree (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            VAR curr_name   : tsp00_KnlIdentifier;
            node            : integer);
 
VAR
      _ix : integer;
 
BEGIN
WHILE node <> 0 DO
    WITH acv, a_ap_tree^[ node ] DO
        BEGIN
        IF  n_symb = s_authid
        THEN
            BEGIN
            a05identifier_get( acv, node, sizeof( curr_name ),
                  curr_name );
            IF  curr_name = viewscanpar.vsc_old_user_name
            THEN
                BEGIN
                _ix := 0;
                WHILE a_ap_tree^[ a_ap_tree^[ _ix ].n_refback ].n_pos <
                      n_pos DO
                    _ix := a_ap_tree^[ _ix ].n_refback;
                (*ENDWHILE*) 
                n_refback                   := a_ap_tree^[ _ix ].n_refback;
                a_ap_tree^[ _ix ].n_refback := node;
&               ifdef trace
                t01int4( ak_sem, 'ix          ', _ix );
                _ix := 0;
                WHILE _ix <> 1 DO
                    BEGIN
                    t01int4( ak_sem, 'list        ',
                          a_ap_tree^[ _ix ].n_refback );
                    _ix := a_ap_tree^[ _ix ].n_refback;
                    END;
                (*ENDWHILE*) 
&               endif
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ak27scan_syntax_tree( acv,
              viewscanpar, curr_name, n_sa_level );
        node := n_lo_level;
        END;
    (*ENDWITH*) 
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27rp_handling (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par);
 
VAR
      _ok          : boolean;
      _check_table : boolean;
      _b_err       : tgg00_BasisError;
      _viewowner   : tgg00_Surrogate;
      _syskey      : tgg00_SysInfoKey;
      _catalog_ptr : tak_sysbufferaddress;
      _priv        : tak_privilege;
 
BEGIN
_ok               := false;
_check_table      := false;
_syskey           := a01defaultkey;
_syskey.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
a10get_sysinfo( acv, _syskey, d_fix, _catalog_ptr, _b_err );
IF  _b_err <> e_ok
THEN
    a07_b_put_error( acv, _b_err, 1 )
ELSE
    BEGIN
    IF  viewscanpar.vsc_usagedef.usa_tablekind = tsynonym
    THEN
        BEGIN
        WITH _catalog_ptr^.ssynonym DO
            a06_systable_get( acv, d_fix, syn_tableid,
                  acv.a_p_arr2.pbasep, NOT c_get_all, _ok );
        (*ENDWITH*) 
        IF  _ok
        THEN
            BEGIN
            a06user_get_priv( acv, acv.a_p_arr2.pbasep,
                  _catalog_ptr^.ssynonym.syn_authid, _priv );
            IF  ( _priv.priv_all_set = [  ] ) AND
                ( _priv.priv_col_exist = [  ] )
            THEN
                viewscanpar.vsc_delete_view := true;
            (*ENDIF*) 
            a10_rel_sysinfo( acv, acv.a_p_arr2.pbasep^.syskey );
            END
        ELSE
            a07ak_system_error( acv, 27, 1 );
        (*ENDIF*) 
        END
    ELSE
        BEGIN
&       ifdef trace
        t01buf1( ak_sem, _catalog_ptr^, 1, _catalog_ptr^.b_sl );
&       endif
        _viewowner := _catalog_ptr^.sbase.bauthid;
        ak27dropped_columns( acv, _viewowner, viewscanpar );
        IF  NOT viewscanpar.vsc_delete_view AND
            ( viewscanpar.vsc_usagedef.usa_tablekind <> tcomplexview )
        THEN
            ak27privilege( acv, viewscanpar );
        (*ENDIF*) 
        viewscanpar.vsc_col_dropped := false;
        END;
    (*ENDIF*) 
    a10_rel_sysinfo( acv, _syskey );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27check_fk (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            VAR vqual_ptr   : tak_sysbufferaddress);
 
CONST
      c_found = -1;
 
VAR
      _fk_buf   : tak_sysbufferaddress;
      _sysk     : tgg00_SysInfoKey;
      _ix       : integer;
      _fk_cnt   : integer;
      _fk_index : integer;
      _b_err    : tgg00_BasisError;
 
BEGIN
_ix := 1;
WHILE  ( _ix < vqual_ptr^.sviewqual_basis.vbasetabcnt ) AND
      ( NOT viewscanpar.vsc_delete_view ) DO
    BEGIN
    IF  vqual_ptr^.sviewqual_basis.vtable[ _ix + 1 ].vttableid =
        viewscanpar.vsc_base_tabid
    THEN
        BEGIN
        _sysk           := a01defaultkey;
        _sysk.stableid  := vqual_ptr^.sviewqual_basis.vtable[ _ix ].vttableid;
        _sysk.sentrytyp := cak_eforeignkey;
        _fk_cnt         := cak_is_undefined;
        _fk_index       := 1;
        REPEAT
            a10get_sysinfo( acv, _sysk, d_release, _fk_buf, _b_err );
            IF  _b_err = e_ok
            THEN
                WITH _fk_buf^.slink DO
                    BEGIN
                    IF  _fk_cnt = cak_is_undefined
                    THEN
                        _fk_cnt := linkcount;
                    (*ENDIF*) 
                    IF  linkdef[ _fk_index ].ltableid =
                        viewscanpar.vsc_base_tabid
                    THEN
                        _fk_cnt := c_found
                    ELSE
                        _fk_cnt := _fk_cnt - 1;
                    (*ENDIF*) 
                    IF  _fk_index = cak_maxlinkdef
                    THEN
                        BEGIN
                        _fk_index := 1;
                        a06inc_linkage( _sysk.slinkage );
                        END
                    ELSE
                        _fk_index := succ( _fk_index );
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
        UNTIL
            _fk_cnt <= 0;
        (*ENDREPEAT*) 
        IF  _fk_cnt = cak_is_undefined
        THEN
            BEGIN
            IF  _b_err <> e_sysinfo_not_found
            THEN
                a07_b_put_error( acv, _b_err, 1 );
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        viewscanpar.vsc_delete_view := ( _fk_cnt <> c_found );
        END;
    (*ENDIF*) 
    _ix := succ( _ix );
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27privilege (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par);
 
VAR
      _vqual_ptr    : tak_sysbufferaddress;
      _privusr_ptr  : tak_sysbufferaddress;
      _viewtext_ptr : tak_sysbufferaddress;
      _from_ptr     : tak_sysbufferaddress;
      _owner        : tsp00_KnlIdentifier;
      _priv         : tak_privilege;
      _oldpriv      : tak_privilege;
      _sysk         : tgg00_SysInfoKey;
      _viewtext_key : tgg00_SysInfoKey;
      _i            : tak_priv_descriptors;
      _cascade      : boolean;
      _b_err        : tgg00_BasisError;
 
BEGIN
IF  acv.a_returncode = 0 (* PTS 1112924 *)
THEN
    BEGIN
    _sysk            := acv.a_p_arr2.pbasep^.syskey;
    _sysk.sentrytyp  := cak_eviewqual_basis;
    a10get_sysinfo( acv, _sysk, d_fix, _vqual_ptr, _b_err );
    IF  _b_err = e_ok
    THEN
        BEGIN
        _sysk.sentrytyp  := cak_eprivuser;
        _sysk.suserid    := acv.a_p_arr2.pbasep^.sbase.bauthid;
        _sysk.sgrantuser := _sysk.suserid;
        _sysk.skeylen    := _sysk.skeylen + 2 * SURROGATE_MXGG00;
        a10_fix_len_get_sysinfo( acv, _sysk, d_fix,
              sizeof( tak_privuserrecord ), 0, _privusr_ptr, _b_err );
        END;
    (*ENDIF*) 
    IF  _b_err = e_ok
    THEN
        BEGIN
        _oldpriv := a01emptypriv;
        a06unpack_priv( _privusr_ptr^.sprivuser.pru_priv, _oldpriv );
&       IFDEF TRACE
        a06td_priv( _oldpriv, 'oldpriv           ' , true );
&       ENDIF
        IF  ( acv.a_p_arr2.pbasep^.sbase.btablekind = tview ) AND
            ( acv.a_p_arr2.pbasep^.sbase.bv_checkopt)         AND (* PTS 1112213 *)
            (([ r_del, r_ins, r_upd ] * _oldpriv.priv_all_set <> []) OR
            ( _oldpriv.priv_upd_set <> []))
        THEN
            ak27check_fk( acv, viewscanpar, _vqual_ptr );
        (*ENDIF*) 
        IF  NOT viewscanpar.vsc_delete_view
        THEN
            BEGIN
            _viewtext_key           := a01defaultkey;
            _viewtext_key.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
            _viewtext_key.sentrytyp := cak_eviewtext;
            a10get_sysinfo( acv, _viewtext_key, d_fix, _viewtext_ptr, _b_err );
            IF  _b_err = e_ok
            THEN
                BEGIN
                _priv := _oldpriv;
                a16privrec_build( acv, acv.a_p_arr2.pbasep, _from_ptr,
                      _viewtext_ptr, _vqual_ptr, _priv, true (* PTS 1112924 *) );
                a10_rel_sysinfo( acv, _viewtext_key );
&               IFDEF TRACE
                a06td_priv( _priv, 'newpriv           ' , true );
&               ENDIF
                IF  _priv.priv_c196 <> _oldpriv.priv_c196
                THEN
                    WITH acv.a_p_arr2.pbasep^.sbase DO
                        BEGIN
                        a06determine_username( acv, bauthid, _owner );
                        a22add_priv_rec( acv, acv.a_p_arr2.pbasep,
                              _priv, _privusr_ptr, false, _cascade );
                        IF  _cascade
                        THEN
                            BEGIN
                            _priv.priv_all_set := _oldpriv.priv_all_set -
                                  _priv.priv_all_set;
                            _priv.priv_all_grant_set :=
                                  _oldpriv.priv_all_grant_set -
                                  _priv.priv_all_grant_set;
                            FOR _i := priv_col_sel TO priv_col_upd_grant DO
                                _priv.priv_col[ _i ] := _oldpriv.priv_col[ _i ] -
                                      _priv.priv_col[ _i ];
                            (*ENDFOR*) 
                            a22revoke_cascade( acv, acv.a_p_arr2.pbasep,
                                  viewscanpar.vsc_valid_colset, bauthid, _priv );
                            END;
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                ELSE
                    IF  NOT ( viewscanpar.vsc_col_dropped )
                    THEN
                        viewscanpar.vsc_type := v_version;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a10_rel_sysinfo( acv, _sysk );
        END;
    (*ENDIF*) 
    IF  _b_err <> e_ok
    THEN
        a07_b_put_error( acv, _b_err, 1 );
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27dropped_columns (
            VAR acv         : tak_all_command_glob;
            VAR viewowner   : tgg00_Surrogate;
            VAR viewscanpar : tak_viewscan_par);
 
CONST
      c_dummy_bool = false;
 
VAR
      _viewtext_ptr : tak_sysbufferaddress;
      _tabno        : integer;
      _drop_cnt     : integer;
      _owner_id     : tgg00_Surrogate;
      _syskey       : tgg00_SysInfoKey;
      _priv         : tak_privilege;
      _ok           : boolean;
      _b_err        : tgg00_BasisError;
 
BEGIN
IF  acv.a_returncode = 0 (* PTS 1112924 *)
THEN
    BEGIN
    _syskey           := a01defaultkey;
    _syskey.stableid  := viewscanpar.vsc_usagedef.usa_tableid;
    _syskey.sentrytyp := cak_eviewtext;
    a10get_sysinfo( acv, _syskey, d_fix, _viewtext_ptr, _b_err );
    IF  _b_err = e_ok
    THEN
        ak27get_viewdesc( acv, viewscanpar, _b_err );
    (*ENDIF*) 
    IF  _b_err = e_ok
    THEN
        WITH _viewtext_ptr^.sviewtext DO
            BEGIN
            _tabno        := 1;
            viewscanpar.vsc_drop_set := [  ];
            _drop_cnt     := 0;
            WHILE ( _tabno <= vttabcount ) AND
                  NOT ( viewscanpar.vsc_delete_view ) DO
                WITH vttab[ _tabno ] DO
                    BEGIN
                    a06_systable_get( acv, d_release, vtttableid,
                          acv.a_p_arr2.pbasep, c_get_all, _ok );
                    IF  _ok
                    THEN
                        BEGIN
                        _owner_id := viewowner;
                        a06user_get_priv( acv, acv.a_p_arr2.pbasep,
                              _owner_id, _priv );
                        IF  NOT ( r_sel in _priv.priv_all_set ) AND
                            NOT ( priv_col_sel in _priv.priv_col_exist )
                        THEN
                            viewscanpar.vsc_delete_view := true
                        ELSE
                            ak27rp_det_dropped_cols( acv,
                                  viewscanpar, _tabno, _priv,_drop_cnt );
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    _tabno := succ( _tabno );
                    END;
                (*ENDWITH*) 
            (*ENDWHILE*) 
            viewscanpar.vsc_col_dropped := _drop_cnt > 0;
&           ifdef trace
            t01int4( ak_sem, 'drop_cnt    ', _drop_cnt );
            t01int4( ak_sem, 'vsc_col_drop', ord( viewscanpar.vsc_col_dropped ));
&           endif
            ak27dc_drop_col( acv, cak_is_undefined, c_dummy_bool, viewscanpar );
            a10_rel_sysinfo( acv, _syskey );
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27rp_det_dropped_cols (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            tabno           : integer;
            VAR priv        : tak_privilege;
            VAR drop_cnt    : integer);
 
VAR
      _j : integer;
      _k : integer;
 
BEGIN
FOR _j := acv.a_p_arr2.pbasep^.sbase.bfirstindex TO
      acv.a_p_arr2.pbasep^.sbase.blastindex DO
    WITH acv.a_p_arr2.pbasep^.sbase.bcolumn[ _j ]^ DO
        BEGIN
        _k     := 1;
        WHILE ( _k <= acv.a_ptr8^.sviewdesc.vdesc_cnt ) AND
              NOT( viewscanpar.vsc_delete_view ) DO
            WITH acv.a_ptr8^.sviewdesc.vdescription[ _k ] DO
                BEGIN
                IF  ( vfromextcolno = cextcolno )
                    AND ( vfromtabno = tabno )
                THEN
                    IF  ( ctdropped in ccolpropset )   OR
                        ( ctinvisible in ccolpropset ) OR
                        ( NOT( cextcolno in priv.priv_sel_set )
                        AND
                        NOT ( r_sel in priv.priv_all_set ))
                    THEN
                        IF  vextcolno = 0
                        THEN
                            viewscanpar.vsc_delete_view := true
                        ELSE
                            IF  NOT ( vextcolno in viewscanpar.vsc_drop_set )
                            THEN
                                BEGIN
                                drop_cnt := succ( drop_cnt );
                                viewscanpar.vsc_drop_set :=
                                      viewscanpar.vsc_drop_set + [ vextcolno ];
&                               ifdef trace
                                t01int4( ak_sem, 'drop_col    ',
                                      vextcolno );
&                               endif
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                _k := succ( _k );
                END;
            (*ENDWITH*) 
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27rt_analyze_col_definitions (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            viewtext_ptr    : tak_sysbufferaddress;
            tabno           : integer);
 
VAR
      i          : integer;
      add        : integer;
      pos_info   : tak27_own_tab_col_info;
 
BEGIN
FOR i := 1 TO acv.a_ptr8^.sviewdesc.vdesc_cnt DO
    WITH acv.a_ptr8^.sviewdesc.vdescription[ i ] DO
        IF  ( vfromtabno = tabno ) AND ( vn_pos <> 0 )
        THEN
            BEGIN (* vn_pos points to column name *)
            ak27get_pos_info( acv, abs( vn_pos ), pos_info );
            IF  (viewscanpar.vsc_new_authname <> a01_il_b_identifier ) AND
                (pos_info.otc_own_pos <> cak_is_undefined)
            THEN
                BEGIN
                ak27rename_in_buf( acv, viewscanpar, viewtext_ptr,
                      pos_info.otc_own_pos, viewscanpar.vsc_new_authname, add );
                pos_info.otc_tab_pos := pos_info.otc_tab_pos + add
                END;
            (*ENDIF*) 
            IF  pos_info.otc_tab_pos <> cak_is_undefined
            THEN
                BEGIN
                ak27rename_in_buf( acv, viewscanpar, viewtext_ptr,
                      pos_info.otc_tab_pos, viewscanpar.vsc_new_tablen, add );
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27rt_handling (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par);
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  viewscanpar.vsc_usagedef.usa_tablekind = tonebase
    THEN
        ak27base_rec_handling( acv, viewscanpar );
    (*ENDIF*) 
    IF  ( viewscanpar.vsc_usagedef.usa_tablekind <> tsynonym ) OR
        ( acv.a_is_ddl = ddl_rename_synonym )
    THEN
        ak27dcrcrt_viewtext_manipulat( acv, vtrename_table, viewscanpar );
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27view_definition_to_sysinfo (
            VAR acv          : tak_all_command_glob;
            VAR viewscanpar  : tak_viewscan_par;
            VAR viewtext_ptr : tak_sysbufferaddress; (*in/out*)
            bufcnt           : integer);
 
VAR
      _b_err      : tgg00_BasisError;
      _dstate     : tak_directory_state;
      _ppos       : integer;
      _vpos       : integer;
      _cnt        : integer;
      _plus       : integer;
      _movelen    : integer;
      _i          : integer;
      _syspointer : tak_sysbufferaddress;
      _syskey     : tgg00_SysInfoKey;
 
BEGIN
_ppos   := 1;
_cnt    := 0;
_dstate := d_fix;
_syskey := viewtext_ptr^.syskey;
REPEAT
    IF  _cnt + 1 < bufcnt
    THEN
        _plus := 0
    ELSE
        _plus := sizeof( tak_viewtextrecord );
    (*ENDIF*) 
    IF  _cnt < bufcnt
    THEN
        BEGIN
        a10_fix_len_get_sysinfo( acv, _syskey, _dstate,
              _plus, 0, _syspointer, _b_err );
        IF  _cnt = 0
        THEN
            BEGIN
            viewtext_ptr := _syspointer;
            _dstate      := d_release;
            END
        (*ENDIF*) 
        END
    ELSE
        a10_nil_get_sysinfo( acv, _syskey, d_release, _plus, _syspointer, _b_err );
    (*ENDIF*) 
    IF  _b_err = e_ok
    THEN
        WITH _syspointer^.sviewtext DO
            BEGIN
            _cnt := succ( _cnt );
            IF  _cnt > bufcnt
            THEN
                BEGIN
                vttabcount   := 0;
                vtselect_pos := 0;
                END;
            (*ENDIF*) 
            _vpos := vttabcount * mxak_vttabdef + 1;
            IF  acv.a_cmd_part^.sp1p_buf_len - _ppos <= mxak_viewtext - _vpos
            THEN
                _movelen := acv.a_cmd_part^.sp1p_buf_len - _ppos + 1
            ELSE
                _movelen := mxak_viewtext - _vpos + 1;
            (*ENDIF*) 
            SAPDB_PascalMove('VAK27 ',  11,    
                  acv.a_cmd_part^.sp1p_buf_size, sizeof( vttbuf ),
                  @acv.a_cmd_part^.sp1p_buf, _ppos,
                  @vttbuf, _vpos, _movelen, _b_err );
            _ppos         := _ppos + _movelen;
            vttextlength := _movelen;
            vtnextexist  := ( _ppos <= acv.a_cmd_part^.sp1p_buf_len );
            _syspointer^.b_sl := mxak_standard_sysk + cgg_rec_key_offset +
                  mxak_viewtext_offset + _vpos + _movelen - 1;
            IF  _b_err = e_ok
            THEN
                IF  _cnt > bufcnt
                THEN
                    a10add_sysinfo  ( acv, _syspointer, _b_err )
                ELSE
                    a10repl_sysinfo( acv, _syspointer, _b_err );
                (*ENDIF*) 
            (*ENDIF*) 
            a06inc_linkage( _syskey.slinkage )
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
UNTIL
    ( _ppos > acv.a_cmd_part^.sp1p_buf_len ) OR ( _b_err <> e_ok );
(*ENDREPEAT*) 
IF  _b_err = e_ok
THEN
    IF  _cnt < bufcnt
    THEN
        FOR _i := _cnt + 1 TO bufcnt DO
            BEGIN
            _syskey.slinkage[ 2 ] := chr( _i );
            a10del_sysinfo( acv, _syskey, _b_err );
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  _b_err = e_ok
THEN
    ak27store_vdesc( acv, viewscanpar )
ELSE
    a07_b_put_error( acv, _b_err, 1 );
(*ENDIF*) 
a542pop_packet( acv );
END;
 
(*------------------------------*) 
 
FUNCTION
      ak27unique (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            viewlevel_cnt   : integer) : boolean;
 
VAR
      _all_catalog_save : boolean;
      _site             : tgg00_ServerdbNo;
      _lkey             : tgg00_Lkey;
      _rec_buf          : tgg00_Rec;
 
BEGIN
ak27unique := false;
SAPDB_PascalForcedMove( sizeof( viewscanpar.vsc_usagedef ), sizeof( _rec_buf.info ),
      @viewscanpar.vsc_usagedef, 1,
      @_rec_buf.info, 1, SURROGATE_MXGG00 );
_rec_buf.keylen   := SURROGATE_MXGG00;
_rec_buf.len      := SURROGATE_MXGG00 + cgg_rec_key_offset;
_rec_buf.recVarcolOffset_gg00 := 0;
_rec_buf.recVarcolCnt_gg00    := 0;
_all_catalog_save := false;
IF  viewscanpar.vsc_type = v_save_scheme
THEN
    IF  viewscanpar.vsc_all_save
    THEN
        _all_catalog_save := true;
    (*ENDIF*) 
(*ENDIF*) 
IF  _all_catalog_save
THEN
    BEGIN
    _rec_buf.info[ SURROGATE_MXGG00 + 1 ] := chr( viewlevel_cnt );
    _site := cgg_zero_c2;
    _rec_buf.info[ SURROGATE_MXGG00 + 2 ] := _site[ 1 ];
    _rec_buf.info[ SURROGATE_MXGG00 + 3 ] := _site[ 2 ];
    _rec_buf.len := _rec_buf.len + 3;
    END;
(*ENDIF*) 
b07cadd_record( acv.a_transinf.tri_trans, acv.a_into_tree, _rec_buf );
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    ak27unique := NOT _all_catalog_save
ELSE
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_duplicate_key
    THEN
        a07_b_put_error( acv, acv.a_transinf.tri_trans.trError_gg00, 1 )
    ELSE
        IF  _all_catalog_save
        THEN
            BEGIN
            _lkey.len := SURROGATE_MXGG00;
            SAPDB_PascalForcedMove( sizeof( viewscanpar.vsc_usagedef.usa_tableid ),
                  sizeof( _lkey.k ),
                  @viewscanpar.vsc_usagedef.usa_tableid, 1, @_lkey.k, 1,
                  sizeof( viewscanpar.vsc_usagedef.usa_tableid ) );
            b07cget_record( acv.a_transinf.tri_trans,
                  acv.a_into_tree, _lkey, _rec_buf );
            IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
            THEN
                IF  ord( _rec_buf.info[ SURROGATE_MXGG00 + 1 ] ) < viewlevel_cnt
                THEN
                    BEGIN
                    _rec_buf.info[ SURROGATE_MXGG00 + 1 ] := chr( viewlevel_cnt );
                    b07crepl_record( acv.a_transinf.tri_trans,
                          acv.a_into_tree, _rec_buf );
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
            THEN
                a07_b_put_error( acv, acv.a_transinf.tri_trans.trError_gg00, 1 )
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27view_scan   (
            VAR acv         : tak_all_command_glob;
            tableid         : tgg00_Surrogate;
            viewlevel_cnt   : integer;
            VAR viewscanpar : tak_viewscan_par);
      (* tableid, loc, viewlevel_cnt must be const parameter, because *)
      (* procedure calls itself recursively                           *)
 
CONST
      c_unknown_sequence = true;
 
VAR
      _columns_dropped  : boolean;
      _handled          : boolean;
      _rp_rt_handling   : boolean;
      _do_cascade       : boolean;
      _init_vsc_type    : tak_viewscantype;
      _view_col_list    : boolean;
      _b_err            : tgg00_BasisError;
      _udefcnt          : tsp00_Int2;
      _linkage          : tsp00_C2;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef TRACE
    ak27trace_vsc_type( acv, 'vsc_type    ', viewscanpar.vsc_type );
    t01tabid( ak_sem, 'revoke_tabid', viewscanpar.vsc_start_tabid );
&   endif
    IF  ( viewscanpar.vsc_type = v_rename_table )  OR
        ( viewscanpar.vsc_type = v_rename_column ) OR
        ( viewscanpar.vsc_type = v_revoke_priv )
    THEN
        IF  NOT ( viewscanpar.vsc_rp_rt_handling )
        THEN
            IF  tableid = viewscanpar.vsc_start_tabid
            THEN
                viewscanpar.vsc_rp_rt_handling := true;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    _columns_dropped := viewscanpar.vsc_col_dropped;
    _view_col_list   := viewscanpar.vsc_col_list;
&   ifdef TRACE
    t01bool( ak_sem, 'columns_drop', _columns_dropped );
&   endif
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    _linkage := cak_init_linkage;
    _udefcnt := 0;
    REPEAT
&       ifdef TRACE
        ak27trace_vsc_type( acv, 'vsc_type    ', viewscanpar.vsc_type );
&       endif
        (* get usage information for tableid -> acv.a_ptr6 *)
        viewscanpar.vsc_key           := a01defaultkey;
        viewscanpar.vsc_key.stableid  := tableid;
        viewscanpar.vsc_key.sentrytyp := cak_eusage;
        viewscanpar.vsc_key.slinkage  := _linkage;
        a10get_sysinfo( acv, viewscanpar.vsc_key, d_fix, acv.a_ptr6, _b_err );
        ak27next_usage_entry( acv,viewscanpar, _udefcnt, _linkage, _b_err );
        IF  _b_err = e_ok
        THEN
            WITH viewscanpar DO
                BEGIN
                _init_vsc_type   := vsc_type;
                vsc_delete_view  := false;
                vsc_col_dropped  := false;
                vsc_from_tableid := tableid;
                vsc_usagedef     := acv.a_ptr6^.susage.usagedef[ _udefcnt ];
                acv.a_ptr8       := NIL;
                _handled         := true;
                _do_cascade      := true;
                _rp_rt_handling  := vsc_rp_rt_handling;
&               ifdef trace
                t01lidentifier( ak_sem, vsc_baseauthname );
                t01lidentifier( ak_sem, vsc_basetablen );
                ak27trace_vsc_type( acv, 'vsc_type    ', viewscanpar.vsc_type );
                t01int4( ak_sem, 'usa_tablekin',
                      ord( vsc_usagedef.usa_tablekind ) );
&               endif
                CASE vsc_type OF
                    v_rename_table :
                        BEGIN
                        IF  vsc_usagedef.usa_tableid = vsc_start_tabid
                        THEN
                            BEGIN
                            _rp_rt_handling := false;
                            IF  vsc_usagedef.usa_tablekind <> tsynonym
                            THEN
                                ak27dcrcrt_viewtext_manipulat( acv,
                                      vtrename_view, viewscanpar );
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  tableid = vsc_start_tabid
                        THEN
                            BEGIN
                            (* only views defined directly on *)
                            (* renamed table must be analyzed *)
                            ak27rt_handling( acv, viewscanpar );
                            (* PTS 1111576 E.Z. *)
                            END
                        ELSE
                            IF  vsc_usagedef.usa_tablekind <> tcomplexview
                            THEN
                                _handled := false;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    v_rename_user :
                        BEGIN
                        _do_cascade := false;
                        a27rename_user( acv, viewscanpar );
                        END;
                    v_save_scheme, v_intern_save_scheme :
                        IF  ak27unique( acv, viewscanpar, viewlevel_cnt )
                        THEN
                            a15one_table_catalog( acv, viewlevel_cnt,
                                  NOT c_unknown_sequence, viewscanpar );
                        (*ENDIF*) 
                    v_revoke_priv :
                        BEGIN
                        IF  vsc_usagedef.usa_tableid = vsc_start_tabid
                        THEN
                            _rp_rt_handling := false;
                        (*ENDIF*) 
                        IF  vsc_rp_rt_handling
                        THEN
                            ak27rp_handling( acv, viewscanpar )
                        ELSE
                            IF  vsc_usagedef.usa_tablekind <> tcomplexview
                            THEN
                                _handled := false;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    v_rename_column :
                        BEGIN
                        IF  vsc_usagedef.usa_tableid = vsc_start_tabid
                        THEN
                            BEGIN
                            vsc_col_list    := _view_col_list;
                            _rp_rt_handling := false;
                            ak27dcrcrt_viewtext_manipulat( acv,
                                  vtrename_view_column, viewscanpar );
                            a13add_dropped_columns( acv,
                                  viewlevel_cnt, viewscanpar );
                            vsc_col_dropped  := false;
                            _columns_dropped := true;
                            _handled         := false
                            END;
                        (*ENDIF*) 
                        IF  vsc_rp_rt_handling
                        THEN
                            ak27dcrc_analyze_columns( acv,
                                  viewlevel_cnt, true, viewscanpar )
                        ELSE
                            _handled := false
                        (*ENDIF*) 
                        END;
                    v_alter_drop :
                        ak27dc_drop_col( acv, viewlevel_cnt, _columns_dropped,
                              viewscanpar );
                    OTHERWISE
                        (* PTS 1111576 E.Z. *)
                        _handled := false;
                    END;
                (*ENDCASE*) 
                IF  NOT _handled
                THEN
                    IF  ( vsc_usagedef.usa_tablekind = tonebase ) AND
                        ( vsc_type <> v_index )
                    THEN
                        BEGIN
                        (* current view references one base table *)
                        (* and not called by create index         *)
                        vsc_tabno_set := [ 1 ];
                        vsc_tabno     := 1;
                        ak27base_rec_handling( acv, viewscanpar )
                        END
                    ELSE
                        IF  vsc_usagedef.usa_tablekind <> tcomplexview
                        THEN
                            ak27qual_handling( acv, viewscanpar )
                        ELSE
                            ak27base_rec_handling( acv, viewscanpar );
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                a10release_table( acv,
                      acv.a_ptr6^.susage.usagedef[ _udefcnt ].usa_tableid );
                a10_rel_sysinfo( acv, vsc_key );
                IF  vsc_delete_view
                THEN
                    IF  vsc_restrict
                    THEN
                        BEGIN
                        (* restrict option specified, *)
                        (* return error               *)
                        a06_systable_get( acv, d_release,
                              acv.a_ptr6^.susage.
                              usagedef[ _udefcnt ].usa_tableid,
                              acv.a_p_arr2.pbasep, NOT c_get_all, _handled );
                        IF  _handled
                        THEN
                            vsc_basetablen :=
                                  acv.a_p_arr2.pbasep^.sbase.btablen^
                        ELSE
                            vsc_basetablen :=
                                  a01_il_b_identifier;
                        (*ENDIF*) 
                        a07_nb_put_error( acv, e_use_cascade, 1,
                              vsc_basetablen )
                        END
                    ELSE
                        BEGIN
                        IF  vsc_col_dropped
                        THEN
                            ak27del_dropcol_info( acv, viewlevel_cnt );
                        (*ENDIF*) 
                        a11drop_table( acv, acv.a_ptr6^.susage.
                              usagedef[ _udefcnt ].usa_tableid, acv.a_ptr6^.
                              susage.usagedef[ _udefcnt ].usa_tablekind, false );
                        _udefcnt := pred( _udefcnt );
                        END
                    (*ENDIF*) 
                ELSE
                    IF  _do_cascade
                    THEN
                        ak27view_scan( acv, acv.a_ptr6^.susage.
                              usagedef[ _udefcnt ].usa_tableid,
                              viewlevel_cnt + 1, viewscanpar );
                    (*ENDIF*) 
                (*ENDIF*) 
                vsc_col_dropped    := _columns_dropped;
                vsc_rp_rt_handling := _rp_rt_handling;
                vsc_type           := _init_vsc_type
                END
            (*ENDWITH*) 
        ELSE
            IF  _b_err = e_buffer_limit
            THEN
                _b_err := e_ok
            ELSE
                IF  _columns_dropped
                THEN
                    ak27del_dropcol_info( acv, viewlevel_cnt - 1 );
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    UNTIL
        ( _b_err <> e_ok ) OR ( acv.a_returncode <> 0 );
    (*ENDREPEAT*) 
    IF  _b_err <> e_sysinfo_not_found
    THEN
        a07_b_put_error( acv, _b_err, 1 );
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a27init_viewscanpar (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            v_type          : tak_viewscantype);
 
VAR
      _i : integer;
 
BEGIN
WITH viewscanpar DO
    BEGIN
    vsc_baseauthname      := a01_il_b_identifier;
    vsc_basetablen        := a01_il_b_identifier;
    vsc_filevers.ci2_gg00 := cgg_dummy_file_version;
    vsc_rp_rt_handling := false;
    vsc_init_type      := v_type;
    vsc_base_tabid     := cgg_zero_id;
    vsc_key            := a01defaultkey;
    vsc_edi            := false;
    vsc_ti             := 0;
    vsc_tabno          := 0;
    vsc_restrict       := false;
    vsc_type           := v_type;
    vsc_delete_view    := false;
    vsc_mult_index     := false;
    vsc_modified       := false;
    vsc_from_tableid   := cgg_zero_id;
    vsc_col_list       := false;
    vsc_col_dropped    := false;
    (*vsc_usagedef      : tak_usagedef;*)
    vsc_start_tabid    := cgg_zero_id;
    FOR _i := 1 TO 8 DO
        vsc_vdesc_modified[ _i ] := false;
    (*ENDFOR*) 
    vsc_rows           := 0;
    vsc_tabno_set      := [  ];
    vsc_vdesc_cnt      := 0;
    CASE v_type OF
        v_statistics    :
            BEGIN
            vsc_base_page_cnt := -1;
            vsc_base_rec_cnt  := -1;
            vsc_st_filler1    := csp_maxint4;
            vsc_st_filler2    := csp_maxint4;
            FOR _i := 1 TO MAX_COL_PER_TAB_GG00 DO
                vsc_page_cnt_info[ _i ] := -1;
            (*ENDFOR*) 
            END;
        v_alter_drop, v_revoke_priv, v_index :
            BEGIN
            vsc_drop_set      := [  ];
            vsc_valid_colset  := [  ];
            vsc_dr_col.dcount := 0;
            FOR _i := 1 TO MAX_COL_PER_TAB_GG00 DO
                vsc_valid_cols[ _i ] := 0;
            (*ENDFOR*) 
            vsc_valid_cnt       := 0;
            vsc_extcol_set      := [  ];
            vsc_rev_tableid     := cgg_zero_id;
            vsc_start_revoke    := false;
            vsc_userkind        := uprivate;
            vsc_page_cnt        := 0;
            vsc_rec_cnt         := 0;
            vsc_prim_cnt        := 0;
            vsc_null_cnt        := 0;
            vsc_mode            := cmd_create_index;
            vsc_index_col_count := 0;
            vsc_indexname       := a01_il_b_identifier;
            vsc_unique          := false;
            vsc_ignore_error    := false;
            vsc_keylen          := 0;
            vsc_col_ptr         := NIL;
            vsc_op_order        := op_none
            END;
        v_rename_column, v_rename_table :
            BEGIN
            vsc_rename_set   := [  ];
            vsc_info_cnt     := 0;
            FOR _i := 1 TO MAX_COL_PER_TAB_GG00 DO
                vsc_pos_info[ _i ] := 0;
            (*ENDFOR*) 
            vsc_newcolname   := a01_il_b_identifier;
            vsc_newcol_len   := 0;
            vsc_oldcolname   := a01_il_b_identifier;
            vsc_col_extcolno := 0;
            vsc_colptr       := NIL;
            vsc_renamed_cols := 0;
            vsc_renamed      := false;
            vsc_col_in_qual  := false;
            vsc_quotes       := false;
            vsc_rename_filler:= false;
            vsc_new_authname := a01_il_b_identifier;
            vsc_old_len      := 0;
            vsc_new_tablen   := a01_il_b_identifier;
            ;
            vsc_new_len      := 0;
            vsc_old_tablen   := a01_il_b_identifier;
            ;
            ;
            vsc_ren_tabid    := cgg_zero_id
            END;
        v_save_scheme, v_intern_save_scheme :
            BEGIN
            vsc_tree_id       := b01niltree_id;
            vsc_into_authname := a01_il_b_identifier;
            vsc_into_tablen   := a01_il_b_identifier;
            vsc_save_into     := false;
            vsc_tablekind     := twithkey;
            vsc_into_treeid   := b01niltree_id;
            vsc_cmd_cnt       := 0;
            vsc_first_save    := false;
            vsc_last_save     := false;
            vsc_all_save      := false;
            vsc_user_save     := false;
            vsc_schema_save   := false;
            END;
        OTHERWISE ;
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27viewtext_into_cmd_part (
            VAR acv             : tak_all_command_glob;
            VAR viewscanpar     : tak_viewscan_par;
            VAR viewtext_ptr    : tak_sysbufferaddress;
            VAR bufcnt          : integer);
 
VAR
      _b_err     : tgg00_BasisError;
      _dstate    : tak_directory_state;
      _sysp      : tak_sysbufferaddress;
      _syskey    : tgg00_SysInfoKey;
 
BEGIN
a542internal_packet( acv, NOT c_release_internal_packet, g01packet_size );
IF  acv.a_returncode = 0
THEN
    BEGIN
    acv.a_cmd_part^.sp1p_part_kind := sp1pk_command;
    acv.a_cmd_part^.sp1p_buf_len   := 0;
    _b_err           := e_ok;
    bufcnt           := 0;
    _syskey          := a01defaultkey;
    _syskey.stableid := viewscanpar.vsc_usagedef.usa_tableid;
    (* view description info -> acv.a_ptr8 *)
    IF  acv.a_ptr8 = NIL
    THEN
        ak27get_viewdesc( acv, viewscanpar, _b_err );
    (*ENDIF*) 
    IF  _b_err = e_ok
    THEN
        BEGIN
        _syskey.sentrytyp := cak_eviewtext;
        _dstate           := d_fix;
        acv.a_cmd_part^.sp1p_buf_len := 0;
        REPEAT
            a10get_sysinfo( acv, _syskey, _dstate, _sysp, _b_err );
            _dstate := d_release;
            IF  _b_err = e_ok
            THEN
                BEGIN
                bufcnt := succ( bufcnt );
                IF  bufcnt = 1
                THEN
                    viewtext_ptr := _sysp;
                (*ENDIF*) 
                IF  acv.a_cmd_part^.sp1p_buf_len +
                    _sysp^.sviewtext.vttextlength >
                    acv.a_cmd_part^.sp1p_buf_size
                THEN
                    a07_b_put_error( acv, e_too_long_viewtext, 1 )
                ELSE
                    SAPDB_PascalMove('VAK27 ',  12,    
                          sizeof( _sysp^.sviewtext.vttbuf ),
                          acv.a_cmd_part^.sp1p_buf_size,
                          @_sysp^.sviewtext.vttbuf,
                          _sysp^.sviewtext.vttabcount * mxak_vttabdef + 1,
                          @acv.a_cmd_part^.sp1p_buf,
                          acv.a_cmd_part^.sp1p_buf_len + 1,
                          _sysp^.sviewtext.vttextlength, _b_err );
                (*ENDIF*) 
                acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len +
                      _sysp^.sviewtext.vttextlength;
                IF  NOT ( _sysp^.sviewtext.vtnextexist )
                THEN
                    _b_err := e_buffer_limit
                ELSE
                    a06inc_linkage( _syskey.slinkage );
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            _b_err <> e_ok;
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    IF  _b_err <> e_buffer_limit
    THEN
        a07_b_put_error( acv, _b_err, 1 );
    (*ENDIF*) 
    END;
&ifdef trace
(*ENDIF*) 
t01moveobj( ak_sem, acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len );
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27get_viewdesc (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            VAR b_err       : tgg00_BasisError);
 
VAR
      _next_exist : boolean;
      _ix         : integer;
      _dstate     : tak_directory_state;
      _ptr        : tak_sysbufferaddress;
      _sysk       : tgg00_SysInfoKey;
      _tempsysk   : tgg00_SysInfoKey;
 
BEGIN
_sysk               := a01defaultkey;
_sysk.stableid      := viewscanpar.vsc_usagedef.usa_tableid;
_sysk.sentrytyp     := cak_eviewdesc;
_tempsysk           := _sysk;
_tempsysk.sentrytyp := cak_etempviewdesc;
_dstate             := d_fix;
viewscanpar.vsc_vdesc_cnt       := 0;
REPEAT
    viewscanpar.vsc_vdesc_cnt := succ( viewscanpar.vsc_vdesc_cnt );
    a10get_sysinfo( acv, _sysk, _dstate, _ptr, b_err );
    IF  b_err = e_ok
    THEN
        WITH _ptr^.sviewdesc DO
            BEGIN
&           ifdef trace
            FOR _ix := 1 TO vdesc_cnt DO
                WITH vdescription[ _ix ] DO
                    BEGIN
                    t01int4( ak_sem, 'vfromtabno  ', vfromtabno );
                    t01int4( ak_sem, 'vn_pos      ', vn_pos );
                    t01int4( ak_sem, 'vfrom       ', vfromextcolno );
                    t01int4( ak_sem, 'vextcolno   ', vextcolno );
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
&           endif
            _next_exist := vdesc_next;
            IF  _sysk.slinkage = cak_init_linkage
            THEN
                BEGIN
                _dstate     := d_release;
                acv.a_ptr8  := _ptr
                END
            ELSE
                BEGIN
                _tempsysk.slinkage := _sysk.slinkage;
                a10_copy_catalog_rec( acv, _sysk, false,
                      _tempsysk, vsegmentid, true, b_err );
                a06inc_linkage( _sysk.slinkage );
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
UNTIL
    NOT _next_exist OR ( b_err <> e_ok );
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27store_vdesc (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par);
 
VAR
      _b_err    : tgg00_BasisError;
      _i        : integer;
      _sysk     : tgg00_SysInfoKey;
      _tempsysk : tgg00_SysInfoKey;
 
BEGIN
_sysk               := acv.a_ptr8^.syskey;
_tempsysk           := _sysk;
_tempsysk.sentrytyp := cak_etempviewdesc;
_i    := 1;
WHILE ( _i <= viewscanpar.vsc_vdesc_cnt ) AND
      ( acv.a_returncode = 0 )
      DO
    BEGIN
    IF  viewscanpar.vsc_vdesc_modified [ _i ]
    THEN
        BEGIN
        IF  _sysk.slinkage = cak_init_linkage
        THEN
            a10repl_sysinfo( acv, acv.a_ptr8, _b_err )
        ELSE
            BEGIN
            _tempsysk.slinkage := _sysk.slinkage;
            a10_copy_catalog_rec( acv, _tempsysk,
                  true, _sysk, acv.a_ptr8^.sviewdesc.vsegmentid,
                  true, _b_err );
            END;
        (*ENDIF*) 
        IF  _b_err <> e_ok
        THEN
            a07_b_put_error( acv, _b_err, 1 )
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a06inc_linkage( _sysk.slinkage );
    _i := succ( _i );
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak27scan_vdesc (
            VAR acv         : tak_all_command_glob;
            VAR viewscanpar : tak_viewscan_par;
            VAR scan_record : tak27_vdesc_scan_record);
 
VAR
      _next_exist : boolean;
      _b_err      : tgg00_BasisError;
      _i          : integer;
      _ptr        : tak_sysbufferaddress;
      _sysk       : tgg00_SysInfoKey;
 
BEGIN
_ptr            := acv.a_ptr8;
_sysk           := _ptr^.syskey;
_sysk.sentrytyp := cak_etempviewdesc;
REPEAT
    BEGIN
    _next_exist := _ptr^.sviewdesc.vdesc_next;
    _i          := 1;
    WHILE _i <= _ptr^.sviewdesc.vdesc_cnt DO
        WITH _ptr^.sviewdesc.vdescription[ _i ] DO
            BEGIN
&           ifdef trace
            t01p4int4( ak_sem, 'vdescription', vfromtabno,
                  vfromextcolno, vn_pos, vextcolno );
&           endif
            CASE scan_record.sc_reason OF
                sc_get_pos :
                    IF  vextcolno = scan_record.sc_extcolno
                    THEN
                        BEGIN
                        _i            := cak_maxviewdesc + 1;
                        scan_record.sc_found      := true;
                        scan_record.sc_pos        := vn_pos;
                        _next_exist   := false;
                        END;
                    (*ENDIF*) 
                sc_new_pos :
                    IF  vextcolno = scan_record.sc_drop_col
                    THEN
                        BEGIN
&                       ifdef trace
                        t01int4( ak_sem, 'drop entry  ', _i );
&                       endif
                        IF  _i < _ptr^.sviewdesc.vdesc_cnt
                        THEN
                            SAPDB_PascalOverlappingMove('VAK27 ',  13,    
                                  sizeof( _ptr^.sviewdesc.vdescription[ 1 ] )*
                                  ( cak_maxviewdesc - _i ),
                                  sizeof( _ptr^.sviewdesc.vdescription[ 1 ]) *
                                  ( cak_maxviewdesc -_i + 1 ),
                                  @_ptr^.sviewdesc.vdescription[ _i + 1 ], 1,
                                  @_ptr^.sviewdesc.vdescription[ _i ], 1,
                                  ( _ptr^.sviewdesc.vdesc_cnt - _i ) *
                                  mxak_vcolumndesc,
                                  acv.a_returncode );
                        (*ENDIF*) 
                        _ptr^.sviewdesc.vdesc_cnt :=
                              pred( _ptr^.sviewdesc.vdesc_cnt );
                        _i         := _i - 1;
                        viewscanpar.vsc_vdesc_modified [
                              ord( _sysk.slinkage[ 2 ] ) ] := true
                        END
                    ELSE
                        IF  abs( vn_pos ) > scan_record.sc_startpos
                        THEN
                            BEGIN
                            IF  vn_pos > 0
                            THEN
                                vn_pos := vn_pos + scan_record.sc_offset
                            ELSE
                                vn_pos := vn_pos - scan_record.sc_offset;
                            (*ENDIF*) 
                            viewscanpar.vsc_vdesc_modified [
                                  ord( _sysk.slinkage[ 2 ] ) ] := true
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                sc_test_columns :
                    IF  vfromtabno = scan_record.sc_tabno
                    THEN
                        IF  vfromextcolno in scan_record.sc_from_col_set
                        THEN
                            IF  viewscanpar.vsc_type = v_rename_column
                            THEN
                                BEGIN
                                IF  vn_pos > 0
                                THEN
                                    BEGIN
                                    scan_record.sc_colcnt    :=
                                          succ( scan_record.sc_colcnt );
                                    viewscanpar.vsc_info_cnt :=
                                          succ( viewscanpar.vsc_info_cnt );
                                    viewscanpar.vsc_pos_info
                                          [ scan_record.sc_colcnt ] := vn_pos;
                                    END;
                                (*ENDIF*) 
                                IF  vextcolno > 0
                                THEN
                                    viewscanpar.vsc_rename_set :=
                                          viewscanpar.vsc_rename_set
                                          + [ vextcolno ];
                                (*ENDIF*) 
                                END
                            ELSE
                                IF  vextcolno = 0
                                THEN
                                    viewscanpar.vsc_delete_view := true
                                ELSE
                                    BEGIN
                                    IF  NOT ( vextcolno in
                                        viewscanpar.vsc_drop_set )
                                    THEN
                                        scan_record.sc_colcnt :=
                                              succ( scan_record.sc_colcnt );
                                    (*ENDIF*) 
                                    viewscanpar.vsc_drop_set := viewscanpar.vsc_drop_set+
                                          [ vextcolno ];
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                END;
            (*ENDCASE*) 
            _i := succ( _i );
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
&   ifdef trace
    FOR _i := 1 TO _ptr^.sviewdesc.vdesc_cnt DO
        WITH _ptr^.sviewdesc.vdescription[ _i ] DO
            t01p4int4( ak_sem, 'vdescription', vfromtabno,
                  vfromextcolno, vn_pos, vextcolno );
        (*ENDWITH*) 
    (*ENDFOR*) 
&   endif
    IF  _next_exist
    THEN
        BEGIN
        IF  viewscanpar.vsc_vdesc_modified[ ord( _sysk.slinkage[ 2 ] ) ]
            AND
            ( _ptr^.syskey.sentrytyp = cak_etempviewdesc )
        THEN
            a10repl_sysinfo( acv, _ptr, _b_err );
        (*ENDIF*) 
        a06inc_linkage( _sysk.slinkage );
        a10get_sysinfo( acv, _sysk, d_release, _ptr, _b_err );
        END;
    (*ENDIF*) 
    END;
UNTIL
    NOT _next_exist OR ( _b_err <> e_ok );
(*ENDREPEAT*) 
END;
 
&ifdef trace
(*------------------------------*) 
 
PROCEDURE
      ak27trace_vsc_type(
            VAR acv : tak_all_command_glob;
            name    : tsp00_Sname;
            vsctype : tak_viewscantype );
 
VAR
      _ln  : tsp00_Line;
      _typ : tsp00_Name;
      _e   : tgg00_BasisError;
 
BEGIN
_e := e_ok;
_ln := a99blankline;
SAPDB_PascalMove('VAK27 ',  14,    
      sizeof( name ), sizeof( _ln ),
      @name, 1, @_ln, 1, sizeof( name ), _e );
_ln[ sizeof( name ) + 2 ] := ':';
CASE vsctype OF
    v_version:
        BEGIN
        _typ := 'v_version         ';
        SAPDB_PascalMove('VAK27 ',  15,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_statistics:
        BEGIN
        _typ := 'v_statistics      ';
        SAPDB_PascalMove('VAK27 ',  16,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_intern_save_scheme:
        BEGIN
        _typ := 'v_intern_save_sche';
        SAPDB_PascalMove('VAK27 ',  17,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_alter_drop:
        BEGIN
        _typ := 'v_alter_drop      ';
        SAPDB_PascalMove('VAK27 ',  18,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_index:
        BEGIN
        _typ := 'v_index           ';
        SAPDB_PascalMove('VAK27 ',  19,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_alter_column:
        BEGIN
        _typ := 'v_alter_column    ';
        SAPDB_PascalMove('VAK27 ',  20,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_rename_column:
        BEGIN
        _typ := 'v_rename_column   ';
        SAPDB_PascalMove('VAK27 ',  21,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_rename_table:
        BEGIN
        _typ := 'v_rename_table    ';
        SAPDB_PascalMove('VAK27 ',  22,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_save_scheme:
        BEGIN
        _typ := 'v_save_scheme     ';
        SAPDB_PascalMove('VAK27 ',  23,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_revoke_priv:
        BEGIN
        _typ := 'v_revoke_priv     ';
        SAPDB_PascalMove('VAK27 ',  24,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    v_rename_user:
        BEGIN
        _typ := 'v_rename_user     ';
        SAPDB_PascalMove('VAK27 ',  25,    
              sizeof( _typ ), sizeof( _ln ),
              @_typ, 1, @_ln, sizeof( name ) + 4 , sizeof( _typ ), _e );
        END;
    OTHERWISE
        a07ak_system_error( acv, 271, 1 );
    END;
(*ENDCASE*) 
t01line( ak_sem, _ln );
END;
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
