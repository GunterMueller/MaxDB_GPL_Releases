.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-27
*****************************************************
modname : VAK725
changed : 2000-11-27
module  : Trace_Strategy_1
 
Author  : GertG
Created : 2000-03-08
*****************************************************
 
Purpose : module for tracing of strategy information
 
Define  :
 
        PROCEDURE
              a725gg_strategy (
                    debug      : tgg00_Debug;
                    VAR strat  : tgg07_StrategyInfo);
 
        PROCEDURE
              a725output_colposarr (
                    debug       : tgg00_Debug;
                    nam         : tsp00_Sname;
                    VAR keypos  : tgg07_ColPosArr);
 
        PROCEDURE
              a725output_invstrat(
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR inv_strat : tgg07_StrInvInRange);
 
        PROCEDURE
              a725output_keystrat(
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR key_strat : tgg07_StrKeyInRange);
 
        PROCEDURE
              a725output_access_info (
                    debug           : tgg00_Debug;
                    nam             : tsp00_Sname;
                    VAR access_info : tak70_strategy_record);
 
        PROCEDURE
              a725L1_terms_output (
                    debug        : tgg00_Debug;
                    VAR L1_terms : tak70_term);
 
        PROCEDURE
              a725output_involved_cols (
                    debug   : tgg00_Debug;
                    nam     : tsp00_Sname;
                    ic_info : tak70_involved_columns);
 
        PROCEDURE
              a725output_eval (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR eval_stat : tak71_page_eval_rec);
 
        PROCEDURE
              a725output_one_strat (
                    debug           : tgg00_Debug;
                    VAR one_strat   : tak70_one_strat);
 
        PROCEDURE
              a725output_gg_strat (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname(*ptocSynonym const char**);
                    VAR gg_strat  : tgg07_StrategyInfo);
 
        PROCEDURE
              a725output_colposarr_ex (
                    debug       : tgg00_Debug;
                    nam         : tsp00_Sname (*ptoc *);
                    VAR keypos  : tgg07_ColPosArr;
                    length      : tsp00_Int2);
 
        PROCEDURE
              a725output_invposarr (
                    debug       : tgg00_Debug;
                    nam         : tsp00_Sname;
                    VAR invpos  : tak70_Invposarr);
 
        PROCEDURE
              a725output_end_strat(
                    debug             : tgg00_Debug;
                    nam               : tsp00_Sname;
                    VAR gg_strategy   : tgg07_StrategyInfo;
                    VAR eval_info     : tak71_page_eval_rec;
                    VAR StratInfo_len : tsp00_Int2);
 
        PROCEDURE
              a725output_query_prop (
                    debug   : tgg00_Debug;
                    qprop   : tak70_query_properties);
 
        PROCEDURE
              a725output_sequence_prop (
                    debug   : tgg00_Debug;
                    sprop   : tak70_sequence_properties);
 
        PROCEDURE
              a725output_more_strat(
                    VAR acv         : tak_all_command_glob;
                    debug           : tgg00_Debug;
                    VAR gg_strategy : tgg07_StrategyInfo;
                    VAR all_strats  : tak70_all_strat);
 
        PROCEDURE
              a725output_explain(
                    debug    : tgg00_Debug;
                    VAR expl : tak71_explain_rec);
 
        PROCEDURE
              a725output_col_cluster (
                    debug           : tgg00_Debug;
                    nam             : tsp00_Sname;
                    VAR col_cluster : tak70_sort_col_arr;
                    array_len       : tsp00_Int2);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Syntax-Tree-Printer : VAK99;
 
        VAR
              a99blankline : tsp00_Line;
 
        PROCEDURE
              a99putint  (
                    VAR lineinfo : tsp00_DataLine;
                    integervalue : integer;
                    fieldlength  : tsp00_FieldRange);
 
        PROCEDURE
              a99put4int  (
                    VAR data : tsp00_DataLine;
                    i      : tsp00_Int4;
                    fl     : tsp00_FieldRange);
 
      ------------------------------ 
 
        FROM
              Build_Strategy : VAK70;
 
        VAR
              a70glob_key_strats        : tgg07_StratEnumSet;
              a70glob_inv_strats        : tgg07_StratEnumSet;
              a70glob_join_strats       : tgg07_StratEnumSet;
              a70glob_join_inv_strats   : tgg07_StratEnumSet;
              a70glob_join_key_strats   : tgg07_StratEnumSet;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove  (
                    mod_id         : tsp00_C6;
                    mod_intern_num : tsp00_Int4;
                    source_upb     : tsp00_Int4;
                    destin_upb     : tsp00_Int4;
                    source         : tsp00_MoveObjPtr;
                    source_pos     : tsp00_Int4;
                    destin         : tsp00_MoveObjPtr;
                    destin_pos     : tsp00_Int4;
                    length         : tsp00_Int4;
                    VAR e          : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17nameto_line (
                    n           : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (
                    n             : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (
                    int4       : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4 (
                    VAR source : tsp00_MoveObj;
                    source_pos : tsp00_Int4) : tsp00_Int4;
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              hint_trace_routines : VAK81;
 
        PROCEDURE
              a81debug_access_config (
                    debug       : tgg00_Debug;
                    VAR config  : tak00_access_configuration);
&       endif
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01showkind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    show_kind : tgg00_ShowKind);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01strat_access_mode (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    access   : tgg07_StratAccessModSet);
 
        PROCEDURE
              t01distinct_kind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    dist_kind : tgg04_Distinct);
 
        PROCEDURE
              t01qual_kind (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    qual_kind : tgg00_QualKind);
 
        PROCEDURE
              t01rowno (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    rowno : tsp00_Int4);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01bool2 (
                    debug     : tgg00_Debug;
                    nam1      : tsp00_Sname;
                    bool1     : boolean;
                    nam2      : tsp00_Sname;
                    bool2     : boolean);
 
        PROCEDURE
              t01treeid (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              t01real (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    re       : tsp00_Longreal;
                    digits   : integer);
 
        PROCEDURE
              t01Int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Name;
                    int4     : tsp00_Int4);
 
        PROCEDURE
              t01knl_identifier (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01sname (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01line (
                    level  : tgg00_Debug;
                    VAR ln : tsp00_Line);
 
        PROCEDURE
              t01name (
                    level : tgg00_Debug;
                    nam : tsp00_Name);
 
        PROCEDURE
              t01strat_enum (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    strat : tgg07_StratEnum);
 
        FUNCTION
              t01trace (layer : tgg00_Debug) : boolean;
 
        PROCEDURE
              t01write_line (VAR ln : tsp00_Line);
 
        PROCEDURE
              t01basis_error (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01c40 (
                    debug : tgg00_Debug;
                    msg   : tsp00_C40);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
(*------------------------------*) 
 
PROCEDURE
      a725output_keystrat(
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            VAR key_strat : tgg07_StrKeyInRange);
 
VAR
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _ln_len := _ln_len + 2;
    t01line (debug, _line );
    t01name( debug, '------------------');
    IF  ( ksp_auto_distinct in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'auto distinc' );
    (*ENDIF*) 
    IF  ( ksp_exact_match in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'exact match ' );
    (*ENDIF*) 
    IF  ( ksp_exact_IN_SUBQ_match in key_strat.skir_strat_props )
    THEN
        t01name( debug, 'exact INSUBQ match' );
    (*ENDIF*) 
    IF  ( ksp_order_support in key_strat.skir_strat_props )
    THEN
        BEGIN
        IF  ( ksp_order_support_reverse in key_strat.skir_strat_props )
        THEN
            t01sname( debug, 'reverse     ' );
        (*ENDIF*) 
        t01name( debug, 'key order support ' );
        END;
    (*ENDIF*) 
    IF  ( ksp_aggr_MIN_opt in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'MIN optim   ');
    (*ENDIF*) 
    IF  ( ksp_aggr_MAX_opt in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'MAX optim   ');
    (*ENDIF*) 
    IF  ( ksp_first_row_start in key_strat.skir_strat_props )
    THEN
        t01name( debug, 'first row start   ' );
    (*ENDIF*) 
    IF  ( ksp_first_row_stop in key_strat.skir_strat_props )
    THEN
        t01name( debug, 'first row stop    ' );
    (*ENDIF*) 
    IF  ( ksp_unused11 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused11    ');
    (*ENDIF*) 
    IF  ( ksp_unused12 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused12    ');
    (*ENDIF*) 
    IF  ( ksp_unused13 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused13    ');
    (*ENDIF*) 
    IF  ( ksp_unused14 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused14    ');
    (*ENDIF*) 
    IF  ( ksp_unused15 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused15    ');
    (*ENDIF*) 
    IF  ( ksp_unused16 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused16    ');
    (*ENDIF*) 
    IF  ( ksp_unused17 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused17    ');
    (*ENDIF*) 
    IF  ( ksp_unused20 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused20    ');
    (*ENDIF*) 
    IF  ( ksp_unused21 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused21    ');
    (*ENDIF*) 
    IF  ( ksp_unused22 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused22    ');
    (*ENDIF*) 
    IF  ( ksp_unused23 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused23    ');
    (*ENDIF*) 
    IF  ( ksp_unused24 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused24    ');
    (*ENDIF*) 
    IF  ( ksp_unused25 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused25    ');
    (*ENDIF*) 
    IF  ( ksp_unused26 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused26    ');
    (*ENDIF*) 
    IF  ( ksp_unused27 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused27    ');
    (*ENDIF*) 
    IF  ( ksp_unused30 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused30    ');
    (*ENDIF*) 
    IF  ( ksp_unused31 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused31    ');
    (*ENDIF*) 
    IF  ( ksp_unused32 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused32    ');
    (*ENDIF*) 
    IF  ( ksp_unused33 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused33    ');
    (*ENDIF*) 
    IF  ( ksp_unused34 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused34    ');
    (*ENDIF*) 
    IF  ( ksp_unused35 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused35    ');
    (*ENDIF*) 
    IF  ( ksp_unused36 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused36    ');
    (*ENDIF*) 
    IF  ( ksp_unused37 in key_strat.skir_strat_props )
    THEN
        t01sname( debug, 'unused37    ');
    (*ENDIF*) 
    a725output_colposarr( debug, 'key start   ', key_strat.skir_keystart );
    a725output_colposarr( debug, 'key stop    ', key_strat.skir_keystop );
    t01Int4( debug, 'IN/SUBQ stackpos  ', key_strat.skir_IN_SUBQ_stpos );
    t01Int4( debug, 'IN elem cnt       ', key_strat.skir_inelemcnt );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_invstrat(
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            VAR inv_strat : tgg07_StrInvInRange);
 
VAR
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _ln_len := _ln_len + 2;
    t01line (debug, _line );
    WITH inv_strat DO
        BEGIN
        t01name( debug, '------------------');
        t01int4( debug, 'index_no    ', inv_strat.siir_indexno );
        t01int4( debug, 'icount      ', inv_strat.siir_icount );
        t01int4( debug, 'invlen      ', inv_strat.siir_invlen );
        ak725InvColSet( debug, 'invcoldesc  ', inv_strat.siir_invcoldesc );
        t01int4( debug, 'IN/SUBQ stpo', inv_strat.siir_IN_SUBQ_stpos );
        t01int4( debug, 'inelemcnt   ', inv_strat.siir_inelemcnt );
        t01int4( debug, 'subq idx    ', inv_strat.siir_subq_idx );
        t01int4( debug, 'out invseq  ', inv_strat.siir_out_invseqlen );
        t01name( debug, '- inv properties -');
        IF  ( isp_auto_distinct in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'auto distinc' );
        (*ENDIF*) 
        IF  ( isp_unique_idx in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'iunique     ' );
        (*ENDIF*) 
        IF  ( isp_inv_only in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'inv only    ' );
        (*ENDIF*) 
        IF  ( isp_exact_match in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'exact match ' );
        (*ENDIF*) 
        IF  ( isp_exact_IN_SUBQ_match in inv_strat.siir_strat_props )
        THEN
            t01name( debug, 'exact INSUBQ match' );
        (*ENDIF*) 
        IF  ( isp_order_support in inv_strat.siir_strat_props )
        THEN
            BEGIN
            IF  ( isp_order_support_reverse in inv_strat.siir_strat_props )
            THEN
                t01sname( debug, 'reverse     ' );
            (*ENDIF*) 
            t01name( debug, 'inv order support ' );
            END;
        (*ENDIF*) 
        IF  ( isp_listmerge_allowed in inv_strat.siir_strat_props )
        THEN
            t01name( debug, 'merge possible    ' );
        (*ENDIF*) 
        IF  ( isp_aggr_MIN_opt in inv_strat.siir_strat_props )
        THEN
            BEGIN
            IF  ( isp_aggr_MIN_opt_reverse in inv_strat.siir_strat_props )
            THEN
                t01name( debug, 'MIN opt as MAX opt')
            ELSE
                t01name( debug, 'MIN optim         ');
            (*ENDIF*) 
            t01int4 ( debug, 'MIN recpos  ', inv_strat.siir_MIN_recpos );
            END;
        (*ENDIF*) 
        IF  ( isp_aggr_MAX_opt in inv_strat.siir_strat_props )
        THEN
            BEGIN
            IF  ( isp_aggr_MAX_opt_reverse in inv_strat.siir_strat_props )
            THEN
                t01name( debug, 'MAX opt as MIN opt')
            ELSE
                t01name( debug, 'MAX optim         ');
            (*ENDIF*) 
            t01int4 ( debug, 'MAX recpos  ', inv_strat.siir_MAX_recpos );
            END;
        (*ENDIF*) 
        IF  ( isp_pure_inv_output in siir_strat_props )
        THEN
            t01name( debug, 'pure inv output   ' );
        (*ENDIF*) 
        IF  ( isp_aggr_optim in inv_strat.siir_strat_props )
        THEN
            t01name( debug, 'aggregation optim ' );
        (*ENDIF*) 
        IF  ( isp_aggr_key_MIN_opt in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'key MIN opt ');
        (*ENDIF*) 
        IF  ( isp_aggr_key_MAX_opt in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'key MAX opt ');
        (*ENDIF*) 
        IF  ( isp_first_row_start in inv_strat.siir_strat_props )
        THEN
            t01name( debug, 'first row start   ' );
        (*ENDIF*) 
        IF  ( isp_first_row_stop in inv_strat.siir_strat_props )
        THEN
            t01name( debug, 'first row stop    ' );
        (*ENDIF*) 
        IF  ( isp_keysubset in inv_strat.siir_strat_props )
        THEN
            t01name( debug, 'idx is keysubset  ');
        (*ENDIF*) 
        IF  ( isp_unused23 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused23    ');
        (*ENDIF*) 
        IF  ( isp_unused24 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused24    ');
        (*ENDIF*) 
        IF  ( isp_unused25 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused25    ');
        (*ENDIF*) 
        IF  ( isp_unused26 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused26    ');
        (*ENDIF*) 
        IF  ( isp_unused27 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused27    ');
        (*ENDIF*) 
        IF  ( isp_unused30 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused30    ');
        (*ENDIF*) 
        IF  ( isp_unused31 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused31    ');
        (*ENDIF*) 
        IF  ( isp_unused32 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused32    ');
        (*ENDIF*) 
        IF  ( isp_unused33 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused33    ');
        (*ENDIF*) 
        IF  ( isp_unused34 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused34    ');
        (*ENDIF*) 
        IF  ( isp_unused35 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused35    ');
        (*ENDIF*) 
        IF  ( isp_unused36 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused36    ');
        (*ENDIF*) 
        IF  ( isp_unused37 in inv_strat.siir_strat_props )
        THEN
            t01sname( debug, 'unused37    ');
        (*ENDIF*) 
        a725output_colposarr_ex( debug, 'inv start   ',
              inv_strat.siir_invstart, inv_strat.siir_startcnt );
        a725output_colposarr_ex( debug, 'inv stop    ',
              inv_strat.siir_invstop, inv_strat.siir_stopcnt );
        END;
    (*ENDWITH*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_colposarr (
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            VAR keypos  : tgg07_ColPosArr);
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    a725output_colposarr_ex( debug, nam, keypos, MAX_STRATEGY_KEYS_GG04 );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_access_info (
            debug           : tgg00_Debug;
            nam             : tsp00_Sname;
            VAR access_info : tak70_strategy_record);
 
VAR
      _line     : tsp00_Line;
      _ln_len   : integer;
 
BEGIN
IF  t01trace (debug)
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    t01line( debug, _line );
    t01name( ak_strat, '-- ACCESS INFO -- ' );
    ak725output_keyaccess( debug, 'KEY ACCESS  ', access_info.srec_keyaccess );
    ak725output_invaccess( debug, 'INV ACCESS  ', access_info.srec_invaccess );
    ;
    a81debug_access_config( debug, access_info.srec_config );
    a725output_query_prop( debug, access_info.srec_query_prop );
    t01int4( debug, 'L1 predicate', access_info.srec_L1_pred_cnt  );
    t01bool( debug, 'L1 pred unus', access_info.srec_unusable_L1_pred );
    t01bool( debug, 'L23 predicat', access_info.srec_L23_predicates );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725L1_terms_output (
            debug        : tgg00_Debug;
            VAR L1_terms : tak70_term);
 
VAR
      l1term     : tsp00_Int2;
      preds     : tsp00_Int2;
      t     : tsp00_Int2;
      dt    : tsp00_DataLine;
      ln_pos : integer;
 
BEGIN
IF  t01trace(debug)
THEN
    BEGIN
    t01name( debug, '---- L1 terms ----' );
    t01int4( debug, 'L1term cnt  ', L1_terms.trm_L1termcnt );
    l1term := 0;
    WHILE ( l1term <= L1_terms.trm_L1termcnt - 1 ) AND
          ( l1term <= cak70_max_L1terms - 1 ) DO
        BEGIN
        IF  L1_terms.trm_L1terms[ l1term ].l1t_is_usable
            THEN
                BEGIN
            IF  ( L1_terms.trm_L1terms[ l1term ].l1t_L2pL3tcnt > 0 )
                THEN
                    BEGIN
                t01int4( debug, 'L2pL3term   ', L1_terms.trm_L1terms[ l1term ].l1t_L2pL3tcnt );
                    t := 1;
                WHILE ( t <= L1_terms.trm_L1terms[ l1term ].l1t_L2pL3tcnt ) DO
                            BEGIN
                            dt.text       := a99blankline;
                            dt.text[ 1 ]  := 'L';
                            dt.text[ 2 ]  := '1';
                            dt.text[ 3 ]  := 'T';
                            dt.text[ 4 ]  := 'E';
                            dt.text[ 5 ]  := 'R';
                            dt.text[ 6 ]  := 'M';
                            dt.text[ 7 ]  := chr( l1term + ord( '0' ) );
                            dt.text[ 9 ]  := 'T';
                            dt.text[ 10 ] := 'E';
                            dt.text[ 11 ] := 'R';
                            dt.text[ 12 ] := 'M';
                            IF  ( t < 10 )
                            THEN
                                dt.text[ 13 ] := chr( t + ord('0') )
                            ELSE
                                BEGIN
                                dt.text[ 13 ] :=
                                      chr( ( t DIV 10 ) + ord( '0' ) );
                                dt.text[ 14 ] :=
                                      chr( ( t MOD 10 ) + ord( '0' ) )
                                END;
                            (*ENDIF*) 
                            t01line( debug, dt.text );
                            preds := 1;
                    WHILE ( preds <= L1_terms.trm_L1terms[ l1term ].l1t_L2terms[ t - 1 ].l2l3p_predcnt ) DO
                                    BEGIN
                                    dt.text := a99blankline;
                                    dt.text[ 12 ] := 'P';
                                    dt.text[ 13 ] := 'R';
                                    dt.text[ 14 ] := 'E';
                                    dt.text[ 15 ] := 'D';
                                    dt.text[ 17 ] :=
                                          chr( preds + ord( '0' ) );
                        dt.pos    := 19;
                        dt.length := 21;
                        a99putint(dt, L1_terms.trm_L1terms[ l1term ].
                              l1t_L2terms[ t - 1 ].l2l3p_preds[ preds - 1 ].
                              pred_start, 3);
                        dt.pos    := 23;
                        dt.length := 25;
                        a99putint( dt, L1_terms.trm_L1terms[ l1term ].
                              l1t_L2terms[ t - 1 ].l2l3p_preds[ preds - 1 ].
                              pred_stop, 3 );
                        IF  L1_terms.trm_L1terms[ l1term ].l1t_L2terms[ t-1 ].
                            l2l3p_preds[ preds - 1 ].pred_key
                                    THEN
                                        dt.text[ 29 ] := 'K';
                                    (*ENDIF*) 
                        IF  L1_terms.trm_L1terms[ l1term ].l1t_L2terms[ t-1 ].
                            l2l3p_preds[ preds - 1 ].pred_inv
                                    THEN
                                        dt.text[ 31 ] := 'I';
                                    (*ENDIF*) 
                        dt.pos    := 33;
                        dt.length := 42;
                                    a99put4int( dt, 100, 10 );
                                    t01line( debug, dt.text );
                                    preds := succ( preds );
                                    END;
                            (*ENDWHILE*) 
                            t01line( debug, a99blankline );
                        t := succ( t );
                        END;
                    (*ENDWHILE*) 
                    t01line( debug, a99blankline );
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
            dt.text       := a99blankline;
            dt.text[ 1 ]  := 'L';
            dt.text[ 2 ]  := '1';
            dt.text[ 3 ]  := 'T';
            dt.text[ 4 ]  := 'E';
            dt.text[ 5 ]  := 'R';
            dt.text[ 6 ]  := 'M';
            dt.text[ 7 ]  := chr( l1term + ord( '0' ) );
            ln_pos := 8;
            g17sname_to_line( 'disabled    ', ln_pos, dt.text );
            t01line( debug, dt.text );
                END;
            (*ENDIF*) 
        l1term := succ(l1term);
        END;
    (*ENDWHILE*) 
    t01name( ak_strat, '------------------' );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_involved_cols (
            debug   : tgg00_Debug;
            nam     : tsp00_Sname;
            ic_info : tak70_involved_columns);
 
BEGIN
IF  t01trace(debug)
THEN
    WITH ic_info DO
        BEGIN
        t01sname( debug, nam );
        ak725output_colsequence_ex( debug, 'index output',
              ic_i_outp_cols, ic_i_outp_cnt );
        a725output_colposarr_ex( debug,    'key   output',
              ic_k_outp_cols, ic_k_outp_cnt );
        ak725output_colsequence_ex( debug, 'index qual  ',
              ic_i_qual_cols, ic_i_qual_cnt );
        a725output_colposarr_ex( debug,    'key   qual  ',
              ic_k_qual_cols, ic_k_qual_cnt );
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_eval (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            VAR eval_stat : tak71_page_eval_rec);
 
VAR
      ln_len       : integer;
      ln           : tsp00_Line;
 
BEGIN
IF  t01trace(debug)
THEN
    BEGIN
    ln          := a99blankline;
    ln[ 1 ]     := '-';
    ln[ 2 ]     := '-';
    ln_len      := 3;
    g17sname_to_line( nam, ln_len, ln );
    ln[ ln_len + 2 ] := '-';
    ln[ ln_len + 3 ] := '-';
    t01line( debug, ln );
    t01int4( debug, 'cost   pages', eval_stat.pev_wholeIO_pages );
    t01int4( debug, 'result pages', eval_stat.pev_readIO_pages );
    t01int4( debug, 'result rows ', eval_stat.pev_readIO_rows );
    t01int4( debug, 'read inv pag', eval_stat.pev_readInvIO_pages );
    t01int4( debug, 'res min rows', eval_stat.pev_readIO_rows_min );
    t01sname( debug, '------------' );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_one_strat (
            debug           : tgg00_Debug;
            VAR one_strat   : tak70_one_strat);
 
BEGIN
IF  ( t01trace( debug ) )
THEN
    BEGIN
    t01name( debug, '-- ONE STRATEGY --' );
    t01strat_enum( debug, 'strategy is ',    one_strat.ostr_strategy );
    IF  ( one_strat.ostr_strategy <> strat_no_result )
    THEN
        IF  ( one_strat.ostr_strategy in a70glob_key_strats )
        THEN
            a725output_keystrat( debug, 'key data    ', one_strat.ostr_key_in_range )
        ELSE
            BEGIN
            a725output_colposarr( debug, 'key start   ',
                  one_strat.ostr_key_in_range.skir_keystart );
            a725output_colposarr( debug, 'key stop    ',
                  one_strat.ostr_key_in_range.skir_keystop );
            IF  one_strat.ostr_strategy in a70glob_inv_strats
            THEN
                BEGIN
                a725output_invstrat( debug, 'inv data    ',
                      one_strat.ostr_inv_in_range );
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    t01int4( ak_strat, 'whole  pages', one_strat.ostr_wholeIO_pages );
    t01int4( ak_strat, 'read   pages', one_strat.ostr_readIO_pages );
    t01int4( ak_strat, 'read  ppages', one_strat.ostr_readIO_primpages );
    t01int4( ak_strat, 'read   rows ', one_strat.ostr_readIO_rows );
    t01real( ak_strat, 'strat value ', one_strat.ostr_strat_value, 6 );
    t01name( debug, '------------------' );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_gg_strat (
            debug         : tgg00_Debug;
            nam           : tsp00_Sname;
            VAR gg_strat  : tgg07_StrategyInfo);
 
VAR
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    t01line( debug, _line );
    a725gg_strategy( debug, gg_strat );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_colposarr_ex (
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            VAR keypos  : tgg07_ColPosArr;
            length      : tsp00_Int2);
 
VAR
      _ix       : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _ln_len := _ln_len + 2;
    IF  length = 0
    THEN
        BEGIN
        g17sname_to_line( 'NONE        ', _ln_len, _line );
        END
    ELSE
        FOR _ix := 0 TO length - 1 DO
            BEGIN
            g17trimint4_to_line( keypos[ _ix ], _ln_len, _line );
            _ln_len := succ( _ln_len );
            IF  ( _ln_len > 70 ) AND ( _ix < MAX_COLPOSARR_IDX_GG07 )
            THEN
                BEGIN
                t01line( debug, _line );
                _line := a99blankline;
                _ln_len := sizeof( nam ) + 4;
                END
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    t01line( debug, _line );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak725output_keyaccess (
            debug           : tgg00_Debug;
            nam             : tsp00_Sname;
            VAR keyaccess   : tak70_key_access);
 
VAR
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    t01line( debug, _line );
    a725output_colposarr_ex( debug, 'start fields',
          keyaccess.ka_startfields, keyaccess.ka_startcnt );
    a725output_colposarr_ex( debug, 'stop fields ',
          keyaccess.ka_stopfields, keyaccess.ka_stopcnt );
    IF  keyaccess.ka_infield.in_stpos <> 0
    THEN
        BEGIN
        t01int4( debug, 'IN stack pos', keyaccess.ka_infield.in_stpos );
        t01int4( debug, 'IN elem cnt ', keyaccess.ka_infield.in_elemcnt );
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_invposarr (
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            VAR invpos  : tak70_Invposarr);
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    ak725output_invposarr_ex( debug, nam, invpos, MAX_QUALIFICATIONS_AK70 );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak725output_invposarr_ex (
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            VAR invpos  : tak70_Invposarr;
            length      : tsp00_Int2);
 
VAR
      _ix       : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _ln_len := _ln_len + 2;
    IF  length = 0
    THEN
        BEGIN
        g17sname_to_line( 'NONE        ', _ln_len, _line );
        END
    ELSE
        FOR _ix := 0 TO length - 1 DO
            BEGIN
            g17trimint4_to_line( invpos[ _ix ], _ln_len, _line );
            _ln_len := succ( _ln_len );
            IF  ( _ln_len > 70 ) AND ( _ix < length - 1 )
            THEN
                BEGIN
                t01line( debug, _line );
                _line := a99blankline;
                _ln_len := sizeof( nam ) + 4;
                END
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    t01line( debug, _line );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak725output_invinposarr_ex (
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            VAR invpos  : tak70_InvInposarr;
            length      : tsp00_Int2);
 
VAR
      _ix       : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _ln_len := _ln_len + 2;
    IF  length = 0
    THEN
        BEGIN
        g17sname_to_line( 'NONE        ', _ln_len, _line );
        END
    ELSE
        FOR _ix := 0 TO length - 1 DO
            BEGIN
            g17trimint4_to_line( invpos[ _ix ].in_stpos, _ln_len, _line );
            _ln_len := succ( _ln_len );
            _line[ _ln_len ] := '[';
            _ln_len := succ( _ln_len );
            g17trimint4_to_line( invpos[ _ix ].in_elemcnt, _ln_len, _line );
            _ln_len := succ( _ln_len );
            _line[ _ln_len ] := ']';
            _ln_len := succ( _ln_len );
            IF  ( _ln_len > 70 ) AND ( _ix < length - 1 )
            THEN
                BEGIN
                t01line( debug, _line );
                _line := a99blankline;
                _ln_len := sizeof( nam ) + 4;
                END
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    t01line( debug, _line );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak725output_invaccess (
            debug           : tgg00_Debug;
            nam             : tsp00_Sname;
            VAR invaccess   : tak70_index_access);
 
VAR
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    t01line( debug, _line );
    ak725output_invposarr_ex( debug, 'start fields',
          invaccess.ia_startfields, invaccess.ia_startcnt );
    ak725output_invposarr_ex( debug, 'stop fields ',
          invaccess.ia_stopfields, invaccess.ia_stopcnt );
    ak725output_invinposarr_ex( debug, 'in fields   ',
          invaccess.ia_infields, invaccess.ia_incnt );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak725output_colsequence_ex (
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            VAR colseq  : tak_colsequence;
            length      : tsp00_Int2);
 
VAR
      _ix       : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _ln_len := _ln_len + 2;
    IF  length = 0
    THEN
        BEGIN
        g17sname_to_line( 'NONE        ', _ln_len, _line );
        END
    ELSE
        FOR _ix := 1 TO length DO
            BEGIN
            g17trimint4_to_line( colseq[ _ix ], _ln_len, _line );
            _ln_len := succ( _ln_len );
            IF  ( _ln_len > 70 ) AND ( _ix < MAX_COL_SEQUENCE_GG00 )
            THEN
                BEGIN
                t01line( debug, _line );
                _line := a99blankline;
                _ln_len := sizeof( nam ) + 4;
                END
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    t01line( debug, _line );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_end_strat(
            debug             : tgg00_Debug;
            nam               : tsp00_Sname;
            VAR gg_strategy   : tgg07_StrategyInfo;
            VAR eval_info     : tak71_page_eval_rec;
            VAR StratInfo_len : tsp00_Int2);
 
VAR
      ln     : tsp00_Line;
      ln_len : integer;
 
BEGIN
ln          := a99blankline;
ln[ 1 ]     := '-';
ln[ 2 ]     := '-';
ln_len      := 3;
g17sname_to_line( nam, ln_len, ln );
ln[ ln_len + 2 ] := '-';
ln[ ln_len + 3 ] := '-';
t01line( debug, ln );
t01strat_enum( debug, 'strategy    ', gg_strategy.str_strategy );
a725output_gg_strat( debug, 'strat data  ', gg_strategy );
t01int4( debug, 'strategy len', StratInfo_len );
a725output_eval( debug, 'eval info   ', eval_info );
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_more_strat(
            VAR acv         : tak_all_command_glob;
            debug           : tgg00_Debug;
            VAR gg_strategy : tgg07_StrategyInfo;
            VAR all_strats  : tak70_all_strat);
 
VAR
      _iy            : tsp00_Int2;
      _ix            : tsp00_Int2;
      _one_strat     : tak70_one_strat;
      _err           : tgg00_BasisError;
      _StratInfo_len : tsp00_Int2;
 
      _str       : RECORD
            CASE boolean OF
                true  :
                    (strat_char : tsp00_C1);
                false :
                    (strat_enum : tgg07_StratEnum);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  ( t01trace( debug ) )
THEN
    BEGIN
    a725output_gg_strat( debug, 'invariant   ', gg_strategy );
    t01int4( debug, 'strat count ', all_strats.ast_cntstrats );
    t01int4( debug, 'whole  pages', all_strats.ast_wholeIO_pages );
    t01int4( debug, 'read   pages', all_strats.ast_readIO_pages );
    t01int4( debug, 'read  ppages', all_strats.ast_readIO_primpages );
    IF  ( all_strats.ast_cntstrats > 1 )
    THEN
        BEGIN
        _err := e_ok;
        _iy  := 1;
        WHILE ( _iy <= all_strats.ast_cntstrats ) AND ( _err = e_ok ) DO
            BEGIN
            t01int4( debug, 'one stratpos',
                  all_strats.ast_strats[ _iy ].osr_stratpos );
            _str.strat_char[ 1 ] := acv.a_mblock.mb_strat^[
                  all_strats.ast_strats[ _iy ].osr_stratpos ];
            _one_strat.ostr_wholeIO_pages  := 0;
            _one_strat.ostr_readIO_pages   := 0;
            _one_strat.ostr_readIO_primpages:= 0;
            _one_strat.ostr_readIO_rows    := 0;
            _one_strat.ostr_strat_value    := 0;
            _one_strat.ostr_strategy    := _str.strat_enum;
            _StratInfo_len := all_strats.ast_strats[ _iy ].osr_stratlen;
            t01int4( debug, 'stratlen 1  ', _StratInfo_len );
            t01int4( debug, 'stratlen 2  ',
                  s20buf_to_int4( acv.a_mblock.mb_strat^,
                  all_strats.ast_strats[ _iy ].osr_stratpos + 4 ));
            FOR _ix := 1 TO MAX_COLPOSARR_IDX_GG07 DO
                BEGIN
                _one_strat.ostr_key_in_range.skir_keystart[ _ix ] := 0;
                _one_strat.ostr_key_in_range.skir_keystop [ _ix ] := 0;
                END;
            (*ENDFOR*) 
            SAPDB_PascalMove ('VAK725',   1,    
                  acv.a_mblock.mb_strat_size, sizeof( _one_strat.ostr_raw ),
                  @acv.a_mblock.mb_strat^,
                  all_strats.ast_strats[ _iy ].osr_stratpos + cgg07_stratpos_offs,
                  @_one_strat.ostr_raw, 1,
                  _StratInfo_len,
                  _err);
            IF  ( _err = e_ok )
            THEN
                a725output_one_strat( debug, _one_strat );
            (*ENDIF*) 
            _iy := succ( _iy );
            END;
        (*ENDWHILE*) 
        IF  ( _err <> e_ok )
        THEN
            t01basis_error( debug, 'error occure', _err );
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak725InvColSet (
            debug           : tgg00_Debug;
            nam             : tsp00_Sname;
            invcolset       : tgg07_InvColSet);
 
VAR
      _ix       : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _ln_len := _ln_len + 2;
    IF  ( invcolset = [] )
    THEN
        BEGIN
        g17sname_to_line( 'EMPTY       ', _ln_len, _line );
        END
    ELSE
        FOR _ix := 1 TO MAX_COL_SEQUENCE_GG00 DO
            BEGIN
            IF  ( _ix in invcolset )
            THEN
                BEGIN
                g17trimint4_to_line( _ix, _ln_len, _line );
                _ln_len := succ( _ln_len );
                IF  ( _ln_len > 70 ) AND ( _ix < MAX_COL_SEQUENCE_GG00 )
                THEN
                    BEGIN
                    t01line( debug, _line );
                    _line   := a99blankline;
                    _ln_len := sizeof( nam ) + 4;
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    t01line( debug, _line );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_explain(
            debug    : tgg00_Debug;
            VAR expl : tak71_explain_rec);
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    t01knl_identifier( debug, 'USER        ', expl.exp_user );
    t01knl_identifier( debug, 'TABLE       ', expl.exp_table );
    t01knl_identifier( debug, 'COLUMN      ', expl.exp_column );
    t01c40( debug , expl.exp_strat );
    t01int4( debug, 'PAGECOUNT   ', expl.exp_pagecount );
    IF  ( exp_only_inv in expl.exp_flags )
    THEN
        t01sname( debug, 'only inv    ' );
    (*ENDIF*) 
    IF  ( exp_distinct_A in expl.exp_flags )
    THEN
        t01sname( debug, 'distinct A  ' );
    (*ENDIF*) 
    IF  ( exp_distinct_P in expl.exp_flags )
    THEN
        t01sname( debug, 'distinct P  ' );
    (*ENDIF*) 
    IF  ( exp_distinct_C in expl.exp_flags )
    THEN
        t01sname( debug, 'distinct C  ' );
    (*ENDIF*) 
    IF  ( exp_distinct_K in expl.exp_flags )
    THEN
        t01sname( debug, 'distinct K  ' );
    (*ENDIF*) 
    IF  ( exp_temp_inv in expl.exp_flags )
    THEN
        t01sname( debug, 'temp. inv   ' );
    (*ENDIF*) 
    IF  ( exp_qual_on_inv in expl.exp_flags )
    THEN
        t01sname( debug, 'qual on inv ' );
    (*ENDIF*) 
    IF  ( exp_hash_join in expl.exp_flags )
    THEN
        t01sname( debug, 'table hashed' );
    (*ENDIF*) 
    IF  ( exp_parallel_index in expl.exp_flags )
    THEN
        t01sname( debug, 'parallel inv' );
    (*ENDIF*) 
    IF  ( exp_sorted_access in expl.exp_flags )
    THEN
        t01sname( debug, 'sorted acces' );
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_query_prop (
            debug   : tgg00_Debug;
            qprop   : tak70_query_properties);
 
VAR
      _first_entry  : boolean;
      _ln_len       : integer;
      _ln           : tsp00_Line;
 
BEGIN
IF  ( t01trace( debug ) )
THEN
    BEGIN
    t01name( debug, '--- QUERY PROP ---' );
    _first_entry := true;
    (**************************************)
    (* qp_build_result, qp_no_result_set, qp_missing_value *)
    _ln           := a99blankline;
    _ln_len       := 0;
    IF  ( qp_build_result in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'buildresult ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_no_result_set in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'no result   ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_missing_value in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'missing valu', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* qp_given_rescnt, qp_given_rescnt_param, qp_inv_only_impossible *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( qp_given_rescnt in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'gvn rescnt: ', _ln_len, _ln );
        _ln_len := succ( _ln_len );
        g17trimint4_to_line( qprop.qps_rescnt, _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_given_rescnt_param in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'rescnt param', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_inv_only_impossible in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'invo imposs ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* qp_check_order_support, qp_archive_access, qp_aggr_optim_poss *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( qp_check_order_support in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'check order ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_archive_access in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'arch access ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_aggr_optim_poss in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'aggr optim  ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* qp_check_key_min_max_opt, qp_check_inv_min_max_opt, qp_auto_distinct *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( qp_check_key_MIN_MAX_opt in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'check key MIN/MAX ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_check_inv_MIN_MAX_opt in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'check inv MIN/MAX ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_auto_distinct in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'auto distinc', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* qp_check_key_inv_MIN_MAX_opt, qp_ROWNO_limit *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( qp_check_key_inv_MIN_MAX_opt in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'chk keyinv MIN/MAX', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_ROWNO_limit in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'ROWNO limit ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* qp_unused20, qp_unused21, qp_unused22, qp_unused23  *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( qp_unused20 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused20    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused21 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused21    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused22 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused22    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused23 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused23    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* qp_unused24, qp_unused25, qp_unused26, qp_unused27  *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( qp_unused24 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused24    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused25 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused25    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused26 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused26    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused27 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused27    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* qp_unused30, qp_unused31, qp_unused32, qp_unused33  *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( qp_unused30 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused30    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused31 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused31    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused32 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused32    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused33 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused33    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* qp_unused34, qp_unused35, qp_unused36, qp_unused37  *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( qp_unused34 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused34    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused35 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused35    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused36 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused36    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( qp_unused37 in qprop.qps_switches )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused37    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    t01name( debug, '------------------' );
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_col_cluster (
            debug           : tgg00_Debug;
            nam             : tsp00_Sname;
            VAR col_cluster : tak70_sort_col_arr;
            array_len       : tsp00_Int2);
 
VAR
      _ix       : tsp00_Int2;
      _colpos   : tsp00_Int2;
      _colcnt   : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _colpos := 0;
    _colcnt := 0;
    _ix     := 1;
    IF  ( array_len = 0 ) OR ( array_len = IS_UNDEFINED_GG07 )
    THEN
        BEGIN
        g17sname_to_line( '  NONE      ', _ln_len, _line );
        END
    ELSE
        WHILE _ix <= array_len DO
            BEGIN
            IF  _colpos = col_cluster[ _ix ].col_id
            THEN
                BEGIN
                IF  col_cluster[ _ix ].col_stpos <> 0
                THEN
                    CASE col_cluster[ _ix ].col_eop OF
                        op_eq, op_eq_all:
                            BEGIN
                            IF  _ln_len + 12 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                IF  col_cluster[ _ix ].col_eop = op_eq_all
                                THEN
                                    BEGIN
                                    g17nameto_line( 'all               ', _ln_len, _line );
                                    _ln_len := succ(_ln_len);
                                    END;
                                (*ENDIF*) 
                                IF  NOT col_cluster[ _ix ].col_subq
                                THEN
                                    BEGIN
                                    _line[ _ln_len + 1 ] := '=';
                                    _line[ _ln_len + 2 ] := '(';
                                    _ln_len := _ln_len + 2;
                                    g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                          _ln_len, _line );
                                    _line[ _ln_len + 1 ] := ')';
                                    _ln_len := _ln_len + 2;
                                    END
                                ELSE
                                    BEGIN
                                    _line[ _ln_len + 1 ] := 'S';
                                    _line[ _ln_len + 2 ] := 'U';
                                    _line[ _ln_len + 3 ] := 'B';
                                    _line[ _ln_len + 4 ] := 'Q';
                                    _line[ _ln_len + 5 ] := '(';
                                    _ln_len := _ln_len + 5;
                                    g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                          _ln_len, _line );
                                    _line[ _ln_len + 1 ] := ')';
                                    _ln_len := _ln_len + 2;
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        op_gt:
                            BEGIN
                            IF  _ln_len + 8 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                _line[ _ln_len + 1 ] := '>';
                                _line[ _ln_len + 2 ] := '(';
                                _ln_len := _ln_len + 2;
                                g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                      _ln_len, _line );
                                _line[ _ln_len + 1 ] := ')';
                                _ln_len := _ln_len + 2;
                                END;
                            (*ENDIF*) 
                            END;
                        op_ge:
                            BEGIN
                            IF  _ln_len + 9 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                _line[ _ln_len + 1 ] := '>';
                                _line[ _ln_len + 2 ] := '=';
                                _line[ _ln_len + 3 ] := '(';
                                _ln_len := _ln_len + 3;
                                g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                      _ln_len, _line );
                                _line[ _ln_len + 1 ] := ')';
                                _ln_len := _ln_len + 2;
                                END;
                            (*ENDIF*) 
                            END;
                        op_lt:
                            BEGIN
                            IF  _ln_len + 8 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                _line[ _ln_len + 1 ] := '<';
                                _line[ _ln_len + 2 ] := '(';
                                _ln_len := _ln_len + 2;
                                g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                      _ln_len, _line );
                                _line[ _ln_len + 1 ] := ')';
                                _ln_len := _ln_len + 2;
                                END;
                            (*ENDIF*) 
                            END;
                        op_le:
                            BEGIN
                            IF  _ln_len + 9 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                _line[ _ln_len + 1 ] := '<';
                                _line[ _ln_len + 2 ] := '=';
                                _line[ _ln_len + 3 ] := '(';
                                _ln_len := _ln_len + 3;
                                g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                      _ln_len, _line );
                                _line[ _ln_len + 1 ] := ')';
                                _ln_len := _ln_len + 2;
                                END;
                            (*ENDIF*) 
                            END;
                        op_between:
                            IF  _ln_len + 11 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                g17sname_to_line( 'BTWN        ', _ln_len, _line );
                                _line[ _ln_len + 1 ] := '(';
                                _ln_len := succ( _ln_len );
                                g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                      _ln_len, _line );
                                _line[ _ln_len + 1 ] := ')';
                                _ln_len := _ln_len + 2;
                                END;
                            (*ENDIF*) 
                        op_like:
                            IF  _ln_len + 11 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                g17sname_to_line( 'LIKE        ', _ln_len, _line );
                                _line[ _ln_len + 1 ] := '(';
                                _ln_len := succ( _ln_len );
                                g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                      _ln_len, _line );
                                _line[ _ln_len + 1 ] := ')';
                                _ln_len := _ln_len + 2;
                                END;
                            (*ENDIF*) 
                        op_in:
                            IF  _ln_len + 8 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                g17sname_to_line( 'IN          ', _ln_len, _line );
                                _line[ _ln_len + 1 ] := '(';
                                _ln_len := succ( _ln_len );
                                g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                      _ln_len, _line );
                                _line[ _ln_len + 1 ] := ')';
                                _ln_len := _ln_len + 2;
                                END;
                            (*ENDIF*) 
                        op_false:
                            IF  _ln_len + 11 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                g17sname_to_line( 'FALSE       ', _ln_len, _line );
                                _line[ _ln_len + 1 ] := '(';
                                _ln_len := succ( _ln_len );
                                g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                      _ln_len, _line );
                                _line[ _ln_len + 1 ] := ')';
                                _ln_len := _ln_len + 2;
                                END;
                            (*ENDIF*) 
                        OTHERWISE
                            BEGIN
                            IF  _ln_len + 8 <= sizeof( tsp00_Line )
                            THEN
                                BEGIN
                                _line[ _ln_len + 1 ] := '?';
                                _line[ _ln_len + 2 ] := '(';
                                _ln_len := _ln_len + 2;
                                g17trimint4_to_line( col_cluster[ _ix ].col_stpos,
                                      _ln_len, _line );
                                _line[ _ln_len + 1 ] := ')';
                                _ln_len := _ln_len + 2;
                                END;
                            (*ENDIF*) 
                            END;
                        END;
                    (*ENDCASE*) 
                (*ENDIF*) 
                _ix := succ( _ix );
                END
            ELSE
                BEGIN
                t01line (debug, _line );
                _colcnt := succ( _colcnt );
                _colpos := col_cluster[ _ix ].col_id;
                _line   := a99blankline;
                _ln_len := 0;
                g17sname_to_line( 'Key         ', _ln_len, _line );
                _ln_len := succ( _ln_len );
                g17trimint4_to_line( _colcnt, _ln_len, _line );
                _ln_len := _ln_len + 2;
                _line[ _ln_len ] := ':';
                _ln_len := _ln_len + 2;
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
    (*ENDIF*) 
    t01line (debug, _line );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725output_sequence_prop (
            debug   : tgg00_Debug;
            sprop   : tak70_sequence_properties);
 
VAR
      _first_entry  : boolean;
      _ln_len       : integer;
      _ln           : tsp00_Line;
 
BEGIN
IF  ( t01trace( debug ) )
THEN
    BEGIN
    t01name( debug, '--- SEQUE PROP ---' );
    _first_entry := true;
    (**************************************)
    (* sp_exact_match, sp_exact_IN_SUBQ_match *)
    _ln           := a99blankline;
    _ln_len       := 0;
    IF  ( sp_exact_match in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'exact match ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_exact_IN_SUBQ_match in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'exact IN/SUBQ mtch', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* sp_IN_usage, sp_IN_usage_start, sp_IN_usage_stop *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( sp_IN_usage in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'IN usage    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_IN_usage_start in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'IN usage start    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_IN_usage_stop in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'IN usage stop     ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* sp_SUBQ_usage, sp_SUBQ_usage_start, sp_SUBQ_usage_stop *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( sp_SUBQ_usage in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'SUBQ usage  ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_SUBQ_usage_start in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'SUBQ usage start  ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_SUBQ_usage_stop in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'SUBQ usage stop   ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* sp_first_row_start, sp_first_row_stop, sp_unused2 *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( sp_first_row_start in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'first row start   ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_first_row_stop in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17nameto_line( 'first row stop    ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_unused2 in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused2     ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* sp_unused3, sp_unused4, sp_unused5 *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( sp_unused3 in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused3     ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_unused4 in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused4     ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_unused5 in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused5     ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    (* sp_unused6, sp_unused7             *)
    _ln          := a99blankline;
    _ln_len      := 0;
    IF  ( sp_unused6 in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused6     ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    IF  ( sp_unused7 in sprop )
    THEN
        BEGIN
        IF  ( NOT _first_entry )
        THEN
            BEGIN
            _ln[ _ln_len + 1 ] := ',';
            _ln_len := _ln_len + 2;
            END;
        (*ENDIF*) 
        g17sname_to_line( 'unused7     ', _ln_len, _ln );
        _first_entry  := false;
        END;
    (*ENDIF*) 
    t01write_line( _ln );
    _first_entry := true;
    (**************************************)
    t01name( debug, '------------------' );
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a725gg_strategy (
            debug      : tgg00_Debug;
            VAR strat  : tgg07_StrategyInfo);
 
BEGIN
WITH strat DO
    BEGIN
    t01name  (debug, '--- STRATEGY -----');
    t01strat_enum(debug, 'strategy    ',    str_strategy      );
    t01treeid    (debug, 'result_id   ',    str_result_id     );
    t01distinct_kind(debug, 'distinct    ', str_distinc       );
    t01qual_kind (debug, 'qual_kind   ',    str_qual_kind     );
    t01rowno     (debug, 'rowno       ', str_rowno );
    t01bool2     (debug, 'build_result', str_build_result
          ,              'use_rowno   ', str_use_rowno     );
    t01bool2     (debug, 'corr_single ', str_corr_single
          ,              'res_possible', str_res_possible  );
    t01bool2     (debug, 'use_order   ', str_use_order
          ,              'ordering    ', str_ordering );
    t01bool      (debug, 'sel into    ', str_selinto );
    t01p2int4    (debug, 'cnt_strat   ', str_cnt_strat
          ,              'union_kind  ', str_union_kind    );
    t01p2int4    (debug, 'foundresults', str_foundresults
          ,              'union_key_cn', str_union_key_cnt_offs);
    t01p2int4    (debug, 'key_len     ', str_key_len
          ,              'rec_len     ', str_rec_len       );
    t01p2int4    (debug, 'out key seql', str_out_keyseqlen
          ,              'stack out of', str_stack_output_offs );
    t01bool2     (debug, 'search_first', str_search_first
          ,              'all_files   ',    str_all_files     );
    t01strat_access_mode(debug, 'access mode ', str_access_mod );
    IF  ( str_key_order_support = kos_asc )
    THEN
        t01name  (debug, 'asc key order supp')
    ELSE
        IF  ( str_key_order_support = kos_desc )
        THEN
            t01name  (debug, 'desc key order sup');
        (*ENDIF*) 
    (*ENDIF*) 
    IF  NOT ( str_strategy
        in [ strat_no_result, strat_more_than_one, strat_undecided ] )
    THEN
        BEGIN
        IF  ( str_strategy in a70glob_inv_strats ) OR
            ( str_strategy in a70glob_join_inv_strats ) OR
            (( str_strategy in a70glob_join_key_strats ) AND
            ( str_strategy <> strat_join_viewkey ))
        THEN
            BEGIN
            a725output_colposarr( debug, 'keystart    ',
                  str_key_in_range.skir_keystart );
            a725output_colposarr( debug, 'keystop     ',
                  str_key_in_range.skir_keystop );
            END;
        (*ENDIF*) 
        IF  ( str_strategy in a70glob_inv_strats )
        THEN
            BEGIN
            a725output_invstrat( debug, 'inv data    ', str_inv_in_range );
            END
        ELSE
            BEGIN
            IF  ( str_strategy in a70glob_key_strats )
            THEN
                BEGIN
                a725output_keystrat( debug, 'key data    ', str_key_in_range );
                END
            ELSE
                IF  ( str_strategy in a70glob_join_strats )
                THEN
                    BEGIN
                    IF   ( NOT ( str_strategy
                        in [ strat_join_viewkey, strat_viewkey ]))
                    THEN
                        BEGIN
                        t01int4( debug, 'index no    ', str_join_multfields.sjmf_index_no );
                        t01int4( debug, 'cntfields   ', str_join_multfields.sjmf_cntfields );
                        t01int4( debug, 'invlen      ', str_join_multfields.sjmf_invlen );
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  ( str_strategy = strat_catalog )
                    THEN
                        BEGIN
                        t01showkind ( debug, 'showkind    ', str_catalog.scat_show_kind );
                        t01int4(      debug, 'authname    ', str_catalog.scat_authname );
                        t01int4(      debug, 'tablename   ', str_catalog.scat_tablename );
                        t01int4(      debug, 'username    ', str_catalog.scat_username );
                        t01int4(      debug, 'columnname  ', str_catalog.scat_columnname );
                        ak725output_catalog_cols( debug, 'cols needed ',
                              str_catalog.scat_col_needed );
                        ak725output_catalog_cols( debug, 'cols qual   ',
                              str_catalog.scat_qual_cols );
                        END
                    ELSE
                        t01strat_enum(debug, 'unknown stra', str_strategy );
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    t01name( debug, '-- END STRATEGY --' );
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak725output_catalog_cols (
            debug       : tgg00_Debug;
            nam         : tsp00_Sname;
            VAR colpos  : tgg07_CatRecColPosArr);
 
VAR
      _ix       : tsp00_Int2;
      _ln_len   : integer;
      _line     : tsp00_Line;
 
BEGIN
IF  t01trace( debug )
THEN
    BEGIN
    _line   := a99blankline;
    _ln_len := 0;
    g17sname_to_line( nam, _ln_len, _line );
    _ln_len := sizeof( nam ) + 2;
    _line[ _ln_len ] := ':';
    _ln_len := _ln_len + 2;
    FOR _ix := 1 TO MAX_SHOW_COLUMNS_GG04 DO
        BEGIN
        IF  ( colpos[ _ix ] )
        THEN
            BEGIN
            g17trimint4_to_line( _ix, _ln_len, _line );
            _ln_len := succ( _ln_len );
            IF  ( _ln_len > 70 ) AND ( _ix < MAX_SHOW_COLUMNS_GG04 )
            THEN
                BEGIN
                t01line( debug, _line );
                _line := a99blankline;
                _ln_len := sizeof( nam ) + 4;
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    t01line( debug, _line );
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
