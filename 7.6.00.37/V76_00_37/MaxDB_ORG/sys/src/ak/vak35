.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-10-11
*****************************************************
modname : VAK35
changed : 2000-10-11
module  : AK_distributor
 
Author  : ElkeZ
Created : 1985-10-16
*****************************************************
 
Purpose :
 
Define  :
 
        PROCEDURE
              a35_asql_statement (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a35_asql_statement2 (VAR acv : tak_all_command_glob;
                    prepareHandle        : tgg00_VoidPtr);
 
        PROCEDURE
              a35_flush_vtrace (VAR acv : tak_all_command_glob);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01kw                 : tak_keywordtab;
              a01sysnullkey         : tgg00_SysInfoKey;
              a01_il_b_identifier   : tsp00_KnlIdentifier;
              a01diag_monitor_on    : boolean;
              a01diag_analyze_on    : boolean;
              a01diag_ana_coll_data : boolean;
              a01char_size          : integer;
 
        PROCEDURE
              a01_call_put (
                    VAR acv  : tak_all_command_glob;
                    proc     : tak_procs;
                    subproc  : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_init_command (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_is_end_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_get_keyword (
                    VAR acv   : tak_all_command_glob;
                    VAR index : integer;
                    VAR reserved : boolean);
 
        PROCEDURE
              a01_is_odbc_syntax (
                    VAR acv      : tak_all_command_glob;
                    VAR partype  : tak_odbc_partype;
                    VAR functype : tak_odbc_functiontype);
 
        FUNCTION
              a01_eqkey (
                    VAR a      : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
        FUNCTION
              a01mandatory_keyword (
                    VAR acv          : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
        PROCEDURE
              a01_force_symbol (
                    VAR acv         : tak_all_command_glob;
                    expected_symbol : tak_sc_symbol;
                    VAR node1       : tsp00_Int2;
                    VAR node2       : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06drop_fieldlist_references (VAR fieldlists : tgg00_FieldLists);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_error (
                    VAR acv   : tak_all_command_glob;
                    errorcode : tgg00_BasisError;
                    VAR nod1  : tsp00_Int2;
                    VAR nod2  : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_hex_uni_error (
                    VAR acv     : tak_all_command_glob;
                    uni_err     : tsp8_uni_error;
                    err_code    : tsp00_Int4;
                    to_unicode  : boolean;
                    bytestr     : tsp00_MoveObjPtr;
                    len         : tsp00_Int4 );
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10_cache_delete  (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10clean_cache (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10refresh_cache (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10shrink_syntax_tree (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10table_cache_delete (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11_call_semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Domain : VAK12;
 
        PROCEDURE
              a12_call_semantic  (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Alter_Table : VAK13;
 
        PROCEDURE
              a13_call_semantic  (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_save_scheme : VAK15;
 
        PROCEDURE
              a15save_restore_catalog (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_SAVE_RESTORE_LOAD : VAK17;
 
        PROCEDURE
              a17call_semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_View_semantic  : VAK16;
 
        PROCEDURE
              a16_call_semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_exist_rename_Table   : VAK18;
 
        PROCEDURE
              a18_call_semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_User_Password : VAK21;
 
        PROCEDURE
              a21_call_semantic  (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Grant_Revoke  : VAK22;
 
        PROCEDURE
              a22_call_semantic  (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Synonym       : VAK23;
 
        PROCEDURE
              a23_call_semantic  (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Index         : VAK24;
 
        PROCEDURE
              a24_call_semantic  (
                    VAR acv       : tak_all_command_glob;
                    ignore_errors : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Link : vak25;
 
        PROCEDURE
              a25link_semantic (
                    VAR acv    : tak_all_command_glob;
                    start_node : integer);
 
      ------------------------------ 
 
        FROM
              AK_Comment : VAK26;
 
        PROCEDURE
              a26comment_on (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Stored_Procedure_DDL : VAK261;
 
        PROCEDURE
              a261proc_handling (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262trigger_semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Function : VAK264;
 
        PROCEDURE
              a264function_semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        PROCEDURE
              a28update_statistics (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Kernel_Sink : VAK34;
 
        PROCEDURE
              a34call_semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Statement_Syntax : VAK351;
 
        PROCEDURE
              a351syntax (VAR acv : tak_all_command_glob;
                    kw_index                 : integer;
                    expected_odbc_terminator : tak_odbc_partype);
 
      ------------------------------ 
 
        FROM
              AK_cold_utility_functions : VAK36;
 
        PROCEDURE
              a36_call_semantic (
                    VAR acv         : tak_all_command_glob;
                    VAR util_cmd_id : tgg00_UtilCmdId);
 
        PROCEDURE
              a36utilprot_needed (
                    VAR acv           : tak_all_command_glob;
                    VAR prot_needed   : boolean;
                    VAR with_tapeinfo : boolean);
 
      ------------------------------ 
 
        FROM
              Catalog_Migration_2 : VAK362;
 
        VAR
              a362OnlineTaskId : tsp00_TaskId;
 
      ------------------------------ 
 
        FROM
              AK_warm_utility_functions : VAK37;
 
        PROCEDURE
              a37_call_semantic (
                    VAR acv               : tak_all_command_glob;
                    VAR util_cmd_id       : tgg00_UtilCmdId);
 
        PROCEDURE
              a37utilprot_needed (
                    VAR acv           : tak_all_command_glob;
                    VAR prot_needed   : boolean;
                    VAR with_tapeinfo : boolean);
 
      ------------------------------ 
 
        FROM
              AK_data_dictionary : VAK38;
 
        PROCEDURE
              a38_call_semantic  (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_show_syntax : VAK41;
 
        PROCEDURE
              a41_show_semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Show_statistics   : VAK42;
 
        PROCEDURE
              a42_start_semantic (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a42_check_database (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a42put_running_cmds (
                    VAR acv    : tak_all_command_glob;
                    VAR parsid : tak_parsid);
 
        PROCEDURE
              a42reset_running_cmds (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52end_rollback_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier;
                    m_type            : tgg00_MessType);
 
        PROCEDURE
              a52internal_subtrans (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a52_call_semantik (
                    VAR acv : tak_all_command_glob;
                    subproc : tsp00_Int2);
 
        PROCEDURE
              a52_ex_commit_rollback (
                    VAR acv        : tak_all_command_glob;
                    m_type         : tgg00_MessType;
                    n_rel          : boolean;
                    normal_release : boolean);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_shortinfo_to_varpart (
                    VAR acv   : tak_all_command_glob;
                    store_cmd : boolean;
                    VAR infop : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542reset_packet (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542move_to_packet (
                    VAR acv    : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
        PROCEDURE
              a542identifier_to_packet (
                    VAR acv        : tak_all_command_glob;
                    VAR identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              a542char_to_packet (
                    VAR acv : tak_all_command_glob;
                    c       : char);
 
      ------------------------------ 
 
        FROM
              diagnose analyze : VAK544;
 
        PROCEDURE
              a544put_syscmd_analyze (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              diagnose monitor : VAK545;
 
        PROCEDURE
              a545diag_parse_info (
                    VAR acv        : tak_all_command_glob;
                    VAR parsid     : tak_parsid;
                    VAR sel_parsid : tak_parsid);
 
        PROCEDURE
              a545sm_insert (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Insert : VAK56;
 
        PROCEDURE
              a56_insert_statement (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Insert_Select : VAK562;
 
        PROCEDURE
              a562_select_insert (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Update : VAK57;
 
        PROCEDURE
              a57_update_statement (
                    VAR acv    : tak_all_command_glob;
                    start_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_Delete : VAK58;
 
        PROCEDURE
              a58_delete (
                    VAR acv    : tak_all_command_glob;
                    start_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60_aselect_statement (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Single_Select : VAK62;
 
        PROCEDURE
              a62_direct_ordered_select (
                    VAR acv    : tak_all_command_glob;
                    start_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Execute_Select_Expression : VAK660;
 
        PROCEDURE
              a660_select (
                    VAR acv   : tak_all_command_glob;
                    startnode : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              OptiQueryRewrite : VAK664Wrapper;
 
        PROCEDURE
              a664_QueryRewrite (
                    VAR acv     : tak_all_command_glob;
                    prepareHandle : tgg00_VoidPtr
                    );
 
      ------------------------------ 
 
        FROM
              Resulttable : VAK73;
 
        PROCEDURE
              a73_call_semantic (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Hint_Handling : VAK80;
 
        PROCEDURE
              a80drop_all_hint_info( VAR acv : tak_all_command_glob );
 
      ------------------------------ 
 
        FROM
              KB_headmaster : vkb38;
 
        PROCEDURE
              k38UtilIdGet (VAR UtilId : tgg00_UtilCmdId);
 
        PROCEDURE
              k38UtilIdSaveLineNo (VAR UtilId : tgg00_UtilCmdId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id      : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120FlushTrace(  TaskId : tsp00_TaskId );
 
      ------------------------------ 
 
        FROM
              task_temp_data_cache : VBD21;
 
        FUNCTION
              b21m_is_select (temp_cache_ptr : tgg00_TempDataCachePtr) : boolean;
 
        PROCEDURE
              b21m_parseid (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR parseid       : tak_parsid;
                    VAR masterparseid : tak_parsid);
 
        PROCEDURE
              b21mp_is_select (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    is_select : boolean);
 
        PROCEDURE
              b21m_reset_monitor (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    reset_sum : boolean);
 
        PROCEDURE
              b21mp_parseid_put (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR parseid       : tak_parsid;
                    VAR masterparseid : tak_parsid);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01diag_moni_parse_on  : boolean;
              g01unicode             : boolean;
              g01code                : tgg04_CodeGlobals;
              g01glob                : tgg00_KernelGlobals;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17hexto_line (
                    c          : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17nameto_line (
                    n           : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (
                    n             : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17int4to_line (
                    int       : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        PROCEDURE
              gg999GetNewCommandId (taskid : tsp00_TaskId;
                    VAR id : tgg00_UtilCmdId);
 
        FUNCTION
              gg999KernelStateIsOnline : boolean;
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26find_part (
                    VAR segm         : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr (
                    VAR str   : tsp00_MoveObj;
                    skip_val  : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gstr (
                    VAR buf    : tsp00_MoveObj;
                    pos        : tsp00_Int4;
                    len        : integer;
                    frac       : integer;
                    origlen    : integer;
                    VAR dest   : tsp00_Line;
                    dpos       : tsp00_Int4;
                    VAR dlen   : integer;
                    VAR res    : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans (
                    src_ptr         : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vutilprot (
                    VAR msg_line : tsp00_Buf;
                    msg_len      : tsp00_Int4);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        FUNCTION
              t01trace (debug : tgg00_Debug) : boolean;
 
        PROCEDURE
              t01aptree (
                    layer         : tgg00_Debug;
                    VAR a_ap_tree : tak_ap_max_tree;
                    node_cnt      : integer;
                    hint_node     : tsp00_Int2);
 
        PROCEDURE
              t01moveobj (
                    level       : tgg00_Debug;
                    VAR buf     : tsp00_MoveObj;
                    pos_start   : tsp00_Int4;
                    pos_end     : tsp00_Int4);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname (*ptocSynonym const char**);
                    curr_bool: boolean);

        PROCEDURE
              t01segment (
                    debug       : tgg00_Debug;
                    VAR segm    : tsp1_segment);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              b21m_parseid;
 
              tsp00_C12      tak_parsid
              tsp00_C12      tak_parsid
 
        PROCEDURE
              s42gstr;
 
              tsp00_MoveObj tsp00_Line
 
        PROCEDURE
              t01aptree;
 
              tsp00_MoveObj tak_ap_max_tree
 
        PROCEDURE
              a42put_running_cmds;
 
              tsp00_C12 tak_parsid
 
        PROCEDURE
              b21mp_parseid_put;
 
              tsp00_C12 tak_parsid
              tsp00_C12 tak_parsid
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      ignore_no_errors = false;
      c_is_rollback    = true;
      c_reset_sum      = true  (* b21m_reset_monitor *);
      c_is_select      = true (* b21mp_is_select *);
      c_with_zero      = true (*g17int4to_line*);
      c_trans_to_uni   = true (* a07_hex_uni_error  *);
      c_release_internal_packet= true (* a542internal_packet*);
      c_unicode_wid    = 2    (* a07_hex_uni_error  *);
      mx_page_cnt      = 10;
 
TYPE
      t_utilheader_kind = (
            uhk_request,
            uhk_receive,
            uhk_save);
 
 
(*------------------------------*) 
 
PROCEDURE
      a35_asql_statement (VAR acv : tak_all_command_glob);
 
BEGIN
a35_asql_statement2(acv, NIL);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a35_asql_statement2 (VAR acv : tak_all_command_glob;
            prepareHandle        : tgg00_VoidPtr);
 
CONST
      c_show             = true;
      max_countdatatypes = 1;
 
VAR
      again                 : boolean;
      init_intern_expl      : boolean;
      make_subtrans         : boolean;
      refresh_catalog       : boolean;
      init_ex_kind          : tak_execution_kind;
      m_init_ddl            : tak_ddl_descriptor;
      countfilevers         : integer;
      (* PTS 1000985/1001162 E.Z. *)
      countdatatypes        : integer;
      save_cmd_length       : integer;
      save_data_length      : integer;
      symbindex             : integer;
      init_costsum          : tsp00_Int4;
      old_costwarn          : tsp00_Int4;
      res_kw                : boolean;
      last_cmd_was_select   : boolean;
      pseudo_select         : boolean;
      odbc_partype          : tak_odbc_partype;
      odbc_functype         : tak_odbc_functiontype;
      pp                    : tak_parsid;
      try_queryrewrite      : boolean;
      dummypp               : tak_parsid;
 
BEGIN
odbc_partype   := no_odbc;
odbc_functype  := odbc_nothing;
make_subtrans  := true;
old_costwarn   := acv.a_costwarn_value;
pseudo_select  := false;
IF  acv.a_cmd_segment_header.sp1c_ignore_costwarning
THEN
    acv.a_costwarn_value := acv.a_costlimit_value;
&ifdef TRACE
(*ENDIF*) 
t01moveobj( ak_syn, acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len );
t01int4( ak_sem, 'precomp_info', ord( acv.a_precomp_info_byte ));
&endif
a01_init_command (acv);
(* PTS 1104963 E.Z. *)
acv.a_precomp_info_byte := csp1_p_none;
IF  acv.a_scv.sc_symb = s_leftpar
THEN
    BEGIN
    WHILE ( acv.a_scv.sc_symb = s_leftpar ) DO
        a01_next_symbol(acv);
    (*ENDWHILE*) 
    IF  NOT a01_eqkey (a01kw[ cak_i_select ], acv.a_sqlmode,
        acv.a_cmd_part^.sp1p_buf, acv.a_scv)
    THEN
        a07_b_put_error (acv, e_invalid_command, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
acv.a_ap_tree^[ 0 ].n_lo_level := 1;
acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc := no_proc;
a01_get_keyword (acv, symbindex, res_kw);
acv.a_select_node := 0;
(* PTS 1120377 E.Z. *)
IF  (* PTS 1106205 E.Z. *)
    (symbindex <> cak_i_ping)
THEN
    BEGIN
    IF  (acv.a_curr_user_name =  a01_il_b_identifier) AND
        (symbindex        <> cak_i_connect          ) AND
        NOT (acv.a_in_ddl_trigger)
    THEN
        a07_b_put_error (acv, e_user_not_connected, 1)
    ELSE
        (* PTS 1111575 E.Z. *)
        IF  (acv.a_ex_kind <> only_parsing)
            AND
            (acv.a_ex_kind <> only_syntax)
            AND
            (acv.a_cmd_segment_header.sp1c_mass_cmd)
            AND
            ((symbindex = cak_i_delete)  OR
            ( symbindex = cak_i_insert)  OR
            ( symbindex = cak_i_select)  OR
            ( symbindex = cak_i_declare) OR
            ( symbindex = cak_i_append)
            (* PTS 1102325 E.Z. *)
            (* OR ( symbindex = cak_i_update) *)
            )
        THEN
            a07_b_put_error (acv, e_invalid_command, 1)
        ELSE
            IF  (acv.a_dbproc_level + acv.a_trigger_level > 0) AND
                (symbindex = cak_i_connect)
            THEN
                a07_b_put_error (acv, e_invalid_command, 1);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  ( acv.a_returncode = 0 )
    THEN
        BEGIN
        (* PTS 1120287 E.Z. *)
        IF  acv.a_statement_kind = isql_commands
        THEN
            CASE symbindex OF
                cak_i_alter :
                    acv.a_statement_kind := ialters;
                cak_i_commit :
                    acv.a_statement_kind := icommits;
                cak_i_create :
                    acv.a_statement_kind := icreates;
                cak_i_delete :
                    acv.a_statement_kind := ideletes;
                cak_i_drop :
                    BEGIN
                    (* will be done in vak20 because if drop parseid *)
                    END;
                cak_i_insert :
                    acv.a_statement_kind := iinserts;
                cak_i_lock, cak_i_unlock :
                    acv.a_statement_kind := ilocks;
                cak_i_rollback :
                    acv.a_statement_kind := irollbacks;
                cak_i_select,
                cak_i_declare,
                (* PTS 1111576 E.Z. *)
                cak_i_fetch :
                    BEGIN
                    acv.a_statement_kind := iselects;
                    IF  (acv.a_ex_kind <> only_parsing)                   AND
                        (acv.a_iso_level = cak_iso_level_stmt_consistent) AND
                        (acv.a_transinf.tri_trans.trConsistReadInfo_gg00 = CnsReadNone)
                    THEN
                        acv.a_transinf.tri_trans.trConsistReadInfo_gg00 := CnsReadStatement;
                    (*ENDIF*) 
                    END;
                cak_i_savepoint :
                    IF  acv.a_sqlmode = sqlm_oracle
                    THEN
                        acv.a_statement_kind := ibegin_subtrans
                    ELSE
                        acv.a_statement_kind := icollisions (* no useable value *);
                    (*ENDIF*) 
                (* PTS 1003033 E.Z. *)
                (* PTS 1111576 E.Z. *)
                cak_i_update, cak_i_append :
                    acv.a_statement_kind := iupdates;
                OTHERWISE
                    BEGIN
                    IF  symbindex <> cak_i_subtrans
                    THEN
                        acv.a_statement_kind := icollisions (* no useable value *)
                    (*ENDIF*) 
                    END
                (*acv.a_statement_kind := iload_dbproc_calls;
                      acv.a_statement_kind := itrigger_calls;*)
                END;
            (*ENDCASE*) 
        (*  h.b. 15.09.1994 noch nicht freigegeben *)
        (*ENDIF*) 
        IF  (symbindex = cak_i_no_keyword) AND
            ((acv.a_comp_type = at_odbc) OR (acv.a_comp_type = at_jdbc))
        THEN
            BEGIN
            a01_is_odbc_syntax ( acv, odbc_partype, odbc_functype);
            IF  (odbc_partype <> no_odbc)
                AND (odbc_functype = odbc_call)
            THEN
                symbindex := cak_i_dbproc
            ELSE
                IF  (odbc_partype <> no_odbc)
                    AND (odbc_functype = odbc_dbfunc)
                THEN
                    ak35odbc_func_call (acv, symbindex)
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        CASE symbindex OF
            cak_i_beginload,
            cak_i_commit,
            cak_i_connect,
            cak_i_dbproc, cak_i_dbprocedure,
            cak_i_proc,   cak_i_procedure,
            cak_i_call,
            cak_i_endload,
            cak_i_fetch,
            cak_i_lock,
            cak_i_inner,
            cak_i_rollback,
            cak_i_savepoint,
            cak_i_subtrans,
            cak_i_unlock :
                make_subtrans := false;
            OTHERWISE
                BEGIN
                END
            END;
        (*ENDCASE*) 
        CASE symbindex OF
            cak_i_describe,
            cak_i_fetch :
                pseudo_select := true;
            OTHERWISE
                BEGIN
                END
            END;
        (*ENDCASE*) 
        (* ============== *)
        (* Syntaxanalysis *)
        (* ============== *)
        a351syntax (acv, symbindex, odbc_partype);
        IF  acv.a_cmd_part = NIL
        THEN
            acv.a_original_stmt_lenght := 0
        ELSE
            acv.a_original_stmt_lenght := acv.a_cmd_part^.sp1p_buf_len;
        (*ENDIF*) 
&       IFDEF TRACE
        IF  t01trace( ak_syn )
        THEN
            BEGIN
            t01int4 (ak_syn, 'START_NODE  ', acv.a_ap_tree^[ 0 ].n_lo_level);
            IF  acv.a_first_hint_node <> csp_minint2
            THEN
                t01int4 (ak_syn, 'HINT_NODE   ', acv.a_first_hint_node);
            (*ENDIF*) 
            t01aptree (ak_syn, acv.a_ap_tree^, acv.a_scv_index,
                  acv.a_first_hint_node);
            END
        ELSE
            BEGIN
            t01int4 (ak_sem, 'START_NODE  ', acv.a_ap_tree^[ 0 ].n_lo_level);
            IF  acv.a_first_hint_node <> csp_minint2
            THEN
                t01int4 (ak_sem, 'HINT_NODE   ', acv.a_first_hint_node);
            (*ENDIF*) 
            t01aptree (ak_sem, acv.a_ap_tree^, acv.a_scv_index,
                  acv.a_first_hint_node);
            END;
        (*ENDIF*) 
&       ENDIF
        END;
    (*ENDIF*) 
    IF  acv.a_init_ddl = no_ddl
    THEN
        acv.a_init_ddl := acv.a_is_ddl;
    (*ENDIF*) 
    IF  acv.a_returncode <> 0
    THEN
        BEGIN
        acv.a_parsing_again := acv.a_returncode = csp_old_fileversion;
        IF  acv.a_parsing_again AND (acv.a_is_ddl <> no_ddl) (* PTS 1136381 *)
        THEN
            BEGIN
            acv.a_parsing_again := false;
            acv.a_returncode    := 0;
            a07_b_put_error (acv, e_invalid_mix_dml_ddl, 1)
            END
        ELSE
            acv.a_try_again := acv.a_parsing_again;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  (acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level].n_proc = a36)
            OR
            (acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level].n_proc = a37)
            (* PTS 1121750 E.Z. *)
            OR
            (acv.a_ap_tree^[acv.a_ap_tree^[ 0 ].n_lo_level].n_proc = a30)
        THEN
            BEGIN
            make_subtrans := false;
            IF  acv.a_return_segm^.sp1r_function_code = csp1_nil_fc
            THEN
                acv.a_return_segm^.sp1r_function_code := csp1_administrator_fc
            ELSE
                IF  ((acv.a_return_segm^.sp1r_function_code = csp1_diagnose_fc) OR
                    ( acv.a_return_segm^.sp1r_function_code = csp1_monitor_fc))
                    AND
                    gg999KernelStateIsOnline
                THEN
                    make_subtrans := true;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ( a01diag_monitor_on OR a01diag_analyze_on ) AND
            ( acv.a_in_session )
        THEN
            BEGIN
            last_cmd_was_select := b21m_is_select (
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00);
            (* we try to store SELECT and FETCHes together *)
            (* even if FETCH-parsen is between them        *)
            (* we expect the FETCH-parse directly behind   *)
            (* the SELECT-execute                          *)
            IF  ( last_cmd_was_select )
            THEN
                BEGIN
                IF  NOT pseudo_select
                THEN
                    b21mp_is_select( acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                          NOT c_is_select )
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                b21m_parseid( acv.a_transinf.tri_trans.trBdTcachePtr_gg00, pp, dummypp );
                IF  ( pp.pid_session.ci4_gg00 <> '    ' ) AND
                    ( ord( pp.pid_parsk.p_kind) <> ord( bsp_c1 ))
                    (* not counted values stored in b21 *)
                THEN
                    a545sm_insert( acv );
                (*ENDIF*) 
                b21m_reset_monitor( acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                      c_reset_sum );
                END
            (*ENDIF*) 
            END;
        (*********************************)
        (*ENDIF*) 
        IF  acv.a_ex_kind = only_syntax
        THEN
            BEGIN
            IF  (acv.a_is_ddl = ddl_create_as_select) AND
                (acv.a_init_ex_kind <> only_syntax)
            THEN
                BEGIN
                (* CREATE TABLE AS SELECT *)
                IF  acv.a_initial_segment_header.sp1c_mess_type <> sp1m_execute
                THEN
                    a542reset_packet (acv);
                (*ENDIF*) 
                ak35parse_ddl( acv, NOT c_show );
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            (* PTS 1103681 E.Z. *)
            IF  (acv.a_precomp_info_byte >= csp1_p_mass_command) AND
                (acv.a_return_segm^.sp1r_function_code >= csp1_masscmd_fc_offset) AND
                (acv.a_count_variab = 0)
            THEN
                BEGIN
                acv.a_precomp_info_byte := acv.a_precomp_info_byte - csp1_p_mass_command;
                acv.a_return_segm^.sp1r_function_code :=
                      acv.a_return_segm^.sp1r_function_code - csp1_masscmd_fc_offset
                END;
            (* PTS 1119972 E.Z. *)
            (*ENDIF*) 
            IF  a01diag_analyze_on AND
                acv.a_in_session   AND
                ( acv.a_cmd_segment_header.sp1c_producer = sp1pr_user_cmd )
            THEN
                BEGIN
                (* create CMDID *)
                a544put_syscmd_analyze ( acv ); (* h.b. PTS 1105522 *)
                (* performance data for FETCH count for the last command *)
                (* we hope, this was a SELECT :-)                        *)
                END;
            (*ENDIF*) 
            IF  (acv.a_ex_kind = only_parsing)
                AND
                NOT acv.a_progusage_add
                AND
                (* PTS 1115025 E.Z. *)
                (NOT (acv.a_is_ddl in
                [              no_ddl
                ,              ddl_comment_on, ddl_create_as_select
                ,              ddl_restore_schema
                ,              ddl_usage_off, ddl_save_restore_cmd])
                OR (symbindex = cak_i_init)
                (* PTS 1111576 E.Z. *)
                OR (symbindex = cak_i_force)
                OR (symbindex = cak_i_alter) (* oracle nls *)
                OR (symbindex = cak_i_monitor)
                OR (symbindex = cak_i_diagnose)
                OR (symbindex = cak_i_exists)
                OR (symbindex = cak_i_reset)
                (* PTS 1115654 E.Z. *)
                OR ((symbindex = cak_i_set) AND
                (acv.a_ap_tree^[acv.a_ap_tree^[0].n_lo_level].n_subproc in
                [cak_x_set_format,
                cak_x_set_role,
                cak_x_set_session_trace]))
                )
            THEN
                ak35parse_ddl (acv,(symbindex = cak_i_explain))
            ELSE
                BEGIN
                acv.a_ap_tree^[0].n_proc := a10;
                (* PTS 1128197 D.T. *)
                acv.a_ap_tree^[0].n_subproc := 0;
                acv.a_ap_tree^[0].n_pos := 0;
                acv.a_ap_tree^[0].n_length := 0;
                acv.a_ap_tree^[0].n_refback   := cak_qrewrite_ref_init;
                acv.a_ap_tree^[0].n_querycheck:= [];
                acv.a_ap_tree^[0].n_dt_format := acv.a_dt_format;
                (* *)
                IF  (acv.a_is_ddl <> no_ddl) AND
                    (acv.a_internal_sql = no_internal_sql) AND
                    NOT acv.a_progusage_add
                THEN
                    BEGIN
                    IF  (acv.a_sqlmode = sqlm_oracle)   AND
                        (acv.a_ex_kind <> only_parsing) AND
                        (a362OnlineTaskId = UNDEF_SP00) (* PTS 1120287 M.Ki *)
                    THEN
                        a52_ex_commit_rollback (acv,
                              m_commit, false, false);
                    (*ENDIF*) 
                    acv.a_usage_curr.fileRoot_gg00 := NIL_PAGE_NO_GG00
                    END;
                (*ENDIF*) 
                IF  acv.a_cmd_part <> NIL
                THEN
                    save_cmd_length   := acv.a_cmd_part^.sp1p_buf_len
                ELSE
                    save_cmd_length   := 0;
                (*ENDIF*) 
                save_data_length  := acv.a_data_length;
                init_ex_kind      := acv.a_ex_kind;
                countfilevers     := 0;
                countdatatypes    := 0;
                again             := false;
                IF  (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc <> a63) AND
                    (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc <> a56)
                THEN
                    acv.a_costcheck := false;
                (*ENDIF*) 
                IF  acv.a_max_intern_select > 0
                THEN
                    init_costsum := acv.a_costsum
                ELSE
                    init_costsum := 0;
                (*ENDIF*) 
                init_intern_expl := acv.a_intern_explain;
                a06drop_fieldlist_references (acv.a_mblock.mb_fieldlists);
                (* PTS 1128197 D.T. *)
                try_queryrewrite := false;
                IF  ( ( acv.a_returncode = 0 ) AND
                    ( acv.a_ex_kind <> only_syntax ) AND
                    ( acv.a_init_ddl = no_ddl ) AND
                    ( acv.a_ap_tree = acv.a_session_ap_tree ) AND
                    ( acv.a_queryrewrite_mode = Operator_Rewrite ) AND
                    ( acv.a_command_kind <> complex_view_command ) AND
                    (acv.a_precomp_info_byte <> csp1_p_select_for_update_found) AND
                    (acv.a_precomp_info_byte <> csp1_p_for_upd_mselect_found) AND
                    (acv.a_precomp_info_byte <> csp1_p_reuse_update_sel_found) AND
                    (acv.a_precomp_info_byte <> csp1_p_reuse_upd_mselect_found) AND
                    ( acv.a_cmd_segm^.sp1s_segm_header.sp1c_producer <> sp1pr_complex_view_handling))
                THEN
                    BEGIN
                    IF  (((symbindex = cak_i_explain)
                        ) OR
                        ((symbindex = cak_i_select) AND (NOT acv.a_may_be_direct_sel)) OR
                        (symbindex = cak_i_declare) (* OR
                              (symbindex = cak_i_insert)  OR
                              (symbindex = cak_i_append)  OR
                              (symbindex = cak_i_update)  OR
                              (symbindex = cak_i_delete)  *)
                        )
                    THEN
                        BEGIN
                        try_queryrewrite := true;
                        a664_QueryRewrite(acv, prepareHandle);
&                       ifdef trace
                        t01bool( ak_syn, 'QRW Modified', acv.a_queryrewrite_modified);
                        t01bool( ak_syn, 'QRW Optimize', (acv.a_queryrewrite_done = Operator_Rewrite));
                        t01int4( ak_syn, 'a_returncode', acv.a_returncode);
                        t01moveobj( ak_syn, acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len );
&                       endif
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    BEGIN
                    REPEAT
                        acv.a_part_rollback := false;
                        acv.a_p_arr1.pcount := 0;
                        acv.a_p_arr1.pbasep := NIL;
                        IF  (acv.a_ex_kind <> only_parsing) OR
                            (acv.a_qualified_jv_upd = no_jv_upd)
                        THEN
                            acv.a_input_data_pos := 1;
                        (*ENDIF*) 
                        countfilevers := succ(countfilevers);
                        acv.a_output_data_pos := 1;
                        acv.a_returncode      := 0;
                        acv.a_main_returncode := 0;
                        acv.a_errorpos        := 0;
                        acv.a_main_errorpos   := 0;
                        acv.a_err_parm_cnt := 0;
                        acv.a_special_expr := false;
                        acv.a_allow_functions := tf_unknown;
                        IF  make_subtrans
                        THEN
                            a52internal_subtrans( acv );
                        (*ENDIF*) 
                        ak35call_semantik( acv, prepareHandle );
&                       ifdef trace
                        IF  ( acv.a_returncode <> 0 ) AND try_queryrewrite AND NOT acv.a_queryrewrite_modified
                        THEN
                            (* PTS 1128197 D.T. *)
                            WITH acv.a_transinf.tri_trans DO
                                trWarning_gg00 := trWarning_gg00 - [warn15_user_defined_code];
                            (*ENDWITH*) 
&                       endif
                        (* PTS 1000985/1001162 E.Z. *)
                        (*ENDIF*) 
                        IF  ( csa_subq_datatype_problem in acv.a_sql_cmd_state )
                        THEN
                            BEGIN
                            acv.a_retpart_locked := false;
                            IF  acv.a_returncode = 0
                            THEN
                                acv.a_returncode := cak_e_subq_type_diff;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  (
                            (acv.a_return_segm^.sp1r_function_code >= csp1_fetch_first_fc) AND
                            (acv.a_return_segm^.sp1r_function_code <= csp1_fetch_same_fc)
                            )
                            OR
                            (acv.a_return_segm^.sp1r_function_code = csp1_fetch_relative_fc)
                            OR
                            (
                            (acv.a_return_segm^.sp1r_function_code >= csp1_mfetch_first_fc) AND
                            (acv.a_return_segm^.sp1r_function_code <= csp1_mfetch_same_fc)
                            )
                            OR
                            (acv.a_return_segm^.sp1r_function_code = csp1_mfetch_relative_fc)
                        THEN
                            BEGIN
                            END
                        ELSE
                            a06drop_fieldlist_references (acv.a_mblock.mb_fieldlists);
                        (*ENDIF*) 
                        IF  (acv.a_main_returncode <> 0) AND
                            (acv.a_returncode = 0)
                        THEN
                            BEGIN
                            acv.a_returncode := acv.a_main_returncode;
                            acv.a_errorpos   := acv.a_main_errorpos;
                            acv.a_main_returncode := 0;
                            acv.a_main_errorpos   := 0;
                            END;
                        (*ENDIF*) 
                        IF  acv.a_returncode = 0
                        THEN
                            BEGIN
                            again := false;
                            IF  (acv.a_init_ddl <> no_ddl)         AND
                                (acv.a_init_ddl <> ddl_comment_on) AND
                                (acv.a_init_ddl <> ddl_create_as_select)
                            THEN
                                a10clean_cache (acv);
                            (*ENDIF*) 
                            END
                        ELSE
                            (* PTS 1109783 E.Z. *)
                            IF  (acv.a_returncode = cak_e_released)
                                OR
                                (acv.a_returncode = cak_e_roll_released)
                                OR
                                (
                                ((acv.a_return_segm^.sp1r_function_code = csp1_commit_release_fc) OR
                                ( acv.a_return_segm^.sp1r_function_code = csp1_rollback_release_fc))
                                AND
                                (acv.a_cmd_segment_header.sp1c_mess_type in [ sp1m_dbs, sp1m_execute ])
                                )
                            THEN
                                again := false
                            ELSE
                                BEGIN
                                acv.a_intern_explain := init_intern_expl;
                                refresh_catalog :=
                                      ak35refresh_catalog (acv);
                                IF  (acv.a_returncode = csp_old_fileversion)  OR
                                    (acv.a_returncode = cak00_old_parsid)       OR
                                    (acv.a_returncode = cak_e_cache_full)     OR
                                    (acv.a_returncode = cak_e_inv_not_found)  OR
                                    (acv.a_returncode =
                                    cak_e_table_or_file_dropped)                            OR
                                    refresh_catalog                                         OR
                                    (* PTS 1000985/1001162 E.Z. *)
                                    ((csa_subq_datatype_problem in acv.a_sql_cmd_state) AND
                                    (acv.a_returncode = cak_e_subq_type_diff)) OR
                                    (acv.a_returncode =
                                    cak_e_corelated_subquery_not_allowed)
                                THEN
                                    IF  (symbindex = cak_i_beginload) OR
                                        (symbindex = cak_i_endload)   OR
                                        (symbindex = cak_i_fetch  )   OR
                                        (symbindex = cak_i_describe)  OR
                                        (symbindex = cak_i_restart) (* in case systemtrigger causes some trouble *)
                                        (* PTS 1111576 E.Z. *)
                                        (* PTS 1111075 E.Z. *)
                                    THEN
                                        again := false
                                    ELSE
                                        BEGIN
                                        acv.a_shortinfo_key := cgg_zero_id;
                                        (* PTS 1106602 E.Z. *)
                                        IF  (
                                            (acv.a_is_ddl <> no_ddl)                                        AND
                                            (acv.a_returncode      <> cak_e_corelated_subquery_not_allowed) AND
                                            (acv.a_returncode      <> cak_e_subq_type_diff)
                                            )
                                        THEN
                                            BEGIN
                                            again := false;
                                            a52end_rollback_subtrans (
                                                  acv, a01_il_b_identifier,
                                                  m_end);
                                            IF  refresh_catalog
                                            THEN
                                                a10refresh_cache (acv)
                                            ELSE
                                                a10_cache_delete (acv,
                                                      NOT c_is_rollback);
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            BEGIN
                                            acv.a_costsum       := init_costsum;
                                            acv.a_ex_kind       := init_ex_kind;
                                            IF  acv.a_in_internal_subtr
                                            THEN
                                                BEGIN
                                                (* PTS 1106602 E.Z. *)
                                                IF  (
                                                    (acv.a_is_ddl = ddl_create_as_select) AND
                                                    (acv.a_returncode      = cak_e_corelated_subquery_not_allowed)
                                                    )                                                                  OR
                                                    (
                                                    (acv.a_is_ddl <> no_ddl) AND
                                                    (acv.a_returncode = cak_e_subq_type_diff)
                                                    )
                                                THEN
                                                    BEGIN
                                                    (* needed, otherwise the stored_cmd   *)
                                                    (* will be destroyed, which is needed *)
                                                    (* for the second try of the select   *)
                                                    m_init_ddl := acv.a_init_ddl;
                                                    acv.a_init_ddl := no_ddl;
                                                    a52end_rollback_subtrans (
                                                       acv, a01_il_b_identifier,
                                                       m_end);
                                                    acv.a_init_ddl := m_init_ddl
                                                    END
                                                ELSE
                                                    a52end_rollback_subtrans (
                                                       acv, a01_il_b_identifier,
                                                       m_end)
                                                (*ENDIF*) 
                                                END;
                                            (*ENDIF*) 
                                            IF  refresh_catalog
                                            THEN
                                                a10refresh_cache (acv)
                                            ELSE
                                                a10_cache_delete (acv,
                                                      NOT c_is_rollback);
                                            (*ENDIF*) 
                                            IF  acv.a_cmd_part = NIL
                                            THEN
                                                again := false
                                            ELSE
                                                BEGIN
                                                acv.a_cmd_part^.sp1p_buf_len    := save_cmd_length;
                                                acv.a_data_length   := save_data_length;
                                                IF  (acv.a_returncode      = cak_e_corelated_subquery_not_allowed)
                                                THEN
                                                    BEGIN
                                                    again := (acv.a_is_ddl = no_ddl) OR
                                                       (acv.a_is_ddl = ddl_create_as_select);
                                                    IF  again AND
                                                     (acv.a_max_intern_select > 0) AND
                                                     (acv.a_intern_select_cnt > 0)
                                                    THEN
                                                     BEGIN
                                                     (* everything was destroyed *)
                                                     (* by a10cmd_rollback       *)
                                                     (* start at the very first beginning *)
                                                     again := false;
                                                     END
                                                    (*ENDIF*) 
                                                    END
                                                ELSE
                                                    (* PTS 1000985/1001162 E.Z. *)
                                                    IF  ((csa_subq_datatype_problem in acv.a_sql_cmd_state) AND
                                                     (acv.a_returncode = cak_e_subq_type_diff))
                                                    THEN
                                                     BEGIN
                                                     IF  countdatatypes <= max_countdatatypes
                                                     THEN
                                                      BEGIN
                                                      countdatatypes := succ(countdatatypes);
                                                      again := true;
                                                      acv.a_part_rollback := true;
                                                      acv.a_sql_cmd_state :=
                                                         acv.a_sql_cmd_state -
                                                         [ csa_subq_datatype_problem ];
                                                      acv.a_returncode := 0;
                                                      countfilevers := pred(countfilevers);
                                                      END
                                                     ELSE
                                                      BEGIN
                                                      again := false;
                                                      acv.a_returncode := 0;
                                                      a07_b_put_error (acv, e_incompatible_datatypes, 1)
                                                      END
                                                     (*ENDIF*) 
                                                     END
                                                    ELSE
                                                     BEGIN
                                                     again           := false;
                                                     acv.a_parsing_again := acv.a_returncode = csp_old_fileversion;
                                                     acv.a_try_again     := true;
                                                     a542reset_packet (acv)
                                                     END
                                                    (*ENDIF*) 
                                                (*ENDIF*) 
                                                END
                                            (*ENDIF*) 
                                            END
                                        (*ENDIF*) 
                                        END
                                    (*ENDIF*) 
                                (* PTS 1122846 E.Z. *)
                                ELSE
                                    again := false
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    UNTIL
                        (NOT again) OR (countfilevers > 1);
                    (*ENDREPEAT*) 
                    END;
                (*ENDIF*) 
                IF  acv.a_returncode <> 0
                THEN
                    IF  (acv.a_returncode =
                        a071_return_code (e_unknown_tablename,
                        acv.a_sqlmode))  OR
                        (acv.a_returncode =
                        a071_return_code (e_unknown_columnname,
                        acv.a_sqlmode)) OR
                        (acv.a_returncode =
                        a071_return_code (e_missing_privilege,
                        acv.a_sqlmode)) OR
                        (acv.a_returncode = cak_e_table_unloaded)
                    THEN
                        BEGIN
                        IF  acv.a_error_tableid <> b01niltree_id.fileTabId_gg00
                        THEN
                            a10table_cache_delete (acv, acv.a_error_tableid)
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  (acv.a_returncode = csp_old_fileversion)
                            (* PTS 1108476 E.Z. *)
                            AND NOT
                            (
                            (acv.a_cmd_segment_header.sp1c_mess_type = sp1m_execute) AND
                            (acv.a_ex_kind = pars_then_execute)             AND
                            (acv.a_is_ddl <> no_ddl)
                            )
                        THEN
                            BEGIN
                            acv.a_returncode := 0;
                            a07_b_put_error (acv,
                                  e_invalid_mix_dml_ddl, 1)
                            END
                        ELSE
                            IF  acv.a_returncode = cak_e_union_in_corr
                            THEN
                                BEGIN
                                acv.a_returncode := 0;
                                a07_b_put_error (acv,
                                      e_corelated_subquery_not_allowe,
                                      -acv.a_errorpos)
                                      (* for -errorpos see vak07, isuni.. *)
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_ap_max_node <> cak_init_node
    THEN
        a10shrink_syntax_tree (acv);
    (*ENDIF*) 
    IF  (symbindex = cak_i_connect) AND (acv.a_returncode = 0)
    THEN
        old_costwarn     := acv.a_costwarn_value
    ELSE
        acv.a_costwarn_value := old_costwarn
    (*ENDIF*) 
    END
ELSE
    (* PTS 1106205 E.Z. *)
    IF  symbindex = cak_i_ping
    THEN
        ak35ping (acv)
    ELSE
        (* PTS 1120377 E.Z. *)
        a07_b_put_error (acv, e_invalid_command, 1)
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak35parse_ddl (
            VAR acv : tak_all_command_glob;
            is_show : boolean);
 
CONST
      c_store_cmd = true;
 
VAR
      b_err         : tgg00_BasisError;
      shortinfo_ptr : tak_sysbufferaddress;
      sysk          : tgg00_SysInfoKey;
 
BEGIN
acv.a_returncode := 0;
IF  ( is_show )
THEN
    acv.a_pars_last_key.p_kind := m_show
ELSE
    BEGIN
    acv.a_pars_last_key.p_kind := m_create_table;
    IF  ( acv.a_is_ddl = no_ddl )
    THEN (* assign any ddl_kind that requires no trigger call *)
        acv.a_is_ddl := ddl_create_table
    (*ENDIF*) 
    END;
(*ENDIF*) 
sysk                     := a01sysnullkey;
sysk.sentrytyp           := cak_eshortinfo;
a10_nil_get_sysinfo( acv, sysk, d_release,
      sizeof( tak_shortinforecord ) - sizeof( tak_paraminfoarr ),
      shortinfo_ptr, b_err );
IF  ( b_err = e_ok )
THEN
    BEGIN
    shortinfo_ptr^.sshortinfo.sicount := 0;
    shortinfo_ptr^.sshortinfo.sisl    := 0;
    acv.a_init_ex_kind                := only_parsing;
    a54_shortinfo_to_varpart( acv, c_store_cmd, shortinfo_ptr );
    (* does all to be done, i.e                      *)
    (* stores the DDL statement in the temp catalog, *)
    (* returns the parseid to the user and destroys  *)
    (* the short info record                         *)
    END
ELSE
    a07_b_put_error( acv, b_err, 1 );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak35call_semantik (VAR acv : tak_all_command_glob;
            prepareHandle        : tgg00_VoidPtr);
 
VAR
      init_sqlmode        : tsp00_SqlMode;
      aux_return          : tsp00_Int2;
      aux_errorpos        : tsp00_Int4;
      dummy_sel_parsid    : tak_parsid;
      dummy_parsid        : tak_parsid;
      call_sm_insert      : boolean;
      reset_running_cmds  : boolean;
      pp                  : tak_parsid;
      dummypp             : tak_parsid;
 
BEGIN
WITH acv, a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
    IF  a_count_variab > csp_maxvariables
    THEN
        a07_b_put_error( acv, e_too_many_variables, 1 )
    ELSE
        BEGIN
        IF  (acv.a_transinf.tri_trans.trBdTcachePtr_gg00 <> NIL) AND
            (a01diag_monitor_on OR a01diag_analyze_on) AND
            NOT ((a_statement_kind = iselects) AND (n_proc = a73))
        THEN
            BEGIN
&           ifdef trace
            t01bool( test_ak, 'reset cmdmon', true);
&           endif
            b21m_parseid( acv.a_transinf.tri_trans.trBdTcachePtr_gg00, pp, dummypp );
            IF  ( pp.pid_session.ci4_gg00 <> '    ' ) AND
                ( ord( pp.pid_parsk.p_kind) <> ord( bsp_c1 ))
                (* not counted values stored in b21 *)
            THEN
                a545sm_insert( acv );
            (*ENDIF*) 
            b21m_reset_monitor (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                  c_reset_sum);
            END;
        (*ENDIF*) 
        call_sm_insert     := false;
        reset_running_cmds := false;
        IF  (a_ex_kind <> only_parsing) AND
            g01diag_moni_parse_on       AND
            a_in_session                AND
            (
            (a_statement_kind in [ideletes, iinserts, iupdates,
            icommits, irollbacks, ialters, icreates, idrops])
            OR
            ((a_statement_kind = iselects) AND (n_proc <> a73))
            ) AND
            (acv.a_initial_segment_header.sp1c_mess_type <> sp1m_execute)
        THEN
            BEGIN
            dummy_parsid.pid_session :=
                  a_transinf.tri_trans.trSessionId_gg00;
            dummy_parsid.pid_parsk   := a_pars_last_key;
            dummy_parsid.pid_appl_info[1]  := chr(0);
            dummy_parsid.pid_dtime_info[1] := chr(ord(dtf_none));
            dummy_sel_parsid.pid_session.ci4_gg00
                  := cgg_nil_session;
            a545diag_parse_info (acv, dummy_parsid, dummy_sel_parsid);
            a42put_running_cmds (acv, dummy_parsid);
            reset_running_cmds := true;
            IF  a01diag_monitor_on OR a01diag_analyze_on
            THEN
                BEGIN
                b21mp_parseid_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                      dummy_parsid, dummy_parsid);
                call_sm_insert := true;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        CASE n_proc OF
            no_proc,
            a14, a19,
            a20,                               a27,      a29,
            a32, a33,      a35,                a39,
            a40,                                         a49,
            a59,
            a61, a68, a69,
            a71, a72, a74,
            a81 :
                BEGIN
                (* PTS 1104914 E.Z. *)
                a07_b_put_error (acv, e_invalid_command, ord(n_proc));
                END;
            a10 :
                BEGIN
                (* PTS 1104914 E.Z. *)
                (* create schema has nothing to do *)
                END;
            a11 :
                a11_call_semantic (acv);     (* table *)
            a12 :
                a12_call_semantic (acv);     (* domain *)
            a13 :
                a13_call_semantic (acv);     (* alter table *)
            a15 :
                a15save_restore_catalog (acv);
            a16 :
                a16_call_semantic (acv);     (* create view  *)
            a17 :
                a17call_semantic (acv);
            a18 :
                a18_call_semantic (acv);     (* exist,rename table *)
            a21 :
                a21_call_semantic (acv);     (* user *)
            a22 :
                a22_call_semantic (acv);     (* grant *)
            a23 :
                a23_call_semantic (acv);     (* synonym *)
            a24 :
                a24_call_semantic (acv, ignore_no_errors); (*index*)
            a25 :
                a25link_semantic (acv, 1);      (* Link *)
            a26 :
                a26comment_on (acv);
            a260 : (* PTS 1104914 T.A. call of dbproc happens in VAK93 *)
                acv.a_stored_proc_call := true;
            a261 :
                a261proc_handling (acv);
            a262 :
                a262trigger_semantic (acv);
            a264 :
                a264function_semantic (acv);
            a28 :
                a28update_statistics (acv);
            a30 :
                BEGIN
                END;
            a34 :
                a34call_semantic (acv);
            a36, a37 :
                ak35dbmcommands (acv);
            a38 :
                a38_call_semantic (acv);     (* drop program *)
            a41, a43 :
                BEGIN
                init_sqlmode := a_sqlmode;
                IF  (a_sqlmode = sqlm_oracle)                           AND
                    (a_ap_tree^[ n_lo_level ].n_subproc <> cak_i_param) AND
                    (n_proc    = a41)
                THEN
                    a_sqlmode := sqlm_internal;
                (*ENDIF*) 
                a41_show_semantic (acv);    (* shows *)
                IF  init_sqlmode = sqlm_oracle
                THEN
                    a_sqlmode := init_sqlmode;
                (*ENDIF*) 
                END;
            a42 :
                a42_start_semantic (acv);    (* start monitor *)
            a44 :
                a42_check_database (acv);
            a51 :
                a51semantic (acv);
            a52 :
                a52_call_semantik (acv, n_subproc);
            a56 :
                IF  n_subproc = cak_x_insert_select
                THEN
                    a562_select_insert (acv)
                ELSE
                    a56_insert_statement (acv);
                (*ENDIF*) 
            a57 :
                a57_update_statement (acv, a_ap_tree^[ 0 ].n_lo_level);
            a58 :
                a58_delete (acv, a_ap_tree^[ 0 ].n_lo_level);
            a62 :
                BEGIN
                a62_direct_ordered_select (acv, a_ap_tree^[ 0 ].n_lo_level);
                IF  (a_may_be_direct_sel AND
                    ((a_returncode =
                    a071_return_code (e_missing_basetable,
                    a_sqlmode)) OR
                    (a_returncode =
                    a071_return_code (e_no_resulttable_allowed,
                    a_sqlmode)) OR
                    (a_returncode =
                    a071_return_code (e_missing_keyfield,
                    a_sqlmode)) OR
                    (a_returncode =
                    a071_return_code (e_column_must_be_keycolumn,
                    a_sqlmode)) OR
                    (a_returncode =
                    a071_return_code (e_duplicate_columnname,
                    a_sqlmode))))
                THEN
                    (* PTS 1111575 E.Z. *)
                    BEGIN
                    a_may_be_direct_sel := false;
                    a_max_intern_select := 0;
                    a_intern_select_cnt := 0;
                    a_parameter_offset  := 0;
                    a_precomp_info_byte := csp1_p_none;
                    a_errpos_offset     := 0;
                    a_command_kind      := single_command;
                    a_timestamp         := bsp_c20;
                    a_isolation_info    := temp_lock_rec_not_needed;
                    a_error_tableid     := b01niltree_id.fileTabId_gg00;
                    a_shortinfo_key     := cgg_zero_id;
                    aux_return          := acv.a_returncode;
                    aux_errorpos        := acv.a_errorpos;
                    a_returncode        := 0;
                    WITH a_pars_last_key DO
                        BEGIN
                        p_id   := chr(0);
                        p_kind := m_nil;
                        p_no   := 0
                        END;
                    (*ENDWITH*) 
                    a_first_parskey    := chr(0);
                    a_tempinfo_key     := cgg_zero_id;
                    a06drop_fieldlist_references (acv.a_mblock.mb_fieldlists);
                    a01_init_command (acv);
                    a60_aselect_statement (acv,
                          a_ap_tree^[ 0 ].n_lo_level);
                    IF  a_returncode <> 0
                    THEN
                        BEGIN
                        (* it was really a wrong SELECT DIRECT *)
                        acv.a_returncode := aux_return;
                        acv.a_errorpos   := aux_errorpos;
                        END;
                    (*ENDIF*) 
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        IF  ( (acv.a_init_ddl = no_ddl)  AND
                            (acv.a_ex_kind <> only_syntax) AND
                            (acv.a_ap_tree = acv.a_session_ap_tree) AND
                            (acv.a_queryrewrite_mode = Operator_Rewrite) AND
                            (acv.a_command_kind <> complex_view_command ) AND
                            (acv.a_precomp_info_byte <> csp1_p_select_for_update_found) AND
                            (acv.a_precomp_info_byte <> csp1_p_for_upd_mselect_found) AND
                            (acv.a_precomp_info_byte <> csp1_p_reuse_update_sel_found) AND
                            (acv.a_precomp_info_byte <> csp1_p_reuse_upd_mselect_found) )
                        THEN
                            IF  (acv.a_cmd_segm^.sp1s_segm_header.sp1c_producer
                                <> sp1pr_complex_view_handling)
                            THEN
                                BEGIN
                                a664_QueryRewrite(acv, prepareHandle);
&                               ifdef trace
                                t01bool( ak_syn, 'QRW Modified', acv.a_queryrewrite_modified);
                                t01bool( ak_syn, 'QRW Optimize', (acv.a_queryrewrite_done = Operator_Rewrite));
                                t01int4( ak_syn, 'a_returncode', acv.a_returncode);
                                t01moveobj( ak_syn, acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len );
&                               endif
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        IF  acv.a_returncode = 0
                        THEN
                            a660_select (acv, a_ap_tree^[ 0 ].n_lo_level);
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            a63 :
                a660_select (acv, a_ap_tree^[ 0 ].n_lo_level);
            a73 :
                a73_call_semantic (acv); (*(m)fetch/close/describe*)
            (* drop parseid, next stamp, next long *)
            OTHERWISE
                BEGIN
                (* PTS 1104914 E.Z. *)
                a07_b_put_error (acv, e_invalid_command, ord(n_proc));
                END
            END;
        (*ENDCASE*) 
        IF  call_sm_insert
        THEN
            BEGIN
            a545sm_insert( acv );
            b21m_reset_monitor (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                  c_reset_sum);
            END;
        (*ENDIF*) 
        IF  reset_running_cmds
        THEN
            a42reset_running_cmds (acv);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
IF  ( acv.a_init_ex_kind = parsing_executing ) AND
    ( acv.a_first_hint_node <> csp_minint2 )
THEN
    a80drop_all_hint_info( acv )
ELSE
    (* will be droped with prefix delete on 'close cursor' or 'drop parsid' *)
    ;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak35refresh_catalog (VAR acv : tak_all_command_glob) : boolean;
 
BEGIN
WITH acv DO
    ak35refresh_catalog  := (a_is_ddl = no_ddl) AND
          (a_intern_select_cnt = 0)             AND
          (a_in_packet <> NIL     )             AND
          (* PTS 1113100 E.Z. *)
          (a101_IsExtendedTempFile (acv, acv.a_pars_curr)) AND
          (a101_GetExtendedTempFileType (acv,
          acv.a_pars_curr) <> ttfnTrigger_egg00) AND
          (( a_returncode = a071_return_code (
          e_null_value_illegal, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_column_must_be_keycolumn, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_col_must_be_no_keycolumn, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_column_must_have_default, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_column_not_indexed, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_const_incompatible_with_typ, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_incompatible_datatypes, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_invalid_datalength, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_invalid_length_of_datatyp, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_join_fields_too_long, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_missing_column_definite, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_missing_mandatory_recordfield, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_missing_privilege, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_one_output_field_too_long, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_output_columns_too_long, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_too_few_columns, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_too_many_columns, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_too_many_values, a_sqlmode)) OR
          ( a_returncode = a071_return_code (
          e_unknown_columnname, a_sqlmode)) OR
          (* PTS 1000985/1001162 E.Z. *)
          (csa_subq_datatype_problem in a_sql_cmd_state) OR
          (* PTS 1121166 T.A. *)
          ( a_returncode = a071_return_code (
          e_sysinfo_not_found, a_sqlmode))
          )
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a35_flush_vtrace (VAR acv : tak_all_command_glob);
 
BEGIN
a01_next_symbol (acv);
a01_is_end_symbol (acv);
IF  acv.a_returncode = 0
THEN
    BEGIN
    b120FlushTrace( acv.a_transinf.tri_trans.trTaskId_gg00 );
    IF  acv.a_curr_user_name = a01_il_b_identifier
    THEN
        acv.a_returncode := cak_e_released;
    (*ENDIF*) 
    acv.a_return_segm^.sp1r_function_code := csp1_diagnose_fc;
    (* PTS 1113577 E.Z. *)
    IF  acv.a_ex_kind = only_parsing
    THEN
        BEGIN
        a01_call_put (acv, a36, cak_x_diagnose, acv.a_ap_tree^[0].n_lo_level);
        ak35parse_ddl (acv, false);
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(* PTS 1106205 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak35ping (VAR acv : tak_all_command_glob);
 
VAR
      i            : integer;
      parsid       : tsp00_C12;
 
BEGIN
a01_next_symbol (acv);
a01_is_end_symbol (acv);
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  acv.a_curr_user_name = a01_il_b_identifier
    THEN
        acv.a_returncode := cak_e_released;
    (*ENDIF*) 
    acv.a_return_segm^.sp1r_function_code := csp1_diagnose_fc;
    IF  acv.a_ex_kind = only_parsing
    THEN
        BEGIN
        FOR i := 1 TO sizeof(parsid) DO
            parsid[ i ] := csp_defined_byte;
        (*ENDFOR*) 
        parsid[ sizeof(parsid)-1 ] := chr(csp1_p_command_executed);
        a06retpart_move (acv, @parsid, sizeof(parsid));
        a06finish_curr_retpart (acv, sp1pk_parsid, 1)
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak35c_utilprot_cmd (
            VAR acv           : tak_all_command_glob;
            VAR prot_needed   : boolean;
            VAR with_tapeinfo : boolean;
            VAR util_cmd_id   : tgg00_UtilCmdId;
            is_verify         : boolean;
            VAR line          : tsp00_String);
 
VAR
      prot_buf    : tsp00_Buf;
      curr_n      : tsp00_Int2;
      buf_len     : tsp00_Int4;
      err_char_no : tsp00_Int4;
      maxlinelen  : integer;
      uni_err     : tsp8_uni_error;
      move_err    : tgg00_BasisError;
      cmd_len     : integer;
      rest_len    : integer;
      line_ptr    : ^tsp00_Line;
 
BEGIN
IF  NOT prot_needed
THEN
    IF  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc = a36
    THEN
        a36utilprot_needed (acv, prot_needed, with_tapeinfo)
    ELSE
        a37utilprot_needed (acv, prot_needed, with_tapeinfo);
    (*ENDIF*) 
(*ENDIF*) 
IF  prot_needed
THEN
    WITH acv, a_cmd_part^ DO
        BEGIN
        line_ptr  := @prot_buf;
        ak35h_utilprot_header (acv,
              uhk_request, line_ptr^, buf_len, util_cmd_id);
        curr_n := a_ap_tree^[ 0 ].n_lo_level;
        (* PTS 1120611 E.Z. *)
        IF  (a_ap_tree^[curr_n].n_proc     = a36)               AND
            (a_ap_tree^[curr_n].n_subproc  = cak_x_init_config) AND
            (a_ap_tree^[curr_n].n_sa_level <> 0)
        THEN
            curr_n := a_ap_tree^[curr_n].n_sa_level;
        (*ENDIF*) 
        IF  (a_ap_tree^[curr_n].n_proc     = a36)            AND
            (a_ap_tree^[curr_n].n_subproc  = cak_x_activate) AND
            (a_ap_tree^[curr_n].n_sa_level <> 0)
        THEN (* ACTIVATE SERVERDB SYSDBA ... PASSWORD ... *)
            (*  Here we better cut the PASSWORD off.      *)
            WITH a_ap_tree^[ a_ap_tree^[curr_n].n_sa_level ] DO
                cmd_len := n_pos + n_length -1
            (*ENDWITH*) 
        ELSE
            cmd_len := sp1p_buf_len;
        (*ENDIF*) 
        IF  g01unicode
        THEN      (* Since utility commands have to be in ascii, *)
            BEGIN (* we simply transform it back. CK, 21.3.97    *)
            rest_len := sizeof (tsp00_Buf) - buf_len;
            s80uni_trans (@sp1p_buf[ 1 ],           cmd_len,  csp_unicode,
                  @prot_buf[ 1 + buf_len ], rest_len, csp_ascii,
                  [ ], uni_err, err_char_no)
            END
        ELSE
            BEGIN
            IF  cmd_len < sizeof (tsp00_Buf) - buf_len
            THEN
                rest_len := cmd_len
            ELSE
                rest_len := sizeof (tsp00_Buf) - buf_len;
            (*ENDIF*) 
            move_err := e_ok;
            SAPDB_PascalMove ('VAK35 ',   1,    
                  sp1p_buf_size, sizeof (prot_buf),
                  @sp1p_buf, 1, @prot_buf, 1 + buf_len, rest_len, move_err)
            END;
        (*ENDIF*) 
        buf_len := buf_len + rest_len;
        maxlinelen := sizeof(line.text)
              -  1 (* ' '          *)
              -  1 (* ':'          *)
              - 10 (* 'RETURNCODE' *)
              -  6 (* RETURNCODE   *);
        IF  is_verify
        THEN
            maxlinelen := maxlinelen
                  -  1 (* ';'          *)
                  -  2 * (1 + mx_page_cnt + 18)  (* BAD INDEXES *) + 8;
        (*ENDIF*) 
        IF  buf_len > maxlinelen
        THEN
            BEGIN
            WHILE (maxlinelen > 21) (* to have at least beginning of command *)
                  AND (prot_buf [maxlinelen] <> ' ') DO
                maxlinelen := pred(maxlinelen);
            (*ENDWHILE*) 
            line.length := pred(maxlinelen);
            END
        ELSE
            line.length := buf_len;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK35 ',   2,    
              sizeof (prot_buf), sizeof (line.text),
              @prot_buf, 1, @line.text, 1, line.length, move_err);
        vutilprot (prot_buf, buf_len)
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak35r_utilprot_retcode (
            VAR acv         : tak_all_command_glob;
            prot_needed     : boolean;
            with_tapeinfo   : boolean;
            isAutoSave      : boolean;
            isVerify        : boolean;
            VAR util_cmd_id : tgg00_UtilCmdId;
            VAR line        : tsp00_String);
 
VAR
      ln_len     : integer;
      buf_ptr    : ^tsp00_Buf;
      move_err   : tgg00_BasisError;
      data_part  : tsp1_part_ptr;
      sinfo_part : tsp1_part_ptr;
      coln_part  : tsp1_part_ptr;
 
BEGIN
WITH acv DO
    BEGIN
    IF  isAutoSave          AND
        (a_returncode <> 0) AND
        (a_returncode <> 100)
    THEN
        BEGIN
        prot_needed := true;
        ak35c_utilprot_cmd (acv,
              prot_needed, with_tapeinfo,
              util_cmd_id, false, line);
        END;
    (*ENDIF*) 
    IF  prot_needed
    THEN
        BEGIN
        move_err := e_ok;
        buf_ptr  := @line.text;
        ln_len := line.length;
        line.text [line.length+1] := ':';
        line.text [line.length+2] := ' ';
        line.text [line.length+3] := 'R';
        line.text [line.length+4] := 'E';
        line.text [line.length+5] := 'T';
        line.text [line.length+6] := 'U';
        line.text [line.length+7] := 'R';
        line.text [line.length+8] := 'N';
        line.text [line.length+9] := 'C';
        line.text [line.length+10]:= 'O';
        line.text [line.length+11]:= 'D';
        line.text [line.length+12]:= 'E';
        line.length := line.length + 12;
        IF  a_returncode < 0
        THEN
            g17int4to_line (a_returncode,
                  NOT c_with_zero, 6, line.length+1, line.text)
        ELSE
            g17int4to_line (a_returncode MOD cak_e_released,
                  NOT c_with_zero, 6, line.length+1, line.text);
        (*ENDIF*) 
        line.length   := line.length + 6;
        IF  isVerify
        THEN
            BEGIN
            line.length         := line.length + 1;
            line.text[ line.length ] := ';';
            IF  a_returncode = 0
            THEN
                BEGIN
                s26find_part (a_return_segm^, sp1pk_data, data_part);
                IF  data_part <> NIL
                THEN
                    WITH data_part^ DO
                        BEGIN
                        line.length         := line.length + 1;
                        line.text[ line.length ] := ' ';
                        SAPDB_PascalMove ('VAK35 ',   3,    
                              sp1p_buf_size, sizeof (line.text),
                              @sp1p_buf, 2, @buf_ptr^, line.length+1, mx_page_cnt,
                              move_err);
                        line.length := line.length + mx_page_cnt;
                        ln_len := line.length;
                        g17nameto_line (' PERM PAGES,      ', ln_len, line.text);
                        ln_len := ln_len + 1;
                        line.text[ ln_len ] := ' ';
                        SAPDB_PascalMove ('VAK35 ',   4,    
                              sp1p_buf_size, sizeof (line.text),
                              @sp1p_buf, 13, @buf_ptr^, ln_len+1, mx_page_cnt,
                              move_err);
                        ln_len := ln_len + mx_page_cnt;
                        g17nameto_line (' RELEASED BLOCKS  ', ln_len, line.text);
                        line.length := ln_len;
                        END
                    (*ENDWITH*) 
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                s26find_part (a_return_segm^, sp1pk_data, data_part);
                IF  data_part <> NIL
                THEN
                    WITH data_part^ DO
                        BEGIN
                        move_err       := e_ok;
                        line.length         := line.length + 1;
                        line.text[ line.length ] := ' ';
                        SAPDB_PascalMove ('VAK35 ',   5,    
                              sp1p_buf_size, sizeof (line.text),
                              @sp1p_buf, 1, @buf_ptr^, line.length+1, mx_page_cnt,
                              move_err);
                        line.length := line.length + mx_page_cnt;
                        ln_len := line.length;
                        g17nameto_line (' BAD INDEXES      ', ln_len, line.text);
                        ln_len := ln_len + 1;
                        line.text[ ln_len ] := ' ';
                        SAPDB_PascalMove ('VAK35 ',   6,    
                              sp1p_buf_size, sizeof (line.text),
                              @sp1p_buf, 11, @buf_ptr^, ln_len+1, mx_page_cnt,
                              move_err);
                        ln_len := ln_len + mx_page_cnt;
                        g17nameto_line (' TOTAL BAD FILES  ', ln_len, line.text);
                        line.length := ln_len;
                        END
                    (*ENDWITH*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        vutilprot (buf_ptr^, line.length);
        IF  with_tapeinfo
        THEN
            BEGIN
            s26find_part (a_return_segm^,
                  sp1pk_data, data_part);
            s26find_part (a_return_segm^,
                  sp1pk_shortinfo, sinfo_part);
            s26find_part (a_return_segm^,
                  sp1pk_columnnames, coln_part);
            IF  (data_part  <> NIL) AND
                (sinfo_part <> NIL) AND
                (coln_part  <> NIL)
            THEN
                ak35save_info (acv,
                      data_part^, sinfo_part^, coln_part^,
                      util_cmd_id);
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak35dbmcommands (VAR acv : tak_all_command_glob);
 
VAR
      prot_needed         : boolean;
      with_tapeinfo       : boolean;
      isAutoSave          : boolean;
      isVerify            : boolean;
      util_cmd_id         : tgg00_UtilCmdId; (* PTS 1104845 UH 02-12-1999 *)
      line                : tsp00_String;
 
BEGIN
prot_needed   := false;
with_tapeinfo := false;
isAutoSave    := false;
WITH acv, a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
    isVerify      := n_subproc = cak_x_verify;
(*ENDWITH*) 
util_cmd_id.utidId_gg00     := bsp_c12;
util_cmd_id.utidLineNo_gg00 := 0;
ak35c_utilprot_cmd (acv, prot_needed, with_tapeinfo, util_cmd_id, isVerify, line);
WITH acv, a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
    IF  n_proc = a36
    THEN
        a36_call_semantic (acv, util_cmd_id)
    ELSE
        BEGIN
        isAutoSave := (n_subproc = cak_x_autosave) AND (n_length  = cak_i_show);
        a37_call_semantic (acv, util_cmd_id);
        END;
    (*ENDIF*) 
(*ENDWITH*) 
ak35r_utilprot_retcode (acv, prot_needed, with_tapeinfo, isAutoSave, isVerify, util_cmd_id, line);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak35save_info (
            VAR acv         : tak_all_command_glob;
            VAR data_part   : tsp1_part;
            VAR sinfo_part  : tsp1_part;
            VAR coln_part   : tsp1_part;
            VAR util_cmd_id : tgg00_UtilCmdId);
 
CONST
      c_undef = 'UNDEF       ';
      c_true  = 'TRUE        ';
      c_false = 'FALSE       ';
 
VAR
      curr_index : integer;
      buf_len    : integer;
      buf        : tsp00_Buf;
      line_ptr   : ^tsp00_Line;
      sinfo_pos  : tsp00_Int4;
      coln_pos   : tsp00_Int4;
      head_len   : integer;
      this_len   : integer;
      num_len    : integer;
      namelen    : integer;
      num_err    : tsp00_NumError;
      move_err   : tgg00_BasisError;
      err_char_no: tsp00_Int4;
      error      : tsp8_uni_error;
      sinfo      : tsp1_param_info;
 
BEGIN
coln_pos  := 1;
sinfo_pos := 1;
move_err  := e_ok;
line_ptr  := @buf;
(* PTS 1000584 UH *)
FOR curr_index := 1 TO sinfo_part.sp1p_arg_count DO
    BEGIN
    ak35h_utilprot_header (acv, uhk_save, line_ptr^,
          head_len, util_cmd_id); (* PTS 1000584 UH *)
    buf_len   := head_len;
    this_len := ord (coln_part.sp1p_buf[ coln_pos ]);
    (* PTS 1115493 E.Z. *)
    IF  acv.a_out_packet^.sp1_header.sp1h_mess_code <> csp_ascii
    THEN
        BEGIN
        namelen := this_len DIV 2;
        s80uni_trans (@(coln_part.sp1p_buf[coln_pos+1]), this_len,
              acv.a_out_packet^.sp1_header.sp1h_mess_code,
              @(buf[buf_len+1]), namelen, csp_ascii,
              [ ], error, err_char_no);
        IF  error <> uni_ok
        THEN
            a07_hex_uni_error (acv, error, 1, NOT c_trans_to_uni,
                  @(coln_part.sp1p_buf[coln_pos+err_char_no]), c_unicode_wid);
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        SAPDB_PascalMove ('VAK35 ',   7,    
              coln_part.sp1p_buf_size, sizeof (buf),
              @coln_part.sp1p_buf, coln_pos+1, @buf, buf_len+1,
              this_len, move_err);
        namelen := this_len;
        END;
    (*ENDIF*) 
    buf_len  := buf_len      + namelen;
    coln_pos := coln_pos + 1 + this_len;
    IF  buf_len < head_len+18
    THEN
        SAPDB_PascalFill ('VAK35 ',   8,    
              sizeof (buf), @buf, buf_len+1, head_len+18-buf_len,
              '.', move_err);
    (*ENDIF*) 
    buf_len         := head_len+18+1;
    buf[ buf_len ] := ' ';
    SAPDB_PascalMove ('VAK35 ',   9,    
          sinfo_part.sp1p_buf_size, sizeof (sinfo),
          @sinfo_part.sp1p_buf, sinfo_pos, @sinfo, 1,
          sizeof (sinfo), move_err);
    sinfo_pos := sinfo_pos + sizeof (sinfo);
&   ifdef trace
    t01int4 (ak_sem, 'bufpos      ', sinfo.sp1i_bufpos);
    t01int4 (ak_sem, 'data_type   ', ord (sinfo.sp1i_data_type));
&   endif
    WITH data_part, sinfo DO
        IF  sp1p_buf[ sp1i_bufpos ] = csp_undef_byte
        THEN
            g17sname_to_line (c_undef, buf_len, line_ptr^)
        ELSE
            CASE sp1i_data_type OF
                dcha:
                    BEGIN
                    this_len := s30lnr (sp1p_buf, csp_ascii_blank,
                          sp1i_bufpos + 1, sp1i_length);
                    SAPDB_PascalMove ('VAK35 ',  10,    
                          sp1p_buf_size, sizeof (buf),
                          @sp1p_buf, sp1i_bufpos + 1,
                          @buf, buf_len + 1,
                          this_len, move_err);
                    buf_len := buf_len + this_len
                    END;
                ddate:
                    BEGIN
                    buf[ buf_len + 1 ] := sp1p_buf[ sp1i_bufpos+1 ];
                    buf[ buf_len + 2 ] := sp1p_buf[ sp1i_bufpos+2 ];
                    buf[ buf_len + 3 ] := sp1p_buf[ sp1i_bufpos+3 ];
                    buf[ buf_len + 4 ] := sp1p_buf[ sp1i_bufpos+4 ];
                    buf[ buf_len + 5 ] := '-';
                    buf[ buf_len + 6 ] := sp1p_buf[ sp1i_bufpos+5 ];
                    buf[ buf_len + 7 ] := sp1p_buf[ sp1i_bufpos+6 ];
                    buf[ buf_len + 8 ] := '-';
                    buf[ buf_len + 9 ] := sp1p_buf[ sp1i_bufpos+7 ];
                    buf[ buf_len +10 ] := sp1p_buf[ sp1i_bufpos+8 ];
                    buf_len             := buf_len + 10;
                    END;
                dtime:
                    BEGIN
                    buf[ buf_len+1 ] := sp1p_buf[ sp1i_bufpos+3 ];
                    buf[ buf_len+2 ] := sp1p_buf[ sp1i_bufpos+4 ];
                    buf[ buf_len+3 ] := ':';
                    buf[ buf_len+4 ] := sp1p_buf[ sp1i_bufpos+5 ];
                    buf[ buf_len+5 ] := sp1p_buf[ sp1i_bufpos+6 ];
                    buf[ buf_len+6 ] := ':';
                    buf[ buf_len+7 ] := sp1p_buf[ sp1i_bufpos+7 ];
                    buf[ buf_len+8 ] := sp1p_buf[ sp1i_bufpos+8 ];
                    buf_len           := buf_len + 8;
                    END;
                dfixed:
                    BEGIN
                    s42gstr (sp1p_buf, sp1i_bufpos + 1,
                          csp_resnum_deflen, 0, csp_resnum_deflen,
                          line_ptr^, buf_len + 1, num_len, num_err);
                    buf_len := buf_len + num_len
                    END;
                dboolean:
                    IF  ord (sp1p_buf[ sp1i_bufpos+1 ]) <> 0
                    THEN
                        g17sname_to_line (c_true, buf_len, line_ptr^ )
                    ELSE
                        g17sname_to_line (c_false, buf_len, line_ptr^);
                    (*ENDIF*) 
                OTHERWISE;
                END;
            (*ENDCASE*) 
        (*ENDIF*) 
    (*ENDWITH*) 
    vutilprot (buf, buf_len);
    END;
(*ENDFOR*) 
k38UtilIdSaveLineNo (util_cmd_id); (* PTS 1108625 UH 2000-12-11 *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak35h_utilprot_header (
            VAR acv         : tak_all_command_glob;
            header_kind     : t_utilheader_kind;
            VAR ln          : tsp00_Line;
            VAR ln_len      : integer;
            VAR util_id_str : tgg00_UtilCmdId);
 
CONST
      c_request     = 'REQ';
      c_receive     = 'RET';
      c_save        = 'TAP';
 
VAR
      use_old_id  : boolean;                     (* PTS 1000584 UH *)
      dummy_err   : tgg00_BasisError;             (* PTS 1000431 UH *)
      header      : tsp00_C3;
      c3_ptr      : ^tsp00_C3;
      line_ptr    : ^tsp00_Line;                   (* PTS 1000584 UH *)
      aux_line_no : tsp_int_map_c2;   (* PTS 1104845 UH 02-12-1999 *)
 
BEGIN
SAPDB_PascalForcedFill (sizeof (ln), @ln, 1, 24, ' ');          (* PTS 1000584 UH *)
use_old_id := false;                           (* PTS 1000584 UH *)
IF  header_kind = uhk_request                  (* PTS 1000584 UH *)
THEN
    CASE acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc OF
        a36:
            IF  (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc IN
                [cak_x_restore_db, cak_x_restore_pages, cak_x_restore_log])
                AND
                (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length IN
                [cak_i_replace, cak_i_ignore, cak_i_cancel])
            THEN
                use_old_id := true;
            (*ENDIF*) 
        a37:
            IF  (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc IN
                [cak_x_save_log, cak_x_save_database, cak_x_save_pages])
                AND
                (acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length IN
                [cak_i_replace, cak_i_ignore, cak_i_cancel])
            THEN
                use_old_id := true;
            (*ENDIF*) 
        END;
    (*ENDCASE*) 
(* PTS 1104845 UH 02-12-1999 begin *)
(*ENDIF*) 
IF  use_old_id
THEN
    k38UtilIdGet (util_id_str)
ELSE
    IF  header_kind = uhk_request
    THEN
        gg999GetNewCommandId (acv.a_transinf.tri_trans.trTaskId_gg00, util_id_str);
    (* PTS 1104845 UH 02-12-1999 end *)
    (*ENDIF*) 
(*ENDIF*) 
dummy_err := e_ok;                             (* PTS 1000431 UH *)
line_ptr  := @util_id_str.utidId_gg00;                     (* PTS 1000584 UH *)
SAPDB_PascalForcedMove (sizeof (util_id_str.utidId_gg00), sizeof (ln),
      @line_ptr^, 1, @ln, 1, sizeof (util_id_str.utidId_gg00)); (* PTS 1000584 UH *)
ln_len   := sizeof (util_id_str.utidId_gg00) + 1;             (* PTS 1000584 UH *)
(* PTS 1104845 UH 02-12-1999 begin *)
aux_line_no.map_int := util_id_str.utidLineNo_gg00;
util_id_str.utidLineNo_gg00 := (util_id_str.utidLineNo_gg00 + 1) MOD 999;
IF  g01code.kernel_swap = sw_normal
THEN
    BEGIN
    g17hexto_line (aux_line_no.map_c2[1], ln_len, ln);
    g17hexto_line (aux_line_no.map_c2[2], ln_len, ln)
    END
ELSE
    BEGIN
    g17hexto_line (aux_line_no.map_c2[2], ln_len, ln);
    g17hexto_line (aux_line_no.map_c2[1], ln_len, ln)
    END;
(*ENDIF*) 
(* PTS 1104845 UH 02-12-1999 end *)
ln_len := sizeof (util_id_str.utidLineNo_gg00) + 1;                (* PTS 1000584 UH *)
CASE header_kind OF
    uhk_request:
        CASE acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_proc OF
            a36:
                CASE acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc OF
                    cak_x_activate:
                        IF  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_sa_level <> 0
                        THEN
                            header := 'AC1'
                        ELSE
                            header := 'AC2';
                        (*ENDIF*) 
                    cak_x_clear_log:
                        header := 'CLR';
                    (* PTS 1120611 E.Z. *)
                    cak_x_init_config:
                        IF  acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_sa_level <> 0
                        THEN
                            header := 'IC1'
                        ELSE
                            header := 'IC2';
                        (*ENDIF*) 
                    cak_x_restart:
                        header := 'RST';
                    cak_x_restore_db:
                        header := 'RDB';
                    cak_x_restore_config:
                        header := 'RCF';
                    cak_x_restore_pages:
                        BEGIN
                        header := 'RPG';
                        END;
                    cak_x_restore_log:
                        header := 'RLG';
                    cak_x_rest_log_from:
                        header := 'RLF';
                    cak_x_verify:
                        header := 'VER';
                    OTHERWISE
                        header := c_request;
                    END;
                (*ENDCASE*) 
            a37:
                CASE acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc OF
                    cak_x_add_devspace:
                        header := 'ADD';
                    cak_x_autosave:
                        CASE acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length OF
                            cak_i_on:
                                header := 'ASO';
                            cak_i_end:
                                header := 'ASE';
                            cak_i_cancel:
                                header := 'ASC';
                            OTHERWISE
                                header := c_request;
                            END;
                        (*ENDCASE*) 
                    (* PTS 1115982 E.Z. *)
                    cak_x_save_log:
                        header := 'SLG';
                    cak_x_save_log_cold:
                        header := 'SLC';
                    cak_x_save_database:
                        header := 'SDB';
                    cak_x_save_pages:
                        header := 'SPG';
                    (* PTS 1111289 E.Z. *)
                    cak_x_shutdown:
                        header := 'SHT';
                    OTHERWISE
                        header := c_request;
                    END;
                (*ENDCASE*) 
            OTHERWISE
                header := c_request;
            END;
        (*ENDCASE*) 
    uhk_receive:
        header := c_receive;
    uhk_save:
        header := c_save;
    END;
(*ENDCASE*) 
c3_ptr  := @ln[ 21 ]; (* PTS 1000584 UH *)
c3_ptr^ := header;
ln_len  := 24;        (* PTS 1000584 UH *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak35odbc_func_call (VAR acv : tak_all_command_glob;
            VAR symbindex : integer);
 
VAR
      org_cmd    : tsp00_MoveObjPtr;
      org_len    : tsp00_Int4;
      req_len    : tsp00_Int4;
      src_end    : tsp00_Int4;
      sn         : tsp00_C4;
      node       : tsp00_Int2;
      res_kw     : boolean;
      sysdbaname : tsp00_KnlIdentifier;
      (* This procedures creates a new sql command in a_cmd_part,    *)
      (* ? = CALL <dbfunction with parameters> will be changed to    *)
      (* SELECT <dbfunction with parameters> INTO ? FROM dual        *)
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_next_symbol (acv);
    a01_force_symbol (acv, s_equal, node, node);
    IF  a_returncode = 0
    THEN
        IF  a01mandatory_keyword (acv, cak_i_call)
        THEN
            IF  sc_symb <> s_identifier
            THEN
                a07_error (acv, e_missing_identifier, node, node)
            ELSE
                BEGIN
                (* Set returncode, so that vak35 can parse a second time. *)
                a_returncode := 0;
                org_len := a_cmd_part^.sp1p_buf_len;
                org_cmd := @a_cmd_part^.sp1p_buf;
                (* SELECT INTO ? FROM <sysdba>.DUAL *)
                req_len := 24 + sizeof (tsp00_KnlIdentifier);
                IF  g01unicode
                THEN
                    req_len := 2 * req_len;
                (*ENDIF*) 
                a542internal_packet (acv,
                      NOT c_release_internal_packet, org_len + req_len);
                IF  a_returncode = 0
                THEN
                    BEGIN
                    a542move_to_packet (acv, @a01kw[cak_i_select], 7);
                    IF  g01unicode
                    THEN
                        BEGIN
                        src_end   := org_len;
                        WHILE ((org_cmd^[ src_end   ] <> '}') OR
                              (org_cmd^[ src_end-1 ] <> csp_unicode_mark))
                              AND (src_end-1 > sc_sypos) DO
                            src_end := src_end - 2;
                        (*ENDWHILE*) 
                        IF  ((org_cmd^[ src_end   ] <> '}') OR
                            (org_cmd^[ src_end-1 ] <> csp_unicode_mark))
                        THEN
                            BEGIN
                            sc_sypos := org_len-1;
                            a07_error (acv, e_missing_keyword, node, node);
                            END;
                        (*ENDIF*) 
                        src_end := src_end - 2;
                        a_cmd_part^.sp1p_buf_len := 14
                        END
                    ELSE
                        BEGIN
                        src_end := org_len;
                        WHILE (org_cmd^[ src_end ] <> '}') AND
                              (src_end > sc_sypos) DO
                            src_end := pred (src_end);
                        (*ENDWHILE*) 
                        IF  org_cmd^[ src_end ] <> '}'
                        THEN
                            BEGIN
                            sc_sypos := org_len;
                            a07_error (acv, e_missing_keyword, node, node);
                            END;
                        (*ENDIF*) 
                        src_end := pred (src_end);
                        a_cmd_part^.sp1p_buf_len := 7;
                        END;
                    (*ENDIF*) 
                    SAPDB_PascalMove ('VAK35 ',  11,    
                          org_len, a_cmd_part^.sp1p_buf_size,
                          @org_cmd^, sc_sypos, @a_cmd_part^.sp1p_buf, a_cmd_part^.sp1p_buf_len+1,
                          src_end + 1 - sc_sypos, a_returncode);
                    a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len +
                          src_end + 1 - sc_sypos + a01char_size;
                    a542move_to_packet (acv, @a01kw[cak_i_into], 5);
                    a542char_to_packet       (acv, '?');
                    a542char_to_packet       (acv, ' ');
                    a542move_to_packet (acv, @a01kw[cak_i_from], 5);
                    sysdbaname := g01glob.sysuser_name;
                    a542identifier_to_packet (acv, sysdbaname);
                    a542char_to_packet       (acv, '.');
                    sn := 'DUAL';
                    a542move_to_packet       (acv, @sn, sizeof (sn));
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
&       ifdef TRACE
        t01moveobj( ak_syn, acv.a_cmd_part^.sp1p_buf, 1, acv.a_cmd_part^.sp1p_buf_len );
&       endif
        a01_init_command (acv);
        a01_get_keyword (acv, symbindex, res_kw);
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
