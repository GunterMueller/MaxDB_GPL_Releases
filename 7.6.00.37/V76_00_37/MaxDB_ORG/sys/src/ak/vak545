.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VAK545$
.tt 2 $$$
.TT 3 $GertG$diagnose_monitor$2000-03-28$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : diagnose monitor
=========
.sp
Purpose : procedures for DIAGNOSE MONITOR
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a545_init;
 
        PROCEDURE
              a545diag_monitor_syntax  (VAR acv : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a545sm_data_tree (VAR acv : tak_all_command_glob;
                    VAR mondata_tree : tgg00_FileId);
 
        PROCEDURE
              a545sm_insert (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a545sm_param_info (VAR acv : tak_all_command_glob;
                    VAR parsid : tak_parsid);
 
        PROCEDURE
              a545sm_reset (VAR monitor_tree : tgg00_FileId);
 
        PROCEDURE
              a545sm_set_rowno (maxrowno : tsp00_Int4);
 
        FUNCTION
              a545sm_get_rowno : tsp00_Int4;
 
        PROCEDURE
              a545diag_parse_info (VAR acv : tak_all_command_glob;
                    VAR parsid     : tak_parsid;
                    VAR sel_parsid : tak_parsid);
 
        PROCEDURE
              a545clear_monitor (VAR acv : tak_all_command_glob);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01kw                : tak_keywordtab;
              a01diag_monitor_on   : boolean;
              a01diag_analyze_on   : boolean;
              a01sm_collect_data   : boolean;
              a01_i_sysmonitor     : tsp00_KnlIdentifier;
              a01_i_sysmondata     : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_call_put (VAR acv : tak_all_command_glob;
                    proc     : tak_procs;
                    subproc  : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_is_end_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_get_keyword (VAR acv : tak_all_command_glob;
                    VAR index : integer;
                    VAR reserved : boolean);
 
        FUNCTION
              a01_eqkey (VAR a : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
        FUNCTION
              a01mandatory_keyword (
                    VAR acv          : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02_aauthid (VAR acv : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_values_tools : VAK03;
 
        PROCEDURE
              a03_aunsigned_integer (VAR acv : tak_all_command_glob;
                    VAR put_node : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (VAR acv : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06lsend_mess_buf (VAR acv : tak_all_command_glob;
                    VAR mbuf        : tgg00_MessBlock;
                    call_from_rsend : boolean;
                    VAR b_err       : tgg00_BasisError);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authid   : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR d_sparr  : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_error (VAR a_scv : tak_all_command_glob;
                    errorcode : tgg00_BasisError;
                    VAR nod1  : tsp00_Int2;
                    VAR nod2  : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
      ------------------------------ 
 
        FROM
              Pseudo_fieldmap : VAK509;
 
        FUNCTION
              a509build_map_from_databuffer (databuffer_ptr : tsp00_MoveObjPtr;
                    map_ptr                  : tsp00_MoveObjPtr;
                    VAR length_in_databuffer : tsp00_Int4) : boolean;
 
        FUNCTION
              a509get_one_value (map_ptr : tsp00_MoveObjPtr;
                    value_no       : tsp00_Int2;
                    VAR value_ptr  : tsp00_MoveObjPtr;
                    VAR value_len  : tsp00_Int4;
                    VAR is_null    : boolean;
                    VAR is_default : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542get_abapinfo (VAR acv : tak_all_command_glob;
                    VAR abapname    : tsp00_C40;
                    VAR abapnamelen : integer;
                    VAR abaplinenr  : tsp00_Number);
 
      ------------------------------ 
 
        FROM
              diagnose analyze : VAK544;
 
        PROCEDURE
              a544put_sysdata_analyze (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92find_return_part (VAR acv : tak_all_command_glob;
                    part_kind    : tsp1_part_kind;
                    VAR part_ptr : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
        PROCEDURE
              b01filestate (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01tcreate_file (VAR t : tgg00_TransContext;
                    VAR current : tgg00_FileId);
 
        PROCEDURE
              b01empty_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02add_record (VAR t : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR b          : tgg00_Rec);
 
        PROCEDURE
              b02del_record (VAR t : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR rk         : tgg00_Lkey);
 
        PROCEDURE
              b02next_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    inclusive   : boolean;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b02repl_record (VAR t : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR b          : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              task_temp_data_cache : VBD21;
 
        PROCEDURE
              b21m_copy_result (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR copy_result : tsp00_C3);
 
        FUNCTION
              b21m_fetch_calls (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_kb_calls (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_microsec (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        PROCEDURE
              b21m_parseid (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR parseid : tsp00_C12;
                    VAR masterparseid : tsp00_C12);
 
        FUNCTION
              b21m_phys_ios (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        PROCEDURE
              b21m_roots (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR cnt          : tsp00_Int4;
                    VAR rootlist_ptr : tgg00_RootListPtr);
 
        FUNCTION
              b21m_rows_fetched (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_rows_qual (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_rows_read (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_sec (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        PROCEDURE
              b21m_strat (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR strategy : tsp00_C40);
 
        FUNCTION
              b21m_suspends (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        PROCEDURE
              b21m_termid (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR termid : tsp00_TermId);
 
        PROCEDURE
              b21m_username (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR username : tsp00_KnlIdentifier);
 
        PROCEDURE
              b21m_values (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR values_addr : tsp00_MoveObjPtr;
                    VAR values_len  : tsp00_Int4);
 
        FUNCTION
              b21m_virt_reads (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_waits (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01tabid          : tgg04_TabIdGlobals;
              g01unicode        : boolean;
              g01glob           : tgg00_KernelGlobals;
 
        FUNCTION
              g01sm_milliseconds : tsp00_Int4;
 
        FUNCTION
              g01sm_reads : tsp00_Int4;
 
        FUNCTION
              g01sm_selectivity : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        VAR
              g08monitor : tsp00_RegionId;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30cmp (VAR buf1   : tsp00_C8;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_Buf;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        PROCEDURE
              s30cmp1 (VAR buf1  : tsp00_Key;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_Key;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        FUNCTION
              s30klen (VAR str : tsp00_C40;
                    val        : char;
                    cnt        : integer) : integer;
 
        FUNCTION
              s30lnr_defbyte (str : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40gbyte (
                    VAR buf        : tsp00_MoveObj;
                    pos            : tsp00_Int4;
                    len            : integer;
                    VAR dest       : tsp00_Buf;
                    dpos           : tsp00_Int4;
                    dlen           : integer;
                    VAR truncated  : boolean);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions: VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              GETSTRING-Conversions : VSP42;
 
        PROCEDURE
              s42gchr (
                    VAR buf  : tsp00_Number;
                    pos      : tsp00_Int4;
                    len      : integer;
                    frac     : integer;
                    origlen  : integer;
                    VAR dest : tsp00_Buf;
                    dpos     : tsp00_Int4;
                    VAR dlen : integer;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              Number-Arithmetic : VSP51;
 
        PROCEDURE
              s51add (VAR left     : tsp00_Number;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_Number;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_MoveObj;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
        PROCEDURE
              s51div (VAR left     : tsp00_MoveObj;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_Number;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_Number;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbegexcl (pid : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vendexcl (pid : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vgetapplpid (pid : tsp00_TaskId;
                    VAR appl_node : tsp00_NodeId;
                    VAR appl_pid  : tsp00_Int4;
                    VAR ok        : boolean);
 
        PROCEDURE
              vtimestamp (VAR t   : tsp00_Timestamp);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (level : tgg00_Debug;
                    VAR buf   : tsp00_MoveObj;
                    pos_start : tsp00_Int4;
                    pos_end   : tsp00_Int4);
 
        PROCEDURE
              t01basis_error (debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj tsp00_C40
 
        PROCEDURE
              s30cmp;
 
              tsp00_MoveObj tsp00_C8
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s30cmp1;
 
              tsp00_MoveObj tsp00_Key
 
        PROCEDURE
              s40gbyte;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s42gchr;
 
              tsp00_MoveObj tsp00_Number
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s51add;
 
              tsp00_MoveObj tsp00_Number
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s51div;
 
              tsp00_MoveObj tsp00_Number
              tsp00_MoveObj tsp00_Number
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : GertG
.sp
.cp 3
Created : 1985-01-22
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-03-28
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 2;.of 14
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_call_from_rsend = true (* a06lsend_mess_buf   *);
      cak545param_info_offset = cgg_rec_key_offset + 20;
 
TYPE
      tak545numeric_columns = (n_rows_read, n_rows_qual,
            n_virtual_reads, n_subrequests, n_runtime,
            n_vwaits, n_vsuspends, n_physical_io,
            n_rows_fetched, n_fetch_calls, n_root1, n_root2, n_root3,
            n_root4, n_root5, n_root6);
      tak545num_col_arr = ARRAY[tak545numeric_columns] OF tsp00_Int4;
 
VAR
      ak545mon_key         : tsp00_C8;
      ak545mon_maxkey      : tsp00_C8;
      ak545mon_tree        : tgg00_FileId;
      ak545mon_data_tree   : tgg00_FileId;
      ak545mon_shinfo_tree : tgg00_FileId;
 
 
(*------------------------------*) 
 
PROCEDURE
      a545_init;
 
BEGIN
ak545mon_data_tree   := b01niltree_id;
ak545mon_shinfo_tree := b01niltree_id;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a545diag_monitor_syntax  (VAR acv : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      _kw_index   : integer;
      _last_n     : tsp00_Int2;
      _res_kw     : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_call_put (acv, a37, cak_x_monitor, put_node);
    a01_next_symbol (acv);
    a01_get_keyword (acv, _kw_index, _res_kw);
    a_return_segm^.sp1r_function_code := csp1_monitor_fc;
    CASE _kw_index OF
        cak_i_call : (* PTS 1113491 *)
            BEGIN
            a_ap_tree^[ put_node ].n_length := _kw_index;
            a01_next_symbol (acv);
            IF  a01mandatory_keyword (acv, cak_i_sequence)
            THEN
                a03_aunsigned_integer (acv,
                      a_ap_tree^[ put_node ].n_sa_level, _last_n)
            (*ENDIF*) 
            END;
        cak_i_off :
            BEGIN
            a_ap_tree^[ put_node ].n_length := _kw_index;
            a01_next_symbol (acv);
            IF  a01_eqkey (a01kw[ cak_i_for], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                a02_aauthid (acv, a_ap_tree^[a_ap_tree^[ put_node ].n_sa_level].n_sa_level, _last_n);
                END;
            (*ENDIF*) 
            END;
        cak_i_parseid :
            BEGIN
            a_ap_tree^[put_node].n_length := _kw_index;
            a01_next_symbol (acv);
            a01_get_keyword (acv, _kw_index, _res_kw);
            CASE _kw_index OF
                cak_i_on, cak_i_off :
                    a_ap_tree^[put_node].n_pos := _kw_index;
                OTHERWISE
                    a07_error (acv, e_wanted_keyword, put_node, put_node);
                END
            (*ENDCASE*) 
            END;
        cak_i_clear, cak_i_data, cak_i_read, cak_i_rowno,
        cak_i_selectivity, cak_i_time :
            BEGIN
            a_ap_tree^[put_node].n_length := _kw_index;
            a01_next_symbol (acv);
            IF  _kw_index = cak_i_data
            THEN
                BEGIN
                a01_get_keyword (acv, _kw_index, _res_kw);
                CASE _kw_index OF
                    cak_i_on, cak_i_off :
                        a_ap_tree^[put_node].n_pos := _kw_index;
                    OTHERWISE
                        a07_error (acv, e_wanted_keyword, put_node, put_node);
                    END
                (*ENDCASE*) 
                END
            ELSE
                IF  _kw_index <> cak_i_clear
                THEN
                    BEGIN
                    IF  a01_eqkey (a01kw[ cak_i_off], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        a01_next_symbol (acv)
                    ELSE
                        a03_aunsigned_integer (acv,
                              a_ap_tree^[ put_node ].n_sa_level, _last_n);
                    (*ENDIF*) 
                    IF  a01_eqkey (a01kw[ cak_i_for], a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        BEGIN
                        a01_next_symbol (acv);
                        a02_aauthid (acv, a_ap_tree^[a_ap_tree^[ put_node ].n_sa_level].n_sa_level, _last_n);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        OTHERWISE
            a07_error (acv, e_wanted_keyword, put_node, _last_n);
        END;
    (*ENDCASE*) 
    a01_next_symbol (acv);
    a01_is_end_symbol (acv)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a545sm_data_tree (VAR acv : tak_all_command_glob;
            VAR mondata_tree : tgg00_FileId);
 
BEGIN
IF  ak545mon_data_tree.fileName_gg00 = cgg_zero_fn
THEN
    ak545mon_data_tree         := mondata_tree;
(*ENDIF*) 
IF  ak545mon_shinfo_tree.fileName_gg00 = cgg_zero_fn
THEN
    BEGIN
    ak545mon_shinfo_tree       := mondata_tree;
    (* we just need a unique fileno stored in a545mon_shinfo_tree, this will be *)
    (* provided by the following b01tcreate_file                                *)
    b01tcreate_file (acv.a_transinf.tri_trans, ak545mon_shinfo_tree);
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        BEGIN
        ak545mon_shinfo_tree := b01niltree_id;
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a545sm_insert (VAR acv : tak_all_command_glob);
 
CONST
      c_inclusive  = true;
 
VAR
      _res           : tsp00_NumError;
      _cmp           : tsp00_LcompResult;
      _ok            : boolean;
      _do_insert     : boolean;
      _b_err         : tgg00_BasisError;
      _ix            : integer;
      _cnt           : integer;
      _param_no      : integer;
      _nix           : tak545numeric_columns;
      _strat_len     : integer;
      _res_len       : integer;
      _rows_qual     : tsp00_Int4;
      _qual_rows     : tsp00_Int4;
      _rows_read     : tsp00_Int4;
      _virtual_reads : tsp00_Int4;
      _values_len    : tsp00_Int4;
      _root_cnt      : tsp00_Int4;
      _mobj_ptr      : tsp00_MoveObjPtr;
      _info          : ^tak_paraminfoarr;
      _root_list_ptr : tgg00_RootListPtr;
      _tcache_ptr    : tgg00_TempDataCachePtr;
      _data_ptr      : tsp00_MoveObjPtr;
      _result_copied : tsp00_C3;
      _name_len      : integer;
      _appl_node     : tsp00_NodeId;
      _appl_pid      : tsp00_Int4;
      _key           : tsp00_C8;
      _parseid       : tsp00_C12;
      _termid        : tsp00_TermId;
      _username      : tsp00_KnlIdentifier;
      _operand1      : tsp00_Number;
      _operand2      : tsp00_Number;
      _lkey          : tgg00_Lkey;
      _strategy      : tsp00_C40;
      _int_arr       : tak545num_col_arr;
      _data          : tgg00_Rec;
      _rec           : tgg00_Rec;
 
BEGIN
IF  a01diag_monitor_on AND NOT acv.a_in_ddl_trigger
THEN
    BEGIN
    _tcache_ptr    := acv.a_transinf.tri_trans.trBdTcachePtr_gg00;
    _rows_read     := cak_is_undefined;
    _virtual_reads := b21m_virt_reads (_tcache_ptr);
&   ifdef trace
    t01int4 (ak_sem, 'virt reads  ', _virtual_reads);
    t01int4 (ak_sem, 'g01sm_reads ', g01sm_reads);
&   endif
    IF  _virtual_reads > g01sm_reads
    THEN
        _do_insert := true
    ELSE
        BEGIN
        _rows_read := b21m_rows_read (_tcache_ptr);
        _rows_qual := b21m_rows_qual (_tcache_ptr);
        IF  _rows_qual = 0
        THEN
            _qual_rows := 1
        ELSE
            _qual_rows := _rows_qual;
        (*ENDIF*) 
&       ifdef trace
        t01int4 (ak_sem, 'rows reads  ', _rows_read);
        t01int4 (ak_sem, 'rows qual   ', _rows_qual);
&       endif
        IF  _rows_read > 0
        THEN
            _do_insert := _qual_rows / _rows_read * 1000 < g01sm_selectivity
        ELSE
            _do_insert := false
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT _do_insert AND (g01sm_milliseconds <> csp_maxint4)
    THEN
        BEGIN
        _do_insert :=
              b21m_sec (_tcache_ptr) > g01sm_milliseconds / 1000;
        IF  NOT _do_insert
        THEN
            BEGIN
            IF  b21m_sec (_tcache_ptr) = g01sm_milliseconds / 1000
            THEN
                _do_insert :=
                      g01sm_milliseconds MOD 1000 <= b21m_microsec (_tcache_ptr) / 1000;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    _do_insert := false;
(*ENDIF*) 
IF  _do_insert
THEN
    BEGIN
    b21m_parseid (_tcache_ptr, _parseid, _parseid);
    IF  _rows_read = cak_is_undefined
    THEN
        BEGIN
        _rows_read := b21m_rows_read (_tcache_ptr);
        _rows_qual := b21m_rows_qual (_tcache_ptr);
        END;
    (*ENDIF*) 
    b21m_strat       (_tcache_ptr, _strategy);
    b21m_copy_result (_tcache_ptr, _result_copied);
    b21m_termid      (_tcache_ptr, _termid);
    b21m_username    (_tcache_ptr, _username);
    WITH acv, _data DO
        BEGIN
        SAPDB_PascalForcedFill (sizeof (_data.recBuf_gg00),
              @_data.recBuf_gg00, 1, sizeof (_data.recBuf_gg00), chr(0));
        recLen_gg00 := cgg_rec_key_offset + 1 + sizeof (_key);
        (*------- LINKAGE --> buf -------*)
        recLen_gg00      := recLen_gg00 + 2;
        recBuf_gg00[recLen_gg00] := chr(1);
        recKeyLen_gg00   := recLen_gg00 - cgg_rec_key_offset;
        (*------- PARSEID --> buf -------*)
        _parseid[11] := chr(0);
        SAPDB_PascalMove ('VAK545',   1,    
              sizeof (_parseid), sizeof (recBuf_gg00),
              @_parseid, 1, @recBuf_gg00, recLen_gg00 + 2, sizeof (_parseid),
              a_returncode);
        recLen_gg00 := recLen_gg00 + sizeof (_parseid) + 1;
        (* ROWS_READ ff. --> buf *)
        _int_arr[n_rows_read    ] := _rows_read;
        _int_arr[n_rows_qual    ] := _rows_qual;
        _int_arr[n_virtual_reads] := _virtual_reads;
        _int_arr[n_subrequests  ] := b21m_kb_calls (_tcache_ptr);
        _int_arr[n_runtime]       := b21m_microsec (_tcache_ptr);
        _int_arr[n_vwaits]        := b21m_waits    (_tcache_ptr);
        _int_arr[n_vsuspends]     := b21m_suspends (_tcache_ptr);
        _int_arr[n_physical_io]   := b21m_phys_ios (_tcache_ptr);
        _int_arr[n_rows_fetched]  :=
              b21m_rows_fetched (_tcache_ptr);
        _int_arr[n_fetch_calls]   :=
              b21m_fetch_calls (_tcache_ptr);
        _nix := pred (n_root1);
        b21m_roots (_tcache_ptr, _root_cnt, _root_list_ptr);
        IF  _root_cnt > MAX_ROOTLIST_GG00
        THEN
            _root_cnt := MAX_ROOTLIST_GG00;
        (*ENDIF*) 
        FOR _ix := 1 TO _root_cnt DO
            BEGIN
            _nix           := succ (_nix);
            _int_arr[_nix] := _root_list_ptr^[_ix]
            END;
        (*ENDFOR*) 
        WHILE _nix < n_root6 DO
            BEGIN
            _nix           := succ (_nix);
            _int_arr[_nix] := -1
            END;
        (*ENDWHILE*) 
        FOR _nix := n_rows_read TO n_fetch_calls DO
            BEGIN
            _data_ptr := @_data;
            IF  _int_arr[_nix] < 0
            THEN
                _data_ptr^[recLen_gg00+1] := csp_undef_byte
            ELSE
                s41plint (_data_ptr^,
                      recLen_gg00 + 2, 20, 0, _int_arr[_nix], _res);
            (*ENDIF*) 
            IF  (_nix = n_runtime) AND (_int_arr[_nix] >= 0)
            THEN
                BEGIN
                (* runtime := b21m_sec+b21m_microsec/1000000 *)
                _mobj_ptr := @_operand1;
                s41plint (_mobj_ptr^,
                      1, csp_fixed, 0, 1000000, _res);
                IF  _res = num_ok
                THEN
                    s51div (_data_ptr^, recLen_gg00 + 2, 20 DIV 2 + 1,
                          _operand1, 1, csp_fixed DIV 2 + 1,
                          _operand2, 1,
                          csp_fixed (* result length in digits *),
                          6, _res_len, _res);
                (*ENDIF*) 
                IF  _res = num_ok
                THEN
                    s41plint (_mobj_ptr^, 1, csp_fixed, 0,
                          b21m_sec (_tcache_ptr), _res);
                (*ENDIF*) 
                IF  _res = num_ok
                THEN
                    s51add (_operand1, 1, csp_fixed DIV 2 + 1,
                          _operand2, 1, csp_fixed DIV 2 + 1,
                          _data_ptr^, recLen_gg00 + 2,
                          20 (* result length in digits *),
                          6, _res_len, _res);
                (*ENDIF*) 
                IF  _res <> num_ok
                THEN
                    recBuf_gg00[recLen_gg00+1] := csp_undef_byte;
                (*ENDIF*) 
                recLen_gg00 := recLen_gg00 + (20 DIV 2) + 2
                END
            ELSE
                recLen_gg00 := recLen_gg00 + (20 DIV 2) + 2
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        FOR _nix := n_root1 TO n_root6 DO
            BEGIN
            _data_ptr := @_data;
            IF  _int_arr[_nix] < 0
            THEN
                _data_ptr^[recLen_gg00+1] := csp_undef_byte
            ELSE
                s41plint (_data_ptr^,
                      recLen_gg00 + 2, 10, 0, _int_arr[_nix], _res);
            (*ENDIF*) 
            recLen_gg00 := recLen_gg00 + (10 DIV 2) + 2
            END;
        (*ENDFOR*) 
        (*------- RESULT_COPIED (YES/NO) --> row *)
        recBuf_gg00[recLen_gg00 + 1] := csp_ascii_blank;
        FOR _ix := 1 TO sizeof (_result_copied) DO
            recBuf_gg00[recLen_gg00 + 1 + _ix] := _result_copied[_ix];
        (*ENDFOR*) 
        recLen_gg00 := recLen_gg00 + 1 + sizeof (_result_copied);
        (*------- DATETIME --> row --------------*)
        IF  a_timestamp = bsp_c20
        THEN
            vtimestamp (a_timestamp);
        (*ENDIF*) 
        recBuf_gg00[recLen_gg00+1] := csp_ascii_blank;
        FOR _ix := 1 TO sizeof (a_timestamp) DO
            recBuf_gg00[recLen_gg00 + 1 + _ix] := a_timestamp[_ix];
        (*ENDFOR*) 
        recLen_gg00 := recLen_gg00 + 1 + sizeof (a_timestamp);
        (*------- TERMID --> row ----------------*)
        recBuf_gg00[recLen_gg00+1] := csp_ascii_blank;
        FOR _ix := 1 TO sizeof (_termid) DO
            recBuf_gg00[recLen_gg00 + 1 + _ix] := _termid[_ix];
        (*ENDFOR*) 
        recLen_gg00 := recLen_gg00 + 1 + sizeof (_termid);
        (*------- Application Pid --> row -------*)
        vgetapplpid (acv.a_transinf.tri_trans.trTaskId_gg00, _appl_node,
              _appl_pid, _ok);
        IF  _ok
        THEN
            s41plint (_data_ptr^,
                  recLen_gg00 + 2, 10, 0, _appl_pid, _res)
        ELSE
            recBuf_gg00[recLen_gg00+1] := csp_undef_byte;
        (*ENDIF*) 
        recLen_gg00 := recLen_gg00 + (10 DIV 2) + 2;
        (*------- finish columns of fixed length *)
        recVarcolOffset_gg00 := recLen_gg00 - cgg_rec_key_offset - recKeyLen_gg00;
        recVarcolCnt_gg00    := 3;
        (*------- STRATEGY --> row --------------*)
        IF  _strategy = bsp_c40
        THEN
            BEGIN
            recLen_gg00      := recLen_gg00 + 1;
            recBuf_gg00[recLen_gg00] := chr(1);
            recLen_gg00      := recLen_gg00 + 1;
            recBuf_gg00[recLen_gg00] := csp_undef_byte
            END
        ELSE
            BEGIN
            recLen_gg00 := recLen_gg00 + 1;
            _strat_len :=
                  s30klen (_strategy, bsp_c1, sizeof (_strategy));
            recBuf_gg00[recLen_gg00] := chr (1 + _strat_len);
            recLen_gg00      := recLen_gg00 + 1;
            recBuf_gg00[recLen_gg00] := csp_ascii_blank;
            SAPDB_PascalMove ('VAK545',   2,    
                  sizeof (_strategy), sizeof (recBuf_gg00),
                  @_strategy, 1, @recBuf_gg00, recLen_gg00 + 1, _strat_len,
                  a_returncode);
            recLen_gg00 := recLen_gg00 + _strat_len;
            END;
        (*ENDIF*) 
        (*------- USERNAME --> row --------------*)
        _name_len := a061identifier_len (_username);
        recBuf_gg00[recLen_gg00+1] := chr(_name_len+1);
        IF  g01unicode
        THEN
            recBuf_gg00[recLen_gg00+2] := csp_unicode_def_byte
        ELSE
            recBuf_gg00[recLen_gg00+2] := csp_ascii_blank;
        (*ENDIF*) 
        FOR _ix := 1 TO _name_len DO
            recBuf_gg00[recLen_gg00 + 2 + _ix] := _username[_ix];
        (*ENDFOR*) 
        recLen_gg00 := recLen_gg00 + 2 + _name_len;
        _name_len := sizeof (_appl_node);
        WHILE _appl_node[_name_len] = bsp_c1 DO
            _name_len := _name_len - 1;
        (*ENDWHILE*) 
        recBuf_gg00[recLen_gg00+1] := chr(_name_len + 1);
        recBuf_gg00[recLen_gg00+2] := csp_ascii_blank;
        FOR _ix := 1 TO _name_len DO
            recBuf_gg00[recLen_gg00 + 2 + _ix] := _appl_node[_ix];
        (*ENDFOR*) 
        recLen_gg00 := recLen_gg00 + 2 + _name_len;
        (* increment key *)
        vbegexcl (a_transinf.tri_trans.trTaskId_gg00, g08monitor);
        IF  ak545mon_key >= ak545mon_maxkey
        THEN
            BEGIN
            FOR _ix := 1 TO sizeof (ak545mon_key) - 1 DO
                ak545mon_key[_ix] := chr(0);
            (*ENDFOR*) 
            ak545mon_key[sizeof (ak545mon_key)] := chr(1)
            END
        ELSE
            BEGIN
            _ix := sizeof (ak545mon_key);
            WHILE (_ix > 0) AND (ak545mon_key[_ix] = chr(255)) DO
                BEGIN
                ak545mon_key[_ix] := chr(0);
                _ix               := _ix - 1
                END;
            (*ENDWHILE*) 
            IF  _ix > 0
            THEN
                ak545mon_key[_ix] := succ (ak545mon_key[_ix]);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        (*------- SYSK --> buf -------*)
        _key := ak545mon_key;
        SAPDB_PascalMove ('VAK545',   3,    
              sizeof (_key), sizeof (recBuf_gg00),
              @_key, 1, @recBuf_gg00, cgg_rec_key_offset + 2, sizeof (_key),
              a_returncode);
        b02add_record (a_transinf.tri_trans, ak545mon_tree, _data);
        _b_err := a_transinf.tri_trans.trError_gg00;
        IF  _b_err = e_duplicate_key
        THEN
            BEGIN
            b02repl_record (a_transinf.tri_trans, ak545mon_tree, _data);
            _b_err := a_transinf.tri_trans.trError_gg00;
            IF  _b_err = e_ok
            THEN
                BEGIN
                (* delete data of the overwritten statement *)
                (* use b02range_delete when implemented     *)
                _lkey.len  := 1 + sizeof (_key);
                _lkey.k[1] := chr(0);
                SAPDB_PascalMove ('VAK545',   4,    
                      sizeof (_key), sizeof (_lkey.k),
                      @_key, 1, @_lkey.k, 2, sizeof (_key),
                      a_returncode);
                REPEAT
                    b02next_record (acv.a_transinf.tri_trans,
                          ak545mon_data_tree, _lkey, NOT c_inclusive, _rec);
                    _b_err := acv.a_transinf.tri_trans.trError_gg00;
                    IF  (_b_err = e_ok) OR (_b_err = e_key_not_found)
                    THEN
                        BEGIN
                        _b_err := e_ok;
                        s30cmp (_key, 1, sizeof (_key), _rec.recBuf_gg00,
                              cgg_rec_key_offset + 2, sizeof (_key), _cmp);
                        IF  _cmp = l_equal
                        THEN
                            BEGIN
                            _lkey.len := _rec.recKeyLen_gg00;
                            SAPDB_PascalMove ('VAK545',   5,    
                                  sizeof (_rec.recBuf_gg00), sizeof (_lkey.k),
                                  @_rec.recBuf_gg00, cgg_rec_key_offset + 1,
                                  @_lkey.k, 1, _rec.recKeyLen_gg00,
                                  a_returncode);
                            b02del_record (acv.a_transinf.tri_trans,
                                  ak545mon_data_tree, _lkey)
                            END
                        ELSE
                            _b_err := e_no_next_record
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                UNTIL
                    (_b_err <> e_ok) OR
                    (a_returncode <> 0);
                (*ENDREPEAT*) 
                IF  _b_err = e_no_next_record
                THEN
                    _b_err := e_ok
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  _b_err = e_ok
    THEN
        b21m_values (_tcache_ptr, _mobj_ptr, _values_len);
    (*ENDIF*) 
    IF  a01sm_collect_data AND (_b_err = e_ok) AND (_values_len > 0)
    THEN
        BEGIN (* store data in table sysmondata *)
&       ifdef trace
        t01moveobj (ak_sem, _mobj_ptr^, 1, _values_len);
&       endif
        IF  acv.a_variable_input
        THEN
            IF  NOT a509build_map_from_databuffer (_mobj_ptr,
                acv.a_input_data_map, _values_len)
            THEN
                a07ak_system_error (acv, 545, 2);
            (*ENDIF*) 
        (*ENDIF*) 
        _lkey.len := sizeof (_parseid);
        SAPDB_PascalMove ('VAK545',   6,    
              sizeof (_parseid), sizeof (_lkey.k),
              @_parseid, 1, @_lkey.k, 1, _lkey.len,
              acv.a_returncode);
        _param_no := 0;
        REPEAT
            (* read short field infos *)
            b02next_record (acv.a_transinf.tri_trans,
                  ak545mon_shinfo_tree, _lkey, NOT c_inclusive, _rec);
            _b_err := acv.a_transinf.tri_trans.trError_gg00;
            IF  (_b_err = e_ok) OR (_b_err = e_key_not_found)
            THEN
                BEGIN
                s30cmp1 (_lkey.keyVal_gg00, 1, sizeof (_parseid),
                      _rec.recKey_gg00.keyVal_gg00, 1, sizeof (_parseid), _cmp);
                IF  _cmp = l_equal
                THEN
                    BEGIN
                    _lkey.len := _rec.recKeyLen_gg00;
                    SAPDB_PascalMove ('VAK545',   7,    
                          sizeof (_rec.recBuf_gg00), sizeof (_lkey.k),
                          @_rec.recBuf_gg00, cgg_rec_key_offset + 1, @_lkey.k, 1,
                          _lkey.len, acv.a_returncode);
                    _b_err := e_ok;
                    _info  := @_rec.recBuf_gg00[cak545param_info_offset+1];
                    _cnt   := (_rec.recLen_gg00 - cak545param_info_offset) DIV
                          sizeof (_info^[1]);
                    _ix    := 1;
                    WHILE (_ix <= _cnt) AND (_b_err = e_ok) DO
                        BEGIN
                        IF  (_info^[_ix].sp1i_io_type in [sp1io_input, sp1io_inout])
                            AND
                            NOT (_info^[_ix].sp1i_data_type in [dstra, dstrb,
                            dstruni, dlonga, dlongb, dlonguni])
                        THEN
                            BEGIN
                            ak545build_sysmondata_rec (acv,
                                  _data, _key, _info^[_ix],
                                  _param_no + _ix, _mobj_ptr^, _values_len);
                            b02add_record (acv.a_transinf.tri_trans,
                                  ak545mon_data_tree, _data);
                            _b_err := acv.a_transinf.tri_trans.trError_gg00;
                            END;
                        (*ENDIF*) 
                        _ix := _ix + 1
                        END;
                    (*ENDWHILE*) 
                    IF  _rec.info[_rec.recKeyLen_gg00] = chr(255)
                    THEN
                        _b_err := e_no_next_record
                    ELSE
                        _param_no := _param_no + _cnt;
                    (*ENDIF*) 
                    END
                ELSE
                    _b_err := e_no_next_record;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        UNTIL
            _b_err <> e_ok;
        (*ENDREPEAT*) 
        END;
    (*ENDIF*) 
    vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08monitor);
    END;
(*ENDIF*) 
IF  a01diag_analyze_on AND NOT acv.a_in_ddl_trigger
THEN
    a544put_sysdata_analyze( acv );
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a545sm_param_info (VAR acv : tak_all_command_glob;
            VAR parsid : tak_parsid);
 
VAR
      _rest       : integer;
      _cnt        : integer;
      _rec_cnt    : integer;
      _si_index   : integer;
      _move_len   : integer;
      _infopart   : tsp1_part_ptr;
      _info       : ^tak_paraminfoarr;
      _aux_parsid : tak_parsid;
      _rec        : tgg00_Rec;
 
BEGIN
(* PTS 1001121 E.Z. *)
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  acv.a_variable_input
    THEN
        a92find_return_part (acv, sp1pk_vardata_shortinfo, _infopart)
    ELSE
        a92find_return_part (acv, sp1pk_shortinfo, _infopart);
    (*ENDIF*) 
    IF  _infopart <> NIL
    THEN
        BEGIN
        _aux_parsid                  := parsid;
        _aux_parsid.pid_appl_info[1] := chr(0);
        SAPDB_PascalForcedMove (sizeof (_aux_parsid), sizeof (_rec.buf), @_aux_parsid, 1,
              @_rec.buf, cgg_rec_key_offset + 1, sizeof (_aux_parsid));
        _rec.keylen := sizeof (_aux_parsid) + 1;
        _rest       := _infopart^.sp1p_arg_count;
        _info       := @_infopart^.sp1p_buf;
        _si_index   := 0;
        _rec_cnt    := 0;
        REPEAT
            _rec_cnt := _rec_cnt + 1;
            _rec.len := cak545param_info_offset;
            _cnt     := (MAX_RECLEN_GG00 - _rec.len) DIV sizeof (_info^[1]);
            IF  _rest <= _cnt
            THEN
                BEGIN
                _cnt     := _rest;
                _rec_cnt := 255
                END;
            (*ENDIF*) 
            _move_len := _cnt * sizeof (_info^[1]);
            SAPDB_PascalMove ('VAK545',   8,    
                  _infopart^.sp1p_buf_size, sizeof (_rec.buf),
                  @_info^, _si_index * sizeof (_info^[1]) + 1,
                  @_rec.buf, _rec.len + 1, _move_len,
                  acv.a_returncode);
            _rec.info[_rec.recKeyLen_gg00] := chr(_rec_cnt);
            _rec.recLen_gg00              := _rec.recLen_gg00 + _move_len;
            _rec.recVarcolOffset_gg00     := _rec.recLen_gg00 - cgg_rec_key_offset - _rec.recKeyLen_gg00;
            _rec.recVarcolCnt_gg00        := 0;
            b02add_record (acv.a_transinf.tri_trans, ak545mon_shinfo_tree, _rec);
            _si_index := _si_index + _cnt;
            _rest     := _rest - _cnt;
        UNTIL
            (_rest <= 0) OR (acv.a_transinf.tri_trans.trError_gg00 <> e_ok);
        (*ENDREPEAT*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a545sm_reset (VAR monitor_tree : tgg00_FileId);
 
BEGIN
ak545mon_key                              := cgg_zero_id;
ak545mon_maxkey                           := cgg_zero_id;
ak545mon_maxkey [sizeof(ak545mon_maxkey)] := chr(255);
ak545mon_tree                             := monitor_tree;
ak545mon_data_tree.fileRoot_gg00          := NIL_PAGE_NO_GG00;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a545sm_set_rowno (maxrowno : tsp00_Int4);
 
VAR
      _ix : integer;
 
BEGIN
ak545mon_maxkey := cgg_zero_id;
_ix             := sizeof (ak545mon_maxkey);
WHILE maxrowno > 0 DO
    BEGIN
    ak545mon_maxkey[_ix] := chr (maxrowno MOD 256);
    maxrowno := maxrowno DIV 256;
    _ix      := _ix - 1
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a545sm_get_rowno : tsp00_Int4;
 
VAR
      _ix       : integer;
      _power    : integer;
      _maxrowno : integer;
 
BEGIN
_maxrowno := 0;
_power    := 1;
(* h.b. PTS 1104671 *)
_ix       := sizeof (ak545mon_maxkey);
WHILE _ix  >= 1 DO
    BEGIN
    _maxrowno := _maxrowno + ord (ak545mon_maxkey[_ix]) * _power;
    _power    := _power * 256;
    _ix       := pred(_ix);
    END;
(*ENDWHILE*) 
a545sm_get_rowno := _maxrowno;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a545diag_parse_info (VAR acv : tak_all_command_glob;
            VAR parsid     : tak_parsid;
            VAR sel_parsid : tak_parsid);
 
CONST
      sql_stmt_datalen = 7800;
 
VAR
      _num_err      : tsp00_NumError;
      _b_err        : tgg00_BasisError;
      _job_len      : integer;
      _p1_pos       : integer;
      _move_len     : integer;
      _pos          : integer;
      _len          : integer;
      _cnt          : integer;
      _aux_parsid   : tak_parsid;
      _i_sel_parsid : tak_parsid;
      _i2           : tsp_int_map_c2;
      _job          : tsp00_C40;
      _linenr       : tsp00_Number;
 
BEGIN
IF  NOT acv.a_in_ddl_trigger
THEN
    BEGIN
    (* insert into SYSPARSEID *)
    _p1_pos := 1;
    _cnt    := 0;
    _aux_parsid                  := parsid;
    _aux_parsid.pid_appl_info[1] := chr(0);
    _i_sel_parsid                := sel_parsid;
    _i_sel_parsid.pid_appl_info[1] := chr(0);
    a542get_abapinfo (acv, _job, _job_len, _linenr);
    _b_err := e_ok;
    REPEAT
        _cnt := _cnt + 1;
        a06a_mblock_init (acv, m_insert, mm_nil, g01tabid.sys_diag_parse);
        WITH acv.a_mblock, mb_data^ DO
            BEGIN
            (* mxak_parsid + defined_byte + len(fixed(1)) + defined_byte *)
            mbp_keylen := mxak_parsid + 1 + (((1 + 1) DIV 2) + 1) + 1 ;
            _pos        := cgg_rec_key_offset + 1;
            (* write PARSEID CHAR(12) *)
            mbp_buf[_pos] := csp_defined_byte;
            SAPDB_PascalMove ('VAK545',   9,    
                  sizeof (_aux_parsid), mb_data_size,
                  @_aux_parsid, 1, @mbp_buf, _pos + 1, sizeof (_aux_parsid), _b_err);
            _pos := _pos + 1 + sizeof (_aux_parsid);
            (* write LINKAGE FIXED(1)*)
            mbp_buf[_pos] := csp_defined_byte;
            s41plint (mbp_buf, _pos + 1, 1, 0, _cnt, _num_err);
            _pos := _pos + 1 + (((1 + 1) DIV 2) + 1);
            (* write SELECT_PARSEID CHAR(12) *)
            IF  _i_sel_parsid.pid_session.ci4_gg00 <> cgg_nil_session
            THEN
                BEGIN
                mbp_buf[_pos] := csp_defined_byte;
                SAPDB_PascalMove ('VAK545',  10,    
                      sizeof (_i_sel_parsid), mb_data_size, @_i_sel_parsid, 1,
                      @mbp_buf, _pos + 1, sizeof (_i_sel_parsid), _b_err);
                END
            ELSE
                BEGIN
                mbp_buf[_pos] := csp_undef_byte;
                SAPDB_PascalFill ('VAK545',  11,    
                      mb_data_size, @mbp_buf, _pos + 1,
                      sizeof (_i_sel_parsid), csp_defined_byte, _b_err)
                END;
            (*ENDIF*) 
            _pos := _pos + 1 + sizeof (_i_sel_parsid);
            (* write LINE FIXED(10)*)
            mbp_buf[_pos] := csp_defined_byte;
            SAPDB_PascalMove ('VAK545',  12,    
                  sizeof (_linenr), mb_data_size,
                  @_linenr, 1, @mbp_buf, _pos + 1, ((10 + 1) DIV 2) + 1, _b_err);
            _pos := _pos + 1 + (((10 + 1) DIV 2) + 1);
            (* two columns of variable length *)
            mbp_varcol_offset := _pos - 1 - cgg_rec_key_offset - mbp_keylen;
            mbp_varcol_cnt    := 2;
            (* write OWNER CHAR(64) *)
            _len := a061identifier_len (acv.a_curr_user_name);
            mbp_buf[_pos] := chr(_len+1);
            _pos          := _pos + 1;
            IF  g01unicode
            THEN
                mbp_buf[_pos] := csp_unicode_def_byte
            ELSE
                mbp_buf[_pos] := bsp_c1;
            (*ENDIF*) 
            SAPDB_PascalMove ('VAK545',  13,    
                  sizeof (acv.a_curr_user_name), mb_data_size,
                  @acv.a_curr_user_name, 1, @mbp_buf, _pos + 1, _len, _b_err);
            _pos := _pos + _len + 1;
            (* write JOB CHAR(40) *)
            IF  g01unicode
            THEN
                BEGIN
                mbp_buf[_pos] := chr(_job_len+1);
                mbp_buf[_pos + 1] := csp_unicode_def_byte;
                END
            ELSE
                BEGIN
                mbp_buf[_pos] := chr(_job_len+1);
                mbp_buf[_pos + 1 ] := bsp_c1;
                END;
            (*ENDIF*) 
            _pos := _pos + 2;
            SAPDB_PascalMove ('VAK545',  14,    
                  sizeof (_job), mb_data_size,
                  @_job, 1, @mbp_buf, _pos, _job_len, _b_err);
            _pos := _pos + _job_len;
            (* write SQL_STATEMENT CHAR(7800) *)
            IF  acv.a_original_stmt_lenght - _p1_pos + 1 > sql_stmt_datalen
            THEN
                _move_len := sql_stmt_datalen
            ELSE
                _move_len := acv.a_original_stmt_lenght - _p1_pos + 1;
            (*ENDIF*) 
            _i2.map_int     := _move_len + 1;
            mbp_buf[_pos]   := _i2.map_c2[1];
            mbp_buf[_pos+1] := _i2.map_c2[2];
            IF  g01unicode
            THEN
                mbp_buf[_pos+2] := csp_unicode_def_byte
            ELSE
                mbp_buf[_pos+2] := bsp_c1;
            (*ENDIF*) 
            _pos := _pos + 3;
            SAPDB_PascalMove ('VAK545',  15,    
                  acv.a_cmd_part^.sp1p_buf_size, mb_data_size,
                  @acv.a_cmd_part^.sp1p_buf, _p1_pos, @mbp_buf, _pos,
                  _move_len, _b_err);
            mbp_reclen   := _pos + _move_len - 1;
            mb_data_len  := mbp_reclen;
            IF  _b_err = e_ok
            THEN
                a06lsend_mess_buf (acv, acv.a_mblock,
                      NOT c_call_from_rsend, _b_err);
            (*ENDIF*) 
            _p1_pos := _p1_pos + _move_len;
            END;
        (*ENDWITH*) 
    UNTIL
        (_p1_pos > acv.a_original_stmt_lenght) OR (_b_err <> e_ok);
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a545clear_monitor (VAR acv : tak_all_command_glob);
 
VAR
      p_arr          : tak_syspointerarr;
      tablename      : tsp00_KnlIdentifier;
      authid         : tsp00_KnlIdentifier;
 
BEGIN (* h.b. PTS 1104444 *)
authid    := g01glob.sysuser_name;
tablename := a01_i_sysmonitor;
IF  a06_table_exist (acv, d_release, authid, tablename, p_arr, false)
THEN
    BEGIN
    ak545mon_tree := p_arr.pbasep^.sbase.btreeid;
    b01empty_file (acv.a_transinf.tri_trans, ak545mon_tree);
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (acv.a_returncode = 0)
THEN
    BEGIN
    tablename := a01_i_sysmondata;
    IF  a06_table_exist (acv, d_release, authid, tablename, p_arr, false)
    THEN
        BEGIN
        ak545mon_data_tree := p_arr.pbasep^.sbase.btreeid;
        b01empty_file (acv.a_transinf.tri_trans, ak545mon_data_tree);
        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak545build_sysmondata_rec (VAR acv : tak_all_command_glob;
            VAR data       : tgg00_Rec;
            VAR key        : tsp00_C8;
            VAR param_info : tsp1_param_info;
            param_no       : integer;
            VAR valuebuf   : tsp00_MoveObj;
            valuebuf_len   : tsp00_Int4);
 
VAR
      _to_unicode : boolean;
      _overflw    : boolean;
      _dummy      : boolean;
      _undef      : boolean;
      _err_char_no: tsp00_Int4;
      _uni_err    : tsp8_uni_error;
      _val_len    : tsp00_Int4;
      _ix         : integer;
      _jx         : integer;
      _mobj_ptr   : tsp00_MoveObjPtr;
      _pos        : integer;
      _data_len   : tsp_int_map_c2;
      _res        : tsp00_NumError;
      _b_err      : tgg00_BasisError;
      _value_ptr  : tsp00_MoveObjPtr;
      _is_default : boolean;
      _num        : tsp00_Number;
 
BEGIN
WITH data DO
    BEGIN
&   ifdef trace
    IF  NOT acv.a_variable_input
    THEN
        t01int4 (ak_sem, 'buf_pos     ', param_info.sp1i_bufpos)
    ELSE
        t01int4 (ak_sem, 'param_no    ', param_info.sp1i_param_no);
    (*ENDIF*) 
    t01int4 (ak_sem, 'inoutlen    ', param_info.sp1i_in_out_len);
&   endif
    (* KEY = SYSK CHAR(8) BYTE + PARAMNO FIXED(5) *)
    _pos := cgg_rec_key_offset + 1;
    (* write SYSK CHAR(8) BYTE KEY *)
    recBuf_gg00[_pos] := csp_defined_byte;
    _pos := _pos + 1;
    SAPDB_PascalMove ('VAK545',  16,    
          sizeof (key), sizeof (recBuf_gg00),
          @key, 1, @recBuf_gg00, _pos, sizeof (key),
          acv.a_returncode);
    _pos := _pos + sizeof(key);
    (* write PARAMNO FIXED(5) KEY *)
    recBuf_gg00[_pos] := csp_defined_byte;
    _pos := _pos + 1;
    _mobj_ptr  := @data;
    s41plint (_mobj_ptr^, _pos, 5, 0, param_no, _res);
    recKeyLen_gg00 := _pos + (((5 + 1) DIV 2) + 1) - 1;
    (* produce variable long key *)
    WHILE recBuf_gg00[recKeyLen_gg00] = chr(0) DO
        recKeyLen_gg00 := recKeyLen_gg00 - 1;
    (*ENDWHILE*) 
    recKeyLen_gg00 := recKeyLen_gg00 - cgg_rec_key_offset;
    _undef := false;
    _pos   := recKeyLen_gg00 + cgg_rec_key_offset + 1;
    (* write DATA_TYPE CHAR(12) ASCII / CHAR(6) UNICODE *)
    IF  g01unicode
    THEN
        recBuf_gg00[_pos] := csp_unicode_def_byte
    ELSE
        recBuf_gg00[_pos] := csp_ascii_blank;
    (*ENDIF*) 
    _b_err := e_ok;
    _pos   := _pos + 1;
    IF  g01unicode
    THEN
        BEGIN
        SAPDB_PascalUnicodeFill ('VAK545',  17,    
              sizeof(recBuf_gg00), _mobj_ptr, _pos, 12,
              csp_unicode_blank, _b_err)
        END
    ELSE
        BEGIN
        SAPDB_PascalFill ('VAK545',  18,    
              sizeof(recBuf_gg00), _mobj_ptr, _pos, 12,
              csp_ascii_blank, _b_err);
        END;
    (*ENDIF*) 
    IF  _b_err = e_ok
    THEN
        CASE param_info.sp1i_data_type OF
            dboolean, dunicode, dvarcharuni, dcha, ddate, dtime, dtimestamp, dvarchara :
                IF  g01unicode
                THEN
                    BEGIN
                    recBuf_gg00[_pos+1] := 'C';
                    recBuf_gg00[_pos+3] := 'H';
                    recBuf_gg00[_pos+5] := 'A';
                    recBuf_gg00[_pos+7] := 'R';
                    END
                ELSE
                    BEGIN
                    recBuf_gg00[_pos  ] := 'C';
                    recBuf_gg00[_pos+1] := 'H';
                    recBuf_gg00[_pos+2] := 'A';
                    recBuf_gg00[_pos+3] := 'R';
                    END;
                (*ENDIF*) 
            dfixed, dinteger, dsmallint :
                IF  g01unicode
                THEN
                    BEGIN
                    recBuf_gg00[_pos+1] := 'N';
                    recBuf_gg00[_pos+3] := 'U';
                    recBuf_gg00[_pos+5] := 'M';
                    recBuf_gg00[_pos+7] := 'B';
                    recBuf_gg00[_pos+9] := 'E';
                    recBuf_gg00[_pos+11]:= 'R';
                    END
                ELSE
                    BEGIN
                    recBuf_gg00[_pos  ] := 'N';
                    recBuf_gg00[_pos+1] := 'U';
                    recBuf_gg00[_pos+2] := 'M';
                    recBuf_gg00[_pos+3] := 'B';
                    recBuf_gg00[_pos+4] := 'E';
                    recBuf_gg00[_pos+5] := 'R';
                    END;
                (*ENDIF*) 
            dfloat, dvfloat : (* h.b. PTS 1104239 *)
                IF  g01unicode
                THEN
                    BEGIN
                    recBuf_gg00[_pos+1] := 'F';
                    recBuf_gg00[_pos+3] := 'L';
                    recBuf_gg00[_pos+5] := 'O';
                    recBuf_gg00[_pos+7] := 'A';
                    recBuf_gg00[_pos+9] := 'T';
                    END
                ELSE
                    BEGIN
                    recBuf_gg00[_pos  ] := 'F';
                    recBuf_gg00[_pos+1] := 'L';
                    recBuf_gg00[_pos+2] := 'O';
                    recBuf_gg00[_pos+3] := 'A';
                    recBuf_gg00[_pos+4] := 'T';
                    END;
                (*ENDIF*) 
            OTHERWISE
                IF  g01unicode
                THEN
                    BEGIN
                    recBuf_gg00[_pos+1] := 'B';
                    recBuf_gg00[_pos+3] := 'Y';
                    recBuf_gg00[_pos+5] := 'T';
                    recBuf_gg00[_pos+7] := 'E';
                    END
                ELSE
                    BEGIN
                    recBuf_gg00[_pos  ] := 'B';
                    recBuf_gg00[_pos+1] := 'Y';
                    recBuf_gg00[_pos+2] := 'T';
                    recBuf_gg00[_pos+3] := 'E';
                    END;
                (*ENDIF*) 
            END
        (*ENDCASE*) 
    ELSE
        BEGIN
&       ifdef TRACE
        t01basis_error(ak_sem, 'fill DATA_TY', _b_err );
&       endif
        recBuf_gg00[_pos - 1] := csp_undef_byte;
        END;
    (*ENDIF*) 
    _pos := _pos + 12 (* CHAR(12) ASCII / CHAR(6) UNICODE *);
    recVarcolOffset_gg00 := _pos - 1 - cgg_rec_key_offset - recKeyLen_gg00;
    recVarcolCnt_gg00    := 0;
    IF  NOT acv.a_variable_input
    THEN
        BEGIN
        IF  param_info.sp1i_bufpos + param_info.sp1i_in_out_len - 1 >
            valuebuf_len
        THEN
            _val_len := valuebuf_len - param_info.sp1i_bufpos + 1
        ELSE
            _val_len := param_info.sp1i_in_out_len;
        (*ENDIF*) 
        IF  _val_len > 0
        THEN
            BEGIN
            _overflw := false;
            _undef   := valuebuf[param_info.sp1i_bufpos] = csp_undef_byte
            END
        ELSE
            _overflw := true;
        (*ENDIF*) 
        IF  _undef OR _overflw
        THEN
            BEGIN
            _val_len     := 1;
            recBuf_gg00[_pos + 2] := csp_undef_byte;
            _to_unicode  := false
            END
        ELSE
            BEGIN
            _to_unicode := g01unicode;
            recBuf_gg00[_pos + 2]  := csp_ascii_blank;
            CASE param_info.sp1i_data_type OF
                dboolean :
                    BEGIN
                    IF  valuebuf[param_info.sp1i_bufpos + 1] = chr(0)
                    THEN
                        BEGIN
                        recBuf_gg00[_pos + 3] := 'F';
                        recBuf_gg00[_pos + 4] := 'A';
                        recBuf_gg00[_pos + 5] := 'L';
                        recBuf_gg00[_pos + 6] := 'S';
                        recBuf_gg00[_pos + 7] := 'E';
                        _val_len    := 6
                        END
                    ELSE
                        BEGIN
                        recBuf_gg00[_pos + 3] := 'T';
                        recBuf_gg00[_pos + 4] := 'R';
                        recBuf_gg00[_pos + 5] := 'U';
                        recBuf_gg00[_pos + 6] := 'E';
                        _val_len    := 5
                        END;
                    (*ENDIF*) 
                    END;
                dcha, ddate, dtime, dtimestamp, dvarchara :
                    BEGIN
                    SAPDB_PascalMove ('VAK545',  19,    
                          valuebuf_len, sizeof (recBuf_gg00),
                          @valuebuf, param_info.sp1i_bufpos, @recBuf_gg00,
                          _pos + 2,
                          _val_len, acv.a_returncode);
                    END;
                dfixed, dinteger, dsmallint :
                    BEGIN
                    _num := csp_null_number;
                    _val_len := pred(_val_len);
                    SAPDB_PascalMove ('VAK545',  20,    
                          valuebuf_len, sizeof(_num),
                          @valuebuf, param_info.sp1i_bufpos + 1,
                          @_num, 1, _val_len, acv.a_returncode);
                    s42gchr (_num, 1,
                          param_info.sp1i_length, param_info.sp1i_frac,
                          param_info.sp1i_length, recBuf_gg00, _pos + 3,
                          _val_len, _res);
                    IF  _res <> num_ok
                    THEN
                        _overflw := true
                    ELSE
                        _val_len := succ(_val_len)
                    (*ENDIF*) 
                    END;
                dfloat, dvfloat :
                    BEGIN
                    recBuf_gg00[_pos + 2] := csp_defined_byte;
                    _num := csp_null_number;
                    _val_len := pred(_val_len);
                    SAPDB_PascalMove ('VAK545',  21,    
                          valuebuf_len, sizeof(_num),
                          @valuebuf, param_info.sp1i_bufpos + 1,
                          @_num, 1, _val_len, acv.a_returncode);
                    s42gchr (_num, 1,
                          param_info.sp1i_length, csp_float_frac,
                          param_info.sp1i_length, recBuf_gg00, _pos + 3,
                          _val_len, _res);
                    IF  _res <> num_ok
                    THEN
                        _overflw := true
                    ELSE
                        _val_len := succ(_val_len)
                    (*ENDIF*) 
                    END;
                dunicode,  dvarcharuni:
                    BEGIN
                    _to_unicode := false;
                    IF  (acv.a_cmd_packet_header.sp1h_mess_swap <> sw_normal)
                        AND
                        (acv.a_cmd_packet_header.sp1h_mess_code <> csp_unicode)
                    THEN
                        BEGIN
                        recBuf_gg00[_pos + 2] := csp_unicode_def_byte;
                        _val_len := pred(_val_len);
                        s80uni_trans (@valuebuf[param_info.sp1i_bufpos + 1],
                              _val_len, csp_unicode_swap,
                              @recBuf_gg00[_pos + 3], _val_len, csp_unicode,
                              [ ], _uni_err, _err_char_no);
                        IF  _uni_err <> uni_ok
                        THEN
                            _overflw := true
                        ELSE
                            _val_len := succ(_val_len)
                        (*ENDIF*) 
                        END
                    ELSE
                        SAPDB_PascalMove ('VAK545',  22,    
                              valuebuf_len, sizeof (recBuf_gg00),
                              @valuebuf, param_info.sp1i_bufpos, @recBuf_gg00,
                              _pos + 2,
                              _val_len, acv.a_returncode);
                    (*ENDIF*) 
                    END;
                OTHERWISE
                    BEGIN
                    _val_len := pred(_val_len);
                    IF  _val_len > 4000
                    THEN
                        _val_len := 2000;
                    (*ENDIF*) 
                    s40gbyte (valuebuf, param_info.sp1i_bufpos + 1, _val_len,
                          recBuf_gg00, _pos + 3, 2 * _val_len, _dummy);
                    _val_len := succ(_val_len * 2)
                    END;
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        IF  NOT a509get_one_value (acv.a_input_data_map, param_info.sp1i_param_no,
            _value_ptr, _val_len, _undef, _is_default)
        THEN
            a07ak_system_error (acv, 545, 1)
        ELSE
            BEGIN
            _overflw := false;
            IF  _val_len <= 0
            THEN
                _overflw := true;
            (*ENDIF*) 
            IF  _undef OR _overflw
            THEN
                BEGIN
                _val_len     := 1;
                recBuf_gg00[_pos + 2] := csp_undef_byte;
                _to_unicode  := false
                END
            ELSE
                BEGIN
                _to_unicode := g01unicode;
                recBuf_gg00[_pos + 2]  := csp_ascii_blank;
                CASE param_info.sp1i_data_type OF
                    dboolean :
                        BEGIN
                        IF  _value_ptr^[1] = chr(0)
                        THEN
                            BEGIN
                            recBuf_gg00[_pos + 3] := 'F';
                            recBuf_gg00[_pos + 4] := 'A';
                            recBuf_gg00[_pos + 5] := 'L';
                            recBuf_gg00[_pos + 6] := 'S';
                            recBuf_gg00[_pos + 7] := 'E';
                            _val_len    := 6
                            END
                        ELSE
                            BEGIN
                            recBuf_gg00[_pos + 3] := 'T';
                            recBuf_gg00[_pos + 4] := 'R';
                            recBuf_gg00[_pos + 5] := 'U';
                            recBuf_gg00[_pos + 6] := 'E';
                            _val_len    := 5
                            END;
                        (*ENDIF*) 
                        END;
                    dcha, ddate, dtime, dtimestamp, dvarchara :
                        BEGIN
                        SAPDB_PascalMove ('VAK545',  23,    
                              _val_len, sizeof (recBuf_gg00),
                              @_value_ptr^, 1, @recBuf_gg00, _pos + 3,
                              _val_len, acv.a_returncode);
                        _val_len := succ(_val_len);
                        END;
                    dfixed, dinteger, dsmallint :
                        BEGIN
                        _num := csp_null_number;
                        SAPDB_PascalMove ('VAK545',  24,    
                              _val_len, sizeof(_num),
                              @_value_ptr^, 1, @_num, 1, _val_len, acv.a_returncode);
                        s42gchr (_num, 1,
                              param_info.sp1i_length, param_info.sp1i_frac,
                              param_info.sp1i_length, recBuf_gg00, _pos + 3,
                              _val_len, _res);
                        IF  _res <> num_ok
                        THEN
                            _overflw := true
                        ELSE
                            _val_len := succ(_val_len);
                        (*ENDIF*) 
                        END;
                    dfloat, dvfloat :
                        BEGIN
                        _num := csp_null_number;
                        SAPDB_PascalMove ('VAK545',  25,    
                              _val_len, sizeof(_num),
                              @_value_ptr^, 1, @_num, 1, _val_len, acv.a_returncode);
                        s42gchr (_num, 1,
                              param_info.sp1i_length, csp_float_frac,
                              param_info.sp1i_length, recBuf_gg00, _pos + 3,
                              _val_len, _res);
                        IF  _res <> num_ok
                        THEN
                            _overflw := true
                        ELSE
                            _val_len := succ(_val_len);
                        (*ENDIF*) 
                        END;
                    dunicode, dvarcharuni :
                        BEGIN
                        _to_unicode := false;
                        recBuf_gg00[_pos + 2] := csp_unicode_def_byte;
                        IF  (acv.a_cmd_packet_header.sp1h_mess_swap <> sw_normal)
                            AND
                            (acv.a_cmd_packet_header.sp1h_mess_code <> csp_unicode)
                        THEN
                            BEGIN
                            s80uni_trans (_value_ptr, _val_len, csp_unicode_swap,
                                  @recBuf_gg00[_pos + 3], _val_len, csp_unicode,
                                  [ ], _uni_err, _err_char_no);
                            IF  _uni_err <> uni_ok
                            THEN
                                _overflw := true
                            (*ENDIF*) 
                            END
                        ELSE
                            SAPDB_PascalMove ('VAK545',  26,    
                                  _val_len, sizeof (recBuf_gg00),
                                  @_value_ptr^, 1, @recBuf_gg00, _pos + 3,
                                  _val_len, acv.a_returncode);
                        (*ENDIF*) 
                        _val_len := succ(_val_len);
                        END;
                    OTHERWISE
                        BEGIN
                        IF  (_val_len > 4000) OR
                            (_to_unicode AND (_val_len > 2000))
                        THEN
                            _val_len := 2000;
                        (*ENDIF*) 
                        s40gbyte (_value_ptr^, 1, _val_len,
                              recBuf_gg00, _pos + 3, 2 * _val_len, _dummy);
                        _val_len := succ(_val_len * 2)
                        END;
                    END;
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  _to_unicode
    THEN
        BEGIN
        recBuf_gg00[_pos + 2] := csp_unicode_def_byte;
        _jx := _pos + 2 + (_val_len - 1) * 2;
        FOR _ix := _pos + 2 + _val_len - 1 DOWNTO _pos + 3 DO
            BEGIN
            recBuf_gg00[_jx  ] := recBuf_gg00[_ix];
            recBuf_gg00[_jx-1] := csp_unicode_mark;
            _jx := _jx - 2
            END;
        (*ENDFOR*) 
        _val_len := succ(pred(_val_len) * 2)
        END;
    (*ENDIF*) 
    IF  _overflw
    THEN
        BEGIN
        _val_len := 1;
        recBuf_gg00[_pos + 2] := csp_oflw_byte
        END;
    (*ENDIF*) 
    IF  acv.a_variable_input
    THEN
        _data_len.map_int := _val_len
    ELSE
        _data_len.map_int :=
              1 + s30lnr_defbyte (@recBuf_gg00, recBuf_gg00[_pos+2],
              _pos + 3, _val_len - 1);
    (*ENDIF*) 
&   ifdef TRACE
    t01int4(ak_sem, '_val_len    ', _val_len);
    t01int4(ak_sem, '_data_len   ', _data_len.map_int);
&   endif
    recBuf_gg00[_pos]   := _data_len.map_c2[1];
    recBuf_gg00[_pos+1] := _data_len.map_c2[2];
    recLen_gg00 := _pos + 2 (* col len *) + _data_len.map_int - 1;
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
