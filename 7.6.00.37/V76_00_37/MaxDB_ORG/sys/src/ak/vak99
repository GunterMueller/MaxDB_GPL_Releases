.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-09-20
*****************************************************
modname : VAK99
changed : 2000-09-20
module  : Syntax-Tree-Printer
 
Author  :
Created : 1985-10-16
*****************************************************
 
Purpose : Syntax Tree Printer
 
Define  :
 
        VAR
              a99blankline : tsp00_Line;
 
        PROCEDURE
              a99init;
 
        PROCEDURE
              a99priv (
                    layer    : tgg00_Debug;
                    p        : tak_privilege;
                    id       : tsp00_C18;
                    unpacked : boolean);
 
        PROCEDURE
              a99_priv_all_set (
                    layer              : tgg00_Debug;
                    priv_all_set       : tak00_PrivilegeSet;
                    priv_all_grant_set : tak00_PrivilegeSet);
 
        PROCEDURE
              a99putint  (
                    VAR lineinfo : tsp00_DataLine;
                    integervalue : integer;
                    fieldlength  : tsp00_FieldRange);
 
        PROCEDURE
              a99put4int  (
                    VAR data : tsp00_DataLine;
                    i      : tsp00_Int4;
                    fl     : tsp00_FieldRange);
 
        PROCEDURE
              a99print_nodes (
                    VAR ap_tree : tak_ap_max_tree;
                    cntnodes : integer;
                    hint_node: tsp00_Int2
                    );
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (
                    int       : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size     : tsp00_Int4;
                    m        : tsp00_MoveObjPtr;
                    pos      : tsp00_Int4;
                    len      : tsp00_Int4;
                    fillchar : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove  (
                    size1    : tsp00_Int4;
                    size2    : tsp00_Int4;
                    val1     : tsp00_MoveObjPtr;
                    p1       : tsp00_Int4;
                    val2     : tsp00_MoveObjPtr;
                    p2       : tsp00_Int4;
                    cnt      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01c18 (debug : tgg00_Debug; msg : tsp00_C18);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01str30 (debug : tgg00_Debug; str30 : tsp00_C30);
 
        FUNCTION
              t01trace (layer : tgg00_Debug) : boolean;
 
        PROCEDURE
              t01write_line (VAR ln : tsp00_Line);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
.sp 2
This module outputs only the contents of the parse tree. In fact, the
output ought to have been located in the VTA01, but, then, various types would
have had to go into the VGG00. Therefore, although a VTA01 routine is called in
the core modules, it has the work done by VAK99.
.sp
The result typically has the following appearance:
.sp;Command:
.sp
SELECT A, B*4 FROM T WHERE A = 'NME'!
.sp;The output by VAK99:
.sp;.nf
Index Proc   Symb    Pos  Len  Lo   Sa
   1   63     1                2    0
   2   60     1                3   10
   3   60     2                4    5
   4  Symb columnn    8    1   0    0
   5   60     2                7    0
   6  Symb columnn   11    1   0    8
   7   64     6                6    0
   8  Symb stern     12    1   0    9
   9  Symb uns_int   13    1   0    0
  10   63     3               11   13
  11   66     1               12    0
  12  Symb tablen    20    1   0    0
  13   63    10               17    0
  14  Symb columnn   28    1   0   15
  15  Symb equal     30    1   0   16
  16  Symb stringli  33    3   0    0
  17   64     3               14    0
 1------ 2------ 3------ 4------
 | a63|__| a60|__| a60|__|Symb|
 |  1 |  |  1 |  |  2 |  |colu|
  ------  ------  ------  ------
            |       |
            |   5------ 7------ 6------
            |    | a60|__| a64|__|Symb|
            |    |  2 |  |  6 |  |colu|
            |    ------  ------  ------
            |                       |
            |                   8------
            |                    |Symb|
            |                    |ster|
            |                    ------
            |                       |
            |                   9------
            |                    |Symb|
            |                    |uns_|
            |                    ------
            |
        10------11------12------
         | a63|__| a66|__|Symb|
         |  3 |  |  1 |  |tabl|
          ------  ------  ------
            |
        13------17------14------
         | a63|__| a64|__|Symb|
         | 10 |  |  3 |  |colu|
          ------  ------  ------
                            |
                        15------
                         |Symb|
                         |equa|
                          ------
                            |
                        16------
                         |Symb|
                         |stri|
                          ------
.fo
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
 
Description:
.sp 2
The parse tree is an array of nodes, with a node having the following
appearance:
.sp;.nf
      ap_node = RECORD
            n_proc     : procs;
            n_symb     : sc_symbol;
            n_pos      : int2;
            n_length   : int2;
            n_lo_level : int2;
            n_sa_level : int2;
      END;
.fo
See VAK01 for the meaning of the individual parts.
 
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      one_l       = 8;
      one_small_l = 4;
 
TYPE
      fourlinearr = ARRAY [ 1..4 ] OF tsp00_DataLine;
      vertlines   = ARRAY [ 1..40 ] OF char;
 
VAR
      ak99privs : ARRAY[tak00_PrivR] OF tsp00_C3;
 
 
(*------------------------------*) 
 
PROCEDURE
      ak99build_small_output_lines (
            VAR n  : tak_ap_node;
            curr_n : integer;
            level  : integer;
            VAR la : fourlinearr);
 
VAR
      s2    : tsp00_C8;
      diff  : integer;
      i     : integer;
      start : integer;
 
BEGIN
IF  (level+1) * one_small_l <= LINE_MXSP00
THEN
    BEGIN
    start := level*one_small_l;
    diff := 0;
    i := curr_n MOD 10000;
    IF  i > 1000
    THEN
        BEGIN
        diff := 2;
        la[ 1 ].text[ start+1 ] := chr(i DIV 1000 + ord('0'));
        i := i MOD 1000;
        la[ 1 ].text[ start+2 ] := chr(i DIV 100 + ord('0'))
        END
    ELSE
        IF  i > 100
        THEN
            BEGIN
            diff := 1;
            la[ 1 ].text[ start+1 ] := chr(i DIV 100 + ord('0'))
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    i := curr_n MOD 100;
    IF  ((i DIV 10 > 0) OR (diff > 0))
    THEN
        la[ 1 ].text[ start+1+diff ] := chr(i DIV 10 + ord('0'));
    (*ENDIF*) 
    la[ 1 ].text[ start+2+diff ] := chr(i MOD 10 + ord('0'));
    FOR i := 3+diff TO one_small_l DO
        la[ 1 ].text[ start+i ] := '-';
    (*ENDFOR*) 
    FOR i := 2 TO one_small_l DO
        la[ 4 ].text[ start+i ] := '-';
    (*ENDFOR*) 
    IF  ord(n.n_proc) = 0
    THEN
        BEGIN
        la[ 2 ].text[ start+2 ] := 'S';
        la[ 2 ].text[ start+3 ] := 'y';
        la[ 2 ].text[ start+4 ] := 'm';
        ak99puts2 (n, s2);
        FOR i := 1 TO 3 DO
            la[ 3 ].text[ start+1+i ] := s2[ i ]
        (*ENDFOR*) 
        END
    ELSE
        BEGIN
        (*la[ 2 ].text[ start+1 ] := bsp_c1;*)
        IF  n.n_proc > a90
        THEN
            BEGIN
            la[ 2 ].pos := start+2;
            la[ 2 ].length := start+4;
            CASE n.n_proc OF
                a63query_spec :
                    a99putint (la[ 2 ], 631, 3);
                a92fromsel :
                    a99putint (la[ 2 ], 921, 3);
                a262 :
                    a99putint (la[ 2 ], 262, 3);
                a641 :
                    a99putint (la[ 2 ], 641, 3);
                a999ptr_node :
                    BEGIN
                    la[ 2 ].text[ start+2 ] := 'p';
                    la[ 2 ].text[ start+3 ] := 't';
                    la[ 2 ].text[ start+4 ] := 'r';
                    END;
                OTHERWISE
                    a99putint (la[ 2 ], 0, 3);
                END
            (*ENDCASE*) 
            END
        ELSE
            BEGIN
            la[ 2 ].text[ start+2 ] := 'a';
            la[ 2 ].pos := start+3;
            la[ 2 ].length := start+4;
            a99putint (la[ 2 ], ord(n.n_proc)+9, 2);
            END;
        (*ENDIF*) 
        IF  n.n_proc = a999ptr_node
        THEN
            FOR i := 2 TO 4 DO
                la[ 3 ].text[ start+i ] := bsp_c1
            (*ENDFOR*) 
        ELSE
            IF  NOT ( n.n_symb in [ s_unknown, s_sum, s_count, s_dis_count ])
            THEN
                BEGIN
                ak99puts2(n, s2);
                FOR i := 1 TO 3 DO
                    la[ 3 ].text[ start+1+i ] := s2[ i ]
                (*ENDFOR*) 
                END
            ELSE
                BEGIN
                (*la[ 3 ].text[ start+1 ] := bsp_c1;*)
                la[ 3 ].pos := start+2;
                la[ 3 ].length := start+3;
                a99putint (la[ 3 ], ord(n.n_subproc), 3);
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    FOR i := 1 TO 4 DO
        la[ i ].text[ start+5 ] := '|';
    (*ENDFOR*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak99small_nodeoutput (
            VAR ap_tree : tak_ap_max_tree;
            curr_n : integer;
            level  : integer;
            VAR la : fourlinearr;
            VAR vl : vertlines
            );
 
VAR
      i      : integer;
      innode : integer;
      j      : integer;
      start  : integer;
 
BEGIN
(*writeln ('act node: ', curr_n);*)
ak99build_small_output_lines (ap_tree[ curr_n ], curr_n, level, la);
innode := curr_n;
IF  ap_tree[ innode ].n_sa_level > 0
THEN
    vl[ level+1 ] := '|'
ELSE
    vl [ level+1 ] := ' ';
(*ENDIF*) 
IF  ap_tree[ curr_n ].n_lo_level > 0
THEN
    BEGIN
    IF  ((ap_tree[ curr_n ].n_proc <> no_proc) OR
        (ap_tree[ curr_n ].n_symb <> s_unknown))
    THEN
        IF  (level+2) * one_small_l <= LINE_MXSP00
        THEN
            BEGIN
            start := (level+1)*one_small_l;
            (*la[ 2 ].text[ start+1 ] := '_';*)
            (*writeln ('goto lower level. ', curr_n ,
                  ap_tree[ curr_n ].n_lo_level);*)
            ak99small_nodeoutput (ap_tree, ap_tree[ curr_n ].n_lo_level,
                  level+1, la, vl);
            FOR i := 1 TO 4 DO
                FOR j := 1 TO one_small_l+1 DO
                    la[ i ].text[ start+j ] := bsp_c1
                (*ENDFOR*) 
            (*ENDFOR*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END
ELSE
    FOR i := 1 TO 4 DO
        t01write_line (la[ i ].text);
    (*ENDFOR*) 
(*ENDIF*) 
IF   ap_tree[ innode ].n_sa_level > 0
THEN
    BEGIN
    start := level*one_small_l+2;
    FOR i := 1 TO 4 DO
        BEGIN
        FOR j := 1 TO start DO
            la[ i ].text[ j ] := bsp_c1;
        (*ENDFOR*) 
        FOR j := 1 TO level DO
            la[ i ].text[ j*one_small_l-1 ] := vl[ j ]
        (*ENDFOR*) 
        END;
    (*ENDFOR*) 
    ak99small_putblank (level, vl);
    (*writeln ('goto same  level. ', innode,
          ap_tree[ innode ].n_sa_level);*)
    innode := ap_tree[ innode ].n_sa_level;
    ak99small_nodeoutput (ap_tree, innode, level, la, vl);
    vl[ level+1 ] := ' '
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak99build_output_lines (
            VAR n  : tak_ap_node;
            curr_n : integer;
            level  : integer;
            VAR la : fourlinearr);
 
VAR
      s2    : tsp00_C8;
      diff  : integer;
      i     : integer;
      start : integer;
 
BEGIN
IF  (level+1) * one_l <= LINE_MXSP00
THEN
    BEGIN
    start := level*one_l;
    diff := 0;
    i := curr_n MOD 10000;
    IF  i > 1000
    THEN
        BEGIN
        diff := 2;
        la[ 1 ].text[ start+1 ] := chr(i DIV 1000 + ord('0'));
        i := i MOD 1000;
        la[ 1 ].text[ start+2 ] := chr(i DIV 100 + ord('0'))
        END
    ELSE
        IF  i > 100
        THEN
            BEGIN
            diff := 1;
            la[ 1 ].text[ start+1 ] := chr(i DIV 100 + ord('0'))
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    i := curr_n MOD 100;
    IF  ((i DIV 10 > 0) OR (diff > 0))
    THEN
        la[ 1 ].text[ start+1+diff ] := chr(i DIV 10 + ord('0'));
    (*ENDIF*) 
    la[ 1 ].text[ start+2+diff ] := chr(i MOD 10 + ord('0'));
    FOR i := 3+diff TO one_l DO
        la[ 1 ].text[ start+i ] := '-';
    (*ENDFOR*) 
    FOR i := 3 TO one_l DO
        la[ 4 ].text[ start+i ] := '-';
    (*ENDFOR*) 
    la[ 2 ].text[ start+3 ] := '|';
    la[ 3 ].text[ start+3 ] := '|';
    la[ 2 ].text[ start+8 ] := '|';
    la[ 3 ].text[ start+8 ] := '|';
    IF  ord(n.n_proc) = 0
    THEN
        BEGIN
        la[ 2 ].text[ start+4 ] := 'S';
        la[ 2 ].text[ start+5 ] := 'y';
        la[ 2 ].text[ start+6 ] := 'm';
        la[ 2 ].text[ start+7 ] := 'b';
        ak99puts2 (n, s2);
        FOR i := 1 TO 4 DO
            la[ 3 ].text[ start+3+i ] := s2[ i ]
        (*ENDFOR*) 
        END
    ELSE
        BEGIN
        la[ 2 ].text[ start+4 ] := bsp_c1;
        IF  n.n_proc > a90
        THEN
            BEGIN
            la[ 2 ].pos := start+5;
            la[ 2 ].length := start+7;
            CASE n.n_proc OF
                a63query_spec :
                    a99putint (la[ 2 ], 631, 3);
                a92fromsel :
                    a99putint (la[ 2 ], 921, 3);
                a262 :
                    a99putint (la[ 2 ], 262, 3);
                a641 :
                    a99putint (la[ 2 ], 641, 3);
                a999ptr_node :
                    BEGIN
                    la[ 2 ].text[ start+5 ] := 'p';
                    la[ 2 ].text[ start+6 ] := 't';
                    la[ 2 ].text[ start+7 ] := 'r';
                    END;
                OTHERWISE
                    a99putint (la[ 2 ], 0, 3);
                END
            (*ENDCASE*) 
            END
        ELSE
            BEGIN
            la[ 2 ].text[ start+5 ] := 'a';
            la[ 2 ].pos := start+6;
            la[ 2 ].length := start+7;
            a99putint (la[ 2 ], ord(n.n_proc)+9, 2);
            END;
        (*ENDIF*) 
        IF  n.n_proc = a999ptr_node
        THEN
            FOR i := 4 TO 7 DO
                la[ 3 ].text[ start+i ] := bsp_c1
            (*ENDFOR*) 
        ELSE
            IF  NOT ( n.n_symb in [  s_unknown, s_sum, s_count, s_dis_count ])
            THEN
                BEGIN
                ak99puts2(n, s2);
                FOR i := 1 TO 4 DO
                    la[ 3 ].text[ start+3+i ] := s2[ i ]
                (*ENDFOR*) 
                END
            ELSE
                BEGIN
                la[ 3 ].text[ start+4 ] := bsp_c1;
                la[ 3 ].pos := start+5;
                la[ 3 ].length := start+6;
                a99putint (la[ 3 ], ord(n.n_subproc), 3);
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak99small_putblank (
            level  : integer;
            VAR vl : vertlines);
 
VAR
      i  : integer;
      l1 : tsp00_Line;
 
BEGIN
l1 := a99blankline;
FOR i := 1 TO level+1 DO
    l1[ i*one_small_l-1 ] := vl[ i ];
(*ENDFOR*) 
t01write_line (l1)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak99nodeoutput (
            VAR ap_tree  : tak_ap_max_tree;
            curr_n       : integer;
            level        : integer;
            VAR la       : fourlinearr;
            VAR vl       : vertlines;
            VAR too_wide : boolean
            );
 
VAR
      i      : integer;
      innode : integer;
      j      : integer;
      start  : integer;
 
BEGIN
(*writeln ('act node: ', curr_n);*)
ak99build_output_lines (ap_tree[ curr_n ], curr_n, level, la);
innode := curr_n;
IF  ap_tree[ innode ].n_sa_level > 0
THEN
    vl[ level+1 ] := '|'
ELSE
    vl [ level+1 ] := ' ';
(*ENDIF*) 
IF  ap_tree[ curr_n ].n_lo_level > 0
THEN
    BEGIN
    IF  ((ap_tree[ curr_n ].n_proc <> no_proc) OR
        (ap_tree[ curr_n ].n_symb <> s_unknown))
    THEN
        IF  (level+2) * one_l <= LINE_MXSP00
        THEN
            BEGIN
            start := (level+1)*one_l;
            la[ 2 ].text[ start+1 ] := '_';
            la[ 2 ].text[ start+2 ] := '_';
            (*writeln ('goto lower level. ', curr_n ,
                  ap_tree[ curr_n ].n_lo_level);*)
            ak99nodeoutput (ap_tree, ap_tree[ curr_n ].n_lo_level,
                  level+1, la, vl, too_wide);
            FOR i := 1 TO 4 DO
                FOR j := 1 TO one_l DO
                    la[ i ].text[ start+j ] := bsp_c1
                (*ENDFOR*) 
            (*ENDFOR*) 
            END
        ELSE
            too_wide := true
        (*ENDIF*) 
    (*ENDIF*) 
    END
ELSE
    FOR i := 1 TO 4 DO
        t01write_line (la[ i ].text);
    (*ENDFOR*) 
(*ENDIF*) 
IF   ap_tree[ innode ].n_sa_level > 0
THEN
    BEGIN
    IF  NOT too_wide
    THEN
        ak99putblank (level, vl)
    ELSE
        BEGIN
        la[ 1 ].text := a99blankline;
        la[ 1 ].text[80] := 'o';
        la[ 1 ].text[81] := 'u';
        la[ 1 ].text[82] := 't';
        la[ 1 ].text[83] := 'p';
        la[ 1 ].text[84] := 'u';
        la[ 1 ].text[85] := 't';
        la[ 1 ].text[86] := ' ';
        la[ 1 ].text[87] := 'i';
        la[ 1 ].text[88] := 's';
        la[ 1 ].text[89] := ' ';
        la[ 1 ].text[90] := 't';
        la[ 1 ].text[91] := 'o';
        la[ 1 ].text[92] := 'o';
        la[ 1 ].text[93] := ' ';
        la[ 1 ].text[94] := 'l';
        la[ 1 ].text[95] := 'o';
        la[ 1 ].text[96] := 'n';
        la[ 1 ].text[97] := 'g';
        la[ 1 ].text[98] := '.';
        la[ 1 ].text[99] := ' ';
        la[ 1 ].text[100] := 'S';
        la[ 1 ].text[101] := 'e';
        la[ 1 ].text[102] := 'e';
        la[ 1 ].text[103] := ' ';
        la[ 1 ].text[104] := 's';
        la[ 1 ].text[105] := 'm';
        la[ 1 ].text[106] := 'a';
        la[ 1 ].text[107] := 'l';
        la[ 1 ].text[108] := 'l';
        la[ 1 ].text[109] := 'n';
        la[ 1 ].text[110] := 'o';
        la[ 1 ].text[111] := 'd';
        la[ 1 ].text[112] := 'e';
        la[ 1 ].text[113] := 's';
        la[ 1 ].text[114] := '.';
        t01write_line (la[ 1 ].text)
        END;
    (*ENDIF*) 
    start := level*one_l+2;
    FOR i := 1 TO 4 DO
        BEGIN
        FOR j := 1 TO start DO
            la[ i ].text[ j ] := bsp_c1;
        (*ENDFOR*) 
        FOR j := 1 TO level DO
            la[ i ].text[ j*one_l-2 ] := vl[ j ]
        (*ENDFOR*) 
        END;
    (*ENDFOR*) 
    (*writeln ('goto same  level. ', innode,
          ap_tree[ innode ].n_sa_level);*)
    innode := ap_tree[ innode ].n_sa_level;
    ak99nodeoutput (ap_tree, innode, level, la, vl, too_wide);
    vl[ level+1 ] := ' '
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak99putblank (
            level  : integer;
            VAR vl : vertlines);
 
VAR
      i  : integer;
      l1 : tsp00_Line;
 
BEGIN
l1 := a99blankline;
FOR i := 1 TO level+1 DO
    l1[ i*one_l-2 ] := vl[ i ];
(*ENDFOR*) 
t01write_line (l1)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak99put_info (
            VAR n  : tak_ap_node;
            VAR s2 : tsp00_C12);
 
BEGIN
CASE n.n_proc OF
    a11 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_create_table:
                s2 := 'CREATE TABLE';
            cak_x_drop_table:
                s2 := 'DROP TABLE  ';
            cak_x_drop_view:
                s2 := 'DROP VIEW   ';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a55 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_search_clause:
                s2 := 'SRCH CLAUSE ';
            cak_x_keyspec:
                s2 := 'KEYSPEC     ';
            cak_x_current_of:
                s2 := 'CURRENT OF  ';
            cak_x_keyspec_list:
                s2 := 'KEYSPEC LIST';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a56 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_normal_insert :
                s2 := 'NORM INSERT ';
            cak_x_enum_values :
                s2 := 'ENUM VAL    ';
            cak_x_column_list :
                s2 := 'COL LIST    ';
            cak_x_value_list :
                s2 := 'VAL LIST    ';
            cak_x_ignore_dupl :
                s2 := 'IGNORE DUP  ';
            cak_x_update_dupl :
                s2 := 'UPD IGNORE  ';
            cak_x_reject_dupl :
                s2 := 'REJECT DUP  ';
            cak_x_named_values :
                s2 := 'NAM VAL     ';
            cak_x_set_clause :
                s2 := 'SET CLAUSE  ';
            cak_x_insert_select :
                s2 := 'INSERT SELCT';
            cak_x_minsert :
                s2 := 'MASS INSERT ';
            cak_x_pseudo_ins_select :
                s2 := 'PSEUDO INSEL';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a57 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_update :
                s2 := 'UPDATE      ';
            cak_x_update_set :
                s2 := 'UPDATE SET  ';
            cak_x_one_update_col :
                s2 := 'ONE UPDCOL  ';
            cak_x_mupdate :
                s2 := 'MASS UPDATE ';
            cak_x_append :
                s2 := 'APPEND      ';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a58 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_delete :
                s2 := 'DELETE      ';
            cak_x_mdelete :
                s2 := 'MASS DELETE ';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a60 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_select_list:
                s2 := 'SEL LIST    ';
            cak_x_select_column:
                s2 := 'SEL COLUMN  ';
            cak_x_single_select:
                s2 := 'SINGLE SEL  ';
            cak_x_lock_nowait:
                s2 := 'LOCK NOWAIT ';
            cak_x_lock_exclusive:
                s2 := 'LOCK EXCLUSI';
            cak_x_lock_share:
                s2 := 'LOCK SHARE  ';
            cak_x_lock_optimistic:
                s2 := 'LOCK OPT    ';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a62 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_select_direct :
                s2 := 'SEL DIRECT  ';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a63 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_mass_select :
                s2 := 'MASS SELECT ';
            cak_x_distinct :
                s2 := 'DISTINCT    ';
            cak_x_from_part :
                s2 := 'FROM        ';
            cak_x_decl_cursor :
                s2 := 'DCL CURSOR  ';
            cak_x_order :
                s2 := 'ORDER       ';
            cak_x_for_update :
                s2 := 'FOR UPDATE  ';
            cak_x_group_by :
                s2 := 'GROUP BY    ';
            cak_x_having :
                s2 := 'HAVING      ';
            cak_x_sort_spec :
                s2 := 'SORT SPEC   ';
            cak_x_search_condition :
                s2 := 'SEARCH COND ';
            cak_x_for_reuse :
                s2 := 'FOR REUSE   ';
            cak_x_subquery :
                s2 := 'SUBQUERY    ';
            cak_x_start_union :
                s2 := 'START UNION ';
            cak_x_union :
                s2 := 'UNION       ';
            cak_x_union_all :
                s2 := 'UNION ALL   ';
            cak_x_except :
                s2 := 'EXCEPT      ';
            cak_x_except_all :
                s2 := 'EXCEPT ALL  ';
            cak_x_intersect :
                s2 := 'INTERSECT   ';
            cak_x_intersect_all :
                s2 := 'INTERSCT ALL';
            cak_x_res_delete :
                s2 := 'RES DEL     ';
            cak_x_res_no_delete :
                s2 := 'RES NO DEL  ';
            cak_x_recursive_select :
                s2 := 'RECUR SEL   ';
            cak_x_new_columnname_list :
                s2 := 'NEW COLNA LI';
            cak_x_one_val_subquery :
                s2 := 'ONE VAL SUBQ';
            cak_x_corr_subquery :
                s2 := 'CORR SUBQ   ';
            cak_x_one_val_corr_sub :
                s2 := '1VALCORRSUBQ';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a64 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_or_operator :
                s2 := 'OR          ';
            cak_x_and_operator :
                s2 := 'AND         ';
            cak_x_predicate :
                s2 := 'PREDICAT    ';
            cak_x_add_operator :
                s2 := 'ADD         ';
            cak_x_mult_operator :
                s2 := 'MULT        ';
            cak_x_between_pred :
                s2 := 'BETWEEN     ';
            cak_x_in_pred :
                s2 := 'IN          ';
            cak_x_in_pred_list :
                s2 := 'IN LIST     ';
            cak_x_like_pred :
                s2 := 'LIKE        ';
            cak_x_sounds_pred :
                s2 := 'SOUNDS      ';
            cak_x_duration :
                s2 := 'DURATION    ';
            cak_x_left_outer_join :
                s2 := 'LEFT OJOIN  ';
            cak_x_right_outer_join :
                s2 := 'RIGHT OJOIN ';
            cak_x_full_outer_join :
                s2 := 'FUL OJOIN   ';
            cak_x_escape :
                s2 := 'ESCAPE      ';
            cak_x_truth_value :
                s2 := 'TRUTH       ';
            cak_x_value_expression :
                s2 := 'VAL EXPR    ';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a66 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_given_sequence :
                s2 := 'GIVEN SEQUEN';
            cak_x_table_spec :
                s2 := 'TAB SPEC    ';
            cak_x_select_in_from_part :
                s2 := 'FROMSEL     ';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a63query_spec :
        BEGIN
        s2 := 'QUERY SPEC  ';
        END;
    a80 :
        BEGIN
        CASE n.n_subproc OF
            cak_x_select_hint :
                s2 := 'SELECT HINT ';
            cak_x_delete_hint :
                s2 := 'DELETE HINT ';
            cak_x_update_hint :
                s2 := 'UPDATE HINT ';
            cak_x_ordered_hint :
                s2 := 'ordered     ';
            cak_x_keyaccess_hint :
                s2 := 'keyaccess   ';
            cak_x_indexaccess_hint :
                s2 := 'indexaccess ';
            cak_x_indexscan_hint :
                s2 := 'indexscan   ';
            cak_x_keyscan_hint :
                s2 := 'keyscan     ';
            cak_x_buildresult_hint :
                s2 := 'buildresult ';
            cak_x_fetchresult_hint :
                s2 := 'fetchresult ';
            cak_x_enablemerge_hint :
                s2 := 'enable merge';
            cak_x_disableinvonly_hint :
                s2 := 'disa invonly';
            cak_x_trace_hint :
                s2 := 'trace       ';
            cak_x_L1_strat_hint :
                s2 := 'L1 strat    ';
            cak_x_L2_strat_hint :
                s2 := 'L2 strat    ';
            cak_x_L2_more_strat_hint :
                s2 := 'L2 more     ';
            cak_x_L2_range_strat_hint :
                s2 := 'L2 range    ';
            cak_x_L2_strat_no_optim_hint :
                s2 := 'L2 no optim ';
            cak_x_in_strat_hint :
                s2 := 'IN strat    ';
            cak_x_subq_strat_hint :
                s2 := 'subq strat  ';
            cak_x_nopath_hint     :
                s2 := 'notrans     ';
            cak_x_join_hint       :
                s2 := 'join hint   ';
            cak_x_access_hint       :
                s2 := '1tab access ';
            OTHERWISE
                s2 := '            ';
            END;
        (*ENDCASE*) 
        END;
    a92fromsel :
        BEGIN
        s2 := 'FROMSEL     ';
        END;
    OTHERWISE
        s2 := '            ';
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak99puts2 (
            VAR n  : tak_ap_node;
            VAR s2 : tsp00_C8);
 
BEGIN
CASE n.n_symb OF
    s_unknown :
        s2 := 'unknown ';
    s_comma :
        s2 := 'comma   ';
    s_divide :
        s2 := 'divide  ';
    s_eof :
        s2 := 'eof     ';
    s_equal :
        s2 := 'equal   ';
    s_greater :
        s2 := 'greater ';
    s_greater_or_eq :
        s2 := 'great_eq';
    s_leftpar :
        s2 := 'leftpar ';
    s_less :
        s2 := 'less    ';
    s_less_or_eq :
        s2 := 'less_equ';
    s_minus :
        s2 := 'minus   ';
    s_plus :
        s2 := 'plus    ';
    s_point :
        s2 := 'point   ';
    s_rightpar :
        s2 := 'rightpar';
    s_semicolon :
        s2 := 'semicolo';
    s_asterisk :
        s2 := 'stern   ';
    s_unequal :
        s2 := 'unequal ';
    s_key :
        s2 := 'key     ';
    s_not_null :
        s2 := 'not_null';
    s_ascii :
        s2 := 'ascii   ';
    s_byte :
        s2 := 'byte    ';
    s_byte_string :
        s2 := 'byte_str';
    s_date :
        s2 := 'date    ';
    s_time :
        s2 := 'time    ';
    s_user :
        s2 := 'user    ';
    s_notin :
        s2 := 'notin   ';
    s_in :
        s2 := 'in      ';
    s_notbetween :
        s2 := 'notbetwe';
    s_between :
        s2 := 'between ';
    s_default :
        s2 := 'default ';
    s_character :
        s2 := 'char    ';
    s_fixed :
        s2 := 'fixed   ';
    s_float :
        s2 := 'float   ';
    s_file :
        s2 := 'file    ';
    s_smallint :
        s2 := 'smallint';
    s_varchar :
        s2 := 'varchar ';
    s_longvarchar :
        s2 := 'longvarc';
    s_integer :
        s2 := 'integer ';
    s_fixed_point_literal :
        s2 := 'fixed_li';
    s_floating_point_literal :
        s2 := 'float_li';
    s_identifier :
        s2 := 'identifi';
    s_authid :
        s2 := 'authid  ';
    s_tablename :
        s2 := 'tablen  ';
    s_columnname :
        s2 := 'columnn ';
    s_columnid :
        s2 := 'columnID';
    s_parameter_name :
        s2 := 'paramete';
    s_special_identifier :
        s2 := 'speciden';
    s_string_literal :
        s2 := 'stringli';
    s_unsigned_integer :
        s2 := 'uns_int ';
    s_null :
        s2 := 'null    ';
    s_desc :
        s2 := 'descend ';
    s_or :
        s2 := ' or     ';
    s_not :
        s2 := 'not     ';
    s_and :
        s2 := 'and     ';
    s_is_not_null :
        s2 := 'isnotnul';
    s_is_null :
        s2 := 'is_null ';
    s_count :
        s2 := 'count   ';
    s_avg :
        s2 := 'avg     ';
    s_min :
        s2 := 'min     ';
    s_max :
        s2 := 'max     ';
    s_sum :
        s2 := 'sum     ';
    s_abs :
        s2 := 'abs     ';
    s_trunc :
        s2 := 'trunc   ';
    s_div :
        s2 := 'div     ';
    s_mod :
        s2 := 'mod     ';
    s_concat :
        s2 := 'concat  ';
    s_substr :
        s2 := 'substr  ';
    s_trim :
        s2 := 'trim    ';
    s_length :
        s2 := 'length  ';
    s_vsize :
        s2 := 'vsize   ';
    s_upper :
        s2 := 'upper   ';
    s_lower :
        s2 := 'lower   ';
    s_lpad :
        s2 := 'lpad    ';
    s_rpad :
        s2 := 'rpad    ';
    s_num :
        s2 := 'num     ';
    s_chr :
        s2 := 'chr     ';
    s_all :
        s2 := 'all     ';
    s_any :
        s2 := 'any     ';
    s_reference_name :
        s2 := 'referenc';
    s_asc :
        s2 := 'asc     ';
    s_all_priv :
        s2 := 'all_pr  ';
    s_owner :
        s2 := 'owner   ';
    s_insert :
        s2 := 'insert  ';
    s_delete :
        s2 := 'delete  ';
    s_update :
        s2 := 'update  ';
    s_select :
        s2 := 'select  ';
    s_selupd :
        s2 := 'selupd  ';
    s_index :
        s2 := 'index   ';
    s_rfill :
        s2 := 'rfill   ';
    s_lfill :
        s2 := 'lfill   ';
    s_dis_count :
        s2 := 'discount';
    s_dis_avg :
        s2 := 'disavg  ';
    s_dis_sum :
        s2 := 'dissum  ';
    s_vs_decimal :
        s2 := 'vs_decim';
    s_vs_zoned :
        s2 := 'vs_zoned';
    s_all_count :
        s2 := 'allcount';
    s_adddate :
        s2 := 'adddate ';
    s_subdate :
        s2 := 'subdate ';
    s_datediff :
        s2 := 'datediff';
    s_dayofweek :
        s2 := 'dayweek ';
    s_weekofyear :
        s2 := 'weekyear';
    s_dayofyear :
        s2 := 'dayyear ';
    s_addtime :
        s2 := 'addtime ';
    s_subtime :
        s2 := 'subtime ';
    s_timediff:
        s2 := 'timediff';
    s_next_day:
        s2 := 'next_day';
    s_rowno:
        s2 := 'rowno   ';
    s_maketime:
        s2 := 'maketime';
    s_round :
        s2 := 'round   ';
    s_mapchar :
        s2 := 'mapchar ';
    s_usergroup :
        s2 := 'usergrou';
    s_packed :
        s2 := 'packed  ';
    s_binary :
        s2 := 'binary  ';
    s_makedate :
        s2 := 'makedate';
    s_exists :
        s2 := 'exists  ';
    s_expand :
        s2 := 'expand  ';
    s_stamp :
        s2 := 'stamp   ';
    s_mult :
        s2 := 'mult    ';
    s_like :
        s2 := 'like    ';
    s_notlike :
        s2 := 'notlike ';
    s_sounds :
        s2 := 'sounds  ';
    s_notsounds :
        s2 := 'notsound';
    s_value :
        s2 := 'value   ';
    s_func_char  :
        s2 := 'f_char  ';
    s_day   :
        s2 := 'day     ';
    s_days  :
        s2 := 'days    ';
    s_digits:
        s2 := 'digits  ';
    s_hex   :
        s2 := 'hex     ';
    s_hour  :
        s2 := 'hour    ';
    s_microsecond :
        s2 := 'microsec';
    s_minute:
        s2 := 'minute  ';
    s_month :
        s2 := 'month   ';
    s_second :
        s2 := 'second  ';
    s_timestamp :
        s2 := 'timestam';
    s_year  :
        s2 := 'year    ';
    s_timezone :
        s2 := 'timezone';
    s_alter :
        s2 := 'alter   ';
    s_outer_join :
        s2 := 'outrjoin';
    s_soundex :
        s2 := 'soundex ';
    s_double_precision :
        s2 := 'doubprec';
    s_link :
        s2 := 'link    ';
    (* PTS 1111797 E.Z. *)
    s_sysdba :
        s2 := 'sysdba  ';
    s_func_date :
        s2 := 'funcdate';
    s_func_time :
        s2 := 'functime';
    s_func_timestamp :
        s2 := 'functstp';
    s_colon :
        s2 := 'colon   ';
    s_hostfilename :
        s2 := 'hostfile';
    s_midnight :
        s2 := 'midnight';
    s_graphic :
        s2 := 'graphic ';
    s_vargraphic :
        s2 := 'vargraph';
    s_long_varchar :
        s2 := 'long_var';
    s_long_vargraphic :
        s2 := 'longraph';
    s_noround :
        s2 := 'noround ';
    s_is_true :
        s2 := 'is true ';
    s_is_not_true :
        s2 := 'not true';
    s_is_false :
        s2 := 'is false';
    s_is_not_false :
        s2 := 'notfalse';
    s_to_number :
        s2 := 'to_numbe';
    s_ltrim :
        s2 := 'ltrim   ';
    s_rtrim :
        s2 := 'rtrim   ';
    s_initcap :
        s2 := 'initcap ';
    s_translate :
        s2 := 'translat';
    s_replace :
        s2 := 'replace ';
    s_ceil :
        s2 := 'ceil    ';
    s_floor :
        s2 := 'floor   ';
    s_sign :
        s2 := 'sign    ';
    s_mod_func :
        s2 := 'modfunc ';
    s_sqrt :
        s2 := 'sqrt    ';
    s_power :
        s2 := 'power   ';
    s_exp :
        s2 := 'exponent';
    s_ln :
        s2 := 'log_nat ';
    s_log :
        s2 := 'logarith';
    s_cos :
        s2 := 'cosinus ';
    s_cosh :
        s2 := 'cos_hyp ';
    s_sin :
        s2 := 'sinus   ';
    s_sinh :
        s2 := 'sin_hyp ';
    s_tan :
        s2 := 'tangens ';
    s_tanh :
        s2 := 'tan_hyp ';
    s_greatest:
        s2 := 'greatest';
    s_least :
        s2 := 'least   ';
    s_decode :
        s2 := 'decode  ';
    s_stddev :
        s2 := 'stddev  ';
    s_dis_stddev :
        s2 := 'd stddev';
    s_variance :
        s2 := 'variance';
    s_dis_variance :
        s2 := 'd varian';
    s_chr_ora :
        s2 := 'chr_ora ';
    s_hextoraw :
        s2 := 'hextoraw';
    s_add_months :
        s2 := 'addmonth';
    s_last_day :
        s2 := 'last_day';
    s_months_between :
        s2 := 'months_b';
    s_dba :
        s2 := 'dba     ';
    s_nextval :
        s2 := 'nextval ';
    s_sequence :
        s2 := 'sequence';
    s_to_24_char :
        s2 := 'to_24_ch';
    s_uid :
        s2 := 'uid     ';
    s_rowid :
        s2 := 'rowid   ';
    s_user_func :
        s2 := 'userfunc';
    s_currval :
        s2 := 'currval ';
    s_real :
        s2 := 'real    ';
    s_new_time :
        s2 := 'new_time';
    s_to_date :
        s2 := 'to_date ';
    s_to_char :
        s2 := 'to_char ';
    s_old_long :
        s2 := 'old_long';
    s_acos :
        s2 := 'acos    ';
    s_asin :
        s2 := 'asin    ';
    s_atan :
        s2 := 'atan    ';
    s_atan2 :
        s2 := 'atan2   ';
    s_cot :
        s2 := 'cot     ';
    s_log10 :
        s2 := 'log10   ';
    s_pi :
        s2 := 'pi      ';
    s_radians :
        s2 := 'radians ';
    s_degrees :
        s2 := 'degrees ';
    s_left :
        s2 := 'left    ';
    s_right :
        s2 := 'right   ';
    s_space :
        s2 := 'space   ';
    s_dayofmonth :
        s2 := 'dayofmon';
    s_monthname :
        s2 := 'monthnam';
    s_boolean :
        s2 := 'boolean ';
    s_true :
        s2 := 'true    ';
    s_false :
        s2 := 'false   ';
    s_toidentifier :
        s2 := 'toident ';
    s_degree :
        s2 := 'degree  ';
    s_cast :
        s2 := 'cast    ';
    s_database :
        s2 := 'database';
    s_where :
        s2 := 'where   ';
    s_having :
        s2 := 'having  ';
    s_dayname :
        s2 := 'dayname ';
    s_unicode :
        s2 := 'unicode ';
    s_mbcs :
        s2 := 'mbcs    ';
    s_transaction :
        s2 := 'transact';
    s_serial :
        s2 := 'serial  ';
    s_method_call :
        s2 := 'methcall';
    s_hint :
        s2 := 'hint    ';
    (* PTS 1109925 E.Z. *)
    s_utcdiff :
        s2 := 'utcdiff ';
    (* PTS 1116175 E.Z. *)
    s_utcdate :
        s2 := 'utcdate ';
    (* PTS 1111577 E.Z. *)
    s_get_schema :
        s2 := 'getschem';
    s_get_name :
        s2 := 'get_name';
    (* PTS 1117523 E.Z. *)
    s_case :
        s2 := 'case    ';
    s_now :
        s2 := 'now     ';
    s_current_schema :
        s2 := 'c_schema';
    OTHERWISE
        BEGIN
        s2 := 'neu     ';
        s2[ 4 ] := chr(ord(n.n_symb)  DIV 100 + ord('0'));
        s2[ 5 ] := chr((ord(n.n_symb) MOD 100) DIV 10 + ord('0'));
        s2[ 6 ] := chr(ord(n.n_symb)           MOD 10 + ord('0'))
        END
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a99init;
 
BEGIN
SAPDB_PascalForcedFill (sizeof(a99blankline), @a99blankline, 1,
      sizeof(a99blankline), bsp_c1);
ak99privs[r_sel  ] := 'SEL';
ak99privs[r_upd  ] := 'UPD';
ak99privs[r_ins  ] := 'INS';
ak99privs[r_del  ] := 'DEL';
ak99privs[r_owner] := 'OWN';
ak99privs[r_alter] := 'ALT';
ak99privs[r_index] := 'IDX';
ak99privs[r_link ] := 'REF';
END;
 
(*------------------------------*) 
 
PROCEDURE
      a99_priv_all_set (
            layer              : tgg00_Debug;
            priv_all_set       : tak00_PrivilegeSet;
            priv_all_grant_set : tak00_PrivilegeSet);
 
VAR
      curr_priv : tak00_PrivR;
      ln_pos    : integer;
      ix        : integer;
      ln        : tsp00_Line;
 
BEGIN
IF  t01trace (layer)
THEN
    BEGIN
    ln     := a99blankline;
    ln_pos := 1;
    FOR curr_priv := r_sel TO r_link DO
        BEGIN
        IF  curr_priv in priv_all_set
        THEN
            BEGIN
            FOR ix := 1 TO sizeof(ak99privs[curr_priv]) DO
                BEGIN
                ln[ln_pos] := ak99privs[curr_priv, ix];
                ln_pos     := ln_pos + 1
                END;
            (*ENDFOR*) 
            IF  curr_priv in priv_all_grant_set
            THEN
                ln[ln_pos] := '+';
            (*ENDIF*) 
            ln_pos := ln_pos + 1
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    t01write_line (ln)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a99print_nodes (
            VAR ap_tree : tak_ap_max_tree;
            cntnodes : integer;
            hint_node: tsp00_Int2
            );
 
CONST
      procstart    =  7;
      subprocstart = 11;
      symbstart    = 19;
      datatypstart = 33;
      posstart     = 45;
      lengthstart  = 51;
      lolevelstart = 56;
      salevelstart = 61;
      balevelstart = 66;
      specialstart = 71;
 
VAR
      too_wide : boolean;
      s1       : tsp00_C80;
      s2       : tsp00_C8;
      s3       : tsp00_C12;
      l        : tsp00_DataLine;
      la       : fourlinearr;
      i        : integer;
      j        : integer;
      vl       : vertlines;
      msg      : tsp00_Sname;
 
BEGIN
s1 :=
      'Index Proc Subproc Symb/Info     Datatype     Pos  Len   Lo   Sa   Ba           ';
l.text := a99blankline;
FOR i := 1 TO 80 DO
    l.text[ i ] := s1[ i ];
(*ENDFOR*) 
t01write_line (l.text);
i := 0;
REPEAT
    IF  NOT ((ord(ap_tree[ i ].n_proc)=0)
        AND (ap_tree[ i ].n_sa_level=-1)
        AND (ap_tree[ i ].n_lo_level=-1) )
    THEN
        BEGIN
        (* D.T.: print only those nodes that are not set as 'free nodes' by QueryRewrite *)
        l.text   := a99blankline;
        l.pos    := 1;
        l.length := 1;
        a99putint (l, i, 4);
        IF  ord(ap_tree[ i ].n_proc) = 0
        THEN
            BEGIN
            IF  ap_tree[ i ].n_symb = s_columnid
            THEN
                BEGIN
                l.pos    := subprocstart;
                l.length := subprocstart+1;
                a99putint (l, ap_tree[ i ].n_subproc, 4);
                END;
            (*ENDIF*) 
            l.text[ procstart   ] := 'S';
            l.text[ procstart+1 ] := 'y';
            l.text[ procstart+2 ] := 'm';
            l.text[ procstart+3 ] := 'b';
            ak99puts2 (ap_tree[ i ], s2);
            FOR j := 1 TO 8 DO
                l.text[ symbstart+j ] := s2[ j ];
            (*ENDFOR*) 
            l.pos    := posstart;
            l.length := posstart+1;
            a99putint (l, ap_tree[ i ].n_pos, 5);
            l.pos    := lengthstart;
            l.length := lengthstart+1;
            a99putint (l, ap_tree[ i ].n_length, 4);
            IF  ap_tree[ i ].n_datatype <> dunknown
            THEN
                BEGIN
                CASE ap_tree[ i ].n_datatype OF
                    dfixed:
                        msg := 'fixed       ';
                    dfloat:
                        msg := 'float       ';
                    dcha:
                        msg := 'char_asc    ';
                    dchb:
                        msg := 'char_byte   ';
                    drowid:
                        msg := 'rowid       ';
                    dstra:
                        msg := 'string_asc  ';
                    dstrb:
                        msg := 'string_byte ';
                    ddate:
                        msg := 'date        ';
                    dtime:
                        msg := 'time        ';
                    dvfloat:
                        msg := 'vfloat      ';
                    dtimestamp:
                        msg := 'timestamp   ';
                    dunknown:
                        msg := 'unknown     ';
                    dnumber:
                        msg := 'number      ';
                    dnonumber:
                        msg := 'nonumber    ';
                    dduration:
                        msg := 'duration    ';
                    dlonga:
                        msg := 'long_asc    ';
                    dlongb:
                        msg := 'long_byte   ';
                    dboolean:
                        msg := 'boolean     ';
                    dunicode:
                        msg := 'unicode     ';
                    dsmallint:
                        msg := 'smallint    ';
                    dinteger:
                        msg := 'integer     ';
                    dvarchara:
                        msg := 'varchar_asc ';
                    dvarcharb:
                        msg := 'varchar_byte';
                    dstruni:
                        msg := 'string_unico';
                    dlonguni:
                        msg := 'long_unicode';
                    OTHERWISE
                        msg := 'new datatype';
                    END;
                (*ENDCASE*) 
                SAPDB_PascalForcedMove (sizeof(msg), sizeof(l.text),
                      @msg, 1, @l.text, datatypstart, sizeof(msg));
                END
            ELSE
                BEGIN
                l.pos    := lengthstart;
                l.length := lengthstart+1;
                a99putint (l, ap_tree[ i ].n_length, 4);
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            l.text[ procstart ] := 'a';
            l.pos       := procstart+1;
            l.length    := procstart+2;
            IF  ap_tree[ i ].n_proc > a90
            THEN
                BEGIN
                CASE ap_tree[ i ].n_proc OF
                    a63query_spec :
                        a99putint (l, 631, 3);
                    a92fromsel :
                        a99putint (l, 921, 3);
                    a262 :
                        a99putint (l, 262, 3);
                    a641 :
                        a99putint (l, 641, 3);
                    a999ptr_node :
                        BEGIN
                        l.text[ l.pos-1 ] := 'p';
                        l.text[ l.pos   ] := 't';
                        l.text[ l.pos+1 ] := 'r';
                        l.pos := l.pos + 3;
                        l.length := l.length + 3
                        END;
                    OTHERWISE
                        a99putint (l, 0, 3);
                    END;
                (*ENDCASE*) 
                END
            ELSE
                a99putint (l, ord(ap_tree[ i ].n_proc)+9, 2);
            (*ENDIF*) 
            IF  ap_tree[ i ].n_proc <> a999ptr_node
            THEN
                BEGIN
                l.pos    := subprocstart;
                l.length := subprocstart+1;
                a99putint (l, ap_tree[ i ].n_subproc, 4);
                IF  ap_tree[ i ].n_symb <> s_unknown
                THEN
                    BEGIN
                    ak99puts2 (ap_tree[ i ], s2);
                    FOR j := 1 TO 8 DO
                        l.text[ symbstart+j ] := s2[ j ];
                    (*ENDFOR*) 
                    END
                ELSE
                    BEGIN
                    ak99put_info( ap_tree[ i ], s3 );
                    FOR j := 1 TO 12 DO
                        l.text[ symbstart+j ] := s3[ j ];
                    (*ENDFOR*) 
                    END;
                (*ENDIF*) 
                IF  ap_tree[ i ].n_datatype <> dunknown
                THEN
                    BEGIN
                    CASE ap_tree[ i ].n_datatype OF
                        dfixed:
                            msg := 'fixed       ';
                        dfloat:
                            msg := 'float       ';
                        dcha:
                            msg := 'char_asc    ';
                        dchb:
                            msg := 'char_byte   ';
                        drowid:
                            msg := 'rowid       ';
                        dstra:
                            msg := 'string_asc  ';
                        dstrb:
                            msg := 'string_byte ';
                        ddate:
                            msg := 'date        ';
                        dtime:
                            msg := 'time        ';
                        dvfloat:
                            msg := 'vfloat      ';
                        dtimestamp:
                            msg := 'timestamp   ';
                        dunknown:
                            msg := 'unknown     ';
                        dnumber:
                            msg := 'number      ';
                        dnonumber:
                            msg := 'nonumber    ';
                        dduration:
                            msg := 'duration    ';
                        dlonga:
                            msg := 'long_asc    ';
                        dlongb:
                            msg := 'long_byte   ';
                        dboolean:
                            msg := 'boolean     ';
                        dunicode:
                            msg := 'unicode     ';
                        dsmallint:
                            msg := 'smallint    ';
                        dinteger:
                            msg := 'integer     ';
                        dvarchara:
                            msg := 'varchar_asc ';
                        dvarcharb:
                            msg := 'varchar_byte';
                        dstruni:
                            msg := 'string_unico';
                        dlonguni:
                            msg := 'long_unicode';
                        OTHERWISE
                            msg := 'new datatype';
                        END;
                    (*ENDCASE*) 
                    SAPDB_PascalForcedMove (sizeof(msg), sizeof(l.text),
                          @msg, 1, @l.text, datatypstart, sizeof(msg));
                    END;
                (*ENDIF*) 
                l.pos    := posstart;
                l.length := posstart+1;
                a99putint (l, ap_tree[ i ].n_pos, 5);
                END;
            (*ENDIF*) 
            l.pos    := lengthstart;
            l.length := lengthstart+1;
            a99putint (l, ap_tree[ i ].n_length, 4);
            END;
        (*ENDIF*) 
        l.pos    := lolevelstart;
        l.length := lolevelstart+1;
        a99putint (l, ap_tree[ i ].n_lo_level, 4);
        l.pos    := salevelstart;
        l.length := salevelstart+1;
        a99putint (l, ap_tree[ i ].n_sa_level, 4);
        l.pos    := balevelstart;
        l.length := balevelstart+1;
        a99putint (l, ap_tree[ i ].n_refback, 4);
        (*writeln (l.text);*)
        IF  ni_complex_predicate in ap_tree[ i ].n_special
        THEN
            l.text[ specialstart   ] := 'C';
        (*ENDIF*) 
        IF  ni_complex_string_id in ap_tree[ i ].n_special
        THEN
            l.text[ specialstart+1 ] := 'D';
        (*ENDIF*) 
        IF  ni_info_node in ap_tree[ i ].n_special
        THEN
            l.text[ specialstart+2 ] := 'I';
        (*ENDIF*) 
        IF  ni_skip_node in ap_tree[ i ].n_special
        THEN
            l.text[ specialstart+3 ] := 'S';
        (*ENDIF*) 
        IF  ni_blank_skip in ap_tree[ i ].n_special
        THEN
            l.text[ specialstart+4 ] := 'B';
        (*ENDIF*) 
        t01write_line (l.text);
        END;
    (*ENDIF*) 
    IF  (ni_skip_node in ap_tree[ i ].n_special) (* PTS 1116891 *)
    THEN
        IF  (ap_tree[ i ].n_pos = 0)
        THEN
            i := cntnodes + 1 (* break loop *)
        ELSE
            i := ap_tree[ i ].n_pos
        (*ENDIF*) 
    ELSE
        i := succ(i);
    (*ENDIF*) 
UNTIL
    i > cntnodes;
(*ENDREPEAT*) 
FOR i := 1 TO 4 DO
    la[ i ].text := a99blankline;
(*ENDFOR*) 
FOR i := 1 TO 20 DO
    vl[ i ] := ' ';
(*ENDFOR*) 
IF  cntnodes > 0
THEN
    BEGIN
    (*begin writeln ('---------');
          writeln ('nodeoutput Start. Anz. Nodes: ', cntnodes);*)
    too_wide := false;
    ak99nodeoutput (ap_tree, ap_tree[ 0 ].n_lo_level, 0, la, vl, too_wide);
    IF  too_wide
    THEN
        BEGIN
        FOR i := 1 TO 4 DO
            la[ i ].text := a99blankline;
        (*ENDFOR*) 
        FOR i := 1 TO 20 DO
            vl[ i ] := ' ';
        (*ENDFOR*) 
        ak99small_nodeoutput (ap_tree, ap_tree[ 0 ].n_lo_level, 0, la, vl);
        END;
    (*ENDIF*) 
    IF  hint_node <> csp_minint2
    THEN
        BEGIN
        FOR i := 1 TO 4 DO
            la[ i ].text := a99blankline;
        (*ENDFOR*) 
        FOR i := 1 TO 20 DO
            vl[ i ] := ' ';
        (*ENDFOR*) 
        too_wide := false;
        ak99nodeoutput (ap_tree, hint_node, 0, la, vl, too_wide);
        IF  too_wide
        THEN
            BEGIN
            FOR i := 1 TO 4 DO
                la[ i ].text := a99blankline;
            (*ENDFOR*) 
            FOR i := 1 TO 20 DO
                vl[ i ] := ' ';
            (*ENDFOR*) 
            ak99small_nodeoutput (ap_tree, hint_node, 0, la, vl);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*end*)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a99priv (
            layer    : tgg00_Debug;
            p        : tak_privilege;
            id       : tsp00_C18;
            unpacked : boolean);
 
VAR
      i : tak_priv_descriptors;
      j : tak_priv_descriptors;
      k : integer;
 
BEGIN
t01c18 (ak_sem, id);
IF  p.priv_all_set <> [  ]
THEN
    BEGIN
    t01str30 (layer, '= = = = = priv_all_set = = = =');
    a99_priv_all_set (layer, p.priv_all_set, p.priv_all_grant_set);
    END;
(*ENDIF*) 
j := priv_col_sel;
FOR i := priv_col_sel TO priv_col_ref_grant DO
    BEGIN
    IF  (i in p.priv_col_exist) OR unpacked
    THEN
        BEGIN
        IF  unpacked
        THEN
            j := i;
        (*ENDIF*) 
        CASE i OF
            priv_col_sel       :
                t01str30 (layer,'priv_col_sel                  ');
            priv_col_upd       :
                t01str30 (layer,'priv_col_upd                  ');
            priv_col_sel_grant :
                t01str30 (layer,'priv_col_sel_grant            ');
            priv_col_upd_grant :
                t01str30 (layer,'priv_upd_grant                ');
            priv_col_ref :
                t01str30 (layer,'priv_col_ref                  ');
            priv_col_ref_grant :
                t01str30 (layer,'priv_col_ref_grant            ');
            OTHERWISE
                t01int4 (layer, 'priv_col_set', ord(i));
            END;
        (*ENDCASE*) 
        FOR k := 1 TO MAX_COL_PER_TAB_GG00 DO
            IF  k in p.priv_col[ j ]
            THEN
                t01int4 (ak_sem, 'extcolno =  ', k);
            (*ENDIF*) 
        (*ENDFOR*) 
        IF  NOT unpacked AND (j < priv_col_ref_grant)
        THEN
            j := succ(j);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a99putint  (
            VAR lineinfo : tsp00_DataLine;
            integervalue : integer;
            fieldlength  : tsp00_FieldRange);
 
BEGIN
g17int4to_line (integervalue, false, fieldlength,
      lineinfo.pos, lineinfo.text);
lineinfo.pos := lineinfo.pos + fieldlength;
lineinfo.length := lineinfo.length + fieldlength;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a99put4int  (
            VAR data : tsp00_DataLine;
            i      : tsp00_Int4;
            fl     : tsp00_FieldRange);
 
BEGIN
g17int4to_line (i, false, fl, data.pos, data.text);
data.pos    := data.pos + fl;
data.length := data.length + fl;
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
