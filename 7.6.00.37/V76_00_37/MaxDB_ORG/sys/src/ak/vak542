.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-01-25
*****************************************************
modname : VAK542
changed : 2000-01-25
module  : DML_Help_Procedures
 
Author  : ElkeZ
Created : 1985-02-06
*****************************************************
 
Purpose : Module for help procedures that cannot be assigned to
          any of the DML commands
 
Define  :
 
        PROCEDURE
              a542add_intern_file (
                    VAR acv           : tak_all_command_glob;
                    VAR tableid       : tgg00_Surrogate;
                    VAR owner         : tgg00_Surrogate;
                    correlated_view   : boolean;
                    sqlmode           : tsp00_SqlMode;
                    VAR schemacontext : tgg00_Surrogate;
                    ptr               : tak_sysbufferaddress);
 
        PROCEDURE
              a542char_to_packet (
                    VAR acv : tak_all_command_glob;
                    c       : char);
 
        FUNCTION
              a542cmplex_view_stored (
                    VAR acv     : tak_all_command_glob;
                    VAR view_id : tgg00_Surrogate) : boolean;
 
        PROCEDURE
              a542copy_into_packet (
                    VAR acv    : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
        FUNCTION
              a542GetAndRemovePacket (VAR acv : tak_all_command_glob) : tsp00_MoveObjPtr;
 
        PROCEDURE
              a542InternalPacket (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    initial_len             : tsp00_Int4;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542fill_packet (
                    VAR acv  : tak_all_command_glob;
                    pos      : tsp00_Int4;
                    len      : tsp00_Int4;
                    fillchar : char);
 
        PROCEDURE
              a542move_to_packet (
                    VAR acv    : tak_all_command_glob;
                    const_addr : tsp00_MoveObjPtr;
                    const_len  : tsp00_Int4);
 
        PROCEDURE
              a542identifier_to_packet (
                    VAR acv        : tak_all_command_glob;
                    VAR identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542next_intern_sql_cmd (
                    VAR acv        : tak_all_command_glob;
                    release_packet : boolean;
                    VAR tree    : tgg00_FileId;
                    VAR key_int : tsp00_Int2);
 
        PROCEDURE
              a542change_intern_sql_cmd (
                    VAR acv  : tak_all_command_glob;
                    VAR tree : tgg00_FileId;
                    key_int  : tsp00_Int2);
 
        PROCEDURE
              a542pop_packet (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a542push_packet (
                    VAR acv : tak_all_command_glob;
                    pPacket : tsp00_MoveObjPtr);
 
        PROCEDURE
              a542release_packet (
                    VAR acv  : tak_all_command_glob;
                    segm_ptr : tsp1_segment_ptr);
 
        PROCEDURE
              a542reset_packet (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a542store_current_command (
                    VAR acv     : tak_all_command_glob;
                    VAR tree    : tgg00_FileId;
                    VAR key_int : tsp00_Int2);
 
        PROCEDURE
              a542cmd_shinfo_store (
                    VAR acv        : tak_all_command_glob;
                    VAR parsk      : tak_parskey;
                    short_info_ptr : tak_sysbufferaddress);
 
        PROCEDURE
              a542get_abapinfo (
                    VAR acv         : tak_all_command_glob;
                    VAR abapname    : tsp00_C40;
                    VAR abapnamelen : integer;
                    VAR abaplinenr  : tsp00_Number);
 
        PROCEDURE
              a542SubstituteInPacket (
                    VAR acv         : tak_all_command_glob;
                    packetPos       : integer;
                    oldLength       : integer;
                    pNewValue       : tsp00_MoveObjPtr;
                    newLength       : integer);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01nil_part_desc     : tsp1_part_header;
              a01char_size         : integer;
              a01defaultkey        : tgg00_SysInfoKey;
              a01kw                : tak_keywordtab;
 
        FUNCTION
              a01is_whitespace_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4) : boolean;
 
        FUNCTION
              a01aligned_cmd_len (len : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              a01equal_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    cmp_char : char) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05put_identifier (
                    VAR id      : tsp00_KnlIdentifier;
                    VAR moveobj : tsp00_MoveObj;
                    moveobj_size: tsp00_Int4;
                    VAR pos     : tsp00_Int4;
                    VAR retcode : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_hex_uni_error (
                    VAR acv     : tak_all_command_glob;
                    uni_err     : tsp8_uni_error;
                    err_code    : tsp00_Int4;
                    to_unicode  : boolean;
                    bytestr     : tsp00_MoveObjPtr;
                    len         : tsp00_Int4 );
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10new_packet (
                    VAR acv : tak_all_command_glob;
                    size    : tsp00_Int4;
                    VAR ptr : tsp00_MoveObjPtr);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p : tsp00_MoveObjPtr);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_copy_catalog_rec (
                    VAR acv         : tak_all_command_glob;
                    VAR old_key     : tgg00_SysInfoKey;
                    del_old_rec     : boolean;
                    VAR new_key     : tgg00_SysInfoKey;
                    new_segment_id  : tsp00_C2;
                    add_new_rec     : boolean;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_CreateGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId;
                    tempFileType   : tgg00_TfnTemp);
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        PROCEDURE
              a101_SetTempFileLevel(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    level          : tsp00_Int2(*ptocConst*));
 
        PROCEDURE
              a101_SetTempFileSublevel(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int2(*ptocConst*));
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103GetSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaId   : tgg00_Surrogate;
                    VAR schemaName : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51SwitchUser (
                    VAR acv            : tak_all_command_glob;
                    VAR new_user_name  : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cadd_record (
                    VAR t       : tgg00_TransContext;
                    VAR current : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cget_record (
                    VAR t       : tgg00_TransContext;
                    VAR current : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07crepl_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01unicode        : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf   (
                    val      : tsp00_Int4;
                    VAR dest : tsp00_Buf;
                    di       : tsp00_Int4);
 
        PROCEDURE
              s20int4_to_buf_1  (
                    val      : tsp00_Int4;
                    VAR dest : tsp00_Key;
                    di       : tsp00_Int4);
 
        PROCEDURE
              s20int4_to_buf_2  (
                    val      : tsp00_Int4;
                    VAR dest : tsp00_MoveObj;
                    di       : tsp00_Int4);
 
        FUNCTION
              s20buf_to_int4 (
                    VAR source    : tsp00_MoveObj;
                    source_pos    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              PUTSTRING-Conversions : VSP43;
 
        PROCEDURE
              s43pstr  (
                    VAR dbuf   : tsp00_Number;
                    dpos       : tsp00_Int4;
                    datalen    : integer;
                    datafrac   : integer;
                    VAR source : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    slen       : integer;
                    VAR err    : tsp00_NumError);
 
        PROCEDURE
              s43pstr1  (
                    VAR dbuf   : tsp00_Number;
                    dpos       : tsp00_Int4;
                    datalen    : integer;
                    datafrac   : integer;
                    VAR source : tsp00_C10;
                    spos       : tsp00_Int4;
                    slen       : integer;
                    VAR err    : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Version : VSP100;
 
        PROCEDURE
              sp100_GetSenderIDVersionP  (
                    VAR SenderIDP    : tsp00_C5);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (
                    level     : tgg00_Debug;
                    VAR buf   : tsp00_MoveObj;
                    pos_start : tsp00_Int4;
                    pos_end   : tsp00_Int4);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a10dispose;
 
              tak_sysbufferaddress tsp00_MoveObjPtr
 
        PROCEDURE
              s20int4_to_buf;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s20int4_to_buf_1;
 
              tsp00_MoveObj tsp00_Key
 
        PROCEDURE
              s43pstr;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s43pstr1;
 
              tsp00_MoveObj  tsp00_Number
              tsp00_MoveObj  tsp00_C10
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
 
A54_SUBQUERY: Generation of information records for
subqueries in updates and deletes, of
the updates and deletes themselves and,
if appropriate, execution of subqueries and modifications
 
.CM *-END-* specification -------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      intern_keylen     = 4;
      c_add_new_rec     = true (* a10copy_catalog_rec *);
      c_del_old_rec     = true (* a10copy_catalog_rec *);
      c_user_pos        = cgg_rec_key_offset + intern_keylen + 1;
      c_schema_pos      = c_user_pos   + SURROGATE_MXGG00;
      c_sum_pos         = c_schema_pos + SURROGATE_MXGG00;
      c_sqlmode_pos     = c_sum_pos         + 1;
      c_prepare_pos     = c_sqlmode_pos     + 1;
      c_datetime_pos    = c_prepare_pos     + 1;
      c_trunc_pos       = c_datetime_pos    + 1;
      c_cmd_or_segm_pos = c_trunc_pos       + 1;
      c_length_pos      = c_cmd_or_segm_pos + 1;
      c_cmd             =  0;
      c_segm            =  1;
      c_trans_from_uni  =  false;  (* a07_hex_uni_err *)
      c_unicode_wid     =  2;      (* a07_hex_uni_err *)
      mxak542maxpartcnt =  8;
 
TYPE
 
      tak542packet_context = RECORD
            ct_in_packet        : tsp1_packet_ptr;
            ct_cmd_segm         : tsp1_segment_ptr;
            ct_data_part        : tsp1_part_ptr;
            ct_cmd_part         : tsp1_part_ptr;
            ct_data_ptr         : tsp00_MoveObjPtr;
            ct_cmd_length       : tsp00_Int4;
            ct_data_len         : tsp00_Int4;
            ct_segment_header   : tsp1_segment_header;
            ct_packet_header    : tsp1_packet_header;
            ct_packet           : tsp1_packet;
      END;
 
      tak542packet_ct_ptr = ^tak542packet_context;
 
      tak542one_part = RECORD
            p_ptr : tsp00_MoveObjPtr;
            p_len : tsp00_Int4;
      END;
 
      tak542all_parts = ARRAY [1..mxak542maxpartcnt] OF tak542one_part;
 
 
(*------------------------------*) 
 
PROCEDURE
      a542add_intern_file (
            VAR acv           : tak_all_command_glob;
            VAR tableid       : tgg00_Surrogate;
            VAR owner         : tgg00_Surrogate;
            correlated_view   : boolean;
            sqlmode           : tsp00_SqlMode;
            VAR schemacontext : tgg00_Surrogate;
            ptr               : tak_sysbufferaddress);
 
VAR
      b_err      : tgg00_BasisError;
      get_next   : boolean;
      next_exist : boolean;
      next_outbuf: boolean;
      i2c2       : tsp_int_map_c2;
      buf_index  : integer;
      bpos       : integer;
      cnt        : integer;
      move_len   : integer;
      vpos       : integer;
      cmd_length : tsp00_Int4;
      viewtkey   : tgg00_SysInfoKey;
      buf        : ARRAY[1..2] OF tgg00_Rec;
 
BEGIN
b_err := e_ok;
IF  acv.a_max_intern_select = 0
THEN
    BEGIN
    a101_CreateGroupedTempFile(acv.a_transinf.tri_trans,
          acv.a_intern_cmd_tree,
          a101_GetExtendedTempFileType (acv, acv.a_intern_cmd_tree));
    b_err := acv.a_transinf.tri_trans.trError_gg00
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    BEGIN
    buf[1].keylen := SURROGATE_MXGG00;
    SAPDB_PascalMove ('VAK542',   1,    
          sizeof(tableid), sizeof(buf[1].buf),
          @tableid, 1, @buf[1].buf,
          cgg_rec_key_offset + 1, sizeof(tableid),
          acv.a_returncode);
    i2c2.map_int                    := acv.a_max_intern_select + 1;
    buf[1].info[SURROGATE_MXGG00 + 1] := i2c2.map_c2[ 1 ];
    buf[1].info[SURROGATE_MXGG00 + 2] := i2c2.map_c2[ 2 ];
    i2c2.map_int               := cak_is_undefined;
    buf[1].info[SURROGATE_MXGG00 + 3] := i2c2.map_c2[ 1 ];
    buf[1].info[SURROGATE_MXGG00 + 4] := i2c2.map_c2[ 2 ];
    buf[1].len := cgg_rec_key_offset + SURROGATE_MXGG00 + 4;
    buf[1].recVarcolOffset_gg00 := 0;
    buf[1].recVarcolCnt_gg00    := 0;
    b07cadd_record (acv.a_transinf.tri_trans,
          acv.a_intern_cmd_tree, buf[1]);
    b_err := acv.a_transinf.tri_trans.trError_gg00
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    BEGIN
    acv.a_max_intern_select := succ(acv.a_max_intern_select);
    viewtkey                := ptr^.syskey;
    s20int4_to_buf (acv.a_max_intern_select, buf[1].buf, cgg_rec_key_offset+1);
    s20int4_to_buf (acv.a_max_intern_select, buf[2].buf, cgg_rec_key_offset+1);
    WITH ptr^.sviewtext DO
        vpos := vtselect_pos - (vttabcount * mxak_vttabdef);
    (*ENDWITH*) 
    SAPDB_PascalMove ('VAK542',   2,    
          sizeof(owner), sizeof(buf[1].buf), @owner, 1, @buf[1].buf,
          c_user_pos, sizeof(owner),
          acv.a_returncode);
    SAPDB_PascalMove ('VAK542',   3,    
          sizeof(schemacontext), sizeof(buf[1].buf), @schemacontext, 1, @buf[1].buf,
          c_schema_pos, sizeof(schemacontext),
          acv.a_returncode);
    buf[1].buf[c_sum_pos     ]    := chr(ord(correlated_view));
    buf[1].buf[c_sqlmode_pos ]    := chr(ord(sqlmode));
    buf[1].buf[c_prepare_pos ]    := chr(ord(false));
    buf[1].buf[c_trunc_pos   ]    := chr(ord(false));
    buf[1].buf[c_cmd_or_segm_pos] := chr(c_cmd);
    bpos                          := c_length_pos + 4;
    buf[1].keylen                 := intern_keylen;
    buf[1].len                    := bpos - 1;
    buf[2].recVarcolOffset_gg00   := 0;
    buf[2].recVarcolCnt_gg00      := 0;
    get_next                      := false;
    cnt                           := 0;
    buf_index                     := 1;
    cmd_length                    := 0;
    REPEAT
        IF  get_next
        THEN
            BEGIN
            a06inc_linkage (viewtkey.slinkage);
            a10get_sysinfo (acv, viewtkey, d_release, ptr, b_err);
            vpos := 1;
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            WITH ptr^.sviewtext DO
                BEGIN
                IF  viewtkey.slinkage = cak_init_linkage
                THEN
                    (* PTS 1112472 E.Z. *)
                    IF  vtcontext MOD 10 = ord(dtf_was_ansi_now_is_same_as_iso)
                    THEN
                        buf[1].buf[c_datetime_pos] :=
                              chr(ord(dtf_iso))
                    ELSE
                        buf[1].buf[c_datetime_pos] :=
                              chr(vtcontext MOD 10);
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  vttextlength - vpos <= MAX_RECLEN_GG00 - bpos
                THEN
                    move_len := vttextlength - vpos + 1
                ELSE
                    move_len := MAX_RECLEN_GG00 - bpos + 1;
                (*ENDIF*) 
                SAPDB_PascalMove ('VAK542',   4,    
                      sizeof(vttbuf), sizeof(buf[buf_index].buf),
                      @vttbuf, vpos + (vttabcount * mxak_vttabdef),
                      @buf[buf_index].buf, bpos, move_len,
                      acv.a_returncode);
                b_err := acv.a_returncode;
                bpos       := bpos + move_len;
                vpos       := vpos + move_len;
                cmd_length := cmd_length + move_len;
                next_exist := (vpos <= vttextlength) OR
                      vtnextexist;
                buf[buf_index].len := buf[buf_index].len + move_len;
                (* PTS 1120916 E.Z. *)
                next_outbuf := false;
                IF  (b_err = e_ok)
                    AND
                    (buf_index <> 1)
                    AND
                    ((bpos > MAX_RECLEN_GG00) OR NOT (next_exist))
                THEN
                    BEGIN
                    b07cadd_record (acv.a_transinf.tri_trans,
                          acv.a_intern_cmd_tree, buf[buf_index]);
                    b_err      := acv.a_transinf.tri_trans.trError_gg00;
                    next_outbuf := true;
                    END
                ELSE
                    IF  (buf_index = 1) AND (bpos > MAX_RECLEN_GG00)
                    THEN
                        next_outbuf := true;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  next_outbuf
                THEN
                    BEGIN
                    buf_index := 2;
                    buf[2].keylen := intern_keylen + 1;
                    bpos          := cgg_rec_key_offset + buf[2].keylen + 1;
                    buf[2].len    := bpos - 1;
                    cnt           := succ(cnt);
                    buf[2].buf[ cgg_rec_key_offset + buf[2].keylen ] :=
                          chr(cnt);
                    END;
                (*ENDIF*) 
                get_next := (vtnextexist) AND (vpos > vttextlength);
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR NOT (next_exist);
    (*ENDREPEAT*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        s20int4_to_buf (cmd_length, buf[1].buf, c_length_pos);
        b07cadd_record (acv.a_transinf.tri_trans,
              acv.a_intern_cmd_tree, buf[1]);
        b_err := acv.a_transinf.tri_trans.trError_gg00
        END;
    (*ENDIF*) 
    END
ELSE
    IF  b_err = e_duplicate_key
    THEN
        b_err := e_ok;
    (*ENDIF*) 
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542char_to_packet (
            VAR acv : tak_all_command_glob;
            c : char);
 
VAR
      aux : tsp00_C1;
 
BEGIN
aux[1] := c;
a542move_to_packet (acv, @aux[1], 1)
END;
 
(*------------------------------*) 
 
FUNCTION
      a542cmplex_view_stored (
            VAR acv     : tak_all_command_glob;
            VAR view_id : tgg00_Surrogate) : boolean;
 
VAR
 
      k : RECORD
            CASE boolean OF
                true :
                    (dummy   : tsp00_Int2;
                    klen     : tsp00_Int2;
                    vcol_off : tsp00_Int2;
                    vcol_cnt : tsp00_Int2;
                    tabid    : tgg00_Surrogate);
                false :
                    (lk : tgg00_Lkey);
                END;
            (*ENDCASE*) 
 
      rec_buf : tgg00_Rec;
 
BEGIN
IF  acv.a_max_intern_select = 0
THEN
    a542cmplex_view_stored := false
ELSE
    BEGIN
    k.klen := SURROGATE_MXGG00;
    k.tabid := view_id;
    b07cget_record (acv.a_transinf.tri_trans,
          acv.a_intern_cmd_tree, k.lk, rec_buf);
    a542cmplex_view_stored :=
          acv.a_transinf.tri_trans.trError_gg00 = e_ok
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542copy_into_packet (
            VAR acv    : tak_all_command_glob;
            const_addr : tsp00_MoveObjPtr;
            const_len  : tsp00_Int4);
 
BEGIN
IF  acv.a_cmd_part^.sp1p_buf_len + const_len <=
    acv.a_cmd_part^.sp1p_buf_size
THEN
    BEGIN
    SAPDB_PascalOverlappingMove ('VAK542',   5,    
          const_len, acv.a_cmd_part^.sp1p_buf_size,
          @const_addr^, 1, @acv.a_cmd_part^.sp1p_buf,
          acv.a_cmd_part^.sp1p_buf_len + 1, const_len,
          acv.a_returncode);
    acv.a_cmd_part^.sp1p_buf_len :=
          acv.a_cmd_part^.sp1p_buf_len + const_len
    END
ELSE
    a07_b_put_error (acv, e_too_small_packet_size, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542fill_packet (
            VAR acv : tak_all_command_glob;
            pos : tsp00_Int4;
            len : tsp00_Int4;
            fillchar : char);
 
VAR
      unicode_char : tsp00_C2;
 
BEGIN
WITH acv DO
    IF  g01unicode
    THEN
        BEGIN
        unicode_char[1] := csp_unicode_mark;
        unicode_char[2] := fillchar;
        SAPDB_PascalUnicodeFill ('VAK542',   6,    
              a_cmd_part^.sp1p_buf_size, @a_cmd_part^.sp1p_buf,
              pos, len, unicode_char,
              a_returncode)
        END
    ELSE
        SAPDB_PascalFill ('VAK542',   7,    
              a_cmd_part^.sp1p_buf_size, @a_cmd_part^.sp1p_buf,
              pos, len, fillchar,
              a_returncode)
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542identifier_to_packet (
            VAR acv        : tak_all_command_glob;
            VAR identifier : tsp00_KnlIdentifier);
 
BEGIN
WITH acv, a_cmd_part^ DO
    BEGIN
    sp1p_buf_len := sp1p_buf_len + 1;
    a05put_identifier (identifier, sp1p_buf,
          sp1p_buf_size, sp1p_buf_len,
          acv.a_returncode);
    sp1p_buf_len := sp1p_buf_len - 1
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542move_to_packet (
            VAR acv    : tak_all_command_glob;
            const_addr : tsp00_MoveObjPtr;
            const_len  : tsp00_Int4);
 
VAR
      err_char_no : tsp00_Int4;
      uni_err     : tsp8_uni_error;
      curr_len    : tsp00_Int4;
 
BEGIN
WITH acv DO
    BEGIN
    IF  g01unicode
    THEN
        BEGIN
        curr_len := a_cmd_part^.sp1p_buf_size -
              a_cmd_part^.sp1p_buf_len;
        s80uni_trans (const_addr, const_len, csp_ascii,
              @a_cmd_part^.sp1p_buf[a_cmd_part^.sp1p_buf_len + 1],
              curr_len, csp_unicode, [ ],
              uni_err, err_char_no);
        IF  uni_err <> uni_ok
        THEN
            a07_hex_uni_error (acv, uni_err,
                  err_char_no, c_trans_from_uni,
                  @const_addr^[err_char_no],
                  c_unicode_wid)
        ELSE
            a_cmd_part^.sp1p_buf_len :=
                  a_cmd_part^.sp1p_buf_len + curr_len
        (*ENDIF*) 
        END
    ELSE
        IF  a_cmd_part^.sp1p_buf_len + const_len <=
            a_cmd_part^.sp1p_buf_size
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK542',   8,    
                  const_len, a_cmd_part^.sp1p_buf_size,
                  @const_addr^, 1, @a_cmd_part^.sp1p_buf,
                  a_cmd_part^.sp1p_buf_len + 1, const_len,
                  a_returncode);
            a_cmd_part^.sp1p_buf_len :=
                  a_cmd_part^.sp1p_buf_len + const_len
            END
        ELSE
            a07_b_put_error (acv, e_too_small_packet_size, 1)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542internal_packet (
            VAR acv                 : tak_all_command_glob;
            release_internal_packet : boolean;
            required_len            : tsp00_Int4);
 
BEGIN
a542InternalPacket (acv, release_internal_packet, required_len, required_len);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542InternalPacket (
            VAR acv                 : tak_all_command_glob;
            release_internal_packet : boolean;
            initial_len             : tsp00_Int4;
            required_len            : tsp00_Int4);
 
VAR
      aligned_len          : tsp00_Int4;
      intern_cmdsegm_len   : tsp00_Int4;
      init_segment_header  : tsp1_segment_header;
 
      ptr : RECORD
            CASE boolean OF
                true :
                    (ct_ptr : tak542packet_ct_ptr);
                false :
                    (moveobj_ptr : tsp00_MoveObjPtr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
&ifdef trace
t01int4 (ak_sem, 'initial_len ', initial_len);
t01int4 (ak_sem, 'required_len', required_len);
&endif
init_segment_header := acv.a_cmd_segment_header;
IF  release_internal_packet AND
    (acv.a_cmd_segment_header.sp1c_producer in
    [sp1pr_kernel, sp1pr_view_optimizer, sp1pr_queryrewrite, sp1pr_complex_view_handling])
THEN
    a542reset_packet (acv);
(*ENDIF*) 
aligned_len := a01aligned_cmd_len (initial_len);
intern_cmdsegm_len := aligned_len + sizeof (tsp1_part_header)
      + sizeof (tsp1_segment_header);
IF  acv.a_cmd_stack.cst_top < cak_max_cmd_stack
THEN
    a10new_packet (acv,
          sizeof (tak542packet_context) - sizeof (tsp00_MoveObj) +
          intern_cmdsegm_len + required_len - initial_len , ptr.moveobj_ptr)
ELSE
    ptr.moveobj_ptr := NIL;
(*ENDIF*) 
IF  ptr.moveobj_ptr <> NIL
THEN
    BEGIN
    WITH acv, ptr.ct_ptr^, a_cmd_stack DO
        BEGIN
        cst_top             := cst_top + 1;
        cst_stack[cst_top]  := ptr.moveobj_ptr;
        ct_in_packet        := a_in_packet;
        ct_cmd_segm         := a_cmd_segm;
        ct_data_part        := a_data_part;
        ct_cmd_part         := a_cmd_part;
        ct_cmd_length       := 0     (*a_cmd_part^.sp1p_buf_len*);
        ct_data_ptr         := a_data_ptr;
        ct_data_len         := a_data_length;
        ct_segment_header   := a_cmd_segment_header;
        ct_packet_header    := a_cmd_packet_header;
        a_in_packet         := @ct_packet;
        WITH a_in_packet^.sp1_header DO
            BEGIN
            IF  g01unicode
            THEN
                sp1h_mess_code := csp_unicode
            ELSE
                sp1h_mess_code := g01code.ctype;
            (*ENDIF*) 
            sp1h_no_of_segm    := 1;
            sp1h_varpart_size  := intern_cmdsegm_len + required_len - initial_len;
            sp1h_varpart_len   := sp1h_varpart_size;
            sp1h_mess_swap     := g01code.kernel_swap;
            sp100_GetSenderIDVersionP (sp1h_appl_version);
            sp1h_application   := 'INT';
            END;
        (*ENDWITH*) 
        a_cmd_packet_header := a_in_packet^.sp1_header;
        a_cmd_segm := @ct_packet.sp1_segm;
        WITH a_cmd_segm^ DO
            BEGIN
            sp1s_segm_kind          := sp1sk_cmd;
            sp1s_segm_offset        := 0;
            sp1s_segm_len           := intern_cmdsegm_len;
            sp1s_no_of_parts        := 1;
            sp1s_own_index          := cst_top;
            sp1c_mess_type          := init_segment_header.sp1c_mess_type;
            sp1c_commit_immediately := false;
            sp1c_with_info          := false;
            sp1c_sqlmode            := init_segment_header.sp1c_sqlmode;
            sp1c_producer           := sp1pr_kernel;
            sp1c_ignore_costwarning := true;
            sp1c_prepare            := false;
            sp1c_mass_cmd           := false;
            sp1c_parsing_again      := false;
            sp1c_command_options    := init_segment_header.sp1c_command_options;
            END;
        (*ENDWITH*) 
        a_cmd_segment_header         := a_cmd_segm^.sp1s_segm_header;
        a_cmd_part                   := @ct_packet.sp1_segm.sp1p_part_header;
        a_cmd_part^.sp1p_part_header := a01nil_part_desc;
        WITH a_cmd_part^.sp1p_part_header DO
            BEGIN
            sp1p_buf_len   := initial_len;
            sp1p_buf_size  := aligned_len + required_len - initial_len;
            sp1p_part_kind := sp1pk_command;
            sp1p_arg_count := 1
            END;
        (*ENDWITH*) 
        a_data_part        := NIL;
        a_data_ptr         := NIL;
        a542fill_packet (acv, 1, initial_len, bsp_c1);
        a_cmd_part^.sp1p_buf_len     := 0;
        END;
    (*ENDWITH*) 
    END
ELSE
    a07_b_put_error (acv, e_no_more_memory, 1);
(*ENDIF*) 
END;
 
(* PTS 1119568 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a542change_intern_sql_cmd (
            VAR acv  : tak_all_command_glob;
            VAR tree : tgg00_FileId;
            key_int  : tsp00_Int2);
 
VAR
      k               : tgg00_Lkey;
 
BEGIN
WITH acv, a_mblock, mb_data^ DO
    BEGIN
    a101_SetTempFileLevel (acv, a_intern_res_tree, key_int);
    s20int4_to_buf_1 (key_int, k.k, 1);
    k.len           := 4;
    b07cget_record (a_transinf.tri_trans,
          tree, k, mbp_rec);
    IF  a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  ord (mbp_buf[c_sum_pos]) <> ord(true)
        THEN
            mbp_buf[c_sum_pos] := chr(ord(true));
        (*ENDIF*) 
        b07crepl_record (a_transinf.tri_trans, tree, mbp_rec);
        END;
    (*ENDIF*) 
    IF  a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        IF  acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found
        THEN
            a07_b_put_error (acv, e_sysinfo_not_found, 1)
        ELSE
            a07_b_put_error (acv,
                  acv.a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542next_intern_sql_cmd (
            VAR acv        : tak_all_command_glob;
            release_packet : boolean;
            VAR tree       : tgg00_FileId;
            VAR key_int    : tsp00_Int2);
 
CONST
      c_exit_loop = -2;
 
VAR
      first           : boolean;
      i2c2            : tsp_int_map_c2;
      cnt             : integer;
      pos             : integer;
      cmd_or_segm     : integer;
      length          : tsp00_Int4;
      moved_length    : tsp00_Int4;
      new_user_id     : tgg00_Surrogate;
      new_schema_id   : tgg00_Surrogate;
      new_user_name   : tsp00_KnlIdentifier;
      internal        : tsp00_C18;
      k               : tgg00_Lkey;
 
      c_map_sqlmode : RECORD
            CASE boolean OF
                true :
                    (c : tsp00_C1);
                false :
                    (mode : tsp00_SqlMode);
                END;
            (*ENDCASE*) 
 
 
      c_map_dt : RECORD
            CASE boolean OF
                true :
                    (c : tsp00_C1);
                false :
                    (dt : tgg00_DateTimeFormat);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH acv, a_mblock, mb_data^ DO
    IF  a_returncode = 0
    THEN
        BEGIN
        key_int      := succ(key_int);
        i2c2.map_int := key_int;
        a101_SetTempFileLevel (acv, a_intern_res_tree, ord(i2c2.map_c2[ 1 ]));
        a101_SetTempFileSublevel (acv, a_intern_res_tree,
              ord(i2c2.map_c2[ 2 ]));
        s20int4_to_buf_1 (key_int, k.k, 1);
        k.len           := 4;
        cnt             := 0;
        first           := true;
        length          := 0;
        moved_length    := 0;
        REPEAT
            b07cget_record (a_transinf.tri_trans,
                  tree, k, mbp_rec);
            IF  a_transinf.tri_trans.trError_gg00 = e_ok
            THEN
                BEGIN
                IF  first
                THEN
                    BEGIN
                    first              := false;
                    a_corr_select      := ord (mbp_buf[c_sum_pos]) = ord(true);
                    c_map_sqlmode.c[1] := mbp_buf[c_sqlmode_pos];
                    a_sqlmode := c_map_sqlmode.mode;
&                   IFDEF TRACE
                    t01int4 (ak_sem,
                          'acv_corr_sel', ord(a_corr_select));
&                   ENDIF
                    SAPDB_PascalMove ('VAK542',   9,    
                          mb_data_size, sizeof(new_user_id),
                          @mbp_buf, c_user_pos,
                          @new_user_id, 1, sizeof (new_user_id),
                          a_returncode);
                    SAPDB_PascalMove ('VAK542',  10,    
                          mb_data_size, sizeof(new_schema_id),
                          @mbp_buf, c_schema_pos,
                          @new_schema_id, 1, sizeof (new_schema_id),
                          a_returncode);
                    cmd_or_segm := ord(mbp_buf[ c_cmd_or_segm_pos ]);
                    length := s20buf_to_int4 (mbp_buf, c_length_pos);
                    IF  cmd_or_segm = c_segm
                    THEN
                        length := length - sizeof (tsp1_segment_header) -
                              sizeof (tsp1_part_header);
                    (*ENDIF*) 
                    IF  a_returncode = 0
                    THEN
                        a542internal_packet (acv,
                              release_packet, length);
                    (*ENDIF*) 
                    IF  cmd_or_segm = c_segm
                    THEN
                        length := length + sizeof (tsp1_segment_header) +
                              sizeof (tsp1_part_header);
                    (*ENDIF*) 
                    IF  ord (mbp_buf[c_prepare_pos]) = ord(true)
                    THEN
                        BEGIN
                        a_cmd_segm^.sp1c_prepare          := true;
                        a_cmd_segment_header.sp1c_prepare := true;
                        END;
                    (*ENDIF*) 
                    c_map_dt.c[1] := mbp_buf[c_datetime_pos];
                    a_dt_format   := c_map_dt.dt;
                    pos := c_length_pos + 4
                    END
                ELSE
                    pos := cgg_rec_key_offset + mbp_keylen + 1;
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    IF  cmd_or_segm = c_cmd
                    THEN
                        BEGIN
                        SAPDB_PascalMove ('VAK542',  11,    
                              mb_data_size, acv.a_cmd_part^.sp1p_buf_size,
                              @mbp_buf, pos, @acv.a_cmd_part^.sp1p_buf,
                              a_cmd_part^.sp1p_buf_len + 1,
                              mbp_reclen - pos + 1,
                              a_returncode);
                        a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len
                              + mbp_reclen - pos + 1;
                        (* PTS 1122236 E.Z. *)
                        END
                    ELSE
                        BEGIN
                        (* complete command segment *)
                        SAPDB_PascalMove ('VAK542',  12,    
                              mb_data_size, length,
                              @mbp_buf, pos, @acv.a_cmd_segm^,
                              moved_length+1,
                              mbp_reclen - pos + 1,
                              a_returncode);
                        (* the part_size-values and segm_size-values *)
                        (* are not ok *)
                        END;
                    (*ENDIF*) 
                    (* PTS 1122236 E.Z. *)
                    k.len        := intern_keylen + 1;
                    cnt          := succ(cnt);
                    k.k[ k.len ] := chr (cnt);
                    moved_length := moved_length + mbp_reclen - pos + 1;
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found
                THEN
                    a07_b_put_error (acv, e_sysinfo_not_found, 1)
                ELSE
                    a07_b_put_error (acv,
                          acv.a_transinf.tri_trans.trError_gg00, 1);
                (*ENDIF*) 
            (*ENDIF*) 
        UNTIL
            (moved_length >= length) OR
            (a_returncode <> 0);
        (*ENDREPEAT*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            a06determine_username (acv, new_user_id, new_user_name);
            a51SwitchUser (acv, new_user_name);
            IF  new_schema_id = new_user_id
            THEN
                BEGIN
                a_curr_schema := new_user_name;
                a_curr_schema_set := false;
                END
            ELSE
                BEGIN
                a103GetSchemaName (acv, new_schema_id, a_curr_schema);
                a_curr_schema_set := true
                END;
            (*ENDIF*) 
            a_curr_schema_id  := new_schema_id;
            END;
        (*ENDIF*) 
        IF  (cmd_or_segm = c_cmd) AND (acv.a_returncode = 0)
        THEN
            BEGIN
            WHILE a01is_whitespace_char (a_cmd_part^.sp1p_buf,
                  a_cmd_part^.sp1p_buf_len - (a01char_size - 1)) DO
                a_cmd_part^.sp1p_buf_len :=
                      a_cmd_part^.sp1p_buf_len - a01char_size;
            (*ENDWHILE*) 
            (* PTS 1105418 G.G.*)
            internal := a01kw[ cak_i_internal ];
            length   := a_cmd_part^.sp1p_buf_len;
            pos      := 8 (* sizeof('INTERNAL') *);
            WHILE pos > 0 DO
                IF  a01equal_char (a_cmd_part^.sp1p_buf,
                    length - (a01char_size - 1), internal[pos])
                THEN
                    BEGIN
                    pos    := pos - 1;
                    length := length - a01char_size
                    END
                ELSE
                    pos := c_exit_loop;
                (*ENDIF*) 
            (*ENDWHILE*) 
            IF  ( pos <> c_exit_loop ) AND
                ( a01is_whitespace_char(a_cmd_part^.sp1p_buf,
                length - (a01char_size - 1) ) OR
                ( a_cmd_part^.sp1p_buf[ length ] = ')'  ) OR
                ( a_cmd_part^.sp1p_buf[ length ] = '"'  ) OR
                ( a_cmd_part^.sp1p_buf[ length ] = '''' ))
            THEN
                a_cmd_part^.sp1p_buf_len := length;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            acv.a_cmd_segment_header.sp1c_producer := sp1pr_kernel;
            acv.a_cmd_segm^.sp1c_producer := sp1pr_kernel;
            END;
        (*ENDIF*) 
&       IFDEF TRACE
        t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len);
&       ENDIF
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542pop_packet (VAR acv : tak_all_command_glob);
 
VAR
 
      ptr : RECORD
            CASE integer OF
                1 :
                    (mobj_ptr      : tsp00_MoveObjPtr);
                2 :
                    (packet_ct_ptr : tak542packet_ct_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
(* releases the internal packet of the top of the packet stack *)
(* and restores the context of the pred packet                 *)
WITH acv DO
    BEGIN
    IF  a_cmd_stack.cst_top > 0
    THEN
        BEGIN
        ptr.mobj_ptr := a_cmd_stack.cst_stack[a_cmd_stack.cst_top];
        WITH ptr.packet_ct_ptr^ DO
            BEGIN
            a_in_packet              := ct_in_packet;
            a_cmd_segm               := ct_cmd_segm;
            a_data_part              := ct_data_part;
            a_cmd_part               := ct_cmd_part;
            (* h.b. 20.09.1995 This statement produces
                  an error if we handle with UNICODE ! Why ?
                  a_cmd_part^.sp1p_buf_len := ct_cmd_length; *)
            a_data_ptr               := ct_data_ptr;
            a_data_length            := ct_data_len;
            a_cmd_segment_header     := ct_segment_header;
            a_cmd_packet_header      := ct_packet_header;
            END;
        (*ENDWITH*) 
        a10dispose (acv, ptr.mobj_ptr);
        a_cmd_stack.cst_top := a_cmd_stack.cst_top - 1
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542push_packet (
            VAR acv : tak_all_command_glob;
            pPacket : tsp00_MoveObjPtr);
 
VAR
      ct_ptr : tak542packet_ct_ptr;
 
BEGIN
WITH acv, a_cmd_stack DO
    BEGIN
    cst_top             := cst_top + 1;
    cst_stack[cst_top]  := pPacket;
    END;
(*ENDWITH*) 
ct_ptr := @pPacket^;
WITH ct_ptr^ DO
    BEGIN
    ct_in_packet        := acv.a_in_packet;
    ct_cmd_segm         := acv.a_cmd_segm;
    ct_data_part        := acv.a_data_part;
    ct_cmd_part         := acv.a_cmd_part;
    ct_cmd_length       := 0      (* acv.a_cmd_part^.sp1p_buf_len*) ;
    ct_data_ptr         := acv.a_data_ptr;
    ct_data_len         := acv.a_data_length;
    ct_segment_header   := acv.a_cmd_segment_header;
    ct_packet_header    := acv.a_cmd_packet_header;
    acv.a_in_packet     := @ct_packet;
    acv.a_cmd_segm      := @ct_packet.sp1_segm;
    acv.a_data_part     := NIL;
    acv.a_data_ptr      := NIL;
    acv.a_cmd_part      := @ct_packet.sp1_segm.sp1p_part_header
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542release_packet (
            VAR acv  : tak_all_command_glob;
            segm_ptr : tsp1_segment_ptr);
 
VAR
      ix           : integer;
      packet_index : integer;
      packet_ptr   : tsp00_MoveObjPtr;
 
      p1,p2        : RECORD
            CASE boolean OF
                true :
                    (m : tsp00_MoveObjPtr);
                false :
                    (p : tak542packet_ct_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
(* releases an internal packet without restoring the context *)
packet_index := segm_ptr^.sp1s_own_index;
IF  (packet_index <= acv.a_cmd_stack.cst_top) AND
    (acv.a_cmd_stack.cst_top > 1)             AND
    (segm_ptr^.sp1c_producer in
    [sp1pr_kernel, sp1pr_view_optimizer, sp1pr_queryrewrite, sp1pr_complex_view_handling])
THEN
    BEGIN
    packet_ptr := acv.a_cmd_stack.cst_stack[packet_index];
&   ifdef trace
    t01int4 (ak_sem, 'release pack', packet_index);
    t01moveobj (ak_sem, segm_ptr^.sp1p_buf, 1,
          segm_ptr^.sp1p_part_header.sp1p_buf_len);
&   endif
    IF  packet_index < acv.a_cmd_stack.cst_top
    THEN
        BEGIN
        p1.m                    := packet_ptr;
        p2.m                    := acv.a_cmd_stack.cst_stack[packet_index + 1];
        p2.p^.ct_in_packet      := p1.p^.ct_in_packet;
        p2.p^.ct_cmd_segm       := p1.p^.ct_cmd_segm;
        p2.p^.ct_data_part      := p1.p^.ct_data_part;
        p2.p^.ct_cmd_part       := p1.p^.ct_cmd_part;
        p2.p^.ct_cmd_length     := p1.p^.ct_cmd_length;
        p2.p^.ct_data_ptr       := p1.p^.ct_data_ptr;
        p2.p^.ct_segment_header := p1.p^.ct_segment_header;
        p2.p^.ct_packet_header  := p1.p^.ct_packet_header;
        FOR ix := packet_index + 1 TO acv.a_cmd_stack.cst_top DO
            BEGIN
            acv.a_cmd_stack.cst_stack[ix-1] :=
                  acv.a_cmd_stack.cst_stack[ix];
            p1.m  := acv.a_cmd_stack.cst_stack[ix];
            p1.p^.ct_packet.sp1_segm.sp1s_own_index := ix - 1
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    acv.a_cmd_stack.cst_top := acv.a_cmd_stack.cst_top - 1;
    a10dispose (acv, packet_ptr)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a542GetAndRemovePacket (VAR acv : tak_all_command_glob) : tsp00_MoveObjPtr;
 
VAR
 
      ptr : RECORD
            CASE integer OF
                1 :
                    (mobj_ptr      : tsp00_MoveObjPtr);
                2 :
                    (packet_ct_ptr : tak542packet_ct_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
(* return the internal packet of the top of the packet stack *)
(* and restores the context of the previous packet           *)
WITH acv DO
    BEGIN
    IF  a_cmd_stack.cst_top > 0
    THEN
        BEGIN
        ptr.mobj_ptr := a_cmd_stack.cst_stack[a_cmd_stack.cst_top];
        WITH ptr.packet_ct_ptr^ DO
            BEGIN
            a_in_packet          := ct_in_packet;
            a_cmd_segm           := ct_cmd_segm;
            a_data_part          := ct_data_part;
            a_cmd_part           := ct_cmd_part;
            a_data_ptr           := ct_data_ptr;
            a_data_length        := ct_data_len;
            a_cmd_segment_header := ct_segment_header;
            a_cmd_packet_header  := ct_packet_header;
            END;
        (*ENDWITH*) 
        a542GetAndRemovePacket := ptr.mobj_ptr;
        a_cmd_stack.cst_top    := a_cmd_stack.cst_top - 1
        END
    ELSE
        a542GetAndRemovePacket := NIL;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542reset_packet (VAR acv : tak_all_command_glob);
 
BEGIN
(* releases all internal packets and restores the context of *)
(* the initial in_packet                                     *)
WITH acv, a_cmd_stack DO
    IF  cst_top > 0
    THEN
        BEGIN
        WHILE cst_top > 1 DO
            BEGIN
            a10dispose (acv, cst_stack[cst_top]);
            cst_top := cst_top - 1
            END;
        (*ENDWHILE*) 
        a542pop_packet (acv)
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak542prepare_partlist (VAR acv : tak_all_command_glob;
            VAR all_parts    : tak542all_parts;
            VAR cmd_length   : tsp00_Int4);
 
VAR
      partno       : integer;
 
BEGIN
(* an array is filled with all parts being possible (and given in *)
(* the current statement) together with a command part (incl.) .  *)
(* the segment header is included because of cmd_store            *)
(* for all of them a pointer and the length (incl part_header) is *)
(* filled in the array                                            *)
(* together with this the full length of a segment combined by    *)
(* these parts is calculated                                      *)
WITH acv DO
    BEGIN

    (* D.T. : QueryRewrite *)
    IF (a_cmd_segm <> NIL) 
    THEN
    BEGIN
        IF ( a_cmd_segm^.sp1c_producer = sp1pr_queryrewrite )
        THEN
			a542pop_packet(acv);
    END;  

    FOR partno := 1 TO mxak542maxpartcnt DO
        all_parts[partno].p_ptr := NIL;
    (*ENDFOR*) 
    partno := 1;
    all_parts[partno].p_ptr := @a_cmd_segment_header;
    all_parts[partno].p_len := sizeof(a_cmd_segment_header);
    cmd_length := sizeof(a_cmd_segment_header);
    partno := 2;
    all_parts[partno].p_ptr := @a_cmd_part^;
    all_parts[partno].p_len := sizeof(a_cmd_part^.sp1p_part_header) +
          a01aligned_cmd_len (a_cmd_part^.sp1p_buf_len);          
    cmd_length := cmd_length + all_parts[partno].p_len;
    IF  a_rescount_part <> NIL
    THEN
        BEGIN
        partno := succ(partno);
        all_parts[partno].p_ptr := @a_rescount_part^;
        all_parts[partno].p_len :=
              sizeof(a_rescount_part^.sp1p_part_header)  +
              a01aligned_cmd_len (a_rescount_part^.sp1p_buf_len);
        cmd_length := cmd_length + all_parts[partno].p_len;
        END;
    (*ENDIF*) 
    IF  a_resname_part <> NIL
    THEN
        BEGIN
        partno := succ(partno);
        all_parts[partno].p_ptr := @a_resname_part^;
        all_parts[partno].p_len :=
              sizeof(a_resname_part^.sp1p_part_header)  +
              a01aligned_cmd_len (a_resname_part^.sp1p_buf_len);
        cmd_length := cmd_length + all_parts[partno].p_len;
        END;
    (*ENDIF*) 
    IF  a_abap_part <> NIL
    THEN
        BEGIN
        partno := succ(partno);
        all_parts[partno].p_ptr := @a_abap_part^;
        all_parts[partno].p_len :=
              sizeof(a_abap_part^.sp1p_part_header)  +
              a01aligned_cmd_len (a_abap_part^.sp1p_buf_len);
        cmd_length := cmd_length + all_parts[partno].p_len;
        END;
    (*ENDIF*) 
    IF  a_modulename_part <> NIL
    THEN
        BEGIN
        partno := succ(partno);
        all_parts[partno].p_ptr := @a_modulename_part^;
        all_parts[partno].p_len :=
              sizeof(a_modulename_part^.sp1p_part_header)  +
              a01aligned_cmd_len ( a_modulename_part^.sp1p_buf_len);
        cmd_length := cmd_length + all_parts[partno].p_len;
        END;
    (*ENDIF*) 
    IF  a_appl_param_part <> NIL
    THEN
        BEGIN
        partno := succ(partno);
        all_parts[partno].p_ptr := @a_appl_param_part^;
        all_parts[partno].p_len :=
              sizeof(a_appl_param_part^.sp1p_part_header)  +
              a01aligned_cmd_len (a_appl_param_part^.sp1p_buf_len);
        cmd_length := cmd_length + all_parts[partno].p_len;
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542cmd_shinfo_store (
            VAR acv        : tak_all_command_glob;
            VAR parsk      : tak_parskey;
            short_info_ptr : tak_sysbufferaddress);
 
VAR
      b_err        : tgg00_BasisError;
      vpos         : integer;
      move_len     : integer;
      pos_in_buf   : integer;
      now_to_move  : integer;
      cmd_length   : tsp00_Int4;
      moved_len    : tsp00_Int4;
      old_segm_len : tsp00_Int4;
      sysbuf       : tak_sysbufferaddress;
      sysk         : tgg00_SysInfoKey;
      partno       : integer;
      bufSize      : tsp00_Int4;
      this_part_len: tsp00_Int4;
      pPart        : tsp1_part_ptr;
      this_part    : tsp00_MoveObjPtr;
      all_parts    : tak542all_parts;
 
BEGIN
WITH acv DO
    IF  ( a_intern_select_cnt = a_max_intern_select )
    THEN
        BEGIN
        sysk := a01defaultkey;
        WITH sysk DO
            BEGIN
            sauthid[ 1 ] := cak_tempinfo_byte;
            SAPDB_PascalForcedMove( sizeof( parsk ), sizeof( sauthid ),
                  @parsk, 1, @sauthid, 2, mxak_parskey );
            sentrytyp := cak_eshortinfo
            END;
        (*ENDWITH*) 
        WITH short_info_ptr^ DO
            IF  sshortinfo.sicount > 0
            THEN
                BEGIN
                b_sl := sizeof( tak_shortinforecord ) - sizeof( tak_paraminfoarr ) +
                      sshortinfo.sicount * sizeof( tsp1_param_info );
                a10_copy_catalog_rec( acv, short_info_ptr^.syskey,
                      NOT c_del_old_rec, sysk, cak00_local_segment_id,
                      c_add_new_rec, b_err )
                END
            ELSE
                b_err := e_ok;
            (*ENDIF*) 
        (*ENDWITH*) 
        IF  (b_err = e_ok) AND NOT (a_parsingForSharedSql)
        THEN
            BEGIN
            ak542prepare_partlist (acv, all_parts, cmd_length);
            sysk.sentrytyp := cak_estored_cmd;
            old_segm_len := a_cmd_segment_header.sp1s_segm_len;
            a_cmd_segment_header.sp1s_segm_len := cmd_length;
&           ifdef TRACE
            t01int4( ak_sem, 'segm_len    ', a_cmd_segment_header.sp1s_segm_len );
            t01int4( ak_sem, 'buf_len     ', a_cmd_part^.sp1p_buf_len );
            t01int4( ak_sem, 'cmd_length  ', cmd_length );
&           endif
            pos_in_buf := succ(sizeof( sysbuf^.sstored_cmd.scr_buf));
            b_err := e_ok;
            partno := 1;
            this_part     := all_parts[partno].p_ptr;
            this_part_len := all_parts[partno].p_len;
            vpos           := 1;
            moved_len      := 0;
            REPEAT
                IF  pos_in_buf > sizeof( sysbuf^.sstored_cmd.scr_buf)
                THEN
                    BEGIN
                    IF  cmd_length - moved_len <=
                        sizeof( sysbuf^.sstored_cmd.scr_buf )
                    THEN
                        move_len := cmd_length - moved_len
                    ELSE
                        move_len := sizeof( sysbuf^.sstored_cmd.scr_buf );
                    (*ENDIF*) 
&                   ifdef TRACE
                    t01int4( ak_sem, 'move_len   1', move_len );
&                   endif
                    a10_nil_get_sysinfo( acv, sysk, d_release,
                          sizeof( tak_stored_cmd_record ) -
                          sizeof( sysbuf^.sstored_cmd.scr_buf ) + move_len,
                          sysbuf, b_err );
                    IF  b_err = e_ok
                    THEN
                        BEGIN
                        sysbuf^.sstored_cmd.scr_fullen    := cmd_length;
                        sysbuf^.sstored_cmd.scr_movelen   := move_len;
                        sysbuf^.sstored_cmd.scr_ddl       := a_is_ddl;
                        sysbuf^.sstored_cmd.scr_sql_mode  := a_sqlmode;
                        pos_in_buf := 1;
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  b_err = e_ok
                THEN
                    BEGIN
                    IF  this_part_len - vpos + 1 > move_len
                    THEN
                        now_to_move := move_len
                    ELSE
                        now_to_move := this_part_len - vpos + 1;
                    (*ENDIF*) 
&                   ifdef TRACE
                    t01int4( ak_sem, 'now_to_move ', now_to_move );
&                   endif
                    IF  partno = 2
                    THEN
                        BEGIN
                        pPart                := @this_part^;
                        bufSize              := pPart^.sp1p_buf_size;
                        pPart^.sp1p_buf_size := cmd_length - moved_len;
                        END;
                    (*ENDIF*) 
                    SAPDB_PascalMove('VAK542',  13,    
                          this_part_len,
                          sysbuf^.sstored_cmd.scr_movelen,
                          @this_part^, vpos, @sysbuf^.sstored_cmd.scr_buf,
                          pos_in_buf, now_to_move,
                          a_returncode );
                    IF  partno = 2
                    THEN
                        pPart^.sp1p_buf_size := bufSize;
                    (*ENDIF*) 
                    vpos       := vpos       + now_to_move;
                    move_len   := move_len   - now_to_move;
                    pos_in_buf := pos_in_buf + now_to_move;
                    moved_len  := moved_len  + now_to_move;
&                   ifdef TRACE
                    t01int4( ak_sem, 'move_len   1', move_len );
                    t01int4( ak_sem, 'moved_len  1', moved_len );
&                   endif
                    IF  this_part_len <= vpos
                    THEN
                        BEGIN
                        partno := succ(partno);
                        this_part := all_parts[partno].p_ptr;
                        IF  this_part <> NIL
                        THEN
                            BEGIN
                            this_part_len := all_parts[partno].p_len;
                            vpos := 1;
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  move_len = 0
                    THEN
                        BEGIN
                        a10add_sysinfo( acv, sysbuf, b_err );
                        IF  ( b_err = e_ok ) AND (this_part <> NIL)
                        THEN
                            a06inc_linkage( sysk.slinkage );
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            UNTIL
                ( b_err <> e_ok ) OR (this_part = NIL);
            (*ENDREPEAT*) 
            a_cmd_segment_header.sp1s_segm_len := old_segm_len;
            END;
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error( acv, b_err, 1 )
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542store_current_command (
            VAR acv     : tak_all_command_glob;
            VAR tree    : tgg00_FileId;
            VAR key_int : tsp00_Int2);
 
VAR
      bpos         : integer;
      cnt          : integer;
      move_len     : integer;
      vpos         : integer;
      partno       : integer;
      cmd_length   : tsp00_Int4;
      moved_len    : tsp00_Int4;
      old_segm_len : tsp00_Int4;
      this_part_len: tsp00_Int4;
      this_part    : tsp00_MoveObjPtr;
      all_parts    : tak542all_parts;
 
BEGIN
WITH acv, a_mblock, mb_data^ DO
    BEGIN
    (*------------ key ==> buffer --------------*)
    key_int := succ(key_int);
    s20int4_to_buf_2 (key_int, mbp_buf, cgg_rec_key_offset + 1);
    (*------------ user id ==> buffer ----------*)
    SAPDB_PascalMove ('VAK542',  14,    
          sizeof(a_curr_user_id), mb_data_size,
          @a_curr_user_id, 1, @mbp_buf,
          c_user_pos, SURROGATE_MXGG00,
          a_returncode);
    SAPDB_PascalMove ('VAK542',  15,    
          sizeof(a_curr_schema_id), mb_data_size,
          @a_curr_schema_id, 1, @mbp_buf,
          c_schema_pos, SURROGATE_MXGG00,
          a_returncode);
    (*------------ sum indicator ==> buffer ----*)
    mbp_buf[c_sum_pos] :=
          chr(ord(a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_symb = s_sum));
    (*------------ sqlmode ==> buffer ----------*)
    mbp_buf[c_sqlmode_pos ]    := chr(ord(a_sqlmode));
    mbp_buf[c_prepare_pos ]    := chr(ord(a_cmd_segment_header.sp1c_prepare));
    mbp_buf[c_datetime_pos]    := chr(ord(a_dt_format));
    mbp_buf[c_trunc_pos   ]    := chr(ord(false));
    mbp_buf[c_cmd_or_segm_pos] := chr(c_segm);
    (*------------ cmd length ==> buffer -------*)
    ak542prepare_partlist (acv, all_parts, cmd_length);
    s20int4_to_buf_2 (cmd_length, mbp_buf, c_length_pos);
    old_segm_len := a_cmd_segment_header.sp1s_segm_len;
    a_cmd_segment_header.sp1s_segm_len := cmd_length;
&   ifdef TRACE
    t01int4 (ak_sem, 'segm_len    ', a_cmd_segment_header.sp1s_segm_len);
    t01int4 (ak_sem, 'buf_len     ', a_cmd_part^.sp1p_buf_len);
    t01int4 (ak_sem, 'cmd_length  ', cmd_length);
&   endif
    partno := 1;
    this_part     := all_parts[partno].p_ptr;
    this_part_len := all_parts[partno].p_len;
    vpos          := 1;
    moved_len     := 0;
    bpos          := c_length_pos + 4;
    mbp_keylen := 4;
    mbp_reclen := bpos - 1;
    mbp_varcol_offset := 0;
    mbp_varcol_cnt    := 0;
    cnt := 0;
    acv.a_transinf.tri_trans.trError_gg00 := e_ok;
    REPEAT
        IF  this_part_len - moved_len <=
            MAX_RECLEN_GG00 - bpos
        THEN
            move_len := this_part_len - moved_len
        ELSE
            move_len := MAX_RECLEN_GG00 - bpos + 1;
        (*ENDIF*) 
&       ifdef TRACE
        t01int4 (ak_sem, 'move_len   1', move_len);
&       endif
        IF  move_len > 0
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK542',  16,    
                  this_part_len, mb_data_size,
                  @this_part^, vpos, @mbp_buf,
                  bpos, move_len,
                  a_returncode);
            vpos      := vpos      + move_len;
            bpos      := bpos      + move_len;
            moved_len := moved_len + move_len;
            END;
&       ifdef TRACE
        (*ENDIF*) 
        t01int4 (ak_sem, 'moved_len  4', moved_len);
&       endif
        mbp_reclen := bpos-1;
        IF  vpos > this_part_len
        THEN
            BEGIN
            partno := succ(partno);
            this_part := all_parts[partno].p_ptr;
            IF  this_part <> NIL
            THEN
                BEGIN
                this_part_len := all_parts[partno].p_len;
                vpos := 1;
                moved_len := 0;
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (bpos > MAX_RECLEN_GG00)
            OR
            (
            (this_part = NIL) AND
            (bpos > cgg_rec_key_offset + intern_keylen + 1 + 1)
            )
        THEN
            BEGIN
            b07cadd_record (acv.a_transinf.tri_trans, tree, mbp_rec);
            bpos       := cgg_rec_key_offset + intern_keylen + 1 + 1;
            mbp_keylen := intern_keylen + 1;
            mbp_reclen := cgg_rec_key_offset + mbp_keylen;
            cnt        := succ(cnt);
            mbp_buf[ cgg_rec_key_offset + mbp_keylen ] := chr(cnt);
            END
        (*ENDIF*) 
    UNTIL
        (acv.a_transinf.tri_trans.trError_gg00 <> e_ok) OR
        (a_returncode <> 0) OR
        (this_part = NIL);
    (*ENDREPEAT*) 
    a_cmd_segment_header.sp1s_segm_len := old_segm_len;
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END; { a542store_current_command }
 
(*------------------------------*) 
 
PROCEDURE
      a542SubstituteInPacket (
            VAR acv         : tak_all_command_glob;
            packetPos       : integer;
            oldLength       : integer;
            pNewValue       : tsp00_MoveObjPtr;
            newLength       : integer);
 
BEGIN
&ifdef trace
t01moveobj (ak_sem, acv.a_cmd_part^.sp1p_buf, packetPos, packetPos + oldLength - 1);
t01moveobj (ak_sem, pNewValue^, 1, newLength);
&endif
IF  newLength > oldLength
THEN
    SAPDB_PascalOverlappingMove ('VAK542',  17,    
          acv.a_cmd_part^.sp1p_buf_size, acv.a_cmd_part^.sp1p_buf_size,
          @acv.a_cmd_part^.sp1p_buf, packetPos + oldLength, @acv.a_cmd_part^.sp1p_buf,
          packetPos + newLength,
          acv.a_cmd_part^.sp1p_buf_len - (packetPos + oldLength) + 1,
          acv.a_returncode)
ELSE
    IF  newLength < oldLength
    THEN
        SAPDB_PascalOverlappingMove   ('VAK542',  18,    
              acv.a_cmd_part^.sp1p_buf_size, acv.a_cmd_part^.sp1p_buf_size,
              @acv.a_cmd_part^.sp1p_buf, packetPos + oldLength,
              @acv.a_cmd_part^.sp1p_buf, packetPos + newLength,
              acv.a_cmd_part^.sp1p_buf_len - (packetPos + oldLength) + 1,
              acv.a_returncode);
    (*ENDIF*) 
(*ENDIF*) 
acv.a_cmd_part^.sp1p_buf_len :=
      acv.a_cmd_part^.sp1p_buf_len + newLength -  oldLength;
SAPDB_PascalMove ('VAK542',  19,    
      acv.a_cmd_part^.sp1p_buf_size, acv.a_cmd_part^.sp1p_buf_size,
      @pNewValue^, 1, @acv.a_cmd_part^.sp1p_buf, packetPos, newLength,
      acv.a_returncode);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a542get_abapinfo (
            VAR acv         : tak_all_command_glob;
            VAR abapname    : tsp00_C40;
            VAR abapnamelen : integer;
            VAR abaplinenr  : tsp00_Number);
 
VAR
      _pos         : integer;
      _len         : integer;
      _err         : tsp00_NumError;
      _err_char_no : tsp00_Int4;
      _e           : tsp8_uni_error;
      _temp_space  : tsp00_C10;
      _uni_len     : tsp00_Int4;
 
BEGIN
abapnamelen := 0;
abaplinenr := csp_null_number;
IF  g01unicode
THEN
    SAPDB_PascalUnicodeFill('VAK542',  20,    
          sizeof(abapname), @abapname,
          1, sizeof(abapname), csp_unicode_blank,
          acv.a_returncode)
ELSE
    abapname := bsp_c40;
(*ENDIF*) 
abaplinenr := csp_minluns;
IF  acv.a_abap_part <> NIL
THEN
    WITH acv, a_abap_part^ DO
        BEGIN
        _pos := 2;
        abapnamelen := ord(sp1p_buf[1]);
        IF  abapnamelen > sizeof(abapname)
        THEN
            abapnamelen := sizeof(abapname);
        (* abap info part is always sending in ascii by the application !!! *)
        (*ENDIF*) 
        IF  g01unicode
        THEN
            BEGIN
            _len := abapnamelen;
            IF  _len > sizeof(abapname) DIV 2
            THEN
                _len := sizeof(abapname) DIV 2;
            (*ENDIF*) 
            abapnamelen := sizeof(abapname);
            s80uni_trans (@sp1p_buf[ 2 ], _len,
                  csp_ascii,
                  @abapname, abapnamelen,
                  csp_unicode, [ ], _e, _err_char_no)
            END
        ELSE
            SAPDB_PascalMove ('VAK542',  21,    
                  sp1p_buf_size, sizeof (abapname),
                  @sp1p_buf, 2, @abapname, 1, abapnamelen,
                  acv.a_returncode);
        (*ENDIF*) 
        _pos := 3 + ord(sp1p_buf[1]);
        _len := ord(sp1p_buf[_pos-1]);
        s43pstr (abaplinenr, 1, csp_fixed, csp_float_frac,
              sp1p_buf, _pos, _len, _err);
&       ifdef trace
        t01moveobj (ak_sem, sp1p_buf, 1, sp1p_buf_len);
        t01int4 (ak_sem, ' hhh pos    ', _pos);
        t01int4 (ak_sem, ' hhh len    ', _len);
        t01int4 (ak_sem, ' hhh err    ', ord(_err));
&       endif
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
