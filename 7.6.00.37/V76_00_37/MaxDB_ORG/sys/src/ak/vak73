.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK73$
.tt 2 $$$
.TT 3 $ElkeZ$Resulttable$$2000-09-26$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : Resulttable
=========
.sp
Purpose : Syntax analysis and processing of commands:
          FETCH, MFETCH, CLOSE, DESCRIBE, DROP PARSEID,
          NEXT STAMP
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a73_afetch_statement (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a73_aclose_resulttable (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a73_adescribe_resulttable (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a73_adparseid (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a73_anext_statement (
                    VAR acv      : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a73_call_semantic  (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a73_infolen_get (
                    VAR acv        : tak_all_command_glob;
                    no_of_out_cols : integer;
                    VAR output_len : tsp00_Int2);
 
        PROCEDURE
              a73_one_fetch (
                    VAR acv      : tak_all_command_glob;
                    VAR sparr    : tak_syspointerarr;
                    mtype        : tgg00_MessType2;
                    pos          : tsp00_Int4);
 
        PROCEDURE
              a73_more_fetch (
                    VAR acv      : tak_all_command_glob;
                    VAR sparr    : tak_syspointerarr;
                    mtype        : tgg00_MessType2;
                    pos          : tsp00_Int4;
                    mfetch_count : tsp00_Int4);
 
        PROCEDURE
              a73_ex_describe (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    start_fieldno : integer;
                    subquery      : boolean);
 
        PROCEDURE
              a73_close_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    VAR res_name   : tsp00_KnlIdentifier;
                    VAR modul_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a73_describe_execute (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    VAR res_name   : tsp00_KnlIdentifier;
                    VAR modul_name : tsp00_KnlIdentifier);
 
        FUNCTION
              a73_calc_unused_space (
                    VAR acv : tak_all_command_glob) : tsp00_Int4;
 
        PROCEDURE
              a73parsid_describe_semantic (VAR acv : tak_all_command_glob;
                    inclusive_output : boolean;
                    VAR infop        : tak_sysbufferaddress;
                    VAR columnnamep  : tak_sysbufferaddress);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01kw                : tak_keywordtab;
              a01sysnullkey        : tgg00_SysInfoKey;
              a01_i_rest           : tsp00_KnlIdentifier;
              a01_il_b_identifier  : tsp00_KnlIdentifier;
              a01diag_analyze_on   : boolean;
              a01diag_monitor_on   : boolean;
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_get_keyword (
                    VAR acv      : tak_all_command_glob;
                    VAR index    : integer;
                    VAR reserved : boolean);
 
        PROCEDURE
              a01_is_end_symbol (VAR acv : tak_all_command_glob);
 
        FUNCTION
              a01aligned_cmd_len (len : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              a01_eqkey (
                    VAR a      : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
        FUNCTION
              a01mandatory_keyword (
                    VAR acv          : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
        PROCEDURE
              a01_force_symbol (
                    VAR acv         : tak_all_command_glob;
                    expected_symbol : tak_sc_symbol;
                    VAR node1       : tsp00_Int2;
                    VAR node2       : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02_aresulttablename (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_l_aparameter_list (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_s_aparameterspec (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a02_atablename (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_syntax_values_tools : VAK03;
 
        PROCEDURE
              a03_anumeric_literal (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
        PROCEDURE
              a03_ainteger (
                    VAR acv            : tak_all_command_glob;
                    VAR put_node       : tsp00_Int2;
                    VAR last_node      : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05int4_get (
                    VAR acv            : tak_all_command_glob;
                    pos                : integer;
                    mfr_reclength                  : tsp00_Int2;
                    VAR int            : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061td_colinfo (
                    VAR colinfo : tak00_columninfo;
                    index : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_error (
                    VAR acv   : tak_all_command_glob;
                    errorcode : tgg00_BasisError;
                    VAR nod1  : tsp00_Int2;
                    VAR nod2  : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    mfr_b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv : tak_all_command_glob;
                    mfr_b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              AK_BD_procedure_interface : VAK09;
 
        PROCEDURE
              a09activate_lock (
                    VAR t      : tgg00_TransContext;
                    stack_addr : tgg00_StackListPtr;
                    stack_max  : tsp00_Int2;
                    VAR mfr_b_err  : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR mfr_b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR mfr_b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR mfr_b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey;
                    VAR mfr_b_err   : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_GetExecuteHandle (
                    VAR acv      : tak_all_command_glob;
                    VAR parsedId : tak_parsid;
                    CountExecuting : boolean) : tgg00_VoidPtr;
 
        PROCEDURE
              a101_ReleaseExecuteHandle (
                    VAR acv        : tak_all_command_glob;
                    VAR planHandle : tgg00_VoidPtr);
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tsp00_Int4;
 
        PROCEDURE
              a101_GetTempFileInstance(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              AK_dialog_tools : VAK260;
 
        (* PTS 1103841 *)
        PROCEDURE
              a260DropParseIds (
                    VAR acv : tak_all_command_glob;
                    VAR p : tak_parskey);
 
      ------------------------------ 
 
        FROM
              Long-Support-Getval: VAK508;
 
        PROCEDURE
              a508_lget_long_columns (
                    VAR acv             : tak_all_command_glob;
                    VAR change_rec      : tak_changerecord;
                    VAR lcol_lock       : boolean;
                    rec_cnt             : integer;
                    rec_len             : integer;
                    startpos            : integer);
 
        FUNCTION
              a508_lcol_found (
                    VAR acv        : tak_all_command_glob;
                    VAR change_rec : tak_changerecord) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52_lock_statement (
                    VAR acv    : tak_all_command_glob;
                    start_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_dml_init (
                    VAR acv   : tak_all_command_glob;
                    VAR dmli  : tak_dml_info;
                    in_union  : boolean);
 
        PROCEDURE
              a54_dml_finalize (
                    VAR dmli         : tak_dml_info;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              a54_get_pparsp_pinfop (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    mtype     : tgg00_MessType);
 
        PROCEDURE
              a54return_parsid (
                    VAR acv     : tak_all_command_glob;
                    VAR parskey : tak_parskey);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542cmd_shinfo_store (
                    VAR acv        : tak_all_command_glob;
                    VAR parsk      : tak_parskey;
                    short_info_ptr : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              diagnose monitor : VAK545;
 
        PROCEDURE
              a545diag_parse_info (
                    VAR acv        : tak_all_command_glob;
                    VAR parsid     : tak_parsid;
                    VAR sel_parsid : tak_parsid);
 
      ------------------------------ 
 
        FROM
              AK_Update : VAK57;
 
        PROCEDURE
              a57_update_statement (
                    VAR acv    : tak_all_command_glob;
                    start_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_Delete : VAK58;
 
        PROCEDURE
              a58_delete (
                    VAR acv    : tak_all_command_glob;
                    start_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Select_Syntax : VAK60;
 
        PROCEDURE
              a60_change_results (
                    VAR acv        : tak_all_command_glob;
                    VAR data       : tsp00_MoveObj;
                    VAR change_rec : tak_changerecord;
                    startpos       : integer;
                    curr_resreclen : integer);
 
        PROCEDURE
              a60_p_info_output (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr);
 
        PROCEDURE
              a60_columnnames_return (
                    VAR acv   : tak_all_command_glob;
                    pcolnamep : tak_sysbufferaddress);
 
        PROCEDURE
              a60_get_longinfobuffer (
                    VAR acv   : tak_all_command_glob;
                    VAR sparr : tak_syspointerarr;
                    col_cnt   : integer;
                    result_no : tsp00_Int4);
 
        PROCEDURE
              a60rescount (
                    VAR acv  : tak_all_command_glob;
                    rescount : tsp00_Int4);
 
        PROCEDURE
              a60_put_result (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock;
                    spos       : integer);
 
      ------------------------------ 
 
        FROM
              Select_List : VAK61;
 
        PROCEDURE
              a61_p_short_info (
                    VAR acv    : tak_all_command_glob;
                    VAR sparr  : tak_syspointerarr;
                    VAR colinf : tak00_columninfo;
                    i          : integer;
                    fix_bufpos : integer);
 
        PROCEDURE
              a61_p_long_info (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR colinf : tak00_columninfo);
 
        PROCEDURE
              a61columnnames (
                    VAR acv     : tak_all_command_glob;
                    VAR sparr   : tak_syspointerarr;
                    VAR refname : tsp00_KnlIdentifier;
                    VAR colinf  : tak00_columninfo);
 
      ------------------------------ 
 
        FROM
              Single_Select : VAK62;
 
        PROCEDURE
              a62_direct_ordered_select (
                    VAR acv    : tak_all_command_glob;
                    start_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Execute_Select_Expression : VAK660;
 
        PROCEDURE
              a660_search_one_table (
                    VAR acv        : tak_all_command_glob;
                    VAR dmli       : tak_dml_info;
                    table_node     : integer;
                    all            : boolean;
                    check_teresult : boolean;
                    lock_spec      : tak_lockenum;
                    wanted_priv    : tak00_PrivR);
 
        PROCEDURE
              a660_new_pparsp (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    needs_twuseold : boolean;
                    complicate     : boolean);
 
        PROCEDURE
              a660_prefix_delete (
                    VAR acv       : tak_all_command_glob;
                    VAR parsk     : tak_parskey;
                    VAR del_cnt   : integer;
                    prefix_length : integer);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        PROCEDURE
              a663_drop_parsid (
                    VAR acv     : tak_all_command_glob;
                    VAR p       : tak_parsid;
                    VAR del_cnt : integer);
 
        PROCEDURE
              a663_del_result (
                    VAR acv          : tak_all_command_glob;
                    VAR resname_rec  : tak_resname_record;
                    do_cdel          : boolean;
                    del_resname_rec  : boolean);
 
        PROCEDURE
              a663get_result_records (
                    VAR acv    : tak_all_command_glob;
                    dstate     : tak_directory_state;
                    resid      : tsp00_Int4;
                    VAR pbasep : tak_sysbufferaddress;
                    VAR ok     : boolean);
 
        PROCEDURE
              a663_get_result_info (
                    VAR acv          : tak_all_command_glob;
                    VAR resname      : tsp00_KnlIdentifier;
                    VAR modul_name   : tsp00_KnlIdentifier;
                    VAR resname_addr : tak_sysbufferaddress;
                    make_new_res     : boolean;
                    ftemptype        : tgg00_TfnTemp;
                    dstate           : tak_directory_state;
                    VAR f_ok         : boolean);
 
        PROCEDURE
              a663pid_restable_get (
                    VAR acv        : tak_all_command_glob;
                    VAR pars_key   : tak_parskey;
                    dstate         : tak_directory_state;
                    VAR sparr      : tak_syspointerarr);
 
        PROCEDURE
              a663restable_get (
                    VAR acv    : tak_all_command_glob;
                    dstate     : tak_directory_state;
                    VAR tablen : tsp00_KnlIdentifier;
                    VAR sparr  : tak_syspointerarr;
                    VAR ok     : boolean);
 
        PROCEDURE
              a663_resname (
                    VAR acv          : tak_all_command_glob;
                    VAR res_name     : tsp00_KnlIdentifier;
                    VAR modul_name   : tsp00_KnlIdentifier;
                    VAR resname_addr : tak_sysbufferaddress;
                    dstate           : tak_directory_state;
                    errorpos         : integer);
 
      ------------------------------ 
 
        FROM
              Fetch_Without_Resulttable : VAK74;
 
        PROCEDURE
              a74_search_fetch (
                    VAR acv        : tak_all_command_glob;
                    VAR sparr      : tak_syspointerarr;
                    mtype          : tgg00_MessType2;
                    pos            : tsp00_Int4;
                    VAR resnamerec : tak_sysbufferaddress;
                    single_fetch   : boolean;
                    mfetch_count   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92_add_pcount (
                    VAR acv  : tak_all_command_glob;
                    pcount   : tsp00_C3;
                    parskind : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cget_record (
                    VAR t    : tgg00_TransContext;
                    VAR curr : tgg00_FileId;
                    VAR rk   : tgg00_Lkey;
                    VAR b    : tgg00_Rec);
 
        PROCEDURE
              b07cnext_record (
                    VAR t          : tgg00_TransContext;
                    VAR curr       : tgg00_FileId;
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tsp00_MoveObj);
 
        PROCEDURE
              b07cprev_record (
                    VAR t           : tgg00_TransContext;
                    VAR act_tree_id : tgg00_FileId;
                    VAR rk          : tgg00_Lkey;
                    VAR set_result  : tgg00_BdSetResultRecord;
                    VAR tree_pos    : tgg00_FilePos;
                    VAR b           : tsp00_MoveObj);
 
      ------------------------------ 
 
        FROM
              task_temp_data_cache : VBD21;
 
        PROCEDURE
              b21mp_rows_fetched_put (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    rows_fetched : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code               : tgg04_CodeGlobals;
              g01diag_moni_parse_on : boolean;
              g01unicode            : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill  (
                    mod_id         : tsp00_C6;
                    mod_intern_num : tsp00_Int4;
                    source_upb     : tsp00_Int4;
                    source         : tsp00_MoveObjPtr;
                    source_pos     : tsp00_Int4;
                    length         : tsp00_Int4;
                    fill_char      : char;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove   (
                    mod_id          : tsp00_C6;
                    mod_intern_num  : tsp00_Int4;
                    source_upb      : tsp00_Int4;
                    destin_upb      : tsp00_Int4;
                    source          : tsp00_MoveObjPtr;
                    source_pos      : tsp00_Int4;
                    destin          : tsp00_MoveObjPtr;
                    destin_pos      : tsp00_Int4;
                    length          : tsp00_Int4;
                    VAR e           : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size     : tsp00_Int4;
                    m        : tsp00_MoveObjPtr;
                    pos      : tsp00_Int4;
                    len      : tsp00_Int4;
                    fillchar : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove  (
                    size1    : tsp00_Int4;
                    size2    : tsp00_Int4;
                    val1     : tsp00_MoveObjPtr;
                    p1       : tsp00_Int4;
                    val2     : tsp00_MoveObjPtr;
                    p2       : tsp00_Int4;
                    mfr_cnt  : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id          : tsp00_C6;
                    mod_intern_num  : tsp00_Int4;
                    source_upb      : tsp00_Int4;
                    destin_upb      : tsp00_Int4;
                    source          : tsp00_MoveObjPtr;
                    source_pos      : tsp00_Int4;
                    destin          : tsp00_MoveObjPtr;
                    destin_pos      : tsp00_Int4;
                    length          : tsp00_Int4;
                    VAR e           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (
                    val        : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tak_res_keysbuf;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
 
      ------------------------------ 
 
        FROM
              Packet_handling: VSP26;
 
        PROCEDURE
              s26find_part (
                    VAR segm         : tsp1_segment;
                    part_kind        : tsp1_part_kind;
                    VAR part_ptr     : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30eq (
                    VAR a : tsp00_C4;
                    VAR b : tsp00_MoveObj;
                    bi    : tsp00_Int4;
                    mfr_cnt   : tsp00_Int4) : boolean;
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41p4int (
                    VAR buf : tsp00_ResNum;
                    pos     : tsp00_Int4;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01messtype (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    mess_type    : tgg00_MessType);
 
        PROCEDURE
              t01basis_error (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01mess2type (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    mess2_type    : tgg00_MessType2);
 
        PROCEDURE
              t01int4 (
                    level : tgg00_Debug;
                    nam : tsp00_Sname;
                    int : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01lidentifier (
                    level      : tgg00_Debug;
                    identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01buf  (
                    level     : tgg00_Debug;
                    VAR buf   : tak_resname_record;
                    pos_start : integer;
                    pos_end   : integer);
 
        PROCEDURE
              t01buf1 (
                    level : tgg00_Debug;
                    VAR b : tak_colnamesbuf;
                    start : integer;
                    stop  : integer);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              GET-Conversions: VSP40;
 
        PROCEDURE
              s40glint (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tak_res_keysbuf
 
        PROCEDURE
              s30eq;
 
              tsp00_MoveObj tsp00_C4
 
        PROCEDURE
              s41p4int;
 
              tsp00_MoveObj tsp00_ResNum
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tak_resname_record
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tak_colnamesbuf
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tak_colnamesbuf
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1985-01-22
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-09-26
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
A73_AFETCH_STATEMENT
.sp
The syntax of a FETCH or MFETCH command is analyzed. Whether it is a FETCH
command or an MFETCH is given to this procedure by the parameter ind.
.br;With regard to the specification of POS, a parameter or an integer is
allowed in brackets, nothing else.
.br;If neither FIRST, nor LAST, nor NEXT, PREV, SAME, POS has been specified,
the default is: NEXT.
.br;The result-set name may have been specified or the FETCH may refer to the
unnamed result set.
.br;If only parsing is to be performed, the specification of an INTO clause is
necessary (transfer of values to a program); otherwise optional. In this case,
however, warning 3 is given.
.sp 2;A73_ACLOSE_RESULTTABLE
.sp
The key word CLOSE is followed only, if applicable, by the result-set name.
.sp 2;A73_ADESCRIBE_RESULTTABLE
.sp
The key word DESCRIBE is followed only, if applicable, by the name of the
result set whose result fields are to be described as long infos.
.sp 2;A73_ADPARSEID
.sp
The parse id of the command DROP PARSEID is in part2 of the SQL_PACKET.
The command is used by the precompiler if it is known that a specific parse id
will no longer be used in future.
.sp 2;A73_CALL_SEMANTIC
.sp
This procedure is the distributor for all AK73 commands.
.sp 2;CLOSE_SEMANTIC
.sp
If it exists, the result-set name is fetched from the SQL_PACKET and the
procedure A73_CLOSE_EXECUTE is called.
.sp 2;A73_CLOSE_EXECUTE
.sp
This procedure is called by CLOSE_SEMANTIC and also by VAK50 (execution of
commands only).
.br;For the unnamed result set and the SHOW result set, it is possible to check
directly in the array resnamearr, in which the result sets are recorded,
whether the result set is known or not (cntbuf = -1).
.br;In the case of named result sets, a search must be made for the specified
name by A66_RESNAME_SEARCH.
.br;If the result set exists, it is deleted by means of A66_DEL_RESULT and its
system information is removed. The entry in the array is, if applicable, set
only to CLOSED, while the name itself must continue to be known.
.br;If the CLOSE is only executed, the parse id of the associated SELECT is
given to the user (precompiler) in order to give him the opportunity to delete
his corresponding MFETCH buffer. Otherwise, assignment would be impossible.
.br;If the command is only to be parsed, parse information containing the
result-set name is stored, and a parse id is returned to the user.
.sp 2;DESCRIBE_SEMANTIC
.sp
The result-set name, if specified, is fetched from the SQL_PACKERT and
A73_DESCRIBE_EXECUTE is called.
.sp 2;A73_DESCRIBE_EXECUTE
.sp
This procedure is called by DESCRIBE_SEMANTIC as well as from VAK50 if the
DESCRIBE is only to be executed.
.br;For the unnamed result set and the SHOW result set, it is possible to check
directly in the array resnamearr, in which the result sets are recorded,
whether the result set is known or not (cntbuf = -1).
.br;In the case of named result sets, a search must be made for the specified
name by A66_RESNAME_SEARCH.
.br;If the result set exists, the description is made with the aid of
A73_EX_DESCRIBE.
.br;If the command is only to be parsed, parse information containing the
result-set name is stored, and a parse id is returned to the user.
.sp 2;A73_EX_DESCRIBE
.sp
This procedure is called by A73_DESCRIBE_EXECUTE as well as, in the case of
subqueries, from VAK62 and VAK66. In the last two cases, the resultcount
already has an entry in it and must be saved prior to overwriting.
.br;The position of the result set in the result-set description array is known
from atpos_result.
.br;If the SELECT has been executed with the message type m_adbsinfo or
m_adbsinfocommit, the long infos that were created during SELECT-execution will
exist in the form of system information. This is indicated by their number (1
or 2 (more than 166 output fields) or 0 (non-existent)).
.br;If there are no long-info buffers that could be simply moved to the
SQL_PACKET by GET_LONGINFO, the system information for the result set must be
fetched and processed.
.br;Space is made in the cache for long-info buffers (A60_GET_LONGINFOBUFFER).
The base system-information records for the result set are fetched by
A60_RESTABLE_GET. In a loop, a long info is built from the field description
for the fields starting at start_fieldno (= 1 if called from VAK62 (Ordered
Select), otherwise = 2 because of the implicitly inserted SYSKEY) and is put in
the long-info buffers (A61_P_LONG_INFO).
.br;These buffers are put in the SQL_PACKET by A60_P_INFO_OUTPUT.
.br;If it is a subquery for which the long infos were not able to be created in
the normal way, they must now be stored. Otherwise, the temporary long-info
buffers are deleted.
.sp 2;DROP_PARSEID
.sp
The parse id (6 bytes in part2 of the SQL_PACKET) is fetched from the
SQL_PACKET and all associated parse information is deleted by
A66_PREFIX_DELETE.
.br;In the case of parsed SELECTs, the base system-information records are
stored not only under the parse id, but also under the result-set name, so
that, for following commands (FETCH <resulttablename>), this result-set name
and the fields contained in the set are known. This base system information
must be deleted (drop_eresult) if the SELECT has not been executed.
.sp 2;FETCH_SEMANTIC
.sp
It is determined whether there is a FETCH or an MFETCH and whether a search is
to be made for the first, next or last records.
.br;The information as to how many records are to be searched for in MFETCH is
in the form of int2 in the first 2 bytes of part2 of the SQL_PACKET,
byte-swapped if necessary.
.br;If mtype = mm_direct (specification 'POS [  ]'), it is also necessary to
determine the value for the position, either directly from the command
(unsigned_integer) or in the form of a number (18,0) from part2 of the
SQL_PACKET behind the 2 bytes of the Mfetch number, if applicable.
.br;If it exists, the result-set name is read. It is checked whether 'FETCH
REST' has been specified. In this case, it is only necessary to move the
result to the SQL_PACKET. This result
was previously (during SELECT- or FETCH-execution) stored in the Mess-Buffer,
for which there was no longer any space in the SQL_PACKET in the Ordered
Select, SELECT INTO or FETCH, because the long infos were very long (> 4KB).
.br;A73_RESNAME determines the position in the result-set array at which the
description of the specified set is located. If applicable, the error
unknown_resultname is output.
.br;Only if the SELECT has already been called with the message type m_adbsinfo
or m_adbsinfocommit (infobuf > 0) do the associated long-info buffers exist and
can, if requested (info_output), be moved to the SQL_PACKET by means of
GET_LONGINFO.
.br;The system-information record in which it is recorded how far inside the
result set fetching has already been performed is fetched, as well as, if
applicable, the record in which the keys of the base tables can be stored for
SELECTs on a Join View with specification of FOR UPDATE.
.br;The number of INTO parameters of the FETCH is counted and is compared with
the number of output fields of the SELECT (res_outcolno). If applicable,
warning 3 is output. Only as many fields are output as there are output
parameters, but no more than there are SELECT output fields.
.br;If the FETCH/MFETCH command is only to be parsed, 2 buffers are created for
the internal information on the parameters and for the information on the
parameters that is to be given to the user. The information that is to be given
to the user (short infos) is built in that a run is made in a loop through the
base system information for the result set and in that, for each field (except
the first one, which contains the syskey), short information is built from the
field description by means of A61_P_SHORT_INFO.
.br;If more INTO parameters have been specified than output fields were
specified in the SELECT, sicount is > i. (Sicount is given in GET_PPARSP_PINFOP
the value of count_variab, a variable in the ACV, which is increased by 1 for
each parameter in the syntax analysis ] These excess short infos are given the
entry chr(0) in order to show the precompiler that there are no longer any data
for them.
.br;The short infos are moved to the SQL_PACKET and are byte-swapped and
code-converted by A04_INFO_BYTESWAP_CODETYPE. The temporary sysinfo record is
deleted.
.br;
The internal parameter information is so far empty (no input parameters).
Therefore, the parse id of the SELECT is put into the first parameter
information record, so that, when the FETCH is executed, it can be checked
whether the FETCH matches the last-executed SELECT with the specified result-
set name.
.br;The parse information is stored; the parse id is moved to the
SQL_PACKET.
.sp 2;If the FETCH/MFETCH is to be executed, this is done in VAK73 (result set
built) or in VAK74 (result set not built).
.sp 2;GET_LONGINFO
.sp
In this procedure, the 1 or 2 long-info buffers that were created in SELECT are
fetched and are put into the SQL_PACKET (in the case of FETCH/MFETCH and
message type m_adbsinfo or m_adbsinfocommit). The buffers are byte-swapped and
code-converted by A04_INFO_BYTESWAP_CODETYPE.
.sp 2;FETCH_REST
.sp
The result, stored intermediately in the Mess-Buffer, for which there was no
longer any space in the request segment in SELECT or FETCH because of
excessively long long-infos is now transferred to the SQL_PACKET.
.sp 2;A73_RESNAME
.sp
A search is made in the array of result-set descriptions for the result-set
name and the position in the array is output. If the result set does not exist
(cntbuf -1) or if the SELECT has not been executed, but the FETCH is now to be
executed, there is the error unknown_resultname.
.sp 2;A73_ONE_FETCH
.sp
The system-information record in which it is recorded how far in the result set
fetching has already been performed is used.
.br;If the search is to be 'direct' (specification of 'POS [  ]), it is
determined whether the position is not greater than the number of results found
in the result set. If it is still an allowable position, a distinction is made
as to whether the x-th record can be accessed directly (NOT res_order, i.e. the
key of the result records consists only of 4 bytes, which contain a counter
ascending without gap from 1) or not.
.br;If accessing cannot be performed directly, an attempt is made from the
current position or from another known position (first result record) to get to
the desired record with as little record accessing as possible. This is done in
ONE_BEFORE_POS. Then, the desired record can be fetched directly or with only
one NEXT access.
.sp 2;If the search is not to be direct, the desired record is fetched from
Zerokey or Fullkey or from the current key value.
.sp 2;In all this record accessing, BD is gone to directly (without involvement
of KB05) and the current-information (rootno etc ] of the result set is used.
.br;The keys and counters that describe the current position (res_next/prev. ]
are updated so that they can be used for further searches. next... and prev...
are there because, in MFETCH, the first and the last result records found are
recorded.
.br;If it was a SELECT with 'FOR UPDATE' (res_length=length of the output
desired by the user < length of a result record (the primary keys of the base
tables are also in there)), the keys are transferred to the extra sysinfo
record for Join View keys or to the normal record, which also contains the
other information required for FETCH. RES_USEUPDK specifies whether it is then
possible for a ... CURRENT OF to be performed with this result-set name or not.
.br;A60_PUT_RESULT
takes the result from the Mess-Buffer to the SQL_PACKET (if there is still
space for it there in addition to the long infos).
.sp 2;A73_MORE_FETCH
.sp
The system-information record in which it is recorded how far in the result set
fetching has already been performed is used.
.br;It is determined how many of the desired results can be accommodated in the
request segment together with the info part. At least one result is fetched
and, if necessary, stored intermediately in the Mess-Buffer, so that it can be
fetched with FETCH REST.
.br;If the search is to be 'direct' (specification of 'POS [  ]), it is
determined whether the position is not greater than the number of results found
in the result set. If it is still an allowable position, a distinction is made
as to whether the x-th record can be accessed directly (NOT res_order, i.e. the
key of the result records consists only of 4 bytes, which contain a counter
ascending without gap from 1) or not. Since, in MFETCH, searching is performed
with 'NEXT' also in the case of a direct search, the position is used decreased
by one.
.br;If the record cannot be accessed directly, an attempt is made from the
current position or from another known position (first result record) to get to
the desired record with as little record accessing as possible. This is done in
ONE_BEFORE_POS. Then, the desired record can be fetched directly or with only
one NEXT access. Since, in MFETCH, searching is performed with 'NEXT' also in
the case of a direct search, the key is set to the next-smaller value.
.sp 2;If a direct search is not to be performed, the desired records are fetched
from Zerokey or Fullkey or from the actual key value.
.sp 2;In all this record accessing, BD is gone to directly (without involvement
of KB05) and the current-information [rootno etc ] of the result set is used.
.br;In a loop, as many results are fetched as the user requested or as can be
accommodated in the SQL_PACKET in addition to the info part. For this
purpose, BD is called. It has to SAPDB_PascalForcedFill a buffer with as many result records
as requested or fewer, if there are not enough result records any more.
.br;The first key found is transferred to res_prevkeys, so that it is available
for following FETCH PREVs, and a corresponding entry is made in the position.
.br;The results are code-converted by means of A60_CHANGE_RESULTS and
they are moved to the SQL_PACKET or are prepared for
FETCH REST.
.br;For the next BD request, the value of the last key found is entered in the
start key.
.sp 2;There is this loop for Next and for Prev. The difference consists not only
in the fact that, instead of b07CNEXT_RECORD, b07CPREV_RECORD is called and,
accordingly, not nextkey but prevkey is used, but also in the storing of the
results in the SQL_PACKET. Also for Prev (e.g. MFETCH LAST), the result
record with the smallest key is on the extreme left in the SQL_PACKET,
with the result that the SQL_PACKET is filled from right to left. If fewer
results are found than requested, it is, of course, necessary for the filled
part of part2 of the SQL_PACKET to be pulled up directly to part1.
.br;The number of records found is entered as int2 in the first two bytes of
part2 of the SQL_PACKET (byte-swapped).
.sp 2;ONE_BEFORE_POS
.sp
This procedure is called in order, if POS [  ] is specified, to get as quickly
as possible to the record with the preceding position, since, in this case, the
FETCH is to be performed with NEXT.
.br;It is checked which position (NEXTPOS or PREVPOS (different according to
MFETCH) or the start position 0) is closest to the desired position.
.br;From this start position, the position that is one before the desired
result is reached by several CNEXT-RECORD or
CPREV_RECORD requests, which each fetch several results from the result set.
After each CNEXT or CPREV request, the key of the last record found is fetched
from the buffer in order to act as the start key for the next request.
.sp 2;UNSIGNED_INT4_GET
.sp
This procedure is called if POS (<unsigned_integer>) has been specified. At
most, the specification of an int4 is allowable.
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_in_union        = true (* a54_dml_init *);
      c_make_new_res    = true (* a663_get_result_info *);
      c_all             = true (* a660_search_one_table *);
      c_check_teresult  = true (* a660_search_one_table *);
      c_needs_twuseold  = true (* a660_new_pparsp *);
      c_complicate      = true (* a660_new_pparsp *);
      c_do_cdel         = true (* a663_del_result *);
      c_del_resname_rec = true (* a663_del_result *);
      c_subquery        = true (* a73_ex_describe *);
      c_inclusive_output= true (* a73parsid_describe_semantic *);
      c_rescount_len61  = 11   (* mxsp_resnum for pre 6.2 *);
 
TYPE
 
      mfetchrec = RECORD
            mfr_count1     : integer;
            mfr_count2     : integer;
            mfr_cnt        : integer;
            mfr_reclength  : tsp00_Int2;
            mfr_b_err      : tgg00_BasisError
      END;
 
 
 
(*------------------------------*) 
 
PROCEDURE
      ak73close_semantic (VAR acv : tak_all_command_glob);
 
VAR
      curr_n   : integer;
      res_name : tsp00_KnlIdentifier;
      sparr    : tak_syspointerarr;
 
BEGIN
WITH acv, a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
    BEGIN
    curr_n   := 1;
    res_name := a01_il_b_identifier;
    IF  n_sa_level <> 0
    THEN
        BEGIN
        curr_n := n_sa_level;
        IF  a_ap_tree^[curr_n].n_symb = s_identifier
        THEN
            a05identifier_get (acv,
                  curr_n, sizeof (res_name), res_name);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a73_close_execute (acv, sparr, res_name, a_modul_name)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak73describe_semantic (VAR acv : tak_all_command_glob);
 
VAR
      curr_n   : integer;
      res_name : tsp00_KnlIdentifier;
      sparr    : tak_syspointerarr;
 
BEGIN
WITH acv, a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
    BEGIN
    curr_n   := 1;
    res_name := a01_il_b_identifier;
    IF  n_sa_level <> 0
    THEN
        BEGIN
        curr_n := n_sa_level;
        IF  a_ap_tree^[curr_n].n_symb = s_identifier
        THEN
            a05identifier_get (acv,
                  curr_n, sizeof (res_name), res_name);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a73_describe_execute (acv, sparr, res_name, a_modul_name)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73parsid_describe_semantic (VAR acv : tak_all_command_glob;
            inclusive_output : boolean;
            VAR infop        : tak_sysbufferaddress;
            VAR columnnamep  : tak_sysbufferaddress);
 
VAR
      i           : integer;
      col_ptr     : tak00_colinfo_ptr;
      dmli        : tak_dml_info;
      lparskey    : tak_parskey;
      parsedId    : tak_parsid;
 
BEGIN
(* describes a result table of a select, that has been parsed   *)
(* but not necessarily executed. The result table is identified *)
(* by the corresponding parsid in data_part !                   *)
WITH acv, dmli DO
    BEGIN
    a54_dml_init (acv, dmli, NOT c_in_union);
    lparskey := a_pars_last_key;
    IF  a_data_ptr <> NIL
    THEN
        BEGIN
        SAPDB_PascalMove ('VAK73 ',   1,    
              a_data_part^.sp1p_buf_size, sizeof (lparskey),
              @a_data_ptr^, 5, @lparskey, 1,
              sizeof (lparskey),
              a_returncode);
        IF  lparskey.p_kind = m_sharedSQLParseid
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK73 ',   2,    
                  acv.a_data_part^.sp1p_buf_size, sizeof(parsedId),
                  @a_data_ptr^, 1, @parsedId, 1, sizeof(parsedId),
                  acv.a_returncode);
            IF  acv.a_returncode = 0
            THEN
                acv.a_planHandle := a101_GetExecuteHandle (acv, parsedId, false);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        a663pid_restable_get (acv, lparskey, d_fix, d_sparr);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        d_keylen  := -cgg_rec_key_offset;
        a60_get_longinfobuffer (acv, d_sparr,
              d_sparr.pbasep^.sresult.boutcolno - 1, -1);
        END;
    (*ENDIF*) 
    i := 2;
    IF  a_returncode = 0
    THEN
        WHILE (i <= d_sparr.pbasep^.sresult.boutcolno) AND
              (a_returncode = 0) DO
            BEGIN
            a06extcolno (d_sparr.pbasep^.sbase, i, col_ptr);
            d_inoutpos := col_ptr^.ccolstack.epos;
            a61_p_long_info (acv, dmli, col_ptr^);
            i := i + 1
            END;
        (*ENDWHILE*) 
    (*ENDIF*) 
    IF  inclusive_output
    THEN
        BEGIN
        a60_p_info_output (acv, d_sparr);
        IF  d_sparr.pinfop <> NIL
        THEN
            BEGIN
            a10_key_del (acv, d_sparr.pinfop^.syskey);
&           ifdef trace
            d_sparr.pinfop := NIL;
&           endif
            a_shortinfo_key := cgg_zero_id;
            END;
        (*ENDIF*) 
        IF  d_sparr.pcolnamep <> NIL
        THEN
            BEGIN
            a10_key_del (acv, d_sparr.pcolnamep^.syskey);
&           ifdef trace
            d_sparr.pcolnamep := NIL
&                 endif
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        infop := dmli.d_sparr.pinfop;
        columnnamep  := dmli.d_sparr.pcolnamep;
        END;
    (*ENDIF*) 
    ;
    a54_dml_finalize( dmli, acv.a_transinf.tri_trans );
    END;
(*ENDWITH*) 
IF  acv.a_planHandle <> NIL
THEN
    a101_ReleaseExecuteHandle (acv, acv.a_planHandle);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak73drop_parseid (VAR acv : tak_all_command_glob);
 
VAR
      p       : tak_parsid;
      del_cnt : integer;
      pcount  : integer;
      i       : integer;
      err     : tsp00_Int2;
      errpos  : integer;
      move_err: boolean;
 
BEGIN
WITH acv DO
    BEGIN
&   IFDEF TRACE
    t01int4 (ak_sem, 'a_data_lengt', a_data_length);
&   ENDIF
    err      := 0;
    errpos   := 1;
    move_err := false;
    IF  (a_ex_kind <> parsing_executing) AND
        (a_data_part^.sp1p_part_kind <> sp1pk_parsid)
    THEN
        a07_b_put_error (acv, e_invalid_command, 1)
    ELSE
        BEGIN
        (* BEGIN PTS 1107060 U.J. *)
        IF  a_data_part^.sp1p_arg_count < 1
        THEN
            pcount := 1
        ELSE
            pcount := a_data_part^.sp1p_arg_count;
        (*ENDIF*) 
        IF  a_data_length <> (mxak_parsid * pcount)
        THEN
            a07_b_put_error (acv, e_invalid_datalength, a_data_length)
        ELSE
            BEGIN
            i := 0;
            WHILE ((i < pcount) AND (move_err = false)) DO
                BEGIN
                IF  NOT s30eq (a_transinf.tri_trans.trSessionId_gg00.ci4_gg00,
                    a_data_ptr^, (i * mxak_parsid) + 1, mxsp_c4)
                THEN
                    BEGIN
                    move_err := true;
                    a07_b_put_error (acv, e_unknown_parseid, 1);
                    END
                ELSE
                    BEGIN
                    (* PTS 1114128 E.Z. *)
                    SAPDB_PascalMove ('VAK73 ',   3,    
                          a_data_part^.sp1p_buf_size, sizeof(p),
                          @a_data_ptr^, (i * mxak_parsid) + 1,
                          @p, 1, sizeof(p),
                          a_returncode);
                    IF  p.pid_parsk.p_kind <> m_destroy_temp
                    THEN
                        BEGIN
                        IF  a_returncode <> 0
                        THEN
                            BEGIN
                            move_err := true;
                            i := pcount; (* Jump to end of FOR... *)
                            err := a_returncode;
                            errpos := a_errorpos;
                            END
                        ELSE
                            BEGIN
                            (* PTS 1103841 *)
                            IF  (p.pid_appl_info[1] = chr(csp1_p_dialog_call)) AND
                                (p.pid_parsk.p_kind = m_delete)
                            THEN (* drop parseid of sql statements of internal stored procedure *)
                                a260DropParseIds (acv, p.pid_parsk);
                            (*ENDIF*) 
                            IF  a_returncode = 0
                            THEN
                                (* PTS 1114071 E.Z. *)
                                a663_drop_parsid (acv, p, del_cnt);
                            (* PTS 1109291 E.Z. *)
                            (*ENDIF*) 
                            IF  (a_returncode = 0) AND (del_cnt > 0)
                            THEN
                                a92_add_pcount (acv, p.pid_parsk.p_count,
                                      p.pid_parsk.p_kind);
                            (*ENDIF*) 
                            IF  a_returncode <> 0
                            THEN
                                BEGIN
                                IF  err = 0
                                THEN
                                    BEGIN
                                    err := a_returncode;
                                    errpos := pcount + 1;
                                    END;
                                (*ENDIF*) 
                                a_returncode := 0;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        a92_add_pcount (acv, p.pid_parsk.p_count,
                              p.pid_parsk.p_kind);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                i := i + 1;
                END;
            (*ENDWHILE*) 
            IF  (err <> 0) AND (move_err = false)
            THEN
                BEGIN
                a_returncode := err;
                a_errorpos   := errpos;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        (* END PTS 1107060 U.J. *)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak73rest_fetch (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv, a_mblock DO
    BEGIN
    a06retpart_move (acv, @mb_data^.mbp_buf, mb_data_len );
    IF  a_returncode = 0
    THEN
        BEGIN
        a06finish_curr_retpart (acv, sp1pk_data, 1);
        IF  a01diag_monitor_on OR a01diag_analyze_on
        THEN
            b21mp_rows_fetched_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak73fetch_semantic (VAR acv : tak_all_command_glob);
 
VAR
      _b_err           : tgg00_BasisError;
      _multi_command   : integer;
      _start_node      : tsp00_Int2;
      _first_resname_n : tsp00_Int2;
      _pos_resname_n   : tsp00_Int2;
      _curr_n          : tsp00_Int2;
      _del_cnt         : integer;
      _sparr           : tak_syspointerarr;
      _sysk            : tgg00_SysInfoKey;
      _parsk           : tak_parskey;
      _new_res_name    : tsp00_KnlIdentifier;
      _res_name        : tsp00_KnlIdentifier;
 
BEGIN
_start_node := acv.a_ap_tree^[ 0 ].n_lo_level;
IF  ( acv.a_ap_tree^[ _start_node ].n_sa_level > 0 )
THEN
    BEGIN
    _multi_command := 1;
    acv.a_ex_kind := only_parsing;
    acv.a_command_kind := subquery_command
    END
ELSE
    _multi_command := 0;
(*ENDIF*) 
_first_resname_n := 0;
_pos_resname_n   := 0;
WHILE ( _start_node > 0 ) AND ( acv.a_returncode = 0 ) DO
    BEGIN
    IF  ( acv.a_ap_tree^[ _start_node ].n_proc = a73 )
    THEN
        BEGIN
        ak73one_semantic_fetch (acv, _sparr,
              _start_node, _pos_resname_n, _multi_command);
        IF  ( _multi_command > 0 )
        THEN
            BEGIN
            IF  ( _first_resname_n = 0 )
            THEN
                BEGIN
                _first_resname_n := _pos_resname_n;
                _curr_n          := _first_resname_n
                END
            ELSE
                BEGIN
                acv.a_ap_tree^[ _curr_n ].n_sa_level := _pos_resname_n;
                _curr_n := acv.a_ap_tree^[ _curr_n ].n_sa_level
                END;
            (*ENDIF*) 
            IF  ( acv.a_returncode = 0 ) AND
                ( _pos_resname_n > 0 )
            THEN
                BEGIN
                a05identifier_get (acv, _pos_resname_n,
                      sizeof(_new_res_name), _new_res_name);
                _curr_n := _first_resname_n;
                WHILE _curr_n <> _pos_resname_n DO
                    BEGIN
                    a05identifier_get (acv, _curr_n,
                          sizeof(_res_name), _res_name);
                    IF  ( _res_name = _new_res_name )
                    THEN
                        BEGIN
                        a07_nb_put_error (acv, e_current_of_needs_fetch,
                              acv.a_ap_tree^[ _pos_resname_n ].n_pos, _res_name);
                        _curr_n := _pos_resname_n
                        END
                    ELSE
                        _curr_n := acv.a_ap_tree^[ _curr_n ].n_sa_level
                    (*ENDIF*) 
                    END
                (*ENDWHILE*) 
                END;
            (*ENDIF*) 
            IF  ( acv.a_returncode <> 0 )
            THEN
                BEGIN
                _parsk           := acv.a_pars_last_key;
                _parsk.p_id[ 1 ] := acv.a_first_parskey;
                _parsk.p_kind    := m_complex;
                _parsk.p_no      := 0;
                a660_prefix_delete (acv, _parsk, _del_cnt, cak_complete_prefix)
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        _sysk := _sparr.pinfop^.syskey;
        a10add_sysinfo (acv, _sparr.pinfop, _b_err);
        IF  _b_err <> e_ok
        THEN
            a07_b_put_error (acv, _b_err, 1)
        ELSE
            BEGIN
            CASE acv.a_ap_tree^[ _start_node ].n_proc OF
                a52 :
                    a52_lock_statement (acv, _start_node);
                a57 :
                    a57_update_statement (acv, _start_node);
                a58 :
                    a58_delete (acv, _start_node);
                a62 :
                    a62_direct_ordered_select (acv, _start_node);
                OTHERWISE
                    a07_b_put_error (acv, e_not_implemented, _start_node);
                END;
            (*ENDCASE*) 
            a10del_sysinfo (acv, _sysk, _b_err);
            IF  _b_err <> e_ok
            THEN
                a07_b_put_error (acv, _b_err, 1)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    _multi_command := succ(_multi_command);
    _start_node := acv.a_ap_tree^[ _start_node ].n_sa_level;
    IF  ( _start_node > 0 )
    THEN
        WITH acv.a_ap_tree^[ _start_node ] DO
            IF  (n_proc = a63) AND
                (* PTS 1117747 E.Z. *)
                (
                (n_subproc = cak_x_subquery)         OR
                (n_subproc = cak_x_one_val_subquery) OR
                (n_subproc = cak_x_corr_subquery   ) OR
                (n_subproc = cak_x_one_val_corr_sub)
                )
            THEN
                _start_node := 0;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak73one_semantic_fetch (
            VAR acv       : tak_all_command_glob;
            VAR sparr     : tak_syspointerarr;
            start_node    : tsp00_Int2;
            VAR resn_node : tsp00_Int2;
            multi_command : integer);
 
VAR
      _b_err            : tgg00_BasisError;
      _deleted          : boolean;
      _f_ok             : boolean;
      _mfetch           : boolean;
      _pos_is_parameter : boolean;
      _is_relative_pos  : boolean;
      _drop_columninfo  : boolean;
      _mfetch_count     : tsp00_Int4;
      _position_node    : tsp00_Int2;
      _curr_n           : integer;
      _param_cnt        : integer;
      _k                : integer;
      _merror           : integer;
      _mreturn          : integer;
      _output_len       : integer;
      _output_params    : integer;
      _resnpos          : integer;
      _mfetch_count2    : tsp00_Int4;
      _args             : tsp00_Int2;
      _count1           : tsp00_Int4;
      _mtype            : tgg00_MessType2;
      _res_name         : tsp00_KnlIdentifier;
      _col_ptr          : tak00_colinfo_ptr;
      _resname_addr     : tak_sysbufferaddress;
      _ke               : tgg00_SysInfoKey;
      _isparr           : tak_syspointerarr;
      _fetch_parsid     : tak_parsid;
      _select_parsid    : tak_parsid;
      _res              : tsp00_NumError;
      _part_ptr         : tsp1_part_ptr;
      _relative_pos     : tsp00_ResNum;
      _refname          : tsp00_KnlIdentifier;
 
BEGIN
_f_ok := false;
WITH acv.a_ap_tree^[ start_node ] DO
    BEGIN
    (* PTS 1111576 E.Z. *)
    IF  n_subproc = cak_x_fetch
    THEN
        _mfetch := false
    ELSE
        _mfetch := true;
    (*ENDIF*) 
    _curr_n := n_lo_level;
    END;
(*ENDWITH*) 
WITH acv.a_ap_tree^[ _curr_n ] DO
    BEGIN
    CASE n_subproc OF
        cak_x_first :
            _mtype := mm_first;
        cak_x_next :
            _mtype := mm_next;
        cak_x_last :
            _mtype := mm_last;
        cak_x_prev :
            _mtype := mm_prev;
        cak_x_pos :
            _mtype := mm_direct;
        cak_x_same :
            _mtype := mm_same;
        cak_x_relative :
            _mtype := mm_search;
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
IF  ( NOT _mfetch )
THEN
    BEGIN
    _mfetch_count  := 1;
    _mfetch_count2 := 1
    END
ELSE
    BEGIN
    IF  ( acv.a_ex_kind = only_parsing )
    THEN
        _mfetch_count := 1
    ELSE
        IF  ( acv.a_rescount_part = NIL )
        THEN
            a07_b_put_error (acv, e_too_short_datapart, 1)
        ELSE
            IF  (acv.a_rescount_part^.sp1p_buf_len < mxsp_resnum)
            THEN
                a07_b_put_error (acv, e_too_short_datapart, 1)
            ELSE
                BEGIN
                s40glint (acv.a_rescount_part^.sp1p_buf, 2, 10,
                      _mfetch_count, _res);
                IF  ( _res <> num_ok ) OR
                    ( acv.a_rescount_part^.sp1p_buf [ 1 ] <> csp_defined_byte )
                THEN
                    a07_b_put_error (acv, e_too_short_datapart, 1)
                ELSE
                    IF  _mfetch_count > MAX_INT2_SP00
                    THEN
                        _mfetch_count := MAX_INT2_SP00;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
_count1 := -1;
_is_relative_pos := false;
_pos_is_parameter := false;
_position_node := 0;
&ifdef trace
t01mess2type( ak_sem, '_mtype      ', _mtype );
&endif
IF  ( _mtype = mm_direct ) OR ( _mtype = mm_search )
THEN
    BEGIN
    WITH acv.a_ap_tree^[ acv.a_ap_tree^[_curr_n].n_lo_level ] DO
        IF  (n_symb = s_unsigned_integer) OR
            (n_symb = s_minus) OR
            (n_symb = s_plus)
        THEN
            BEGIN
            a05int4_get (acv, n_pos, n_length, _count1);
            IF  (_mtype = mm_search) AND
                (acv.a_returncode = 0)
            THEN
                BEGIN
                IF  _count1 = 0
                THEN
                    _mtype := mm_same
                ELSE
                    IF  _count1 = 1
                    THEN
                        _mtype := mm_next;
                    (*ENDIF*) 
                (*ENDIF*) 
                _relative_pos [1] := csp_defined_byte;
                s41p4int (_relative_pos, 2, _count1, _res);
                _is_relative_pos := true;
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            (* position will be given as parameter. *)
            _position_node := acv.a_ap_tree^[_curr_n].n_lo_level;
            _pos_is_parameter := true
            END
        (*ENDIF*) 
    (*ENDWITH*) 
    END;
(*ENDIF*) 
_res_name := a01_il_b_identifier;
_resnpos  := 1;
IF  ( acv.a_ap_tree^[ _curr_n ].n_sa_level <> 0 )
THEN
    BEGIN
    _curr_n := acv.a_ap_tree^[ _curr_n ].n_sa_level;
    WITH acv.a_ap_tree^[ _curr_n ] DO
        IF  n_symb = s_identifier
        THEN
            BEGIN
            a05identifier_get (acv, _curr_n,
                  sizeof(_res_name), _res_name);
            _resnpos := n_pos;
            IF  _mtype = mm_direct
            THEN
                resn_node := _curr_n
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDWITH*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    IF  _res_name = a01_i_rest
    THEN
        ak73rest_fetch (acv)
    ELSE
        BEGIN
        a663_resname (acv, _res_name, acv.a_modul_name, _resname_addr, d_fix, 1);
        IF  ( acv.a_returncode = 0 )
        THEN
            BEGIN
            IF  _res_name <> a01_il_b_identifier
            THEN
                IF  acv.a_ap_tree^[ _curr_n ].n_sa_level <> 0
                THEN
                    _curr_n := acv.a_ap_tree^[ _curr_n ].n_sa_level;
                (*ENDIF*) 
            (*ENDIF*) 
            WITH _resname_addr^.sresname DO
                IF  (acv.a_info_output AND
                    (resinfobuf > 0) AND
                    (acv.a_ex_kind <> only_parsing) AND
                    (_resname_addr^.sresname.resselect_fetch <>
                    sft_select_all_results))
                THEN
                    ak73get_longinfo (acv, sparr,
                          a101_GetTempFileIndex (acv, restreeid));
                (*ENDIF*) 
            (*ENDWITH*) 
            IF  ( _resname_addr^.sresname.resselect_fetch =
                sft_select_all_results )
            THEN
                IF  ( _mtype = mm_direct )
                THEN
                    a07_b_put_error (acv, e_unknown_resultname,
                          acv.a_ap_tree^[ _curr_n ].n_pos);
                (*ENDIF*) 
            (*ENDIF*) 
            IF  ( acv.a_returncode = 0 )
            THEN
                BEGIN
                _output_params := 0;
                _param_cnt := 0;
                _ke := a01sysnullkey;
                WITH _ke, _resname_addr^.sresname DO
                    BEGIN
                    IF  (NOT resexecuted) AND
                        (reseparsk.p_kind <> m_show)
                    THEN
                        BEGIN
                        sauthid[ 1 ] := cak_tempinfo_byte;
                        SAPDB_PascalForcedMove (sizeof(reseparsk), sizeof(sauthid),
                              @reseparsk, 1, @sauthid, 2, mxak_parskey);
                        sauthid[ mxak_parskey+1 ] := chr(0);
                        END
                    ELSE
                        stempid := a101_GetTempFileIndex (acv, restreeid);
                    (*ENDIF*) 
                    sentrytyp := cak_ereskey;
                    END;
                (*ENDWITH*) 
&               IFDEF TRACE
                t01int4 (ak_sem, 'curr_n      ', _curr_n);
&               ENDIF
                IF  ((acv.a_ap_tree^[ _curr_n ].n_proc = a73) AND
                    ( acv.a_ap_tree^[ _curr_n ].n_subproc = cak_x_params) AND
                    (acv.a_returncode = 0))
                THEN
                    BEGIN
                    _curr_n := acv.a_ap_tree^[ _curr_n ].n_lo_level;
&                   ifdef LONGREC
                    _param_cnt := 2;
                    acv.a_count_variab := succ(acv.a_count_variab);
&                   else
                    _param_cnt := 1;
&                   endif
&                   IFDEF TRACE
                    t01int4 (ak_sem, 'curr_n      ', _curr_n);
&                   ENDIF
                    WHILE acv.a_ap_tree^[ _curr_n ].n_sa_level <> 0 DO
                        BEGIN
                        _param_cnt := succ(_param_cnt);
&                       IFDEF TRACE
                        t01int4 (ak_sem, 'count output', _param_cnt);
&                       ENDIF
                        _curr_n := acv.a_ap_tree^[ _curr_n ].n_sa_level
                        END;
                    (*ENDWHILE*) 
                    _output_params := _param_cnt
                    END;
                (*ENDIF*) 
                IF  ( multi_command = 0 )
                THEN
                    BEGIN
                    IF  (acv.a_ex_kind <> only_parsing) AND
                        (_mtype <> mm_next)             AND
                        NOT _resname_addr^.sresname.resscrollable
                    THEN
                        a07_b_put_error (acv, e_scrolling_fetch_not_allowed, 1)
                    ELSE
                        IF  (_resname_addr^.sresname.resselect_fetch <>
                            sft_select_all_results)
                        THEN
                            BEGIN
                            a10get_sysinfo (acv, _ke, d_fix, sparr.px[ 2 ], _b_err);
                            IF  ( _b_err <> e_ok )
                            THEN
                                a07_b_put_error (acv, _b_err, 1)
                            ELSE
                                WITH sparr.px[ 2 ]^.sreskey DO
                                    IF  res_outcolno <> _output_params
                                    THEN
                                        BEGIN
                                        WITH acv.a_transinf.tri_trans DO
                                            trWarning_gg00 := trWarning_gg00 + [ warn0_exist,
                                                  warn3_output_not_into_columns ];
                                        (*ENDWITH*) 
                                        IF  (res_outcolno < _output_params) OR
                                            (_output_params = 0)
                                        THEN
                                            _output_params := res_outcolno;
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                (*ENDWITH*) 
                            (*ENDIF*) 
                            END
                        (* PTS 1102254 E.Z. *)
                        ELSE
                            IF  acv.a_ex_kind <> only_parsing
                            THEN
                                a07_b_put_error (acv,
                                      e_row_not_found, 1);
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  ( acv.a_returncode = 0 )
                THEN
                    IF  ( acv.a_ex_kind = only_parsing )
                    THEN
                        BEGIN
                        IF  ( multi_command = 0 )
                        THEN
                            BEGIN
                            IF  ( _param_cnt = 0 )
                            THEN
                                acv.a_count_variab := acv.a_count_variab+_output_params;
                            (*ENDIF*) 
                            IF  ( _mfetch )
                            THEN
                                BEGIN
                                a54_get_pparsp_pinfop (acv, sparr, m_mfetch);
                                acv.a_precomp_info_byte := csp1_p_mfetch_found
                                END
                            ELSE
                                BEGIN
                                a54_get_pparsp_pinfop (acv, sparr, m_fetch);
                                acv.a_precomp_info_byte := csp1_p_fetch_found
                                END;
                            (*ENDIF*) 
                            IF  _resname_addr^.sresname.resselect_fetch = sft_select_all_results
                            THEN
                                acv.a_count_variab := 0;
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  multi_command = 1
                            THEN
                                a54_get_pparsp_pinfop (acv, sparr, m_fetch)
                            ELSE
                                a660_new_pparsp (acv, sparr,
                                      NOT c_needs_twuseold, c_complicate);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        _output_len := -1;
                        IF  acv.a_returncode = 0
                        THEN
                            BEGIN
                            IF  _pos_is_parameter
                            THEN
                                BEGIN
                                _k := acv.a_ap_tree^[ _position_node ].n_length;
                                WITH sparr.pinfop^.sshortinfo, siinfo[ _k ] DO
                                    BEGIN
                                    sp1i_mode       := [ sp1ot_mandatory ];
                                    sp1i_io_type    := sp1io_input;
                                    sp1i_data_type  := dfixed;
                                    sp1i_frac       := 0;
                                    sp1i_length     := csp_resnum_deflen;
                                    sp1i_in_out_len := mxsp_resnum;
                                    IF  acv.a_variable_input
                                    THEN
                                        BEGIN
                                        sp1i_param_no  := _k;
                                        sp1i_read_only := false;
                                        sp1i_serial    := false;
                                        END
                                    ELSE
                                        sp1i_bufpos   := acv.a_input_data_pos;
                                    (*ENDIF*) 
                                    IF  _k > sicount
                                    THEN
                                        sicount := _k;
                                    (*ENDIF*) 
                                    END
                                (*ENDWITH*) 
                                END;
                            (*ENDIF*) 
                            IF  (_resname_addr^.sresname.resselect_fetch <>
                                sft_select_all_results)
                            THEN
                                a663restable_get (acv, d_release,
                                      _resname_addr^.sresname.reskey_name,
                                      _isparr, _f_ok)
                            ELSE
                                BEGIN
                                (* PTS 1000479 E.Z. *)
                                _output_len := -_output_params;
                                _f_ok := true
                                END;
                            (*ENDIF*) 
                            IF  _f_ok
                            THEN
                                BEGIN
                                IF  multi_command = 0
                                THEN
                                    BEGIN
                                    acv.a_output_data_pos := 1;
                                    IF  (_resname_addr^.sresname.resselect_fetch <>
                                        sft_select_all_results)
                                    THEN
                                        BEGIN
&                                       ifdef trace
                                        WITH _isparr.pbasep^.sbase DO
                                            t01int4 (ak_sem, 'bfirstcolind',
                                                  bfirstcolind);
                                        (*ENDWITH*) 
&                                       endif
                                        _col_ptr := a103GetColumn (_isparr.pbasep^.sbase, _isparr.pbasep^.sbase.bfirstcolind);
                                        IF  
                                            (
                                            (acv.a_comp_type = at_xci) OR
                                            (acv.a_comp_type = at_db_manager) OR
                                            (acv.a_comp_type = at_odbc)
                                            )                      AND
                                            (acv.a_ex_kind = only_parsing) AND
                                            (_resname_addr^.sresname.resselect_fetch <>
                                            sft_select_all_results)
                                        THEN
                                            BEGIN
                                            WITH _resname_addr^.sresname DO
                                                BEGIN
                                                _drop_columninfo := true;
                                                a60_get_longinfobuffer (acv, sparr,
                                                      _output_params,
                                                      a101_GetTempFileIndex (
                                                      acv, restreeid));
                                                _refname      := a01_il_b_identifier;
                                                _ke           := a01sysnullkey;
                                                _ke.stempid   :=
                                                      a101_GetTempFileIndex (
                                                      acv, restreeid);
                                                _ke.sentrytyp := cak_ecolnames;
                                                IF  acv.a_returncode = a071_return_code
                                                    (e_duplicate_sysinfo, acv.a_sqlmode)
                                                THEN
                                                    BEGIN
                                                    acv.a_returncode := 0;
                                                    a10get_sysinfo (acv, _ke, d_fix, sparr.pcolnamep, _b_err);
                                                    _drop_columninfo := false;
                                                    END
                                                (*ENDIF*) 
                                                END;
                                            (*ENDWITH*) 
                                            END;
                                        (*ENDIF*) 
                                        IF  acv.a_returncode = 0
                                        THEN
                                            BEGIN
                                            FOR _k := 2 TO _output_params+1 DO
                                                BEGIN
&                                               ifdef trace
                                                a061td_colinfo (_col_ptr^, 1);
&                                               endif
                                                _col_ptr := a103GetColumn (_isparr.pbasep^.sbase,
                                                      _col_ptr^.cnextind);
                                                acv.a_output_data_pos := _col_ptr^.
                                                      ccolstack.epos;
                                                IF  _pos_is_parameter
                                                THEN
                                                    a61_p_short_info (acv, sparr,
                                                       _col_ptr^, _k, 0)
                                                ELSE
                                                    a61_p_short_info (acv, sparr,
                                                       _col_ptr^, _k-1, 0);
                                                (*ENDIF*) 
                                                IF  
                                                    (
                                                    (acv.a_comp_type = at_xci) OR
                                                    (acv.a_comp_type = at_db_manager) OR
                                                    (acv.a_comp_type = at_odbc)
                                                    )                      AND
                                                    (acv.a_ex_kind = only_parsing) AND
                                                    (_resname_addr^.sresname.resselect_fetch <>
                                                    sft_select_all_results) AND
                                                    _drop_columninfo
                                                THEN
                                                    a61columnnames (acv, sparr, _refname, _col_ptr^);
                                                (*ENDIF*) 
                                                END;
                                            (*ENDFOR*) 
                                            IF  acv.a_returncode = 0
                                            THEN
                                                WITH _col_ptr^ DO
                                                    _output_len :=
                                                       ccolstack.epos + cinoutlen - 1;
                                                (*ENDWITH*) 
                                            (*ENDIF*) 
                                            IF  _pos_is_parameter
                                            THEN
                                                _output_params := succ(_output_params);
                                            (*ENDIF*) 
                                            WITH sparr.pinfop^.sshortinfo DO
                                                FOR _k := _output_params + 1 TO sicount DO
                                                    siinfo[ _k ].sp1i_data_type := dunknown;
                                                (*ENDFOR*) 
                                            (*ENDWITH*) 
                                            END
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                    _fetch_parsid.pid_session :=
                                          acv.a_transinf.tri_trans.trSessionId_gg00;
                                    _fetch_parsid.pid_parsk   := acv.a_pars_last_key;
                                    _fetch_parsid.pid_appl_info[1]  :=
                                          chr(acv.a_precomp_info_byte);
                                    _fetch_parsid.pid_dtime_info[1] :=
                                          chr(ord(dtf_none));
                                    END;
                                (*ENDIF*) 
                                IF  acv.a_returncode = 0
                                THEN
                                    BEGIN
                                    _select_parsid.pid_session :=
                                          acv.a_transinf.tri_trans.trSessionId_gg00;
                                    WITH  _resname_addr^.sresname DO
                                        IF  reseparsk.p_kind <> m_nil
                                        THEN
                                            BEGIN
                                            _select_parsid.pid_parsk :=
                                                  reseparsk;
                                            _select_parsid.pid_appl_info[1] :=
                                                  chr(resparsinfobyte);
                                            _select_parsid.pid_dtime_info[1] :=
                                                  chr(ord(resdatetimeformat));
                                            END
                                        ELSE
                                            SAPDB_PascalForcedFill (sizeof(_select_parsid),
                                                  @_select_parsid, 1,
                                                  sizeof (_select_parsid),
                                                  chr(0));
                                        (*ENDIF*) 
                                    (*ENDWITH*) 
                                    IF  multi_command = 0
                                    THEN
                                        BEGIN
                                        IF  acv.a_cmd_segment_header.sp1c_prepare
                                        THEN
                                            a542cmd_shinfo_store (acv,
                                                  acv.a_pars_last_key, sparr.pinfop);
                                        (*ENDIF*) 
                                        IF  g01diag_moni_parse_on
                                        THEN
                                            BEGIN
                                            IF  _select_parsid.pid_session.ci4_gg00 =
                                                cgg_zero_c4
                                            THEN
                                                _select_parsid.pid_session.ci4_gg00 :=
                                                      cgg_nil_session;
                                            (*ENDIF*) 
                                            a545diag_parse_info (acv,
                                                  _fetch_parsid, _select_parsid);
                                            IF  _select_parsid.pid_session.ci4_gg00 =
                                                cgg_nil_session
                                            THEN
                                                _select_parsid.pid_session.ci4_gg00:=
                                                      cgg_zero_c4;
                                            (*ENDIF*) 
                                            END;
                                        (*ENDIF*) 
                                        IF  
                                            (
                                            (acv.a_comp_type = at_xci) OR
                                            (acv.a_comp_type = at_db_manager) OR
                                            (acv.a_comp_type = at_odbc)
                                            )                      AND
                                            (acv.a_returncode = 0) AND
                                            (acv.a_ex_kind = only_parsing) AND
                                            (_resname_addr^.sresname.resselect_fetch <>
                                            sft_select_all_results)
                                        THEN
                                            BEGIN
                                            a60_columnnames_return (acv, sparr.pcolnamep);
                                            IF  _drop_columninfo
                                            THEN
                                                a10del_sysinfo (acv, _ke, _b_err)
                                            ELSE
                                                a10rel_sysinfo (sparr.pcolnamep)
                                            (*ENDIF*) 
                                            END;
                                        (*ENDIF*) 
                                        IF  a01diag_analyze_on
                                        THEN
                                            WITH  _resname_addr^.sresname DO
                                                BEGIN
&                                               ifdef trace
                                                t01buf (ak_sem, _resname_addr^.sresname,
                                                      1, sizeof(tak_resname_record));
&                                               endif
                                                END;
                                            (*ENDWITH*) 
                                        (*ENDIF*) 
                                        WITH sparr.pinfop^, sshortinfo DO
                                            BEGIN
                                            a06retpart_move (acv,
                                                  @sshortinfo.siinfo,
                                                  sicount * sizeof(tsp1_param_info));
                                            _args := sicount;
                                            a10_key_del (acv, syskey);
&                                           ifdef trace
                                            sparr.pinfop := NIL;
&                                           endif
                                            acv.a_shortinfo_key := cgg_zero_id;
                                            IF  acv.a_returncode = 0
                                            THEN
                                                a06finish_curr_retpart (acv,
                                                      sp1pk_shortinfo, _args);
                                            (*ENDIF*) 
                                            END
                                        (*ENDWITH*) 
                                        END
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  acv.a_returncode = 0
                        THEN
                            WITH sparr DO
                                BEGIN
                                WITH pparsp^.sparsinfo DO
                                    BEGIN
                                    p_select     := false;
                                    p_resn       := _res_name;
                                    p_modul_name := acv.a_modul_name;
                                    IF  _mfetch
                                    THEN
                                        BEGIN
                                        p_mtyp := m_mfetch;
                                        (* PTS 1111576 E.Z. *)
                                        p_reuse := false
                                        END
                                    ELSE
                                        p_mtyp := m_fetch;
                                    (*ENDIF*) 
                                    p_mtyp2 := _mtype;
                                    p_session_isolevel := acv.a_iso_level;
                                    p_use_sess_isolevel:= false;
                                    IF  _pos_is_parameter
                                    THEN
                                        p_posno := csp_maxint2
                                    ELSE
                                        p_posno := _count1;
                                    (*ENDIF*) 
                                    IF  acv.a_variable_input
                                    THEN
                                        IF  _pos_is_parameter
                                        THEN
                                            p_p_no := acv.a_ap_tree^[ _position_node ].n_length
                                        ELSE
                                            p_p_no := 0
                                        (*ENDIF*) 
                                    ELSE
                                        p_p_no := acv.a_input_data_pos;
                                    (*ENDIF*) 
                                    acv.a_input_data_pos :=
                                          acv.a_input_data_pos + mxsp_resnum;
                                    p_prepare := false;
                                    p_resinfolen := _output_len;
                                    (* length of described output    *)
                                    (* with more_fetch not more than *)
                                    (* _output_len bytes may be given *)
                                    (* to the user !!                *)
                                    SAPDB_PascalForcedMove (sizeof(_select_parsid),
                                          sizeof(p_pars_infos[1]),
                                          @_select_parsid, 1,
                                          @p_pars_infos[ 1 ],
                                          1, sizeof(_select_parsid));
                                    END;
                                (*ENDWITH*) 
                                pparsp^.b_sl := mxak_pars_header +
                                      cak_sysbufferoffset +
                                      mxak_parsid;
                                pparsp^.sparsinfo.p_fullen := pparsp^.b_sl;
                                pparsp^.b_kl := mxak_standard_sysk;
                                a10add_sysinfo (acv, pparsp, _b_err);
                                IF  _b_err <> e_ok
                                THEN
                                    a07_b_put_error (acv, _b_err, 1)
                                ELSE
                                    IF  multi_command = 0
                                    THEN
                                        BEGIN
                                        a06retpart_move (acv,
                                              @_fetch_parsid,
                                              sizeof (_fetch_parsid));
                                        a06finish_curr_retpart (acv,
                                              sp1pk_parsid, 1);
                                        a06retpart_move (acv,
                                              @_select_parsid,
                                              sizeof (_select_parsid));
                                        a06finish_curr_retpart (acv,
                                              sp1pk_parsid_of_select, 1);
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        (* <> only_parsing *)
                        BEGIN
                        _f_ok := true;
                        IF  NOT ( _resname_addr^.sresname.resexecuted )
                        THEN
                            a07_b_put_error (acv, e_unknown_resultname,
                                  acv.a_ap_tree^[ _curr_n ].n_pos)
                        ELSE
                            IF  ((_mtype <> mm_next) AND
                                NOT _resname_addr^.sresname.resscrollable)
                                OR
                                (
                                (sparr.px[ 2 ]^.sreskey.res_limit_offset <> cgg04_no_rowno_predicate) AND
                                ((_mtype in [mm_last, mm_prev, mm_search]) OR
                                ((_mtype = mm_direct) AND (_count1 < 0)))
                                )
                            THEN
                                a07_b_put_error (acv, e_scrolling_fetch_not_allowed, 1)
                            ELSE
                                IF  ((sparr.px[ 2 ]^.sreskey.res_bof)
                                    AND (_mtype = mm_same))
                                THEN
                                    a07_b_put_error (acv,
                                          e_current_of_needs_fetch, 7)
                                ELSE
                                    BEGIN
                                    IF  a101_IsExtendedTempFile (acv,
                                        sparr.px[ 2 ]^.sreskey.res_restree)
                                    THEN
                                        a101_GetTempFileInstance (
                                              acv.a_transinf.tri_trans,
                                              sparr.px[ 2 ]^.sreskey.res_restree);
&                                   ifdef TRACE
                                    (*ENDIF*) 
                                    t01int4 (ak_sem, 'limit_offset', sparr.px[ 2 ]^.sreskey.res_limit_offset);
                                    t01int4 (ak_sem, '_mtype      ', ord(_mtype));
                                    t01int4 (ak_sem, '_count1     ', _count1);
&                                   endif
                                    IF  (sparr.px[ 2 ]^.sreskey.res_limit_offset <> cgg04_no_rowno_predicate)
                                    THEN
                                        IF  (_mtype = mm_first) OR
                                            ((_mtype = mm_next) AND sparr.px[ 2 ]^.sreskey.res_bof)
                                        THEN
                                            BEGIN
                                            _mtype  := mm_direct;
                                            _count1 := succ(sparr.px[ 2 ]^.sreskey.res_limit_offset);
                                            END;
&                                       ifdef TRACE
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    t01int4 (ak_sem, '_mtype      ', ord(_mtype));
                                    t01int4 (ak_sem, '_count1     ', _count1);
&                                   endif
                                    IF  sparr.px[ 2 ]^.sreskey.res_build
                                    THEN
                                        IF  NOT _mfetch
                                        THEN
                                            a73_one_fetch (acv, sparr,
                                                  _mtype, _count1)
                                        ELSE
                                            (* PTS 1111576 E.Z. *)
                                            a73_more_fetch (acv, sparr, _mtype,
                                                  _count1, _mfetch_count)
                                        (*ENDIF*) 
                                    ELSE
                                        (* PTS 1111576 E.Z. *)
                                        a74_search_fetch( acv, sparr, _mtype,
                                              _count1,
                                              _resname_addr, NOT _mfetch,
                                              _mfetch_count );
                                    (*ENDIF*) 
                                    _mreturn     := acv.a_returncode;
                                    _merror      := acv.a_errorpos;
                                    _deleted     := false;
                                    acv.a_returncode := 0;
                                    IF  (acv.a_sqlmode = sqlm_oracle)
                                        OR
                                        ((NOT _resname_addr^.sresname.resscrollable) AND
                                        NOT (_resname_addr^.sresname.resparsinfobyte in
                                        [csp1_p_reuse_mass_select_found,
                                        csp1_p_reuse_update_sel_found,
                                        csp1_p_reuse_mselect_found,
                                        csp1_p_reuse_upd_mselect_found]))
                                    THEN
                                        BEGIN
                                        IF  _mreturn = a071_return_code
                                            (e_row_not_found, acv.a_sqlmode)
                                        THEN
                                            BEGIN
                                            a663_del_result (acv,
                                                  _resname_addr^.sresname,
                                                  c_do_cdel, c_del_resname_rec);
                                            acv.a_intern_warnings :=
                                                  acv.a_intern_warnings + [sp1iw_warn0_resultset_closed];
                                            _f_ok := false; (* otherwise rel_sysinfo *)
                                            (* some lines done *)
                                            _deleted := true;
                                            END
                                        ELSE
                                            IF  _mfetch     (* PTS 1116801 E.Z. *)
                                            THEN
                                                BEGIN
                                                s26find_part (acv.a_return_segm^,
                                                      sp1pk_data, _part_ptr);
                                                IF  _part_ptr <> NIL
                                                THEN
                                                    IF  sp1pa_last_packet in
                                                     _part_ptr^.sp1p_attributes
                                                    THEN
                                                     BEGIN
                                                     a663_del_result (acv,
                                                        _resname_addr^.sresname,
                                                        c_do_cdel, c_del_resname_rec);
                                                     acv.a_intern_warnings :=
                                                        acv.a_intern_warnings + [sp1iw_warn0_resultset_closed];
                                                     _f_ok := false; (* otherwise *)
                                                     (* rel_sysinfo some *)
                                                     (* lines done *)
                                                     _deleted := true;
                                                     END
                                                    (*ENDIF*) 
                                                (*ENDIF*) 
                                                END
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                    IF  NOT _deleted AND ( _mreturn = 0 )
                                    THEN
                                        BEGIN
                                        a10repl_sysinfo (acv,
                                              sparr.px[ 2 ], _b_err);
                                        IF  _b_err <> e_ok
                                        THEN
                                            a07_b_put_error (acv, _b_err, 1);
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                    IF  _mreturn <> 0
                                    THEN
                                        BEGIN
                                        acv.a_returncode := _mreturn;
                                        acv.a_errorpos   := _merror
                                        END
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  _is_relative_pos AND
    ((acv.a_returncode = 0) OR
    ( acv.a_returncode = 100))
THEN
    BEGIN
    a06retpart_move (acv, @_relative_pos,
          sizeof (_relative_pos));
    a06finish_curr_retpart (acv, sp1pk_relative_pos, 1)
    END;
(*ENDIF*) 
IF  _f_ok
THEN
    a10_rel_sysinfo (acv, _resname_addr^.syskey);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak73get_longinfo (
            VAR acv    : tak_all_command_glob;
            VAR sparr  : tak_syspointerarr;
            res_id     : tsp00_Int4);
 
VAR
      mfr_b_err      : tgg00_BasisError;
      ke         : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    ke := a01sysnullkey;
    WITH ke DO
        BEGIN
        stempid   := res_id;
        sentrytyp := cak_ecolnames;
        END;
    (*ENDWITH*) 
    a10get_sysinfo (acv, ke, d_fix, sparr.pcolnamep, mfr_b_err);
    IF  mfr_b_err = e_ok
    THEN
        BEGIN
        ke.sentrytyp := cak_eshortinfo;
        a10get_sysinfo (acv, ke, d_release, sparr.pinfop, mfr_b_err)
        END;
    (*ENDIF*) 
    IF  mfr_b_err <> e_ok
    THEN
        a07_b_put_error (acv, mfr_b_err, 1)
    ELSE
        BEGIN
        a60_p_info_output (acv, sparr);
        a10rel_sysinfo (sparr.pcolnamep)
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak73next_stamp (VAR acv : tak_all_command_glob);
 
VAR
      mfr_b_err        : tgg00_BasisError;
      ts           : tsp1_param_info;
      dmli         : tak_dml_info;
      curr_n       : integer;
      parsid       : tak_parsid;
      dummy_parsid : tak_parsid;
 
BEGIN
WITH acv, a_pars_last_key DO
    BEGIN
    p_kind := m_stamp;
    WITH ts DO
        BEGIN
        sp1i_mode       := [ sp1ot_mandatory ];
        sp1i_io_type    := sp1io_output;
        sp1i_data_type  := dchb;
        sp1i_frac       := 0;
        sp1i_length     := SURROGATE_MXGG00;
        sp1i_in_out_len := succ(SURROGATE_MXGG00);
        sp1i_bufpos     := 1;
        END;
    (*ENDWITH*) 
    WITH dmli.d_sparr DO
        BEGIN
        curr_n   := 1;
        curr_n := a_ap_tree^[ curr_n ].n_lo_level;
        IF  curr_n <> 0
        THEN
            BEGIN
            a54_dml_init (acv, dmli, NOT c_in_union);
            dmli.d_acttabindex := 1;
            a660_search_one_table (acv, dmli, curr_n,
                  NOT c_all, NOT c_check_teresult, no_lock, r_sel);
            a54_dml_finalize( dmli, acv.a_transinf.tri_trans );
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            a54_get_pparsp_pinfop (acv, dmli.d_sparr, m_stamp);
            IF  a_returncode = 0
            THEN
                BEGIN
                IF  dmli.d_sparr.pinfop <> NIL
                THEN
                    BEGIN
                    a10_key_del (acv, dmli.d_sparr.pinfop^.syskey);
&                   ifdef trace
                    dmli.d_sparr.pinfop := NIL;
&                   endif
                    a_shortinfo_key := cgg_zero_id;
                    END;
                (*ENDIF*) 
                WITH pparsp^.sparsinfo DO
                    BEGIN
                    p_mtyp     := m_stamp;
                    p_mtyp2    := mm_nil;
                    p_select   := false;
                    p_prepare  := false;
                    p_session_isolevel := acv.a_iso_level;
                    p_use_sess_isolevel:= false;
                    END;
                (*ENDWITH*) 
                pparsp^.b_sl := mxak_pars_header + cak_sysbufferoffset;
                pparsp^.sparsinfo.p_fullen := pparsp^.b_sl;
                pparsp^.b_kl := mxak_standard_sysk;
                a10add_sysinfo (acv, pparsp, mfr_b_err);
                IF  mfr_b_err <> e_ok
                THEN
                    a07_b_put_error (acv, mfr_b_err, 1)
                ELSE
                    BEGIN
                    parsid.pid_session :=
                          a_transinf.tri_trans.trSessionId_gg00;
                    parsid.pid_parsk   := a_pars_last_key;
                    parsid.pid_appl_info[1]  :=
                          chr(a_precomp_info_byte);
                    parsid.pid_dtime_info[1] := chr(ord(dtf_none));
                    IF  g01diag_moni_parse_on
                    THEN
                        BEGIN
                        dummy_parsid.pid_session.ci4_gg00 := cgg_nil_session;
                        a545diag_parse_info (acv,
                              parsid, dummy_parsid);
                        END;
                    (*ENDIF*) 
                    a06retpart_move (acv, @ts,     sizeof (ts));
                    a06finish_curr_retpart (acv, sp1pk_shortinfo, 1);
                    a06retpart_move (acv, @parsid, sizeof (parsid));
                    a06finish_curr_retpart (acv, sp1pk_parsid,    1)
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak73one_before_pos (
            VAR acv   : tak_all_command_glob;
            VAR sparr : tak_syspointerarr;
            pos       : tsp00_Int4);
 
VAR
      mfr_b_err      : tgg00_BasisError;
      set_result : tgg00_BdSetResultRecord;
      previous   : boolean;
      i          : integer;
      start      : integer;
      mfr_count2     : tsp00_Int4;
      tree_pos   : tgg00_FilePos;
      bd_lkey    : tgg00_Lkey;
 
BEGIN
previous := false;
WITH acv, sparr.px[ 2 ]^.sreskey DO
    IF  ((pos = res_nextpos) OR (pos = res_prevpos))
    THEN
        BEGIN
        IF  pos = res_prevpos
        THEN
            BEGIN
            res_nextkeys.reckeyspec.ks_len :=
                  res_prevkeys.reckeyspec.ks_len;
            SAPDB_PascalMove ('VAK73 ',   4,    
                  sizeof(res_keysbuf), sizeof(res_keysbuf),
                  @res_keysbuf, res_prevkeys.reckeyspec.ks_pos,
                  @res_keysbuf, res_nextkeys.reckeyspec.ks_pos,
                  res_nextkeys.reckeyspec.ks_len,
                  a_returncode);
            res_nextpos             := res_prevpos
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  pos > res_nextpos
        THEN
            mfr_count2 := res_nextpos + 1
        ELSE
            IF  pos > res_prevpos
            THEN
                BEGIN
                res_nextpos             := res_prevpos;
                mfr_count2                  := res_nextpos+1;
                res_nextkeys.reckeyspec.ks_len := res_prevkeys.reckeyspec.ks_len;
                SAPDB_PascalMove ('VAK73 ',   5,    
                      sizeof(res_keysbuf), sizeof(res_keysbuf),
                      @res_keysbuf, res_prevkeys.reckeyspec.ks_pos,
                      @res_keysbuf, res_nextkeys.reckeyspec.ks_pos,
                      res_nextkeys.reckeyspec.ks_len,
                      a_returncode)
                END
            ELSE
                IF  ((pos < res_prevpos - pos) OR (pos = 1))
                THEN
                    BEGIN
                    res_nextkeys.reckeyspec.ks_len := 0;
                    res_nextpos             := 0;
                    mfr_count2                  := 1
                    END
                ELSE
                    BEGIN
                    res_nextkeys.reckeyspec.ks_len :=
                          res_prevkeys.reckeyspec.ks_len;
                    SAPDB_PascalMove ('VAK73 ',   6,    
                          sizeof(res_keysbuf), sizeof(res_keysbuf),
                          @res_keysbuf, res_prevkeys.reckeyspec.ks_pos,
                          @res_keysbuf, res_nextkeys.reckeyspec.ks_pos,
                          res_nextkeys.reckeyspec.ks_len,
                          a_returncode);
                    res_nextpos             := res_prevpos;
                    mfr_count2                  := res_prevpos;
                    previous                := true
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        WITH set_result DO
            BEGIN
            bd_key_check_len := 0;
            bd_max_rec_cnt   := 1;
            bd_max_fill_len  := a_mblock.mb_data_size;
            bd_next          := true;
            END;
        (*ENDWITH*) 
        tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
        IF  NOT previous
        THEN
            WHILE ((a_returncode = 0) AND
                  (mfr_count2 < pos)) DO
                BEGIN
                IF  pos-mfr_count2 > csp_maxint2
                THEN
                    set_result.bd_max_rec_cnt := csp_maxint2
                ELSE
                    set_result.bd_max_rec_cnt := pos-mfr_count2;
                (*ENDIF*) 
                bd_lkey.len := res_nextkeys.reckeyspec.ks_len;
                SAPDB_PascalMove ('VAK73 ',   7,    
                      sizeof(res_keysbuf), sizeof(tsp00_Key),
                      @res_keysbuf, res_nextkeys.reckeyspec.ks_pos,
                      @bd_lkey.k, 1, bd_lkey.len,
                      a_returncode);
                IF  a_returncode = 0
                THEN
                    BEGIN
                    b07cnext_record (a_transinf.tri_trans,
                          res_restree, bd_lkey,
                          set_result, tree_pos, a_mblock.mb_data^.mbp_buf);
                    CASE a_transinf.tri_trans.trError_gg00 OF
                        e_key_not_found, e_buffer_limit :
                            mfr_b_err := e_ok;
                        e_no_next_record :
                            BEGIN
                            mfr_b_err := e_no_next_record;
                            a07_b_put_error (acv, e_row_not_found, 1)
                            END;
                        OTHERWISE
                            mfr_b_err := a_transinf.tri_trans.trError_gg00;
                        END
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
                IF  mfr_b_err <> e_ok
                THEN
                    a07_b_put_error (acv, mfr_b_err, 1)
                ELSE
                    BEGIN
                    start := 1;
                    FOR i := 1 TO set_result.bd_rec_cnt-1 DO
                        start := start+res_reclen;
                    (*ENDFOR*) 
                    SAPDB_PascalMove ('VAK73 ',   8,    
                          a_mblock.mb_data_size,
                          sizeof(res_keysbuf),
                          @a_mblock.mb_data^.mbp_buf, start+cgg_rec_key_offset,
                          @res_keysbuf,
                          res_nextkeys.reckeyspec.ks_pos,
                          res_keylen, a_returncode);
                    res_nextkeys.reckeyspec.ks_len := res_keylen;
                    res_nextpos             := res_nextpos +
                          set_result.bd_rec_cnt
                    END;
                (*ENDIF*) 
                mfr_count2 := mfr_count2+set_result.bd_rec_cnt;
                set_result.bd_next := false;
                END
            (*ENDWHILE*) 
        ELSE
            WHILE ((a_returncode = 0) AND
                  (mfr_count2 >= pos)) DO
                BEGIN
                set_result.bd_max_rec_cnt := mfr_count2 - pos + 1;
                bd_lkey.len := res_nextkeys.reckeyspec.ks_len;
                SAPDB_PascalMove ('VAK73 ',   9,    
                      sizeof(res_keysbuf), sizeof(tsp00_Key),
                      @res_keysbuf, res_nextkeys.reckeyspec.ks_pos,
                      @bd_lkey.k, 1, bd_lkey.len,
                      a_returncode);
                IF  a_returncode = 0
                THEN
                    BEGIN
                    b07cprev_record (a_transinf.tri_trans,
                          res_restree, bd_lkey,
                          set_result, tree_pos, a_mblock.mb_data^.mbp_buf);
                    CASE a_transinf.tri_trans.trError_gg00 OF
                        e_key_not_found, e_buffer_limit :
                            mfr_b_err := e_ok;
                        e_no_prev_record :
                            BEGIN
                            mfr_b_err := e_no_next_record;
                            a07_b_put_error (acv, e_row_not_found, 1)
                            END;
                        OTHERWISE
                            mfr_b_err := a_transinf.tri_trans.trError_gg00;
                        END
                    (*ENDCASE*) 
                    END;
                (*ENDIF*) 
                IF  mfr_b_err <> e_ok
                THEN
                    a07_b_put_error (acv, mfr_b_err, 1)
                ELSE
                    BEGIN
                    start := 1;
                    FOR i := 1 TO set_result.bd_rec_cnt-1 DO
                        start := start+res_reclen;
                    (*ENDFOR*) 
                    SAPDB_PascalMove ('VAK73 ',  10,    
                          a_mblock.mb_data_size,
                          sizeof(res_keysbuf),
                          @a_mblock.mb_data^.mbp_buf, start+cgg_rec_key_offset,
                          @res_keysbuf,
                          res_nextkeys.reckeyspec.ks_pos,
                          res_keylen, a_returncode);
                    res_nextkeys.reckeyspec.ks_len := res_keylen;
                    res_nextpos             := res_nextpos -
                          set_result.bd_rec_cnt
                    END;
                (*ENDIF*) 
                mfr_count2 := mfr_count2-set_result.bd_rec_cnt;
                set_result.bd_next := false;
                END
            (*ENDWHILE*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
&ifdef trace
t01int4( ak_sem, 'a_returncode', acv.a_returncode );
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_aclose_resulttable (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_return_segm^.sp1r_function_code := csp1_close_fc;
    a01_call_put (acv, a73, cak_x_close, curr_n);
    put_node := curr_n;
    (* PTS 1120287 E.Z. *)
    a01_next_symbol (acv);
    IF  sc_symb <> s_eof
    THEN
        a02_aresulttablename (acv, a_ap_tree^[ curr_n ].n_sa_level, curr_n);
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_adescribe_resulttable (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_call_put (acv, a73, cak_x_describe, curr_n);
    put_node := curr_n;
    a01_next_symbol (acv);
    IF  sc_symb <> s_eof
    THEN
        a02_aresulttablename (acv,
              a_ap_tree^[ curr_n ].n_sa_level, curr_n)
    ELSE
        IF  (a_data_length = mxak_parsid) AND (a_ex_kind <> only_parsing)
        THEN
            a_ap_tree^[ put_node ].n_subproc := cak_x_describe_parsid;
        (*ENDIF*) 
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_adparseid (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_return_segm^.sp1r_function_code := csp1_drop_parseid_fc;
    a01_call_put (acv, a73, cak_x_drop, put_node);
    a01_next_symbol (acv);
    a01_is_end_symbol (acv)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_afetch_statement (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      res_kw  : boolean;
      index   : integer;
      curr_n  : tsp00_Int2;
      last_n  : tsp00_Int2;
      subproc : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    (* PTS 1111576 E.Z. *)
    IF  a_cmd_segment_header.sp1c_mass_cmd
    THEN
        a01_call_put (acv, a73, cak_x_mfetch, curr_n)
    ELSE
        a01_call_put (acv, a73, cak_x_fetch, curr_n);
    (*ENDIF*) 
    put_node := curr_n;
    a01_next_symbol (acv);
    IF  ((sc_symb <> s_eof) AND (a_sqlmode = sqlm_internal))
    THEN
        a01_get_keyword (acv, index, res_kw)
    ELSE
        index := cak_i_no_keyword;
    (*ENDIF*) 
    IF  index = cak_i_pos
    THEN
        BEGIN
        a01_call_put (acv, a73, cak_x_pos, a_ap_tree^[ curr_n ].n_lo_level);
        a_return_segm^.sp1r_function_code := csp1_fetch_pos_fc;
        curr_n := a_ap_tree^[ curr_n ].n_lo_level;
        a01_next_symbol (acv);
        a01_force_symbol (acv, s_leftpar, put_node, put_node);
        CASE sc_symb OF
            s_parameter_name :
                a02_s_aparameterspec (acv, a_ap_tree^[ curr_n ]
                      .n_lo_level, last_n);
            s_unsigned_integer :
                a03_anumeric_literal (acv, a_ap_tree^[ curr_n ]
                      .n_lo_level, last_n);
            OTHERWISE
                a07_error (acv, e_missing_value_spec,
                      put_node, put_node);
            END;
        (*ENDCASE*) 
        a01_force_symbol (acv, s_rightpar, put_node, put_node);
        END
    ELSE
        IF  (index = cak_i_absolute) OR
            (index = cak_i_relative)
        THEN
            BEGIN
            IF  index = cak_i_relative
            THEN
                BEGIN
                a01_call_put (acv, a73, cak_x_relative,
                      a_ap_tree^[ curr_n ].n_lo_level);
                a_return_segm^.sp1r_function_code := csp1_fetch_relative_fc;
                END
            ELSE
                BEGIN
                a01_call_put (acv, a73, cak_x_pos,
                      a_ap_tree^[ curr_n ].n_lo_level);
                a_return_segm^.sp1r_function_code := csp1_fetch_pos_fc;
                END;
            (*ENDIF*) 
            curr_n := a_ap_tree^[ curr_n ].n_lo_level;
            a01_next_symbol (acv);
            CASE sc_symb OF
                s_parameter_name :
                    a02_s_aparameterspec (acv, a_ap_tree^[ curr_n ]
                          .n_lo_level, last_n);
                s_unsigned_integer :
                    a03_anumeric_literal (acv, a_ap_tree^[ curr_n ]
                          .n_lo_level, last_n);
                s_plus, s_minus :
                    a03_ainteger (acv, a_ap_tree^[ curr_n ]
                          .n_lo_level, last_n);
                OTHERWISE
                    a07_error (acv, e_missing_value_spec,
                          put_node, put_node);
                END;
            (*ENDCASE*) 
            END
        ELSE
            BEGIN
            IF  index in [ cak_i_first, cak_i_next, cak_i_last, cak_i_prev ]
            THEN
                BEGIN
                CASE index OF
                    cak_i_first :
                        BEGIN
                        subproc := cak_x_first;
                        a_return_segm^.sp1r_function_code :=
                              csp1_fetch_first_fc;
                        END;
                    cak_i_next :
                        BEGIN
                        subproc := cak_x_next;
                        a_return_segm^.sp1r_function_code :=
                              csp1_fetch_next_fc;
                        END;
                    cak_i_last :
                        BEGIN
                        subproc := cak_x_last;
                        a_return_segm^.sp1r_function_code :=
                              csp1_fetch_last_fc;
                        END;
                    cak_i_prev :
                        BEGIN
                        subproc := cak_x_prev;
                        a_return_segm^.sp1r_function_code :=
                              csp1_fetch_prev_fc;
                        END;
                    END;
                (*ENDCASE*) 
                a01_next_symbol (acv)
                END
            ELSE
                IF  index = cak_i_same
                THEN
                    BEGIN
                    subproc := cak_x_same;
                    a01_next_symbol (acv);
                    a_return_segm^.sp1r_function_code :=
                          csp1_fetch_same_fc;
                    END
                ELSE
                    BEGIN
                    subproc := cak_x_next;
                    a_return_segm^.sp1r_function_code :=
                          csp1_fetch_next_fc;
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            a01_call_put (acv, a73, subproc, a_ap_tree^[ curr_n ].n_lo_level);
            curr_n := a_ap_tree^[ curr_n ].n_lo_level
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  ((sc_symb <> s_eof) AND (a_returncode = 0))
    THEN
        IF  (((a_sqlmode <> sqlm_internal) AND
            ( a_sqlmode <> sqlm_oracle)) OR
            NOT (a01_eqkey (a01kw[ cak_i_into ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)))
        THEN
            a02_aresulttablename (acv,
                  a_ap_tree^[ curr_n ].n_sa_level, curr_n);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  NOT a01_eqkey (a01kw[ cak_i_into ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            IF  a_ex_kind <> only_parsing
            THEN
                IF  a_sqlmode <> sqlm_internal
                THEN
                    a07_error (acv, e_wanted_keyword,
                          put_node, last_n)
                ELSE
                    WITH a_transinf.tri_trans DO
                        trWarning_gg00 := trWarning_gg00 + [ warn0_exist,
                              warn3_output_not_into_columns ]
                    (*ENDWITH*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            a01_next_symbol (acv);
            a01_call_put (acv, a73, cak_x_params,
                  a_ap_tree^[ curr_n ].n_sa_level);
            curr_n := a_ap_tree^[ curr_n ].n_sa_level;
            a02_l_aparameter_list (acv, a_ap_tree^[ curr_n ].n_lo_level,
                  last_n)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_cmd_segment_header.sp1c_mass_cmd
    THEN
        a_return_segm^.sp1r_function_code :=
              a_return_segm^.sp1r_function_code +
              csp1_masscmd_fc_offset;
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_anext_statement (
            VAR acv      : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      last_node : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a01_next_symbol (acv);
    IF  (((a_ex_kind <> only_parsing) AND (a_ex_kind <> only_syntax)) OR
        (a_sqlmode <> sqlm_internal))
    THEN
        a07_b_put_error (acv, e_invalid_command, 1)
    ELSE
        IF  a01_eqkey (a01kw[ cak_i_stamp ], a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            BEGIN
            a_return_segm^.sp1r_function_code := csp1_next_stamp_fc;
            a01_call_put (acv, a73, cak_x_stamp_get, put_node);
            a01_next_symbol (acv);
            IF  a01_eqkey (a01kw[ cak_i_for ], a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                a02_atablename (acv, a_ap_tree^[ put_node ].n_lo_level,
                      last_node);
                END;
            (*ENDIF*) 
            IF  sc_symb = s_parameter_name
            THEN
                a01_next_symbol (acv)
            ELSE
                BEGIN
                IF  a01mandatory_keyword (acv, cak_i_into)
                THEN
                    BEGIN
                    IF  sc_symb = s_parameter_name
                    THEN
                        a01_next_symbol (acv)
                    ELSE
                        a07_error (acv, e_missing_identifier,
                              put_node, put_node)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            a07_error (acv, e_wanted_keyword, put_node, put_node);
        (*ENDIF*) 
    (*ENDIF*) 
    a01_is_end_symbol (acv)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_call_semantic  (VAR acv : tak_all_command_glob);
 
VAR
      dummy : tak_sysbufferaddress;
 
BEGIN
CASE acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_subproc OF
    cak_x_close :
        ak73close_semantic (acv);
    cak_x_describe :
        ak73describe_semantic (acv);
    cak_x_describe_parsid :
        a73parsid_describe_semantic (acv, c_inclusive_output, dummy, dummy);
    cak_x_drop :
        ak73drop_parseid (acv);
    cak_x_stamp_get :
        ak73next_stamp (acv);
    OTHERWISE
        ak73fetch_semantic (acv);
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_close_execute (
            VAR acv        : tak_all_command_glob;
            VAR sparr      : tak_syspointerarr;
            VAR res_name   : tsp00_KnlIdentifier;
            VAR modul_name : tsp00_KnlIdentifier);
 
VAR
      mfr_b_err        : tgg00_BasisError;
      f_ok         : boolean;
      hpfiller     : tgg00_DateTimeFormat;
      i            : integer;
      hpinfobyte   : tsp00_Uint1;
      hparsk       : tak_parskey;
      parsid       : tak_parsid;
      dummy_parsid : tak_parsid;
      dummy_c12    : tsp00_C12;
 
BEGIN
WITH acv DO
    BEGIN
    a663_get_result_info (acv, res_name, modul_name,
          a_resname_addr[ cak_aux_pos ],
          NOT c_make_new_res, ttfnNone_egg00, d_release, f_ok);
    IF  f_ok
    THEN
        BEGIN
&       IFDEF TRACE
        t01lidentifier (ak_sem, res_name);
&       ENDIF
        WITH a_resname_addr[ cak_aux_pos ]^.sresname DO
            BEGIN
            hparsk     := reseparsk;
            hpinfobyte := resparsinfobyte;
            hpfiller   := resdatetimeformat;
            f_ok       := NOT ((NOT resexecuted) AND
                  (a_ex_kind <> only_parsing));
            IF  (a_ex_kind <> only_parsing) OR
                (NOT resexecuted)
            THEN
                a663_del_result (acv,
                      a_resname_addr[ cak_aux_pos ]^.sresname,
                      c_do_cdel, c_del_resname_rec);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END
    ELSE
        hparsk.p_kind := m_nil;
    (*ENDIF*) 
    IF  ((NOT f_ok) AND (a_sqlmode <> sqlm_oracle))
    THEN
        (* oracle can close not-existed resultset without an error !! *)
        (* checked with ORACLE V6 on 13.9.93 ! *)
        IF  g01unicode
        THEN
            a07_b_put_error (acv, e_unknown_resultname, 13)
        ELSE
            a07_b_put_error (acv, e_unknown_resultname, 7);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_ex_kind = only_executing
    THEN
        BEGIN
        IF  hparsk.p_kind <> m_nil
        THEN
            BEGIN
            parsid.pid_session :=
                  a_transinf.tri_trans.trSessionId_gg00;
            parsid.pid_parsk   := hparsk;
            parsid.pid_appl_info[1]  :=
                  chr(hpinfobyte);
            parsid.pid_dtime_info[1] := chr(ord(hpfiller));
            a06retpart_move (acv, @parsid, sizeof (parsid));
            END
        ELSE
            BEGIN
            FOR i := 1 TO mxak_parsid DO
                dummy_c12 [i] := chr(0);
            (*ENDFOR*) 
            a06retpart_move (acv, @dummy_c12, sizeof (parsid));
            END;
        (*ENDIF*) 
        a06finish_curr_retpart (acv, sp1pk_parsid_of_select, 1);
        END;
    (*ENDIF*) 
    IF  ((a_returncode = 0) AND
        (a_ex_kind = only_parsing))
    THEN
        WITH sparr DO
            BEGIN
            a54_get_pparsp_pinfop (acv, sparr, m_close);
            IF  a_returncode = 0
            THEN
                BEGIN
                a_precomp_info_byte := csp1_p_close_found;
                WITH pparsp^.sparsinfo DO
                    BEGIN
                    p_mtyp             := m_close;
                    p_select           := false;
                    p_resn             := res_name;
                    p_modul_name       := modul_name;
                    p_statement_kind   := icollisions;
                    p_filler1          := false;
                    p_function_code    := a_return_segm^.sp1r_function_code;
                    p_prepare          := false;
                    p_session_isolevel := acv.a_iso_level;
                    p_use_sess_isolevel:= false;
                    END;
                (*ENDWITH*) 
                pparsp^.b_sl := mxak_pars_header + cak_sysbufferoffset;
                pparsp^.sparsinfo.p_fullen := pparsp^.b_sl;
                pparsp^.b_kl := mxak_standard_sysk;
                a10add_sysinfo (acv, pparsp, mfr_b_err);
                IF  mfr_b_err <> e_ok
                THEN
                    a07_b_put_error (acv, mfr_b_err, 1)
                ELSE
                    BEGIN
                    parsid.pid_session :=
                          a_transinf.tri_trans.trSessionId_gg00;
                    parsid.pid_parsk   := a_pars_last_key;
                    parsid.pid_appl_info[1]  :=
                          chr(a_precomp_info_byte);
                    parsid.pid_dtime_info[1] := chr(ord(dtf_none));
                    IF  g01diag_moni_parse_on
                    THEN
                        BEGIN
                        dummy_parsid.pid_session.ci4_gg00 := cgg_nil_session;
                        a545diag_parse_info (acv,
                              parsid, dummy_parsid);
                        END;
                    (*ENDIF*) 
                    a54return_parsid (acv, parsid.pid_parsk);
                    a06init_curr_retpart (acv);
                    a06finish_curr_retpart (acv, sp1pk_shortinfo, 0)
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_describe_execute (
            VAR acv        : tak_all_command_glob;
            VAR sparr      : tak_syspointerarr;
            VAR res_name   : tsp00_KnlIdentifier;
            VAR modul_name : tsp00_KnlIdentifier);
 
VAR
      mfr_b_err        : tgg00_BasisError;
      f_ok         : boolean;
      parsid       : tak_parsid;
      dummy_parsid : tak_parsid;
      dmli         : tak_dml_info;
 
BEGIN
WITH acv, dmli DO
    BEGIN
    a54_dml_init (acv, dmli, NOT c_in_union);
    a663_get_result_info (acv, res_name, modul_name,
          a_resname_addr[ cak_extern_pos ],
          NOT c_make_new_res, ttfnNone_egg00, d_release, f_ok);
    IF  f_ok
    THEN
        BEGIN
        d_pos_result        := cak_extern_pos;
        d_global_pos_result := cak_extern_pos;
&       IFDEF TRACE
        t01lidentifier (ak_sem, res_name);
        t01int4 (ak_sem, 'POS_ERG     ', d_pos_result);
&       ENDIF
        IF  a_ex_kind <> only_parsing
        THEN
            a73_ex_describe (acv, dmli, 2, NOT c_subquery);
        (*ENDIF*) 
        END
    ELSE
        IF  g01unicode
        THEN
            a07_b_put_error (acv, e_unknown_resultname, 19)
        ELSE
            a07_b_put_error (acv, e_unknown_resultname, 10);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  ((a_returncode = 0) AND
        (a_ex_kind = only_parsing))
    THEN
        WITH sparr DO
            BEGIN
            a54_get_pparsp_pinfop (acv, sparr, m_describe);
            IF  a_returncode = 0
            THEN
                BEGIN
                a_precomp_info_byte := csp1_p_describe_found;
                WITH pparsp^.sparsinfo DO
                    BEGIN
                    p_mtyp       := m_describe;
                    p_select     := false;
                    p_resn       := res_name;
                    p_modul_name := modul_name;
                    p_prepare    := false;
                    p_session_isolevel := acv.a_iso_level;
                    p_use_sess_isolevel:= false;
                    END;
                (*ENDWITH*) 
                pparsp^.b_sl := mxak_pars_header + cak_sysbufferoffset;
                pparsp^.sparsinfo.p_fullen := pparsp^.b_sl;
                pparsp^.b_kl := mxak_standard_sysk;
                a10add_sysinfo (acv, pparsp, mfr_b_err);
                IF  mfr_b_err <> e_ok
                THEN
                    a07_b_put_error (acv, mfr_b_err, 1)
                ELSE
                    BEGIN
                    parsid.pid_session :=
                          a_transinf.tri_trans.trSessionId_gg00;
                    parsid.pid_parsk   := a_pars_last_key;
                    parsid.pid_appl_info[1]  :=
                          chr(a_precomp_info_byte);
                    parsid.pid_dtime_info[1] := chr(ord(dtf_none));
                    IF  g01diag_moni_parse_on
                    THEN
                        BEGIN
                        dummy_parsid.pid_session.ci4_gg00 := cgg_nil_session;
                        a545diag_parse_info (acv,
                              parsid, dummy_parsid);
                        END;
                    (*ENDIF*) 
                    a54return_parsid (acv, parsid.pid_parsk);
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    a_resname_addr[cak_extern_pos] := NIL;
    a54_dml_finalize( dmli, acv.a_transinf.tri_trans );
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_ex_describe (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            start_fieldno : integer;
            subquery      : boolean);
 
VAR
      mfr_b_err    : tgg00_BasisError;
      done     : boolean;
      f_ok     : boolean;
      fieldno  : integer;
      startpos : integer;
      res_id   : tsp00_Int4;
      col_ptr  : tak00_colinfo_ptr;
 
BEGIN
WITH acv, dmli DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'd_global_pos', d_global_pos_result);
&   endif
    (* PTS 1000985/1001162 E.Z. *)
    IF  (csa_subq_datatype_problem in acv.a_sql_cmd_state)
    THEN
        done := true
    ELSE
        done := false;
    (*ENDIF*) 
    IF  d_global_pos_result <= cak_maxresulttables
    THEN (* *** not into file *** *)
        WITH a_resname_addr[ d_global_pos_result ]^.sresname DO
            IF  resinfobuf > 0
            THEN
                BEGIN
                ak73get_longinfo (acv, d_sparr, a101_GetTempFileIndex (acv,
                      restreeid));
                done := true
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  NOT done
    THEN
        WITH dmli DO
            BEGIN
            d_single  := false;
            d_keylen  := -cgg_rec_key_offset;
            d_refname := a01_il_b_identifier;
            startpos  := 0;
            d_sparr.pinfop := NIL;
            a_shortinfo_key := cgg_zero_id;
            WITH a_resname_addr[ d_global_pos_result ]^.sresname DO
                IF  d_global_pos_result <= cak_maxresulttables
                THEN
                    BEGIN
                    (* PTS 1112770 E.Z. *)
                    IF  d_global_pos_result = cak_intern_pos
                    THEN
                        res_id := cak_intern_res_fid
                    ELSE
                        res_id := a101_GetTempFileIndex (acv, restreeid);
                    (*ENDIF*) 
                    END
                ELSE
                    res_id := cak_into_res_fid;
                (*ENDIF*) 
            (*ENDWITH*) 
            d_sparr.psynfound := false;
            a663get_result_records (acv, d_fix,
                  res_id, d_sparr.pbasep, f_ok);
            (* d_fix !!! because of second longinfo_buffer *)
            IF  NOT f_ok
            THEN
                a07_b_put_error (acv, e_unknown_resultname, 1)
            ELSE
                WITH d_sparr.pbasep^.sresult DO
                    BEGIN
                    WITH a_resname_addr[ d_global_pos_result ]^.sresname DO
                        IF  d_global_pos_result <= cak_maxresulttables
                        THEN
                            a60_get_longinfobuffer (acv, d_sparr,
                                  boutcolno - start_fieldno + 1,
                                  a101_GetTempFileIndex (acv, restreeid));
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        fieldno := start_fieldno;
                        WHILE fieldno <= boutcolno DO
                            BEGIN
                            a06extcolno (d_sparr.pbasep^.sbase,
                                  fieldno, col_ptr);
                            d_inoutpos := startpos +
                                  col_ptr^.ccolstack.epos;
                            a61_p_long_info (acv, dmli, col_ptr^);
                            fieldno    := succ(fieldno)
                            END;
                        (*ENDWHILE*) 
                        a10_rel_sysinfo (acv, d_sparr.pbasep^.syskey);
                        IF  a_returncode = 0
                        THEN
                            a60_p_info_output (acv, d_sparr);
                        (*ENDIF*) 
                        IF  d_sparr.pcolnamep <> NIL
                        THEN
                            IF  subquery
                            THEN
                                BEGIN
                                a10add_sysinfo (acv,
                                      d_sparr.pcolnamep, mfr_b_err);
                                IF  mfr_b_err <> e_ok
                                THEN
                                    a07_b_put_error (acv, mfr_b_err, 1)
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                a10_key_del (acv, d_sparr.pcolnamep^.syskey);
&                               ifdef trace
                                d_sparr.pcolnamep := NIL
&                                     endif
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        IF  a_returncode = 0
                        THEN
                            IF  subquery
                            THEN
                                BEGIN
                                WITH d_sparr.pinfop^ DO
                                    BEGIN
                                    b_sl := sizeof(sshortinfo) -
                                          sizeof(sshortinfo.siinfo) +
                                          sshortinfo.sicount *
                                          sizeof(tsp1_param_info);
                                    END;
                                (*ENDWITH*) 
                                a10add_sysinfo (acv,
                                      d_sparr.pinfop, mfr_b_err);
                                IF  mfr_b_err <> e_ok
                                THEN
                                    a07_b_put_error (acv, mfr_b_err, 1)
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                a10_key_del (acv, d_sparr.pinfop^.syskey);
&                               ifdef trace
                                d_sparr.pinfop := NIL;
&                               endif
                                a_shortinfo_key := cgg_zero_id;
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* PTS 1000479 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a73_infolen_get (
            VAR acv        : tak_all_command_glob;
            no_of_out_cols : integer;
            VAR output_len : tsp00_Int2);
 
VAR
      f_ok    : boolean;
      isparr  : tak_syspointerarr;
      k       : integer;
      col_ptr : tak00_colinfo_ptr;
 
BEGIN
WITH acv DO
    BEGIN
    a663restable_get (acv, d_release,
          a_resname_addr[ cak_extern_pos ]^.sresname.reskey_name,
          isparr, f_ok);
    IF  f_ok
    THEN
        BEGIN
        a_output_data_pos := 1;
        col_ptr           := a103GetColumn (isparr.pbasep^.sbase, isparr.pbasep^.sbase.bfirstcolind);
        FOR k := 2 TO no_of_out_cols+1 DO
            BEGIN
            col_ptr := a103GetColumn (isparr.pbasep^.sbase, col_ptr^.cnextind);
            a_output_data_pos := col_ptr^.ccolstack.epos;
            END;
        (*ENDFOR*) 
        WITH col_ptr^ DO
            output_len := ccolstack.epos + cinoutlen - 1;
        (*ENDWITH*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_more_fetch (
            VAR acv      : tak_all_command_glob;
            VAR sparr    : tak_syspointerarr;
            mtype        : tgg00_MessType2;
            pos          : tsp00_Int4;
            mfetch_count : tsp00_Int4);
 
VAR
      mfr_b_err               : tgg00_BasisError;
      set_result          : tgg00_BdSetResultRecord;
      firstres            : boolean;
      not_null            : boolean;
      col_no              : integer;
      i                   : integer;
      start               : tsp00_Int2;
      tree_pos            : tgg00_FilePos;
      mfr                 : mfetchrec;
      lcol_found          : boolean;
      lcol_lock           : boolean;
      bd_lkey             : tgg00_Lkey;
      unused_leng         : integer;
      ic2                 : tsp_int_map_c2;
 
BEGIN
WITH acv, sparr, mfr DO
    BEGIN
    lcol_found := false;
    a09activate_lock (a_transinf.tri_trans, a_work_st_addr,
          a_work_st_max, mfr_b_err);
    IF  mfr_b_err = e_rollback_wanted
    THEN
        BEGIN
        a_rollback_info := [ trans_rollback, new_trans ];
        mfr_b_err := e_work_rolled_back
        END;
    (*ENDIF*) 
    IF  mfr_b_err <> e_ok
    THEN
        a07_b_put_error (acv, mfr_b_err, 1);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        WITH px[ 2 ]^.sreskey, a_mblock DO
            BEGIN
            a60rescount (acv, 0);
            IF  a_curr_retpart = NIL
            THEN
                a06init_curr_retpart (acv);
            (*ENDIF*) 
            IF  (res_change.cr_colcount > 0)
            THEN
                lcol_found := a508_lcol_found (acv, res_change);
&           IFDEF TRACE
            (*ENDIF*) 
            t01int4 (bi, 'res_nextpos ', res_nextpos);
            t01int4 (bi, 'res_prevpos ', res_prevpos);
&           ENDIF
            mfr_b_err       := e_ok;
            res_useupdk := 0;
            (* PTS 1116917 E.Z. *)
            unused_leng := a73_calc_unused_space (acv);
            IF  a_init_ex_kind = only_executing
            THEN
                (* PTS 1000479 E.Z. *)
                IF  px[ 1 ]^.sparsinfo.p_resinfolen < 0
                THEN
                    BEGIN
                    col_no := -px[ 1 ]^.sparsinfo.p_resinfolen;
                    IF  col_no > res_outcolno
                    THEN
                        col_no := res_outcolno;
                    (*ENDIF*) 
                    a73_infolen_get (acv, col_no, mfr_reclength)
                    END
                ELSE
                    mfr_reclength := px[ 1 ]^.sparsinfo.p_resinfolen
                (*ENDIF*) 
            ELSE
                mfr_reclength := res_length - res_keylen - cgg_rec_key_offset;
            (*ENDIF*) 
            IF  unused_leng < mfr_reclength
            THEN
                mfr_count1 := 1
            ELSE
                mfr_count1 := unused_leng DIV mfr_reclength;
            (*ENDIF*) 
            IF  mfr_count1 > mfetch_count
            THEN
                mfr_count1 := mfetch_count;
            (*ENDIF*) 
            WITH set_result DO
                BEGIN
                bd_key_check_len := 0;
                bd_max_rec_cnt   := 1;
                bd_max_fill_len  := a_mblock.mb_data_size;
                bd_next          := true;
                END;
            (*ENDWITH*) 
&           ifdef TRACE
            t01int4 (ak_sem, 'mtype       ', ord(mtype));
            t01int4 (ak_sem, 'pos         ', pos  );
            t01int4 (ak_sem, 'res_nextpos ', res_nextpos);
            t01int4 (ak_sem, 'res_prevpos ', res_prevpos);
&           endif
            IF  mtype = mm_search
            THEN
                BEGIN
                IF  (res_eof AND (pos >= 0)) OR
                    (res_bof AND (pos <= 0))
                THEN
                    a07_b_put_error (acv, e_row_not_found, 1)
                ELSE
                    BEGIN
                    IF  pos >= 0
                    THEN
                        BEGIN
                        IF  NOT res_bof
                        THEN
                            pos := res_nextpos + pos
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  res_eof
                        THEN
                            pos := res_actres + 1 + pos
                        ELSE
                            pos := res_prevpos + pos;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  pos <= 0
                    THEN
                        BEGIN
                        res_bof := true;
                        res_eof := false;
                        a07_b_put_error (acv, e_row_not_found, 1)
                        END
                    ELSE
                        mtype := mm_direct;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                IF  mtype = mm_same
                THEN
                    IF  res_bof OR res_eof
                    THEN
                        a07_b_put_error (acv,
                              e_current_of_needs_fetch, 1)
                    ELSE
                        IF  res_prevpos > 0
                        THEN
                            BEGIN
                            mtype := mm_direct;
                            pos   := res_prevpos
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  mtype = mm_direct
            THEN
                BEGIN
                IF  pos < 0
                THEN
                    pos := res_actres + pos + 1;
                (*ENDIF*) 
                IF  (pos > res_actres) OR
                    ((res_upper_limit <> cgg04_no_rowno_predicate) AND (pos > res_upper_limit))
                THEN
                    BEGIN
                    res_bof := false;
                    res_eof := true;
                    a07_b_put_error (acv, e_row_not_found, 1)
                    END
                ELSE
                    IF  (pos <= 0) OR
                        ((res_limit_offset <> cgg04_no_rowno_predicate) AND (pos < res_limit_offset))
                    THEN
                        BEGIN
                        res_bof := true;
                        res_eof := false;
                        a07_b_put_error (acv, e_row_not_found, 1)
                        END
                    ELSE
                        BEGIN
                        IF  res_order
                        THEN
                            BEGIN
                            ak73one_before_pos (acv, sparr, pos);
                            IF  pos = res_nextpos
                            THEN
                                BEGIN
                                not_null := false;
                                WITH res_nextkeys.reckeyspec DO
                                    BEGIN
                                    REPEAT
                                        IF  res_keysbuf[ ks_pos+ks_len-1 ] = chr(0)
                                        THEN
                                            ks_len      := pred(ks_len)
                                        ELSE
                                            not_null := true
                                        (*ENDIF*) 
                                    UNTIL
                                        (ks_len = 0) OR not_null;
                                    (*ENDREPEAT*) 
                                    IF  ks_len > 0
                                    THEN
                                        BEGIN
                                        res_keysbuf[ ks_pos+ks_len-1 ] :=
                                              chr(pred(ord(res_keysbuf[ ks_pos+ks_len-1 ])));
                                        SAPDB_PascalFill ('VAK73 ',  11,    
                                              sizeof(res_keysbuf),
                                              @res_keysbuf, ks_pos+ks_len,
                                              res_keylen-ks_len, chr(255),
                                              a_returncode);
                                        ks_len := res_keylen
                                        END
                                    (*ENDIF*) 
                                    END;
                                (*ENDWITH*) 
                                res_nextpos := pred(res_nextpos)
                                END;
                            (*ENDIF*) 
                            mtype := mm_next;
                            res_bof := false
                            END
                        ELSE
                            BEGIN
                            s20int4_to_buf_swap (pos-1, g01code.kernel_swap,
                                  res_keysbuf, res_nextkeys.reckeyspec.ks_pos,
                                  sw_normal);
                            res_nextkeys.reckeyspec.ks_len := res_keylen;
                            res_nextpos             := pos-1;
                            mtype                   := mm_next;
                            res_bof                 := false
                            END
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                IF  ((mtype = mm_first) OR
                    ((mtype = mm_next) AND res_bof))
                THEN
                    BEGIN
                    res_nextpos             := 0;
                    res_nextkeys.reckeyspec.ks_len := 0
                    END
                ELSE
                    IF  ((mtype = mm_last) OR
                        ((mtype = mm_prev) AND res_eof) OR
                        ((mtype = mm_next) AND res_eof))
                        (* pos > res_actres *)
                    THEN
                        BEGIN
                        WITH res_prevkeys.reckeyspec DO
                            SAPDB_PascalFill ('VAK73 ',  12,    
                                  sizeof(res_keysbuf),
                                  @res_keysbuf, ks_pos,
                                  res_keylen, chr(255),
                                  a_returncode);
                        (*ENDWITH*) 
                        res_prevpos                    := res_actres+1;
                        res_prevkeys.reckeyspec.ks_len := res_keylen
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                firstres := true;
                mfr_b_err    := e_buffer_limit;
                IF  mtype in [ mm_first, mm_next ]
                THEN
                    BEGIN
                    mfr_count2         := 0;
                    IF  (res_upper_limit <> cgg04_no_rowno_predicate) AND
                        (res_nextpos + mfr_count1 > res_upper_limit)
                    THEN
                        BEGIN
                        mfr_count1 := res_upper_limit - res_nextpos;
                        IF  mfr_count1 < 1
                        THEN
                            mfr_b_err := e_no_next_record;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
                    WHILE ((a_returncode = 0) AND (mfr_count2 < mfr_count1) AND
                          (mfr_b_err = e_buffer_limit)) DO
                        BEGIN
                        set_result.bd_max_rec_cnt := mfr_count1-mfr_count2;
                        bd_lkey.len := res_nextkeys.reckeyspec.ks_len;
                        SAPDB_PascalMove ('VAK73 ',  13,    
                              sizeof(res_keysbuf), sizeof(tsp00_Key),
                              @res_keysbuf, res_nextkeys.reckeyspec.ks_pos,
                              @bd_lkey.k, 1, bd_lkey.len,
                              a_returncode);
                        IF  a_returncode = 0
                        THEN
                            BEGIN
                            b07cnext_record (a_transinf.tri_trans,
                                  res_restree, bd_lkey,
                                  set_result, tree_pos, mb_data^.mbp_buf);
                            IF  a_transinf.tri_trans.trError_gg00 = e_key_not_found
                            THEN
                                mfr_b_err := e_ok
                            ELSE
                                mfr_b_err := a_transinf.tri_trans.trError_gg00
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  ((mfr_b_err <> e_ok)           AND
                            ( mfr_b_err <> e_buffer_limit) AND
                            ( mfr_b_err <> e_no_next_record))
                        THEN
                            a07_b_put_error (acv, mfr_b_err, 1)
                        ELSE
                            WITH a_mblock, mb_data^ DO
                                BEGIN
                                res_bof := false;
                                res_eof := false;
                                set_result.bd_next := false;
                                mfr_cnt := set_result.bd_rec_cnt;
                                IF  (firstres AND (mfr_cnt > 0))
                                THEN
                                    IF  res_keylen <> mbp_keylen
                                    THEN
                                        a07_b_put_error (acv, e_too_long_key, 1)
                                    ELSE
                                        IF  res_reclen <> mbp_reclen
                                        THEN
                                            a07_b_put_error (acv, e_too_long_record, 1)
                                        ELSE
                                            BEGIN
                                            firstres                := false;
                                            SAPDB_PascalMove ('VAK73 ',  14,    
                                                  mb_data_size, sizeof(res_keysbuf),
                                                  @mbp_buf, cgg_rec_key_offset + 1,
                                                  @res_keysbuf, res_prevkeys.reckeyspec.ks_pos,
                                                  res_keylen,
                                                  a_returncode);
                                            res_prevpos             :=
                                                  succ(res_nextpos);
                                            res_prevkeys.reckeyspec.ks_len := res_keylen
                                            END;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                start := 1;
                                IF  unused_leng
                                    < a_curr_retpart^.sp1p_buf_len + (mfr_cnt * mfr_reclength)
                                THEN
                                    a07_b_put_error (acv, e_stack_overflow, 1);
                                (*ENDIF*) 
                                mfr_count2      := mfr_count2+mfr_cnt;
                                res_nextpos := res_nextpos+mfr_cnt;
                                IF  (a_returncode = 0) AND
                                    res_for_update AND (mfr_count1 = 1)
                                THEN
                                    BEGIN
                                    res_useupdk := res_upd_tabcnt;
                                    SAPDB_PascalMove ('VAK73 ',  15,    
                                          mb_data_size, sizeof(res_keysbuf),
                                          @mbp_buf, res_length+1, @res_keysbuf,
                                          res_updkey.ks_pos, res_reclen-res_length,
                                          a_returncode);
                                    END;
                                (*ENDIF*) 
                                IF  a_returncode = 0
                                THEN
                                    BEGIN
                                    FOR i := 1 TO mfr_cnt DO
                                        BEGIN
                                        a60_change_results (acv,
                                              mb_data^.mbp_buf,
                                              res_change, start - 1,
                                              mfr_reclength + cgg_rec_key_offset+res_keylen);
                                        a06retpart_move (acv,
                                              @mbp_buf [start+
                                              cgg_rec_key_offset+res_keylen], mfr_reclength);
                                        IF  (i = mfr_cnt) AND
                                            (a_returncode = 0)
                                        THEN
                                            BEGIN
                                            SAPDB_PascalMove ('VAK73 ',  16,    
                                                  mb_data_size,
                                                  sizeof(res_keysbuf),
                                                  @mb_data^.mbp_buf, start+cgg_rec_key_offset,
                                                  @res_keysbuf,
                                                  res_nextkeys.reckeyspec.ks_pos,
                                                  res_keylen, a_returncode);
                                            res_nextkeys.reckeyspec.ks_len :=
                                                  res_keylen
                                            END;
                                        (*ENDIF*) 
                                        start := start+res_reclen
                                        END
                                    (*ENDFOR*) 
                                    END
                                (*ENDIF*) 
                                END
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWHILE*) 
                    IF  mfr_b_err = e_no_next_record
                    THEN
                        BEGIN
                        res_eof := true;
                        (* h.b. 22.08.1995
                              <ROW NOT FOUND> should be given for EXECUTE too
                              IF  ((mfr_count2 > 0) OR (a_ex_kind = only_executing))
                              *)
                        IF  (mfr_count2 > 0)
                        THEN
                            mfr_b_err := e_ok
                        ELSE
                            BEGIN
                            res_bof := false;
                            a07_b_put_error (acv, e_row_not_found, 1)
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    mfr_count2 := 0;
                    IF  a_curr_retpart^.sp1p_buf_len + mfr_count1 * mfr_reclength >
                        a_curr_retpart^.sp1p_buf_size
                    THEN
                        (* PTS 1116801 E.Z. *)
                        a07_b_put_error (acv, e_stack_overflow, 1)
                    ELSE
                        a_curr_retpart^.sp1p_buf_len :=
                              a_curr_retpart^.sp1p_buf_len + mfr_count1 * mfr_reclength;
                    (*ENDIF*) 
                    tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
                    WHILE ((a_returncode = 0) AND (mfr_count2 < mfr_count1) AND
                          (mfr_b_err = e_buffer_limit)) DO
                        BEGIN
                        set_result.bd_max_rec_cnt := mfr_count1-mfr_count2;
                        bd_lkey.len := res_prevkeys.reckeyspec.ks_len;
                        SAPDB_PascalMove ('VAK73 ',  17,    
                              sizeof(res_keysbuf), sizeof(tsp00_Key),
                              @res_keysbuf, res_prevkeys.reckeyspec.ks_pos,
                              @bd_lkey.k, 1, bd_lkey.len,
                              a_returncode);
                        IF  a_returncode = 0
                        THEN
                            BEGIN
                            b07cprev_record (a_transinf.tri_trans,
                                  res_restree, bd_lkey,
                                  set_result, tree_pos, mb_data^.mbp_buf);
                            IF  a_transinf.tri_trans.trError_gg00 = e_key_not_found
                            THEN
                                mfr_b_err := e_ok
                            ELSE
                                mfr_b_err := a_transinf.tri_trans.trError_gg00
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  ((mfr_b_err <> e_ok)           AND
                            ( mfr_b_err <> e_buffer_limit) AND
                            ( mfr_b_err <> e_no_prev_record))
                        THEN
                            a07_b_put_error (acv, mfr_b_err, 1)
                        ELSE
                            WITH a_mblock, mb_data^ DO
                                BEGIN
                                res_bof := false;
                                res_eof := false;
                                set_result.bd_next := false;
                                mfr_cnt := set_result.bd_rec_cnt;
                                IF  (firstres AND (mfr_cnt > 0))
                                THEN
                                    IF  res_keylen <> mbp_keylen
                                    THEN
                                        a07_b_put_error (acv, e_too_long_key, 1)
                                    ELSE
                                        IF  res_reclen <> mbp_reclen
                                        THEN
                                            a07_b_put_error (acv, e_too_long_record, 1)
                                        ELSE
                                            BEGIN
                                            firstres                := false;
                                            SAPDB_PascalMove ('VAK73 ',  18,    
                                                  mb_data_size,
                                                  sizeof(res_keysbuf),
                                                  @mbp_buf, cgg_rec_key_offset + 1,
                                                  @res_keysbuf,
                                                  res_nextkeys.reckeyspec.ks_pos,
                                                  res_keylen, a_returncode);
                                            res_nextpos             :=
                                                  pred(res_prevpos);
                                            res_nextkeys.reckeyspec.ks_len := res_keylen
                                            END;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                IF  (a_returncode = 0) AND
                                    (res_for_update AND (mfr_count1 = 1))
                                THEN
                                    BEGIN
                                    res_useupdk := res_upd_tabcnt;
                                    SAPDB_PascalMove ('VAK73 ',  19,    
                                          mb_data_size, sizeof(res_keysbuf),
                                          @mb_data^.mbp_buf, res_length+1, @res_keysbuf,
                                          res_updkey.ks_pos, res_reclen-res_length,
                                          a_returncode);
                                    END;
                                (*ENDIF*) 
                                IF  a_returncode = 0
                                THEN
                                    BEGIN
                                    start := 1;
                                    FOR i := 1 TO mfr_cnt DO
                                        BEGIN
                                        a60_change_results (acv,
                                              mb_data^.mbp_buf,
                                              res_change, start - 1,
                                              mfr_reclength + cgg_rec_key_offset+res_keylen);
                                        SAPDB_PascalMove ('VAK73 ',  20,    
                                              mb_data_size,
                                              a_curr_retpart^.sp1p_buf_size,
                                              @mb_data^.mbp_buf,
                                              start + cgg_rec_key_offset + res_keylen,
                                              @a_curr_retpart^.sp1p_buf,
                                              1 + (mfr_count1 - mfr_count2 - i) * mfr_reclength, mfr_reclength,
                                              a_returncode);
                                        IF  (i = mfr_cnt) AND
                                            (a_returncode = 0)
                                        THEN
                                            BEGIN
                                            SAPDB_PascalMove ('VAK73 ',  21,    
                                                  mb_data_size,
                                                  sizeof(res_keysbuf),
                                                  @mb_data^.mbp_buf,
                                                  start+cgg_rec_key_offset, @res_keysbuf,
                                                  res_prevkeys.reckeyspec.ks_pos,
                                                  res_keylen,
                                                  a_returncode);
                                            res_prevkeys.reckeyspec.ks_len :=
                                                  res_keylen
                                            END;
                                        (*ENDIF*) 
                                        start := start + res_reclen
                                        END;
                                    (*ENDFOR*) 
                                    res_prevpos := res_prevpos-mfr_cnt;
                                    mfr_count2      := mfr_count2 + mfr_cnt
                                    END
                                (*ENDIF*) 
                                END
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    (*ENDWHILE*) 
                    IF  mfr_b_err = e_no_prev_record
                    THEN
                        BEGIN
                        res_bof := true;
                        (* h.b. 22.08.1995
                              <ROW NOT FOUND> should be given for EXECUTE too
                              IF  ((mfr_count2 > 0) OR (a_ex_kind = only_executing))
                              *)
                        IF  (mfr_count2 > 0)
                        THEN
                            mfr_b_err := e_ok
                        ELSE
                            BEGIN
                            res_eof := false;
                            a07_b_put_error (acv, e_row_not_found, 1);
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  ((mfr_count2 < mfr_count1) AND (a_returncode = 0))
                    THEN
                        BEGIN
                        SAPDB_PascalOverlappingMove ('VAK73 ',  22,    
                              a_curr_retpart^.sp1p_buf_size,
                              a_curr_retpart^.sp1p_buf_size,
                              @a_curr_retpart^.sp1p_buf,
                              (mfr_count1 * mfr_reclength) - (mfr_count2 * mfr_reclength) + 1,
                              @a_curr_retpart^.sp1p_buf,
                              1, mfr_count2*mfr_reclength,
                              a_returncode);
                        a_curr_retpart^.sp1p_buf_len := mfr_count2 * mfr_reclength
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&               IFDEF TRACE
                t01int4 (bi, 'res_nextpos ', res_nextpos);
                t01int4 (bi, 'res_prevpos ', res_prevpos);
&               ENDIF
                IF  (lcol_found AND (mfr_cnt > 0))
                THEN
                    (* PTS 1111576 E.Z. *)
                    BEGIN
                    lcol_lock := true;
                    a508_lget_long_columns (acv, res_change, lcol_lock, mfr_count2,
                          mfr_reclength, - (res_keylen + cgg_rec_key_offset));
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  (mfr_count2 < mfr_count1)
        THEN
            a_curr_retpart^.sp1p_attributes := [ sp1pa_last_packet ];
        (*ENDIF*) 
        a06finish_curr_retpart (acv, sp1pk_data, mfr_count2);
        IF  a01diag_monitor_on OR a01diag_analyze_on
        THEN
            b21mp_rows_fetched_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00, mfr_count2);
        (* PTS 1116801 E.Z. *)
        (*ENDIF*) 
        a60rescount (acv, px[ 2 ]^.sreskey.res_nextpos);
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a73_one_fetch (
            VAR acv      : tak_all_command_glob;
            VAR sparr    : tak_syspointerarr;
            mtype        : tgg00_MessType2;
            pos          : tsp00_Int4);
 
VAR
      _fetch_from_user : boolean;
      _mfr_b_err       : tgg00_BasisError;
      _set_result      : tgg00_BdSetResultRecord;
      _tree_pos        : tgg00_FilePos;
      _lcol_found      : boolean;
      _lcol_lock       : boolean;
      _func_code       : integer;
      _bd_lkey         : tgg00_Lkey;
 
BEGIN
_lcol_found := false;
_fetch_from_user := true;
IF  (acv.a_ex_kind = only_executing) AND (sparr.px[1] <> NIL)
THEN
    BEGIN
    IF  sparr.px[ 1 ]^.sparsinfo.p_function_code > csp1_min_masscmd_fc
    THEN
        _func_code := sparr.px[ 1 ]^.sparsinfo.p_function_code -
              csp1_min_masscmd_fc
    ELSE
        _func_code := sparr.px[ 1 ]^.sparsinfo.p_function_code;
    (*ENDIF*) 
    IF  (_func_code <> csp1_fetch_relative_fc) AND
        ((_func_code < csp1_fetch_first_fc) OR
        ( _func_code > csp1_fetch_same_fc))
    THEN (* where pos of *)
        _fetch_from_user := false;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    IF  (sparr.px[ 2 ]^.sreskey.res_change.cr_colcount > 0) AND
        _fetch_from_user
    THEN
        _lcol_found := a508_lcol_found (acv, sparr.px[ 2 ]^.sreskey.res_change);
    (*ENDIF*) 
    ;
&   IFDEF TRACE
    t01mess2type( ak_sem, 'mtype       ', mtype );
    t01int4 (ak_sem, 'res_nextpos ', sparr.px[ 2 ]^.sreskey.res_nextpos);
    t01int4 (ak_sem, 'res_prevpos ', sparr.px[ 2 ]^.sreskey.res_prevpos);
    t01int4 (ak_sem, 'res_reclen  ', sparr.px[ 2 ]^.sreskey.res_reclen);
    t01int4 (ak_sem, 'res_keylen  ', sparr.px[ 2 ]^.sreskey.res_keylen);
&   ENDIF
    _set_result.bd_key_check_len := 0;
    _set_result.bd_max_rec_cnt   := 1;
    _set_result.bd_max_fill_len  := acv.a_mblock.mb_data_size;
    _set_result.bd_next          := true;
    _mfr_b_err := e_ok;
    a09activate_lock (acv.a_transinf.tri_trans, acv.a_work_st_addr,
          acv.a_work_st_max, _mfr_b_err);
    IF  ( _mfr_b_err = e_rollback_wanted )
    THEN
        BEGIN
        acv.a_rollback_info := [ trans_rollback, new_trans ];
        _mfr_b_err := e_work_rolled_back
        END;
    (*ENDIF*) 
    IF  ( _mfr_b_err <> e_ok )
    THEN
        a07_b_put_error (acv, _mfr_b_err, 1)
    ELSE
        BEGIN
        IF  ( mtype = mm_search )
        THEN
            BEGIN
            IF  (sparr.px[ 2 ]^.sreskey.res_eof AND (pos >= 0)) OR
                (sparr.px[ 2 ]^.sreskey.res_bof AND (pos <= 0))
            THEN
                a07_b_put_error (acv, e_row_not_found, 1)
            ELSE
                BEGIN
                IF  ( pos >= 0 )
                THEN
                    BEGIN
                    IF  NOT sparr.px[ 2 ]^.sreskey.res_bof
                    THEN
                        pos := sparr.px[ 2 ]^.sreskey.res_nextpos + pos
                    (*ENDIF*) 
                    END
                ELSE
                    IF  sparr.px[ 2 ]^.sreskey.res_eof
                    THEN
                        pos := sparr.px[ 2 ]^.sreskey.res_actres + 1 + pos
                    ELSE
                        pos := sparr.px[ 2 ]^.sreskey.res_prevpos + pos;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  ( pos <= 0 )
                THEN
                    BEGIN
                    sparr.px[ 2 ]^.sreskey.res_bof := true;
                    sparr.px[ 2 ]^.sreskey.res_eof := false;
                    a07_b_put_error (acv, e_row_not_found, 1)
                    END
                ELSE
                    mtype := mm_direct;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  ( mtype = mm_direct )
        THEN
            BEGIN
            IF  ( pos < 0 )
            THEN
                pos := sparr.px[ 2 ]^.sreskey.res_actres + pos + 1;
            (*ENDIF*) 
            IF  ( pos > sparr.px[ 2 ]^.sreskey.res_actres ) OR
                ((sparr.px[ 2 ]^.sreskey.res_upper_limit <> cgg04_no_rowno_predicate) AND
                (pos > sparr.px[ 2 ]^.sreskey.res_upper_limit))
            THEN
                BEGIN
                sparr.px[ 2 ]^.sreskey.res_bof := false;
                sparr.px[ 2 ]^.sreskey.res_eof := true;
                a07_b_put_error (acv, e_row_not_found, 1);
                END
            ELSE
                IF  (pos <= 0) OR
                    ((sparr.px[ 2 ]^.sreskey.res_limit_offset <> cgg04_no_rowno_predicate) AND
                    (pos < sparr.px[ 2 ]^.sreskey.res_limit_offset))
                THEN
                    BEGIN
                    sparr.px[ 2 ]^.sreskey.res_bof := true;
                    sparr.px[ 2 ]^.sreskey.res_eof := false;
                    a07_b_put_error (acv, e_row_not_found, 1);
                    END
                ELSE
                    BEGIN
                    IF  ( sparr.px[ 2 ]^.sreskey.res_order )
                    THEN
                        BEGIN
                        ak73one_before_pos (acv, sparr, pos);
                        IF  ( acv.a_returncode = 0 )
                        THEN
                            BEGIN
                            _bd_lkey.len :=
                                  sparr.px[ 2 ]^.sreskey.res_nextkeys.reckeyspec.ks_len;
                            SAPDB_PascalMove ('VAK73 ',  23,    
                                  sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
                                  sizeof(tsp00_Key),
                                  @sparr.px[ 2 ]^.sreskey.res_keysbuf,
                                  sparr.px[ 2 ]^.sreskey.res_nextkeys.
                                  reckeyspec.ks_pos,
                                  @_bd_lkey.k, 1, _bd_lkey.len, acv.a_returncode);
                            IF  ( acv.a_returncode = 0 )
                            THEN
                                BEGIN
                                IF  ( pos = sparr.px[ 2 ]^.sreskey.res_nextpos )
                                THEN
                                    b07cget_record (acv.a_transinf.tri_trans,
                                          sparr.px[ 2 ]^.sreskey.res_restree,
                                          _bd_lkey,
                                          acv.a_mblock.mb_data^.mbp_rec)
                                ELSE
                                    BEGIN
                                    _tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
                                    b07cnext_record (acv.a_transinf.tri_trans,
                                          sparr.px[ 2 ]^.sreskey.res_restree,
                                          _bd_lkey, _set_result, _tree_pos,
                                          acv.a_mblock.mb_data^.mbp_buf);
                                    END;
                                (*ENDIF*) 
                                IF  ( acv.a_transinf.tri_trans.trError_gg00 =
                                    e_key_not_found )
                                THEN
                                    _mfr_b_err := e_ok
                                ELSE
                                    _mfr_b_err :=
                                          acv.a_transinf.tri_trans.trError_gg00;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  (( _mfr_b_err = e_no_next_record ) AND
                                ( _set_result.bd_rec_cnt = 0 ))
                            THEN
                                a07_b_put_error (acv, e_row_not_found, 1)
                            ELSE
                                IF  ( _mfr_b_err <> e_ok )
                                THEN
                                    a07_b_put_error (acv, _mfr_b_err, 1)
                                ELSE
                                    BEGIN
                                    SAPDB_PascalMove ('VAK73 ',  24,    
                                          acv.a_mblock.mb_data_size,
                                          sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
                                          @acv.a_mblock.mb_data^.mbp_buf,
                                          cgg_rec_key_offset + 1,
                                          @sparr.px[ 2 ]^.sreskey.res_keysbuf,
                                          sparr.px[ 2 ]^.sreskey.res_nextkeys.
                                          reckeyspec.ks_pos,
                                          acv.a_mblock.mb_data^.mbp_keylen,
                                          acv.a_returncode);
                                    sparr.px[ 2 ]^.sreskey.res_nextkeys.
                                          reckeyspec.ks_len :=
                                          acv.a_mblock.mb_data^.mbp_keylen;
                                    IF  ( pos <> sparr.px[ 2 ]^.sreskey.
                                        res_nextpos )
                                    THEN
                                        sparr.px[ 2 ]^.sreskey.res_nextpos :=
                                              succ(sparr.px[ 2 ]^.sreskey.
                                              res_nextpos);
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        s20int4_to_buf_swap (pos, g01code.kernel_swap,
                              sparr.px[ 2 ]^.sreskey.res_keysbuf,
                              sparr.px[ 2 ]^.sreskey.res_nextkeys.reckeyspec.ks_pos, sw_normal);
                        sparr.px[ 2 ]^.sreskey.res_nextkeys.
                              reckeyspec.ks_len := sparr.px[ 2 ]^.sreskey.
                              res_keylen;
                        _bd_lkey.len := sparr.px[ 2 ]^.sreskey.
                              res_nextkeys.reckeyspec.ks_len;
                        SAPDB_PascalMove ('VAK73 ',  25,    
                              sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
                              sizeof(tsp00_Key),
                              @sparr.px[ 2 ]^.sreskey.res_keysbuf,
                              sparr.px[ 2 ]^.sreskey.res_nextkeys.
                              reckeyspec.ks_pos,
                              @_bd_lkey.k, 1, _bd_lkey.len, acv.a_returncode);
                        IF  ( acv.a_returncode = 0 )
                        THEN
                            BEGIN
                            sparr.px[ 2 ]^.sreskey.res_nextpos := pos;
                            b07cget_record (acv.a_transinf.tri_trans,
                                  sparr.px[ 2 ]^.sreskey.res_restree, _bd_lkey, acv.a_mblock.mb_data^.mbp_rec);
                            IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                            THEN
                                a07_b_put_error (acv,
                                      acv.a_transinf.tri_trans.trError_gg00, 1)
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  ( _fetch_from_user )
                    THEN
                        a60rescount (acv, 1);
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  (( mtype = mm_first ) OR
                (( mtype = mm_next ) AND sparr.px[ 2 ]^.sreskey.res_bof ))
            THEN
                BEGIN
                sparr.px[ 2 ]^.sreskey.res_nextpos                    := 0;
                sparr.px[ 2 ]^.sreskey.res_nextkeys.reckeyspec.ks_len := 0
                END
            ELSE
                BEGIN
                IF  (( mtype = mm_last ) OR
                    (( mtype = mm_prev ) AND sparr.px[ 2 ]^.sreskey.res_eof ) OR
                    (( mtype = mm_next ) AND sparr.px[ 2 ]^.sreskey.res_eof ))
                    (* pos > res_actres *)
                THEN
                    BEGIN
                    SAPDB_PascalFill ('VAK73 ',  26,    
                          sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
                          @sparr.px[ 2 ]^.sreskey.res_keysbuf,
                          sparr.px[ 2 ]^.sreskey.res_prevkeys.
                          reckeyspec.ks_pos,
                          sparr.px[ 2 ]^.sreskey.res_keylen, chr(255),
                          acv.a_returncode);
                    sparr.px[ 2 ]^.sreskey.res_prevpos :=
                          sparr.px[ 2 ]^.sreskey.res_actres + 1;
                    sparr.px[ 2 ]^.sreskey.res_prevkeys.
                          reckeyspec.ks_len := sparr.px[ 2 ]^.sreskey.res_keylen
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  ( acv.a_returncode = 0 ) AND
                ( acv.a_qualified_jv_upd = no_jv_upd )
            THEN
                (* PTS 1116801 E.Z. *)
                a60rescount (acv, succ(sparr.px[ 2 ]^.sreskey.res_nextpos));
            (*ENDIF*) 
            IF  ( acv.a_returncode = 0 )
            THEN
                BEGIN
                IF  mtype in [ mm_first, mm_next ]
                THEN
                    BEGIN
                    _tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
                    _bd_lkey.len := sparr.px[ 2 ]^.sreskey.
                          res_nextkeys.reckeyspec.ks_len;
                    SAPDB_PascalMove ('VAK73 ',  27,    
                          sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
                          sizeof(tsp00_Key),
                          @sparr.px[ 2 ]^.sreskey.res_keysbuf,
                          sparr.px[ 2 ]^.sreskey.res_nextkeys.reckeyspec.ks_pos,
                          @_bd_lkey.k, 1, _bd_lkey.len,
                          acv.a_returncode);
&                   ifdef TRACE
                    t01int4 (ak_sem, 'upper_limit ', sparr.px[ 2 ]^.sreskey.res_upper_limit);
                    t01int4 (ak_sem, 'nextpos     ', sparr.px[ 2 ]^.sreskey.res_nextpos);
&                   endif
                    IF  ((sparr.px[ 2 ]^.sreskey.res_upper_limit <> cgg04_no_rowno_predicate) AND
                        (succ(sparr.px[ 2 ]^.sreskey.res_nextpos) > sparr.px[ 2 ]^.sreskey.res_upper_limit))
                    THEN
                        _mfr_b_err := e_no_next_record
                    ELSE
                        IF  acv.a_returncode = 0
                        THEN
                            BEGIN
                            b07cnext_record (acv.a_transinf.tri_trans,
                                  sparr.px[ 2 ]^.sreskey.res_restree, _bd_lkey,
                                  _set_result, _tree_pos,
                                  acv.a_mblock.mb_data^.mbp_buf);
                            _mfr_b_err := acv.a_transinf.tri_trans.trError_gg00
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  (( _mfr_b_err = e_ok ) OR ( _mfr_b_err = e_key_not_found ))
                    THEN
                        sparr.px[ 2 ]^.sreskey.res_nextpos := succ(sparr.px[ 2 ]^.sreskey.res_nextpos)
                    ELSE
                        IF  ( _mfr_b_err = e_no_next_record )
                        THEN
                            BEGIN
                            sparr.px[ 2 ]^.sreskey.res_eof := true;
                            sparr.px[ 2 ]^.sreskey.res_bof := false;
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  ( mtype = mm_same )
                    THEN
                        BEGIN
                        IF  ( sparr.px[ 2 ]^.sreskey.res_bof OR
                            sparr.px[ 2 ]^.sreskey.res_eof )
                        THEN
                            a07_b_put_error (acv, e_current_of_needs_fetch, 1)
                        ELSE
                            BEGIN
                            _bd_lkey.len := sparr.px[ 2 ]^.sreskey.res_nextkeys.reckeyspec.ks_len;
                            SAPDB_PascalMove ('VAK73 ',  28,    
                                  sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
                                  sizeof(tsp00_Key),
                                  @sparr.px[ 2 ]^.sreskey.res_keysbuf,
                                  sparr.px[ 2 ]^.sreskey.res_nextkeys.
                                  reckeyspec.ks_pos,
                                  @_bd_lkey.k, 1, _bd_lkey.len, acv.a_returncode);
                            IF  ( acv.a_returncode = 0 )
                            THEN
                                b07cget_record (acv.a_transinf.tri_trans,
                                      sparr.px[ 2 ]^.sreskey.res_restree,
                                      _bd_lkey, acv.a_mblock.mb_data^.mbp_rec);
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        _tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
                        _bd_lkey.len := sparr.px[ 2 ]^.sreskey.res_prevkeys.reckeyspec.ks_len;
                        SAPDB_PascalMove ('VAK73 ',  29,    
                              sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
                              sizeof(tsp00_Key),
                              @sparr.px[ 2 ]^.sreskey.res_keysbuf,
                              sparr.px[ 2 ]^.sreskey.res_prevkeys.
                              reckeyspec.ks_pos,
                              @_bd_lkey.k, 1, _bd_lkey.len, acv.a_returncode);
                        IF  ( acv.a_returncode = 0 )
                        THEN
                            BEGIN
                            b07cprev_record (acv.a_transinf.tri_trans,
                                  sparr.px[ 2 ]^.sreskey.res_restree, _bd_lkey,
                                  _set_result, _tree_pos, acv.a_mblock.mb_data^.mbp_buf);
                            _mfr_b_err := acv.a_transinf.tri_trans.trError_gg00;
                            END;
                        (*ENDIF*) 
                        IF  (( _mfr_b_err = e_ok ) OR
                            ( _mfr_b_err = e_key_not_found ))
                        THEN
                            sparr.px[ 2 ]^.sreskey.res_prevpos :=
                                  pred(sparr.px[ 2 ]^.sreskey.res_prevpos)
                        ELSE
                            IF  ( _mfr_b_err = e_no_prev_record )
                            THEN
                                BEGIN
                                sparr.px[ 2 ]^.sreskey.res_eof := false;
                                sparr.px[ 2 ]^.sreskey.res_bof := true
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  ((( _mfr_b_err = e_key_not_found ) AND
                ( mtype <> mm_same ))
                OR ( _mfr_b_err = e_buffer_limit ))
            THEN
                _mfr_b_err := e_ok;
            (*ENDIF*) 
            IF  ( _mfr_b_err <> e_ok )
            THEN
                a07_b_put_error (acv, _mfr_b_err, 1)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
&   IFDEF TRACE
    t01int4 (ak_sem, 'res_nextpos ', sparr.px[ 2 ]^.sreskey.res_nextpos);
    t01int4 (ak_sem, 'res_prevpos ', sparr.px[ 2 ]^.sreskey.res_prevpos);
&   ENDIF
    END;
(*ENDIF*) 
IF  ( acv.a_returncode <> 0 )
THEN
    sparr.px[ 2 ]^.sreskey.res_useupdk := 0
ELSE
    IF  ( sparr.px[ 2 ]^.sreskey.res_keylen <> acv.a_mblock.mb_data^.mbp_keylen )
    THEN
        a07_b_put_error (acv, e_too_long_key, 1)
    ELSE
        IF  ( sparr.px[ 2 ]^.sreskey.res_reclen <>
            acv.a_mblock.mb_data^.mbp_reclen )
        THEN
            a07_b_put_error (acv, e_too_long_record, 1);
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    sparr.px[ 2 ]^.sreskey.res_bof := false;
    sparr.px[ 2 ]^.sreskey.res_eof := false;
    SAPDB_PascalMove ('VAK73 ',  30,    
          acv.a_mblock.mb_data_size,
          sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
          @acv.a_mblock.mb_data^.mbp_buf, cgg_rec_key_offset+1,
          @sparr.px[ 2 ]^.sreskey.res_keysbuf,
          sparr.px[ 2 ]^.sreskey.res_nextkeys.reckeyspec.ks_pos,
          acv.a_mblock.mb_data^.mbp_keylen, acv.a_returncode)
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    sparr.px[ 2 ]^.sreskey.res_nextkeys.reckeyspec.ks_len :=
          acv.a_mblock.mb_data^.mbp_keylen;
    sparr.px[ 2 ]^.sreskey.res_prevkeys.reckeyspec.ks_len :=
          acv.a_mblock.mb_data^.mbp_keylen;
    SAPDB_PascalMove ('VAK73 ',  31,    
          sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
          sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
          @sparr.px[ 2 ]^.sreskey.res_keysbuf,
          sparr.px[ 2 ]^.sreskey.res_nextkeys.reckeyspec.ks_pos,
          @sparr.px[ 2 ]^.sreskey.res_keysbuf,
          sparr.px[ 2 ]^.sreskey.res_prevkeys.reckeyspec.ks_pos,
          acv.a_mblock.mb_data^.mbp_keylen, acv.a_returncode)
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    IF  mtype in [ mm_last, mm_prev ]
    THEN
        sparr.px[ 2 ]^.sreskey.res_nextpos :=
              sparr.px[ 2 ]^.sreskey.res_prevpos
    ELSE
        sparr.px[ 2 ]^.sreskey.res_prevpos :=
              sparr.px[ 2 ]^.sreskey.res_nextpos;
    (*ENDIF*) 
    acv.a_mblock.mb_data^.mbp_reclen := sparr.px[ 2 ]^.sreskey.res_length;
    acv.a_mblock.mb_data_len         := acv.a_mblock.mb_data^.mbp_reclen;
    IF  ( sparr.px[ 2 ]^.sreskey.res_for_update )
    THEN
        BEGIN
        sparr.px[ 2 ]^.sreskey.res_useupdk := sparr.px[ 2 ]^.sreskey.res_upd_tabcnt;
        SAPDB_PascalMove ('VAK73 ',  32,    
              acv.a_mblock.mb_data_size,
              sizeof(sparr.px[ 2 ]^.sreskey.res_keysbuf),
              @acv.a_mblock.mb_data^.mbp_buf,
              sparr.px[ 2 ]^.sreskey.res_length+1,
              @sparr.px[ 2 ]^.sreskey.res_keysbuf,
              sparr.px[ 2 ]^.sreskey.res_updkey.ks_pos,
              sparr.px[ 2 ]^.sreskey.res_reclen -
              sparr.px[ 2 ]^.sreskey.res_length, acv.a_returncode);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ( acv.a_returncode = 0 )
THEN
    BEGIN
    IF  (acv.a_qualified_jv_upd = no_jv_upd) AND _fetch_from_user
    THEN
        BEGIN
        a60_change_results (acv, acv.a_mblock.mb_data^.mbp_buf,
              sparr.px[ 2 ]^.sreskey.res_change, 0,
              sparr.px[ 2 ]^.sreskey.res_length);
        a60_put_result (acv, acv.a_mblock, cgg_rec_key_offset +
              sparr.px[ 2 ]^.sreskey.res_keylen);
        IF  _lcol_found AND ( acv.a_returncode = 0 )
        THEN
            BEGIN
            _lcol_lock := true;
            a508_lget_long_columns (acv, sparr.px[ 2 ]^.sreskey.res_change,
                  _lcol_lock, 1, sparr.px[ 2 ]^.sreskey.res_length,
                  - (acv.a_mblock.mb_data^.mbp_keylen + cgg_rec_key_offset))
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            a06finish_curr_retpart (acv, sp1pk_data, 1);
        (*ENDIF*) 
        END;
&   IFDEF TRACE
    (*ENDIF*) 
    t01moveobj (ak_sem, acv.a_mblock.mb_data^.mbp_buf, 1, acv.a_mblock.mb_data^.mbp_reclen);
    t01int4 (ak_sem, 'part2_len   ', acv.a_mblock.mb_data_len );
&   ENDIF
    END
(*ENDIF*) 
END;
 
(* PTS 1116801 E.Z. *)
(*------------------------------*) 
 
FUNCTION
      a73_calc_unused_space (
            VAR acv : tak_all_command_glob) : tsp00_Int4;
 
VAR
      length           : tsp00_Int4;
 
BEGIN
WITH acv DO
    BEGIN
    length := a_curr_retpart^.sp1p_buf_size;
    (* room for select_parsid *)
    IF  (a_ex_kind = only_executing) AND
        (
        (
        (a_return_segm^.sp1r_function_code >= csp1_fetch_first_fc) AND
        (a_return_segm^.sp1r_function_code <= csp1_fetch_same_fc)
        )
        OR
        (a_return_segm^.sp1r_function_code =  csp1_fetch_relative_fc)
        OR
        (
        (a_return_segm^.sp1r_function_code >= csp1_mfetch_first_fc) AND
        (a_return_segm^.sp1r_function_code <= csp1_mfetch_same_fc)
        )
        OR
        (a_return_segm^.sp1r_function_code =  csp1_mfetch_relative_fc)
        )
    THEN
        length := length - sizeof (tsp1_part_header) -
              a01aligned_cmd_len (mxak_parsid)
    ELSE
        IF  
            (a_return_segm^.sp1r_function_code =  csp1_fetch_relative_fc)
            OR
            (a_return_segm^.sp1r_function_code =  csp1_mfetch_relative_fc)
        THEN
            length := length - sizeof (tsp1_part_header) -
                  a01aligned_cmd_len (sizeof(tsp00_ResNum));
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
a73_calc_unused_space := length;
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
