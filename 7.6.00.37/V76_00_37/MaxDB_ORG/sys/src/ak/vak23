.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK23$
.tt 2 $$$
.TT 3 $ThomasA$AK_Synonym$1999-09-06$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
 
.fo
.nf
.sp
MODULE  : AK_Synonym
=========
.sp
Purpose :
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a23AttachPublicSequence (VAR acv : tak_all_command_glob;
                    VAR sequenceName : tsp00_KnlIdentifier;
                    VAR sequenceId   : tgg00_Surrogate;
                    VAR seqInfo      : tgg00_SeqInfo);
 
        PROCEDURE
              a23_call_semantic  (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a23change_syn_owner (VAR acv : tak_all_command_glob;
                    VAR synid    : tgg00_Surrogate;
                    VAR owner_id : tgg00_Surrogate);
 
        PROCEDURE
              a23create_sequence (VAR acv : tak_all_command_glob;
                    VAR sequence_id     : tgg00_Surrogate;
                    VAR sequence_schema : tgg00_Surrogate;
                    VAR sequence_name   : tsp00_KnlIdentifier;
                    VAR colinfo         : tak00_columninfo;
                    is_serial           : boolean;
                    is_temp_table       : boolean;
                    tree_index          : integer);
 
        PROCEDURE
              a23drop_sequence (VAR acv : tak_all_command_glob;
                    tableref      : tak_sysbufferaddress);
 
        FUNCTION
              a23exist_sequence (VAR acv : tak_all_command_glob;
                    tree_index      : integer;
                    inclusiveSerial : boolean;
                    VAR seq_buf     : tak_sysbufferaddress;
                    VAR seq_schema  : tsp00_KnlIdentifier;
                    VAR seq_name    : tsp00_KnlIdentifier) : boolean;
 
        PROCEDURE
              a23flush_sequence (VAR t : tgg00_TransContext;
                    VAR seq_surrogate : tgg00_Surrogate;
                    VAR seq_value     : tsp00_Number);
 
        PROCEDURE
              a23get_sequence_value (VAR t : tgg00_TransContext;
                    VAR seq_surrogate : tgg00_Surrogate;
                    VAR seq_value     : tsp00_Number;
                    VAR seq_first     : boolean);
 
        FUNCTION
              a23is_sequence_synonym (VAR synrec : tak_synonymrecord) : boolean;
 
        PROCEDURE
              a23new_version_no (VAR acv : tak_all_command_glob;
                    syn_base_ptr : tak_sysbufferaddress);
 
        PROCEDURE
              a23put_sequence_info (VAR acv : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock;
                    tree_index : integer);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05identifier_get (VAR acv : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05_li_constant_get (VAR acv : tak_all_command_glob;
                    ni               : integer;
                    VAR colinfo      : tak00_columninfo;
                    orig_len         : integer;
                    mv_dest          : integer;
                    VAR dest         : tsp00_C30;
                    destpos          : integer;
                    variable_length  : boolean;
                    VAR actlen       : integer);
 
      ------------------------------ 
 
        FROM
              AK_Domain : VAK12;
 
        PROCEDURE
              a12get_domain (VAR acv : tak_all_command_glob;
                    VAR owner       : tsp00_KnlIdentifier;
                    VAR domain_name : tsp00_KnlIdentifier;
                    ti              : integer;
                    VAR domain_ref  : tak_sysbufferaddress;
                    VAR domain_def  : tak_sysbufferaddress);
 
      ------------------------------ 
 
        FROM
              AK_Data_Type_Options : VAK14;
 
        FUNCTION
              a14LengthOfDefaultValue (
                    VAR DefaultRec : tak_defaultrecord) : integer; (* PTS 1108428 *)
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51RestoreUserContext (
                    VAR acv          : tak_all_command_glob;
                    VAR pOldContext  : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              AK_cold_utility_functions : VAK36;
 
        PROCEDURE
              a36get_catalog_record (VAR t : tgg00_TransContext;
                    VAR sysk   : tgg00_SysInfoKey;
                    VAR sysbuf : tak_sequencerecord);
 
      ------------------------------ 
 
        FROM
              AK_usertab_tools : VAK19;
 
        PROCEDURE
              a19add_usertab  (VAR acv : tak_all_command_glob;
                    VAR user       : tgg00_Surrogate;
                    VAR surrogate  : tgg00_Surrogate;
                    surrogate_desc : tak_usertab_descriptor);
 
        PROCEDURE
              a19del_usertab  (VAR acv : tak_all_command_glob;
                    VAR user      : tgg00_Surrogate;
                    VAR surrogate : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              AK_View_semantic : VAK16;
 
        PROCEDURE
              a16put_usage_def  (VAR acv : tak_all_command_glob;
                    VAR put_tableid   : tgg00_Surrogate;
                    VAR using_tableid : tgg00_Surrogate;
                    using_tablekind   : tgg00_TableKind);
 
      ------------------------------ 
 
        FROM
              AK_Table   : VAK11;
 
        PROCEDURE
              a11get_check_table (VAR acv : tak_all_command_glob;
                    new_table        : boolean;
                    basetable        : boolean;
                    unload_allowed   : boolean;
                    required_priv    : tak00_PrivilegeSet;
                    any_priv         : boolean;
                    all_base_rec     : boolean;
                    d_state          : tak_directory_state;
                    VAR act_tree_ind : tsp00_Int4;
                    VAR authid       : tsp00_KnlIdentifier;
                    VAR tablen       : tsp00_KnlIdentifier;
                    VAR d_sparr      : tak_syspointerarr);
 
        PROCEDURE
              a11drop_table  (VAR acv : tak_all_command_glob;
                    VAR tableid   : tgg00_Surrogate;
                    tablekind     : tgg00_TableKind;
                    succ_filevers : boolean);
 
        PROCEDURE
              a11table_reference (VAR acv : tak_all_command_glob;
                    VAR authid  : tgg00_Surrogate;
                    VAR tablen  : tsp00_KnlIdentifier;
                    tablekind   : tgg00_TableKind;
                    is_global   : boolean;
                    is_systable : boolean;
                    VAR tableid : tgg00_Surrogate);
 
        PROCEDURE
              a11put_date_time (VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10del_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10_del_tab_sysinfo  (VAR acv : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate;
                    VAR qual    : tak_del_tab_qual;
                    temp_table  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10_lock_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    lockm      : tgg00_LockReqMode);
 
        PROCEDURE
              a10next_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey    : tgg00_SysInfoKey;
                    stop_prefix   : integer;
                    dstate        : tak_directory_state;
                    rec_kind      : tsp00_C2;
                    VAR syspoint  : tak_sysbufferaddress;
                    VAR b_err     : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10repl_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_version (VAR acv : tak_all_command_glob;
                    VAR base_rec   : tak_baserecord;
                    m_type         : tgg00_MessType;
                    view_scan      : boolean);
 
        PROCEDURE
              a10get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_cache_delete  (VAR acv : tak_all_command_glob;
                    is_rollback : boolean);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_MapSchemaName (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier;
                    pos            : integer);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103CheckCreateInPrivilege (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer);
 
        PROCEDURE
              a103CheckDropInPrivilege (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer);
 
        PROCEDURE
              a103GetSchemaId (
                    VAR acv        : tak_all_command_glob;
                    VAR schemaName : tsp00_KnlIdentifier (* ptocConst *);
                    errorPos       : integer;
                    VAR schemaId   : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (VAR acv : tak_all_command_glob;
                    mtype        : tgg00_MessType;
                    m2type       : tgg00_MessType2;
                    VAR tree     : tgg00_FileId);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06get_priv  (VAR acv : tak_all_command_glob;
                    VAR brec      : tak_sysbufferaddress;
                    required_priv : tak00_PrivilegeSet;
                    VAR priv      : tak_privilege);
 
        PROCEDURE
              a06get_username (VAR acv : tak_all_command_glob;
                    VAR tree_index : integer;
                    VAR username   : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06rsend_mess_buf (VAR acv : tak_all_command_glob;
                    VAR mblock  : tgg00_MessBlock;
                    return_req  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a06userid_get (VAR acv : tak_all_command_glob;
                    VAR userid : tgg00_Surrogate;
                    VAR ok     : boolean);
 
        PROCEDURE
              a06_systable_get (VAR acv : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
        PROCEDURE
              a06_view_get_basetable (VAR acv : tak_all_command_glob;
                    VAR view_id  : tgg00_Surrogate;
                    tabno        : integer;
                    VAR base_id  : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (VAR acv : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07const_param (VAR acv : tak_all_command_glob;
                    param_no   : integer;
                    param_addr : tsp00_MoveObjPtr;
                    param_len  : integer);
 
        PROCEDURE
              a07_kw_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
        PROCEDURE
              a07_nb_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey        : tgg00_SysInfoKey;
              a01_i_temp           : tsp00_KnlIdentifier;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              KB_Logging: vkb560;
 
        PROCEDURE
              kb560GetSys2CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02repl_record (VAR t : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR b          : tak_sequencerecord);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01glob      : tgg00_KernelGlobals;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    src_upb  : tsp00_Int4;
                    dest_upb : tsp00_Int4;
                    src      : tsp00_MoveObjPtr;
                    src_pos  : tsp00_Int4;
                    dest     : tsp00_MoveObjPtr;
                    dest_pos : tsp00_Int4;
                    length   : tsp00_Int4;
                    VAR err  : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_Number;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              Number-Arithmetic : VSP51;
 
        PROCEDURE
              s51isint (
                    VAR source : tsp00_Number;
                    spos       : tsp00_Int4;
                    slen       : integer;
                    VAR isint  : boolean;
                    VAR ret    : tsp00_NumError);
 
        PROCEDURE
              s51neg (
                    VAR source     : tsp00_Number;
                    spos           : tsp00_Int4;
                    slen           : integer;
                    VAR result     : tsp00_Number;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
        PROCEDURE
              s51mul (
                    VAR left       : tsp00_Number;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_Number;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_Number;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
        PROCEDURE
              s51sub (
                    VAR left       : tsp00_Number;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_Number;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_Number;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj   tsp00_KnlIdentifier
 
        PROCEDURE
              a05_li_constant_get;
 
              tsp00_MoveObj tsp00_C30
 
        PROCEDURE
              a36get_catalog_record;
 
              tak_systembuffer tak_sequencerecord
 
        PROCEDURE
              b02repl_record;
 
              tgg00_Rec tak_sequencerecord
 
        PROCEDURE
              s41plint;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s51isint;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s51neg;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s51sub;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s51mul;
 
              tsp00_MoveObj tsp00_Number
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1985-04-09
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1999-09-06
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
PROCEDURE A23_CALL_SEMANTIC
.sp
This procedure emties the cache to be sure, that all catalog records,
that are read in the course of the sql statement, will be read via KB and
therefore will be locked.
It then branches to one of the procedures ak23create_sequence,
ak23create_synonyme, ak23drop_sequence or ak23drop_synonym.
.sp 3
PROCEDURE AK23CREATE_SEQUENCE
.sp
Creates the catalog record (tak_sequence_record),
that describes a sequence in the SQL-DB catalog.
The sequence is become known in the KB layer via the KB-Call
m_nextval, mm_write where the start value is stored in part1 of the
message buffer as 4 byte integer.
.sp 3
PROCEDURE AK23CREATE_SYNONYM
.sp
Creates the catalog records that describe a synonym in the SQL-DB catalog, i.e.
a tak_tablereference record and a tak_synonym record.
The records are stored replicated, if the table the synonym is created for, is
a replicated table.
The relationship between the table T for which the synonyme is defined and
the synonym itself is stored in a tak_usagerecord of T via a16put_usagedef.
.sp 4
PROCEDURE AK23DROP_SEQUENCE
.sp
Deletes the catalog record describing the sequence from the SQL-DB catalog.
All privileges, that have been granted for that sequence, are dropped too.
.sp 4
PROCEDURE AK23DROP_SYNONYM
.sp
Deletes the catalog records describing the synonym from the SQL-DB catalog.
This is done via a11drop_table.
.sp 4
FUNCTION AK23EXIST_SEQUENCE
.sp
Reads the name of the sequence from the sql statement, and checks wether
this sequence exists.
If this is true, the procedure returns true as well as the name of the
sequence and a pointer to the tak_sequence record, that describes the
sequence.
.sp 4
PROCEDURE AK23NEW_VERSIONNO
.sp
The procedure is called in the course of a create or drop synonyme statement.
Starting from the table the synonym is created for, the procedure tries to
find a base table, which is referenced by the table. The version number of
this table is incremented.
.sp
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_dummy           = false;
      c_global          = true;
      c_systable        = true;
      c_is_rollback     = true;
      c_inclusiveSerial = true;
      c_checkPrivilege  = true;
      c_variable_length = true;
 
 
(*------------------------------*) 
 
PROCEDURE
      a23AttachPublicSequence (VAR acv : tak_all_command_glob;
            VAR sequenceName : tsp00_KnlIdentifier;
            VAR sequenceId   : tgg00_Surrogate;
            VAR seqInfo      : tgg00_SeqInfo);
 
VAR
      e            : tgg00_BasisError;
      p            : tak_sysbufferaddress;
      refOwner     : tgg00_Surrogate;
      refSysk      : tgg00_SysInfoKey;
      sysk         : tgg00_SysInfoKey;
      DummyColInfo : tak00_columninfo;
 
BEGIN
acv.a_returncode := 0;
acv.a_is_ddl                       := ddl_create_sequence;
refOwner                           := cak_public_id;
refSysk                            := a01defaultkey;
refSysk.sauthid                    := refOwner;
refSysk.sentrytyp                  := cak_etableref;
refSysk.sidentifier                := sequenceName;
refSysk.skeylen                    := mxak_standard_sysk + sizeof (refSysk.sidentifier);
a10_lock_sysinfo (acv, refSysk, lckRowExcl_egg00);
a10get_sysinfo   (acv, refSysk, d_release, p, e);
IF  e = e_ok
THEN
    sequenceId := p^.stableref.rtableid
ELSE
    BEGIN
    a11table_reference (acv, refSysk.sauthid, sequenceName, tempty,
          NOT c_global, NOT c_systable, sequenceId);
    IF  acv.a_returncode = 0
    THEN
        a23create_sequence (acv, sequenceId, refSysk.sauthid, sequenceName, DummyColInfo, false, false, 0);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    sysk           := a01defaultkey;
    sysk.stableid  := sequenceId;
    sysk.sentrytyp := cak_esequence;
    a10get_sysinfo (acv, sysk, d_release, p, e);
    IF  e = e_ok
    THEN
        seqInfo := p^.ssequence.seq_info
    ELSE
        a07_b_put_error (acv, e, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
acv.a_is_ddl := no_ddl
END;
 
(*------------------------------*) 
 
PROCEDURE
      a23_call_semantic  (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv  DO
    BEGIN
    a10_cache_delete (acv, NOT c_is_rollback);
    CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc OF
        cak_x_create_sequence :
            ak23create_sequence (acv);
        cak_x_create_synonym :
            ak23create_synonym (acv,
                  a_ap_tree^[1].n_length = cak_i_public);
        cak_x_drop_synonym :
            ak23drop_synonym (acv);
        cak_x_drop_sequence :
            ak23drop_sequence (acv);
        OTHERWISE
            a07_b_put_error (acv, e_invalid_command, 1);
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a23change_syn_owner (VAR acv : tak_all_command_glob;
            VAR synid    : tgg00_Surrogate;
            VAR owner_id : tgg00_Surrogate);
 
VAR
      b_err    : tgg00_BasisError;
      syn_buf  : tak_sysbufferaddress;
      sysk     : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    sysk          := a01defaultkey;
    sysk.stableid := synid;
    a10get_sysinfo (acv, sysk, d_release, syn_buf, b_err);
    IF  b_err = e_ok
    THEN
        WITH syn_buf^.ssynonym DO
            IF  syn_owner = owner_id
            THEN
                BEGIN
                syn_owner := g01glob.sysuser_id;
                a10repl_sysinfo (acv, syn_buf, b_err)
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a23create_sequence (VAR acv : tak_all_command_glob;
            VAR sequence_id     : tgg00_Surrogate;
            VAR sequence_schema : tgg00_Surrogate;
            VAR sequence_name   : tsp00_KnlIdentifier;
            VAR colinfo         : tak00_columninfo;
            is_serial           : boolean;
            is_temp_table       : boolean;
            tree_index          : integer);
 
CONST
      c_default_cache_size = 20;
 
TYPE
      tseq_values = (seq_cache, seq_start, seq_incr, seq_min, seq_nocache, seq_max);
 
VAR
      init_ddl      : tak_ddl_descriptor;
      res           : tsp00_NumError;
      b_err         : tgg00_BasisError;
      ti            : integer;
      ix            : integer;
      err_node      : integer;
      seq_info_pos  : integer;
      len_byte      : integer;
      maxdigits     : integer;
      init_ti       : integer;
      seq_val_index : tseq_values;
      sysp          : tak_sysbufferaddress;
      dom_sysp      : tak_sysbufferaddress;
      domain_ref    : tak_sysbufferaddress;
      domain_def    : tak_sysbufferaddress;
      one_number    : tsp00_Number;
      sysk          : tgg00_SysInfoKey;
      dom_sysk      : tgg00_SysInfoKey;
      c24           : tsp00_C24;
      seq_nodes     : ARRAY [tseq_values] OF integer;
      seq_values    : ARRAY [tseq_values] OF tsp00_Number;
      owner         : tsp00_KnlIdentifier;
      domain_name   : tsp00_KnlIdentifier;
 
BEGIN
WITH acv DO
    BEGIN
    init_ti  := tree_index;
    init_ddl := a_is_ddl;
    a_is_ddl := ddl_create_sequence;
    IF  a_returncode = 0
    THEN
        BEGIN
        c24            := bsp_c24;
        err_node       := 0;
        sysk           := a01defaultkey;
        sysk.stableid  := sequence_id;
        IF  is_temp_table
        THEN
            sysk.sentrytyp := cak_etempdefault
        ELSE
            sysk.sentrytyp := cak_esequence;
        (*ENDIF*) 
        a10_nil_get_sysinfo (acv, sysk,
              d_fix, sizeof (tak_sequencerecord), sysp, b_err);
        IF  b_err = e_ok
        THEN
            WITH sysp^.ssequence DO
                BEGIN
                SAPDB_PascalForcedFill (sizeof (tak_sequencerecord),
                      @sysp^.ssequence, cak_sysbufferoffset + 1,
                      sizeof (tak_sequencerecord) - cak_sysbufferoffset,
                      chr(0));
                seq_owner     := a_curr_user_id;
                seq_comment   := false;
                seq_segmentid := cak00_local_segment_id;
                a11put_date_time (seq_date, seq_time);
                seq_info_pos            := 1;
                FOR seq_val_index := seq_cache TO seq_max DO
                    BEGIN
                    seq_values[seq_val_index] := csp_null_number;
                    seq_nodes [seq_val_index] := 0
                    END;
                (*ENDFOR*) 
                WHILE  tree_index > 0 DO
                    WITH a_ap_tree^[ tree_index ] DO
                        BEGIN
                        CASE n_subproc OF
                            cak_i_cache :
                                seq_val_index := seq_cache;
                            cak_i_increment :
                                seq_val_index := seq_incr;
                            cak_i_maxvalue :
                                seq_val_index := seq_max;
                            cak_i_minvalue :
                                seq_val_index := seq_min;
                            cak_i_nocache :
                                seq_val_index := seq_nocache;
                            cak_i_start    :
                                seq_val_index := seq_start;
                            END;
                        (*ENDCASE*) 
                        seq_nodes[seq_val_index] := tree_index;
                        ti         := n_lo_level;
                        tree_index :=
                              a_ap_tree^[ tree_index ].n_sa_level;
                        IF  seq_val_index <> seq_nocache
                        THEN
                            ak23one_seq_value (acv, colinfo,
                                  ti, seq_values[seq_val_index])
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
                IF  tree_index < 0
                THEN
                    BEGIN
                    tree_index := -tree_index;
                    a12get_domain (acv, owner, domain_name,
                          tree_index, domain_ref, domain_def);
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        dom_sysk           := domain_def^.syskey;
                        dom_sysk.sentrytyp := cak_edefault;
                        a10get_sysinfo (acv, dom_sysk, d_release,
                              dom_sysp, b_err);
                        IF  b_err = e_ok
                        THEN
                            SAPDB_PascalMove ('VAK23 ',   1,    
                                  sizeof (dom_sysp^.sdefault.dfvalues),
                                  sizeof (seq_values[seq_start]),
                                  @dom_sysp^.sdefault.dfvalues, 3,
                                  @seq_values[seq_start], 1,
                                  a14LengthOfDefaultValue (dom_sysp^.sdefault) - 1,
                                  b_err)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    IF  seq_values[seq_incr] = csp_null_number
                    THEN
                        s41plint (seq_values[seq_incr], 1,
                              (sizeof (tsp00_Number) -1) * 2, 0, 1, res)
                    ELSE
                        IF  seq_values[seq_incr, 1] = chr(128)
                        THEN
                            BEGIN
                            err_node  := seq_nodes[seq_incr];
                            b_err     := e_invalid_sequence;
                            c24       := 'INCREMENT 0             '
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  seq_values[seq_max] = csp_null_number
                    THEN
                        IF  seq_values[seq_incr, 1] > chr(128)
                        THEN
                            BEGIN (* maxvalue = 999999999999999999... *)
                            maxdigits := (sizeof (tsp00_Number) - 1) * 2;
                            seq_values[seq_max, 1] := chr (192 + maxdigits);
                            FOR ix := 1 TO maxdigits DIV 2 DO
                                seq_values[seq_max, ix + 1] := chr(153)
                            (*ENDFOR*) 
                            END
                        ELSE
                            s41plint (seq_values[seq_max], 1,
                                  (sizeof (tsp00_Number) -1) * 2, 0, -1, res);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  seq_values[seq_min] = csp_null_number
                    THEN
                        IF  seq_values[seq_incr, 1] > chr(128)
                        THEN
                            seq_values[seq_min] := csp_one_number
                        ELSE
                            BEGIN
                            seq_values[seq_min, 1] := chr (192 +
                                  (sizeof (tsp00_Number) - 1) * 2);
                            FOR ix := 2 TO sizeof (seq_values[seq_min]) DO
                                seq_values[seq_min, ix] := chr(153);
                            (*ENDFOR*) 
                            s51neg (seq_values[seq_min], 1, sizeof (tsp00_Number),
                                  seq_values[seq_min], 1,
                                  (sizeof (tsp00_Number) - 1) * 2, 0,
                                  len_byte, res)
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  seq_nodes[seq_nocache] <> 0
                    THEN
                        BEGIN
                        IF  seq_nodes[seq_cache] <> 0
                        THEN
                            BEGIN
                            b_err    := e_invalid_sequence;
                            err_node := seq_nodes[seq_cache];
                            c24      := 'NOCACHE CACHE CONFLICT  '
                            END
                        ELSE
                            s41plint (seq_values[seq_cache], 1,
                                  (sizeof (tsp00_Number) -1) * 2, 0,
                                  1, res)
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  seq_values[seq_cache] = csp_null_number
                        THEN
                            s41plint (seq_values[seq_cache], 1,
                                  (sizeof (tsp00_Number) -1) * 2, 0,
                                  c_default_cache_size, res)
                        ELSE
                            IF  seq_values[seq_cache] < csp_one_number
                            THEN
                                BEGIN
                                b_err    := e_invalid_sequence;
                                err_node := seq_nodes[seq_cache];
                                c24      := 'CACHE < 1               '
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  seq_values[seq_start] <> csp_null_number
                    THEN
                        BEGIN
                        IF  b_err = e_ok
                        THEN
                            BEGIN
                            b_err := e_invalid_sequence;
                            IF  seq_values[seq_start] < seq_values[seq_min]
                            THEN
                                BEGIN
                                err_node := seq_nodes[seq_min];
                                c24      := 'START < MINVALUE        '
                                END
                            ELSE
                                IF  seq_values[seq_start] > seq_values[seq_max]
                                THEN
                                    BEGIN
                                    err_node := seq_nodes[seq_max];
                                    c24      := 'START > MAXVALUE        '
                                    END
                                ELSE
                                    b_err := e_ok;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            IF  seq_nodes[seq_start] <> 0
                            THEN
                                err_node := seq_nodes[seq_start];
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  seq_values[seq_incr, 1] > chr(128)
                        THEN
                            seq_values[seq_start] := seq_values[seq_min]
                        ELSE
                            seq_values[seq_start] := seq_values[seq_max];
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  b_err = e_ok
                    THEN
                        BEGIN
                        s51mul (seq_values[seq_cache], 1,
                              sizeof (seq_values[seq_cache]),
                              seq_values[seq_incr], 1,
                              sizeof (seq_values[seq_incr]),
                              seq_values[seq_cache], 1,
                              (sizeof (seq_values[seq_cache]) - 1) * 2, 0,
                              len_byte, res);
                        IF  res = num_ok
                        THEN
                            BEGIN
                            FOR ix := len_byte + 1 TO
                                  sizeof (seq_values[seq_cache]) DO
                                seq_values[seq_cache, ix] := csp_defined_byte;
                            (*ENDFOR*) 
                            END;
                        (*ENDIF*) 
                        IF  res <> num_ok
                        THEN
                            BEGIN
                            b_err := e_invalid_sequence;
                            c24   := 'CACHE > CYCLE VALUES    '
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  (a_returncode = 0) AND (b_err = e_ok)
                    THEN
                        IF  seq_values[seq_min] > seq_values[seq_max]
                        THEN
                            BEGIN
                            err_node := seq_nodes[seq_min];
                            IF  err_node = 0
                            THEN
                                err_node := seq_nodes[seq_max];
                            (*ENDIF*) 
                            b_err := e_invalid_sequence;
                            c24   := 'MINVALUE > MAXVALUE     '
                            END
                        ELSE
                            BEGIN
                            IF  is_serial
                            THEN
                                BEGIN
                                (* seq_value := seq_value - 1,   *)
                                (*  because seq_first            *)
                                (* will be set to false          *)
                                seq_values[seq_incr] := seq_values[seq_start];
                                one_number := csp_one_number;
                                s51sub (seq_values[seq_start], 1,
                                      sizeof (seq_values[seq_start]),
                                      one_number, 1, sizeof (one_number),
                                      seq_values[seq_start], 1,
                                      (sizeof (seq_values[seq_start]) -1) * 2, 0,
                                      len_byte, res)
                                END;
                            (*ENDIF*) 
                            seq_value              := seq_values[seq_start];
                            seq_info.seq_increment := seq_values[seq_incr];
                            seq_info.seq_minvalue  := seq_values[seq_min];
                            seq_info.seq_maxvalue  := seq_values[seq_max];
                            seq_info.seq_cachevalue:= seq_values[seq_cache];
                            seq_schema           := sequence_schema;
                            seq_name             := sequence_name;
                            seq_public           := false;
                            IF  init_ti <> 0
                            THEN
                                seq_info.seq_cycle   :=
                                      a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_length = cak_i_round
                            ELSE
                                seq_info.seq_cycle := false;
                            (*ENDIF*) 
                            seq_info.seq_first   := true;
                            IF  is_serial
                            THEN
                                seq_reclen :=  mxak_sequence_offset -
                                      sizeof (seq_info) +
                                      sizeof (seq_info.seq_increment);
                            (*ENDIF*) 
                            a10add_sysinfo (acv, sysp, b_err);
                            IF  (b_err = e_ok) AND
                                NOT is_serial  AND
                                (seq_schema <> seq_owner)
                            THEN
                                a19add_usertab  (acv, seq_owner, seq_surrogate, ut_sequence);
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  (b_err <> e_ok) AND
            (a_returncode = 0)
        THEN
            BEGIN
            IF  b_err = e_duplicate_sysinfo
            THEN
                IF  is_serial (* PTS 1111778 *)
                THEN
                    b_err := e_too_many_serials
                ELSE
                    b_err := e_duplicate_name;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  err_node <> 0
            THEN
                ti := a_ap_tree^[ti].n_pos
            ELSE
                ti := 1;
            (*ENDIF*) 
            a07_b_put_error (acv, b_err, ti);
            IF  b_err = e_invalid_sequence
            THEN
                a07const_param (acv, 1, @c24, sizeof (c24))
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a_is_ddl := init_ddl
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a23drop_sequence (VAR acv : tak_all_command_glob;
            tableref      : tak_sysbufferaddress);
 
CONST
      c_succ_fileversion = true;
 
VAR
      b_err      : tgg00_BasisError;
      ix         : integer;
      seq_buf    : tak_sysbufferaddress;
      seq_privbuf: tak_sysbufferaddress;
      usage_buf  : tak_sysbufferaddress;
      grantee    : tgg00_Surrogate;
      del_qual   : tak_del_tab_qual;
      sysk       : tgg00_SysInfoKey;
 
BEGIN
WITH acv, tableref^.stableref DO
    BEGIN
    sysk           := a01defaultkey;
    sysk.stableid  := rtableid;
    sysk.sentrytyp := cak_esequence;
    a10get_sysinfo (acv, sysk, d_fix, seq_buf, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        IF  seq_buf^.ssequence.seq_schema <> seq_buf^.ssequence.seq_owner
        THEN
            a19del_usertab (acv, seq_buf^.ssequence.seq_owner, rtableid);
        (* Delete sequence of privileged users *)
        (* PTS                                 *)
        (*ENDIF*) 
        sysk           := a01defaultkey;
        sysk.stableid  := rtableid;
        sysk.sentrytyp := cak_esequencepriv;
        REPEAT
            a10next_sysinfo (acv, sysk, SURROGATE_MXGG00 + 2,
                  d_release, cak_esequencepriv,
                  seq_privbuf, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                grantee := seq_privbuf^.syskey.suserid;
                a19del_usertab (acv, grantee, rtableid)
                END;
            (*ENDIF*) 
        UNTIL
            b_err <> e_ok;
        (*ENDREPEAT*) 
        IF  b_err = e_no_next_record
        THEN
            b_err := e_ok
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        sysk           := a01defaultkey;
        sysk.stableid  := rtableid;
        sysk.sentrytyp := cak_eusage;
        sysk.skeylen   := sizeof (sysk.stableid) + sizeof (sysk.sentrytyp);
        REPEAT
            a10next_sysinfo (acv, sysk, SURROGATE_MXGG00 + 2,
                  d_fix, cak_eusage,
                  usage_buf, b_err);
            IF  b_err = e_ok
            THEN
                WITH usage_buf^.susage DO
                    BEGIN
                    ix := 1;
                    WHILE ix <= usagecount DO
                        BEGIN
                        a11drop_table (acv, usagedef[ix].usa_tableid,
                              tsynonym,
                              NOT c_succ_fileversion);
                        ix := ix + 1
                        END;
                    (*ENDWHILE*) 
                    IF  usagenext_exist
                    THEN
                        a06inc_linkage (sysk.slinkage)
                    ELSE
                        b_err := e_no_next_record
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
        UNTIL
            b_err <> e_ok;
        (*ENDREPEAT*) 
        IF  b_err = e_no_next_record
        THEN
            b_err := e_ok
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        (* delete sequence record + sequence privileges + *)
        (* sequence comment                               *)
        del_qual.del_colno     := 1;
        del_qual.del_qual_cnt  := 3;
        del_qual.del_qual[ 1 ] := cak_esequence;
        del_qual.del_qual[ 2 ] := cak_esequencepriv;
        del_qual.del_qual[ 3 ] := cak_ecomment;
        a10_del_tab_sysinfo (acv, seq_buf^.syskey.stableid,
              del_qual, false, b_err)
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN (* remove sequence from sequence cache *)
        a06a_mblock_init  (acv, m_nextval, mm_close,  b01niltree_id);
        SAPDB_PascalForcedMove (sizeof (rtableid), a_mblock.mb_qual_size,
              @rtableid, 1, @a_mblock.mb_qual^.buf, 1, sizeof (rtableid));
        a_mblock.mb_qual_len := sizeof (rtableid);
        a06rsend_mess_buf (acv, a_mblock, cak_return_req, b_err)
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN (* delete sequence reference record *)
        a10del_sysinfo (acv, tableref^.syskey, b_err);
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a23exist_sequence (VAR acv : tak_all_command_glob;
            tree_index      : integer;
            inclusiveSerial : boolean;
            VAR seq_buf     : tak_sysbufferaddress;
            VAR seq_schema  : tsp00_KnlIdentifier;
            VAR seq_name    : tsp00_KnlIdentifier) : boolean;
 
BEGIN
a23exist_sequence := ak23exist_sequence (acv, tree_index, inclusiveSerial,
      c_checkPrivilege, seq_buf, seq_schema, seq_name);
END;
 
(*------------------------------*) 
 
FUNCTION
      ak23exist_sequence (VAR acv : tak_all_command_glob;
            tree_index      : integer;
            inclusiveSerial : boolean;
            checkPrivilege  : boolean;
            VAR seq_buf     : tak_sysbufferaddress;
            VAR seq_schema  : tsp00_KnlIdentifier;
            VAR seq_name    : tsp00_KnlIdentifier) : boolean;
 
VAR
      found          : boolean;
      ok             : boolean;
      exitLoop       : boolean;
      exist_sequence : boolean;
      schemaSpecified: boolean;
      isSequence     : boolean;
      loop_cnt       : integer;
      b_err          : tgg00_BasisError;
      error_pos      : tsp00_Int4;
      base_ptr       : tak_sysbufferaddress;
      seqSchemaId    : tgg00_Surrogate;
      sysk           : tgg00_SysInfoKey;
      foundSysk      : tgg00_SysInfoKey;
      refSysk        : tgg00_SysInfoKey;
      priv           : tak_privilege;
 
BEGIN
WITH acv DO
    BEGIN
    exist_sequence := false;
    error_pos      := 1;
    (* PTS 1103905 E.Z. *)
    schemaSpecified := true;
    IF  tree_index > 0
    THEN
        WITH a_ap_tree^[ tree_index ] DO
            IF  n_symb = s_authid
            THEN
                BEGIN
                schemaSpecified := true;
                a06get_username (acv, tree_index, seq_schema);
                a101_MapSchemaName (acv, seq_schema, n_pos);
                error_pos := n_pos
                END
            ELSE
                BEGIN
                schemaSpecified := false;
                IF  a_curr_schema_set
                THEN
                    BEGIN
                    schemaSpecified := true;
                    seq_schema      := a_curr_schema;
                    END
                ELSE
                    seq_schema := a_curr_user_name;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    a103GetSchemaId (acv, seq_schema, error_pos, seqSchemaId);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        a06userid_get (acv, seqSchemaId, ok);
        IF  NOT ok
        THEN
            a07ak_system_error (acv, 23, 2)
        ELSE
            BEGIN
            IF  tree_index > 0
            THEN
                BEGIN
                a05identifier_get (acv, tree_index,
                      sizeof (seq_name), seq_name);
                error_pos      := a_ap_tree^[tree_index].n_pos;
                END;
            (*ENDIF*) 
            loop_cnt            := 0;
            refSysk             := a01defaultkey;
            refSysk.sauthid     := seqSchemaId;
            exitLoop            := false;
            found               := false;
            REPEAT
                loop_cnt            := loop_cnt + 1;
                isSequence          := false;
                refSysk.sentrytyp   := cak_etableref;
                refSysk.sidentifier := seq_name;
                refSysk.skeylen     := mxak_standard_sysk +
                      sizeof (sysk.sidentifier);
                a10get_sysinfo (acv, refSysk, d_release, seq_buf, b_err);
                IF  b_err = e_ok
                THEN
                    BEGIN
                    IF  seq_buf^.stableref.rtablekind = tsynonym
                    THEN (* is it a synonym for a sequence ? *)
                        BEGIN
                        sysk           := a01defaultkey;
                        sysk.stableid  := seq_buf^.stableref.rsynid;
                        a10get_sysinfo (acv, sysk, d_release, seq_buf, b_err);
                        IF  b_err = e_ok
                        THEN
                            BEGIN
                            found               := true;
                            isSequence          := a23is_sequence_synonym(seq_buf^.ssynonym);
                            foundSysk           := sysk;
                            foundSysk.stableid  := seq_buf^.ssynonym.syn_tableid;
                            foundSysk.sentrytyp := cak_esequence;
                            a06determine_username (acv, seq_buf^.ssynonym.syn_authid, seq_schema);
                            END;
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        isSequence := seq_buf^.stableref.rtablekind = tempty;
                        IF  isSequence OR NOT found
                        THEN
                            BEGIN
                            found               := true;
                            foundSysk           := a01defaultkey;
                            foundSysk.stableid  := seq_buf^.stableref.rtableid;
                            foundSysk.sentrytyp := cak_esequence;
                            a06determine_username (acv, seq_buf^.syskey.sauthid, seq_schema);
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (isSequence) OR (loop_cnt = 4) OR schemaSpecified
                THEN
                    exitLoop := true
                ELSE
                    BEGIN
                    IF  loop_cnt = 1
                    THEN
                        BEGIN
                        IF  seqSchemaId = a_acc_dba_id
                        THEN
                            loop_cnt := 2
                        ELSE
                            refSysk.sauthid := a_acc_dba_id;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  loop_cnt = 2
                    THEN
                        BEGIN
                        IF  a_acc_dba_id = g01glob.sysuser_id
                        THEN
                            loop_cnt := 3
                        ELSE (* PTS 1111797 E.Z. *)
                            refSysk.sauthid := g01glob.sysuser_id;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  loop_cnt = 3
                    THEN
                        BEGIN
                        refSysk.sauthid := cak_public_id;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            UNTIL
                exitLoop;
            (*ENDREPEAT*) 
            IF  found
            THEN
                BEGIN
                a10get_sysinfo (acv, foundSysk, d_fix, seq_buf, b_err);
                IF  b_err = e_ok
                THEN
                    IF  isSequence
                    THEN
                        BEGIN
                        IF  checkPrivilege
                        THEN
                            BEGIN
                            a06get_priv (acv, seq_buf, [r_sel], priv);
                            a10rel_sysinfo (seq_buf);
                            END
                        ELSE
                            priv.priv_all_set := [r_sel];
                        (*ENDIF*) 
                        exist_sequence := r_sel in priv.priv_all_set
                        END
                    ELSE
                        IF  inclusiveSerial
                        THEN
                            BEGIN
                            a06_systable_get (acv, d_release,
                                  foundSysk.stableid, base_ptr, false, ok);
                            IF  ok
                            THEN
                                BEGIN
                                IF  checkPrivilege
                                THEN
                                    a06get_priv  (acv, base_ptr, [r_sel], priv)
                                ELSE
                                    priv.priv_all_set := [r_sel];
                                (*ENDIF*) 
                                exist_sequence := r_sel in priv.priv_all_set
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = e_unknown_sql_schema
    THEN
        acv.a_returncode := 0;
    (*ENDIF*) 
    IF  NOT exist_sequence                 AND
        (a_is_ddl <> ddl_grant_privilege ) AND
        (a_is_ddl <> ddl_revoke_privilege) AND
        (a_is_ddl <> ddl_create_synonym  ) AND
        (tree_index > 0)
    THEN
        a07_nb_put_error (acv, e_unknown_sequencename, error_pos, seq_name);
    (*ENDIF*) 
    ak23exist_sequence := exist_sequence
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a23flush_sequence (VAR t : tgg00_TransContext;
            VAR seq_surrogate : tgg00_Surrogate;
            VAR seq_value     : tsp00_Number);
 
VAR
      sysk     : tgg00_SysInfoKey;
      seqrec   : tak_sequencerecord;
      sys2_cat : tgg00_FileId;
 
BEGIN
sysk           := a01defaultkey;
sysk.stableid  := seq_surrogate;
sysk.sentrytyp := cak_esequence;
a36get_catalog_record (t, sysk, seqrec);
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    seqrec.seq_value := seq_value;
    IF  seqrec.seq_reclen >= mxak_sequence_offset
    THEN
        seqrec.seq_info.seq_first := false;
    (*ENDIF*) 
    kb560GetSys2CatalogTreeId (sys2_cat);
    b02repl_record (t, sys2_cat, seqrec)
    END
ELSE
    IF  t.trError_gg00 = e_key_not_found
    THEN
        t.trError_gg00 := e_ok
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a23is_sequence_synonym (VAR synrec : tak_synonymrecord) : boolean;
 
BEGIN
a23is_sequence_synonym := synrec.syn_maxcol = -1
END;
 
(*------------------------------*) 
 
PROCEDURE
      a23get_sequence_value (VAR t : tgg00_TransContext;
            VAR seq_surrogate : tgg00_Surrogate;
            VAR seq_value     : tsp00_Number;
            VAR seq_first     : boolean);
 
VAR
      sysk   : tgg00_SysInfoKey;
      seqrec : tak_sequencerecord;
 
BEGIN
sysk           := a01defaultkey;
sysk.stableid  := seq_surrogate;
sysk.sentrytyp := cak_esequence;
a36get_catalog_record (t, sysk, seqrec);
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    seq_value := seqrec.seq_value;
    IF  seqrec.seq_reclen < mxak_sequence_offset
    THEN (* serial *)
        seq_first := false
    ELSE
        seq_first := seqrec.seq_info.seq_first
    (*ENDIF*) 
    END
ELSE
    IF  t.trError_gg00 = e_key_not_found
    THEN
        t.trError_gg00 := e_old_fileversion
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak23one_seq_value (VAR acv : tak_all_command_glob;
            VAR colinfo : tak00_columninfo;
            ti          : tsp00_Int4;
            VAR value   : tsp00_Number);
 
VAR
      res        : tsp00_NumError;
      is_int     : boolean;
      is_neg     : boolean;
      ix         : integer;
      curr_len   : integer;
      len_byte   : integer;
      aux_number : tsp00_C30;
 
BEGIN
WITH acv DO
    BEGIN
    FOR ix := 1 TO sizeof (value) DO
        value[ix] := chr(0);
    (*ENDFOR*) 
    IF  a_ap_tree^[ti].n_pos < 0
    THEN
        BEGIN
        is_neg := true;
        a_ap_tree^[ti].n_pos := abs (a_ap_tree^[ti].n_pos);
        END
    ELSE
        is_neg := false;
    (*ENDIF*) 
    a05_li_constant_get (acv, ti, colinfo, colinfo.cinoutlen,
          sizeof (aux_number), aux_number, 1, NOT c_variable_length, curr_len);
    IF  a_returncode = 0
    THEN
        BEGIN
        SAPDB_PascalForcedMove (sizeof (aux_number), sizeof (value),
              @aux_number, 2, @value, 1, curr_len - 1);
        s51isint (value, 1, curr_len - 1, is_int, res);
        IF  NOT is_int
        THEN
            a07_b_put_error (acv, e_missing_integer,
                  a_ap_tree^[ti].n_pos)
        ELSE
            IF  is_neg
            THEN
                s51neg (value, 1, sizeof (tsp00_Number),
                      value, 1, (sizeof (tsp00_Number) - 1) * 2,
                      0, len_byte, res)
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a23put_sequence_info (VAR acv : tak_all_command_glob;
            VAR mblock : tgg00_MessBlock;
            tree_index : integer);
 
VAR
      seq_buf   : tak_sysbufferaddress;
      dummy_own : tsp00_KnlIdentifier;
      dummy_seq : tsp00_KnlIdentifier;
 
BEGIN
IF  a23exist_sequence (acv,
    acv.a_ap_tree^[tree_index].n_lo_level,
    acv.a_ap_tree^[tree_index].n_symb = s_currval,
    seq_buf, dummy_own, dummy_seq)
THEN
    WITH seq_buf^.ssequence, mblock, mb_data^ DO
        IF  mb_data_len + sizeof (seq_surrogate) + sizeof (seq_info) + 1 >
            mb_data_size
        THEN
            a07_b_put_error (acv, e_too_many_mb_data, -mb_data_size)
        ELSE
            BEGIN
            SAPDB_PascalForcedMove (sizeof(seq_info), mb_data_size,
                  @seq_info, 1, @mbp_buf, mb_data_len + 1,
                  sizeof (seq_info));
            mb_data_len := mb_data_len + sizeof (seq_info);
            SAPDB_PascalForcedMove (sizeof(seq_surrogate), mb_data_size,
                  @seq_surrogate, 1, @mbp_buf, mb_data_len + 1,
                  sizeof (seq_surrogate));
            mb_data_len := mb_data_len + sizeof (seq_surrogate);
            IF  acv.a_ap_tree^[tree_index].n_symb = s_nextval
            THEN
                mbp_buf [mb_data_len+1] := cgg04_truechar
            ELSE
                mbp_buf [mb_data_len+1] := cgg04_falsechar;
            (*ENDIF*) 
            mb_data_len := mb_data_len + 1
            END
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak23create_sequence (VAR acv : tak_all_command_glob);
 
CONST
      c_is_serial = true;
 
VAR
      tree_index    : tsp00_Int4;
      pUserContext  : tsp00_Addr;
      sequence_id   : tgg00_Surrogate;
      schemaId      : tgg00_Surrogate;
      schema        : tsp00_KnlIdentifier;
      seqname       : tsp00_KnlIdentifier;
      colinfo       : tak00_columninfo;
 
BEGIN
WITH acv DO
    BEGIN
    pUserContext := NIL;
    IF  a_current_user_kind = unoprivate
    THEN
        a07_kw_put_error (acv, e_missing_privilege, 1, cak_i_resource)
    ELSE
        BEGIN
        tree_index := 2;
        schema     := acv.a_curr_schema;
        schemaId   := acv.a_curr_schema_id;
        a06get_username   (acv, tree_index, schema);
        IF  schema <> a_curr_user_name
        THEN
            IF  schema =  a01_i_temp
            THEN
                a07_nb_put_error (acv, e_schema_not_allowed, a_ap_tree^[2].n_pos, schema)
            ELSE
                BEGIN
                a103GetSchemaId (acv, schema,  a_ap_tree^[2].n_pos, schemaId);
                IF  acv.a_returncode = 0
                THEN
                    a103CheckCreateInPrivilege (acv, schema, a_ap_tree^[2].n_pos);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        a05identifier_get (acv, tree_index, sizeof (seqname), seqname);
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        a11table_reference (acv, schemaId, seqname, tempty,
              NOT c_global, NOT c_systable, sequence_id);
    (*ENDIF*) 
    IF  a_returncode =
        a071_return_code (e_duplicate_tablename, a_sqlmode)
    THEN
        BEGIN
        a_returncode := 0;
        a07_nb_put_error (acv, e_duplicate_name,
              a_ap_tree^[tree_index].n_pos, seqname)
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        colinfo.cdatatyp        := dfixed;
        colinfo.cbinary         := false;
        colinfo.cdatalen        := csp_fixed;
        colinfo.cdatafrac       := cak_frac_offset;
        colinfo.cinoutlen       := (colinfo.cdatalen + 1) DIV 2 + 2;
        colinfo.ccolstack.etype := st_fixcol;
        a23create_sequence (acv,
              sequence_id, schemaId, seqname, colinfo, NOT c_is_serial, c_dummy,
              a_ap_tree^[tree_index].n_sa_level);
        END;
    (*ENDIF*) 
    a51RestoreUserContext (acv, pUserContext);
    IF  a_returncode <> 0
    THEN
        a_part_rollback := true
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak23create_synonym (VAR acv : tak_all_command_glob;
            is_public_synonym : boolean);
 
VAR
      isInternal   : boolean;
      site_type    : tgg00_ServerdbType;
      b_err        : tgg00_BasisError;
      tree_index   : tsp00_Int4;
      ti           : tsp00_Int4;
      synbuf       : tak_sysbufferaddress;
      p_arr        : tak_syspointerarr;
      owner_id     : tgg00_Surrogate;
      syn_id       : tgg00_Surrogate;
      tablauthid   : tsp00_KnlIdentifier;
      tabltablen   : tsp00_KnlIdentifier;
      synonymname  : tsp00_KnlIdentifier;
      schemaName   : tsp00_KnlIdentifier;
      synkey       : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    tree_index := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_lo_level;
    IF  (a_ap_tree^[tree_index].n_proc = a23) AND (* PTS 1109242 *)
        (a_ap_tree^[tree_index].n_subproc = cak_i_internal)
    THEN
        BEGIN
        tree_index := a_ap_tree^[tree_index].n_lo_level;
        isInternal := true;
        END
    ELSE
        isInternal := false;
    (*ENDIF*) 
    ti := tree_index;
    IF  a_ap_tree^[tree_index].n_symb = s_authid
    THEN
        a06get_username (acv, tree_index, schemaName)
    ELSE
        schemaName := a_curr_user_name;
    (*ENDIF*) 
    IF  schemaName <> acv.a_curr_user_name
    THEN
        a07_nb_put_error (acv, e_schema_not_allowed, a_ap_tree^[ti].n_pos, schemaName)
    ELSE
        BEGIN
        a05identifier_get (acv, tree_index, sizeof(synonymname), synonymname);
        tree_index := a_ap_tree^[tree_index].n_lo_level;
        ti         := tree_index;
        a11get_check_table (acv, false, false, true, [  ], true, true,
              d_fix, tree_index, tablauthid, tabltablen, p_arr);
        IF  a_returncode =
            a071_return_code (e_unknown_tablename, a_sqlmode)
        THEN
            BEGIN
            a_returncode := 0;
            IF  NOT a23exist_sequence (acv, ti, NOT c_inclusiveSerial,
                p_arr.pbasep, tablauthid, tabltablen)
            THEN
                a07_nb_put_error (acv, e_unknown_tablename, a_ap_tree^[ti].n_pos,
                      tabltablen)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        syn_id := p_arr.pbasep^.syskey.stableid;
        IF  is_public_synonym
        THEN
            owner_id := cak_public_id
        ELSE
            owner_id := a_curr_user_id;
        (*ENDIF*) 
        a11table_reference (acv, owner_id, synonymname, tsynonym,
              p_arr.pbasep^.sbase.bsegmentid = cak00_public_segment_id,
              NOT c_systable, syn_id)
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        synkey          := a01defaultkey;
        synkey.stableid := syn_id;
        a10_nil_get_sysinfo (acv, synkey,
              d_fix, sizeof (tak_synonymrecord), synbuf, b_err)
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        WITH synbuf^, ssynonym DO
            BEGIN
            IF  is_public_synonym
            THEN
                synsegmentid := cak00_public_segment_id
            ELSE
                synsegmentid := p_arr.pbasep^.sbase.bsegmentid;
            (*ENDIF*) 
            syncomment := false;
            site_type  := sdb_internal;
            syn_owner := a_curr_user_id;
            syn_tableid := p_arr.pbasep^.syskey.stableid;
            syn_internal   := isInternal;
            synfiller0     := false;
            syn_authid     := owner_id;
            syn_tablen     := synonymname;
            syn_tablekind  := tsynonym;
            IF  p_arr.pbasep^.syskey.sentrytyp <> cak_esequence
            THEN
                syn_maxcol := 0
            ELSE
                syn_maxcol := -1;
            (*ENDIF*) 
            a11put_date_time (syn_date, syn_time);
            a10add_sysinfo (acv, synbuf, b_err);
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, 1)
            ELSE
                a16put_usage_def  (acv, syn_tableid,
                      syn_id, tsynonym);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  p_arr.pbasep^.syskey.sentrytyp <> cak_esequence
        THEN
            IF  (p_arr.pbasep^.sbase.btablekind <> tdb2view)       AND
                (p_arr.pbasep^.sbase.btablekind <> tcatalog_table)
            THEN
                a23new_version_no (acv, p_arr.pbasep);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode <> 0
    THEN
        IF  a_internal_sql <> sql_restore_schema
        THEN
            a_part_rollback := true
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak23drop_sequence (VAR acv : tak_all_command_glob);
 
VAR
      b_err        : tgg00_BasisError;
      tree_index   : integer;
      seq_buf      : tak_sysbufferaddress;
      owner        : tsp00_KnlIdentifier;
      name         : tsp00_KnlIdentifier;
      sysk         : tgg00_SysInfoKey;
 
BEGIN
WITH acv DO
    BEGIN
    tree_index := 2;
    IF  ak23exist_sequence (acv, tree_index,
        NOT c_inclusiveSerial, NOT c_checkPrivilege, seq_buf, owner, name)
    THEN
        a103CheckDropInPrivilege (acv, owner, 1);
    (*ENDIF*) 
    IF  (acv.a_returncode = 0)
        AND
        ak23exist_sequence (acv, tree_index,
        NOT c_inclusiveSerial, NOT c_checkPrivilege, seq_buf, owner, name)
    THEN
        BEGIN
        (* sequence must be read again, because a103CheckDropInPrivilege may have displaced it from cache *)
        sysk             := a01defaultkey;
        sysk.sauthid     := seq_buf^.ssequence.seq_schema;
        sysk.sentrytyp   := cak_etableref;
        sysk.sidentifier := name;
        sysk.skeylen     :=
              mxak_standard_sysk + sizeof (sysk.sidentifier);
        a10get_sysinfo (acv, sysk, d_fix, seq_buf, b_err);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        ELSE
            a23drop_sequence (acv, seq_buf)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode <> 0
    THEN
        a_part_rollback := true
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak23drop_synonym (VAR acv : tak_all_command_glob);
 
VAR
      ok                : boolean;
      is_public_synonym : boolean;
      b_err             : tgg00_BasisError;
      index             : integer;
      tabid             : tgg00_Surrogate;
      synbuf            : tak_sysbufferaddress;
      buf               : tak_sysbufferaddress;
      base_ptr          : tak_sysbufferaddress;
      owner             : tsp00_KnlIdentifier;
      synkey            : tgg00_SysInfoKey;
      sysk              : tgg00_SysInfoKey;
 
BEGIN
WITH acv  DO
    BEGIN
    is_public_synonym :=
          a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_length = cak_i_public;
    index  := a_ap_tree^[a_ap_tree^[ 0 ].n_lo_level].n_lo_level;
    IF  a_ap_tree^[index].n_symb = s_authid
    THEN
        a06get_username (acv, index, owner)
    ELSE
        owner := a_curr_user_name;
    (*ENDIF*) 
    IF  owner <> acv.a_curr_user_name
    THEN
        a07_kw_put_error (acv, e_missing_privilege, 1,
              cak_i_userid)
    ELSE
        BEGIN
        synkey := a01defaultkey;
        IF  is_public_synonym
        THEN
            synkey.sauthid := cak_public_id
        ELSE
            synkey.sauthid := a_curr_user_id;
        (*ENDIF*) 
        synkey.sentrytyp  := cak_etableref;
        a05identifier_get (acv,
              index, sizeof (synkey.sidentifier), synkey.sidentifier);
        synkey.skeylen := mxak_standard_sysk + sizeof (synkey.sidentifier);
        END;
    (*ENDIF*) 
    a10get_sysinfo (acv, synkey, d_fix, synbuf, b_err);
    IF  b_err = e_ok
    THEN
        IF  synbuf^.stableref.rtablekind <> tsynonym
        THEN
            b_err := e_sysinfo_not_found
        ELSE
            BEGIN
            tabid          := synbuf^.stableref.rtableid;
            sysk           := a01defaultkey;
            sysk.stableid  := synbuf^.stableref.rsynid;
            a10get_sysinfo (acv, sysk, d_fix, buf, b_err);
            IF  b_err = e_ok
            THEN
                IF  (is_public_synonym) AND
                    (buf^.ssynonym.syn_owner <> a_curr_user_id)
                THEN
                    a07_kw_put_error (acv, e_missing_privilege, 1,
                          cak_i_userid)
                ELSE
                    BEGIN
                    a11drop_table (acv, synbuf^.stableref.rsynid,
                          tsynonym, true);
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        IF  b_err = e_sysinfo_not_found
        THEN
            a07_b_put_error (acv,
                  e_unknown_synonymname, a_ap_tree^[ 2 ].n_pos)
        ELSE
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a06_systable_get (acv, d_fix,
              tabid, base_ptr, false, ok);
        IF  ok
        THEN
            IF  (base_ptr^.sbase.btablekind <> tdb2view)  AND
                (base_ptr^.sbase.btablekind <> tcatalog_table)
            THEN
                a23new_version_no (acv, base_ptr)
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode <> 0
    THEN
        a_part_rollback := true;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a23new_version_no (VAR acv : tak_all_command_glob;
            syn_base_ptr : tak_sysbufferaddress);
 
VAR
      base_table_found    : boolean;
      found               : boolean;
      ok                  : boolean;
      do_return           : boolean;
      b_err               : tgg00_BasisError;
      dstate              : tak_directory_state;
      i                   : integer;
      next_tab            : integer;
      base_ptr            : tak_sysbufferaddress;
      buf                 : tak_sysbufferaddress;
      tabid               : tgg00_Surrogate;
      sysk                : tgg00_SysInfoKey;
 
BEGIN
b_err := e_ok;
WITH syn_base_ptr^.sbase DO
    BEGIN
    dstate            := d_release;
    base_table_found  := false;
    do_return         := false;
    (* PTS 1111576 E.Z. *)
    IF  btablekind in [ twithkey, twithoutkey ]
    THEN
        BEGIN (* synonym for base table *)
        tabid            := syn_base_ptr^.syskey.stableid;
        base_table_found := true;
        dstate           := d_fix
        END
    ELSE
        IF  btablekind = tcomplexview
        THEN
            BEGIN (* synonym for complex view, search underlying *)
            (* Table or View, that is not complex                *)
            sysk           := syn_base_ptr^.syskey;
            sysk.sentrytyp := cak_eviewtext;
            found          := false;
            REPEAT
                a10get_sysinfo (acv,
                      sysk, d_release, buf, b_err);
                IF  b_err = e_ok
                THEN
                    WITH buf^.sviewtext DO
                        BEGIN
                        i        := 1;
                        next_tab := cak_is_undefined;
                        WHILE (i <= vttabcount) AND NOT(found)
                              AND (b_err = e_ok) DO
                            WITH vttab[ i ] DO
                                IF  vttcomplex_view
                                THEN
                                    BEGIN
                                    next_tab := i;
                                    i        := succ(i)
                                    END
                                ELSE
                                    BEGIN
                                    a06_systable_get (acv, d_release,
                                          vtttableid, base_ptr,
                                          false, ok);
                                    IF  ok
                                    THEN
                                        IF  base_ptr^.sbase.bv_tablekind <>
                                            tcatalog_table
                                        THEN
                                            found := true
                                        ELSE
                                            i := i + 1
                                        (*ENDIF*) 
                                    ELSE
                                        b_err := e_sysinfo_not_found
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                            (*ENDWITH*) 
                        (*ENDWHILE*) 
                        IF  NOT (found) AND
                            (next_tab <> cak_is_undefined)
                        THEN
                            i := next_tab;
                        (*ENDIF*) 
                        IF  i <= vttabcount
                        THEN
                            WITH vttab[ i ] DO
                                BEGIN
                                sysk.stableid := vtttableid;
                                END
                            (*ENDWITH*) 
                        ELSE
                            do_return := true;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDIF*) 
            UNTIL
                found                         OR
                (next_tab = cak_is_undefined) OR
                (b_err <> e_ok);
            (*ENDREPEAT*) 
            IF  found
            THEN
                BEGIN
                sysk.sentrytyp := cak_etable;
                a10get_sysinfo (acv,
                      sysk, d_release, buf, b_err);
                END;
            (*ENDIF*) 
            END
        ELSE (* synonym for one base view or join view *)
            buf := syn_base_ptr;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  NOT (base_table_found) AND NOT do_return AND (b_err = e_ok)
THEN
    WITH buf^, sbase DO
        (* PTS 1111576 E.Z. *)
        IF  btablekind in [ twithkey, twithoutkey ]
        THEN
            BEGIN
            tabid := buf^.syskey.stableid;
            END
        ELSE
            IF  btablekind = tonebase
            THEN
                BEGIN
                tabid := btreeid.fileTabId_gg00;
                END
            ELSE
                IF  btablekind = tview
                THEN
                    a06_view_get_basetable (acv, buf^.syskey.stableid,
                          1, tabid);
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
IF  (acv.a_returncode = 0)
    AND NOT do_return AND (b_err = e_ok)
THEN
    BEGIN
    a06_systable_get (acv, d_fix,
          tabid, acv.a_p_arr1.pbasep, true, base_table_found);
    IF  base_table_found
    THEN
        BEGIN
        IF  acv.a_p_arr1.pbasep^.sbase.btablekind <> tcatalog_table
        THEN
            BEGIN
            a10_version (acv, acv.a_p_arr1.pbasep^.sbase,
                  m_succ_file_version, true);
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                a10repl_sysinfo (acv, acv.a_p_arr1.pbasep, b_err);
                IF  dstate <> d_fix
                THEN
                    a10rel_sysinfo (acv.a_p_arr1.pbasep);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    ELSE
        a07ak_system_error (acv, 23, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
