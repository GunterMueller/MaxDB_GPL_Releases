.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VAK544$
.tt 2 $$$
.TT 3 $GertG$diagnose_analyze$2000-04-10$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : diagnose analyze
=========
.sp
Purpose : procedures for DIAGNOSE ANALYZE
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a544syntax_diag_analyze  (VAR acv : tak_all_command_glob;
                    VAR put_node : tsp00_Int2);
 
        PROCEDURE
              a544semantik_diag_analyze (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a544put_syscmd_analyze (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a544put_sysdata_analyze (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a544get_cmdid(VAR acv : tak_all_command_glob;
                    VAR parskey : tak_parskey;
                    VAR cmdid   : tgg00_Surrogate);
 
        PROCEDURE
              a544get_analyze_filter (VAR state : tsp00_C64);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01sysnullkey         : tgg00_SysInfoKey;
              a01diag_analyze_on    : boolean;
              a01diag_ana_coll_data : boolean;
              a01_i_syscmd_analyze  : tsp00_KnlIdentifier;
              a01_i_sysdata_analyze : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01_call_put (VAR acv : tak_all_command_glob;
                    proc     : tak_procs;
                    subproc  : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_is_end_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_get_keyword (VAR acv : tak_all_command_glob;
                    VAR index : integer;
                    VAR reserved : boolean);
 
        FUNCTION
              a01_eqkey (VAR a : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05surrogate_get (VAR acv : tak_all_command_glob;
                    VAR surrogate  : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR authid   : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR d_sparr  : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_error (VAR a_scv : tak_all_command_glob;
                    errorcode : tgg00_BasisError;
                    VAR nod1  : tsp00_Int2;
                    VAR nod2  : tsp00_Int2);
 
        PROCEDURE
              a07_kw_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_SetExecuteStatisticData (
                    VAR acv                     : tak_all_command_glob;
                    VAR parseId                 : tak_parsid;
                    VAR CmdID                   : tgg00_Surrogate;
                    ExecuteTimeSec              : tsp00_Int4;
                    ExecuteTimeMicroSec         : tsp00_Int4;
                    ReadRowCount                : tsp00_Int4;
                    QualifiedRowCount           : tsp00_Int4;
                    VirtualReadCount            : tsp00_Int4;
                    PhysicalReadCount           : tsp00_Int4;
                    FetchRowCount               : tsp00_Int4;
                    SuspendCount                : tsp00_Int4;
                    WaitCount                   : tsp00_Int4 ) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_warm_utility_functions : VAK37;
 
        PROCEDURE
              a37ddl (VAR acv : tak_all_command_glob;
                    ddl_id : tak30_ddl_kind);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542get_abapinfo (VAR acv : tak_all_command_glob;
                    VAR abapname    : tsp00_C40;
                    VAR abapnamelen : integer;
                    VAR abaplinenr  : tsp00_Number);
 
      ------------------------------ 
 
        FROM
              AK_HASH_Procedures : VAK543;
 
        PROCEDURE
              a543hash (
                    VAR hashvalue     : tsp00_MoveObj;
                    len           : tsp00_Int4;
                    VAR hashkey   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92next_monitor_pcount (VAR acv : tak_all_command_glob;
                    VAR parsk : tak_parskey);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        PROCEDURE
              b01empty_file (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02repl_record (VAR t : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR b          : tgg00_Rec);
 
        PROCEDURE
              b02add_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b02get_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tsp00_MoveObj;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              task_temp_data_cache : VBD21;
 
        PROCEDURE
              b21mp_cmdid_put (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR cmdid : tgg00_Surrogate);
 
        PROCEDURE
              b21m_parse_again (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR parse_again : tsp00_C3);
 
        PROCEDURE
              b21mp_parse_again_put (temp_cache_ptr : tgg00_TempDataCachePtr;
                    parse_again : tsp00_C3);
 
        FUNCTION
              b21m_microsec (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_sec (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        PROCEDURE
              b21m_parseid (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR parseid       : tsp00_C12;
                    VAR masterparseid : tsp00_C12);
 
        PROCEDURE
              b21m_cmdid (temp_cache_ptr : tgg00_TempDataCachePtr;
                    VAR cmdid : tgg00_Surrogate);
 
        FUNCTION
              b21m_phys_ios (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_rows_fetched (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_rows_qual (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_rows_read (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_suspends (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_virt_reads (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
        FUNCTION
              b21m_waits (temp_cache_ptr : tgg00_TempDataCachePtr) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01tabid          : tgg04_TabIdGlobals;
              g01unicode        : boolean;
              g01glob           : tgg00_KernelGlobals;
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        VAR
              g08monitor : tsp00_RegionId;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalForcedOverlappingMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30cmp1 (VAR buf1   : tsp00_MoveObj;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_MoveObj;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        PROCEDURE
              s30cmp2 (VAR buf1   : tsp00_Number;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_MoveObj;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions: VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              Number-Arithmetic : VSP51;
 
        PROCEDURE
              s51add (VAR left     : tsp00_MoveObj;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_Number;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_MoveObj;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
        PROCEDURE
              s51div (VAR left     : tsp00_MoveObj;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_Number;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_MoveObj;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbegexcl (pid : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vendexcl (pid : tsp00_TaskId;
                    region  : tsp00_RegionId);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01sname (debug : tgg00_Debug; nam : tsp00_Sname);
 
        PROCEDURE
              t01name (debug : tgg00_Debug; nam  : tsp00_Name);
 
        PROCEDURE
              t01surrogate (debug : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01buf (layer : tgg00_Debug;
                    VAR buf : tgg00_SysInfoKey;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              t01buf1 (layer : tgg00_Debug;
                    VAR buf : tsp00_C12;
                    pos_anf : integer;
                    pos_end : integer);
&       ENDIF
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              b02get_record;
 
              tgg00_Lkey tsp00_MoveObj
 
        PROCEDURE
              s30cmp2;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s51add;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s51div;
 
              tsp00_MoveObj tsp00_Number
&             ifdef TRACE
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tgg00_SysInfoKey
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tsp00_C12
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : GertG
.sp
.cp 3
Created : 1985-01-22
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-04-10
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 2;.of 14
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_sql_stmt_datalen = 7800; (* ak544cmd_analyze_rec_build *)
      c_only_key         = true;
      (* *)
      c_fixed20_size     = ((20 + 1) DIV 2) + 1;
 
TYPE
      (* h.b. PTS 1105522 *)
      tak544analyze_filter_type  =  (actSelect_eak544, actDelete_eak544,
            actInsert_eak544, actUpdate_eak544);
 
VAR
      (* h.b. PTS 1105522 *)
      a544diag_analyze_filter : SET OF tak544analyze_filter_type;
 
 
(*------------------------------*) 
 
PROCEDURE
      a544syntax_diag_analyze  (VAR acv : tak_all_command_glob;
            VAR put_node : tsp00_Int2);
 
VAR
      _kw_index      : integer;
      _last_n        : tsp00_Int2;
      _put_n         : tsp00_Int2;
      _da_clear_cmd  : tak_keyword;
      _res_kw        : boolean;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_return_segm^.sp1r_function_code := csp1_monitor_fc;
    a01_call_put (acv, a37, cak_x_diagnose_analyze, put_node);
    a01_next_symbol (acv);
    a01_get_keyword (acv, _kw_index, _res_kw);
    CASE _kw_index OF
        cak_i_select, cak_i_insert, (* h.b. PTS 1105522 *)
        cak_i_delete, cak_i_update:
            BEGIN
            REPEAT
                _put_n  := put_node;
                _last_n := put_node;
                a01_call_put (acv, a37, _kw_index, _put_n);
                a_ap_tree^[ _last_n ].n_sa_level := _put_n;
                _last_n := _put_n;
                a01_next_symbol (acv);
                a01_get_keyword (acv, _kw_index, _res_kw);
                IF  NOT (_kw_index in
                    [cak_i_select, cak_i_delete, cak_i_update,
                    cak_i_insert, cak_i_on, cak_i_off])
                THEN
                    a07_error (acv, e_wanted_keyword, _put_n, _last_n);
                (*ENDIF*) 
            UNTIL
                (_kw_index in [ cak_i_on, cak_i_off ]) OR
                (a_returncode <> 0);
            (*ENDREPEAT*) 
            a_ap_tree^[ put_node ].n_length := _kw_index;
            END;
        cak_i_on, cak_i_off :
            a_ap_tree^[ put_node ].n_length := _kw_index;
        cak_i_count :
            BEGIN
            a_ap_tree^[put_node].n_length := _kw_index;
            a01_next_symbol (acv);
            a01_get_keyword (acv, _kw_index, _res_kw);
            CASE _kw_index OF
                cak_i_on, cak_i_off :
                    a_ap_tree^[put_node].n_pos := _kw_index;
                OTHERWISE
                    a07_error (acv, e_wanted_keyword, put_node, put_node);
                END;
            (*ENDCASE*) 
            END;
        cak_i_clear:
            BEGIN
            a_ap_tree^[put_node].n_length := _kw_index;
            a01_next_symbol (acv);
            a01_get_keyword (acv, _kw_index, _res_kw);
            CASE _kw_index OF
                cak_i_data:
                    a_ap_tree^[put_node].n_pos := cak30_x_clear_data;
                cak_i_all :
                    a_ap_tree^[put_node].n_pos := cak30_x_clear_all;
                OTHERWISE
                    BEGIN
                    _da_clear_cmd  := 'COMMAND           ';
                    IF  a01_eqkey (_da_clear_cmd, a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        a_ap_tree^[put_node].n_pos := cak30_x_clear_cmd
                    ELSE
                        a07_error (acv, e_wanted_keyword, put_node, put_node);
                    (*ENDIF*) 
                    END;
                END
            (*ENDCASE*) 
            END;
        OTHERWISE
            a07_error (acv, e_wanted_keyword, put_node, put_node);
        END;
    (*ENDCASE*) 
    a01_next_symbol (acv);
    a01_is_end_symbol (acv)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a544semantik_diag_analyze (VAR acv : tak_all_command_glob);
 
VAR
      _act_node : tsp00_Int2;
      _c3       : tsp00_C3;
 
BEGIN
IF  NOT (acv.a_current_user_kind in [ucontroluser, usysdba, udba])
THEN
    a07_kw_put_error (acv, e_missing_privilege, 1, cak_i_dba)
ELSE
    BEGIN
    vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08monitor);
    WITH acv DO
        CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_length OF
            cak_i_on  : (* h.b. PTS 1105522 *)
                BEGIN
&               ifdef TRACE
                t01sname(ak_sem, 'ANALYZE ON  ');
&               endif
                IF  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_sa_level <> 0
                THEN
                    BEGIN
                    IF  NOT a01diag_analyze_on
                    THEN
                        a544diag_analyze_filter := [];
                    (*ENDIF*) 
                    _act_node := a_ap_tree^[ 0 ].n_lo_level;
                    WHILE a_ap_tree^[ _act_node  ].n_sa_level <> 0 DO
                        BEGIN
                        _act_node := a_ap_tree^[ _act_node  ].n_sa_level;
                        CASE a_ap_tree^[ _act_node  ].n_subproc OF
                            cak_i_select:
                                a544diag_analyze_filter :=
                                      a544diag_analyze_filter + [actSelect_eak544];
                            cak_i_insert:
                                a544diag_analyze_filter :=
                                      a544diag_analyze_filter + [actInsert_eak544];
                            cak_i_delete:
                                a544diag_analyze_filter :=
                                      a544diag_analyze_filter + [actDelete_eak544];
                            cak_i_update:
                                a544diag_analyze_filter :=
                                      a544diag_analyze_filter + [actUpdate_eak544];
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDWHILE*) 
                    END
                ELSE
                    a544diag_analyze_filter := [actSelect_eak544,
                          actDelete_eak544, actInsert_eak544, actUpdate_eak544];
                (*ENDIF*) 
                a37ddl (acv, create_syscmd_analyze);
                IF  a_returncode = 0
                THEN
                    a37ddl (acv, create_sysdata_analyze);
                (*ENDIF*) 
                IF  a_returncode = 0
                THEN
                    BEGIN
                    a01diag_analyze_on := true;
                    IF  a_transinf.tri_trans.trBdTcachePtr_gg00 <> NIL
                    THEN
                        BEGIN
                        b21m_parse_again (a_transinf.tri_trans.trBdTcachePtr_gg00,
                              _c3);
                        IF  _c3 = '   '
                        THEN
                            BEGIN
                            WITH a_pars_last_key DO
                                BEGIN
                                (* PTS 1109291 E.Z. *)
                                a92next_monitor_pcount (acv, a_pars_last_key);
                                p_id   := chr(0);
                                p_kind := m_nil;
                                p_no   := 0
                                END;
                            (*ENDWITH*) 
                            b21mp_parse_again_put (acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                                  a_pars_last_key.p_count);
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            cak_i_off : (* h.b. PTS 1105522 *)
                BEGIN
&               ifdef TRACE
                t01sname(ak_sem, 'ANALYZE OFF ');
&               endif
                IF  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_sa_level <> 0
                THEN
                    BEGIN
                    _act_node := a_ap_tree^[ 0 ].n_lo_level;
                    WHILE a_ap_tree^[ _act_node  ].n_sa_level <> 0 DO
                        BEGIN
                        _act_node := a_ap_tree^[ _act_node  ].n_sa_level;
                        CASE a_ap_tree^[ _act_node  ].n_subproc OF
                            cak_i_select:
                                a544diag_analyze_filter :=
                                      a544diag_analyze_filter - [actSelect_eak544];
                            cak_i_insert:
                                a544diag_analyze_filter :=
                                      a544diag_analyze_filter - [actInsert_eak544];
                            cak_i_delete:
                                a544diag_analyze_filter :=
                                      a544diag_analyze_filter - [actDelete_eak544];
                            cak_i_update:
                                a544diag_analyze_filter :=
                                      a544diag_analyze_filter - [actUpdate_eak544];
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDWHILE*) 
                    END
                ELSE
                    a544diag_analyze_filter := [];
                (*ENDIF*) 
                IF  (a544diag_analyze_filter = [])
                THEN
                    BEGIN
                    a01diag_analyze_on    := false;
                    a01diag_ana_coll_data := false;
                    END;
                (*ENDIF*) 
                END;
            cak_i_clear:
                CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_pos OF
                    cak30_x_clear_cmd :
                        BEGIN (* h.b. PTS 1104444 *)
&                       ifdef TRACE
                        t01sname(ak_sem, 'ANA CLEARCMD');
&                       endif
                        ak544clear_cmd_analyze (acv);
                        END;
                    cak30_x_clear_data :
                        BEGIN (* h.b. PTS 1104444 *)
&                       ifdef TRACE
                        t01sname(ak_sem, 'ANA CLEARDAT');
&                       endif
                        ak544clear_data_analyze (acv);
                        END;
                    cak30_x_clear_all :
                        BEGIN (* h.b. PTS 1104444 *)
&                       ifdef TRACE
                        t01sname(ak_sem, 'ANA CLEARALL');
&                       endif
                        ak544clear_cmd_analyze (acv);
                        ak544clear_data_analyze (acv);
                        END;
                    END;
                (*ENDCASE*) 
            cak_i_count :
                CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_pos OF
                    cak_i_on:
                        IF  a01diag_analyze_on
                        THEN
                            BEGIN
                            a01diag_ana_coll_data := true;
&                           ifdef TRACE
                            t01sname(ak_sem, 'ANA COUNT ON');
&                           endif
                            END;
                        (*ENDIF*) 
                    cak_i_off:
                        IF  a01diag_analyze_on
                        THEN
                            BEGIN
                            a01diag_ana_coll_data := false;
&                           ifdef TRACE
                            t01sname(ak_sem, 'ANA COUNT OF');
&                           endif
                            END;
                        (*ENDIF*) 
                    END;
                (*ENDCASE*) 
            END;
        (*ENDCASE*) 
    (*ENDWITH*) 
    vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08monitor)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak544clear_data_analyze(VAR acv : tak_all_command_glob);
 
VAR
      p_arr          : tak_syspointerarr;
      tablename      : tsp00_KnlIdentifier;
      authid         : tsp00_KnlIdentifier;
 
BEGIN (* h.b. PTS 1104444 *)
authid    := g01glob.sysuser_name;
tablename := a01_i_sysdata_analyze;
IF  a06_table_exist (acv, d_release, authid, tablename, p_arr, false)
THEN
    BEGIN
    g01tabid.sys_data_analyze := p_arr.pbasep^.sbase.btreeid;
    b01empty_file (acv.a_transinf.tri_trans, g01tabid.sys_data_analyze);
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak544clear_cmd_analyze(VAR acv : tak_all_command_glob);
 
VAR
      p_arr          : tak_syspointerarr;
      tablename      : tsp00_KnlIdentifier;
      authid         : tsp00_KnlIdentifier;
 
BEGIN (* h.b. PTS 1104444 *)
authid    := g01glob.sysuser_name;
tablename := a01_i_syscmd_analyze;
IF  a06_table_exist (acv, d_release, authid, tablename, p_arr, false)
THEN
    BEGIN
    g01tabid.sys_cmd_analyze := p_arr.pbasep^.sbase.btreeid;
    b01empty_file (acv.a_transinf.tri_trans, g01tabid.sys_cmd_analyze);
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a544put_syscmd_analyze (VAR acv : tak_all_command_glob);
 
CONST
      c_max_stmt_pieces = 10;
 
VAR
      _job            : tsp00_C40;
      _job_len        : integer;
      _loop_cnt       : integer;
      _linenr         : tsp00_Number;
      _cmdhash        : tsp00_Int4;
      _cmdid          : tgg00_Surrogate;
      _dummy_surrogate: tgg00_Surrogate;
      _linkage        : integer;
      _b_err          : tgg00_BasisError;
      _p1_pos         : integer;
      _dummy_pos      : integer;
      _newhashslotpos : integer;
      _cmdidkey       : tgg00_SysInfoKey;
      _cachearea      : tak_sysbufferaddress;
      _l_result       : tsp00_LcompResult;
      _cmd_found      : boolean;
      _eof            : boolean;
 
BEGIN
WITH acv DO
    (* h.b. PTS 1105522 *)
    IF  (a_return_segm^.sp1r_function_code IN [csp1_insert_fc, csp1_minsert_fc]) AND
        (actInsert_eak544 in a544diag_analyze_filter)
        OR
        (a_return_segm^.sp1r_function_code IN [csp1_update_fc, csp1_mupdate_fc]) AND
        (actUpdate_eak544 in a544diag_analyze_filter)
        OR
        (a_return_segm^.sp1r_function_code IN [csp1_delete_fc, csp1_mdelete_fc]) AND
        (actUpdate_eak544 in a544diag_analyze_filter)
        OR
        (a_return_segm^.sp1r_function_code IN [csp1_select_fc, csp1_mselect_fc,
        csp1_select_into_fc, csp1_mselect_into_fc])               AND
        (actSelect_eak544 in a544diag_analyze_filter)
    THEN
        WITH acv, a_mblock.mb_data^ DO
            BEGIN
            (* PTS 1104142 E.Z. *)
            _loop_cnt := 0;
            _b_err := e_ok;
            REPEAT
                _loop_cnt := succ(_loop_cnt);
                IF  (acv.a_cmd_part^.sp1p_buf_len DIV c_sql_stmt_datalen)
                    < c_max_stmt_pieces
                THEN
                    BEGIN
                    (* SQL statement fit in 10 pieces (LINKAGE FIXED(1)) *)
                    _b_err          := e_ok;
                    _linkage        := 0;
                    _newhashslotpos := 0;
                    _eof            := false;
                    _cmd_found      := false;
                    a542get_abapinfo (acv, _job, _job_len, _linenr);
                    a543hash (a_cmd_part^.sp1p_buf,
                          a_cmd_part^.sp1p_buf_len, _cmdhash);
                    (* get last listed SQL statement in a hash list *)
                    REPEAT
                        _newhashslotpos := _newhashslotpos + 1;
                        (* build key record *)
                        ak544cmd_analyze_rec_build ( acv, _job, _linenr,
                              _cmdhash, _linkage, _newhashslotpos,
                              _dummy_surrogate, _dummy_pos,
                              c_only_key, _b_err);
                        IF  _b_err = e_ok
                        THEN
                            BEGIN
                            (* search record *)
                            b02get_record (acv.a_transinf.tri_trans,
                                  g01tabid.sys_cmd_analyze,
                                  acv.a_mblock.mb_data^.mbp_buf,
                                  acv.a_mblock.mb_data^.mbp_rec);
                            _b_err := acv.a_transinf.tri_trans.trError_gg00;
                            IF  (_b_err <> e_ok) AND (_b_err <> e_key_not_found)
                            THEN
                                a07_b_put_error (acv, _b_err, 1);
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  _b_err = e_ok
                        THEN
                            BEGIN
                            (* compare SQL_STATEMENT, because we could get the  *)
                            (* same hash value for different SQL statements     *)
                            ak544cmp_sql_statement(acv, _job, _linenr, _cmdhash,
                                  _linkage, _newhashslotpos, 1, _l_result);
                            IF  _l_result = l_equal
                            THEN
                                BEGIN
&                               ifdef TRACE
                                t01int4(ak_sem, 'stmt found  ', _newhashslotpos);
&                               endif
                                (* extract CMDID CHAR (8) BYTE from record *)
                                SAPDB_PascalMove ('VAK544',   1,    
                                      mbp_reclen, sizeof(_cmdid), @mbp_buf,
                                      mbp_keylen + cgg_rec_key_offset + 1 +
                                      1 (* define byte *),
                                      @_cmdid, 1, sizeof(_cmdid), _b_err);
                                _cmd_found := true;
                                END;
                            (*ENDIF*) 
                            END
                        ELSE
                            _eof := true;
                        (*ENDIF*) 
                    UNTIL
                        _cmd_found OR _eof;
                    (*ENDREPEAT*) 
                    IF  (NOT _cmd_found)
                    THEN
                        BEGIN
&                       ifdef TRACE
                        t01sname(ak_sem, 'insert cmd  ');
&                       endif
                        (* get unequivocal command identifier *)
                        _b_err  := e_ok;
                        _linkage:= 0;
                        _p1_pos := 1;
                        a05surrogate_get (acv, _cmdid);
                        (* insert new SQL command *)
                        REPEAT
                            (* built record *)
                            ak544cmd_analyze_rec_build ( acv, _job, _linenr,
                                  _cmdhash, _linkage, _newhashslotpos,
                                  _cmdid, _p1_pos, NOT c_only_key, _b_err);
                            IF  _b_err = e_ok
                            THEN
                                BEGIN
                                (* try to insert record *)
                                b02add_record (acv.a_transinf.tri_trans,
                                      g01tabid.sys_cmd_analyze,
                                      acv.a_mblock.mb_data^.mbp_rec);
                                _b_err := acv.a_transinf.tri_trans.trError_gg00;
                                (* PTS 1104142 E.Z. *)
                                IF  (_b_err <> e_ok)
                                    AND ((_loop_cnt = 2) OR
                                    (_b_err <> e_duplicate_key))
                                THEN
                                    a07_b_put_error (acv, _b_err, 1);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            _linkage := _linkage + 1;
                        UNTIL
                            (_p1_pos > acv.a_cmd_part^.sp1p_buf_len)
                            OR (_b_err <> e_ok);
                        (*ENDREPEAT*) 
                        END; (* NOT _cmd_found *)
                    (*ENDIF*) 
                    IF  _b_err = e_ok
                    THEN
                        BEGIN
&                       ifdef TRACE
                        t01surrogate(ak_sem, 'assoc CMDID ', _cmdid);
&                       endif
                        IF  a_ex_kind = only_parsing
                        THEN
                            BEGIN
                            (* associate parsid with _cmdid *)
                            _cmdidkey              := a01sysnullkey;
                            _cmdidkey.sauthid[ 1 ] := cak_tempinfo_byte;
                            SAPDB_PascalForcedMove (sizeof (a_pars_last_key),
                                  sizeof (_cmdidkey.sauthid),
                                  @a_pars_last_key, 1, @_cmdidkey.sauthid,
                                  2, 3);
                            _cmdidkey.sentrytyp := cak_ecommand_info;
&                           ifdef trace
                            t01buf (ak_sem, _cmdidkey, 1,
                                  _cmdidkey.skeylen + cgg_rec_key_offset);
&                           endif
                            a10_nil_get_sysinfo (acv, _cmdidkey, d_release,
                                  sizeof( tak_commandinforecord ),
                                  _cachearea, _b_err);
                            IF  _b_err <> e_ok
                            THEN
                                a07_b_put_error (acv, _b_err, 1)
                            ELSE
                                BEGIN
                                (* write command id *)
                                _cachearea^.scommand_info.cicommand_id := _cmdid;
                                a10add_sysinfo( acv, _cachearea, _b_err );
                                IF  ( _b_err <> e_ok )
                                THEN
                                    a07_b_put_error (acv, _b_err, 1)
                                END;
                            (*ENDIF*) 
                            END
                        ELSE
                            b21mp_cmdid_put (
                                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00,
                                  _cmdid);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (* PTS 1104142 E.Z. *)
                (*ENDIF*) 
            UNTIL
                (_loop_cnt = 2) OR (_b_err <> e_duplicate_key);
            (*ENDREPEAT*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak544cmd_analyze_rec_build(VAR acv : tak_all_command_glob;
            VAR job             : tsp00_C40;
            VAR linenr          : tsp00_Number;
            cmdhash             : tsp00_Int4;
            linkage             : integer;
            hashslotpos         : integer;
            VAR cmdid           : tgg00_Surrogate;
            VAR statement_pos   : integer; (*IN/OUT*)
            only_keypart        : boolean;
            VAR b_err           : tgg00_BasisError);
 
VAR
      _move_len     : integer;
      _pos          : integer;
      _i2           : tsp_int_map_c2;
      _num_err      : tsp00_NumError;
 
BEGIN
WITH acv.a_mblock, mb_data^ DO
    BEGIN
    (* KEY = JOB + LINENR + CMDHASH + LINKAGE + HASHLISTPOS *)
    mbp_keylen := 40 + 1 + 2*(((10 + 1) DIV 2) + 1 + 1) +
          (((1 + 1) DIV 2) + 1) + 1 + (((5 + 1)DIV 2) + 1 + 1);
    _pos := cgg_rec_key_offset + 1;
    (* write JOB CHAR(40) *)
    IF  g01unicode
    THEN
        mbp_buf[_pos] := csp_unicode_def_byte
    ELSE
        mbp_buf[_pos ] := csp_ascii_blank;
    (*ENDIF*) 
    _pos := _pos + 1;
    SAPDB_PascalMove ('VAK544',   2,    
          sizeof (job), mb_data_size,
          @job, 1, @mbp_buf, _pos, sizeof (job), b_err);
    _pos := _pos + sizeof (job);
    (* write LINE FIXED(10) *)
    mbp_buf[_pos] := csp_defined_byte;
    _pos := _pos + 1;
    SAPDB_PascalMove ('VAK544',   3,    
          sizeof (linenr), mb_data_size,
          @linenr, 1, @mbp_buf, _pos, ((10 + 1) DIV 2) + 1, b_err);
    _pos := _pos + (((10 + 1) DIV 2) + 1);
    (* write CMDHASH FIXED(10) *)
    mbp_buf[_pos] := csp_defined_byte;
    _pos := _pos + 1;
    s41plint (mbp_buf, _pos, 10, 0, cmdhash, _num_err);
    _pos := _pos + (((10 + 1) DIV 2) + 1);
    (* write LINKAGE FIXED(1) *)
    mbp_buf[_pos] := csp_defined_byte;
    _pos := _pos + 1;
    s41plint (mbp_buf, _pos, 1, 0, linkage, _num_err);
    _pos := _pos + (((1 + 1) DIV 2) + 1);
    (* write HASHLISTPOS FIXED(5) *)
    mbp_buf[_pos] := csp_defined_byte;
    _pos := _pos + 1;
    s41plint (mbp_buf, _pos, 5, 0, hashslotpos, _num_err);
    _pos := _pos + (((5 + 1) DIV 2) + 1);
    IF  only_keypart
    THEN
        BEGIN
        mbp_varcol_offset := 0;
        mbp_varcol_cnt    := 0;
        mbp_reclen        := mbp_keylen + cgg_rec_key_offset;
        END
    ELSE
        BEGIN
        (* write CMDID CHAR(8) BYTE *)
        mbp_buf[_pos] := csp_defined_byte;
        _pos := _pos + 1;
        SAPDB_PascalMove ('VAK544',   4,    
              sizeof (cmdid), mb_data_size, @cmdid, 1,
              @mbp_buf, _pos, sizeof (cmdid), b_err);
        _pos := _pos + sizeof (cmdid);
        (* no column of variable length *)
        mbp_varcol_offset := _pos - 1 - cgg_rec_key_offset - mbp_keylen;
        mbp_varcol_cnt    := 0;
        (* write SQL_STATEMENT CHAR(7800) *)
        IF  acv.a_cmd_part^.sp1p_buf_len - statement_pos + 1 > c_sql_stmt_datalen
        THEN
            _move_len := c_sql_stmt_datalen
        ELSE
            _move_len := acv.a_cmd_part^.sp1p_buf_len - statement_pos + 1;
        (*ENDIF*) 
        _i2.map_int     := _move_len + 1;
        mbp_buf[_pos]   := _i2.map_c2[1];
        mbp_buf[_pos+1] := _i2.map_c2[2];
        IF  g01unicode
        THEN
            mbp_buf[_pos+2] := csp_unicode_def_byte
        ELSE
            mbp_buf[_pos+2] := csp_ascii_blank;
        (*ENDIF*) 
        _pos := _pos + 3;
        SAPDB_PascalMove ('VAK544',   5,    
              acv.a_cmd_part^.sp1p_buf_size, mb_data_size,
              @acv.a_cmd_part^.sp1p_buf, statement_pos, @mbp_buf, _pos,
              _move_len, b_err);
        mbp_reclen    := _pos + _move_len - 1;
        statement_pos := statement_pos + _move_len;
        END;
    (*ENDIF*) 
    mb_data_len  := mbp_reclen;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak544cmp_sql_statement( VAR acv : tak_all_command_glob;
            VAR job             : tsp00_C40;
            VAR linenr          : tsp00_Number;
            cmdhash             : tsp00_Int4;
            linkage             : integer;
            hashslotpos         : integer;
            cmd_statement_pos   : integer;
            VAR l_result        : tsp00_LcompResult);
 
CONST
      c_cmdid_field_len = 9; (* CHAR(8) BYTE + define byte *)
 
VAR
      _longchar_offset : integer;
      _dummy_pos       : integer;
      _dummy_surrogate : tgg00_Surrogate;
      _i2              : tsp_int_map_c2;
      _b_err           : tgg00_BasisError;
 
BEGIN
_b_err   := e_ok;
l_result := l_equal;
&ifdef TRACE
t01int4(ak_sem, 'cmp linkage ', linkage);
&endif
WITH acv.a_mblock, mb_data^ DO
    BEGIN
    (* get SQL statement length *)
    _longchar_offset := 1 + cgg_rec_key_offset + mbp_keylen + c_cmdid_field_len;
    _i2.map_c2[1]    := mbp_buf[_longchar_offset];
    _i2.map_c2[2]    := mbp_buf[_longchar_offset+1];
    _longchar_offset := _longchar_offset + 2  + 1; (* skip define byte *)
    (* _i2.map_int == sql statement length *)
    _i2.map_int := _i2.map_int - 1; (* define byte *)
&   ifdef TRACE
    t01int4(ak_sem, 'stmt length ', _i2.map_int);
    t01int4(ak_sem, 'cmd pos     ', cmd_statement_pos);
    t01int4(ak_sem, 'buf len     ', acv.a_cmd_part^.sp1p_buf_len);
&   endif
    IF  (acv.a_cmd_part^.sp1p_buf_len - cmd_statement_pos + 1 > c_sql_stmt_datalen) AND
        (_i2.map_int >= c_sql_stmt_datalen )
    THEN
        BEGIN
&       ifdef TRACE
        t01sname(ak_sem, 'cmp piecewis');
&       endif
        (* compare piecewise *)
        s30cmp1(acv.a_cmd_part^.sp1p_buf, cmd_statement_pos,
              c_sql_stmt_datalen, mbp_buf, _longchar_offset,
              _i2.map_int, l_result );
        IF  l_result = l_equal
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'next piece  ');
&           endif
            (* get next linkage *)
            ak544cmd_analyze_rec_build( acv, job, linenr, cmdhash,
                  linkage  + 1, hashslotpos, _dummy_surrogate, _dummy_pos,
                  c_only_key, _b_err);
            IF  _b_err = e_ok
            THEN
                BEGIN
                (* search record *)
                b02get_record (acv.a_transinf.tri_trans,
                      g01tabid.sys_cmd_analyze, acv.a_mblock.mb_data^.mbp_buf,
                      acv.a_mblock.mb_data^.mbp_rec);
                _b_err := acv.a_transinf.tri_trans.trError_gg00;
                IF  (_b_err <> e_ok) AND (_b_err <> e_key_not_found)
                THEN
                    a07_b_put_error (acv, _b_err, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  _b_err = e_ok
            THEN
                ak544cmp_sql_statement(acv, job, linenr, cmdhash,
                      linkage + 1, hashslotpos,
                      cmd_statement_pos + c_sql_stmt_datalen , l_result);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        s30cmp1(acv.a_cmd_part^.sp1p_buf, cmd_statement_pos,
              acv.a_cmd_part^.sp1p_buf_len - cmd_statement_pos + 1,
              mbp_buf, _longchar_offset, _i2.map_int, l_result );
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
IF  l_result = l_equal
THEN
    t01sname(ak_sem, 'stmt equal  ')
ELSE
    t01sname(ak_sem, 'stmt not equ');
(*ENDIF*) 
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a544put_sysdata_analyze (
            VAR acv    : tak_all_command_glob);
 
CONST
      c_update_record = true;
 
VAR
      _cmdid : tgg00_Surrogate;
 
      _parseid_cast : RECORD
            CASE boolean OF
                true:
                    (parseid  : tak_parsid);
                false:
                    (idstream : tsp00_C12);
                END;
            (*ENDCASE*) 
 
      _dummympid    : tsp00_C12;
      _b_err        : tgg00_BasisError;
      _loop_cnt     : integer;
      _ok           : boolean;
 
BEGIN
(* not called for FETCH !! *)
(* *)
(* *)
b21m_cmdid (acv.a_transinf.tri_trans.trBdTcachePtr_gg00, _cmdid);
IF  _cmdid <> cgg_zero_id
THEN
    BEGIN
    (* get parseid *)
    b21m_parseid (acv.a_transinf.tri_trans.trBdTcachePtr_gg00, _dummympid, _parseid_cast.idstream);
&   ifdef TRACE
    t01buf1 (ak_sem, _parseid_cast.idstream, 1, sizeof(_parseid_cast.idstream));
&   endif
    IF  acv.a_createSharedSQL
    THEN
        BEGIN
&       ifdef TRACE
        t01name(ak_sem, 'sharedSQL         ');
&       endif
        IF  _parseid_cast.parseid.pid_parsk.p_kind = m_sharedSQLParseid
        THEN
            BEGIN
            _ok :=  a101_SetExecuteStatisticData (acv, _parseid_cast.parseid,  _cmdid,
                  b21m_sec (acv.a_transinf.tri_trans.trBdTcachePtr_gg00),
                  b21m_microsec (acv.a_transinf.tri_trans.trBdTcachePtr_gg00),
                  b21m_rows_read (acv.a_transinf.tri_trans.trBdTcachePtr_gg00),
                  b21m_rows_qual (acv.a_transinf.tri_trans.trBdTcachePtr_gg00),
                  b21m_virt_reads (acv.a_transinf.tri_trans.trBdTcachePtr_gg00),
                  b21m_phys_ios (acv.a_transinf.tri_trans.trBdTcachePtr_gg00),
                  b21m_rows_fetched (acv.a_transinf.tri_trans.trBdTcachePtr_gg00),
                  b21m_suspends (acv.a_transinf.tri_trans.trBdTcachePtr_gg00),
                  b21m_waits (acv.a_transinf.tri_trans.trBdTcachePtr_gg00));
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    _loop_cnt := 0;
    REPEAT
        _b_err := e_ok;
        _loop_cnt := succ(_loop_cnt);
        (* build key record with CMDID CHAR(8) BYTE and SESSION CHAR(4) BYTE *)
        ak544data_analyze_rec_build( acv, _cmdid,
              _parseid_cast.parseid.pid_session,
              c_only_key, NOT c_update_record, _b_err);
        IF  _b_err = e_ok
        THEN
            BEGIN
            (* search record according this key *)
            b02get_record (acv.a_transinf.tri_trans,
                  g01tabid.sys_data_analyze, acv.a_mblock.mb_data^.mbp_buf,
                  acv.a_mblock.mb_data^.mbp_rec);
            _b_err := acv.a_transinf.tri_trans.trError_gg00;
            IF  (_b_err <> e_ok) AND (_b_err <> e_key_not_found)
            THEN
                a07_b_put_error (acv, _b_err, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  _b_err = e_ok
        THEN
            BEGIN
            (* replace CMDID record *)
            ak544data_analyze_rec_build( acv, _cmdid,
                  _parseid_cast.parseid.pid_session,
                  NOT c_only_key, c_update_record, _b_err);
            IF  _b_err = e_ok
            THEN
                BEGIN
                (* try to replace record *)
                b02repl_record (acv.a_transinf.tri_trans,
                      g01tabid.sys_data_analyze, acv.a_mblock.mb_data^.mbp_rec);
                _b_err := acv.a_transinf.tri_trans.trError_gg00;
                IF  (_b_err <> e_ok) AND (_b_err <> e_key_not_found)
                THEN
                    a07_b_put_error (acv, _b_err, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            _b_err := e_ok;
            (* insert new record because CMDID isn't present *)
            ak544data_analyze_rec_build( acv, _cmdid,
                  _parseid_cast.parseid.pid_session,
                  NOT c_only_key, NOT c_update_record, _b_err);
            IF  _b_err = e_ok
            THEN
                BEGIN
                (* try to insert record *)
                b02add_record (acv.a_transinf.tri_trans,
                      g01tabid.sys_data_analyze, acv.a_mblock.mb_data^.mbp_rec);
                _b_err := acv.a_transinf.tri_trans.trError_gg00;
                IF  (_b_err <> e_ok)
                    AND ((_loop_cnt = 2) OR (_b_err <> e_duplicate_key))
                THEN
                    a07_b_put_error (acv, _b_err, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        (* PTS 1104623 E.Z. *)
    UNTIL
        (_loop_cnt = 2) OR (_b_err <> e_duplicate_key);
    (*ENDREPEAT*) 
    END;
&ifdef TRACE
(*ENDIF*) 
t01surrogate(ak_sem, 'CMDID       ', _cmdid);
t01name(ak_sem, '<a544put_sysdata_a');
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak544data_analyze_rec_build(VAR acv : tak_all_command_glob;
            VAR cmdid           : tgg00_Surrogate;
            VAR session         : tgg91_SessionNo;
            only_keypart        : boolean;
            update_record       : boolean;
            VAR b_err           : tgg00_BasisError);
 
VAR
      _pos          : integer;
      _res_len      : integer;
      _operand      : tsp00_Number;
      _operand2     : tsp00_Number;
      _mobj_ptr     : tsp00_MoveObjPtr;
      _num_err      : tsp00_NumError;
      _l_result     : tsp00_LcompResult;
      _runtime_pos  : integer;
      _ix           : integer;
      _name_len     : integer;
 
BEGIN
WITH acv.a_mblock, mb_data^ DO
    BEGIN
    IF  update_record
    THEN
        BEGIN
        (* key is up to date *)
        _pos := cgg_rec_key_offset + mbp_keylen + 1;
        (* update CALL_COUNT FIXED(20) *)
        (* increase call counter for non fetch commands              *)
        (* several FETCHes only count for one SELECT, but this isn't *)
        (* a problem, because this procedure will be called only for *)
        (* non FETCH commands                                        *)
        _mobj_ptr := @_operand;
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, 1, _num_err);
        IF  _num_err = num_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'upd call_cou');
&           endif
            s51add (mbp_buf, _pos + 1 (* define byte *), c_fixed20_size,
                  _operand, 1, csp_fixed DIV 2 + 1,
                  mbp_buf, _pos + 1 (* define byte *),
                  20 (* result length in digits *),
                  0, _res_len, _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err <> num_ok
        THEN
            mbp_buf[_pos] := csp_undef_byte;
        (*ENDIF*) 
        _pos := _pos + c_fixed20_size + 1;
        (* update ROWS_READ FIXED(20) *)
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, b21m_rows_read(
              acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
        IF  _num_err = num_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'upd rows_rea');
&           endif
            s51add (mbp_buf, _pos + 1 (* define byte *), c_fixed20_size,
                  _operand, 1, csp_fixed DIV 2 + 1,
                  mbp_buf, _pos + 1 (* define byte *),
                  20 (* result length in digits *),
                  0, _res_len, _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err <> num_ok
        THEN
            mbp_buf[_pos] := csp_undef_byte;
        (*ENDIF*) 
        _pos := _pos + (((20 + 1) DIV 2) + 1) + 1;
        (* update ROWS_QUAL FIXED(20) *)
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, b21m_rows_qual(
              acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
        IF  _num_err = num_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'upd rows_qua');
&           endif
            s51add (mbp_buf, _pos + 1 (* define byte *), c_fixed20_size,
                  _operand, 1, csp_fixed DIV 2 + 1,
                  mbp_buf, _pos + 1 (* define byte *),
                  20 (* result length in digits *),
                  0, _res_len, _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err <> num_ok
        THEN
            mbp_buf[_pos] := csp_undef_byte;
        (*ENDIF*) 
        _pos := _pos + (((20 + 1) DIV 2) + 1) + 1;
        (* update VIRTUAL_READS FIXED(20) *)
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, b21m_virt_reads(
              acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
        IF  _num_err = num_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'upd virt_rea');
&           endif
            s51add (mbp_buf, _pos + 1 (* define byte *), c_fixed20_size,
                  _operand, 1, csp_fixed DIV 2 + 1,
                  mbp_buf, _pos + 1 (* define byte *),
                  20 (* result length in digits *),
                  0, _res_len, _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err <> num_ok
        THEN
            mbp_buf[_pos] := csp_undef_byte;
        (*ENDIF*) 
        _pos := _pos + c_fixed20_size + 1;
        (* update RUNTIME FIXED(20,6) *)
        (* runtime := b21m_sec+b21m_microsec/1000000 *)
        (* 1000000 --> _operand2 *)
        _mobj_ptr := @_operand2;
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, 1000000, _num_err);
        (* b21m_microsec --> _operand *)
        _mobj_ptr := @_operand;
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, b21m_microsec(
              acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
        IF  _num_err = num_ok
        THEN
            (* b21m_microsec/1000000 --> _operand *)
            s51div (_mobj_ptr^, 1, c_fixed20_size,
                  _operand2, 1, csp_fixed DIV 2 + 1,
                  _mobj_ptr^, 1,
                  20 (* result length in digits *),
                  6, _res_len, _num_err);
        (*ENDIF*) 
        IF  _num_err = num_ok
        THEN
            BEGIN
            (* b21m_sec --> _operand2 *)
            _mobj_ptr := @_operand2;
            s41plint (_mobj_ptr ^, 1, csp_fixed, 0, b21m_sec(
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err = num_ok
        THEN
            (* b21m_sec + b21m_microsec/1000 --> _operand2 *)
            s51add (_mobj_ptr^, 1, c_fixed20_size,
                  _operand, 1, csp_fixed DIV 2 + 1,
                  _mobj_ptr^, 1,
                  20 (* result length in digits *),
                  6, _res_len, _num_err);
        (*ENDIF*) 
        IF  _num_err = num_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'upd runtime ');
&           endif
            s51add (mbp_buf, _pos + 1 (* define byte *), c_fixed20_size,
                  _operand2, 1, csp_fixed DIV 2 + 1,
                  mbp_buf, _pos + 1 (* define byte *),
                  20 (* result length in digits *),
                  6, _res_len, _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err <> num_ok
        THEN
            mbp_buf[_pos] := csp_undef_byte;
        (*ENDIF*) 
        _pos := _pos + c_fixed20_size + 1;
        (* write MIN_RUNTIME FIXED(20,6) *)
        IF  _num_err <> num_ok
        THEN
            BEGIN
            mbp_buf[_pos] := csp_undef_byte;
            _pos := _pos + c_fixed20_size + 1;
            END
        ELSE
            BEGIN
            _pos := _pos + 1; (* defined byte *)
            s30cmp2(_operand2, 1, c_fixed20_size, mbp_buf, _pos,
                  c_fixed20_size, _l_result);
            IF  _l_result = l_less
            THEN
                BEGIN
                SAPDB_PascalMove ('VAK544',   6,    
                      sizeof (_operand2), mb_data_size,
                      @_operand2, 1, @mbp_buf, _pos, c_fixed20_size, b_err);
                END;
            (*ENDIF*) 
            _pos := _pos + c_fixed20_size;
            END;
        (*ENDIF*) 
        (* write MAX_RUNTIME FIXED(20,6) *)
        IF  _num_err <> num_ok
        THEN
            BEGIN
            mbp_buf[_pos] := csp_undef_byte;
            _pos := _pos + c_fixed20_size + 1;
            END
        ELSE
            BEGIN
            _pos := _pos + 1; (* defined byte *)
            s30cmp2(_operand2, 1, c_fixed20_size, mbp_buf, _pos,
                  c_fixed20_size, _l_result);
            IF  _l_result = l_greater
            THEN
                BEGIN
                SAPDB_PascalMove ('VAK544',   7,    
                      sizeof (_operand2), mb_data_size,
                      @_operand2, 1, @mbp_buf, _pos, c_fixed20_size, b_err);
                END;
            (*ENDIF*) 
            _pos := _pos + c_fixed20_size;
            END;
        (*ENDIF*) 
        (* update VWAITS FIXED(20) *)
        _mobj_ptr := @_operand;  (* h.b. PTS 1106251 *)
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, b21m_waits(
              acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
        IF  _num_err = num_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'upd vwaits  ');
&           endif
            s51add (mbp_buf, _pos + 1 (* define byte *), c_fixed20_size,
                  _operand, 1, csp_fixed DIV 2 + 1,
                  mbp_buf, _pos + 1 (* define byte *),
                  20 (* result length in digits *),
                  0, _res_len, _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err <> num_ok
        THEN
            mbp_buf[_pos] := csp_undef_byte;
        (*ENDIF*) 
        _pos := _pos + c_fixed20_size + 1;
        (* update VSUSPENDS FIXED(20) *)
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, b21m_suspends(
              acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
        IF  _num_err = num_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'upd vsuspend');
&           endif
            s51add (mbp_buf, _pos + 1 (* define byte *), c_fixed20_size,
                  _operand, 1, csp_fixed DIV 2 + 1,
                  mbp_buf, _pos + 1 (* define byte *),
                  20 (* result length in digits *),
                  0, _res_len, _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err <> num_ok
        THEN
            mbp_buf[_pos] := csp_undef_byte;
        (*ENDIF*) 
        _pos := _pos + c_fixed20_size + 1;
        (* update PHYSICAL_IO FIXED(20) *)
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, b21m_phys_ios(
              acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
        IF  _num_err = num_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'upd phys_io ');
&           endif
            s51add (mbp_buf, _pos + 1 (* define byte *), c_fixed20_size,
                  _operand, 1, csp_fixed DIV 2 + 1,
                  mbp_buf, _pos + 1 (* define byte *),
                  20 (* result length in digits *),
                  0, _res_len, _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err <> num_ok
        THEN
            mbp_buf[_pos] := csp_undef_byte;
        (*ENDIF*) 
        _pos := _pos + c_fixed20_size + 1;
        (* update ROWS_FETCHED FIXED(20) *)
        s41plint (_mobj_ptr^, 1, csp_fixed, 0, b21m_rows_fetched(
              acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
        IF  _num_err = num_ok
        THEN
            BEGIN
&           ifdef TRACE
            t01sname(ak_sem, 'upd rows_fet');
&           endif
            s51add (mbp_buf, _pos + 1 (* define byte *), c_fixed20_size,
                  _operand, 1, csp_fixed DIV 2 + 1,
                  mbp_buf, _pos + 1 (* define byte *),
                  20 (* result length in digits *),
                  0, _res_len, _num_err);
            END;
        (*ENDIF*) 
        IF  _num_err <> num_ok
        THEN
            mbp_buf[_pos] := csp_undef_byte;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        (* KEY = CMDID CHAR(8) BYTE + SESSION CHAR(4) BYTE *)
        mbp_keylen := 1 (* define byte *) + 8 + 1 (* define byte *) + 4;
        _pos := cgg_rec_key_offset + 1;
        (* write CMDID CHAR(8) BYTE *)
        mbp_buf[_pos] := csp_defined_byte;
        _pos := _pos + 1;
        SAPDB_PascalMove ('VAK544',   8,    
              sizeof (cmdid), mb_data_size, @cmdid, 1,
              @mbp_buf, _pos, sizeof (cmdid), b_err);
        _pos := _pos + sizeof (cmdid);
        (* write SESSION CHAR(4) BYTE *)
        mbp_buf[_pos] := csp_defined_byte;
        _pos := _pos + 1;
        SAPDB_PascalMove ('VAK544',   9,    
              sizeof (session), mb_data_size, @session, 1,
              @mbp_buf, _pos, sizeof (session), b_err);
        _pos := _pos + sizeof (session);
        IF  only_keypart
        THEN
            BEGIN
            mbp_varcol_offset := 0;
            mbp_varcol_cnt    := 0;
            mbp_reclen        := mbp_keylen + cgg_rec_key_offset;
            END
        ELSE
            BEGIN
            (* write CALL_COUNT FIXED(20) *)
            mbp_buf[_pos] := csp_defined_byte;
            _pos := _pos + 1;
            s41plint (mbp_buf, _pos, 20, 0, 1 (* first command call *),
                  _num_err);
            _pos := _pos + c_fixed20_size;
            (* write ROWS_READ FIXED(20) *)
            mbp_buf[_pos] := csp_defined_byte;
            _pos := _pos + 1;
            s41plint (mbp_buf, _pos, 20, 0, b21m_rows_read(
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            _pos := _pos + c_fixed20_size;
            (* write ROWS_QUAL FIXED(20) *)
            mbp_buf[_pos] := csp_defined_byte;
            _pos := _pos + 1;
            s41plint (mbp_buf, _pos, 20, 0, b21m_rows_qual(
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            _pos := _pos + c_fixed20_size;
            (* write VIRTUAL_READS FIXED(20) *)
            mbp_buf[_pos] := csp_defined_byte;
            _pos := _pos + 1;
            s41plint (mbp_buf, _pos, 20, 0, b21m_virt_reads(
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            _pos := _pos + c_fixed20_size;
            (* write RUNTIME FIXED(20,6) *)
            _runtime_pos := _pos;
            mbp_buf[_pos] := csp_defined_byte;
            _pos := _pos + 1;
            (* runtime := b21m_sec+b21m_microsec/1000000 *)
            s41plint (mbp_buf, _pos, 20, 0, b21m_microsec(
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            _mobj_ptr := @_operand;
            s41plint (_mobj_ptr^, 1, csp_fixed, 0, 1000000, _num_err);
            IF  _num_err = num_ok
            THEN
                s51div (mbp_buf, _pos, c_fixed20_size,
                      _operand, 1, csp_fixed DIV 2 + 1,
                      mbp_buf, _pos,
                      20 (* result length in digits *),
                      6, _res_len, _num_err);
            (*ENDIF*) 
            IF  _num_err = num_ok
            THEN
                s41plint (_mobj_ptr^, 1, csp_fixed, 0, b21m_sec(
                      acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            (*ENDIF*) 
            IF  _num_err = num_ok
            THEN
                s51add (mbp_buf, _pos, c_fixed20_size,
                      _operand, 1, csp_fixed DIV 2 + 1,
                      mbp_buf, _pos,
                      20 (* result length in digits *),
                      6, _res_len, _num_err);
            (*ENDIF*) 
            IF  _num_err <> num_ok
            THEN
                mbp_buf[_pos - 1] := csp_undef_byte;
            (*ENDIF*) 
            _pos := _pos + c_fixed20_size;
            (* write MIN_RUNTIME = RUNTIME *)
            SAPDB_PascalOverlappingMove ('VAK544',  10,    
                  mb_data_size, mb_data_size, @mbp_buf, _runtime_pos,
                  @mbp_buf, _pos, c_fixed20_size + 1, b_err);
            (* defined byte + number *)
            _pos := _pos + c_fixed20_size + 1;
            (* write MAX_RUNTIME = RUNTIME *)
            SAPDB_PascalOverlappingMove ('VAK544',  11,    
                  mb_data_size, mb_data_size, @mbp_buf, _runtime_pos,
                  @mbp_buf, _pos, c_fixed20_size + 1, b_err);
            (* defined byte + number *)
            _pos := _pos + c_fixed20_size + 1;
            (* write VWAITS FIXED(20) *)
            mbp_buf[_pos] := csp_defined_byte;
            _pos := _pos + 1;
            s41plint (mbp_buf, _pos, 20, 0, b21m_waits(
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            _pos := _pos + c_fixed20_size;
            (* write VSUSPENDS FIXED(20) *)
            mbp_buf[_pos] := csp_defined_byte;
            _pos := _pos + 1;
            s41plint (mbp_buf, _pos, 20, 0, b21m_suspends(
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            _pos := _pos + c_fixed20_size;
            (* write PHYSICAL_IO FIXED(20) *)
            mbp_buf[_pos] := csp_defined_byte;
            _pos := _pos + 1;
            s41plint (mbp_buf, _pos, 20, 0, b21m_phys_ios(
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            _pos := _pos + c_fixed20_size;
            (* write ROWS_FETCHED FIXED(20) *)
            mbp_buf[_pos] := csp_defined_byte;
            _pos := _pos + 1;
            s41plint (mbp_buf, _pos, 20, 0, b21m_rows_fetched(
                  acv.a_transinf.tri_trans.trBdTcachePtr_gg00), _num_err);
            _pos := _pos + c_fixed20_size;
            (* start of var cols *)
            mbp_varcol_offset := _pos - 1 - cgg_rec_key_offset - mbp_keylen;
            (* write USERNAME CHAR(32) *)
            _name_len := a061identifier_len (acv.a_curr_user_name);
            mbp_buf[_pos] := chr(_name_len+1);
            IF  g01unicode
            THEN
                mbp_buf[_pos+1] := csp_unicode_def_byte
            ELSE
                mbp_buf[_pos+1] := csp_ascii_blank;
            (*ENDIF*) 
            FOR _ix := 1 TO _name_len DO
                mbp_buf[_pos + 1 + _ix] := acv.a_curr_user_name[_ix];
            (*ENDFOR*) 
            _pos := _pos + 2 + _name_len;
            mbp_varcol_cnt    := 1;
            mbp_reclen        := _pos - 1;
            END;
        (*ENDIF*) 
        mb_data_len  := mbp_reclen;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a544get_cmdid(VAR acv : tak_all_command_glob;
            VAR parskey : tak_parskey;
            VAR cmdid   : tgg00_Surrogate);
 
VAR
      _cmdidkey       : tgg00_SysInfoKey;
      _cachearea1     : tak_sysbufferaddress;
      _b_err          : tgg00_BasisError;
 
BEGIN
cmdid := cgg_zero_id;
(* get command id associated with parskey *)
_cmdidkey              := a01sysnullkey;
_cmdidkey.sauthid[ 1 ] := cak_tempinfo_byte;
SAPDB_PascalForcedMove (sizeof (parskey), sizeof (_cmdidkey.sauthid),
      @parskey, 1, @_cmdidkey.sauthid, 2, 3);
_cmdidkey.sentrytyp := cak_ecommand_info;
&ifdef trace
t01buf (ak_sem, _cmdidkey, 1, _cmdidkey.skeylen + cgg_rec_key_offset);
&endif
a10get_sysinfo (acv, _cmdidkey, d_release, _cachearea1, _b_err);
IF  _b_err = e_ok
THEN
    cmdid := _cachearea1^.scommand_info.cicommand_id;
&ifdef TRACE
(*ENDIF*) 
t01surrogate(ak_sem, 'CMDID       ', cmdid);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a544get_analyze_filter (VAR state : tsp00_C64);
 
VAR
      _pos : integer;
 
BEGIN
_pos  := 1;
state := bsp_c64;
IF  (actSelect_eak544 in a544diag_analyze_filter)
THEN
    BEGIN
    state [_pos]   := 'S';
    state [_pos+1] := 'E';
    state [_pos+2] := 'L';
    _pos := _pos + 4;
    END;
(*ENDIF*) 
IF  (actInsert_eak544 in a544diag_analyze_filter)
THEN
    BEGIN
    state [_pos]   := 'I';
    state [_pos+1] := 'N';
    state [_pos+2] := 'S';
    _pos := _pos + 4;
    END;
(*ENDIF*) 
IF  (actUpdate_eak544 in a544diag_analyze_filter)
THEN
    BEGIN
    state [_pos]   := 'U';
    state [_pos+1] := 'P';
    state [_pos+2] := 'D';
    _pos := _pos + 4;
    END;
(*ENDIF*) 
IF  (actDelete_eak544 in a544diag_analyze_filter)
THEN
    BEGIN
    state [_pos]   := 'D';
    state [_pos+1] := 'E';
    state [_pos+2] := 'L';
    _pos := _pos + 4;
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
