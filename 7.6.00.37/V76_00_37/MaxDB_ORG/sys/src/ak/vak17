.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-22
*****************************************************
modname : VAK17
changed : 2000-11-22
module  : AK_SAVE_RESTORE_LOAD
 
Author  : ThomasA
Created : 1987-09-22
*****************************************************
 
Purpose : support of save/restore/unload/reload table
 
Define  :
 
        PROCEDURE
              a17beginload_save_nolog (
                    VAR acv      : tak_all_command_glob;
                    VAR a11v     : tak_a11_glob);
 
        PROCEDURE
              a17call_semantic (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a17describe (
                    VAR acv    : tak_all_command_glob;
                    VAR a11v   : tak_a11_glob);
 
        PROCEDURE
              a17endload (
                    VAR acv  : tak_all_command_glob;
                    VAR a11v : tak_a11_glob);
 
        PROCEDURE
              a17saveinit (
                    VAR acv         : tak_all_command_glob;
                    VAR a11v        : tak_a11_glob;
                    is_short_string : boolean);
 
        PROCEDURE
              a17table_describe (
                    VAR acv    : tak_all_command_glob;
                    VAR a11v   : tak_a11_glob;
                    table_load : boolean);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04index_tree_build (
                    VAR file_id    : tgg00_FileId (*ptocConst*);
                    VAR index_tree : tgg00_FileId;
                    index_no       : tsp00_Int2);
 
        PROCEDURE
              g04short_col_tree_build (
                    VAR table_surrogate : tgg00_Surrogate (*ptocConst*);
                    VAR short_col_tree  : tgg00_FileId;
                    VAR b_err           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01treeid (
                    layer      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              t01moveobj (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
&       endif
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey       : tgg00_SysInfoKey;
              a01_i_sysmessages   : tsp00_KnlIdentifier;
 
        FUNCTION
              a01swap_int2 (old : tsp00_Int2): tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR mblock  : tgg00_MessBlock;
                    result_req  : boolean;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv         : tak_all_command_glob;
                    mtype           : tgg00_MessType;
                    m2type          : tgg00_MessType2;
                    VAR tree        : tgg00_FileId);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        FUNCTION
              a061exist_columnname (
                    VAR base_rec    : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_stamp_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tsp00_Key;
                    destpos    : integer;
                    mv_dest    : integer);
 
        PROCEDURE
              a05_unsigned_int2_get (
                    VAR acv  : tak_all_command_glob;
                    pos      : integer;
                    l        : tsp00_Int2;
                    err_code : tsp00_Int4;
                    VAR int  : tsp00_Int2);
 
        PROCEDURE
              a05identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05serial (
                    VAR acv        : tak_all_command_glob;
                    VAR colinfo    : tak00_columninfo;
                    VAR treeid     : tgg00_FileId;
                    VAR moveobj    : tsp00_MoveObj;
                    moveobj_size   : tsp00_Int4;
                    number_pos     : tsp00_Int4;
                    VAR number_len : integer;
                    with_retpart   : boolean);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07_const_b_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    param_addr : tsp00_MoveObjPtr;
                    const_len  : integer);
 
      ------------------------------ 
 
        FROM
              AK_BD_procedure_interface : VAK09;
 
        PROCEDURE
              a09load_constraint_info (
                    VAR acv         : tak_all_command_glob;
                    last_constraint : boolean;
                    VAR and_cnt     : integer);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    dstate     : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey);
 
        PROCEDURE
              a10_lock_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    lockm      : tgg00_LockReqMode);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_DestroyGroupedTempFiles(
                    VAR trans      : tgg00_TransContext;
                    fileType       : tgg00_TfnTemp;
                    level          : tsp00_Int4;
                    subLevel       : tsp00_Int2;
                    VAR fileName   : tgg00_Filename);
 
      ------------------------------ 
 
        FROM
              AK_Alter_Table : VAK13;
 
        PROCEDURE
              a13_build_mapping_stack (
                    VAR acv        : tak_all_command_glob;
                    VAR a11v       : tak_a11_glob;
                    VAR src_st_ptr : tgg00_StackListPtr;
                    VAR tar_st_ptr : tgg00_StackListPtr;
                    VAR src_col_cnt: tsp00_Int2;
                    VAR new_base   : boolean);
 
        PROCEDURE
              a13_new_catalog_desc (
                    VAR acv        : tak_all_command_glob;
                    VAR a11v       : tak_a11_glob;
                    VAR old_p      : tak_syspointerarr;
                    VAR extcol_map : tgg03_extcol_map;
                    VAR new_base   : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Data_Type_Options : VAK14;
 
        (* PTS 1116675 M.Ki *)
        FUNCTION
              a14LengthOfDefaultValue (
                    VAR DefaultRec : tak_defaultrecord) : integer; (* PTS 1108427 *)
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24init_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24get_indexname (
                    VAR acv        : tak_all_command_glob;
                    indexbuf       : tak_sysbufferaddress;
                    index          : integer;
                    VAR index_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a24finish_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record);
 
        FUNCTION
              a24next_named_index (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Link : VAK25;
 
        PROCEDURE
              a25linkload_info (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        PROCEDURE
              a28table_upd_statistics (
                    VAR acv       : tak_all_command_glob;
                    bForceUpdStat : boolean;
                    sample_rows   : tsp00_Int4;
                    sample_pct    : integer;
                    page_cnt      : tsp00_Int4;
                    rec_cnt       : tsp00_Int4;
                    sec_cnt       : tsp00_Int4;
                    colno         : integer;
                    add           : boolean;
                    commit        : boolean);
 
      ------------------------------ 
 
        FROM
              Deal-With-User-Commands : VAK92;
 
        PROCEDURE
              a92_next_part_get (
                    VAR acv       : tak_all_command_glob;
                    VAR curr_part : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1  : VBD01;
 
        PROCEDURE
              b01empty_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_9 : VBD09;
 
        PROCEDURE
              bd09GetNextLong (
                    VAR t             : tgg00_TransContext;
                    VAR file_id       : tgg00_FileId;
                    string_col_cnt    : integer;
                    VAR rk            : tgg00_Lkey;
                    VAR string_col_no : integer;
                    VAR col_id        : tgg00_FileId;
                    VAR file_pos      : tgg00_FilePos);
 
        PROCEDURE
              bd09FinishLoad (
                    VAR t          : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    rightmost_leaf : tsp00_PageNo);
 
        PROCEDURE
              bd09InitLoad (
                    VAR t              : tgg00_TransContext;
                    VAR file_id        : tgg00_FileId;
                    set_read_only      : boolean;
                    VAR rightmost_leaf : tsp00_PageNo);
 
        PROCEDURE
              bd09InitUnload (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              BD_modify_table : VBD37;
 
        PROCEDURE
              b37_init_conversion_info (
                    VAR t              : tgg00_TransContext;
                    ignore_err         : boolean;
                    source_stack       : tgg00_StackListPtr;
                    src_col_cnt        : integer;
                    target_stack       : tgg00_StackListPtr;
                    trunc_pos          : integer;
                    trunc_cnt          : integer;
                    VAR is_sorted      : boolean;
                    VAR addClusterKey  : boolean;
                    VAR FixedColLength : integer;
                    VAR code_tab       : tgg03_colinf;
                    VAR trunc_col      : tgg03_colinf;
                    VAR frac_col       : tgg03_colinf;
                    VAR not_null_col   : tgg03_not_null;
                    VAR check_col      : tgg03_check_col);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01glob           : tgg00_KernelGlobals;
              g01unicode        : boolean;
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(VAR TransContext : tgg00_TransContext;
                    wantedBytes : integer) : tsp00_MoveObjPtr;
 
        PROCEDURE
              gg941Deallocate(VAR TransContext : tgg00_TransContext;
                    VAR p : tgg03_unloadInfoPtr);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        (* PTS 1107617 E.Z. *)
        PROCEDURE
              vopmsgUnicode(
                    source_encoding : tsp00_Int4;
                    prio        : tsp00_Int2;
                    msgtype     : tsp00_Int2;
                    VAR msgline : tsp00_C132);
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40g4int (
                    VAR buf     : tsp00_MoveObj;
                    pos         : tsp00_Int4;
                    VAR dest    : tsp00_Int4;
                    VAR res     : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Number-Arithmetic : VSP51;
 
        PROCEDURE
              s51sub (
                    VAR left       : tsp00_MoveObj;
                    lpos           : tsp00_Int4;
                    llen           : integer;
                    VAR right      : tsp00_Number;
                    rpos           : tsp00_Int4;
                    rlen           : integer;
                    VAR result     : tsp00_MoveObj;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              a05_stamp_get;
 
              tsp00_MoveObj tsp00_Key
 
        PROCEDURE
              a15catalog_save;
 
              tak_save_viewscan_par tak_viewscan_par
 
        PROCEDURE
              a15restore_catalog;
 
              tak_save_viewscan_par tak_viewscan_par
              (* PTS 1107617 E.Z. *)
 
        PROCEDURE
              s51sub;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              gg941Allocate;
 
              tsp00_Addr tsp00_MoveObjPtr
 
        PROCEDURE
              gg941Deallocate;
 
              tsp00_Addr tgg03_unloadInfoPtr
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_outcopy       = true;
      c_set_read_only = true;
      c_all           = true;
      c_with_retpart  = true;
      (* PTS 1111576 E.Z. *)
 
 
(*------------------------------*) 
 
PROCEDURE
      ak17begin_save_string (VAR acv : tak_all_command_glob);
 
VAR
      ok             : boolean;
      i              : integer;
      string_col_cnt : integer;
      string_col_no  : integer;
      col_index      : integer;
      first_fixcolno : integer;
      ic2            : tsp_int_map_c2;
      aux            : tsp00_C6;
      treeid         : tgg00_FileId;
      col_id         : tgg00_FileId;
      file_pos       : tgg00_FilePos;
      data_ptr       : tsp1_part_ptr;
      bd_info_ptr    : tsp1_part_ptr;
      dummy_ptr      : tsp1_part_ptr;
      rk             : tgg00_Lkey;
 
BEGIN
ok := true;
ak17get_part_pointers (acv,
      data_ptr, bd_info_ptr, dummy_ptr, dummy_ptr);
IF  (bd_info_ptr = NIL) OR (data_ptr = NIL)
THEN
    a07_b_put_error (acv, e_too_short_datapart, 1)
ELSE
    WITH acv DO
        BEGIN
        a_ex_kind  := parsing_executing;
        a_init_ddl := no_ddl;
        SAPDB_PascalForcedMove (bd_info_ptr^.sp1p_buf_size, sizeof(treeid),
              @bd_info_ptr^.sp1p_buf, 1, @treeid, 1, sizeof(treeid));
        treeid.fileRootCheck_gg00 := ROOT_CHECK_GG00;
        SAPDB_PascalForcedMove (data_ptr^.sp1p_buf_size, sizeof (file_pos),
              @data_ptr^.sp1p_buf, 1, @file_pos, 1, FILE_POS_MXGG00);
        IF  a_out_packet^.sp1_header.sp1h_mess_swap
            <> g01code.kernel_swap
        THEN
            BEGIN
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 2];
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 1];
            string_col_cnt := ic2.map_int;
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 4];
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 3];
            string_col_no  := ic2.map_int;
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 6];
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 5];
            END
        ELSE
            BEGIN
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 1];
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 2];
            string_col_cnt  := ic2.map_int;
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 3];
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 4];
            string_col_no   := ic2.map_int;
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 5];
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[FILE_POS_MXGG00 + 6];
            END;
        (*ENDIF*) 
        rk.keyLen_gg00          := ic2.map_int;
        SAPDB_PascalForcedMove (data_ptr^.sp1p_buf_size, sizeof (rk.keyVal_gg00),
              @data_ptr^.sp1p_buf, FILE_POS_MXGG00 + 7,
              @rk.keyVal_gg00, 1, rk.keyLen_gg00);
        acv.a_transinf.tri_trans.trError_gg00 := e_ok;
        (* PTS 1116259 M.Ki *)
        a06_systable_get (acv, d_release, treeid.fileTabId_gg00,
              acv.a_p_arr1.pbasep, c_all, ok);
        IF  acv.a_p_arr1.pbasep^.sbase.bcntdropcol > 0
        THEN
            (* string_col_no needs to be mapped to the old record layout,*)
            (* where we might have dropped LONG columns in between valid *)
            (* LONG columns                                              *)
            WITH acv.a_p_arr1.pbasep^.sbase DO
                BEGIN (* adjust string_col_no *)
                col_index      := bcolumn[ blastkeyind ]^.cnextind;
                first_fixcolno := bcolumn[ col_index   ]^.creccolno;
                WHILE col_index <> 0 DO
                    BEGIN
                    IF  (bcolumn[ col_index ]^.cdatatyp in
                        [dstra, dstrb, dstruni,
                        dlonga, dlongb, dlonguni])
                        AND
                        (ctdropped in bcolumn[ col_index ]^.ccolpropset)
                        AND
                        ((bcolumn[ col_index ]^.creccolno-first_fixcolno) <
                        string_col_no)
                    THEN
                        string_col_no := succ (string_col_no);
                    (*ENDIF*) 
                    col_index := bcolumn[ col_index ]^.cnextind;
                    END;
                (*ENDWHILE*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  ok
        THEN
            bd09GetNextLong (acv.a_transinf.tri_trans, treeid,
                  acv.a_p_arr1.pbasep^.sbase.bstringcount, rk, string_col_no,
                  col_id, file_pos);
        (*ENDIF*) 
        IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
        THEN
            bd09InitUnload (acv.a_transinf.tri_trans, col_id);
        (*ENDIF*) 
        IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
        THEN
            BEGIN
            (* map new string_col_no back to new layout *)
            IF  acv.a_p_arr1.pbasep^.sbase.bcntdropcol > 0
            THEN
                WITH acv.a_p_arr1.pbasep^.sbase DO
                    BEGIN (* map string_col_no back to new layout *)
                    col_index      := bcolumn[ blastkeyind ]^.cnextind;
                    first_fixcolno := bcolumn[ col_index   ]^.creccolno;
                    WHILE col_index <> 0 DO
                        BEGIN
                        IF  (bcolumn[ col_index ]^.cdatatyp in
                            [dstra, dstrb, dstruni,
                            dlonga, dlongb, dlonguni])
                            AND
                            (ctdropped in bcolumn[ col_index ]^.ccolpropset)
                            AND
                            ((bcolumn[ col_index ]^.creccolno-first_fixcolno) <
                            string_col_no)
                        THEN
                            string_col_no := pred (string_col_no);
                        (*ENDIF*) 
                        col_index := bcolumn[ col_index ]^.cnextind;
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            a06retpart_move (acv, @col_id, sizeof (col_id));
            FOR i := 1 TO 2 DO
                a06retpart_move (acv,
                      @col_id.fileRoot_gg00, sizeof (col_id.fileRoot_gg00));
            (*ENDFOR*) 
            a06finish_curr_retpart (acv, sp1pk_bdinfo, 1);
            a06retpart_move (acv, @file_pos, FILE_POS_MXGG00);
            ic2.map_int := string_col_cnt;
            IF  a_out_packet^.sp1_header.sp1h_mess_swap
                <> g01code.kernel_swap
            THEN
                BEGIN
                aux[1] := ic2.map_c2[ 2 ];
                aux[2] := ic2.map_c2[ 1 ];
                END
            ELSE
                BEGIN
                aux[1] := ic2.map_c2[ 1 ];
                aux[2] := ic2.map_c2[ 2 ];
                END;
            (*ENDIF*) 
            ic2.map_int := string_col_no;
            IF  a_out_packet^.sp1_header.sp1h_mess_swap
                <> g01code.kernel_swap
            THEN
                BEGIN
                aux[3] := ic2.map_c2[ 2 ];
                aux[4] := ic2.map_c2[ 1 ];
                END
            ELSE
                BEGIN
                aux[3] := ic2.map_c2[ 1 ];
                aux[4] := ic2.map_c2[ 2 ];
                END;
            (*ENDIF*) 
            ic2.map_int := rk.keyLen_gg00;
            IF  a_out_packet^.sp1_header.sp1h_mess_swap
                <> g01code.kernel_swap
            THEN
                BEGIN
                aux[5] := ic2.map_c2[ 2 ];
                aux[6] := ic2.map_c2[ 1 ];
                END
            ELSE
                BEGIN
                aux[5] := ic2.map_c2[ 1 ];
                aux[6] := ic2.map_c2[ 2 ];
                END;
            (*ENDIF*) 
            a06retpart_move (acv, @aux, sizeof(aux));
            a06retpart_move (acv, @rk.k, rk.keyLen_gg00);
            a06finish_curr_retpart (acv, sp1pk_key, 1)
            END
        ELSE
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak17clean_up (
            VAR acv   : tak_all_command_glob;
            VAR tabid : tgg00_Surrogate);
 
CONST
      c_allLevels    = -1;
      c_allSublevels = -1;
 
VAR
      b_err        : tgg00_BasisError;
      aux_return   : tsp00_Int2;
      aux_errorpos : tsp00_Int4;
      sysk         : tgg00_SysInfoKey;
      tree         : tgg00_FileId;
 
BEGIN
WITH acv DO
    BEGIN
    sysk             := a01defaultkey;
    sysk.stableid    := tabid;
    aux_return   := a_returncode;
    aux_errorpos := a_errorpos;
    a_returncode := 0;
    IF  a_constraint_cnt > 0
    THEN
        BEGIN
        (* destroy temporary constraint information *)
        sysk.sentrytyp   := cak_emessblock;
        sysk.slinkage[2] := chr(1);
        a10del_sysinfo (acv, sysk, b_err)
        END;
    (*ENDIF*) 
    IF  a_fk_check_cnt <> 0
    THEN
        BEGIN
        (* destroy temporary foreign key information *)
        a101_DestroyGroupedTempFiles(
              a_transinf.tri_trans,
              ttfnLink_egg00,
              c_allLevels,
              c_allSublevels,
              tree.fileName_gg00);
        sysk.sentrytyp := cak_elinkparsinfo;
        sysk.slinkage  := cak_init_linkage;
        WHILE (ord(sysk.slinkage[ 2 ]) <= abs(a_fk_check_cnt)) DO
            BEGIN
            a10del_sysinfo (acv, sysk, b_err);
            a06inc_linkage (sysk.slinkage)
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    a_returncode := aux_return;
    a_errorpos   := aux_errorpos;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak17code_byte_swap (
            VAR acv             : tak_all_command_glob;
            is_outcopy          : boolean;
            VAR table_desc      : tsp7_table_description);
 
VAR
      uni_e       : tsp8_uni_error;
      err_char_no : tsp00_Int4;
      BufLen      : tsp00_Int4;
      BufSize     : tsp00_Int4;
      i           : integer;
      packet_ptr  : tsp1_packet_ptr;
 
BEGIN
WITH acv, table_desc DO
    BEGIN
    IF  is_outcopy
    THEN
        packet_ptr := a_out_packet
    ELSE
        packet_ptr := a_in_packet;
    (*ENDIF*) 
    IF  NOT is_outcopy AND
        (a_cmd_packet_header.sp1h_mess_swap <> g01code.kernel_swap)
    THEN
        BEGIN
        sp7t_field_cnt      := a01swap_int2 (sp7t_field_cnt);
        sp7t_constraint_cnt := a01swap_int2 (sp7t_constraint_cnt)
        END;
    (*ENDIF*) 
    FOR i := 1 TO sp7t_field_cnt DO
        WITH sp7t_fields[ i ] DO
            BEGIN
            IF  packet_ptr^.sp1_header.sp1h_mess_swap <>
                g01code.kernel_swap
            THEN
                BEGIN
                sp7fi_def_col_no  := a01swap_int2 (sp7fi_def_col_no);
                sp7fi_stmt_col_no := a01swap_int2 (sp7fi_stmt_col_no);
                sp7fi_len         := a01swap_int2 (sp7fi_len);
                sp7fi_in_out_l    := a01swap_int2 (sp7fi_in_out_l)
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDFOR*) 
    IF  g01unicode AND
        (a_out_packet^.sp1_header.sp1h_mess_swap  <> sw_normal)
    THEN
        BEGIN
        BufLen  := sizeof(sp7t_authid);
        BufSize := sizeof(sp7t_authid);
        s80uni_trans (@sp7t_authid, sizeof(sp7t_authid),
              csp_unicode, @sp7t_authid,
              BufSize, csp_unicode_swap, [ ],
              uni_e, err_char_no);
        BufLen  := sizeof(sp7t_tablename);
        BufSize := sizeof(sp7t_tablename);
        s80uni_trans (@sp7t_tablename, sizeof(sp7t_tablename),
              csp_unicode, @sp7t_tablename,
              BufSize, csp_unicode_swap, [ ],
              uni_e, err_char_no);
        END;
    (*ENDIF*) 
    IF  is_outcopy AND
        (a_out_packet^.sp1_header.sp1h_mess_swap <> g01code.kernel_swap)
    THEN
        BEGIN
        sp7t_field_cnt      := a01swap_int2 (sp7t_field_cnt);
        sp7t_constraint_cnt := a01swap_int2 (sp7t_constraint_cnt)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1120287 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak17describe_default (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
VAR
      new_base   : boolean;
      defaultLen : tsp00_Int2;
      b_err      : tgg00_BasisError;
      sysk       : tgg00_SysInfoKey;
      extcolno   : tsp00_Int2;
      oldbase_p  : tak_syspointerarr;
      extcol_map : tgg03_extcol_map;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    sysk             := a_p_arr1.pbasep^.syskey;
    sysk.sentrytyp   := cak_edefault;
    IF  a_cmd_packet_header.sp1h_mess_swap <> sw_normal
    THEN
        extcolno := ord(a_data_ptr^[1]) + ord(a_data_ptr^[2])*256
    ELSE
        extcolno := ord(a_data_ptr^[2]) + ord(a_data_ptr^[1])*256;
    (*ENDIF*) 
    (* PTS 1116259 M.Ki.: get clean output record map for extcolnos*)
    new_base := false;
    a13_new_catalog_desc (acv, a11v, oldbase_p,
          extcol_map, new_base);
    extcolno := oldbase_p.pbasep^.sbase.bcolumn[
          extcol_map[extcolno].em_old_colind ]^.cextcolno;
    sysk.slinkage[1] := chr (extcolno DIV 256);
    sysk.slinkage[2] := chr (extcolno MOD 256);
    a10get_sysinfo (acv, sysk, d_release, a1valsysp, b_err);
    IF  b_err = e_ok
    THEN
        WITH a1valsysp^.sdefault DO
            BEGIN
            (* PTS 1108427, 1116675 *)
            defaultLen := a14LengthOfDefaultValue(a1valsysp^.sdefault);
            IF  a_out_packet^.sp1_header.sp1h_mess_swap
                <> g01code.kernel_swap
            THEN
                defaultLen := a01swap_int2(defaultLen);
            (*ENDIF*) 
            a06retpart_move (acv, @defaultLen, sizeof(defaultLen));
            a06retpart_move (acv, @dfvalues[2],
                  a14LengthOfDefaultValue(a1valsysp^.sdefault));
            a06finish_curr_retpart (acv, sp1pk_data, 1)
            END
        (*ENDWITH*) 
    ELSE
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    IF  new_base
    THEN
        a10_key_del (acv, acv.a_p_arr1.pbasep^.syskey);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak17end_restore (VAR acv : tak_all_command_glob);
 
VAR
      data_ptr       : tsp1_part_ptr;
      bd_info_ptr    : tsp1_part_ptr;
      dummy_ptr      : tsp1_part_ptr;
      rightmost_leaf : tsp00_PageNo;
      treeid         : tgg00_FileId;
 
BEGIN
ak17get_part_pointers (acv,
      data_ptr, bd_info_ptr, dummy_ptr, dummy_ptr);
WITH acv DO
    IF  bd_info_ptr = NIL
    THEN
        a07_b_put_error (acv, e_too_short_datapart, 1)
    ELSE
        BEGIN
        SAPDB_PascalForcedMove (bd_info_ptr^.sp1p_buf_size, sizeof(treeid),
              @bd_info_ptr^.sp1p_buf, 1, @treeid, 1, sizeof(treeid));
        treeid.fileRootCheck_gg00 := ROOT_CHECK_GG00;
        SAPDB_PascalForcedMove (bd_info_ptr^.sp1p_buf_size, sizeof(rightmost_leaf),
              @bd_info_ptr^.sp1p_buf, sizeof(treeid) + 1,
              @rightmost_leaf, 1, sizeof(rightmost_leaf));
        acv.a_transinf.tri_trans.trError_gg00 := e_ok;
        bd09FinishLoad (acv.a_transinf.tri_trans,
              treeid, rightmost_leaf);
        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
        IF  (treeid.fileTfn_gg00 = tfnTable_egg00) (* PTS 1110396 *)
        THEN
            BEGIN
            IF  (a_restore_with_string > 0)
            THEN (* empty file containing short string columns *)
                b01empty_file (acv.a_transinf.tri_trans, a_into_tree);
            (*ENDIF*) 
            ak17clean_up (acv, treeid.fileTabId_gg00);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak17get_default_range (
            VAR acv              : tak_all_command_glob;
            VAR a11v             : tak_a11_glob;
            VAR sysptr           : tak_syspointerarr; (* PTS 1116259 M.Ki *)
            VAR col_info         : tak00_columninfo;
            VAR def_type         : tsp7_default);
 
VAR
      b_err       : tgg00_BasisError;
 
BEGIN
def_type := sp7_no_default;
WITH acv, a11v, a_p_arr1, col_info DO
    BEGIN
    def_type  := sp7_no_default;
    a1valsysp := NIL;
    IF  ctdefault in ccolpropset
    THEN
        BEGIN
        a1valkey := a01defaultkey;
        WITH a1valkey DO
            BEGIN
            stableid    := sysptr.pbasep^.syskey.stableid; (* PTS 1116259 M.Ki *)
            sentrytyp   := cak_edefault;
            slinkage[1] := chr (cextcolno DIV 256);
            slinkage[2] := chr (cextcolno MOD 256)
            END;
        (*ENDWITH*) 
        a10get_sysinfo (acv, a1valkey, d_fix, a1valsysp, b_err);
        IF  b_err = e_ok
        THEN
            WITH a1valsysp^.sdefault DO
                BEGIN
                IF  dfdefault_function > 0
                THEN
                    CASE dfdefault_function OF
                        cak_x_date :
                            def_type := sp7_default_date;
                        cak_x_stamp:
                            def_type := sp7_default_stamp;
                        cak_x_timestamp :
                            def_type := sp7_default_timestamp;
                        cak_x_time :
                            def_type := sp7_default_time;
                        cak_x_user :
                            def_type := sp7_default_user;
                        cak_x_usergroup :
                            def_type := sp7_default_usergroup;
                        cak_x_uid :
                            def_type := sp7_default_uid;
                        cak_x_true :
                            def_type := sp7_default_true;
                        cak_x_false :
                            def_type := sp7_default_false;
                        (* PTS 1122484 E.Z. *)
                        cak_x_utcdate :
                            def_type := sp7_default_utcdate;
                        cak_x_utcdiff :
                            def_type := sp7_default_utcdiff;
                        cak_x_timezone :
                            def_type := sp7_default_timezone;
                        cak_x_sysdba :
                            def_type := sp7_default_sysdba;
                        OTHERWISE
                            a07ak_system_error (acv, 17, 1);
                        END
                    (*ENDCASE*) 
                ELSE
                    def_type := sp7_other_default;
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        ELSE
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* PTS 1120287 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak17describe_index (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
VAR
      new_base       : boolean;
      i,j            : integer;
      named_indexes  : integer;
      indexname_len  : integer;
      single_set     : tak_columnset;
      index_desc     : ^tsp7_index_description;
      index_name     : tsp00_KnlIdentifier;
      index_scan_rec : tak_index_scan_record;
      oldbase_p      : tak_syspointerarr;
      extcol_map     : tgg03_extcol_map;
 
BEGIN
WITH acv, a_p_arr1, a11v DO
    BEGIN
    new_base := false;
    IF  a_curr_retpart = NIL
    THEN
        a06init_curr_retpart (acv);
    (*ENDIF*) 
    IF  a_curr_retpart <> NIL
    THEN
        BEGIN
        index_desc := @a_curr_retpart^.sp1p_buf;
        SAPDB_PascalFill ('VAK17 ',   1,    
              a_curr_retpart^.sp1p_buf_size, @a_curr_retpart^.sp1p_buf,
              1, a_curr_retpart^.sp1p_buf_size, chr(0),
              a_returncode);
        index_desc^.sp7i_first_mult_index := 0;
        index_desc^.sp7i_single_index_cnt := chr(0);
        index_desc^.sp7i_mult_index_cnt   := 0;
        a_curr_retpart^.sp1p_buf_len      := sizeof (index_desc^) -
              sizeof (index_desc^.sp7i_index_names);
        single_set                        := [  ];
        named_indexes                     := 0;
        IF  pbasep^.sbase.bindexexist
        THEN
            BEGIN
            a24init_index_scan (acv, pbasep^.sbase.bsurrogate,
                  index_scan_rec);
            WHILE a24next_named_index (acv, index_scan_rec) DO
                WITH index_scan_rec, isr_buf^.smindex.indexdef[isr_index] DO
                    BEGIN
                    named_indexes := named_indexes + 1;
                    IF  icount = 1
                    THEN
                        single_set := single_set + [icolseq[1]]
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDWHILE*) 
            a24finish_index_scan (acv, index_scan_rec)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (pbasep^.sbase.bindexexist) AND
        (a_returncode = 0)
    THEN
        WITH index_desc^ DO
            BEGIN
            sp7i_first_mult_index        := sp7i_first_mult_index + 1;
            a_curr_retpart^.sp1p_buf_len :=
                  sizeof (sp7i_single_index_cnt) +
                  sizeof (sp7i_filler           ) +
                  sizeof (sp7i_first_mult_index ) +
                  sizeof (sp7i_mult_index_cnt   ) +
                  (sp7i_first_mult_index + named_indexes - 1) *
                  sizeof (sp7i_mult_index[1]);
            a24init_index_scan (acv, pbasep^.sbase.bsurrogate,
                  index_scan_rec);
            WHILE a24next_named_index (acv, index_scan_rec) DO
                WITH index_scan_rec, isr_buf^.smindex.indexdef[isr_index] DO
                    BEGIN
                    a24get_indexname (acv, isr_buf,
                          isr_index, index_name);
                    indexname_len := a061identifier_len (index_name);
                    ak17move_name (acv, index_name, indexname_len);
                    WITH sp7i_mult_index[sp7i_first_mult_index +
                         sp7i_mult_index_cnt ] DO
                        BEGIN
                        IF  icount = 1
                        THEN
                            sp7mi_index_id := icolseq[ 1 ]
                        ELSE
                            sp7mi_index_id := indexno + MAX_COL_PER_TAB_GG00;
                        (*ENDIF*) 
                        IF  a_out_packet^.sp1_header.sp1h_mess_swap
                            <> g01code.kernel_swap
                        THEN
                            sp7mi_index_id := a01swap_int2 (sp7mi_index_id);
                        (*ENDIF*) 
                        sp7mi_col_cnt    := icount;
                        sp7mi_unique     := iunique;
                        sp7mi_found      := false;
                        sp7mi_filler[ 1 ]:= chr(0);
                        sp7mi_filler[ 2 ]:= chr(0);
                        sp7mi_filler[ 3 ]:= chr(0);
                        FOR j := 1 TO icount DO
                            BEGIN
                            IF  a_out_packet^.sp1_header.sp1h_mess_swap
                                <> g01code.kernel_swap
                            THEN
                                sp7mi_def_col_no[ j ] := a01swap_int2(icolseq[ j ])
                            ELSE
                                sp7mi_def_col_no[ j ] := icolseq[ j ];
                            (*ENDIF*) 
                            sp7mi_descending[ j ] := icolstack[ j ].eop in
                                  [ op_order_desc, op_unique_desc ]
                            END;
                        (*ENDFOR*) 
                        sp7i_mult_index_cnt := sp7i_mult_index_cnt + 1
                        END;
                    (*ENDWITH*) 
                    END;
                (*ENDWITH*) 
            (*ENDWHILE*) 
            a24finish_index_scan (acv, index_scan_rec)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        WITH index_desc^ DO
            BEGIN
            IF  sp7i_mult_index_cnt <> 0
            THEN
                BEGIN
                (* PTS 1116259 M.Ki.: get clean output record map and *)
                (*                    adjust index column numbers     *)
                a13_new_catalog_desc (acv, a11v, oldbase_p,
                      extcol_map, new_base);
                IF  a_returncode = 0
                THEN
                    FOR i := 0 TO sp7i_mult_index_cnt-1 DO
                        WITH sp7i_mult_index[sp7i_first_mult_index + i] DO
                            FOR j := 1 TO sp7mi_col_cnt DO
                                IF  a_out_packet^.sp1_header.sp1h_mess_swap
                                    <> g01code.kernel_swap
                                THEN
                                    sp7mi_def_col_no[ j ] := a01swap_int2(acv.a_p_arr1.pbasep^.
                                          sbase.bcolumn[ extcol_map[
                                          sp7mi_def_col_no[j]].em_new_colind ]^.cextcolno)
                                ELSE
                                    sp7mi_def_col_no[ j ] := acv.a_p_arr1.pbasep^.
                                          sbase.bcolumn[ extcol_map[
                                          sp7mi_def_col_no[j]].em_new_colind ]^.cextcolno;
                                (*ENDIF*) 
                            (*ENDFOR*) 
                        (*ENDWITH*) 
                    (*ENDFOR*) 
                (*ENDIF*) 
                IF  new_base
                THEN
                    a10_key_del (acv, acv.a_p_arr1.pbasep^.syskey);
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                index_desc^.sp7i_first_mult_index := 0;
                a_curr_retpart^.sp1p_buf_len  := a_curr_retpart^.sp1p_buf_len +
                      ord (index_desc^.sp7i_single_index_cnt) *
                      sizeof (tsp7_info_single_index)
                END;
            (*ENDIF*) 
&           ifdef trace
            t01moveobj (ak_sem, a_curr_retpart^.sp1p_buf, 1,
                  a_curr_retpart^.sp1p_buf_len);
&           endif
            IF  a_out_packet^.sp1_header.sp1h_mess_swap <> g01code.kernel_swap
            THEN
                BEGIN
                index_desc^.sp7i_first_mult_index := a01swap_int2(index_desc^.sp7i_first_mult_index);
                index_desc^.sp7i_mult_index_cnt   := a01swap_int2(index_desc^.sp7i_mult_index_cnt);
                END;
            (*ENDIF*) 
            a06finish_curr_retpart (acv, sp1pk_data, 1)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1111576 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak17get_part_pointers (
            VAR acv           : tak_all_command_glob;
            VAR data_ptr      : tsp1_part_ptr;
            VAR bd_info_ptr   : tsp1_part_ptr;
            VAR serial_ptr    : tsp1_part_ptr;
            VAR surrogate_ptr : tsp1_part_ptr);
 
VAR
      ix            : integer;
      curr_part_ptr : tsp1_part_ptr;
 
BEGIN
curr_part_ptr := NIL;
data_ptr      := NIL;
bd_info_ptr   := NIL;
serial_ptr    := NIL;
surrogate_ptr := NIL;
FOR ix := 1 TO acv.a_cmd_segment_header.sp1s_no_of_parts DO
    BEGIN
    a92_next_part_get (acv, curr_part_ptr);
    IF  curr_part_ptr <> NIL
    THEN
        CASE curr_part_ptr^.sp1p_part_kind OF
            sp1pk_data :
                data_ptr := curr_part_ptr;
            sp1pk_bdinfo :
                bd_info_ptr := curr_part_ptr;
            sp1pk_serial :
                serial_ptr := curr_part_ptr;
            sp1pk_surrogate :
                surrogate_ptr := curr_part_ptr;
            OTHERWISE ;
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak17move_name (
            VAR acv     : tak_all_command_glob;
            VAR colname : tsp00_KnlIdentifier;
            name_len    : integer);
 
VAR
      pos : tsp00_Int4;
 
BEGIN
pos := acv.a_curr_retpart^.sp1p_buf_len + 1;
IF  pos + name_len > acv.a_curr_retpart^.sp1p_buf_size
THEN
    a07_b_put_error (acv, e_too_small_packet_size, 1)
ELSE
    BEGIN
    acv.a_curr_retpart^.sp1p_buf[pos] := chr(name_len);
    SAPDB_PascalMove ('VAK17 ',   2,    
          name_len, acv.a_curr_retpart^.sp1p_buf_size,
          @colname, 1, @acv.a_curr_retpart^.sp1p_buf,
          pos + 1, name_len, acv.a_returncode);
    acv.a_curr_retpart^.sp1p_buf_len := pos + name_len
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak17put_index_stack_entries (VAR acv : tak_all_command_glob);
 
VAR
      b_err        : tgg00_BasisError;
      i            : integer;
      j            : integer;
      mind_buf     : tak_sysbufferaddress;
      sysk         : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a_mblock, mb_qual^  DO
    BEGIN
    IF  (a_returncode = 0) AND
        (a_p_arr1.pbasep^.sbase.bindexexist)
    THEN
        BEGIN
        sysk           := a_p_arr1.pbasep^.syskey;
        sysk.sentrytyp := cak_emindex;
        a10get_sysinfo (acv, sysk, d_release, mind_buf, b_err);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            mmult_pos := mfirst_free;
            FOR i := 1 TO mind_buf^.smindex.indexcount DO
                WITH mind_buf^.smindex.indexdef[ i ] DO
                    IF  (indexno <> 0) AND
                        (icount <> 1)
                    THEN
                        IF  (mfirst_free + icount - 1 <= mst_max)
                        THEN
                            BEGIN
                            FOR j := 1 TO icount DO
                                BEGIN
                                mb_st^ [mfirst_free]:=icolstack[ j ];
                                mfirst_free := mfirst_free + 1;
                                END;
                            (*ENDFOR*) 
                            mmult_cnt := mmult_cnt + icount;
                            END
                        ELSE
                            a07_b_put_error (acv,
                                  e_too_many_mb_stackentries, 1);
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak17store_constraint_info (
            VAR acv         : tak_all_command_glob;
            VAR a11v        : tak_a11_glob);
 
VAR
      b_err   : tgg00_BasisError;
      i       : integer;
      and_cnt : integer;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    a1valkey           := a_p_arr1.pbasep^.syskey;
    a1valkey.sentrytyp := cak_econstraint;
    i       := 1;
    and_cnt := 0;
    a06a_mblock_init (acv,
          m_select, mm_nil, a_p_arr1.pbasep^.sbase.btreeid);
    WHILE i <= a_p_arr1.pbasep^.sbase.bnamed_constr DO
        BEGIN
        a1valkey.slinkage[1] := chr(i DIV 256);
        a1valkey.slinkage[2] := chr(i MOD 256);
        a10get_sysinfo (acv, a1valkey, d_release, a_ptr1, b_err);
        IF  b_err = e_ok
        THEN
            a09load_constraint_info (acv,
                  i = a_p_arr1.pbasep^.sbase.bnamed_constr, and_cnt)
        ELSE
            BEGIN
            a07_b_put_error (acv, b_err, 1);
            i := csp_maxint2 - 1
            END;
        (*ENDIF*) 
        i := i + 1
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak17string_beginload (VAR acv  : tak_all_command_glob);
 
VAR
      i              : integer;
      b_err          : tgg00_BasisError;
      pos            : integer;
      ic2            : tsp_int_map_c2;
      data_ptr       : tsp1_part_ptr;
      bd_info_ptr    : tsp1_part_ptr;
      dummy_ptr      : tsp1_part_ptr;
      rightmost_leaf : tsp00_PageNo;
      treeid         : tgg00_FileId;
      col_id         : tgg00_FileId;
      baserec_ptr    : ^tak_baserecord;
 
BEGIN
ak17get_part_pointers (acv,
      data_ptr, bd_info_ptr, dummy_ptr, dummy_ptr);
WITH acv DO
    IF  (bd_info_ptr = NIL) OR (data_ptr = NIL)
    THEN
        a07_b_put_error (acv, e_too_short_datapart, 1)
    ELSE
        BEGIN
        a_ex_kind  := parsing_executing;
        a_init_ddl := no_ddl;
        SAPDB_PascalForcedMove (bd_info_ptr^.sp1p_buf_size, sizeof(treeid),
              @bd_info_ptr^.sp1p_buf, 1, @treeid, 1, sizeof(treeid));
        treeid.fileRootCheck_gg00 := ROOT_CHECK_GG00;
        treeid.fileBdUse_gg00 := treeid.fileBdUse_gg00 + [ bd_load_nolog ];
        col_id                := treeid;
        pos                   := 1;
        a06a_mblock_init (acv, m_begin, mm_string, treeid);
        IF  a_out_packet^.sp1_header.sp1h_mess_swap
            <> g01code.kernel_swap
        THEN
            BEGIN
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[pos  ];
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[pos+1];
            END
        ELSE
            BEGIN
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[pos  ];
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[pos+1];
            END;
        (*ENDIF*) 
        a_mblock.mb_data^.mbp_keylen := ic2.map_int;
        (* PTS 1117508 *)
        SAPDB_PascalMove ('VAK17 ',   3,    
              data_ptr^.sp1p_buf_size, a_mblock.mb_data_size,
              @data_ptr^.sp1p_buf, pos + 2, @a_mblock.mb_data^.mbp_buf,
              cgg_rec_key_offset + 1, a_mblock.mb_data^.mbp_keylen,
              a_returncode);
        a_mblock.mb_data_len  := cgg_rec_key_offset +
              a_mblock.mb_data^.mbp_keylen;
        pos := pos + a_mblock.mb_data^.mbp_keylen + 2;
        IF  a_out_packet^.sp1_header.sp1h_mess_swap
            <> g01code.kernel_swap
        THEN
            BEGIN
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[pos  ];
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[pos+1];
            END
        ELSE
            BEGIN
            ic2.map_c2[ 1 ] := data_ptr^.sp1p_buf[pos  ];
            ic2.map_c2[ 2 ] := data_ptr^.sp1p_buf[pos+1];
            END;
        (*ENDIF*) 
        a_mblock.mb_qual^.mcol_pos := ic2.map_int;
        a06rsend_mess_buf (acv, a_mblock,
              NOT cak_return_req, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            baserec_ptr                      := @a_mblock.mb_data^.mbp_rec;
            col_id.fileTabId_gg00            := baserec_ptr^.bsurrogate;
            col_id.fileTfn_gg00              := tfnColumn_egg00;
            col_id.fileType_gg00             := [ ftsByteStr_egg00, ftsConcurrent_egg00 ];
            col_id.fileRoot_gg00             := NIL_PAGE_NO_GG00;
            col_id.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
            col_id.fileTfnNo_gg00[1]         := chr(0);
            bd09InitLoad (acv.a_transinf.tri_trans, col_id,
                  c_set_read_only, rightmost_leaf);
&           ifdef trace
            t01treeid (ak_sem, 'tree_id     ', col_id);
&           endif
            b_err := acv.a_transinf.tri_trans.trError_gg00;
            IF  b_err = e_ok
            THEN
                BEGIN
                col_id.fileHandling_gg00 := [ hsNoLog_egg00 ];
                a06retpart_move (acv, @col_id, sizeof (col_id));
                FOR i := 1 TO 2 DO
                    a06retpart_move (acv, @rightmost_leaf, sizeof (rightmost_leaf));
                (*ENDFOR*) 
                a06retpart_move (acv, @treeid.fileTabId_gg00, sizeof (tgg00_Surrogate));
                a06finish_curr_retpart (acv, sp1pk_bdinfo, 1);
                acv.a_pars_last_key.p_kind := m_outcopy;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a17beginload_save_nolog (
            VAR acv      : tak_all_command_glob;
            VAR a11v     : tak_a11_glob);
 
VAR
      restore_string : boolean;
      beginload      : boolean;
      serial_colptr  : tak00_colinfo_ptr;
      restore_index  : boolean;
      repl_baserec   : boolean;
      with_stamp     : boolean;
      ix             : integer;
      jx             : integer;
      number_len     : integer;
      aux            : tsp00_C2;
      b_err          : tgg00_BasisError;
      mm_type        : tgg00_MessType2;
      index_id       : tsp00_Int2;
      rightmost_leaf : tsp00_PageNo;
      treeid         : tgg00_FileId;
      aux_treeid     : tgg00_FileId;
      serial_value   : tsp00_C40;
      serial_val_ptr : tsp00_MoveObjPtr;
      stamp          : tsp00_Key;
 
BEGIN
WITH acv, a11v, a_p_arr1.pbasep^.sbase DO
    BEGIN
    b_err                     := e_ok;
    repl_baserec              := bunloaded;
    a_fk_check_cnt            := 0;
    a_constraint_cnt          := 0;
    restore_index             := false;
    with_stamp                := false;
    treeid                    := btreeid;
    treeid.fileLeafNodes_gg00 := cgg_nil_leafnodes;
    WITH a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ] DO
        BEGIN
        beginload      := n_subproc = cak_x_beginload;
        restore_string := n_subproc = cak_x_restore_string;
        with_stamp     := beginload AND (n_length = cak_i_stamp);
        IF  with_stamp AND NOT bdef_stamp
        THEN
            BEGIN
            bdef_stamp   := true;
            repl_baserec := true
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    a_restore_with_string := 0;
    serial_colptr         := NIL;
    FOR jx := a_p_arr1.pbasep^.sbase.bfirstindex TO
          a_p_arr1.pbasep^.sbase.blastindex DO
        BEGIN
        IF  NOT beginload AND
            (a_p_arr1.pbasep^.sbase.bcolumn[jx]^.cdatatyp in
            [dstra, dstrb, dstruni,
            (* PTS 1116934 M.Ki. *)
            dlonga, dlongb, dlonguni])
        THEN
            a_restore_with_string := a_restore_with_string + 1;
        (*ENDIF*) 
        IF   ctserial in a_p_arr1.pbasep^.sbase.bcolumn[jx]^.ccolpropset
        THEN
            serial_colptr := a_p_arr1.pbasep^.sbase.bcolumn[jx]
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    IF  bunloaded
    THEN
        BEGIN
        bunloaded := false;
        a06a_mblock_init (acv, m_reload, mm_table, treeid);
        ak17put_index_stack_entries (acv);
        a06rsend_mess_buf (acv,
              a_mblock, NOT cak_return_req, b_err)
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        a_ex_kind              := parsing_executing;
        a_init_ddl             := no_ddl;
        treeid                 := btreeid;
        treeid. fileBdUse_gg00 := treeid. fileBdUse_gg00 + [ bd_load_nolog ];
        IF  (btablekind = twithoutkey) AND beginload
        THEN
            mm_type := mm_nokey
        ELSE
            mm_type := mm_key;
        (*ENDIF*) 
        IF  NOT (beginload)
        THEN
            BEGIN
            a1ti := a_ap_tree^[ a1ti ].n_sa_level;
            IF  a1ti <> 0
            THEN
                BEGIN (* restore index *)
                restore_index                    := true;
                WITH a_ap_tree^[ a1ti ] DO
                    a05_unsigned_int2_get (acv,
                          n_pos, n_length, e_invalid_unsign_integer, index_id);
                (*ENDWITH*) 
                g04index_tree_build (treeid, aux_treeid,
                      index_id - MAX_COL_PER_TAB_GG00);
                treeid := aux_treeid;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  restore_string
        THEN
            g04short_col_tree_build (treeid.fileTabId_gg00, treeid,
                  acv.a_transinf.tri_trans.trError_gg00);
        (*ENDIF*) 
        a06a_mblock_init (acv,
              m_begin, mm_type, treeid);
        a06rsend_mess_buf (acv,
              a_mblock, NOT cak_return_req, b_err)
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        IF  beginload
        THEN
            BEGIN
            aux[1] := chr(a_mblock.mb_data^.mbp_keylen DIV 256);
            aux[2] := chr(a_mblock.mb_data^.mbp_keylen MOD 256);
            a06retpart_move (acv, @aux[1], 2);
            a06retpart_move (acv, @a_mblock.mb_data^.mbp_rec.info,
                  a_mblock.mb_data^.mbp_keylen);
            a06finish_curr_retpart (acv, sp1pk_key, 1);
            IF  with_stamp
            THEN
                BEGIN
                a05_stamp_get (acv, stamp, 1, PERM_KEY_MXSP00);
                aux[1] := chr (1 + SURROGATE_MXGG00);
                a06retpart_move (acv, @aux[1], 1);
                aux[1] := csp_defined_byte;
                a06retpart_move (acv, @aux[1], 1);
                a06retpart_move (acv, @stamp, SURROGATE_MXGG00);
                a06finish_curr_retpart (acv, sp1pk_surrogate, 1)
                END;
            (*ENDIF*) 
            IF  serial_colptr <> NIL
            THEN
                BEGIN
                serial_value[1] := csp_defined_byte;
                serial_value[2] := csp_zero_exponent;
                serial_val_ptr  := @serial_value;
                a05serial (acv, serial_colptr^, treeid,
                      serial_val_ptr^, sizeof (serial_value), 1, number_len,
                      c_with_retpart);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  restore_string
        THEN
            treeid := a_into_tree;
        (*ENDIF*) 
        bd09InitLoad (acv.a_transinf.tri_trans, treeid,
              c_set_read_only, rightmost_leaf);
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  b_err = e_ok
        THEN
            BEGIN
            treeid.fileHandling_gg00  := [ hsNoLog_egg00 ];
            treeid.fileLeafNodes_gg00 := cgg_nil_leafnodes;
            a06retpart_move (acv, @treeid,
                  sizeof (treeid));
            FOR ix := 1 TO 2 DO
                a06retpart_move (acv, @rightmost_leaf,
                      sizeof (rightmost_leaf));
            (*ENDFOR*) 
            a06finish_curr_retpart (acv, sp1pk_bdinfo, 1);
            acv.a_pars_last_key.p_kind := m_outcopy
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (b_err = e_ok) AND (repl_baserec)
    THEN
        a10repl_sysinfo (acv, a_p_arr1.pbasep, b_err);
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    ELSE
        IF  NOT restore_string AND NOT restore_index
        THEN
            BEGIN
            IF  beginload AND
                (a1tablen = a01_i_sysmessages )
            THEN
                IF  a1authname = g01glob.sysuser_name
                THEN
                    a_errormsg_loading := true;
                (*ENDIF*) 
            (*ENDIF*) 
            a_pars_curr.fileHandling_gg00 := a_pars_curr.fileHandling_gg00 - [ hsNoLog_egg00 ];
            IF  is_secondary_table in blinkexist
            THEN
                a25linkload_info (acv);
            (*ENDIF*) 
            IF  beginload
            THEN
                ak17store_constraint_info (acv, a11v)
            ELSE
                a_fk_check_cnt := -a_fk_check_cnt;
            (*ENDIF*) 
            a_pars_curr.fileHandling_gg00 := a_pars_curr.fileHandling_gg00 + [ hsNoLog_egg00 ];
            a_part_rollback               := a_returncode <> 0
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a17call_semantic (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv DO
    BEGIN
    CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc OF
        (* PTS 1111576 E.Z. *)
        cak_x_end_restore :
            ak17end_restore (acv);
        cak_x_save_string :
            ak17begin_save_string (acv);
        cak_x_restore :
            ak17string_beginload (acv);
        (* PTS 1111576 E.Z. *)
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a17describe (
            VAR acv    : tak_all_command_glob;
            VAR a11v   : tak_a11_glob);
 
BEGIN
CASE acv.a_ap_tree^[ acv.a_ap_tree^[ 0 ].n_lo_level ].n_length OF
    (* PTS 1120287 E.Z. *)
    cak_i_default :
        ak17describe_default (acv, a11v);
    cak_i_index :
        ak17describe_index (acv, a11v);
    cak_i_table, cak_i_except :
        a17table_describe (acv, a11v, false);
    END;
(*ENDCASE*) 
END;
 
(* PTS 1120287 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a17endload (
            VAR acv  : tak_all_command_glob;
            VAR a11v : tak_a11_glob);
 
CONST
      c_undefined    = -1;
      c_100_percent  = 100;
      c_forceUpdStat = true;
 
VAR
      b_err         : tgg00_BasisError;
      add           : boolean;
      res           : tsp00_NumError;
      ix            : integer;
      key_len       : integer;
      pos           : integer;
      number_len    : integer;
      resbytelen    : integer;
      bdInfoLength  : tsp00_Int4;
      mm_type       : tgg00_MessType2;
      page_cnt      : tsp00_Int4;
      rec_cnt       : tsp00_Int4;
      bd_info_ptr   : tsp1_part_ptr;
      data_ptr      : tsp1_part_ptr;
      serial_ptr    : tsp1_part_ptr;
      surrogate_ptr : tsp1_part_ptr;
      one           : tsp00_Number;
 
BEGIN
WITH acv, a11v, a_p_arr1.pbasep^.sbase DO
    BEGIN
    ak17get_part_pointers (acv,
          data_ptr, bd_info_ptr, serial_ptr, surrogate_ptr);
    IF  (data_ptr = NIL) OR (bd_info_ptr = NIL)
    THEN
        a07_b_put_error (acv, e_invalid_command, 1)
    ELSE
        BEGIN
        pos := data_ptr^.sp1p_buf_len - 2 * mxsp_resnum + 1;
        add := data_ptr^.sp1p_buf[pos] <> chr(1);
        pos := pos + 1;
        s40g4int (data_ptr^.sp1p_buf, pos, page_cnt, res);
        pos := pos + mxsp_resnum;
        IF  res = num_ok
        THEN
            s40g4int (data_ptr^.sp1p_buf, pos, rec_cnt, res);
        (*ENDIF*) 
        IF  (res <> num_ok) OR (page_cnt < 0) OR (rec_cnt < 0)
        THEN
            a07_b_put_error (acv, e_num_overflow, 1)
        ELSE
            a28table_upd_statistics (acv, NOT c_forceUpdStat,
                  c_undefined, c_100_percent,
                  page_cnt, rec_cnt, cak_is_undefined, cak_is_undefined,
                  add, false);
        (*ENDIF*) 
        IF  (serial_ptr <> NIL) AND
            (a_returncode = 0)
        THEN
            BEGIN
            ix := bfirstindex;
            WHILE ix <= blastindex DO
                IF  ctserial in bcolumn[ix]^.ccolpropset
                THEN
                    BEGIN
                    number_len := serial_ptr^.sp1p_buf_len;
                    one        := csp_one_number;
                    s51sub (serial_ptr^.sp1p_buf, 2, number_len - 1,
                          one, 1, sizeof (one), serial_ptr^.sp1p_buf, 2,
                          (number_len - 2) * 2, 0, resbytelen, res);
                    IF  res <> num_ok
                    THEN
                        a07_b_put_error (acv, e_num_overflow, 1)
                    ELSE
                        a05serial (acv, bcolumn[ix]^, btreeid,
                              serial_ptr^.sp1p_buf, number_len, 1,
                              number_len, NOT c_with_retpart);
                    (*ENDIF*) 
                    ix := blastindex + 1 (* exit loop *)
                    END
                ELSE
                    ix := ix + 1;
                (*ENDIF*) 
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        IF  (btablekind = twithoutkey) OR (bdef_stamp)
        THEN
            mm_type := mm_nokey
        ELSE
            mm_type := mm_key;
        (*ENDIF*) 
        a06a_mblock_init (acv, m_mend, mm_type, btreeid);
        IF  (btablekind = twithoutkey) OR (bdef_stamp)
        THEN
            BEGIN
            IF  surrogate_ptr <> NIL
            THEN
                BEGIN
                key_len := surrogate_ptr^.sp1p_buf_len;
                IF  key_len <> 1 + SURROGATE_MXGG00
                THEN
                    a07ak_system_error (acv, 17, 3)
                ELSE
                    SAPDB_PascalMove ('VAK17 ',   4,    
                          surrogate_ptr^.sp1p_buf_size, a_mblock.mb_data_size,
                          @surrogate_ptr^.sp1p_buf, 1,
                          @a_mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 1,
                          key_len,  a_returncode)
                (*ENDIF*) 
                END
            ELSE
                a07ak_system_error (acv, 17, 2)
            (*ENDIF*) 
            END
        ELSE
            key_len := 0;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        bdInfoLength                 := bd_info_ptr^.sp1p_part_header.sp1p_buf_len;
        a_mblock.mb_data^.mbp_keylen := key_len;
        SAPDB_PascalMove ('VAK17 ',   5,    
              bd_info_ptr^.sp1p_buf_size, a_mblock.mb_data_size,
              @bd_info_ptr^.sp1p_buf, 1, @a_mblock.mb_data^.mbp_buf,
              cgg_rec_key_offset + key_len + 1, bdInfoLength, a_returncode);
        a_mblock.mb_qual_len  := 0;
        a_mblock.mb_data_len  := cgg_rec_key_offset + key_len + bdInfoLength;
        a06rsend_mess_buf (acv, a_mblock, NOT cak_return_req, b_err);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    ak17clean_up (acv, btreeid.fileTabId_gg00);
    a_errormsg_loading := false
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a17saveinit (
            VAR acv         : tak_all_command_glob;
            VAR a11v        : tak_a11_glob;
            is_short_string : boolean);
 
VAR
      new_base    : boolean;
      i           : integer;
      index_id    : tsp00_Int2;
      unload_info : tgg03_unloadInfoPtr;
      treeid      : tgg00_FileId;
 
BEGIN
WITH acv, a11v, a_p_arr1.pbasep^.sbase DO
    BEGIN
    unload_info := NIL;
    new_base    := false;
    a_ex_kind   := parsing_executing;
    a_init_ddl  := no_ddl;
    treeid      := btreeid;
    a1ti        := a_ap_tree^[ a1ti ].n_sa_level;
    IF  a1ti <> 0
    THEN
        BEGIN (* save init for index *)
        WITH a_ap_tree^[ a1ti ] DO
            a05_unsigned_int2_get (acv, n_pos, n_length,
                  e_invalid_unsign_integer, index_id);
        (*ENDWITH*) 
        g04index_tree_build (btreeid, treeid,
              index_id - MAX_COL_PER_TAB_GG00);
        END
    ELSE
        IF  is_short_string
        THEN
            BEGIN
            treeid := btreeid;
            g04short_col_tree_build (btreeid.fileTabId_gg00, treeid,
                  acv.a_transinf.tri_trans.trError_gg00);
            END
        ELSE
            BEGIN (* PTS 1116259 M.Ki. *)
            IF  treeid.fileTfn_gg00 = tfnTable_egg00
            THEN
                ak17build_save_mapping_stack (acv, a11v, unload_info,
                      new_base);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        bd09InitUnload (acv.a_transinf.tri_trans, treeid);
    (*ENDIF*) 
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        BEGIN
        treeid.fileHandling_gg00  := [ hsNoLog_egg00 ];
        treeid.fileLeafNodes_gg00 := cgg_nil_leafnodes;
        a06retpart_move (acv, @treeid, sizeof (treeid));
        IF  treeid.fileTfn_gg00 = tfnTable_egg00
        THEN
            BEGIN
            unload_info^.ui_src_pageno := treeid.fileRoot_gg00;
            FOR i := 1 TO 2 DO
                a06retpart_move (acv, @unload_info, sizeof (unload_info));
            (*ENDFOR*) 
            END
        ELSE
            FOR i := 1 TO 2 DO
                a06retpart_move (acv, @treeid.fileRoot_gg00,
                      sizeof (treeid.fileRoot_gg00));
            (*ENDFOR*) 
        (*ENDIF*) 
        a06finish_curr_retpart (acv, sp1pk_bdinfo, 1);
        acv.a_pars_last_key.p_kind := m_outcopy
        END
    ELSE
        BEGIN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
        IF  unload_info <> NIL
        THEN
            gg941Deallocate (acv.a_transinf.tri_trans, unload_info);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  new_base
    THEN
        a10_key_del (acv, acv.a_p_arr1.pbasep^.syskey);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a17table_describe (
            VAR acv    : tak_all_command_glob;
            VAR a11v   : tak_a11_glob;
            table_load : boolean);
 
VAR
      migration          : boolean;
      new_base           : boolean;
      error              : tgg00_BasisError;
      def_type           : tsp7_default;
      i, j               : integer;
      col_count          : integer;
      col_index          : integer;
      col_ptr            : tak00_colinfo_ptr;
      oldbase_p          : tak_syspointerarr;
      col_name           : tsp00_KnlIdentifier;
      extcolno_colno_arr : ARRAY[ 1..MAX_COL_PER_TAB_GG00 ] OF integer;
      extcol_map         : tgg03_extcol_map; (* PTS 1116259 M.Ki. *)
      table_desc         : ^tsp7_table_description;
      (* PTS 1107617 E.Z. *)
      msg_op             : tsp00_C132;
      columnName         : tsp00_KnlIdentifier;
 
BEGIN
WITH acv, a11v DO
    BEGIN
    new_base  := false;
    migration := a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_length =
          cak_i_except;
    IF  migration
    THEN
        BEGIN
        j := 1;
        FOR i := 1 TO sizeof (a1authname) DO
            BEGIN
            msg_op [ j ] := a1authname[ i ];
            j := j + 1
            END;
        (*ENDFOR*) 
        FOR i := 1 TO sizeof (a1tablen) DO
            BEGIN
            msg_op [ j ] := a1tablen[ i ];
            j := j + 1
            END;
        (*ENDFOR*) 
        (* PTS 1107617 E.Z. *)
        IF  g01unicode
        THEN
            BEGIN
            SAPDB_PascalUnicodeFill ('VAK17 ',   6,    
                  sizeof(msg_op), @msg_op,
                  sizeof(a1authname) + sizeof(a1tablen) + 1,
                  sizeof(msg_op) - (sizeof(a1authname) + sizeof(a1tablen)),
                  csp_unicode_blank, error);
            vopmsgUnicode(csp_unicode, 2, 0, msg_op);
            END
        ELSE
            BEGIN
            SAPDB_PascalFill ('VAK17 ',   7,    
                  sizeof(msg_op), @msg_op,
                  sizeof(a1authname) + sizeof(a1tablen) + 1,
                  sizeof(msg_op) - (sizeof(a1authname) + sizeof(a1tablen)),
                  bsp_c1, error);
            vopmsgUnicode(csp_ascii, 2, 0, msg_op);
            END;
        (*ENDIF*) 
        (* END PTS 1107617 E.Z. *)
        END;
    (*ENDIF*) 
    a1ti      := a_ap_tree^[ a1ti ].n_lo_level;
    col_count := 0;
    FOR i := 1 TO MAX_COL_PER_TAB_GG00 DO
        extcolno_colno_arr[ i ] := 0;
    (*ENDFOR*) 
    error    := e_ok;
    WITH a_p_arr1.pbasep^.sbase DO
        BEGIN
        col_index := bfirstcolind;
        IF  table_load
        THEN
            IF  bindexexist
            THEN
                error := e_indexed_table_not_allowed
            ELSE
                IF  ins_trigger in blinkexist
                THEN
                    error := e_missing_privilege;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  error = e_ok
        THEN
            BEGIN
            a1sysk          := a01defaultkey;
            a1sysk.stableid := bsurrogate;
            a10_lock_sysinfo (acv, a1sysk, lckSysExcl_egg00)
            END;
        (* PTS 1116259 M.Ki.: preset extcolno mapping assuming a      *)
        (*                    clean record structure                  *)
        (*ENDIF*) 
        WHILE col_index <> 0 DO
            BEGIN
            extcol_map[ bcolumn[col_index]^.cextcolno ].em_old_colind :=
                  col_index;
            col_index := bcolumn[col_index]^.cnextind;
            END;
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
    oldbase_p := acv.a_p_arr1;
    IF  table_load
    THEN
        WHILE (a1ti <> 0) AND (error = e_ok)  DO
            BEGIN
            col_count := succ(col_count);
            WITH a_ap_tree^[ a1ti ] DO
                BEGIN
                a05identifier_get (acv, a1ti,
                      sizeof (col_name), col_name);
                IF  NOT a061exist_columnname (a_p_arr1.pbasep^.sbase,
                    col_name, col_ptr)
                THEN
                    error := e_unknown_columnname
                ELSE
                    WITH col_ptr^ DO
                        IF  extcolno_colno_arr[ cextcolno ] <> 0
                        THEN
                            error := e_duplicate_columnname
                        ELSE
                            BEGIN
                            extcolno_colno_arr[ cextcolno ] :=
                                  col_count;
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDIF*) 
                a1ti := n_sa_level;
                END;
            (*ENDWITH*) 
            END
        (*ENDWHILE*) 
    ELSE (* PTS 1116259: build clean baserecord for output *)
        BEGIN
        a13_new_catalog_desc (acv, a11v, oldbase_p,
              extcol_map, new_base);
        END;
    (*ENDIF*) 
    IF  error <> e_ok
    THEN
        a07_b_put_error (acv, error, 1)
    ELSE
        IF  a_curr_retpart = NIL
        THEN
            BEGIN
            a06init_curr_retpart (acv);
            IF  a_returncode = 0
            THEN
                table_desc := @a_curr_retpart^.sp1p_buf
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (a_returncode = 0)
    THEN
        BEGIN
        col_count   := 0;
        a_curr_retpart^.sp1p_buf_len :=
              sizeof (table_desc^.sp7t_authid) +
              sizeof (table_desc^.sp7t_tablename       ) +
              sizeof (table_desc^.sp7t_field_cnt       ) +
              sizeof (table_desc^.sp7t_kernel_swap     ) +
              sizeof (table_desc^.sp7t_table_kind      ) +
              sizeof (table_desc^.sp7t_kernel_loc      ) +
              sizeof (table_desc^.sp7t_constraint_cnt  ) +
              a_p_arr1.pbasep^.sbase.bmaxcol * sizeof (tsp7_ffield_info);
        col_index   := a_p_arr1.pbasep^.sbase.bfirstcolind;
        END;
    (*ENDIF*) 
    WHILE (col_index <> 0) AND (a_returncode = 0) DO
        WITH a_p_arr1.pbasep^.sbase, bcolumn[ col_index ]^, table_desc^ DO
            BEGIN
            ak17move_name (acv, ccolumnn, ord (ccolumnn_len));
            col_count := succ(col_count);
            IF  table_load
            THEN
                IF  NOT (ctopt in ccolpropset    ) AND
                    NOT (ctdefault in ccolpropset) AND
                    (extcolno_colno_arr[ cextcolno ] = 0)
                THEN
                    BEGIN
                    (* PTS 1112556 *)
                    a061get_colname (bcolumn[ col_index ]^, columnName);
                    a07_nb_put_error (acv,
                          e_missing_mandatory_recordfield,
                          1, columnName);
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                WITH table_desc^.sp7t_fields[ col_count ] DO
                    BEGIN
                    sp7fi_filler      := '   ';
                    sp7fi_stmt_col_no :=
                          extcolno_colno_arr[ cextcolno ];
                    IF  (ctdropped   in ccolpropset) OR
                        (ctinvisible in ccolpropset)
                    THEN
                        sp7fi_col_mode := mod_dropped
                    ELSE
                        IF  ctkey in ccolpropset
                        THEN
                            IF  btablekind = twithoutkey
                            THEN
                                sp7fi_col_mode := mod_syskey
                            ELSE
                                sp7fi_col_mode := mod_key
                            (*ENDIF*) 
                        ELSE
                            IF  ctopt in ccolpropset
                            THEN
                                sp7fi_col_mode := mod_optional
                            ELSE
                                sp7fi_col_mode := mod_mandatory;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  (cdatatyp = dfixed) AND cbinary
                    THEN
                        IF  cdatalen = 5
                        THEN
                            sp7fi_data_type := dsmallint
                        ELSE
                            sp7fi_data_type := dinteger
                        (*ENDIF*) 
                    ELSE (* PTS 1116777 *)
                        IF  (cdatatyp in [dcha,dchb,dunicode])
                            AND
                            (ord(cshiftoutchar) = ord(true))
                        THEN
                            CASE cdatatyp OF
                                dcha:
                                    sp7fi_data_type := dvarchara;
                                dchb:
                                    sp7fi_data_type := dvarcharb;
                                dunicode:
                                    sp7fi_data_type := dvarcharuni;
                                END
                            (*ENDCASE*) 
                        ELSE
                            sp7fi_data_type := cdatatyp;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  ord(cdatafrac) > 0
                    THEN
                        sp7fi_frac := cdatafrac - cak_frac_offset
                    ELSE
                        sp7fi_frac := 0;
                    (*ENDIF*) 
                    sp7fi_len      := cdatalen;
                    sp7fi_in_out_l := cinoutlen;
                    IF  (ccolstack.etype in [ st_fixkey, st_fixcol ])
                    THEN
                        sp7fi_len_type := sp7_fix_len
                    ELSE
                        IF  ccolstack.etype = st_varlongchar
                        THEN
                            sp7fi_len_type := sp7_var_len_long
                        ELSE
                            sp7fi_len_type := sp7_var_len;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  migration
                    THEN
                        BEGIN (* default and constraints are not needed *)
                        sp7fi_default := sp7_no_default;
                        END
                    ELSE
                        BEGIN
                        IF  ctserial in ccolpropset
                        THEN
                            def_type := sp7_default_serial
                        ELSE
                            ak17get_default_range (acv,
                                  a11v,
                                  oldbase_p,
                                  oldbase_p.pbasep^.sbase.bcolumn[ extcol_map[cextcolno].em_old_colind ]^ (* PTS 1116259 M.Ki *),
                                  def_type);
                        (*ENDIF*) 
                        sp7fi_default := def_type;
                        END;
                    (*ENDIF*) 
                    sp7fi_def_col_no := cextcolno
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            col_index := cnextind;
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        WITH a_p_arr1.pbasep^.sbase DO
            BEGIN
            a06determine_username (acv, bauthid, table_desc^.sp7t_authid);
            table_desc^.sp7t_tablename := btablen^;
            IF  migration
            THEN
                table_desc^.sp7t_constraint_cnt := 0
            ELSE
                table_desc^.sp7t_constraint_cnt := bnamed_constr
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        table_desc^.sp7t_field_cnt    := col_count;
        table_desc^.sp7t_kernel_swap  := g01code.kernel_swap;
        table_desc^.sp7t_table_kind   := ord(a_p_arr1.pbasep^.sbase.btablekind);
        table_desc^.sp7t_kernel_loc   := 0;
&       ifdef trace
        WITH table_desc^ DO
            FOR i := 1 TO sp7t_field_cnt DO
                WITH table_desc^.sp7t_fields[ i ] DO
                    BEGIN
                    t01int4  (ak_sem, 'fi_stmt_c_no', sp7fi_stmt_col_no);
                    t01int4  (ak_sem, 'fi_col_mode ', ord (sp7fi_col_mode));
                    t01int4  (ak_sem, 'fi_data_type', ord (sp7fi_data_type));
                    t01int4  (ak_sem, 'fi_frac     ', sp7fi_frac);
                    t01int4  (ak_sem, 'fi_len      ', sp7fi_len);
                    t01int4  (ak_sem, 'fi_in_out   ', sp7fi_in_out_l);
                    t01int4  (ak_sem, 'fi_fixlen   ', ord (sp7fi_len_type));
                    t01int4  (ak_sem, 'fi_default  ', ord (sp7fi_default));
                    t01int4  (ak_sem, 'fi_def_colno', sp7fi_def_col_no);
                    END;
                (*ENDWITH*) 
            (*ENDFOR*) 
        (*ENDWITH*) 
&       endif
        ak17code_byte_swap (acv, c_outcopy, table_desc^);
&       ifdef trace
        t01moveobj (ak_sem, a_curr_retpart^.sp1p_buf, 1,
              a_curr_retpart^.sp1p_buf_len);
&       endif
        a06finish_curr_retpart (acv, sp1pk_data, 1);
        acv.a_init_ddl := no_ddl
        END;
    (*ENDIF*) 
    IF  new_base
    THEN
        a10_key_del (acv, acv.a_p_arr1.pbasep^.syskey);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1120287 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak17build_save_mapping_stack (
            VAR acv         : tak_all_command_glob;
            VAR a11v        : tak_a11_glob;
            VAR unload_info : tgg03_unloadInfoPtr;
            VAR new_base    : boolean);
 
CONST
      c_ignore_err = true;
 
VAR
      is_sorted     : boolean;
      do_mapping    : boolean;
      addClusterKey : boolean;
      src_col_cnt   : tsp00_Int2;
      i             : tsp00_Int2;
      stackpos      : integer;
      req_len       : tsp00_Int4;
      unload_ptr    : tsp00_MoveObjPtr;
      src_st_ptr    : tgg00_StackListPtr;
      tar_st_ptr    : tgg00_StackListPtr;
      msg           : tsp00_C12;
      (* PTS 1116259 M.Ki. *)
 
BEGIN
(* build mapping stack and info needed for the record conversion    *)
(* save it in freshly allocated memory;                             *)
(* on success unload_info will point to beginning of memory block   *)
a13_build_mapping_stack (acv, a11v, src_st_ptr,
      tar_st_ptr, src_col_cnt, new_base);
do_mapping  := false;
unload_info := NIL;
IF  acv.a_returncode = 0
THEN (* check whether mapping is necessary at all *)
    FOR i := 1 TO src_col_cnt DO
        IF  (src_st_ptr^[i].etype    <> tar_st_ptr^[i].etype)    OR
            (src_st_ptr^[i].eop      <> tar_st_ptr^[i].eop)      OR
            (src_st_ptr^[i].epos     <> tar_st_ptr^[i].epos)     OR
            (src_st_ptr^[i].elen_var <> tar_st_ptr^[i].elen_var) OR
            (src_st_ptr^[i].ecol_tab <> tar_st_ptr^[i].ecol_tab)
        THEN
            do_mapping := true;
        (*ENDIF*) 
    (*ENDFOR*) 
(*ENDIF*) 
IF  do_mapping AND (acv.a_returncode = 0)
THEN
    WITH acv, a_mblock DO
        BEGIN
        req_len       := sizeof (tgg03_unloadInfo) +
              mb_qual^.mfirst_free * sizeof (tgg00_StackEntry) + 1;
        unload_ptr    := gg941Allocate (a_transinf.tri_trans, req_len);
        IF  unload_ptr = NIL
        THEN
            a07_b_put_error (acv, e_no_more_memory, 1)
        ELSE
            BEGIN
            unload_info                := @unload_ptr^[1];
            unload_info^.ui_do_mapping := true;
            unload_info^.ui_src_pageno := 0;
            unload_info^.ui_tar_pageno := 0;
            unload_info^.ui_src_recind := 0;
            stackpos := sizeof (tgg03_unloadInfo) + 1;
            IF  (stackpos MOD 2) <> 1
            THEN
                stackpos := succ (stackpos);
            (* copy stack and remember positions of source and target stack *)
            (*ENDIF*) 
            unload_info^.ui_stack_ptr  := @unload_ptr^[ stackpos ];
            SAPDB_PascalMove ('VAK17 ',   8,    
                  sizeof (tgg00_StackList),
                  mb_qual^.mfirst_free * sizeof (tgg00_StackEntry),
                  @mb_st^, 1,
                  @unload_info^.ui_stack_ptr^, 1,
                  mb_qual^.mfirst_free * sizeof (tgg00_StackEntry),
                  a_returncode);
            unload_info^.ui_stack_desc  := mb_qual^.mstack_desc;
            unload_info^.ui_src_st_ptr  := @unload_info^.
                  ui_stack_ptr^[mb_qual^.mresqual_pos];
            unload_info^.ui_tar_st_ptr  := unload_info^.ui_stack_ptr;
            unload_info^.ui_src_col_cnt := src_col_cnt;
            is_sorted := true;
            b37_init_conversion_info (acv.a_transinf.tri_trans,
                  c_ignore_err,
                  unload_info^.ui_src_st_ptr,
                  unload_info^.ui_src_col_cnt,
                  unload_info^.ui_tar_st_ptr,
                  mb_qual^.mqual_pos,
                  mb_qual^.mqual_cnt,
                  is_sorted,
                  addClusterKey,
                  unload_info^.ui_fixedcollen,
                  unload_info^.ui_code_tab,
                  unload_info^.ui_trunc_col,
                  unload_info^.ui_frac_col,
                  unload_info^.ui_not_null,
                  unload_info^.ui_check_col);
            IF  addClusterKey
            THEN
                BEGIN
                msg := 'Cluster key ';
                a07_const_b_put_error (acv, e_not_implemented, 1,
                      @msg, sizeof(msg))
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    (*ENDWITH*) 
ELSE
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        req_len       := sizeof (tgg03_unloadInfo);
        unload_ptr    := gg941Allocate (acv.a_transinf.tri_trans, req_len);
        IF  unload_ptr = NIL
        THEN
            a07_b_put_error (acv, e_no_more_memory, 1)
        ELSE
            BEGIN
            unload_info                := @unload_ptr^[1];
            unload_info^.ui_do_mapping := false;
            unload_info^.ui_src_pageno := 0;
            unload_info^.ui_tar_pageno := 0;
            unload_info^.ui_src_recind := 0;
            unload_info^.ui_stack_ptr  := NIL;
            unload_info^.ui_src_st_ptr := NIL;
            unload_info^.ui_tar_st_ptr := NIL;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  new_base
THEN
    a10_key_del (acv, acv.a_p_arr1.pbasep^.syskey);
&ifdef TRACE
(*ENDIF*) 
t01int4 (ak_sem, 'req_len     ', req_len);
t01int4 (ak_sem, 'do_mapping  ', ord(do_mapping));
&endif
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
