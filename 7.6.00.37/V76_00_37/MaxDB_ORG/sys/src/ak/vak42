.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 2000-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-28
*****************************************************
modname : VAK42
changed : 2000-11-30
module  : AK_Show_statistics
 
Author  : ThomasA
Created : 1985-10-16
*****************************************************
 
Purpose : Show Statistics semantische Routinen.
 
Define  :
 
&       ifdef TRACE
        VAR
              a42check_time : boolean;
 
        PROCEDURE
              a42_init_time_array;
&       endif
 
        PROCEDURE
              a42_check_database (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a42caches_statistics (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a42_get_pagecount (
                    VAR acv       : tak_all_command_glob;
                    base_ptr      : tak_sysbufferaddress;
                    VAR pagecount : tsp00_Int4);
 
        PROCEDURE
              a42execute (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a42get_tablename (
                    VAR t      : tgg00_TransContext;
                    VAR tabid  : tgg00_Surrogate;
                    VAR authid : tsp00_KnlIdentifier;
                    VAR tablen : tsp00_KnlIdentifier;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a42index_inf_to_messbuf (
                    VAR acv         : tak_all_command_glob;
                    VAR mblock      : tgg00_MessBlock;
                    VAR a41v        : tak40_show_glob;
                    VAR indexn      : tsp00_KnlIdentifier;
                    VAR selectivity : boolean;
                    diagnose_index  : boolean);
 
        PROCEDURE
              a42lock_req_mode (
                    VAR acv   : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob;
                    lock_mode : tgg00_LockReqMode);
 
        PROCEDURE
              a42lock_req_state (
                    VAR acv    : tak_all_command_glob;
                    VAR a41v   : tak40_show_glob;
                    lock_state : tgg00_LockReqState);
 
        PROCEDURE
              a42_monitor_init (process_id : tsp00_TaskId);
 
        PROCEDURE
              a42move_trans_no (
                    VAR acv   : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob;
                    VAR trans : tgg91_TransNo);
 
        PROCEDURE
              a42name_and_val_statistic (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob;
                    VAR vkw  : tak_keyword;
                    value    : tsp00_Int4;
                    VAR nam  : tsp00_Sname);
 
        PROCEDURE
              a42new_lock_req_mode (
                    VAR acv   : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob;
                    lock_mode : tgg00_LockReqMode);
 
        PROCEDURE
              a42new_lock_req_state (
                    VAR acv    : tak_all_command_glob;
                    VAR a41v   : tak40_show_glob;
                    lock_state : tgg00_LockReqState);
 
        PROCEDURE
              a42_start_semantic (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a42table_statistics   (
                    VAR acv    : tak_all_command_glob;
                    VAR a41v   : tak40_show_glob;
                    pages_only : boolean);
 
        PROCEDURE
              a42iindex_statistics   (
                    VAR acv    : tak_all_command_glob;
                    VAR a41v   : tak40_show_glob);
 
        PROCEDURE
              a42put_running_cmds (
                    VAR acv    : tak_all_command_glob;
                    VAR parsid : tsp00_C12);
 
        FUNCTION
              a42getparseid (
                    VAR t        : tgg00_TransContext;
                    VAR pid      : tsp00_TaskId;
                    VAR parsid   : tsp00_C12;
                    VAR b_err    : tgg00_BasisError): boolean;
 
        PROCEDURE
              a42reset_running_cmds (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a42bool_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    bool_val    : boolean);
 
        PROCEDURE
              a42date_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_date    : tsp00_Int4);
 
        PROCEDURE
              a42int4_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_val     : tsp00_Int4);
 
        PROCEDURE
              a42session_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    session     : tgg91_SessionNo);
 
        PROCEDURE
              a42str_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    str_ptr     : tsp00_MoveObjPtr;
                    str_len     : integer);
 
        PROCEDURE
              a42surrogate_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    surrogate   : tgg00_Surrogate);
 
        PROCEDURE
              a42time_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_time    : tsp00_Int4);
 
        PROCEDURE
              a42trans_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    trans       : tgg91_TransNo);
 
        PROCEDURE
              a42uint1_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_val     : tsp00_Int2);
 
        PROCEDURE
              a42uint2_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_val     : tsp00_Int4);
 
        PROCEDURE
              a42uint4_to_intern_state (
                    acv_ptr     : tak_acv_address;
                    a41v_ptr    : tak40_show_glob_ptr;
                    component   : tsp00_C20;
                    description : tsp00_C40;
                    int_val     : tsp00_8ByteCounter);
 
        PROCEDURE
              a42UserStatisticsCallback (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob;
                    pUser    : tak_sysbufferaddress);
 
        PROCEDURE
              a42ResetOmsMonitor(VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a42ref_stat_real (
                    VAR acv    : tak_all_command_glob;
                    VAR a41v   : tak40_show_glob;
                    textpar    : tsp00_C40;
                    lreal      : tsp00_Longreal);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              object_garbage_collection : VBD91;
 
        PROCEDURE
              bd91InfoGCReset;
 
        PROCEDURE
              bd91InfoGCStats (
                    idxGC                    : tsp00_Int4;
                    VAR TaskId                : tsp00_TaskId;
                    VAR active                : boolean;
                    VAR activateCount         : tsp00_8ByteCounter;
                    VAR deleteObj             : tsp00_8ByteCounter;
                    VAR relHistEntryNormal    : tsp00_8ByteCounter;
                    VAR relHistCreateObjFile  : tsp00_8ByteCounter;
                    VAR relHistDeleteObj      : tsp00_8ByteCounter;
                    VAR relHistDropObjFile    : tsp00_8ByteCounter;
                    VAR relHistLockObj        : tsp00_8ByteCounter;
                    VAR relHistInsertObj      : tsp00_8ByteCounter;
                    VAR relHistNewObj         : tsp00_8ByteCounter;
                    VAR relHistUpdateObj      : tsp00_8ByteCounter;
                    VAR relPageEmpty          : tsp00_8ByteCounter;
                    VAR relPageDropFile       : tsp00_8ByteCounter;
                    VAR relDropFile           : tsp00_8ByteCounter);
 
        PROCEDURE   (* PTS 1115641 FF *)
              bd91InfoContainerRoots (
                    VAR Trans            : tgg00_TransContext;
                    VAR pObjFileIter      : tsp00_Addr;
                    VAR pContObjFileIter  : tsp00_Addr;
                    pStackarea            : tsp00_Addr;
                    StackareaLen          : tsp00_Int2;
                    VAR ClassId           : tsp00_C8;
                    VAR Root              : tsp00_Int4;
                    VAR ContainerSequelNo : tsp00_Int4;
                    VAR NumKeyPartitions  : tsp00_Int2;
                    VAR VarContainer      : boolean;
                    VAR DeleteFlag        : boolean;
                    VAR MaxObjBodySize    : tsp00_Int4;
                    VAR MaxObjPerPage     : tsp00_Int4;
                    VAR MaxChains         : tsp00_Int4;
                    VAR UnusedBytesPerPage: tsp00_Int2);
 
        PROCEDURE   (* PTS 1115641 FF *)
              bd91InfoContainerChains (
                    VAR Trans            : tgg00_TransContext;
                    VAR pObjFileIter      : tsp00_Addr;
                    VAR pContObjFileIter  : tsp00_Addr;
                    pStackarea            : tsp00_Addr;
                    StackareaLen          : tsp00_Int2;
                    VAR ClassId           : tsp00_C8;
                    VAR ContainerSequelNo : tsp00_Int4;
                    VAR ChainId           : tsp00_Int4;
                    VAR Subroot           : tsp00_Int4;
                    VAR ObjCount          : tsp00_Int4;
                    VAR PageCount         : tsp00_Int4;
                    VAR ActiveGC          : tsp00_Int4;
                    VAR RelEmptyPages     : boolean);
 
        PROCEDURE   (* PTS 1115641 FF  *)
              bd91InfoContainerKeys (
                    VAR Trans            : tgg00_TransContext;
                    VAR pObjFileIter      : tsp00_Addr;
                    pStackarea            : tsp00_Addr;
                    StackareaLen          : tsp00_Int2;
                    VAR KeyIdx            : tsp00_Int2;
                    VAR ClassId           : tsp00_C8;
                    VAR KeyRoot           : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : vbd998;
 
        PROCEDURE
              bd998NewFileDirIterator (
                    VAR trans          : tgg00_TransContext;
                    VAR iteratorPtr    : tsp00_Addr);
 
        PROCEDURE
              bd998DestroyFileDirIterator (
                    VAR trans          : tgg00_TransContext;
                    VAR iteratorPtr    : tsp00_Addr);
 
        PROCEDURE
              bd998AddToFileDirIteratorFilter (
                    VAR iteratorPtr    : tsp00_Addr;
                    fileType           : tgg00_Tfn);
 
        PROCEDURE
              bd998InitFileDirIterator (
                    VAR trans          : tgg00_TransContext;
                    showDeletedFiles   : boolean;
                    VAR iteratorPtr    : tsp00_Addr);
 
        PROCEDURE
              bd998AdvanceFileDirIterator (
                    VAR trans          : tgg00_TransContext;
                    VAR iteratorPtr    : tsp00_Addr;
                    VAR fileId         : tgg00_FileId);
 
        PROCEDURE
              bd998GetTableFileNoForIndex (
                    VAR trans            : tgg00_TransContext;
                    VAR indexSurrogate   : tgg00_Surrogate;
                    VAR tableSurrogate   : tgg00_Surrogate;
                    VAR b_err            : tgg00_BasisError);
 
        PROCEDURE
              bd998GetTableFileNoForShortColumn (
                    VAR trans             : tgg00_TransContext;
                    VAR shortColSurrogate : tgg00_Surrogate;
                    VAR tableSurrogate    : tgg00_Surrogate;
                    VAR b_err             : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              BD_Wrapper : VBD999;
 
        FUNCTION
              bd999LogIsMirrored : boolean;
 
        FUNCTION
              bd999GetPageSize : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        FUNCTION
              gg06IsNilTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        FUNCTION
              gg06SessionGetInt4 (VAR SessionNo : tgg91_SessionNo): tsp00_Int4;
 
        PROCEDURE
              gg06SessionToLine (
                    VAR SessionNo : tgg91_SessionNo;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
        PROCEDURE
              gg06TransToLine (
                    VAR TransNo : tgg91_TransNo;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
        PROCEDURE
              SAPDB_PascalForcedUnicodeFill (
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2 );
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    src_upb  : tsp00_Int4;
                    dest_upb : tsp00_Int4;
                    src      : tsp00_MoveObjPtr;
                    src_pos  : tsp00_Int4;
                    dest     : tsp00_MoveObjPtr;
                    dest_pos : tsp00_Int4;
                    length   : tsp00_Int4;
                    VAR err  : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17date_to_line (
                    date            : tsp00_Date;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
        PROCEDURE
              g17intdate_time (
                    int_date     : tsp00_Int4;
                    int_time     : tsp00_Int4;
                    VAR str_date : tsp00_Date;
                    VAR str_time : tsp00_Time);
 
        PROCEDURE
              g17int4to_line (
                    int       : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_C30);
 
        PROCEDURE
              g17surrogate_to_line (
                    VAR surrogate : tgg00_Surrogate;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17time_to_line (
                    time            : tsp00_Time;
                    VAR ln_len      : integer;
                    VAR ln          : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              Kernel_DiagInfop (
                    requested       : integer;
                    VAR kindOut     : tak_keyword;
                    VAR topicKeyOut : tsp00_Sname;
                    VAR levelOut    : integer) : boolean;
 
      ------------------------------ 
 
        FROM
              KB_Check : VKB03;
 
        FUNCTION
              kb03IsBackupCheck     : boolean;
 
        FUNCTION
              kb03IsLockCheck       : boolean;
 
        FUNCTION
              kb03IsLockSupplyCheck : boolean;
 
        FUNCTION
              kb03IsRegionCheck     : boolean;
 
        FUNCTION
              kb03IsTransCheck      : boolean;
              (* PTS 1107118 E.Z. *)
 
      ------------------------------ 
 
        FROM
              KB_headmaster : VKB38;
 
        (* PTS 1000211, T.A. 1999-07-12 *)
        PROCEDURE
              k38get_autosave_medianame (
                    TaskId         : tsp00_TaskId;
                    VAR media_name : tsp00_C64);
 
        FUNCTION
              k38is_on_autosave (
                    VAR t     : tgg00_TransContext;
                    in_region : boolean) : boolean;
 
      ------------------------------ 
 
        FROM
              KB_locklist : VKB51;
 
        PROCEDURE
              k51info_lock (
                    TaskId         : tsp00_TaskId;
                    VAR LockInfo   : tkb05_LockInfo);
 
        PROCEDURE
              k51reset_statistics (pid : tsp00_TaskId);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560GetHistFileInfo (
                    VAR Trans            : tgg00_TransContext;
                    VAR HistFileNo       : tsp00_Int4;
                    VAR FirstTransId     : tgg91_TransNo;
                    VAR FirstTransIsUsed : boolean;
                    VAR LastTransId      : tgg91_TransNo;
                    VAR LastTransIsUsed  : boolean;
                    VAR PageCount        : tsp00_Int4;
                    VAR bFileIsEmpty     : boolean);
 
        FUNCTION
              kb560GetLogDeviceSize : tsp00_Int4;
 
        FUNCTION
              kb560LogQueueSize : tsp00_Uint4;
 
        PROCEDURE
              kb560GetStatistics (
                    taskid               : tsp00_TaskId;
                    VAR LogDeviceInfo    : tkb00_LogDeviceInfo;
                    VAR LogQueueInfo     : tkb00_LogQueueInfo);
 
        PROCEDURE
              kb560ResetStatistics (taskid : tsp00_TaskId);
 
        FUNCTION
              kb560LogIsFull : boolean;
 
        FUNCTION
              k560IsSavepointAllowed : boolean;
 
        FUNCTION
              kb560IsSys2CatalogTable(
                    VAR tabId : tgg00_Surrogate) : boolean;
 
      ------------------------------ 
 
        FROM
              KB_restart_record : VKB57;
 
        PROCEDURE
              k57statistics_reset (process_id : tsp00_TaskId);
 
        PROCEDURE
              k57info_seq_cache (
                    process_id      : tsp00_TaskId;
                    VAR cache_total : tsp00_8ByteCounter;
                    VAR cache_hit   : tsp00_8ByteCounter;
                    VAR cache_miss  : tsp00_8ByteCounter);
 
        PROCEDURE
              k57select_restartrec (
                    TaskId : tsp00_TaskId;
                    pAcv  : tsp00_Addr;
                    pA41v : tsp00_Addr);
 
        PROCEDURE
              k57select_log_info (
                    TaskId : tsp00_TaskId;
                    pAcv  : tsp00_Addr;
                    pA41v : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              Single_Select : VKB720;
 
        PROCEDURE
              k720init_ref_statistic;
 
        PROCEDURE
              k720show_monitor (VAR info : tgg00_ReferenceInfo);
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey         : tgg00_SysInfoKey;
              a01diag_monitor_on    : boolean;
              a01sm_collect_data    : boolean;
              a01diag_analyze_on    : boolean;
              a01diag_ana_coll_data : boolean;
              a01char_size          : integer;
              a01_i_current         : tsp00_KnlIdentifier;
              a01_i_domain          : tsp00_KnlIdentifier;
              a01_il_b_identifier   : tsp00_KnlIdentifier;
              a01_zero_res_name     : tsp00_KnlIdentifier;
              a01join_clust_read    : boolean;
             
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11get_check_table (
                    VAR acv          : tak_all_command_glob;
                    new_table        : boolean;
                    basetable        : boolean;
                    unload_allowed   : boolean;
                    required_priv    : tak00_PrivilegeSet;
                    any_priv         : boolean;
                    all_base_rec     : boolean;
                    d_state          : tak_directory_state;
                    VAR act_tree_ind : tsp00_Int4;
                    VAR authid       : tsp00_KnlIdentifier;
                    VAR tablen       : tsp00_KnlIdentifier;
                    VAR d_sparr      : tak_syspointerarr);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
        FUNCTION
              a101_RegisterCurrentStatement (
                    VAR acv : tak_all_command_glob) : tsp00_Int4;
 
        PROCEDURE
              a101_UnregisterStatement (
                    VAR acv     : tak_all_command_glob;
                    statementId : tsp00_Int4);
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        PROCEDURE
              a101_GetTempFileInstance(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_DestroyGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        FUNCTION
              a101_RTEMemAllocate (Size : tsp00_Int4) : tsp00_MoveObjPtr;
 
        PROCEDURE
              a101_QueryRewrite_MonitorReset;
 
        PROCEDURE
              a101_QueryRewrite_MonitorOut(
                    VAR acv   : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob);
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103AllUserStatistics (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
      ------------------------------ 
 
        FROM
              AK_User_Password : VAK21;
 
        FUNCTION
              a21is_owner (
                    VAR acv     : tak_all_command_glob;
                    VAR userrec : tak_userrecord) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_dialog_tools : VAK260;
 
        FUNCTION
              a260BuildDebugStack : boolean; (* PTS 1107879 & PTS 1112663 *)
 
        PROCEDURE
              a260reset_statistics;
 
        PROCEDURE
              a260statistics (
                    VAR external_proc_cnt   : tsp00_8ByteCounter;
                    VAR internal_proc_cnt   : tsp00_8ByteCounter);
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262reset_statistics;
 
        PROCEDURE
              a262statistics (
                    VAR external_trigger_cnt : tsp00_8ByteCounter;
                    VAR internal_trigger_cnt : tsp00_8ByteCounter);
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24init_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24finish_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24fnd_indexno (
                    VAR acv            : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    indexno            : integer;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24find_indexname (
                    VAR acv            : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    VAR indexname      : tsp00_KnlIdentifier;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24get_indexname (
                    VAR acv        : tak_all_command_glob;
                    indexbuf       : tak_sysbufferaddress;
                    index          : integer;
                    VAR index_name : tsp00_KnlIdentifier);
 
        FUNCTION
              a24next_named_index (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        PROCEDURE
              a28sys_upd_statistics (
                    VAR acv     : tak_all_command_glob;
                    VAR tree    : tgg00_FileId;
                    mtype       : tgg00_MessType;
                    m2type      : tgg00_MessType2;
                    known_pages : tsp00_Int4;
                    found_pages : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Kernel_Sink_1 : VAK341;
 
        PROCEDURE
              ak341OmsHeapInfo (
                    VAR acv                   : tak_all_command_glob;
                    VAR totalHeap             : tsp00_8ByteCounter;
                    VAR freeSpaceInFreeChunks : tsp00_8ByteCounter;
                    VAR reserved              : tsp00_8ByteCounter;
                    VAR mallocated            : tsp00_8ByteCounter;
                    VAR emergencySize         : tsp00_8ByteCounter;
                    VAR emergencyInUse        : tsp00_8ByteCounter;
                    VAR emergencyMaxUsed      : tsp00_8ByteCounter);
 
        FUNCTION
              ak341GetMonitorInfo (
                    VAR acv     : tak_all_command_glob;
                    VAR handle  : tsp00_Addr;
                    VAR iid     : tsp00_C16;
                    VAR disid   : tsp00_Int4;
                    VAR moninfo : tgg01_COMMonitorInfo) : boolean;
 
        FUNCTION
              ak341GetOmsUnloadedVersions : integer;
 
        PROCEDURE
              ak341MonitorHeapContent (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        FUNCTION
              ak341IsMonitorOn : boolean;
 
        FUNCTION
              ak341NextOmsLockObjInfo(
                    VAR pHandle  : tsp00_Addr;
                    VAR lockInfo : tgg01_OmsLockInfo) : boolean;
 
        PROCEDURE
              ak341ResetMonitor(VAR acv : tak_all_command_glob);
 
        PROCEDURE
              ak341ResetOmsVersionUnloadCounter;
 
        PROCEDURE
              ak341StartStopMonitor(doStart : boolean);
 
      ------------------------------ 
 
        FROM
              AK_cold_utility_functions : VAK36;
 
        PROCEDURE
              a36get_catalog_record (
                    VAR t      : tgg00_TransContext;
                    VAR sysk   : tgg00_SysInfoKey;
                    VAR sysbuf : tak_systembuffer);
 
        PROCEDURE
              a36restart_time (
                    VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        VAR
              a40yes_no : ARRAY[boolean] OF tsp00_C3;
 
        PROCEDURE
              a40FinishTableScan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob);
 
        PROCEDURE
              a40get_catalog_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a40move (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_const (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_counter (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    val           : tsp00_8ByteCounter;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_guid (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    VAR guid    : tsp00_C16);
 
        PROCEDURE
              a40move_i4 (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
        PROCEDURE
              a40move_real (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    val           : tsp00_Longreal;
                    is_null       : boolean;
                    frac          : integer);
 
        PROCEDURE
              a40put_date_time (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR datetime : tsp00_Int4;
                    date         : boolean;
                    is_undef     : boolean);
 
        PROCEDURE
              a40put_one_value (
                    VAR acv      : tak_all_command_glob;
                    VAR a41v     : tak40_show_glob;
                    VAR col_info : tak00_columninfo;
                    do_move      : boolean;
                    VAR valbuf   : tkb05_RowId;
                    valpos       : integer;
                    vallen       : integer;
                    VAR destbuf  : tsp00_C120;
                    VAR destlen  : integer;
                    VAR ok       : boolean);
 
        PROCEDURE
              a40init_table_scan (
                    VAR acv          : tak_all_command_glob;
                    VAR a41v         : tak40_show_glob;
                    scan_temp        : boolean;
                    scan_private     : boolean;
                    scan_non_private : boolean;
                    scan_public      : boolean;
                    use_synonyms     : boolean;
                    all_base         : boolean);
 
        PROCEDURE
              a40ignore_down_error (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a40table_column_to_shbuf (
                    VAR acv    : tak_all_command_glob;
                    VAR a41v   : tak40_show_glob;
                    base_ptr   : tak_sysbufferaddress;
                    colindex   : integer;
                    with_owner : boolean);
 
        PROCEDURE
              a40username_from_syskey (
                    VAR sysk      : tgg00_SysInfoKey;
                    VAR user_name : tsp00_KnlIdentifier);
 
        FUNCTION
              a40next_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51build_userkey (
                    VAR user_name : tsp00_KnlIdentifier;
                    VAR userkey : tgg00_SysInfoKey);
 
      ------------------------------ 
 
        FROM
              diagnose analyze : VAK544;
 
        PROCEDURE
              a544get_analyze_filter (VAR state : tsp00_C64);
 
      ------------------------------ 
 
        FROM
              diagnose monitor : VAK545;
 
        FUNCTION
              a545sm_get_rowno : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Catalog_Select_Optimizer : VAK722;
 
        FUNCTION
              a722test_col_qual (
                    VAR acv   : tak_all_command_glob;
                    VAR a41v  : tak40_show_glob;
                    colname   : tak_oldidentifier;
                    def_byte  : char;
                    value_ptr : tsp00_MoveObjPtr;
                    value_len : integer;
                    work_buf  : tak40_int2_arr_ptr) : boolean;
 
        PROCEDURE
              a722init_epos_reccol_relation(
                    VAR acv       : tak_all_command_glob;
                    VAR pos_info  : tak40_int2_arr_ptr);
 
        PROCEDURE
              a722finalize_epos_reccol_relation(
                    VAR acv       : tak_all_command_glob;
                    VAR pos_info  : tak40_int2_arr_ptr);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache  : VAK10;
 
        FUNCTION
              a10BaseRecPersistentOffset : integer;
 
        FUNCTION
              a10cache_used : tsp00_Int4;
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    key_prefix   : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06check_username (
                    VAR acv    : tak_all_command_glob;
                    VAR auth   : tsp00_KnlIdentifier;
                    VAR is_dba : boolean;
                    VAR ok     : boolean);
 
        PROCEDURE
              a06colname_retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4;
                    src_codeset : tsp00_Int2);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06get_page_cnt (
                    VAR acv          : tak_all_command_glob;
                    VAR file_id      : tgg00_FileId;
                    do_sample        : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR b_err        : tgg00_BasisError);
 
        PROCEDURE
              a06finish_curr_retpart (
                    VAR acv   : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06rsend_mess_buf (
                    VAR acv     : tak_all_command_glob;
                    VAR mblock  : tgg00_MessBlock;
                    result_req  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a06retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06set_mtree (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock;
                    VAR tree   : tgg00_FileId);
 
        PROCEDURE
              a06_systable_get (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR tableid  : tgg00_Surrogate;
                    VAR base_ptr : tak_sysbufferaddress;
                    get_all      : boolean;
                    VAR ok       : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        FUNCTION
              a061exist_columnname (
                    VAR base_rec    : tak_baserecord;
                    VAR column      : tsp00_KnlIdentifier;
                    VAR colinfo_ptr : tak00_colinfo_ptr) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_identifier_get (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id     : tgg00_FileId;
              b01blankfilename  : tsp00_VFilename;
 
        PROCEDURE
              bd01DataCacheSize (
                    VAR TotalPages : tsp00_Int4;
                    VAR UnMapPages : tsp00_Int4);
 
        FUNCTION
              bd01ConverterSize : tsp00_Int4;
 
        FUNCTION
              b01connect_allowed : boolean;
 
        FUNCTION
              b01db_full( taskId : tsp00_TaskId ) : boolean;
 
        PROCEDURE
              b01dbspace_statistic  (
                    VAR t    : tgg00_TransContext;
                    VAR info : tgg00_DbSpaceInfo);
 
        PROCEDURE
              b01destroy_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        FUNCTION
              b01devsize (
                    dev_type : tsp2_dev_type;
                    devno : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              b01empty_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        FUNCTION
              b01get_bad_index_cnt : tsp00_Int4;
 
        PROCEDURE
              b01get_data_cache_workload (
                    VAR trans                  : tgg00_TransContext;
                    VAR DataCacheSize          : tsp00_Int4;
                    VAR OmsHistoryPageCnt      : tsp00_Int4;
                    VAR OmsDataPageCnt         : tsp00_Int4;
                    VAR OmsUnloadedVersPageCnt : tsp00_Int4;
                    VAR SqlDataPageCnt         : tsp00_Int4);
 
        PROCEDURE
              b01get_devname (
                    dev_type    : tsp2_dev_type;
                    devno       : tsp00_Int4;
                    VAR devname : tsp2_devname);
 
        PROCEDURE
              bd01GetLeafPageAndRecordCount(
                    VAR trans         : tgg00_TransContext;
                    VAR fileId        : tgg00_FileId;
                    countRecords      : boolean;
                    VAR leafPageCount : tsp00_Int4;
                    VAR recordCount   : tsp00_Int4);
 
        PROCEDURE
              b01next_bad_dev (
                    VAR dev_type  : tsp2_dev_type;
                    VAR devno     : tsp00_Int4;
                    VAR devname   : tsp2_devname;
                    VAR realy_bad : boolean);
 
        PROCEDURE
              b01next_dev_info (
                    VAR dev_no          : tsp00_Int4;
                    VAR dev_type        : tsp2_dev_type;
                    VAR dev_name        : tsp2_devname;
                    VAR dev_size        : tsp00_Int4;
                    VAR dev_used_blocks : tsp00_Int4;
                    VAR dev_online      : boolean;
                    VAR dev_state       : tsp00_C18);
 
        PROCEDURE
              b01next_fdir_entry (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        FUNCTION
              b01no_of_data_devs : tsp00_Int4;
 
        FUNCTION
              b01no_of_log_devs : tsp00_Int4;
 
        PROCEDURE
              b01reset_monitor (part : tgg00_MonitorPart);
 
        PROCEDURE
              b01show_monitor (
                    TaskId   : tsp00_TaskId;
                    VAR info : tgg00_ReferenceInfo);
 
        PROCEDURE
              b01tcreate_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cadd_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cget_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cnext_record (
                    VAR t          : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tsp00_Buf);
 
        PROCEDURE
              b07crepl_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4 (
                    VAR source    : tsp00_Buf;
                    source_pos    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions: VSP40;
 
        PROCEDURE
              s40gbyte (
                    VAR buf        : tsp00_C120;
                    pos            : tsp00_Int4;
                    len            : integer;
                    VAR dest       : tsp00_C256;
                    dpos           : tsp00_Int4;
                    dlen           : integer;
                    VAR truncated  : boolean);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_Number;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
        PROCEDURE
              s41p4int (
                    VAR buf : tsp00_ResNum;
                    pos     : tsp00_Int4;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code                   : tgg04_CodeGlobals;
              g01glob                   : tgg00_KernelGlobals;
              g01autosave_distance      : tsp00_Int4;
              g01timeout                : tgg00_TimeoutGlobals;
              g01unicode                : boolean;
              g01vtrace                 : tgg00_VtraceState;
              gg01_operator_join        : boolean;
              gg01_operator_join_sort   : boolean;
 
        PROCEDURE
              g01datapart_init (
                    VAR mblock    : tgg00_MessBlock;
                    datapart_ptr  : tgg00_DataPartPtr;
                    datapart_size : tsp00_Int4);
 
        FUNCTION
              g01diag_minmax_optim : boolean;
 
        FUNCTION
              g01diag_reverse_fetch : boolean;
 
        FUNCTION
              g01maxcpu : tsp00_Int4;
 
        FUNCTION
              g01maxlocks : tsp00_Int4;
 
        FUNCTION
              g01maxobjgarbagecoll : tsp00_Int4;
 
        FUNCTION
              g01maxuser : tsp00_Int4;
 
        FUNCTION
              g01optimize_parallel_server : tsp00_Int4;
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        FUNCTION
              g01outer_join_ordered : boolean;
 
        FUNCTION
              g01sm_milliseconds : tsp00_Int4;
 
        FUNCTION
              g01sm_reads : tsp00_Int4;
 
        FUNCTION
              g01sm_selectivity : tsp00_Int4;
 
        PROCEDURE
              g01stack_init (
                    VAR mblock : tgg00_MessBlock;
                    stack_ptr  : tgg00_StackListPtr;
                    stack_size : tsp00_Int4;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
        PROCEDURE
              g01allocate_msg (
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    alloc_size : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t : tgg00_TransContext);
 
        PROCEDURE
              g04index_tree_build (
                    VAR file_id    : tgg00_FileId (*ptocConst*);
                    VAR index_tree : tgg00_FileId;
                    index_no       : tsp00_Int2);
 
        PROCEDURE
              g04short_col_tree_build (
                    VAR table_surrogate : tgg00_Surrogate (*ptocConst*);
                    VAR short_col_tree  : tgg00_FileId;
                    VAR b_err           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Kernel-Version : VGG11;
 
        PROCEDURE
              g11kernel_version  (VAR vers : tsp00_Version);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        FUNCTION
              gg999IsLogAutoOverwriteEnabled (taskid : tsp00_TaskId) : boolean;
 
        FUNCTION
              gg999IsLogWritingEnabled (taskid : tsp00_TaskId) : boolean;
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vgetapplpid (
                    pid           : tsp00_TaskId;
                    VAR appl_node : tsp00_NodeId;
                    VAR appl_pid  : tsp00_Int4;
                    VAR ok        : boolean);
 
        PROCEDURE
              vversion (
                    VAR rdsversion : tsp00_Version;
                    VAR lzuversion : tsp00_Version);
 
        PROCEDURE
              vdcom_dbproc (VAR cdp : tsp_dcom_dispatch_parms);
 
        PROCEDURE  (* Change Request 1000139 T.A. 14.10.1998 *)
              vdcom_monitor_open (VAR params : tsp_dcom_monitor_parms);
 
        PROCEDURE (* Change Request 1000139 T.A. 14.10.1998 *)
              vdcom_monitor_next (VAR params : tsp_dcom_monitor_parms);
 
        PROCEDURE (* Change Request 1000139 T.A. 14.10.1998 *)
              vdcom_monitor_close (VAR params : tsp_dcom_monitor_parms);
 
        PROCEDURE
              vgetfirstuserpid (VAR pid : tsp00_TaskId);
 
        FUNCTION
              vconnectedusertasks : tsp00_Int4;
 
        FUNCTION
              RTEMem_AWEAvailable : boolean;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01lidentifier (
                    debug : tgg00_Debug;
                    id : tsp00_KnlIdentifier);
 
        PROCEDURE
              t01buf (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_Buf;
                    startpos : integer;
                    endpos   : integer);
&       endif
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a05_identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              a40put_one_value;
 
              tsp00_C256 tkb05_RowId
              tsp00_C256 tsp00_C120
 
        FUNCTION
              a101_RTEMemAllocate;
 
              tgg00_VoidPtr tsp00_MoveObjPtr
 
        PROCEDURE
              b07cnext_record;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              g17int4to_line;
 
              tsp00_Line tsp00_C30
 
        FUNCTION
              Kernel_DiagInfop;
 
              tsp00_Identifier tak_keyword
 
        FUNCTION
              s20buf_to_int4;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s40gbyte;
 
              tsp00_MoveObj tsp00_C120
              tsp00_MoveObj tsp00_C256
 
        PROCEDURE
              s41plint;
 
              tsp00_MoveObj tsp00_Number
 
        PROCEDURE
              s41p4int;
 
              tsp00_MoveObj tsp00_ResNum
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
 
Erkennt Syntax :
 
  'SHOW'  'STATISTICS' 'MONITOR'
        [  'ON'
        /  'OFF'
         ]
.CM *-END-* specification -------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_get_all          = true;
      (* h.b. 16.08.1999 always run monitor  *)
      c_monitor_on       = true;
      (* *)
      c_100_pct          = 100;
      c_undefined        = -1;
      (* *)
      c_is_date          = true;
      c_is_null          = true;
      c_null             = true;
      c_to_undef         = true;
      c_reset_statistics = true;
      c_with_owner       = true;
      c_showDeletedFiles = true;
      c_not_in_use       = '\00\00\00\00\00\00\00\00\00\00\00\00';
      n_yes          = 'yes         ';
      n_no           = 'no          ';
      n_on           = 'on          ';
      n_off          = 'off         ';
      n_counting     = 'counting    ';
      n_ak           = 'AK          ';
      n_ascii        = 'ASCII       ';
      n_backup       = 'BACKUP      '; (* PTS 1103957 JA 1999-09-15 *)
      n_bytestr      = 'BYTESTR     ';
      n_datacache    = 'DATACACHE   '; (* PTS 1103957 JA 1999-09-15 *)
      n_default      = 'DEFAULT     ';
      n_delete       = 'DELETE      ';
      n_disabled     = 'disabled    ';
      n_eur          = 'EUR         ';
      n_index        = 'INDEX       ';
      n_insert       = 'INSERT      ';
      n_internal     = 'INTERNAL    ';
      n_iso          = 'ISO         ';
      n_jis          = 'JIS         ';
      n_kb_regions   = 'KB REGIONS  '; (* PTS 1103957 JA 1999-09-15 *)
      n_lock         = 'LOCK        ';
      n_lock_supply  = 'LOCK SUPPLY '; (* PTS 1103957 JA 1999-09-15 *)
      n_long         = 'LONG        ';
      n_obj_bd       = 'OBJECT      ';
      n_obj_free     = 'OBJECT FREE ';
      n_obj_new      = 'OBJECT ADD  ';
      n_obj_get      = 'OBJECT GET  ';
      n_obj_upd      = 'OBJECT ALTER';
      n_optimize     = 'OPTIMIZE    ';
      n_order        = 'ORDER       ';
      n_order_stndrd = 'ORDER STNDRD';
      n_pages        = 'PAGES       ';
      n_perm         = 'perm        ';
      n_select       = 'SELECT      ';
      n_table        = 'TABLE       ';
      n_temp         = 'temp        ';
      n_temp_concurr = 'temp concurr';
      n_time         = 'TIME        ';
      n_translist    = 'TRANSLIST   '; (* PTS 1103957 JA 1999-09-15 *)
      n_tree         = 'TREE        '; (* PTS 1103957 JA 1999-09-15 *)
      n_tree_locks   = 'TREE LOCKS  '; (* PTS 1103957 JA 1999-09-15 *)
      n_unicode      = 'UNICODE     ';
      n_unknown      = 'unknown     ';
      n_update       = 'UPDATE      ';
      n_usa          = 'USA         ';
      (* *)
      ln_serverdb    = 'SERVERDB          ';
      ln_log         = 'LOG               ';
      (* *)
      u_dba          = 'DBA     ';
      u_resource     = 'RESOURCE';
      u_standard     = 'STANDARD';
      (* *)
      (* statistic text *)
      (* *)
      n_bad_volume       = 'Bad volume                    ';
      n_reintegration    = 'Volume in reintegration       ';
      n_cf_dev_name      = 'Data volume       name        ';
      n_cf_dev_size      = 'Data volume       size        ';
      n_cf_logdev_name   = 'LOG name                      ';
      n_cf_logdev_size   = 'LOG size                      ';
      n_cf01_defaultcode = 'Default code                  ';
      n_cf02_date_time   = 'Date/time format              ';
      n_cf04_sesstimeout = 'SESSION TIMEOUT               ';
      n_cf06_req_timeout = 'REQUEST TIMEOUT               ';
      n_cf08_no_of_logs  = 'No of logs                    ';
      n_cf09_no_of_devs  = 'No of data volumes            ';
      n_cf10_mirror_dev  = 'Mirrored volumes              ';
      n_cf11_converter_sz= 'Converter size                ';
      n_cf12_datacache_sz= 'Datacache size                ';
      n_cf13_awe_mapped  = 'AWE mapped size               ';
      n_cf14_awe_unmapped= 'AWE unmapped size             ';
      n_inv01_cnt_seckey = 'Secondary keys (index lists)  ';
      n_inv02_avg_seclen = 'Avg secondary key length      ';
      n_inv03_min_seclen = 'Min secondary key length      ';
      n_inv04_max_seclen = 'Max secondary key length      ';
      n_inv05_cnt_prim   = 'Primary keys                  ';
      n_inv06_avg_listl  = 'Avg primary keys per list     ';
      n_inv07_min_listl  = 'Min primary keys per list     ';
      n_inv08_max_listl  = 'Max primary keys per list     ';
      n_logmode          = 'Log mode                      ';
      n_segmsize         = 'Log segment size              ';
      n_select_notsel    = 'Values with selectivity >  25%';
      n_select01         = 'Values with selectivity <=  1%';
      n_select05         = 'Values with selectivity <=  5%';
      n_select10         = 'Values with selectivity <= 10%';
      n_select25         = 'Values with selectivity <= 25%';
      n_st020_op_join    = 'Able to join w/o temp. results';
      n_op_join_sort     = 'Use operator sort if necessary';
      n_min_max_optim    = 'Optimize MIN/MAX access       ';
      n_outerj_ordered   = 'Outer Join Ordered            ';
      n_reverse_fetch    = 'Use reverse key/index order   ';
      n_join_parallel    = 'Optimize join parallel        ';
      (* PTS 1115978 E.Z. *)
      n_st021_monitoring = 'Monitoring                    '; (* h.b. PTS  *)
      n_st022_da         = 'Diagnose Analyze              '; (* h.b. PTS  *)
      n_st023_da_filter  = 'Diagnose Analyze Filter       '; (* h.b. PTS  *)
      n_st031_mon_read   = 'Diagnose monitor read         ';
      n_st032_mon_sel    = 'Diagnose monitor selectivity  ';
      n_st033_mon_sec    = 'Diagnose monitor time         ';
      n_st034_mon_data   = 'Monitor data collection       ';
      n_st035_mon_row    = 'Monitor rows                  ';
      n_st036_sap_db     = 'SERVERDB is for SAP           ';
      n_st04_used        = 'Catalog cache pages used      ';
      n_st061_bad_index  = 'No of bad indexes             ';
      n_st07_vtrace      = 'Vtrace                        ';
      n_st08_vtrace_chck = 'Vtrace check                  ';
      n_st08a_check      = 'Check                         '; (* PTS 1103957 JA 1999-09-15 *)
      n_st10_subtree_locks='Subtree locks                 '; (* PTS 1119690 E.Z. *)
      n_st11_vtrace_sess = 'Vtrace session                ';
      (* PTS 1110976 E.Z. *)
      n_st11a_stop_on_err= 'Stop on error     ';
      n_st12_db_full     = 'SERVERDB full                 ';
      n_st13_connect_poss= 'Connect possible              ';
      n_st130_logwriter_suspended= 'Logwriter suspended           '; (* PTS 1121939 E.Z. *)
      (* PTS 1107118 E.Z. *)
      n_st132_shutd_ok   = 'Last shutdown finished ok     ';
      m_st133_monitor_oms= 'Monitor OMS started           ';
      n_st18_log_write   = 'Log writing                   '; (* h.b. PTS 1113190 *)
      n_st19_log_auto_overwrite = 'Log automatic overwrite       '; (* PTS 1120106 UH 2003-01-20 *)
      n_st20_join_clust  = 'Join always use cluster       '; 
      n_tab01_root       = 'Root pno                      ';
      n_tab02_filetype   = 'Filetype                      ';
      n_tab03_nodes      = 'Used  pages                   ';
      n_tab04_indexnodes = 'Index pages                   ';
      n_tab05_leafnodes  = 'Leaf  pages                   ';
      n_tab06_hight      = 'Index levels                  ';
      n_tab07_covering   = 'Space used in all   pages (%) ';
      n_tab08_croot      = 'Space used in root  page  (%) ';
      n_tab09_cindex     = 'Space used in index pages (%) ';
      n_tab10_cmin       = 'Space used in index pages (%) min       ';
      n_tab11_cmax       = 'Space used in index pages (%) max       ';
      n_tab12_cleaf      = 'Space used in leaf  pages (%) ';
      n_tab13_lmin       = 'Space used in leaf  pages (%) min       ';
      n_tab14_lmax       = 'Space used in leaf  pages (%) max       ';
      n_tab15_rows       = 'Rows                          ';
      n_tab16_rows_per   = 'Avg rows per page             ';
      n_tab17_min_rows   = 'Min rows per page             ';
      n_tab18_max_rows   = 'Max rows per page             ';
      n_tab19_avg_rowlen = 'Avg row length                ';
      n_tab20_min_rowlen = 'Min row length                ';
      n_tab21_max_rowlen = 'Max row length                ';
      n_tab22_avg_keylen = 'Avg key length                ';
      n_tab23_min_keylen = 'Min key length                ';
      n_tab24_max_keylen = 'Max key length                ';
      n_tab25_avg_seplen = 'Avg separator length          ';
      n_tab26_min_seplen = 'Min separator length          ';
      n_tab27_max_seplen = 'Max separator length          ';
      n_tab28_def_str    = 'Defined LONG columns          ';
      n_tab29_avg_strlen = 'Avg LONG   column length      ';
      n_tab30_min_strlen = 'Min LONG   column length      ';
      n_tab31_max_strlen = 'Max LONG   column length      ';
      n_tab32_str_pages  = 'LONG column pages             ';
      n_tab33_avg_spages = 'Avg pages per LONG column     ';
      n_tab34_min_spages = 'Min pages per LONG column     ';
      n_tab35_max_spages = 'Max pages per LONG column     ';
      (* *)
      n_sys2_cat         = 'SYS_2_CATALOG     ';
      n_obj_file         = 'OBJECT            ';
 
TYPE
 
      tak42_oms_monitor_rec = RECORD
            CASE integer OF
                1 :
                    (align : tsp00_Addr);
                2 :
                    (rec : tgg00_Rec);
                3 :
                    (offset : ARRAY[1..cgg_rec_key_offset] OF char;
                    iid     : tsp00_C16;
                    dispid  : tsp00_Int4;
                    filler  : tsp00_Int4;
                    info    : tgg01_COMMonitorInfo);
                END;
            (*ENDCASE*) 
 
 
      tak42_monitor_rec_key = RECORD
            CASE boolean OF
                true :
                    (lkey : tgg00_Lkey);
                false :
                    (offset  : ARRAY[1..cgg_rec_key_offset] OF char;
                    iid      : tsp00_C16;
                    dispid   : tsp00_Int4);
                END;
            (*ENDCASE*) 
 
 
VAR
      ak42refresh_cnt      : tsp00_Int4;
      ak42fast_refresh_cnt : tsp00_Int4;
      a42monitor_arr       : ARRAY [ tgg00_RefInfoIndex ] OF tsp00_C40;
      a42parseid_list      : tsp00_MoveObjPtr;
 
 
(*------------------------------*) 
 
PROCEDURE
      a42execute (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
BEGIN
WITH acv, a41v DO
    BEGIN
    CASE a4sh_kind OF
        sh_consistent_view : (* PTS 1106007 *)
            ak42consistent_view (acv, a41v);
        sh_ctrl_configuration :
            ak42ctrl_config (acv, a41v);
        sh_ctrl_devspaces :
            ak42ctrl_devspaces (acv, a41v);
        sh_ctrl_io_statistics :
            ak42ctrl_io_statistics (acv, a41v);
        sh_ctrl_locks :
            ak42ctrl_locks (acv, a41v);
        sh_ctrl_log :
            ak42ctrl_log_statistics (acv, a41v);
        (* PTS 1120445 D.T. *)
        (* PTS 1115043 E.Z. *)
        sh_dbm_state :
            ak42dbm_state (acv, a41v);
        sh_roots :
            ak42roots (acv, a41v);
        (* PTS 1113491 *)
        sh_heap_content :
            ak42HeapContent (acv, a41v);
        sh_history_info :
            ak42history_info (acv, a41v);
        (* PTS 1109995 E.Z. *)
        sh_lock, sh_trans, sh_st_lock:
            ak42select_lock_trans (acv, a41v);
        sh_st_config :
            ak42show_config  (acv, a41v);
        sh_st_database :
            ak42serverdb_statistics (acv, a41v);
        sh_monitor_oms :
            ak42monitor_oms  (acv, a41v, NOT c_reset_statistics);
        sh_st_monitor :
            ak42monitor_show (acv, a41v);
        sh_st_state :
            ak42state_statistics (acv, a41v);
        sh_st_user :
            ak42user_statistics  (acv, a41v);
        sh_version_old :
            ak42show_version (acv, a41v);
        (* PTS 115043 U.J. *)
        sh_running_cmds :
            ak42show_running_cmds(acv, a41v);
        sh_oms_memory :
            ak42oms_memory(acv, a41v);
        (* PTS 1107717 E.Z. *)
        sh_internal_state :
            ak42internal_state (acv, a41v);
        sh_oms_lock : (* PTS 1110315 *)
            ak42OmsLockObjInfo (acv, a41v);
        sh_info_gc_stats :
            ak42InfoGCStats (acv, a41v);
        sh_container_roots : (* PTS 1115641 FF *)
            ak42_container_roots (acv, a41v);
        sh_container_chains : (* PTS 1115641 FF *)
            ak42_container_chains (acv, a41v);
        sh_container_keys : (* PTS 1115641 FF *)
            ak42_container_keys (acv, a41v);
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42get_tablename (
            VAR t      : tgg00_TransContext;
            VAR tabid  : tgg00_Surrogate;
            VAR authid : tsp00_KnlIdentifier;
            VAR tablen : tsp00_KnlIdentifier;
            VAR b_err  : tgg00_BasisError);
 
VAR
      name_pos        : integer;
      syskey          : tgg00_SysInfoKey;
      sysbuf          : tgg00_Rec;
      sysbuf_ptr      : tak_sysbufferaddress;
 
BEGIN
sysbuf_ptr      := @sysbuf;
authid          := a01_il_b_identifier;
tablen          := a01_il_b_identifier;
syskey          := a01defaultkey;
syskey.stableid := tabid;
a36get_catalog_record (t, syskey, sysbuf_ptr^);
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    IF  sysbuf_ptr^.sbase.btablekind = tsynonym
    THEN
        name_pos := sizeof(tak_synonymrecord) -
              sizeof(sysbuf_ptr^.ssynonym.syn_tablen) + 1
    ELSE
        name_pos := a10BaseRecPersistentOffset + 1; (* PTS 1105713, T.A. 24.02.2000 *)
    (*ENDIF*) 
&   ifdef trace
    t01int4 (ak_sem, 'name_pos    ', name_pos);
&   endif
    tablen := a01_il_b_identifier;
    SAPDB_PascalMove ('VAK42 ',   1,    
          sizeof (sysbuf.buf), sizeof (tablen), @sysbuf.buf, name_pos + 1,
          @tablen, 1, ord (sysbuf.buf[name_pos]), t.trError_gg00);
    authid := a01_il_b_identifier
    END;
&ifdef trace
(*ENDIF*) 
t01lidentifier (bi, tablen);
&endif
b_err := t.trError_gg00
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42_get_pagecount (
            VAR acv       : tak_all_command_glob;
            base_ptr      : tak_sysbufferaddress;
            VAR pagecount : tsp00_Int4);
 
VAR
      pages          : tsp00_Int4;
      index_scan_rec : tak_index_scan_record;
 
      data           : RECORD
            CASE boolean OF
                true :
                    (d : tsp00_Longreal);
                false :
                    (b : tgg00_DoubleBuf);
                END;
            (*ENDCASE*) 
 
      qual           : tgg00_QualBuf;
      mblock         : tgg00_MessBlock;
 
BEGIN
g01mblock_init   (acv.a_transinf.tri_trans, m_nil, mm_nil, mblock);
g01datapart_init (mblock, @data, sizeof (data));
g01stack_init    (mblock, NIL, 0, @qual, sizeof (qual));
WITH acv DO
    BEGIN
    ak42table_statistics (acv, base_ptr^.sbase, mblock);
    WITH mblock.mb_data^.mbp_sample DO
        pages := nodes + all_stringcol_pages;
    (*ENDWITH*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        (*=======================================*)
        (*= determine number of index leaf pages *)
        (*=======================================*)
        IF  base_ptr^.sbase.bindexexist
        THEN
            BEGIN
            a24init_index_scan (acv, base_ptr^.sbase.bsurrogate,
                  index_scan_rec);
            WITH index_scan_rec DO
                WHILE a24next_named_index (acv, index_scan_rec) DO
                    WITH isr_buf^.smindex.indexdef[isr_index] DO
                        IF  (indexno <> 0) AND
                            (a_returncode = 0)
                        THEN
                            BEGIN
                            ak42one_index_statistics (acv, sh_indexpages,
                                  base_ptr^.sbase, icolstack[1],
                                  mblock);
                            pages := pages +
                                  mblock.mb_data^.mbp_sample.nodes
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                (*ENDWHILE*) 
            (*ENDWITH*) 
            a24finish_index_scan (acv, index_scan_rec)
            END;
        (*=====================================*)
        (*= determine space of single indexes =*)
        (*=====================================*)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        pagecount := pagecount + pages;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      a42_init_time_array;
 
BEGIN
a42check_time := true;
END;
 
&endif
(* PTS 1103033 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak42monitor_init (procid : tsp00_TaskId);
 
BEGIN
ak42refresh_cnt      := 0;
ak42fast_refresh_cnt := 0;
a260reset_statistics;
a262reset_statistics;
k51reset_statistics  (procid);
kb560ResetStatistics (procid);
k57statistics_reset  (procid);
k720init_ref_statistic;
b01reset_monitor (mpAll_egg00);
(* PTS 1103033 E.Z. *)
(* PTS 1103735 E.Z. *)
(* PTS 1111134 E.Z. *)
bd91InfoGCReset; (* PTS 1113774 F.F. *)
ak341ResetOmsVersionUnloadCounter; (* PTS 1119215 *)
a101_QueryRewrite_MonitorReset;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42_start_semantic (VAR acv : tak_all_command_glob);
 
VAR
      procid : tsp00_TaskId;
 
BEGIN
WITH acv DO
    BEGIN
    procid := a_transinf.tri_trans.trTaskId_gg00;
    IF  (a_current_user_kind <> usysdba) AND
        (a_current_user_kind <> udba)    AND
        (a_current_user_kind <> ucontroluser)
    THEN
        a07_b_put_error (acv, e_missing_privilege, 1)
    ELSE
        CASE a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_subproc  OF
            cak_i_init:
                BEGIN
                IF  a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_length <> cak_i_object
                THEN (* PTS 1108772 *)
                    ak42monitor_init (procid);
                (*ENDIF*) 
                a42ResetOmsMonitor (acv);
                END;
            cak_i_on :
                BEGIN
                (* h.b. 16.08.1999 always run monitor  *)
                END;
            cak_i_off :
                BEGIN
                (* h.b. 16.08.1999 always run monitor  *)
                END;
            cak_i_object :
                ak42monitor_object(acv, a_ap_tree^[a_ap_tree^[0].n_lo_level].n_length);
            OTHERWISE :
                a07_b_put_error (acv, e_not_implemented, 1);
            END;
        (*ENDCASE*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42ctrl_config (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      autosave_on    : boolean;
      kb_factor      : tsp00_Int4;
      totalPages     : tsp00_Int4;
      unMapPages     : tsp00_Int4;
      sname          : tsp00_Sname;
      media_name     : tsp00_C64;
 
BEGIN
bd01DataCacheSize( totalPages, unMapPages ); (* TODO *)
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    CASE g01code.char_default OF
        csp_ascii:
            sname := n_ascii;
        csp_codeneutral:
            sname := n_internal;
        csp_unicode:
            sname := n_unicode;
        OTHERWISE
            sname := bsp_sname;
        END;
    (*ENDCASE*) 
    a40move_const (acv, a41v, @sname, sizeof (sname));
    CASE g01code.date_time OF
        dtf_normal :
            sname := n_internal;
        dtf_eur, dtf_ts_eur :
            sname := n_eur;
        dtf_iso    :
            sname := n_iso;
        dtf_jis    :
            sname := n_jis;
        dtf_usa    :
            sname := n_usa;
        OTHERWISE
            sname := bsp_sname;
        END;
    (*ENDCASE*) 
    a40move_const (acv, a41v, @sname, sizeof (sname));
    (* PTS 1118319 E.Z. *)
    IF  bd999LogIsMirrored
    THEN
        sname := 'DUAL        '
    ELSE
        sname := 'SINGLE      ';
    (*ENDIF*) 
    a40move_const (acv, a41v, @sname, sizeof (sname));
    a40move_const (acv, a41v, @a40yes_no [false], 1);
    a40move_const (acv, a41v, @a40yes_no [b01db_full( acv.a_transinf.tri_trans.trTaskId_gg00) ], 1);
    (* PTS 1112568 E.Z. *)
    a40move_const (acv, a41v, @a40yes_no
          [kb560LogIsFull], 1);
    a40move_const (acv, a41v, @a40yes_no [b01connect_allowed], 1);
    a40move_const (acv, a41v, @a40yes_no [a01diag_monitor_on], 1);
    a40move_const (acv, a41v, @a40yes_no [c_monitor_on], 1);
    a40move_const (acv, a41v, @a40yes_no [g01vtrace.vtrAny_gg00], 1);
    autosave_on := k38is_on_autosave (acv.a_transinf.tri_trans, false);
    a40move_const (acv, a41v, @a40yes_no [autosave_on], 1);
    (* PTS 1000211, T.A. 1999-07-12 *)
    IF  autosave_on
    THEN
        BEGIN
        k38get_autosave_medianame (acv.a_transinf.tri_trans.trTaskId_gg00, media_name);
        a40move_const (acv, a41v, @media_name, sizeof(media_name));
        END
    ELSE
        a40move (acv, a41v, NIL, 0);
    (*ENDIF*) 
    a40move_const (acv, a41v, @a40yes_no [false], 1);
    a40move_i4    (acv, a41v, g01maxuser,           NOT c_null, 0, NOT c_to_undef);
    a40move_i4    (acv, a41v, g01maxcpu,            NOT c_null, 0, NOT c_to_undef);
    a40move_i4    (acv, a41v, b01no_of_log_devs,    NOT c_null, 0, NOT c_to_undef);
    a40move_i4    (acv, a41v, b01no_of_data_devs,   NOT c_null, 0, NOT c_to_undef);
    a40move_i4    (acv, a41v, b01get_bad_index_cnt, NOT c_null, 0, NOT c_to_undef);
    kb_factor := PAGE_MXSP00 DIV 1024;
    a40move_i4    (acv, a41v,
          bd01ConverterSize * kb_factor, NOT c_null, 0, NOT c_to_undef);
    a40move_i4    (acv, a41v,
          totalPages * kb_factor, NOT c_null, 0, NOT c_to_undef);
    a40move_i4    (acv, a41v, kb560LogQueueSize, NOT c_null, 0, NOT c_to_undef);
    a40move_i4    (acv, a41v, g01maxlocks, NOT c_null, 0, NOT c_to_undef);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42ctrl_devspaces (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      kb_factor       : integer;
      dev_no          : tsp00_Int4;
      dev_used_blocks : tsp00_Int4;
      devType         : tsp00_C4;
      dev_type        : tsp2_dev_type;
      dev_name        : tsp2_devname;
      dev_size        : tsp00_Int4;
      dev_online      : boolean;
      dev_state       : tsp00_C18;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    dev_no    := -1;
    kb_factor := PAGE_MXSP00 DIV 1024;
    REPEAT
        b01next_dev_info (dev_no, dev_type, dev_name,
              dev_size, dev_used_blocks, dev_online, dev_state);
        IF  dev_no >= 0
        THEN
            BEGIN
            CASE dev_type OF
                sp2dt_sys :
                    devType := 'SYS ';
                sp2dt_log :
                    devType := 'LOG ';
                sp2dt_data :
                    devType := 'DATA';
                OTHERWISE
                    devType := '    ';
                END;
            (*ENDCASE*) 
            a40move_const (acv, a41v, @devType, sizeof (devType));
            a40move_i4    (acv, a41v, dev_no, NOT c_null, 0, NOT c_to_undef);
            a40move_const (acv, a41v, @dev_name, sizeof (dev_name));
            a40move_i4    (acv, a41v, dev_size * kb_factor, NOT c_null, 0, NOT c_to_undef);
            a40move_const (acv, a41v, @dev_state, sizeof (dev_state));
            END;
        (*ENDIF*) 
    UNTIL
        dev_no = -1;
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42ctrl_io_statistics (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      rowNo  : integer;
      sum_ix : integer;
      ind    : tgg00_RefInfoIndex;
      c10    : tsp00_C10;
      info   : tgg00_ReferenceInfo;
      sum    : ARRAY[1..4] OF tsp00_Longreal;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    FOR sum_ix := 1 TO 4 DO
        sum[sum_ix] := 0;
    (*ENDFOR*) 
    rowNo  := 0;
    ak42get_refinfo (acv, info);
    (* PTS 1115043 E.Z. *)
    FOR ind :=  icatalog_r_v TO ipsm_w_p DO
        BEGIN
        IF  a41v.a4pos = 1
        THEN
            BEGIN
            sum_ix := 1;
            rowNo  := rowNo + 1;
            CASE rowNo OF
                1 :
                    c10 := 'Catalog   ';
                2 :
                    c10 := 'Perm Data ';
                3 :
                    c10 := 'Temp Data ';
                (* PTS 1103033 E.Z. *)
                4 :
                    c10 := 'Long Data ';
                5 :
                    c10 := 'Leaf      ';
                6 :
                    c10 := 'Level 1   ';
                7 :
                    c10 := 'Level 2   ';
                8 :
                    c10 := 'Level 3   ';
                (* PTS 1115043 E.Z. *)
                9 :
                    c10 := 'Level 4   ';
                10 :
                    c10 := 'Level 5   ';
                11 :
                    BEGIN
                    c10 := 'Sum (Tree)'; (* PTS 1102630, T.A. 1999-05-10 *)
                    a40move_const (acv, a41v, @c10, sizeof (c10));
                    FOR sum_ix := 1 TO 4 DO
                        a40move_real (acv, a41v, sum[sum_ix], sum[sum_ix] < 0, 0);
                    (*ENDFOR*) 
                    c10 := 'Converter ';
                    END
                END;
            (*ENDCASE*) 
            a40move_const (acv, a41v, @c10, sizeof (c10));
            END;
        (*ENDIF*) 
        a40move_counter (acv, a41v, info.reference_array[ind], NOT c_null, 0, NOT c_to_undef);
        IF  (rowNo >= 4) AND (rowNo <= 10) (* PTS 1102630, T.A. 1999-05-10 *)
        THEN
            IF  sum[sum_ix] >= 0
            THEN
                sum[sum_ix] := sum[sum_ix] + info.reference_array[ind];
            (*ENDIF*) 
        (*ENDIF*) 
        sum_ix := sum_ix + 1
        END;
    (*ENDFOR*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42ctrl_locks (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      lock_info : tkb05_LockInfo; (* PTS 1103743 JA 1999-08-25 *)
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    (* PTS 1103033 E.Z.; PTS 1103743 JA 1999-08-25 *)
    k51info_lock (acv.a_transinf.tri_trans.trTaskId_gg00, lock_info);
    WITH lock_info DO
        BEGIN
        a40move_i4      (acv, a41v, infMaxEntries_kb05,      NOT c_null, 0, NOT c_to_undef);
        a40move_i4      (acv, a41v, infAvgUsed_kb05,         NOT c_null, 0, NOT c_to_undef);
        a40move_counter (acv, a41v, infSqlCollisions_kb05,   NOT c_null, 0, NOT c_to_undef);
        a40move_counter (acv, a41v, infEscalations_kb05,     NOT c_null, 0, NOT c_to_undef);
        a40move_counter (acv, a41v, infRowEntryAmount_kb05,  NOT c_null, 0, NOT c_to_undef);
        a40move_counter (acv, a41v, infTabEntryAmount_kb05,  NOT c_null, 0, NOT c_to_undef);
        a40move_i4      (acv, a41v, g01timeout.timeReq_gg00, NOT c_null, 0, NOT c_to_undef)
        END
    (*ENDWITH*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42ctrl_log_statistics (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      kb_factor           : integer;
      log_percent         : tsp00_Int4;
      sname               : tsp00_Sname;
      ref_info            : tgg00_ReferenceInfo;  (* PTS 1103743 JA 1999-08-25 *)
      log_queue_info      : tkb00_LogQueueInfo;
      log_device_info     : tkb00_LogDeviceInfo;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    kb_factor := PAGE_MXSP00 DIV 1024;
    ak42get_refinfo (acv, ref_info);
    kb560GetStatistics (acv.a_transinf.tri_trans.trTaskId_gg00,
          log_device_info, log_queue_info);
    (* PTS 1118319 E.Z. *)
    IF  bd999LogIsMirrored
    THEN
        sname := 'DUAL        '
    ELSE
        sname := 'SINGLE      ';
    (*ENDIF*) 
    a40move_const (acv, a41v, @sname, sizeof (sname));
    a40move_i4    (acv, a41v, kb560GetLogDeviceSize * kb_factor, NOT c_null, 0, NOT c_to_undef);
    a40move_i4    (acv, a41v, g01autosave_distance * kb_factor, NOT c_null, 0, NOT c_to_undef);
    WITH log_device_info DO
        BEGIN
        a40move_i4 (acv, a41v, ldiPagesUsed_kb00 * kb_factor,     NOT c_null, 0, NOT c_to_undef);
        log_percent := ak42evalpercent (ldiPagesUsed_kb00, kb560GetLogDeviceSize);
        (* *)
        a40move_i4 (acv, a41v, log_percent,                       NOT c_null, 0, NOT c_to_undef);
        a40move_i4 (acv, a41v, ldiPagesNotSaved_kb00 * kb_factor, NOT c_null, 0, NOT c_to_undef);
        log_percent := ak42evalpercent (ldiPagesNotSaved_kb00, kb560GetLogDeviceSize);
        (* *)
        a40move_i4 (acv, a41v, log_percent,                       NOT c_null, 0, NOT c_to_undef);
        a40move_i4 (acv, a41v, ldiPagesSinceBup_kb00 * kb_factor, NOT c_null, 0, NOT c_to_undef);
        a40move    (acv, a41v, NIL, 0);                                           (* to do *)
        a40move_i4 (acv, a41v, ldiSaveptCount_kb00,               NOT c_null, 0, NOT c_to_undef);
        a40move_i4 (acv, a41v, 0(*ldiCheckptCount_kb00*),         NOT c_null, 0, NOT c_to_undef)
        END;
    (*ENDWITH*) 
    WITH ref_info DO
        BEGIN
        a40move_counter (acv,a41v, reference_array [iread_log ], NOT c_null, 0, NOT c_to_undef);
        a40move_counter (acv,a41v, reference_array [iwrite_log], NOT c_null, 0, NOT c_to_undef)
        END;
    (*ENDWITH*) 
    WITH log_queue_info DO
        BEGIN
        a40move_i4      (acv, a41v, lqiLogQueueSize_kb00 * kb_factor, NOT c_null, 0, NOT c_to_undef);
        a40move         (acv, a41v, NIL, 0); (* queue allocated ?? *)
        a40move         (acv, a41v, NIL, 0); (* queue entries   ?? *)
        a40move_counter (acv, a41v, lqiCountRequest_kb00,             NOT c_null, 0, NOT c_to_undef);
        a40move_counter (acv, a41v, lqiCountGroup_kb00,               NOT c_null, 0, NOT c_to_undef);
        a40move_counter (acv, a41v, lqiCountWait_kb00,                NOT c_null, 0, NOT c_to_undef);
        a40move_i4      (acv, a41v, lqiMaxWaitLogpage_kb00,           NOT c_null, 0, NOT c_to_undef);
        a40move_counter (acv, a41v, lqiAvgSumPagewaits_kb00,          NOT c_null, 0, NOT c_to_undef)
        END;
    (*ENDWITH*) 
    (* former obj_log_cache_info: PTS 1105395 JA 2000-03-07 *)
    a40move_i4 (acv, a41v, 0 (* PagesUsed    *), NOT c_null, 0, NOT c_to_undef);
    a40move_i4 (acv, a41v, 0 (* PagesMinFree *), NOT c_null, 0, NOT c_to_undef)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42caches_statistics (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      i          : tgg00_RefInfoIndex;
      ind        : tgg00_RefInfoIndex;
      kind_ix    : integer;
      total      : tsp00_Longreal;
      hit        : tsp00_Longreal;
      (* PTS 1115020 E.Z. *)
      cache_kind : ARRAY[1..2] OF tsp00_C18;
      info       : tgg00_ReferenceInfo;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    ak42get_refinfo (acv, info);
    cache_kind[1] := 'DATA              ';
    (* PTS 1103735 E.Z. *)
    (* PTS 1111134 E.Z. *)
    (* PTS 1105315 E.Z. *)
    (* PTS 1115020 E.Z. *)
    cache_kind[2] := 'SEQUENCE          ';
    kind_ix       := 0;
    (* PTS 1103735 E.Z. *)
    FOR ind := idata_cache_total TO isseq_cache_percent DO
        IF  NOT (ind in [iak_cache_total, iak_cache_hit, iak_cache_miss, iak_cache_percent])
        THEN
            BEGIN
            IF  ind in [idata_cache_total,
                (* PTS 1103735 E.Z. *)
                (* PTS 1111134 E.Z. *)
                (* PTS 1105315 E.Z. *)
                (* PTS 1115020 E.Z. *)
                isseq_cache_total]
            THEN
                BEGIN
                a40move (acv, a41v, NIL, 0); (* null value for sessiond column *)
                kind_ix := kind_ix + 1;
                a40move_const (acv, a41v, @cache_kind[kind_ix], sizeof (cache_kind[kind_ix]));
                END;
            (*ENDIF*) 
            IF  ind in [ idata_cache_percent,
                (* PTS 1103735 E.Z. *)
                (* PTS 1111134 E.Z. *)
                (* PTS 1105315 E.Z. *)
                (* PTS 1115020 E.Z. *)
                iak_cache_percent,
                isseq_cache_percent]
            THEN
                BEGIN (* evaluate percentage value *)
                i   := pred(pred(ind));
                hit := info.reference_array[ i ];
                i   := pred(i);
                total := info.reference_array[ i ];
                info.reference_array[ ind ] :=
                      ak42evalpercent_real (hit, total);
                IF  total = 0
                THEN
                    a40move_counter (acv, a41v, info.reference_array[ind], c_null, 0, NOT c_to_undef)
                ELSE
                    a40move_counter (acv, a41v, info.reference_array[ind], NOT c_null, 0, NOT c_to_undef);
                (*ENDIF*) 
                END
            ELSE
                (* PTS 1111134 E.Z. *)
                a40move_counter (acv, a41v, info.reference_array[ind], NOT c_null, 0, NOT c_to_undef);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDFOR*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42out_monitor (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            VAR info  : tgg00_ReferenceInfo;
            ind       : tgg00_RefInfoIndex);
 
VAR
      hit   : tsp00_Longreal;
      total : tsp00_Longreal;
      i     : tgg00_RefInfoIndex;
 
BEGIN
(* PTS 1103735 E.Z. *)
(* PTS 1111134 E.Z. *)
IF  ind in [ idata_cache_percent,
    (* PTS 1105315 E.Z. *)
    (* PTS 1115020 E.Z. *)
    (* PTS 1115043 E.Z. *)
    iak_cache_percent,
    isseq_cache_percent,
    idata_obj_cache_percent, idata_obj_log_cache_percent,
    (* PTS 1106423 TS 2000-04-20 *)
    (* PTS 1111572 E.Z. *)
    idata_history_cache_percent,
    (* PTS 1106423 *)
    (* PTS 1111134 E.Z. *)
    idata_sql_cache_percent (* PTS 1109469 *)
    ]
THEN
    BEGIN (* evaluate percentage value *)
    i   := pred(pred(ind));
    hit := info.reference_array[ i ];
    i   := pred(i);
    total := info.reference_array[ i ];
    IF  (hit >= 0) AND (total >= 0)
    THEN
        info.reference_array[ ind ] :=
              ak42evalpercent_real (hit, total)
    ELSE
        info.reference_array[ ind ] := -1
    (*ENDIF*) 
    END;
(* PTS 1103735 E.Z. *)
(* PTS 1111134 E.Z. *)
(* PTS 1111572 E.Z. *)
(*ENDIF*) 
IF  (ind >= idata_cache_total) AND (ind <= idata_history_cache_percent)
THEN
    a41v.a4ti := cak_i_caches;
(*ENDIF*) 
IF  (ind >= isql_commands) AND (ind <= ijoin_op_improved )
THEN
    a41v.a4ti := cak_i_load;
(* PTS 1103033 E.Z. *)
(*ENDIF*) 
IF  (ind  >= iavg_lock_used) AND (ind <= irequest_timeouts)
THEN
    a41v.a4ti := cak_i_lock;
(*ENDIF*) 
IF  (ind >= iread_log) AND (ind <= iavg_sum_pagewaits)
THEN
    a41v.a4ti := cak_i_log;
(* PTS 1103033 E.Z. *)
(*ENDIF*) 
IF  (ind >= iread_string) AND (ind <= iwrite_string)
THEN
    a41v.a4ti := cak_i_long;
(* PTS 1115043 E.Z. *)
(*ENDIF*) 
IF  (ind >= ir_v_acc) AND (ind <= ipsm_w_p)
THEN
    a41v.a4ti := cak_i_pages;
(*ENDIF*) 
IF  (ind >= iadd_rec) AND (ind <= icget_inv)
THEN
    a41v.a4ti := cak_i_row;
(* PTS 1103033 E.Z. *)
(*ENDIF*) 
IF  (ind >= ifunccount) AND (ind <= ikb_calls)
THEN
    a41v.a4ti := cak_i_transaction;
(* PTS 1115043 E.Z. *)
(*ENDIF*) 
IF  (info.reference_array[ ind ] >= 0)
THEN
    (* h.b. '* 1.0' looks silly but is necessary because
          of missing cast in pascal *)
    a42ref_stat_real (acv, a41v, a42monitor_arr [ind], info.reference_array [ind] * 1.0);
(* PTS 1103119 E.Z. *)
(* PTS 1103247 E.Z. *)
(*ENDIF*) 
IF  ind = idata_history_cache_percent
THEN
    ak42data_cache_statistics (acv, a41v)
(*ENDIF*) 
END;
 
(* PTS 1111572 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak42data_cache_statistics (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob);
 
VAR
      DataCacheSize          : tsp00_Int4;
      OmsHistoryPageCnt      : tsp00_Int4;
      OmsDataPageCnt         : tsp00_Int4;
      OmsUnloadedVersPageCnt : tsp00_Int4;
      SqlDataPageCnt         : tsp00_Int4;
 
BEGIN
a41v.a4ti := cak_i_caches;
(* k56iobjlog_info and obj_log_cache_info removed: PTS 1105395 JA 2000-03-07 *)
(* PTS 1111572 E.Z. *)
b01get_data_cache_workload (acv.a_transinf.tri_trans, DataCacheSize,
      OmsHistoryPageCnt, OmsDataPageCnt, OmsUnloadedVersPageCnt, SqlDataPageCnt);
ak42ref_i4_statistic (acv, a41v,
      'Data cache no of SQL data pages         ', SqlDataPageCnt);
ak42ref_i4_statistic (acv, a41v,
      'Data cache no of OMS data pages         ', OmsDataPageCnt);
(* PTS 1111572 E.Z. *)
ak42ref_i4_statistic (acv, a41v,
      'Data cache no of history/undo pages     ', OmsHistoryPageCnt);
ak42ref_i4_statistic (acv, a41v,
      'Data cache no of unloaded version pages ', OmsUnloadedVersPageCnt);
(* PTS 1111572 E.Z. *)
END;
 
(* PTS 1115043 E.Z. *)
(* PTS 1115090 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak42datacache_hits (
            VAR acv                       : tak_all_command_glob;
            VAR datacache_hitrate         : tsp00_Int4;
            VAR datacache_oms_hitrate     : tsp00_Int4;
            VAR datacache_oms_log_hitrate : tsp00_Int4);
 
VAR
      info    : tgg00_ReferenceInfo;
      total   : tsp00_Longreal;
      hit     : tsp00_Longreal;
 
BEGIN
WITH acv, info DO
    BEGIN
    b01show_monitor  (a_transinf.tri_trans.trTaskId_gg00, info);
    (* PTS 1127149 E.Z. *)
    reference_array [idata_cache_total] := reference_array [idata_cache_total]
          + reference_array [idata_obj_cache_total]
          + reference_array[idata_obj_log_cache_total]
          + reference_array[idata_history_cache_total];
    reference_array [idata_cache_hit] := reference_array [idata_cache_hit]
          + reference_array [idata_obj_cache_hit]
          + reference_array[idata_obj_log_cache_hit]
          + reference_array[idata_history_cache_hit];
    reference_array [idata_cache_miss] := reference_array [idata_cache_miss]
          + reference_array [idata_obj_cache_miss]
          + reference_array[idata_obj_log_cache_miss]
          + reference_array[idata_history_cache_miss];
    total := info.reference_array[ idata_cache_total ];
    hit   := info.reference_array[ idata_cache_hit ];
    IF  (hit >= 0) AND (total >= 0)
    THEN
        datacache_hitrate := ak42evalpercent_real (hit, total)
    ELSE
        datacache_hitrate := 0;
    (*ENDIF*) 
    datacache_oms_hitrate := 0;
    datacache_oms_log_hitrate := 0;
    total := info.reference_array[ idata_obj_cache_total ];
    hit   := info.reference_array[ idata_obj_cache_hit ];
    IF  (hit >= 0) AND (total >= 0)
    THEN
        datacache_oms_hitrate := ak42evalpercent_real (hit, total);
    (*ENDIF*) 
    total := info.reference_array[ idata_obj_log_cache_total ];
    hit   := info.reference_array[ idata_obj_log_cache_hit ];
    IF  (hit >= 0) AND (total >= 0)
    THEN
        datacache_oms_log_hitrate := ak42evalpercent_real (hit, total);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42dbm_state (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob);
 
VAR
      autosave_on               : boolean;
      really_bad                : boolean;
      datacache_hitrate         : tsp00_Int4;
      datacache_oms_hitrate     : tsp00_Int4;
      datacache_oms_log_hitrate : tsp00_Int4;
      cnt                       : tsp00_Int4;
      devno                     : tsp00_Int4;
      dev_type                  : tsp2_dev_type;
      devname                   : tsp2_devname;
      yes_no                    : ARRAY[boolean] OF tsp00_C3;
      on_off                    : ARRAY[boolean] OF tsp00_C3;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    yes_no[true]  := 'Yes';
    yes_no[false] := 'No ';
    on_off[true]  := 'On ';
    on_off[false] := 'Off';
    a40move_i4    (acv, a41v, bd999GetPageSize DIV 1024, NOT c_null, 0, NOT c_to_undef);
    a40move_i4    (acv, a41v, g01maxuser,            NOT c_null, 0, NOT c_to_undef);
    (* PTS 1115090 E.Z. *)
    a40move_i4    (acv, a41v, vconnectedusertasks,
          NOT c_null, 0, NOT c_to_undef);
    ak42datacache_hits (acv, datacache_hitrate,
          datacache_oms_hitrate, datacache_oms_log_hitrate);
    a40move_i4    (acv, a41v, datacache_hitrate, NOT c_null, 0, NOT c_to_undef);
    a40move_const (acv, a41v, @yes_no [b01db_full(acv.a_transinf.tri_trans.trTaskId_gg00)], 3);
    a40move_const (acv, a41v, @yes_no [b01connect_allowed], 3);
    a40move_const (acv, a41v, @on_off [a01diag_monitor_on], 3);
    a40move_const (acv, a41v, @on_off [c_monitor_on], 3);
    a40move_const (acv, a41v, @on_off [g01vtrace.vtrAny_gg00], 3);
    autosave_on := k38is_on_autosave (acv.a_transinf.tri_trans, false);
    a40move_const (acv, a41v, @on_off [autosave_on], 3);
    a40move_i4    (acv, a41v, b01get_bad_index_cnt, NOT c_null, 0, NOT c_to_undef);
    a40move_const (acv, a41v, @yes_no
          [kb560LogIsFull], 3);
    cnt := 0;
    dev_type := sp2dt_log;
    devno    := 1;
    WHILE dev_type <> sp2dt_trace DO
        BEGIN
        b01next_bad_dev (dev_type, devno, devname, really_bad);
        IF  devname <> b01blankfilename
        THEN
            IF  really_bad
            THEN
                cnt := succ(cnt);
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    a40move_i4        (acv, a41v, cnt, NOT c_null, 0, NOT c_to_undef);
    a40move_i4        (acv, a41v, datacache_oms_hitrate, NOT c_null, 0, NOT c_to_undef);
    a40move_i4        (acv, a41v, datacache_oms_log_hitrate, NOT c_null, 0, NOT c_to_undef);
    END;
(*ENDIF*) 
END;
 
(* PTS 1113491 *)
(*------------------------------*) 
 
PROCEDURE
      ak42HeapContent (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob);
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    ak341MonitorHeapContent(acv, a41v);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42history_info (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob);
 
VAR
      HistFileNo       : tsp00_Int4;
      FirstTransId     : tgg91_TransNo;
      FirstTransIsUsed : boolean;
      LastTransId      : tgg91_TransNo;
      LastTransIsUsed  : boolean;
      PageCount        : tsp00_Int4;
      bFileIsEmpty     : boolean;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  acv.a_returncode = 0
THEN
    BEGIN
    HistFileNo := 0;
    REPEAT
        kb560GetHistFileInfo (acv.a_transinf.tri_trans, HistFileNo,
              FirstTransId, FirstTransIsUsed,
              LastTransId, LastTransIsUsed,
              PageCount, bFileIsEmpty);
        IF  (acv.a_transinf.tri_trans.trError_gg00 = e_ok) AND (HistFileNo >= 0)
        THEN
            BEGIN
            a40move_i4        (acv, a41v, HistFileNo-1, NOT c_null, 0, NOT c_to_undef);
            (* PTS 1112272 E.Z. *)
            a42move_trans_no (acv, a41v, FirstTransId);
            a40move_const     (acv, a41v, @a40yes_no [FirstTransIsUsed], 3);
            a42move_trans_no (acv, a41v, LastTransId);
            a40move_const     (acv, a41v, @a40yes_no [LastTransIsUsed], 3);
            a40move_i4        (acv, a41v, PageCount, NOT c_null, 0, NOT c_to_undef);
            a40move_const     (acv, a41v, @a40yes_no [bFileIsEmpty], 3);
            END;
        (*ENDIF*) 
    UNTIL
        (HistFileNo < 0) OR (acv.a_transinf.tri_trans.trError_gg00 <> e_ok);
    (*ENDREPEAT*) 
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42monitor_object(
            VAR acv   : tak_all_command_glob;
            kw_index  : integer);
 
BEGIN
ak341StartStopMonitor(kw_index = cak_i_on)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42monitor_show (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob);
 
VAR
      ind           : tgg00_RefInfoIndex;
      info          : tgg00_ReferenceInfo;
 
BEGIN
WITH acv, a41v, info DO
    BEGIN
    a4sh_kind := sh_st_monitor;
    a40get_catalog_table (acv, a41v);
    IF  (a_ex_kind <> only_parsing) AND
        (a_returncode = 0)
    THEN
        BEGIN
        ak42get_refinfo (acv, info);
        FOR ind := idata_cache_total TO idata_obj_log_cache_percent DO
            ak42out_monitor (acv, a41v, info, ind);
        (*ENDFOR*) 
        FOR ind := idata_history_cache_total TO idata_history_cache_percent DO
            ak42out_monitor (acv, a41v, info, ind);
        (*ENDFOR*) 
        FOR ind := isql_commands TO ijoin_op_improved DO
            ak42out_monitor (acv, a41v, info, ind);
        (*ENDFOR*) 
        FOR ind := iavg_lock_used TO ikb_calls DO
            ak42out_monitor (acv, a41v, info, ind);
        (*ENDFOR*) 
        a4ti := cak_i_object;
        a42ref_stat_real (acv, a41v,
              'OMS version unloads                     ', ak341GetOmsUnloadedVersions * 1.0);
        a4ti := cak_i_trim;
        a101_QueryRewrite_MonitorOut(acv, a41v);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42_monitor_init (process_id : tsp00_TaskId);
 
BEGIN
(*========== show monitor caches ===============*)
a42monitor_arr[ idata_cache_total ] :=
      'Data cache accesses                     ';
a42monitor_arr[ idata_cache_hit ] :=
      'Data cache accesses successful          ';
a42monitor_arr[ idata_cache_miss ] :=
      'Data cache accesses unsuccessful        ';
a42monitor_arr[ idata_cache_percent ] :=
      'Data cache hit rate (%)                 ';
(* PTS 1103735 E.Z. *)
(* PTS 1111134 E.Z. *)
(* PTS 1105315 E.Z. *)
(* PTS 1115020 E.Z. *)
a42monitor_arr[ iak_cache_total ] :=
      'Catalog cache accesses                  ';
a42monitor_arr[ iak_cache_hit ] :=
      'Catalog cache accesses successful       ';
a42monitor_arr[ iak_cache_miss ] :=
      'Catalog cache accesses unsuccessful     ';
a42monitor_arr[ iak_cache_percent ] :=
      'Catalog cache hit rate (%)              ';
a42monitor_arr[ isseq_cache_total ] :=
      'Sequence cache accesses                 ';
a42monitor_arr[ isseq_cache_hit ] :=
      'Sequence cache accesses successful      ';
a42monitor_arr[isseq_cache_miss] :=
      'Sequence cache accesses unsuccessful    ';
a42monitor_arr[isseq_cache_percent] :=
      'Sequence cache hit rate (%)             ';
(* PTS 1109469 *)
a42monitor_arr[idata_sql_cache_total] :=
      'Data cache sqlpage accesses             ';
a42monitor_arr[idata_sql_cache_hit]  :=
      'Data cache sqlpage accesses successful  ';
a42monitor_arr[idata_sql_cache_miss] :=
      'Data cache sqlpage accesses unsuccessful';
a42monitor_arr[idata_sql_cache_percent] :=
      'Data cache sqlpage hit rate(%)          ';
(* END PTS 1109469 *)
(* PTS 1115043 E.Z. *)
a42monitor_arr[idata_obj_cache_total] :=
      'Data cache OMS accesses                 ';
a42monitor_arr[idata_obj_cache_hit] :=
      'Data cache OMS accesses successful      ';
a42monitor_arr[idata_obj_cache_miss] :=
      'Data cache OMS accesses unsuccessful    ';
a42monitor_arr[idata_obj_cache_percent] :=
      'Data cache OMS hit rate (%)             ';
a42monitor_arr[idata_obj_log_cache_total] :=
      'Data cache OMS log accesses             ';
a42monitor_arr[idata_obj_log_cache_hit] :=
      'Data cache OMS log accesses successful  ';
a42monitor_arr[idata_obj_log_cache_miss] :=
      'Data cache OMS log accesses unsuccessful';
a42monitor_arr[idata_obj_log_cache_percent] :=
      'Data cache OMS log hit rate (%)         ';
(* PTS 1106423 TS 2000-04-20 *)
(* PTS 1111572 E.Z. *)
a42monitor_arr[idata_history_cache_total] :=
      'Data history/undo accesses              ';
a42monitor_arr[idata_history_cache_hit] :=
      'Data history/undo accesses successful   ';
a42monitor_arr[idata_history_cache_miss] :=
      'Data history/undo accesses unsuccessful ';
a42monitor_arr[idata_history_cache_percent] :=
      'Data history/undo hit rate (%)          ';
(* PTS 1106423 *)
(* PTS 1103735 E.Z. *)
(* PTS 1111134 E.Z. *)
(*========== show monitor load =================*)
a42monitor_arr[ isql_commands ] :=
      'SQL commands                            ';
a42monitor_arr[ iprepares ] :=
      'PREPAREs                                ';
(* PTS 1105779 E.Z. *)
a42monitor_arr[ iprepares_again ] :=
      'PREPAREs repeated                       ';
a42monitor_arr[ iexecutes ] :=
      'EXECUTEs                                ';
a42monitor_arr[ icommits ] :=
      'COMMITs                                 ';
a42monitor_arr[ irollbacks ] :=
      'ROLLBACKs                               ';
a42monitor_arr[ ilocks ] :=
      'LOCKs and UNLOCKs                       ';
a42monitor_arr[ ibegin_subtrans ] :=
      'SUBTRANS BEGINs                         ';
a42monitor_arr[ iend_subtrans ] :=
      'SUBTRANS ENDs                           ';
a42monitor_arr[ irollback_subtrans ] :=
      'SUBTRANS ROLLBACKs                      ';
a42monitor_arr[ icreates ] :=
      'CREATEs                                 ';
a42monitor_arr[ ialters ] :=
      'ALTERs                                  ';
a42monitor_arr[ idrops ] :=
      'DROPs                                   ';
a42monitor_arr[ iselects ] :=
      'SELECTs and FETCHes                     ';
a42monitor_arr[ iselects_rows_read ] :=
      'SELECTs and FETCHes, rows read          ';
a42monitor_arr[ iselects_rows_qual ] :=
      'SELECTs and FETCHes, rows qual          ';
a42monitor_arr[ iinserts ] :=
      'INSERTs                                 ';
a42monitor_arr[ iinserts_rows ] :=
      'INSERTs, rows inserted                  ';
a42monitor_arr[ iupdates ] :=
      'UPDATEs                                 ';
a42monitor_arr[ iupdates_rows_read ] :=
      'UPDATEs, rows read                      ';
a42monitor_arr[ iupdates_rows_upd ] :=
      'UPDATEs, rows updated                   ';
a42monitor_arr[ ideletes ] :=
      'DELETEs                                 ';
a42monitor_arr[ ideletes_rows_read ] :=
      'DELETEs, rows read                      ';
a42monitor_arr[ ideletes_rows_del ] :=
      'DELETEs, rows deleted                   ';
(* PTS 1103033 E.Z. *)
a42monitor_arr[ iinternal_dbproc_calls ] :=
      'Internal DBPROC calls                   ';
a42monitor_arr[ iexternal_dbproc_calls ] :=
      'External DBPROC calls                   ';
a42monitor_arr[ iinternal_trigger_calls ] :=
      'Internal trigger calls                  ';
a42monitor_arr[ iexternal_trigger_calls ] :=
      'External trigger calls                  ';
a42monitor_arr[ iprim_key ] :=
      'Primary key accesses                    ';
a42monitor_arr[ iprim_key_in ] :=
      'Primary key accesses (IN strategy)      ';
a42monitor_arr[ iprim_key_subq ] :=
      'Primary key accesses (SUBQ strategy)    ';
a42monitor_arr[ iprim_key_read ] :=
      'Primary key accesses, rows read         ';
a42monitor_arr[ iprim_key_qual ] :=
      'Primary key accesses, rows qual         ';
a42monitor_arr[ iprim_key_range ] :=
      'Primary key range accesses              ';
a42monitor_arr[ iprim_read_key_range ] :=
      'Primary key range accesses, rows read   ';
a42monitor_arr[ iprim_qual_key_range ] :=
      'Primary key range accesses, rows qual   ';
a42monitor_arr[ iindex ] :=
      'Index accesses                          ';
a42monitor_arr[ iindex_in ] :=
      'Index accesses (IN strategy)            ';
a42monitor_arr[ iindex_subq ] :=
      'Index accesses (SUBQ strategy)          ';
a42monitor_arr[ iindex_scan ] :=
      'Index scan                              ';
a42monitor_arr[ iindex_read ] :=
      'Index accesses, rows read               ';
a42monitor_arr[ iindex_qual ] :=
      'Index accesses, rows qual               ';
a42monitor_arr[ iindex_range ] :=
      'Index range accesses                    ';
a42monitor_arr[ iindex_range_read ] :=
      'Index range accesses, rows read         ';
a42monitor_arr[ iindex_range_qual ] :=
      'Index range accesses, rows qual         ';
a42monitor_arr[ iis_index ] :=
      'Isolated index accesses                 ';
a42monitor_arr[ iis_index_in ] :=
      'Isolated index accesses (IN strategy)   ';
a42monitor_arr[ iis_index_subq ] :=
      'Isolated index accesses (SUBQ strategy) ';
a42monitor_arr[ iis_index_read ] :=
      'Isolated index accesses, rows read      ';
a42monitor_arr[ iis_index_qual ] :=
      'Isolated index accesses, rows qual      ';
a42monitor_arr[ iis_index_range ] :=
      'Isolated index range accesses           ';
a42monitor_arr[ iis_index_read_range ] :=
      'Isolated index range accesses, rows read';
a42monitor_arr[ iis_index_qual_range ] :=
      'Isolated index range accesses, rows qual';
a42monitor_arr[ itable_scan ] :=
      'Table scans                             ';
a42monitor_arr[ itable_scan_read ] :=
      'Table scans, rows read                  ';
a42monitor_arr[ itable_scan_qual ] :=
      'Table scans, rows qual                  ';
a42monitor_arr[ iis_index_scan ] :=
      'Isolated index scans                    ';
a42monitor_arr[ iis_index_scan_read ] :=
      'Isolated index scans, rows read         ';
a42monitor_arr[ iis_index_scan_qual ] :=
      'Isolated index scans, rows qual         ';
a42monitor_arr[ imem_sorts ] :=
      'Memory sorts / sort&merge               ';
a42monitor_arr[ imem_sorts_rows_read ] :=
      'Memory sorts / sort&merge, rows read    ';
a42monitor_arr[ iins_sorts ] :=
      'Sorts by insertion                      ';
a42monitor_arr[ iins_sorts_rows_ins ] :=
      'Sorts by insertion, rows inserted       ';
a42monitor_arr[ ijoin_hash ] :=
      'Join via Hash                           ';
a42monitor_arr[ ijoin_parallel ] :=
      'Join via parallel index read            ';
a42monitor_arr[ ijoin_legacy ] :=
      'Join via standard algorithm             ';
a42monitor_arr[ ijoin_op_normal ] :=
      'Join via operator join                  ';
a42monitor_arr[ ijoin_op_improved ] :=
      'Join via improved operator join         ';
(*========== show monitor lock =================*)
a42monitor_arr[ iavg_lock_used ] :=
      'Lock list avg used entries              ';
a42monitor_arr[ imax_lock_used ] :=
      'Lock list max used entries              ';
a42monitor_arr[ icollisions ] :=
      'Lock list collisions                    ';
a42monitor_arr[ iescalations ] :=
      'Lock list escalations                   ';
a42monitor_arr[ inew_rows ] :=
      'Lock list inserted row   entries        ';
a42monitor_arr[ inew_tabs ] :=
      'Lock list inserted table entries        ';
(* PTS 1103033 E.Z. *)
a42monitor_arr[ ideadlocks ] :=
      'Detected deadlocks                      ';
a42monitor_arr[ irequest_timeouts ] :=
      'Request timeouts                        ';
(*========== show monitor log ==================*)
a42monitor_arr[ iread_log ] :=
      'Log page physical reads                 ';
a42monitor_arr[ iwrite_log ] :=
      'Log page physical writes                ';
a42monitor_arr[ ilog_queue_size ] :=
      'Log queue pages                         ';
a42monitor_arr[ imaxqueue_used ] :=
      'Log queue max used pages                ';
a42monitor_arr[ icount_insert ] :=
      'Log queue inserts                       ';
a42monitor_arr[ icount_request ] :=
      'Log queue overflows                     ';
a42monitor_arr[ icount_group ] :=
      'Log queue group commits                 ';
a42monitor_arr[ icount_wait ] :=
      'Log queue waits for log page write      ';
a42monitor_arr[ imaxwait_logpage ] :=
      'Log queue max waits per log page        ';
a42monitor_arr[ iavg_sum_pagewaits ] :=
      'Log queue avg waits per log page        ';
(*========== show monitor long =================*)
a42monitor_arr[ iread_string ] :=
      'BD read   LONG                          ';
a42monitor_arr[ iwrite_string ] :=
      'BD write  LONG                          ';
(* PTS 1103033 E.Z. *)
(*========== show monitor pages ================*)
a42monitor_arr[ ir_v_acc ] :=
      'Virtual  reads                          ';
a42monitor_arr[ iw_v_acc ] :=
      'Virtual  writes                         ';
a42monitor_arr[ ir_p_acc ] :=
      'Physical reads                          ';
a42monitor_arr[ iw_p_acc ] :=
      'Physical writes                         ';
a42monitor_arr[ icatalog_r_v ] :=
      'Catalog        virtual  reads           ';
a42monitor_arr[ icatalog_w_v ] :=
      'Catalog        virtual  writes          ';
a42monitor_arr[ icatalog_r_p ] :=
      'Catalog        physical reads           ';
a42monitor_arr[ icatalog_w_p ] :=
      'Catalog        physical writes          ';
(* PTS 1115043 E.Z. *)
a42monitor_arr[ iperm_r_v ] :=
      'Perm page      virtual  reads           ';
a42monitor_arr[ iperm_w_v ] :=
      'Perm page      virtual  writes          ';
a42monitor_arr[ iperm_r_p ] :=
      'Perm page      physical reads           ';
a42monitor_arr[ iperm_w_p ] :=
      'Perm page      physical writes          ';
a42monitor_arr[ itemp_r_v ] :=
      'Temp page      virtual  reads           ';
a42monitor_arr[ itemp_w_v ] :=
      'Temp page      virtual  writes          ';
a42monitor_arr[ itemp_r_p ] :=
      'Temp page      physical reads           ';
a42monitor_arr[ itemp_w_p ] :=
      'Temp page      physical writes          ';
(* PTS 1103033 E.Z. *)
a42monitor_arr[ ibstr_r_v ] :=
      'LONG page      virtual  reads           ';
a42monitor_arr[ ibstr_w_v ] :=
      'LONG page      virtual  writes          ';
a42monitor_arr[ ibstr_r_p ] :=
      'LONG page      physical reads           ';
a42monitor_arr[ ibstr_w_p ] :=
      'LONG page      physical writes          ';
a42monitor_arr[ ilevel0_r_v ] :=
      'Leaf page      virtual  reads           ';
a42monitor_arr[ ilevel0_w_v ] :=
      'Leaf page      virtual  writes          ';
a42monitor_arr[ ilevel0_r_p ] :=
      'Leaf page      physical reads           ';
a42monitor_arr[ ilevel0_w_p ] :=
      'Leaf page      physical writes          ';
a42monitor_arr[ ilevel1_r_v ] :=
      'Level1 page    virtual  reads           ';
a42monitor_arr[ ilevel1_w_v ] :=
      'Level1 page    virtual  writes          ';
a42monitor_arr[ ilevel1_r_p ] :=
      'Level1 page    physical reads           ';
a42monitor_arr[ ilevel1_w_p ] :=
      'Level1 page    physical writes          ';
a42monitor_arr[ ilevel2_r_v ] :=
      'Level2 page    virtual  reads           ';
a42monitor_arr[ ilevel2_w_v ] :=
      'Level2 page    virtual  writes          ';
a42monitor_arr[ ilevel2_r_p ] :=
      'Level2 page    physical reads           ';
a42monitor_arr[ ilevel2_w_p ] :=
      'Level2 page    physical writes          ';
a42monitor_arr[ ilevel3_r_v ] :=
      'Level3 page    virtual  reads           ';
a42monitor_arr[ ilevel3_w_v ] :=
      'Level3 page    virtual  writes          ';
a42monitor_arr[ ilevel3_r_p ] :=
      'Level3 page    physical reads           ';
a42monitor_arr[ ilevel3_w_p ] :=
      'Level3 page    physical writes          ';
a42monitor_arr[ ilevel4_r_v ] :=
      'Level4 page    virtual  reads           ';
a42monitor_arr[ ilevel4_w_v ] :=
      'Level4 page    virtual  writes          ';
a42monitor_arr[ ilevel4_r_p ] :=
      'Level4 page    physical reads           ';
a42monitor_arr[ ilevel4_w_p ] :=
      'Level4 page    physical writes          ';
a42monitor_arr[ ilevel5_r_v ] :=
      'Level5 page    virtual  reads           ';
a42monitor_arr[ ilevel5_w_v ] :=
      'Level5 page    virtual  writes          ';
a42monitor_arr[ ilevel5_r_p ] :=
      'Level5 page    physical reads           ';
a42monitor_arr[ ilevel5_w_p ] :=
      'Level5 page    physical writes          ';
a42monitor_arr[ ipsm_r_v ] :=
      'Converter page virtual  reads           ';
a42monitor_arr[ ipsm_w_v ] :=
      'Converter page virtual  writes          ';
a42monitor_arr[ ipsm_r_p ] :=
      'Converter page physical reads           ';
a42monitor_arr[ ipsm_w_p ] :=
      'Converter page physical writes          ';
(*========== show monitor row ==================*)
a42monitor_arr[ iadd_rec ] :=
      'BD add  record perm                     ';
a42monitor_arr[ icadd_rec ] :=
      'BD add  record temp                     ';
a42monitor_arr[ irepl_rec ] :=
      'BD repl record perm                     ';
a42monitor_arr[ icrepl_rec ] :=
      'BD repl record temp                     ';
a42monitor_arr[ idel_rec ] :=
      'BD del  record perm                     ';
a42monitor_arr[ icdel_rec ] :=
      'BD del  record temp                     ';
a42monitor_arr[ iget_rec ] :=
      'BD get  record perm                     ';
a42monitor_arr[ icget_rec ] :=
      'BD get  record temp                     ';
a42monitor_arr[ inext_rec ] :=
      'BD next record perm                     ';
a42monitor_arr[ icnext_rec ] :=
      'BD next record temp                     ';
a42monitor_arr[ iprev_rec ] :=
      'BD prev record perm                     ';
a42monitor_arr[ icprev_rec ] :=
      'BD prev record temp                     ';
a42monitor_arr[ isel_direc ] :=
      'BD select direct record                 ';
a42monitor_arr[ isel_next ] :=
      'BD select next   record                 ';
a42monitor_arr[ isel_prev ] :=
      'BD select prev   record                 ';
a42monitor_arr[ iadd_inv ] :=
      'BD add to   index list perm             ';
a42monitor_arr[ icadd_inv ] :=
      'BD add to   index list temp             ';
a42monitor_arr[ idel_inv ] :=
      'BD del from index list perm             ';
a42monitor_arr[ icdel_inv ] :=
      'BD del from index list temp             ';
a42monitor_arr[ iget_inv ] :=
      'BD get      index list perm             ';
a42monitor_arr[iget_inv_parallel ] :=
      'BD get      index list perm parallel    ';
a42monitor_arr[ icget_inv ] :=
      'BD get      index list temp             ';
(* PTS 1103033 E.Z. *)
(*========== show monitor transaction ==========*)
a42monitor_arr[ ifunccount ] :=
      'SQL commands                            ';
a42monitor_arr[ itranscount ] :=
      'Write transactions                      ';
a42monitor_arr[ ikb_calls ] :=
      'KB calls                                ';
(* PTS 1115043 E.Z. *)
ak42refresh_cnt      := 0;
ak42fast_refresh_cnt := 0;
ak42init_running_cmd_list;
(* PTS 1103033 E.Z. *)
ak42monitor_init (process_id);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42monitor_oms (
            VAR acv          : tak_all_command_glob;
            VAR a41v         : tak40_show_glob;
            reset_statistics : boolean);
 
CONST
      c_sys_dispid = 5;
      c_debug      = true;
 
TYPE
 
      I386Stack = RECORD (* PTS 1107879 *)
            plong     : ^tsp00_Int4;
            pBuf      : ^tgg01_COMMonitorTransferBuf;
      END;
 
 
VAR
      handle     : tsp00_Addr;
      iid        : tsp00_C16;
      dispid     : tsp00_Int4;
      dp         : tsp_dcom_dispatch_parms;
      bufLen     : tsp00_Int4;
      buf        : tgg01_COMMonitorTransferBuf;
      stack      : ARRAY[1..2] OF tak_dbproc_stack_param_debug;
      pStack     : ^I386Stack;
      params     : tsp_dcom_monitor_parms;
 
BEGIN
(* PTS 1105440 *)
(* PTS 1107243 *)
(* &if $MACH not in [ NMP ] *)
IF  NOT reset_statistics
THEN
    BEGIN
    a40get_catalog_table (acv, a41v);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        handle := NIL;
        WHILE ak341GetMonitorInfo (acv, handle, iid, dispid, buf.ctbMonInfo_gg00) DO
            (* must be called until false is returned. Otherwise resources *)
            (* in liboms are not released !!                               *)
            ak42AggrMethodMonitorInfo (acv, iid, dispid, buf.ctbMonInfo_gg00);
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    dp.ifactory          := NIL;
    dp.session_context   := @acv;
    dp.dispid            := c_sys_dispid;
    dp.hresult           := 0;
    dp.param_stack       := @stack;
    dp.param_stack_len   := sizeof(stack);
    (*dp.debug_mode        := false; PTS 1112663 *)
    (*dp.debug_location    := NIL;   PTS 1112663 *)
    dp.errtext           := bsp_c64;
    dp.monitoring        := false;
    dp.run_in_ude_server := false;
    buf.ctbMessType_gg00 := m_diagnose;
    IF  a260BuildDebugStack(*(NOT c_debug)PTS 1112663 *) (* PTS 1107879 *)
    THEN
        BEGIN
        stack[1].dbg_value.ptr := @bufLen;
        stack[1].dbg_vt        := csp1_vt_i4;
        stack[1].dbg_inout     := sp1io_inout;
        stack[1].dbg_is_ptr    := true;
        stack[1].dbg_length    := sizeof (bufLen);
        stack[2].dbg_value.ptr := @buf;
        stack[2].dbg_vt        := csp1_vt_userdefined;
        stack[2].dbg_inout     := sp1io_inout;
        stack[2].dbg_is_ptr    := true;
        stack[2].dbg_length    := sizeof (buf);
        END
    ELSE
        BEGIN
        pStack        := @stack;
        pStack^.plong := @bufLen;
        pStack^.pBuf  := @buf;
        END;
    (*ENDIF*) 
    vdcom_monitor_open (params);
    REPEAT
        IF  params.retcode = 0
        THEN
            BEGIN
            dp.idispatch  := params.idispatch;
            IF  reset_statistics
            THEN
                buf.ctbDispId_gg00 := -1
            ELSE
                buf.ctbDispId_gg00 := 0;
            (*ENDIF*) 
            REPEAT
                bufLen := sizeof(buf) - sizeof (buf.ctbMonInfo_gg00);
                vdcom_dbproc (dp);
                IF  NOT reset_statistics AND (buf.ctbDispId_gg00 >= 0) AND (bufLen > 0)
                THEN
                    ak42AggrMethodMonitorInfo (acv, params.iid, buf.ctbDispId_gg00, buf.ctbMonInfo_gg00);
                (*ENDIF*) 
                IF  buf.ctbDispId_gg00 >= 0
                THEN
                    buf.ctbDispId_gg00 := buf.ctbDispId_gg00 + 1
                (*ENDIF*) 
            UNTIL
                (buf.ctbDispId_gg00 < 0) OR reset_statistics OR (dp.hresult <> 0);
            (*ENDREPEAT*) 
            vdcom_monitor_next (params);
            IF  dp.hresult <> 0
            THEN
                a07ak_system_error (acv, 42, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        params.retcode <> 0;
    (*ENDREPEAT*) 
    vdcom_monitor_close (params);
    IF  reset_statistics
    THEN
        ak341ResetMonitor(acv)
    ELSE
        BEGIN
        ak42MonitorOmsBuildUserResult(acv, a41v);
        b01empty_file (acv.a_transinf.tri_trans, acv.a_into_tree)
        END;
    (*ENDIF*) 
    END
(* PTS 1105440 *)
(* PTS 1107243 *)
(* &endif*)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42AggrMethodMonitorInfo (
            VAR acv     : tak_all_command_glob;
            VAR iid     : tsp00_C16;
            VAR dispid  : integer;
            VAR monInfo : tgg01_COMMonitorInfo);
 
VAR
      exitLoop    : boolean;
      monEnum     : tgg01_COMMonEnum;
      key         : tak42_monitor_rec_key;
      monitor_rec : tak42_oms_monitor_rec;
 
BEGIN
key.iid              := iid;
key.dispid           := dispid;
key.lkey.keyLen_gg00 := sizeof(key.iid) + sizeof(key.dispid);
b07cget_record (acv.a_transinf.tri_trans, acv.a_into_tree,
      key.lkey, monitor_rec.rec);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found
THEN
    BEGIN
    monitor_rec.rec.recLen_gg00    :=
          sizeof(monitor_rec.offset) +
          sizeof(monitor_rec.iid)    +
          sizeof(monitor_rec.dispid) +
          sizeof(monitor_rec.filler) +
          sizeof(monitor_rec.info);
    monitor_rec.rec.recKeyLen_gg00 := sizeof(monitor_rec.iid) +
          sizeof(monitor_rec.dispid);
    monitor_rec.rec.recVarcolOffset_gg00 := 0;
    monitor_rec.rec.recVarcolCnt_gg00    := 0;
    monitor_rec.iid    := iid;
    monitor_rec.dispid := dispid;
    monitor_rec.info   := monInfo;
    b07cadd_record (acv.a_transinf.tri_trans, acv.a_into_tree, monitor_rec.rec);
    END
ELSE
    BEGIN
    monEnum  := cmiRunTime;
    exitLoop := false;
    WHILE NOT exitLoop DO
        BEGIN
        CASE monEnum OF
            cmiRunTimeMin, cmiMinWaitNewConsView, cmiMallocMin, cmiFreeMin, cmiDeltaMin,
            cmiMinReadApplCallbacks, cmiMinStreamRowsRead, cmiMinWriteApplCallbacks,
            cmiMinStreamRowsWrite :
                BEGIN
                IF  monInfo.cmiCounters_gg00[monEnum] <
                    monitor_rec.info.cmiCounters_gg00[monEnum]
                THEN
                    monitor_rec.info.cmiCounters_gg00[monEnum] :=
                          monInfo.cmiCounters_gg00[monEnum]
                (*ENDIF*) 
                END;
            cmiRunTimeMax, cmiMaxSubtransLevel,cmiMaxWaitNewConsView,
            cmiMallocMax,  cmiFreeMax, cmiCacheSize, cmiDeltaMax,
            cmiMaxReadApplCallbacks, cmiMaxStreamRowsRead, cmiMaxWriteApplCallbacks,
            cmiMaxStreamRowsWrite :
                BEGIN
                IF  monInfo.cmiCounters_gg00[monEnum] >
                    monitor_rec.info.cmiCounters_gg00[monEnum]
                THEN
                    monitor_rec.info.cmiCounters_gg00[monEnum] :=
                          monInfo.cmiCounters_gg00[monEnum]
                (*ENDIF*) 
                END;
            cmiDeltaAvg :
                BEGIN
                monitor_rec.info.cmiCounters_gg00[cmiDeltaAvg] :=
                      (monitor_rec.info.cmiCounters_gg00[cmiDeltaAvg] * monitor_rec.info.cmiCallCnt_gg00 +
                      monInfo.cmiCounters_gg00[cmiDeltaAvg] * monInfo.cmiCallCnt_gg00)
                      / (monitor_rec.info.cmiCallCnt_gg00 + monInfo.cmiCallCnt_gg00);
                END;
            OTHERWISE
                monitor_rec.info.cmiCounters_gg00[monEnum] :=
                      monitor_rec.info.cmiCounters_gg00[monEnum] +
                      monInfo.cmiCounters_gg00[monEnum];
            END;
        (*ENDCASE*) 
        IF  monEnum < cmiCacheSize
        THEN (* PTS 1107850 *)
            monEnum := succ(monEnum)
        ELSE
            exitLoop := true;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    monitor_rec.info.cmiCallCnt_gg00 := monitor_rec.info.cmiCallCnt_gg00 + monInfo.cmiCallCnt_gg00;
    b07crepl_record (acv.a_transinf.tri_trans, acv.a_into_tree, monitor_rec.rec);
    END;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42MonitorOmsBuildUserResult(
            VAR acv          : tak_all_command_glob;
            VAR a41v         : tak40_show_glob);
 
VAR
      monEnum     : tgg01_COMMonEnum;
      b_err       : tgg00_BasisError;
      avgReal     : real;
      avg         : tsp00_8ByteCounter;
      monitor_rec : tak42_oms_monitor_rec;
      set_result  : tgg00_BdSetResultRecord;
      tree_pos    : tgg00_FilePos;
      zerokey     : ^tgg00_Lkey;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    WITH set_result DO
        BEGIN
        bd_key_check_len:= 0;
        bd_max_rec_cnt  := 1;
        bd_max_fill_len := sizeof (monitor_rec);
        bd_next         := true;
        END;
    (*ENDWITH*) 
    zerokey              := @monitor_rec;
    zerokey^.len         := 0;
    tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
    REPEAT
        b07cnext_record (acv.a_transinf.tri_trans,  acv.a_into_tree,
              zerokey^, set_result, tree_pos, monitor_rec.rec.recBuf_gg00);
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  (b_err = e_ok) OR (b_err = e_key_not_found)
        THEN
            BEGIN
            b_err := e_ok;
            a40move_guid (acv, a41v, monitor_rec.iid);
            a40move_i4    (acv, a41v,
                  monitor_rec.dispid, NOT c_null, 0, NOT c_to_undef);
            a40move       (acv, a41v, @monitor_rec.info.cmiMethodName_gg00,
                  sizeof (monitor_rec.info.cmiMethodName_gg00));
            a40move_counter (acv, a41v,
                  monitor_rec.info.cmiCallCnt_gg00, NOT c_null, 0, NOT c_to_undef);
            monEnum := cmiRunTime;
            WHILE monEnum < cmiCacheSize DO
                BEGIN
                IF  monEnum = cmiWaitOmsLockObjSecs
                THEN
                    BEGIN
                    IF  monitor_rec.info.cmiCounters_gg00[pred(monEnum)] > 0
                    THEN
                        BEGIN
                        avg := trunc(monitor_rec.info.cmiCounters_gg00[monEnum] /
                              monitor_rec.info.cmiCounters_gg00[pred(monEnum)]);
                        a40move_counter (acv, a41v, avg, NOT c_null, 0, NOT c_to_undef);
                        END
                    ELSE
                        a40move (acv, a41v, NIL, 0);
                    (*ENDIF*) 
                    END
                ELSE
                    IF  monEnum = cmiHashSumChainAccessed
                    THEN
                        BEGIN
                        IF  monitor_rec.info.cmiCounters_gg00[succ(monEnum)] > 0
                        THEN
                            BEGIN
                            avgReal := monitor_rec.info.cmiCounters_gg00[monEnum] /
                                  monitor_rec.info.cmiCounters_gg00[succ(monEnum)];
                            a40move_real  (acv, a41v, avgReal, NOT c_null, 2);
                            END
                        ELSE
                            a40move (acv, a41v, NIL, 0);
                        (*ENDIF*) 
                        monEnum := succ(monEnum)
                        END
                    ELSE
                        IF  monEnum in [cmiSumVarObjSize, cmiSumWaitNewConsView]
                        THEN
                            BEGIN
                            IF  monitor_rec.info.cmiCounters_gg00[succ(monEnum)] > 0
                            THEN
                                BEGIN
                                avg := trunc(monitor_rec.info.cmiCounters_gg00[monEnum] /
                                      monitor_rec.info.cmiCounters_gg00[succ(monEnum)]);
                                a40move_counter (acv, a41v, avg, NOT c_null, 0, NOT c_to_undef);
                                END
                            ELSE
                                a40move (acv, a41v, NIL, 0);
                            (*ENDIF*) 
                            monEnum := succ(monEnum)
                            END
                        ELSE
                            IF  monEnum in [cmiSumReadApplCallbacks, cmiSumStreamRowsRead,
                                cmiSumWriteApplCallbacks, cmiSumStreamRowsWrite]
                            THEN
                                BEGIN
                                IF  monitor_rec.info.cmiCallCnt_gg00 > 0
                                THEN
                                    BEGIN
                                    avg := trunc(monitor_rec.info.cmiCounters_gg00[monEnum] /
                                          monitor_rec.info.cmiCallCnt_gg00);
                                    a40move_counter (acv, a41v, avg, NOT c_null, 0, NOT c_to_undef);
                                    END
                                ELSE
                                    a40move (acv, a41v, NIL, 0);
                                (*ENDIF*) 
                                END
                            ELSE
                                a40move_counter (acv, a41v,
                                      monitor_rec.info.cmiCounters_gg00[monEnum],
                                      monitor_rec.info.cmiCounters_gg00[monEnum] = csp_maxint4, 0, NOT c_to_undef);
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  monEnum < cmiCacheSize
                THEN (* PTS 1107850 *)
                    monEnum := succ(monEnum)
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            a40move_counter (acv, a41v,
                  monitor_rec.info.cmiCounters_gg00[cmiCacheSize],
                  monitor_rec.info.cmiCounters_gg00[cmiCacheSize] < 1, 0, NOT c_to_undef);
            END;
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR (acv.a_returncode <> 0);
    (*ENDREPEAT*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42ResetOmsMonitor(VAR acv : tak_all_command_glob);
 
VAR
      a41v : tak40_show_glob;
 
BEGIN
ak42monitor_oms (acv, a41v, c_reset_statistics)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42init_running_cmd_list;
 
VAR
      alloc_sum  : tsp00_Int4;
 
BEGIN
alloc_sum := g01maxuser * sizeof (tak_parsid);
a42parseid_list := a101_RTEMemAllocate (alloc_sum);
IF  a42parseid_list <> NIL
THEN
    SAPDB_PascalForcedFill (alloc_sum, @a42parseid_list^, 1,
          alloc_sum, csp_defined_byte);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42put_running_cmds (
            VAR acv    : tak_all_command_glob;
            VAR parsid : tsp00_C12);
 
VAR
      pidpos          : integer;
      first_user_pid  : integer;
 
BEGIN
WITH acv DO
    BEGIN
    vgetfirstuserpid(first_user_pid);
    (* h.b. PTS 1104483 *)
    IF  (a_transinf.tri_trans.trTaskId_gg00 >=  first_user_pid) AND
        (a_transinf.tri_trans.trTaskId_gg00 <=
        (first_user_pid + g01maxuser))
    THEN
        BEGIN
        pidpos := ((a_transinf.tri_trans.trTaskId_gg00 - first_user_pid)
              * sizeof (parsid)) + 1;
        SAPDB_PascalMove ('VAK42 ',   2,    
              sizeof (parsid), g01maxuser * sizeof (parsid),
              @parsid, 1, @a42parseid_list^, pidpos, sizeof(parsid),
              a_returncode);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a42getparseid (
            VAR t        : tgg00_TransContext;
            VAR pid      : tsp00_TaskId;
            VAR parsid   : tsp00_C12;
            VAR b_err    : tgg00_BasisError): boolean;
 
VAR
      pidpos          : integer;
      first_user_pid  : integer;
 
BEGIN
a42getparseid := false;
vgetfirstuserpid(first_user_pid);
IF  (pid >=  first_user_pid) AND
    (pid <= (first_user_pid + g01maxuser))
THEN
    BEGIN
    pidpos := ((pid - first_user_pid) * sizeof (parsid)) + 1;
    SAPDB_PascalMove ('VAK42 ',   3,    
          g01maxuser * sizeof (parsid), sizeof (parsid),
          @a42parseid_list^, pidpos, @parsid, 1, sizeof(parsid),
          b_err);
    IF  parsid <> c_not_in_use
    THEN
        BEGIN
        parsid[11]    := chr(0);
        (* because pid_appl_info is chr(0) in SYSPARSEID *)
        a42getparseid := true;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42reset_running_cmds (VAR acv : tak_all_command_glob);
 
VAR
      pidpos          : integer;
      parsid          : tsp00_C12;
      first_user_pid  : integer;
 
BEGIN
WITH acv DO
    BEGIN
    parsid  := c_not_in_use;
    vgetfirstuserpid(first_user_pid);
    (* h.b. PTS 1104483 *)
    IF  (a_transinf.tri_trans.trTaskId_gg00 >=  first_user_pid) AND
        (a_transinf.tri_trans.trTaskId_gg00 <=
        (first_user_pid + g01maxuser))
    THEN
        BEGIN
        pidpos  := ((a_transinf.tri_trans.trTaskId_gg00 - first_user_pid)
              * sizeof (parsid)) + 1;
        SAPDB_PascalMove ('VAK42 ',   4,    
              sizeof (parsid), g01maxuser * sizeof (parsid),
              @parsid, 1, @a42parseid_list^, pidpos, sizeof(parsid),
              a_returncode);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42oms_memory (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      totalHeap         : tsp00_8ByteCounter;
      spaceInFreeChunks : tsp00_8ByteCounter;
      reserved          : tsp00_8ByteCounter;
      mallocated        : tsp00_8ByteCounter;
      emergencySize     : tsp00_8ByteCounter;
      emergencyInUse    : tsp00_8ByteCounter;
      emergencyMaxUsed  : tsp00_8ByteCounter;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    BEGIN
    ak341OmsHeapInfo(acv, totalHeap, spaceInFreeChunks, reserved, mallocated,
          emergencySize, emergencyInUse, emergencyMaxUsed);
    a40move_counter (acv, a41v, totalHeap, NOT c_null, 0, NOT c_to_undef);
    a40move_counter (acv, a41v, spaceInFreeChunks, NOT c_null, 0, NOT c_to_undef);
    a40move_counter (acv, a41v, reserved, NOT c_null, 0, NOT c_to_undef);
    a40move_counter (acv, a41v, mallocated, NOT c_null, 0, NOT c_to_undef);
    a40move_counter (acv, a41v, emergencySize, NOT c_null, 0, NOT c_to_undef);
    a40move_counter (acv, a41v, emergencyInUse, NOT c_null, 0, NOT c_to_undef);
    a40move_counter (acv, a41v, emergencyMaxUsed, NOT c_null, 0, NOT c_to_undef);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42oldOmsModes (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            oli_mode    : tsp00_C18);
 
VAR
      old_mode : tsp00_C12;
 
BEGIN
IF  oli_mode = 'LOCK SHARE        '
THEN
    old_mode := 'lock_share  '
ELSE
    IF  oli_mode = 'LOCK EXCLUSIVE    '
    THEN
        old_mode := 'lock_excl   '
    ELSE
        IF  oli_mode = 'REQUEST EXCLUSIVE '
        THEN
            old_mode := 'req_excl    '
        ELSE
            IF  oli_mode = 'REQUEST SHARE     '
            THEN
                old_mode := 'req_share   '
            ELSE
                old_mode := '            ';
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
a40move_const (acv, a41v, @old_mode, sizeof (old_mode));
END;
 
(*------------------------------*) 
 
PROCEDURE (* PTS 1110315 *)
      ak42OmsLockObjInfo (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      exitLoop : boolean;
      handle   : tsp00_Addr;
      lockInfo : tgg01_OmsLockInfo;
 
BEGIN
a40get_catalog_table (acv, a41v);
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    BEGIN
    handle   := NIL;
    exitLoop := false;
    WHILE NOT exitLoop AND ak341NextOmsLockObjInfo(handle, lockInfo) DO
        BEGIN
        a40move       (acv, a41v, @lockInfo.oli_handle, sizeof(lockInfo.oli_handle));
        a40move_i4    (acv, a41v, lockInfo.oli_taskid, NOT c_null, 0, NOT c_to_undef);
        ak42oldOmsModes (acv, a41v, lockInfo.oli_lockmode);
        ak42oldOmsModes (acv, a41v, lockInfo.oli_requestmode);
        a40move_i4    (acv, a41v, lockInfo.oli_timeout, lockInfo.oli_timeout < 0, 0, NOT c_to_undef);
        IF  handle = NIL
        THEN
            exitLoop := true;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42show_running_cmds (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      b_err     : tgg00_BasisError;
      aux_file  : tgg00_FileId;
      mblock    : tgg00_MessBlock;
      data      : tsp00_Buf;
      qual      : tgg00_QualBuf;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a40get_catalog_table (acv, a41v);
    IF  (a_returncode = 0) AND
        (a_ex_kind <> only_parsing)
    THEN
        BEGIN
        g04build_temp_tree_id (aux_file, a_transinf.tri_trans);
        a101_SetTempFileIndex (acv, aux_file, 1);
        aux_file.fileTfnTemp_gg00 := ttfnSaveScheme_egg00;
        g01mblock_init (acv.a_transinf.tri_trans, m_show, mm_running_cmds, mblock);
        g01datapart_init (mblock, @data, sizeof (data));
        g01stack_init    (mblock, NIL, 0, @qual, sizeof (qual));
        mblock.mb_qual^.mtree := aux_file;
        a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
        a101_GetTempFileInstance (acv.a_transinf.tri_trans, aux_file);
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        ELSE
            ak42add_parseid (acv, a41v, aux_file);
        (*ENDIF*) 
        a101_DestroyGroupedTempFile (a_transinf.tri_trans, aux_file);
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42add_parseid (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR tree    : tgg00_FileId);
 
VAR
      b_err        : tgg00_BasisError;
      rec_len      : tsp_int_map_c2;
      key_len      : tsp_int_map_c2;
      pos          : integer;
      set_result   : tgg00_BdSetResultRecord;
      tree_pos     : tgg00_FilePos;
      zerokey      : tgg00_Lkey;
      b            : tsp00_Buf;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    WITH set_result DO
        BEGIN
        bd_key_check_len:= 0;
        bd_max_rec_cnt  := csp_maxint2;
        bd_max_fill_len := sizeof (b);
        bd_next         := false;
        END;
    (*ENDWITH*) 
    zerokey.len          := 0;
    tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
    REPEAT
        b07cnext_record (a_transinf.tri_trans, tree,
              zerokey, set_result, tree_pos, b);
        b_err := a_transinf.tri_trans.trError_gg00;
        IF  (b_err = e_ok) OR (b_err = e_key_not_found) OR
            (b_err = e_buffer_limit)
        THEN
            BEGIN
            pos    := 1;
            WHILE pos < set_result.bd_fill_len DO
                BEGIN
                rec_len.map_c2[1] := b[pos  ];
                rec_len.map_c2[2] := b[pos+1];
                key_len.map_c2[1] := b[pos+2];
                key_len.map_c2[2] := b[pos+3];
&               ifdef trace
                t01buf (ak_sem, b, 1, rec_len.map_int);
&               endif
                a40move_i4 (acv, a41v, s20buf_to_int4 (b, pos + cgg_rec_key_offset),
                      NOT c_null, 0, NOT c_to_undef);
                a40move (acv, a41v,
                      @b[pos+cgg_rec_key_offset+key_len.map_int], mxsp_c12);
                pos := pos + rec_len.map_int
                END;
            (*ENDWHILE*) 
            IF  b_err = e_buffer_limit
            THEN
                b_err := e_ok
            ELSE
                b_err := e_no_next_record;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok) OR (a_returncode <> 0);
    (*ENDREPEAT*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1106007 *)
(*------------------------------*) 
 
PROCEDURE
      ak42consistent_view (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob);
 
VAR
      b_err        : tgg00_BasisError;
      rec_len      : tsp_int_map_c2;
      key_len      : tsp_int_map_c2;
      pos          : integer;
      set_result   : tgg00_BdSetResultRecord;
      tree_pos     : tgg00_FilePos;
      aux_file     : tgg00_FileId;
      zerokey      : tgg00_Lkey;
      b            : tsp00_Buf;
      data         : tgg00_BufLenInfo;
      qual         : tgg00_QualBuf;
      mblock       : tgg00_MessBlock;
      pShow        : ^tkb05_ConsistViewShow;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a40get_catalog_table (acv, a41v);
    IF  a_returncode = 0
    THEN
        BEGIN
        g04build_temp_tree_id (aux_file, a_transinf.tri_trans);
        b01tcreate_file (a_transinf.tri_trans, aux_file);
        IF  a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
        ELSE
            BEGIN
            g01mblock_init (acv.a_transinf.tri_trans,
                  m_show, mm_object, mblock);
            g01datapart_init (mblock, @data, sizeof (data));
            g01stack_init    (mblock, NIL, 0, @qual, sizeof (qual));
            mblock.mb_qual^.mtree := aux_file;
            a06rsend_mess_buf (acv, mblock,
                  cak_return_req, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                WITH set_result DO
                    BEGIN
                    bd_key_check_len:= 0;
                    bd_max_rec_cnt  := csp_maxint2;
                    bd_max_fill_len := sizeof (b);
                    bd_next         := false;
                    END;
                (*ENDWITH*) 
                zerokey.len          := 0;
                tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
                REPEAT
                    b07cnext_record (a_transinf.tri_trans,  aux_file,
                          zerokey, set_result, tree_pos, b);
                    b_err := a_transinf.tri_trans.trError_gg00;
                    IF  (b_err = e_ok) OR (b_err = e_key_not_found) OR
                        (b_err = e_buffer_limit)
                    THEN
                        BEGIN
                        pos  := 1;
                        WHILE pos < set_result.bd_fill_len DO
                            BEGIN
                            rec_len.map_c2[1] := b[pos  ];
                            rec_len.map_c2[2] := b[pos+1];
                            key_len.map_c2[1] := b[pos+2];
                            key_len.map_c2[2] := b[pos+3];
&                           ifdef trace
                            t01buf (ak_sem, b, 1, rec_len.map_int);
&                           endif
                            pShow := @b[pos];
                            IF  gg06IsNilTrans (pShow^.cshConsistView_kb05) (* PTS 1108234 JA 2001-01-19 *)
                            THEN
                                a40move (acv, a41v, NIL, 0)  (* undef *)
                            ELSE
                                a40move (acv, a41v, @pShow^.cshConsistView_kb05,
                                      sizeof(pShow^.cshConsistView_kb05));
                            (*ENDIF*) 
                            (* PTS 1125503 FF 2003-11-19 *)
                            a42move_trans_no (acv, a41v, pShow^.cshCreatorTrans_kb05);
                            IF  gg06IsNilTrans (pShow^.cshOpenTrans_kb05)   (* PTS 1108234 JA 2001-01-19 *)
                            THEN
                                a40move (acv, a41v, NIL, 0)  (* undef *)
                            ELSE
                                a40move (acv, a41v, @pShow^.cshOpenTrans_kb05,
                                      sizeof(pShow^.cshOpenTrans_kb05));
                            (*ENDIF*) 
                            a40put_date_time (acv, a41v, pShow^.cshStartDate_kb05,
                                  c_is_date, pShow^.cshStartDate_kb05 = 0);
                            a40put_date_time (acv, a41v, pShow^.cshStartTime_kb05,
                                  NOT c_is_date, pShow^.cshStartTime_kb05 = 0);
                            a40move_i4 (acv, a41v, pShow^.cshTimeLastUsed_kb05,
                                  NOT c_null, 0, NOT c_to_undef);
                            (* PTS 1120151 FF 2003-01-29 *)
                            a40move_const (acv, a41v, @a40yes_no [pShow^.cshCancelled_kb05], 3);
                            pos := pos + rec_len.map_int
                            END;
                        (*ENDWHILE*) 
                        IF  b_err = e_buffer_limit
                        THEN
                            b_err := e_ok
                        ELSE
                            b_err := e_no_next_record;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                UNTIL
                    (b_err <> e_ok) OR (a_returncode <> 0);
                (*ENDREPEAT*) 
                END;
            (*ENDIF*) 
            b01destroy_file (a_transinf.tri_trans, aux_file)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42roots (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      use_tree       : boolean;
      table_found    : boolean;
      b_err          : tgg00_BasisError;
      res            : tsp00_NumError;
      tree           : tgg00_FileId;
      owner          : tsp00_KnlIdentifier;
      schema         : tsp00_KnlIdentifier;
      tablen         : tsp00_KnlIdentifier;
      owner_ptr      : tsp00_MoveObjPtr;
      schema_ptr     : tsp00_MoveObjPtr;
      tablen_ptr     : tsp00_MoveObjPtr;
      indexname      : tsp00_KnlIdentifier;
      indexn_ptr     : tsp00_MoveObjPtr;
      iterator_ptr   : tsp00_Addr;
      indexn_len     : integer;
      f_type         : tsp00_C18;
      base_ptr       : tak_sysbufferaddress;
      number         : tsp00_ResNum;
      table_surr     : tgg00_Surrogate;
      index_scan_rec : tak_index_scan_record;
      _work_buf      : tak40_int2_arr_ptr;
 
BEGIN
tree := b01niltree_id;
a40get_catalog_table (acv, a41v);
bd998NewFileDirIterator (acv.a_transinf.tri_trans, iterator_ptr);
bd998AddToFileDirIteratorFilter (iterator_ptr, tfnTable_egg00);
bd998AddToFileDirIteratorFilter (iterator_ptr, tfnShortScol_egg00);
bd998AddToFileDirIteratorFilter (iterator_ptr, tfnMulti_egg00);
bd998InitFileDirIterator (acv.a_transinf.tri_trans, NOT c_showDeletedFiles,
      iterator_ptr);
a722init_epos_reccol_relation( acv, _work_buf );
REPEAT
    use_tree := false;
    bd998AdvanceFileDirIterator (
          acv.a_transinf.tri_trans, iterator_ptr, tree);
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        BEGIN
        s41p4int (number, 1, tree.fileRoot_gg00, res);
        IF  res = num_ok
        THEN
            use_tree := a722test_col_qual (acv,
                  a41v, 'ROOT              ',
                  csp_defined_byte, @number, sizeof (number), _work_buf)
        ELSE
            use_tree := true;
        (*ENDIF*) 
        acv.a_transinf.tri_trans.trError_gg00 := e_ok
        END;
    (*ENDIF*) 
    IF  use_tree
    THEN
        BEGIN
        owner_ptr  := NIL;
        schema_ptr := NIL;
        tablen_ptr := NIL;
        indexn_ptr := NIL;
        indexn_len := 0;
        IF  tree.fileTfn_gg00 in [tfnMulti_egg00,
            tfnTable_egg00, tfnShortScol_egg00]
        THEN
            BEGIN
            IF  tree.fileTfn_gg00 in [tfnTable_egg00]
            THEN
                a06_systable_get (acv, d_release, tree.fileTabId_gg00,
                      base_ptr, NOT c_get_all, table_found)
            ELSE
                BEGIN
                IF  tree.fileTfn_gg00 in [tfnMulti_egg00]
                THEN
                    BEGIN
                    bd998GetTableFileNoForIndex (
                          acv.a_transinf.tri_trans,
                          tree.fileTabId_gg00,
                          table_surr,
                          b_err);
                    a06_systable_get (acv, d_release, table_surr,
                          base_ptr, NOT c_get_all, table_found);
                    END
                ELSE
                    BEGIN (* tfnShortColumn_egg00 *)
                    bd998GetTableFileNoForShortColumn (
                          acv.a_transinf.tri_trans,
                          tree.fileTabId_gg00,
                          table_surr,
                          b_err);
                    a06_systable_get (acv, d_release, table_surr,
                          base_ptr, NOT c_get_all, table_found);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  table_found
            THEN
                BEGIN
                owner     := a01_il_b_identifier;
                schema    := a01_il_b_identifier;
                indexname := a01_il_b_identifier;
                a06determine_username (acv,
                      base_ptr^.sbase.bauthid, owner);
                a06determine_username (acv,
                      base_ptr^.sbase.bschema, schema);
                tablen := base_ptr^.sbase.btablen^;
                CASE tree.fileTfn_gg00 OF
                    tfnMulti_egg00 :
                        BEGIN
                        a24fnd_indexno (acv, table_surr,
                              ord (tree.fileTfnNo_gg00[1]),
                              index_scan_rec);
                        IF  acv.a_returncode <> 0
                        THEN (* could not read index catalog info *)
                            acv.a_returncode := 0
                        ELSE
                            WITH index_scan_rec DO
                                IF  isr_buf <> NIL
                                THEN
                                    BEGIN
                                    a24get_indexname (acv, isr_buf, isr_index,
                                          indexname);
                                    indexn_ptr := @indexname;
                                    indexn_len := sizeof (indexname)
                                    END;
                                (*ENDIF*) 
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        f_type := 'NAMED INDEX       ';
                        END;
                    tfnTable_egg00 :
                        f_type := 'TABLE             ';
                    tfnShortScol_egg00 :
                        f_type := 'SHORT STRING FILE ';
                    END;
                (*ENDCASE*) 
                owner_ptr  := @owner;
                schema_ptr := @schema;
                tablen_ptr := @tablen;
                END
            ELSE
                BEGIN
                IF  acv.a_returncode =
                    a071_return_code (e_old_fileversion, acv.a_sqlmode)
                THEN
                    acv.a_returncode := 0;
                (*ENDIF*) 
                acv.a_transinf.tri_trans.trError_gg00 := e_ok;
                CASE tree.fileTfn_gg00 OF
                    tfnMulti_egg00 :
                        BEGIN
                        f_type := 'UNKNOWN INDEX     ';
                        END;
                    tfnTable_egg00 :
                        f_type := 'UNKNOWN TABLE     ';
                    tfnShortScol_egg00 :
                        f_type := 'UNKNOWN SCOL FILE ';
                    END;
                (*ENDCASE*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            acv.a_transinf.tri_trans.trError_gg00 := e_ok;
            CASE tree.fileTfn_gg00 OF
                tfnSys_egg00 :
                    f_type := 'SYS               ';
                tfnTempMulti_egg00 :
                    f_type := 'TEMP MULTI        ';
                tfnTemp_egg00:
                    IF  a101_GetExtendedTempFileType (acv, tree)
                        = ttfnTempInv_egg00
                    THEN
                        f_type := 'TEMP INV          '
                    ELSE
                        f_type := 'TEMP              ';
                    (*ENDIF*) 
                OTHERWISE
                    f_type := 'UNKNOWN           ';
                END;
            (*ENDCASE*) 
            END;
        (*ENDIF*) 
        a40move       (acv, a41v, @tree.fileTabId_gg00, sizeof (tree.fileTabId_gg00));
        a40move       (acv, a41v, schema_ptr,  sizeof (schema));
        a40move       (acv, a41v, owner_ptr,   sizeof (owner));
        a40move       (acv, a41v, tablen_ptr,  sizeof (tablen));
        a40move       (acv, a41v, indexn_ptr,  indexn_len);
        a40move_const (acv, a41v, @f_type,     sizeof (f_type));
        a40move_i4    (acv, a41v,
              tree.fileRoot_gg00, NOT c_null, 0, NOT c_to_undef);
        END;
    (*ENDIF*) 
UNTIL
    (acv.a_transinf.tri_trans.trError_gg00 <> e_ok) OR (acv.a_returncode <> 0);
(*ENDREPEAT*) 
bd998DestroyFileDirIterator (acv.a_transinf.tri_trans, iterator_ptr);
(* iterate through blob file dir *)
tree := b01niltree_id;
REPEAT
    use_tree := false;
    b01next_fdir_entry (acv.a_transinf.tri_trans, tree);
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        BEGIN
        s41p4int (number, 1, tree.fileRoot_gg00, res);
        IF  res = num_ok
        THEN
            use_tree := a722test_col_qual (acv,
                  a41v, 'ROOT              ',
                  csp_defined_byte, @number, sizeof (number), _work_buf)
        ELSE
            use_tree := true;
        (*ENDIF*) 
        acv.a_transinf.tri_trans.trError_gg00 := e_ok
        END;
    (*ENDIF*) 
    IF  use_tree
    THEN
        BEGIN
        owner_ptr  := NIL;
        schema_ptr := NIL;
        tablen_ptr := NIL;
        indexn_ptr := NIL;
        acv.a_transinf.tri_trans.trError_gg00 := e_ok;
        CASE tree.fileTfn_gg00 OF
            tfnColumn_egg00 :
                f_type := 'LONG COLUMN       ';
            OTHERWISE
                f_type := 'UNKNOWN           ';
            END;
        (*ENDCASE*) 
        a40move       (acv, a41v, @tree.fileTabId_gg00, sizeof (tree.fileTabId_gg00));
        a40move       (acv, a41v, schema_ptr,  sizeof (schema));
        a40move       (acv, a41v, owner_ptr,   sizeof (owner));
        a40move       (acv, a41v, tablen_ptr,  sizeof (tablen));
        a40move       (acv, a41v, indexn_ptr,  indexn_len);
        a40move_const (acv, a41v, @f_type,     sizeof (f_type));
        a40move_i4    (acv, a41v,
              tree.fileRoot_gg00, NOT c_null, 0, NOT c_to_undef);
        END;
    (*ENDIF*) 
UNTIL
    acv.a_transinf.tri_trans.trError_gg00 <> e_ok;
(*ENDREPEAT*) 
a722finalize_epos_reccol_relation( acv, _work_buf );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42InfoGCStats (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_null          = true;
      c_zero_to_undef = true;
 
VAR
      taskId                : tsp00_TaskId;
      active                : boolean;
      activateCount         : tsp00_8ByteCounter;
      deleteObj             : tsp00_8ByteCounter;
      relHistCreateObjFile  : tsp00_8ByteCounter;
      relHistDeleteObj      : tsp00_8ByteCounter;
      relHistDropObjFile    : tsp00_8ByteCounter;
      relHistLockObj        : tsp00_8ByteCounter;
      relHistInsertObj      : tsp00_8ByteCounter;
      relHistNewObj         : tsp00_8ByteCounter;
      relHistUpdateObj      : tsp00_8ByteCounter;
      relHistEntryNormal    : tsp00_8ByteCounter;
      relPageEmpty          : tsp00_8ByteCounter;
      relPageDropFile       : tsp00_8ByteCounter;
      relDropFile           : tsp00_8ByteCounter;
      ix                    : tsp00_Int4;
 
BEGIN
a40get_catalog_table (acv, a41v);
FOR ix := 1 TO g01maxobjgarbagecoll DO
    BEGIN
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        bd91InfoGCStats ( ix, taskId, active, activateCount, deleteObj,
              relHistEntryNormal, (*relHistEntrySensitive, relHistEntryTruncate, FF PTS 1120151 *)
              relHistCreateObjFile, relHistDeleteObj, relHistDropObjFile , relHistLockObj,
              relHistInsertObj, relHistNewObj, relHistUpdateObj,
              relPageEmpty, relPageDropFile, relDropFile );
        a40move_i4 (acv, a41v, taskId, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_const (acv, a41v, @a40yes_no [active], 3);
        a40move_counter (acv, a41v, activateCount, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, deleteObj, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relHistEntryNormal, NOT c_null, 0, NOT c_zero_to_undef);
        (*a40move_counter (acv, a41v, relHistEntrySensitive,
              NOT c_null, 0, NOT c_zero_to_undef);FF 1120151 *)
        (*a40move_counter (acv, a41v, relHistEntryTruncate,
              NOT c_null, 0, NOT c_zero_to_undef);FF 1120151 *)
        a40move (acv, a41v, NIL, 0); (* FF PTS 1120151 *)
        a40move (acv, a41v, NIL, 0); (* FF PTS 1120151 *)
        a40move_counter (acv, a41v, relHistCreateObjFile, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relHistDeleteObj, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relHistDropObjFile, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relHistLockObj, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relHistInsertObj, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relHistNewObj, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relHistUpdateObj, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relPageEmpty, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relPageDropFile, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_counter (acv, a41v, relDropFile, NOT c_null, 0, NOT c_zero_to_undef);
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE   (* PTS 1115641 *)
      ak42_container_roots (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_null          = true;
      c_zero_to_undef = true;
 
VAR
      pObjFileIter          : tsp00_Addr;
      pContObjFileIter      : tsp00_Addr;
 
      Stackarea  : RECORD       (* PTS 1116125 FF 2002-06-10 *)
            CASE boolean OF
                true :
                    (p    : tsp00_C64);
                false :
                    (align : tsp00_Addr);
                END;
            (*ENDCASE*) 
 
      ClassId               : tsp00_C8;
      Root                  : tsp00_Int4;
      ContainerSequelNo     : tsp00_Int4;
      NumKeyPartitions      : tsp00_Int2;
      MaxObjBodySize        : tsp00_Int4;
      MaxObjPerPage         : tsp00_Int4;
      MaxChains             : tsp00_Int4;
      VarContainer          : boolean;
      DeleteFlag            : boolean;
      UnusedBytePerPage     : tsp00_Int2; (* PTS 1118335 FF *)
      eof                   : boolean;
 
BEGIN
a40get_catalog_table (acv, a41v);
pObjFileIter     := NIL;
pContObjFileIter := NIL;
eof              := FALSE;
WHILE (NOT eof) AND (acv.a_returncode = 0) DO
    BEGIN
    bd91InfoContainerRoots (acv.a_transinf.tri_trans,
          pObjFileIter, pContObjFileIter,
          @Stackarea.p[1], sizeof(Stackarea), ClassId, Root, ContainerSequelNo,
          NumKeyPartitions, VarContainer, DeleteFlag,
          MaxObjBodySize, MaxObjPerPage, MaxChains, UnusedBytePerPage);
    IF  pObjFileIter <> NIL
    THEN
        BEGIN
        a40move (acv, a41v, @ClassId, sizeof(ClassId));
        a40move_i4 (acv, a41v, ContainerSequelNo, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, Root, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, NumKeyPartitions, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_const (acv, a41v, @a40yes_no [VarContainer], 3);
        a40move_const (acv, a41v, @a40yes_no [DeleteFlag], 3);
        a40move_i4 (acv, a41v, MaxObjBodySize, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, MaxObjPerPage, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, MaxChains, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, UnusedBytePerPage, (-1 = UnusedBytePerPage), 0, NOT c_zero_to_undef);
        END
    ELSE
        eof := true;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
(* PTS 1135610 FF on error release garbage semaphore *)
IF  (NOT eof)
    AND
    (acv.a_returncode <> 0)
    AND
    (pObjFileIter <> NIL)
THEN
    BEGIN
    bd91InfoContainerRoots (acv.a_transinf.tri_trans,
          pObjFileIter, pContObjFileIter,
          @Stackarea.p[1], 0, ClassId, Root, ContainerSequelNo,
          NumKeyPartitions, VarContainer, DeleteFlag,
          MaxObjBodySize, MaxObjPerPage, MaxChains, UnusedBytePerPage);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE   (* PTS 1115641 FF *)
      ak42_container_chains (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_null          = true;
      c_zero_to_undef = true;
 
VAR
      pObjFileIter      : tsp00_Addr;
      pContObjFileIter  : tsp00_Addr;
 
      Stackarea  : RECORD       (* PTS 1116125 FF 2002-06-10 *)
            CASE boolean OF
                true :
                    (p    : tsp00_C64);
                false :
                    (align : tsp00_Addr);
                END;
            (*ENDCASE*) 
 
      ClassId           : tsp00_C8;
      ContainerSequelNo : tsp00_Int4;
      ChainId           : tsp00_Int4;
      Subroot           : tsp00_Int4;
      ObjCount          : tsp00_Int4;
      PageCount         : tsp00_Int4;
      ActiveGC          : tsp00_Int4;
      RelEmptyPages     : boolean;
      eof               : boolean;
 
BEGIN
a40get_catalog_table (acv, a41v);
eof              := FALSE;
pObjFileIter     := NIL;
pContObjFileIter := NIL;
WHILE (NOT eof) AND (acv.a_returncode = 0) DO
    BEGIN
    bd91InfoContainerChains (acv.a_transinf.tri_trans,
          pObjFileIter, pContObjFileIter,
          @Stackarea.p[1], sizeof(Stackarea), ClassId, ContainerSequelNo, ChainId,
          Subroot, ObjCount, PageCount, ActiveGC, RelEmptyPages );
    IF  pObjFileIter <> NIL
    THEN
        BEGIN
        a40move (acv, a41v, @ClassId, sizeof(ClassId));
        a40move_i4 (acv, a41v, ContainerSequelNo, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, ChainId, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, Subroot, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, ObjCount, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, PageCount, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, ActiveGC, NOT c_null, 0, NOT c_zero_to_undef);
        a40move (acv, a41v, NIL, 0); (* FF 1117855 *)
        END
    ELSE
        eof := true;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
(* PTS 1135610 FF on error release garbage semaphore *)
IF  (NOT eof)
    AND
    (acv.a_returncode <> 0)
    AND
    (pObjFileIter <> NIL)
THEN
    BEGIN
    bd91InfoContainerChains (acv.a_transinf.tri_trans,
          pObjFileIter, pContObjFileIter,
          @Stackarea.p[1], 0, ClassId, ContainerSequelNo, ChainId,
          Subroot, ObjCount, PageCount, ActiveGC, RelEmptyPages );
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE   (* PTS 1115641 FF *)
      ak42_container_keys (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_null          = true;
      c_zero_to_undef = true;
 
VAR
      pObjFileIter      : tsp00_Addr;
 
      Stackarea  : RECORD       (* PTS 1116125 FF 2002-06-10 *)
            CASE boolean OF
                true :
                    (p    : tsp00_C64);
                false :
                    (align : tsp00_Addr);
                END;
            (*ENDCASE*) 
 
      ClassId           : tsp00_C8;
      KeyRoot           : tsp00_Int4;
      KeyIdx            : tsp00_Int2;
      eof               : boolean;
 
BEGIN
a40get_catalog_table (acv, a41v);
eof              := FALSE;
pObjFileIter     := NIL;
WHILE (NOT eof) AND (acv.a_returncode = 0) DO
    BEGIN
    bd91InfoContainerKeys (acv.a_transinf.tri_trans,
          pObjFileIter, @Stackarea.p[1], sizeof(Stackarea),
          KeyIdx, ClassId, KeyRoot);
    IF  pObjFileIter <> NIL
    THEN
        BEGIN
        a40move (acv, a41v, @ClassId, sizeof(ClassId));
        a40move_i4 (acv, a41v, KeyIdx, NOT c_null, 0, NOT c_zero_to_undef);
        a40move_i4 (acv, a41v, KeyRoot, NOT c_null, 0, NOT c_zero_to_undef);
        END
    ELSE
        eof := true;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
(* PTS 1135610 FF on error release garbage semaphore *)
IF  (NOT eof)
    AND
    (acv.a_returncode <> 0)
    AND
    (pObjFileIter <> NIL)
THEN
    BEGIN
    bd91InfoContainerKeys (acv.a_transinf.tri_trans,
          pObjFileIter, @Stackarea.p[1], 0,
          KeyIdx, ClassId, KeyRoot);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42select_lock_trans (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_desc_len  = 40;
      c_value_len = 12;
 
VAR
      b_err     : tgg00_BasisError;
      rec_len   : tsp00_IntMapC2;
      key_len   : tsp00_IntMapC2;
      rec_pos   : integer;
      offset    : integer;
      set_result: tgg00_BdSetResultRecord;
      tree_pos  : tgg00_FilePos;
      aux_file  : tgg00_FileId;
      zerokey   : tgg00_Lkey;
      lock_info : tkb05_LockShow;
      mm_type   : tgg00_MessType2;
      data      : tgg00_BufLenInfo;
      qual      : tgg00_QualBuf;
      mblock    : tgg00_MessBlock;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a40get_catalog_table (acv, a41v);
    IF  a_returncode = 0
    THEN
        BEGIN
        g04build_temp_tree_id (aux_file, a_transinf.tri_trans);
        b01tcreate_file (a_transinf.tri_trans, aux_file);
        IF  a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
        ELSE
            BEGIN
            CASE a4sh_kind OF
                sh_lock :
                    mm_type := mm_lock;
                sh_trans :
                    mm_type := mm_subtrans;
                sh_st_lock :
                    mm_type := mm_config;
                (* PTS 1109995 E.Z. *)
                END;
            (*ENDCASE*) 
            g01mblock_init (acv.a_transinf.tri_trans,
                  m_show, mm_type, mblock);
            g01datapart_init (mblock, @data, sizeof (data));
            g01stack_init    (mblock, NIL, 0, @qual, sizeof (qual));
            mblock.mb_qual^.mtree := aux_file;
            a06rsend_mess_buf (acv, mblock,
                  cak_return_req, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                WITH set_result DO
                    BEGIN
                    bd_key_check_len:= 0;
                    bd_max_rec_cnt  := MAX_INT2_SP00;
                    bd_max_fill_len := sizeof(data);
                    bd_next         := false;
                    END;
                (*ENDWITH*) 
                zerokey.len     := 0;
                tree_pos.tpsPno_gg00  := NIL_PAGE_NO_GG00;
                REPEAT
                    b07cnext_record (a_transinf.tri_trans, aux_file,
                          zerokey, set_result, tree_pos, data.rb.buf);
                    b_err := a_transinf.tri_trans.trError_gg00;
                    IF  (b_err = e_ok) OR (b_err = e_key_not_found) OR
                        (b_err = e_buffer_limit)
                    THEN
                        BEGIN
                        rec_pos := 1;
                        WHILE rec_pos < set_result.bd_fill_len DO
                            BEGIN
                            rec_len.mapC2_sp00[1] := data.rb.buf[rec_pos  ];
                            rec_len.mapC2_sp00[2] := data.rb.buf[rec_pos+1];
                            CASE a4sh_kind OF
                                sh_st_lock :
                                    BEGIN
                                    key_len.mapC2_sp00[1] := data.rb.buf[rec_pos+2];
                                    key_len.mapC2_sp00[2] := data.rb.buf[rec_pos+3];
                                    offset := cgg_rec_key_offset +
                                          key_len.mapInt_sp00;
                                    (* h.b. PTS 1001082 *)
                                    a40move (acv, a41v,
                                          @data.rb.buf[rec_pos + offset + 1],
                                          rec_len.mapInt_sp00 - offset -
                                          c_value_len * a01char_size - 1 - 1);
                                    (* h.b. PTS 1001082 *)
                                    a40move (acv, a41v,
                                          @data.rb.buf[rec_pos + offset + 1 +
                                          c_desc_len * a01char_size + 1],
                                          c_value_len * a01char_size)
                                    END;
                                OTHERWISE
                                    BEGIN
                                    SAPDB_PascalMove ('VAK42 ',   5,    
                                          sizeof (data.rb.buf),
                                          sizeof(lock_info), @data.rb.buf,
                                          rec_pos, @lock_info, 1,
                                          rec_len.mapInt_sp00, b_err);
                                    IF  b_err <> e_move_error
                                    THEN
                                        ak42one_lock_info (acv, a41v, lock_info)
                                    (*ENDIF*) 
                                    END;
                                END;
                            (*ENDCASE*) 
                            rec_pos := rec_pos + rec_len.mapInt_sp00
                            END;
                        (*ENDWHILE*) 
                        IF  b_err = e_buffer_limit
                        THEN
                            b_err := e_ok
                        ELSE
                            b_err := e_no_next_record;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                UNTIL
                    (b_err <> e_ok) OR
                    (a_returncode <> 0);
                (*ENDREPEAT*) 
                END
            ELSE
                a07_b_put_error (acv, b_err, 1);
            (*ENDIF*) 
            b01destroy_file (a_transinf.tri_trans, aux_file)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42one_lock_info (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            VAR lock_info : tkb05_LockShow);
 
CONST
      c_do_move = true;
 
VAR
      ok               : boolean;
      table_found      : boolean;
      is_obj_lock      : boolean;
      obj_class_char   : char;
      e                : tgg00_BasisError;
      c3               : tsp00_C3;
      p                : integer;
      c_index          : integer;
      rowid_pos        : integer;
      length           : integer;
      val_length       : integer;
      max_length       : integer;
      curr_move_len    : integer;
      help_tabname_len : integer;
 
      userid : RECORD
            CASE boolean OF
                true :
                    (surrogate : tgg00_Surrogate);
                false :
                    (fill : tsp00_C4;
                    id   : tgg00_UserId);
                END;
            (*ENDCASE*) 
 
      user         : tsp00_KnlIdentifier;
      owner        : tsp00_KnlIdentifier;
      tablename    : tsp00_KnlIdentifier;
      c120         : tsp00_C120;
      key_info     : tsp00_C256;
      is_trunc     : boolean;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    WITH lock_info.lshTransShow_kb05 DO
        BEGIN
        (*
              ------------ session ==> shinfo -----------*)
        a40move_i4 (acv, a41v, gg06SessionGetInt4 (tshSession_kb05),
              NOT c_null, 0, NOT c_to_undef);
        (*
              ------------ select trans  ==> shinfo ------------*)
        a42move_trans_no (acv, a41v, tshSelTransId_kb05);           (* PTS 1108234 JA 2001-01-19 *)
        (*
              ------------ sub trans  ==> shinfo ------------*)
        a40move_i4 (acv, a41v, tshSubtrans_kb05,                     (* PTS 1108234 JA 2001-01-19 *)
              NOT c_null, 0, NOT c_to_undef);
        (*
              ------------ write trans  ==> shinfo ------------*)
        IF  gg06IsNilTrans (tshWriteTransId_kb05)                    (* PTS 1108234 JA 2001-01-19 *)
        THEN
            a40move (acv, a41v, NIL, 0)  (* undef *)
        ELSE
            a40move (acv, a41v, @tshWriteTransId_kb05, sizeof(tshWriteTransId_kb05));
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    WITH lock_info.lshTransShow_kb05 DO
        BEGIN
        a40move_i4 (acv, a41v, tshTaskId_kb05,
              NOT c_null, 0, NOT c_to_undef);
        (*------------ user name ==> shinfo ------------*)
        userid.surrogate := a_curr_user_id;
        userid.id        := tshUserId_kb05;
        a06determine_username (acv, userid.surrogate, user);
        a40move (acv, a41v, @user, sizeof (user));
        (*------------ date ==> shinfo ------------*)
        a40put_date_time (acv, a41v, tshStartDate_kb05,
              c_is_date,  tshStartDate_kb05 = 0);
        (*------------ time ==> shinfo ------------*)
        (* check of DATE is correct, as internal transactions do initialize date and time with 0 *)
        (* but TIME = 0 is correct around midnight !                                             *)
        a40put_date_time (acv, a41v, tshStartTime_kb05,
              NOT c_is_date,  tshStartDate_kb05 = 0);
        (*------------ termid ==> shinfo --------------*)
        a40move_const (acv, a41v, @tshTermId_kb05,
              sizeof (tshTermId_kb05));
        (*------------ lock timeout dummy -------------*)
        a40move (acv, a41v, NIL, 0);
        (*------------ req timeout ==> shinfo --------------*)
        IF  tshTrReqMode_kb05 <> tlmFree_ekb05
        THEN
            a40move_i4 (acv, a41v, tshReqTimeout_kb05,
                  NOT c_null, 0, NOT c_to_undef)
        ELSE
            a40move (acv, a41v, NIL, 0);
        (*ENDIF*) 
        (*------------ time last write ==> shinfo --------------*)
        IF  tshTrLockMode_kb05 = tlmEotExcl_ekb05
        THEN
            a40move_i4 (acv, a41v, tshTimeWrite_kb05,
                  NOT c_null, 0, NOT c_to_undef)
        ELSE
            a40move (acv, a41v, NIL, 0)
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  ((a4sh_kind = sh_lock) OR (a4sh_kind = sh_locks))
    THEN
        WITH lock_info.lshTransShow_kb05 DO                          (* PTS 1108234 JA 2001-01-19 *)
            BEGIN
            (*---------- lock mode/state ==> shinfo ------------*)
            a42lock_req_mode  (acv, a41v, tshLockMode_kb05);
            a42lock_req_state (acv, a41v, tshLockState_kb05);
            (*---------- lock request mode/state ==> shinfo ----*)
            a42lock_req_mode  (acv, a41v, tshReqMode_kb05);
            a42lock_req_state (acv, a41v, tshReqState_kb05);
            END
        (*ENDWITH*) 
    ELSE
        WITH lock_info.lshTransShow_kb05 DO                          (* PTS 1108234 JA 2001-01-19 *)
            BEGIN
            (*---------- trans lock mode/state ==> shinfo ------------*)
            ak42lock_mode  (acv, a41v, tshTrLockMode_kb05);
            ak42lock_state (acv, a41v, tshTrLockMode_kb05);
            (*---------- trans lock request mode/state ==> shinfo ----*)
            ak42lock_mode  (acv, a41v, tshTrReqMode_kb05);
            ak42lock_state (acv, a41v, tshTrReqMode_kb05);
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    WITH lock_info.lshTransShow_kb05 DO                              (* PTS 1108234 JA 2001-01-19 *)
        BEGIN
        IF  gg06IsNilTrans (tshConsistView_kb05)                     (* PTS 1108234 JA 2001-01-19 *)
        THEN
            a40move (acv, a41v, NIL, 0)  (* undef *)
        ELSE
            (* PTS 1106007 *)
            a40move (acv, a41v, @tshConsistView_kb05, sizeof(tshConsistView_kb05));
        (*ENDIF*) 
        ak42appl_info (acv, a41v, tshTaskId_kb05)
        END;
    (*ENDWITH*) 
    IF  a4sh_kind = sh_lock
    THEN
        BEGIN
        is_obj_lock := false;
        (*---------- owner, table name ==> shinfo ----*)
        a06_systable_get (acv, d_release, lock_info.lshTabId_kb05,
              a4p_arr.pbasep, c_get_all, table_found);
        IF  acv.a_returncode =
            a071_return_code (e_old_fileversion, acv.a_sqlmode)
        THEN
            acv.a_returncode := 0; (* PTS 1113099 *)
        (*ENDIF*) 
        IF  table_found
        THEN
            a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1, c_with_owner)
        ELSE
            IF  (a_returncode =
                a071_return_code (e_lock_collision, acv.a_sqlmode))
            THEN
                BEGIN (* try to read dirty *)
                a_returncode := 0;
                a42get_tablename (acv.a_transinf.tri_trans, lock_info.lshTabId_kb05,
                      owner, tablename, e);
                IF  e = e_ok
                THEN
                    BEGIN
                    table_found := true;
                    a40move (acv, a41v, @owner, sizeof(owner));
                    a40move (acv, a41v, @tablename, sizeof(tablename));
                    a40move (acv, a41v, @owner, sizeof(owner));
                    a4p_arr.pbasep := NIL (* we have no base record in ak cache *)
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  NOT table_found
        THEN
            BEGIN
            IF  g01unicode
            THEN
                help_tabname_len := mxsp_c18 DIV 2
            ELSE
                help_tabname_len := mxsp_c18;
            (*ENDIF*) 
            a40move (acv, a41v, NIL, 0); (* schema *)
            IF  kb560IsSys2CatalogTable (lock_info.lshTabId_kb05)
            THEN
                a40move_const (acv, a41v, @n_sys2_cat, help_tabname_len)
            ELSE
                BEGIN
                obj_class_char := lock_info.lshTabId_kb05 [1];
                lock_info.lshTabId_kb05 [1] := chr (0);
                IF  (lock_info.lshTabId_kb05 = cgg_zero_id)
                    AND
                    (ord (obj_class_char) > 0)
                THEN
                    BEGIN
                    a40move_const (acv, a41v, @n_obj_file, help_tabname_len);
                    is_obj_lock := true
                    END
                ELSE
                    (*---- table has been dropped in the meantime *)
                    a40move_const (acv, a41v, NIL, 0)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            a40move (acv, a41v, NIL, 0); (* owner *)
            END;
        (*---------- tabid ==> shinfo -----------*)
        (*ENDIF*) 
        a40move (acv, a41v, @lock_info.lshTabId_kb05, SURROGATE_MXGG00);
        (*---------- rowid len ==> shinfo -----------*)
        a40move_i4 (acv, a41v, lock_info.lshRowIdLen_kb05,
              NOT c_null, 0, c_to_undef);
        (*---------- rowid ==> shinfo ---------------*)
        IF  lock_info.lshUndefRowId_kb05
        THEN
            a40move (acv, a41v, NIL, 0)
        ELSE
            BEGIN
            (*------------- rowid hex ==> shinfo ------------*)
            IF  lock_info.lshRowIdLen_kb05
                <= sizeof (lock_info.lshRowId_kb05)
            THEN
                length := lock_info.lshRowIdLen_kb05
            ELSE
                length := sizeof (lock_info.lshRowId_kb05);
            (*ENDIF*) 
            a40move (acv, a41v, @lock_info.lshRowId_kb05, length)
            END;
        (*ENDIF*) 
        IF  lock_info.lshUndefRowId_kb05
        THEN
            a40move (acv, a41v, NIL, 0)
        ELSE
            BEGIN
            (*------------- rowid text => shinfo ------------*)
            IF  NOT table_found OR (a4p_arr.pbasep = NIL) (* PTS 1113367 *)
            THEN
                BEGIN
                IF  NOT is_obj_lock
                THEN
                    a40move (acv, a41v, NIL, 0)
                ELSE
                    BEGIN
                    IF  lock_info.lshRowIdLen_kb05 <= sizeof (lock_info.lshRowId_kb05)
                    THEN
                        length := lock_info.lshRowIdLen_kb05
                    ELSE
                        length := sizeof (lock_info.lshRowId_kb05);
                    (*ENDIF*) 
                    a40move_const (acv, a41v, @lock_info.lshRowId_kb05, length)
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  lock_info.lshRowIdLen_kb05 <= sizeof(tkb05_RowIdFirstPart) DIV 2 (* PTS 1121179 UH 2003-04-07 *)
                THEN
                    max_length := lock_info.lshRowIdLen_kb05
                ELSE
                    max_length := sizeof(tkb05_RowIdFirstPart) DIV 2; (* PTS 1121179 UH 2003-04-07 *)
                (*ENDIF*) 
                c_index := a4p_arr.pbasep^.sbase.bfirstcolind;
                rowid_pos  := 1;
                p          := 1;
                ok         := true;
                WHILE (c_index <> 0) AND ok DO
                    BEGIN
                    WITH a4p_arr.pbasep^.sbase, a103GetColumn (a4p_arr.pbasep^.sbase, c_index)^ DO
                        IF  NOT (ctkey in ccolpropset)
                            OR
                            (rowid_pos > max_length)
                        THEN
                            c_index := 0
                        ELSE
                            BEGIN
                            IF  rowid_pos + cinoutlen - 1 > max_length
                            THEN
                                IF  cdatatyp in [dfixed, dfloat]
                                THEN
                                    length := 0
                                ELSE
                                    BEGIN
                                    length := max_length - rowid_pos +1;
                                    IF  (cdatatyp = dunicode)
                                        AND (((length - 1) MOD 2) <> 0)
                                    THEN
                                        length := pred (length);
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                            ELSE
                                length := cinoutlen;
                            (*ENDIF*) 
                            IF  length > 0
                            THEN
                                BEGIN
                                IF  cdatatyp = dunicode
                                THEN
                                    SAPDB_PascalForcedUnicodeFill (sizeof (c120), @c120,
                                          1, sizeof (c120),
                                          csp_unicode_blank)
                                ELSE
                                    SAPDB_PascalForcedFill (sizeof (c120), @c120,
                                          1, sizeof (c120), bsp_c1);
                                (*ENDIF*) 
                                a40put_one_value (acv, a41v,
                                      a103GetColumn (a4p_arr.pbasep^.sbase, c_index)^, NOT c_do_move,
                                      lock_info.lshRowId_kb05, rowid_pos,
                                      length, c120, val_length, ok);
                                IF  rowid_pos > 1
                                THEN
                                    ak42ascii_const_move ( @'.', 1,
                                          p, key_info,
                                          a_returncode);
                                (*ENDIF*) 
                                ;
                                CASE cdatatyp OF
                                    dcha, dunicode,
                                    ddate, dtime, dtimestamp :
                                        ak42ascii_const_move ( @'''', 1,
                                              p, key_info,
                                              a_returncode);
                                    dchb :
                                        BEGIN
                                        ak42ascii_const_move ( @'x', 1,
                                              p, key_info,
                                              a_returncode);
                                        ak42ascii_const_move ( @'''', 1,
                                              p, key_info,
                                              a_returncode)
                                        END;
                                    OTHERWISE:
                                        BEGIN
                                        END;
                                    END;
                                (*ENDCASE*) 
                                IF  ( g01unicode
                                    AND (cdatatyp = dunicode) )
                                    OR
                                    ( NOT g01unicode
                                    AND (cdatatyp <> dunicode) )
                                THEN
                                    BEGIN
                                    SAPDB_PascalMove ('VAK42 ',   6,    
                                          sizeof (c120),
                                          sizeof(key_info),
                                          @c120, 1, @key_info, p,
                                          val_length,
                                          a_returncode);
                                    p := p + val_length;
                                    END
                                ELSE
                                    IF  g01unicode
                                        AND (cdatatyp <> dunicode)
                                    THEN
                                        BEGIN
                                        ak42ascii_const_move ( @c120,
                                              val_length, p, key_info,
                                              a_returncode)
                                        END
                                    ELSE
                                        BEGIN
                                        s40gbyte (c120, 1, val_length,
                                              key_info, p,
                                              val_length * 2, is_trunc);
                                        p := p + val_length * 2;
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                IF  cdatatyp in [ dcha, dchb,
                                    dunicode, ddate, dtime, dtimestamp ]
                                THEN
                                    ak42ascii_const_move ( @'''', 1,
                                          p, key_info,
                                          a_returncode);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            rowid_pos := rowid_pos + cinoutlen;
                            c_index := cnextind
                            END;
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END;
                (*ENDWHILE*) 
                IF  ok
                THEN
                    BEGIN
                    IF  max_length < lock_info.lshRowIdLen_kb05
                    THEN
                        BEGIN
                        (* key is truncated *)
                        c3 := '...';
                        ak42ascii_const_move ( @c3, 3, p, key_info,
                              a_returncode);
                        curr_move_len := p - 1;
                        END
                    ELSE
                        curr_move_len := p - 1;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    p := 1;
                    ak42ascii_const_move ( @' ', 1, p, key_info,
                          a_returncode);
                    curr_move_len := p - 1;
                    END;
                (*ENDIF*) 
                a40move (acv, a41v, @key_info, curr_move_len)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42appl_info (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            process_id : tsp00_TaskId);
 
VAR
      ok        : boolean;
      appl_pid  : tsp00_Int4;
      appl_node : tsp00_NodeId;
 
BEGIN
(* process id and node_id of application ==> shinfo *)
vgetapplpid (process_id, appl_node, appl_pid, ok);
a40move_i4 (acv, a41v, appl_pid, NOT ok, 0, NOT c_to_undef);
IF  ok
THEN
    a40move_const (acv, a41v, @appl_node, sizeof (appl_node))
ELSE
    a40move (acv, a41v, NIL, 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42lock_mode (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            lock_mode : tkb05_TransLockMode);
 
VAR
      do_move : boolean;
      id      : tsp00_C14;
 
BEGIN
do_move := true;
CASE lock_mode OF
    tlmFree_ekb05  :
        BEGIN
        do_move := false;
        a40move (acv, a41v, NIL, 0)
        END;
    tlmShare_ekb05 :
        id := 'share         ';
    tlmExcl_ekb05     :
        id := 'exclusive     ';
    tlmEotExcl_ekb05 :
        id := 'exclusive     ';
    END;
(*ENDCASE*) 
IF  do_move
THEN
    a40move_const (acv, a41v, @id, sizeof (id))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42lock_state (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            lock_mode : tkb05_TransLockMode);
 
VAR
      id : tsp00_C10;
 
BEGIN
CASE lock_mode OF
    tlmExcl_ekb05:
        BEGIN
        id := 'write     ';
        a40move_const (acv, a41v, @id, sizeof (id))
        END;
    OTHERWISE
        a40move (acv, a41v, NIL, 0)
    END
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42new_lock_req_mode (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            lock_mode : tgg00_LockReqMode);
 
VAR
      do_move : boolean;
      id      : tsp00_C16;
 
BEGIN
do_move := true;
CASE lock_mode OF
    lckFree_egg00  :
        BEGIN
        do_move := false;
        a40move (acv, a41v, NIL, 0)
        END;
    lckSysShare_egg00 :
        id := 'SYSTEM SHARE    ';
    lckSysExcl_egg00     :
        id := 'SYSTEM EXCLUSIVE';
    lckTabShare_egg00 :
        id := 'TABLE SHARE     ';
    lckTabExcl_egg00 :
        id := 'TABLE EXCLUSIVE ';
    lckRowShare_egg00 :
        id := 'ROW SHARE       ';
    lckRowExcl_egg00 :
        id := 'ROW EXCLUSIVE   ';
    lckRowOptimistic_egg00 :
        id := 'ROW OPTIMISTIC  ';
    END;
(*ENDCASE*) 
IF  do_move
THEN
    a40move_const (acv, a41v, @id, sizeof (id))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42lock_req_mode (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            lock_mode : tgg00_LockReqMode);
 
VAR
      do_move : boolean;
      id      : tsp00_C14;
 
BEGIN
do_move := true;
CASE lock_mode OF
    lckFree_egg00  :
        BEGIN
        do_move := false;
        a40move (acv, a41v, NIL, 0)
        END;
    lckSysShare_egg00 :
        id := 'sys_share     ';
    lckSysExcl_egg00     :
        id := 'sys_exclusive ';
    lckTabShare_egg00 :
        id := 'tab_share     ';
    lckTabExcl_egg00 :
        id := 'tab_exclusive ';
    lckRowShare_egg00 :
        id := 'row_share     ';
    lckRowExcl_egg00 :
        id := 'row_exclusive ';
    lckRowOptimistic_egg00 :
        id := 'row_optimistic';
    END;
(*ENDCASE*) 
IF  do_move
THEN
    a40move_const (acv, a41v, @id, sizeof (id))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42new_lock_req_state (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            lock_state : tgg00_LockReqState);
 
VAR
      do_move : boolean;
      id      : tsp00_C10;
 
BEGIN
do_move := true;
IF  lrsEotExcl_egg00 in lock_state
THEN
    BEGIN
    IF  lrsForInsert_egg00 in lock_state
    THEN
        id := 'WRITE INS '
    ELSE
        id := 'WRITE     '
    (*ENDIF*) 
    END
ELSE
    IF  lrsConsistent_egg00 in lock_state
    THEN
        id := 'CONSISTENT'
    ELSE
        IF  lrsTemp_egg00 in lock_state
        THEN
            id := 'TEMP      '
        ELSE
            IF  lrsIgnoreInsert_egg00 in lock_state
            THEN
                id := 'IGNORE INS'
            ELSE
                BEGIN
                do_move := false;
                a40move (acv, a41v, NIL, 0)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  do_move
THEN
    a40move_const (acv, a41v, @id, sizeof (id))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42lock_req_state (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            lock_state : tgg00_LockReqState);
 
VAR
      do_move : boolean;
      id      : tsp00_C10;
 
BEGIN
do_move := true;
IF  lrsEotExcl_egg00 in lock_state
THEN
    BEGIN
    IF  lrsForInsert_egg00 in lock_state
    THEN
        id := 'write ins '
    ELSE
        id := 'write     '
    (*ENDIF*) 
    END
ELSE
    IF  lrsConsistent_egg00 in lock_state
    THEN
        id := 'consistent'
    ELSE
        IF  lrsTemp_egg00 in lock_state
        THEN
            id := 'temp      '
        ELSE
            IF  lrsIgnoreInsert_egg00 in lock_state
            THEN
                id := 'ignore ins'
            ELSE
                BEGIN
                do_move := false;
                a40move (acv, a41v, NIL, 0)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  do_move
THEN
    a40move_const (acv, a41v, @id, sizeof (id))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42serverdb_statistics (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      db_space_info  : tgg00_DbSpaceInfo;
      log_percent    : tsp00_Int4;
      restart_date   : tsp00_Int4;
      restart_time   : tsp00_Int4;
      unused_pages   : tsp00_Int4;
      log_device_info: tkb00_LogDeviceInfo;
      log_queue_info : tkb00_LogQueueInfo;
 
BEGIN
a40get_catalog_table (acv, a41v);
WITH acv, a41v DO
    IF  a_returncode = 0
    THEN
        BEGIN
        b01dbspace_statistic (a_transinf.tri_trans, db_space_info);
        IF  a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
        ELSE
            BEGIN
            WITH db_space_info DO
                BEGIN
                a40move_i4 (acv, a41v, db_total_pages,    NOT c_null, 0, NOT c_to_undef);
                (* 12.04.2001 h.b. is not known anymore *)
                a40move_i4 (acv, a41v, NIL_PAGE_NO_GG00,  c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, db_perm_pages,     NOT c_null, 0, NOT c_to_undef);
                (* CR 1113689 *)
                a40move_i4 (acv, a41v, db_max_perm_used,  NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, db_real_perm_used, NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, db_perm_percent,   NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, db_temp_pages,     NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, db_temp_percent,   NOT c_null, 0, NOT c_to_undef);
                unused_pages := db_total_pages - db_used_pages;
                a40move_i4 (acv, a41v, unused_pages,      NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v,
                      ak42evalpercent (unused_pages, db_total_pages), NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, db_updated_pages,  NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, db_used_blocks,    NOT c_null, 0, NOT c_to_undef);
                a40move_const (acv, a41v, @a40yes_no [b01db_full(acv.a_transinf.tri_trans.trTaskId_gg00)], 3)
                END;
            (*ENDWITH*) 
            (* *)
            kb560GetStatistics (a_transinf.tri_trans.trTaskId_gg00, log_device_info, log_queue_info);
            (* *)
            WITH log_device_info DO
                BEGIN
                (* *)
                a40move_i4 (acv, a41v, kb560GetLogDeviceSize, NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, ldiPagesUsed_kb00,     NOT c_null, 0, NOT c_to_undef);
                log_percent := ak42evalpercent (ldiPagesUsed_kb00, kb560GetLogDeviceSize);
                (* *)
                a40move_i4 (acv, a41v, log_percent,                  NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, ldiPagesNotSaved_kb00,        NOT c_null, 0, NOT c_to_undef);
                log_percent := ak42evalpercent(ldiPagesNotSaved_kb00, kb560GetLogDeviceSize);
                (* *)
                a40move_i4 (acv, a41v, log_percent,                  NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, ldiPagesSinceBup_kb00,        NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, g01autosave_distance,         NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, ldiSaveptCount_kb00,          NOT c_null, 0, NOT c_to_undef);
                a40move_i4 (acv, a41v, 0(*ldiCheckptCount_kb00*),    NOT c_null, 0, NOT c_to_undef)
                END;
            (*ENDWITH*) 
            (*------------ restart date/time ==> shinfo ------------*)
            a36restart_time  (restart_date, restart_time);
            a40put_date_time (acv, a41v, restart_date, c_is_date,     NOT c_is_null);
            a40put_date_time (acv, a41v, restart_time, NOT c_is_date, NOT c_is_null);
            (* k56iobjlog_info removed: PTS 1105395 JA 2000-03-07 *)
            (* former obj_log_cache_info:                         *)
            a40move_i4 (acv, a41v, 0 (* PagesUsed    *), NOT c_null, 0, NOT c_to_undef);
            a40move_i4 (acv, a41v, 0 (* PagesMinFree *), NOT c_null, 0, NOT c_to_undef)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42state_statistics (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      is_all         : boolean;
      realy_bad      : boolean;
      dev_type       : tsp2_dev_type;
      requested      : integer;
      devno          : tsp00_Int4;
      nam            : tsp00_Sname;
      off_on         : ARRAY[boolean] OF tsp00_Sname;
      v30            : tsp00_C30;
      (* h.b. PTS 1105522 *)
 
      analyze_filter : RECORD
            CASE boolean OF
                true :
                    (devn : tsp00_VFilename);
                false :
                    (filter : tsp00_C64);
                END;
            (*ENDCASE*) 
 
      devname      : tsp2_devname;
      keyword      : tak_keyword;
      kindOut      : tak_keyword;
      topicKeyOut  : tsp00_Sname;
      levelOut     : integer;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    is_all    := (a_current_user_kind in [usysdba, ucontroluser]);
    a4sh_kind := sh_st_state;
    a40get_catalog_table (acv, a41v);
    IF  (a_ex_kind <> only_parsing) AND
        (a_returncode = 0)
    THEN
        BEGIN
        off_on[false] := n_off;
        off_on[true ] := n_on;
        v30 := n_outerj_ordered;
        ak42sname_statistic (acv, a41v, v30, off_on[g01outer_join_ordered]);
        v30 := n_st020_op_join;
        ak42sname_statistic (acv, a41v, v30, off_on[gg01_operator_join]);
        v30 := n_op_join_sort;
        ak42sname_statistic (acv, a41v, v30, off_on[gg01_operator_join_sort]);
        v30 := n_join_parallel;
        ak42datab_statistic (acv, a41v, v30, g01optimize_parallel_server);
        v30 := n_min_max_optim;
        ak42sname_statistic (acv, a41v, v30, off_on[g01diag_minmax_optim]);
        v30 := n_reverse_fetch;
        ak42sname_statistic (acv, a41v, v30, off_on[g01diag_reverse_fetch]);
        (* PTS 1115978 E.Z. *)
        (* PTS 1112386*)
        v30 := n_st021_monitoring;
        ak42sname_statistic (acv, a41v, v30, off_on[c_monitor_on]);
        (* PTS 1113190 *)
        v30 := n_st18_log_write;
        ak42sname_statistic (acv, a41v, v30, (* PTS 1118565 mb 2002-11-04 *)
              off_on[gg999IsLogWritingEnabled(acv.a_transinf.tri_trans.trTaskId_gg00)]);
        v30 := n_st19_log_auto_overwrite;
        ak42sname_statistic (acv, a41v, v30,
              off_on[gg999IsLogAutoOverwriteEnabled(acv.a_transinf.tri_trans.trTaskId_gg00)]);
        v30 := n_st20_join_clust;
        ak42sname_statistic (acv, a41v, v30, off_on[a01join_clust_read]);
        IF  a01diag_monitor_on
        THEN
            BEGIN
            IF  g01sm_reads < MAX_INT4_SP00
            THEN
                ak42datab_statistic (acv, a41v, n_st031_mon_read, g01sm_reads);
            (*ENDIF*) 
            IF  g01sm_selectivity <> cak_is_undefined
            THEN
                ak42datab_statistic (acv, a41v, n_st032_mon_sel, g01sm_selectivity);
            (*ENDIF*) 
            IF  g01sm_milliseconds < MAX_INT4_SP00
            THEN
                ak42datab_statistic (acv, a41v, n_st033_mon_sec, g01sm_milliseconds);
            (*ENDIF*) 
            ak42datab_statistic (acv, a41v, n_st035_mon_row, a545sm_get_rowno);
            v30 := n_st034_mon_data;
            ak42sname_statistic (acv, a41v, v30, off_on[a01sm_collect_data])
            END;
        (*ENDIF*) 
        ;
        IF  a01diag_analyze_on
        THEN
            BEGIN
            v30 := n_st022_da;
            IF  a01diag_ana_coll_data
            THEN
                nam := n_counting
            ELSE
                nam := n_on;
            (*ENDIF*) 
            ak42sname_statistic (acv, a41v, v30, nam);
            (* h.b. PTS 1105522 *)
            v30 := n_st023_da_filter;
            analyze_filter.devn := b01blankfilename;
            a544get_analyze_filter (analyze_filter.filter);
            ak42hostname_statistic (acv, a41v, v30, analyze_filter.devn)
            END;
        (*ENDIF*) 
        ;
        v30 := n_st036_sap_db;
        IF  g01glob.db_is_for_sapr3
        THEN
            nam := n_yes
        ELSE
            nam := n_no;
        (*ENDIF*) 
        ak42sname_statistic (acv, a41v, v30, nam);
        v30 := n_st12_db_full;
        IF  b01db_full( acv.a_transinf.tri_trans.trTaskId_gg00)
        THEN
            nam := n_yes
        ELSE
            nam := n_no;
        (*ENDIF*) 
        ak42sname_statistic (acv, a41v, v30, nam);
        v30 := n_st13_connect_poss;
        IF  b01connect_allowed
        THEN
            nam := n_yes
        ELSE
            nam := n_no;
        (*ENDIF*) 
        ak42sname_statistic (acv, a41v, v30, nam);
        (* PTS 1121939 E.Z. *)
        v30 := n_st130_logwriter_suspended;
        IF  NOT k560IsSavepointAllowed
        THEN
            nam := n_yes
        ELSE
            nam := n_no;
        (*ENDIF*) 
        (* PTS 1107118 E.Z. *)
        v30 := n_st132_shutd_ok;
        (* PTS 1113134 E.Z. *)
        ak42snullname_statistic (acv, a41v, v30);
        (* END PTS 1107118 E.Z. *)
        v30 := m_st133_monitor_oms;
        IF  ak341IsMonitorOn
        THEN
            nam := n_yes
        ELSE
            nam := n_no;
        (*ENDIF*) 
        ak42sname_statistic (acv, a41v, v30, nam);
        IF  is_all
        THEN
            ak42datab_statistic (acv, a41v, n_st04_used, a10cache_used);
        (*ENDIF*) 
        ak42datab_statistic (acv, a41v, n_st061_bad_index, b01get_bad_index_cnt);
        v30 := n_st07_vtrace;
        IF  g01vtrace.vtrAk_gg00
        THEN
            BEGIN
            nam := n_ak;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrAll_gg00
        THEN
            BEGIN
            nam := n_default;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrAkDelete_gg00
        THEN
            BEGIN
            nam := n_delete;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrBdIndex_gg00
        THEN
            BEGIN
            nam := n_index;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrAkInsert_gg00
        THEN
            BEGIN
            nam := n_insert;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrKbLock_gg00
        THEN
            BEGIN
            nam := n_lock;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrBdString_gg00
        THEN
            BEGIN
            nam := n_long;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrStrategy_gg00
        THEN
            BEGIN
            nam := n_optimize;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrAkPacket_gg00
        THEN
            BEGIN
            nam := n_order;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrAkShortPacket_gg00
        THEN
            BEGIN
            nam := n_order_stndrd;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrIoTrace_gg00
        THEN
            BEGIN
            nam := n_pages;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrAkSelect_gg00
        THEN
            BEGIN
            nam := n_select;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrBdPrim_gg00
        THEN
            BEGIN
            nam := n_table;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrTime_gg00
        THEN
            BEGIN
            nam := n_time;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrAkUpdate_gg00
        THEN
            BEGIN
            nam := n_update;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrBdObject_gg00
        THEN
            BEGIN
            nam := n_obj_bd;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrOmsNew_gg00
        THEN
            BEGIN
            nam := n_obj_new;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrOmsGet_gg00
        THEN
            BEGIN
            nam := n_obj_get;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrOmsUpd_gg00
        THEN
            BEGIN
            nam := n_obj_upd;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01vtrace.vtrOmsFree_gg00
        THEN
            BEGIN
            nam := n_obj_free;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (* PTS 1110976 E.Z. *)
        (*ENDIF*) 
        requested := 0;
        WHILE Kernel_DiagInfop (requested, kindOut, topicKeyOut, levelOut) DO
            BEGIN
            IF  levelOut > 0
            THEN
                BEGIN
                IF  (kindOut = 'Vtrace            ') AND (topicKeyOut = 'TABLE       ')
                THEN
                    topicKeyOut := 'TOPICTABLE  ';
                (*ENDIF*) 
                a42name_and_val_statistic (acv, a41v, kindOut, levelOut,
                      topicKeyOut);
                END;
            (*ENDIF*) 
            requested := requested + 1;
            END;
        (*ENDWHILE*) 
        (* END PTS 1110976 E.Z. *)
        IF  g01vtrace.vtrCheck_gg00
        THEN
            BEGIN
            v30 := n_st08_vtrace_chck;
            nam := n_on;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        v30 := n_st08a_check;  (* PTS 1103957 JA 1999-09-15 *)
        IF  kb03IsBackupCheck
        THEN
            (* PTS 1103957 JA 1999-09-15 *)
            BEGIN
            nam := n_backup;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  kb03IsLockCheck
        THEN
            (* PTS 1103957 JA 1999-09-15 *)
            BEGIN
            nam := n_lock;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  kb03IsLockSupplyCheck
        THEN
            (* PTS 1103957 JA 1999-09-15 *)
            BEGIN
            nam := n_lock_supply;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  kb03IsRegionCheck
        THEN
            (* PTS 1103957 JA 1999-09-15 *)
            BEGIN
            nam := n_kb_regions;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  kb03IsTransCheck
        THEN
            (* PTS 1103957 JA 1999-09-15 *)
            BEGIN
            nam := n_translist;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01glob.datacachecheck
        THEN
            (* PTS 1103957 JA 1999-09-15 *)
            BEGIN
            nam := n_datacache;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01glob.bd_lock_check
        THEN
            (* PTS 1103957 JA 1999-09-15 *)
            BEGIN
            nam := n_tree_locks;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (*ENDIF*) 
        IF  g01glob.treecheck
        THEN
            (* PTS 1103957 JA 1999-09-15 *)
            BEGIN
            nam := n_tree;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (* PTS 1107617 E.Z. *)
        (*ENDIF*) 
        ;
        (* PTS 1119690 E.Z. *)
        IF  NOT g01glob.bd_subtree
        THEN
            BEGIN
            v30 := n_st10_subtree_locks;
            nam := n_disabled;
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (* vtrSite removed: PTS 1103799 JA 1999-08-30 *)
        (*ENDIF*) 
        IF  g01vtrace.vtrSession_gg00.ci4_gg00 <> cgg_nil_session
        THEN
            BEGIN
            v30 := n_st11_vtrace_sess;
            ak42session_to_sname (g01vtrace.vtrSession_gg00, sizeof(nam), nam);
            ak42sname_statistic (acv, a41v, v30, nam)
            END;
        (* PTS 1110976 E.Z. *)
        (*ENDIF*) 
        IF  g01vtrace.vtrRetcodeCheck_gg00
        THEN
            BEGIN
            keyword := n_st11a_stop_on_err;
            nam := n_on;
            a42name_and_val_statistic (acv, a41v, keyword,
                  g01vtrace.vtrStopRetcode_gg00, nam);
            END;
        (* END PTS 1110976 E.Z. *)
        (*ENDIF*) 
        dev_type := sp2dt_log;
        devno    := 1;
        WHILE dev_type <> sp2dt_trace DO
            BEGIN
            b01next_bad_dev (dev_type, devno, devname, realy_bad);
            IF  devname <> b01blankfilename
            THEN
                BEGIN
                IF  realy_bad
                THEN
                    v30 := n_bad_volume
                ELSE
                    v30 := n_reintegration;
                (*ENDIF*) 
                ak42hostname_statistic (acv, a41v, v30, devname)
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42ref_i4_statistic (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            textpar  : tsp00_C40;    (* called with constants *)
            lint     : tsp00_Int4);
 
BEGIN
ak42ref_i4_stat_undef (acv, a41v, textpar, lint, false);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42ref_i4_stat_undef (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            textpar    : tsp00_C40;  (* called with constants *)
            lint       : tsp00_Int4;
            zero_undef : boolean);
 
VAR
      col_cnt : integer;
 
BEGIN
WITH acv, a41v  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak42prefix    (acv, a41v, col_cnt);
        a40move_const (acv, a41v, @textpar, sizeof (textpar));
        a40move_i4    (acv, a41v, lint, NOT c_null, 0, zero_undef);
        col_cnt := col_cnt + 2;
        WHILE col_cnt < a4p_arr.pinfop^.sbase.bmaxcol - 1 DO
            BEGIN
            col_cnt := col_cnt + 1;
            a40move (acv, a41v, NIL, 0)
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42ref_stat_real (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            textpar    : tsp00_C40;  (* called with constants *)
            lreal      : tsp00_Longreal);
 
VAR
      col_cnt : integer;
 
BEGIN
WITH acv, a41v  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak42prefix    (acv, a41v, col_cnt);
        a40move_const (acv, a41v, @textpar, sizeof (textpar));
        a40move_real  (acv, a41v, lreal, NOT c_null, 0);
        col_cnt := col_cnt + 2;
        WHILE col_cnt < a4p_arr.pinfop^.sbase.bmaxcol - 1 DO
            BEGIN
            col_cnt := col_cnt + 1;
            a40move (acv, a41v, NIL, 0)
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42prefix (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR col_cnt : integer);
 
BEGIN
WITH a41v DO
    BEGIN
    col_cnt := 0;
    CASE a4sh_kind OF
        sh_st_index, sh_odbc_st_index, sh_indexpages :
            BEGIN
            a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1, c_with_owner);
            IF  a4col_ptr = NIL
            THEN
                a40move (acv, a41v, @a4coln, sizeof (a4coln))
            ELSE
                a40move (acv, a41v, NIL, 0);
            (*ENDIF*) 
            IF  a4col_ptr <> NIL
            THEN
                a40move (acv, a41v, @a4col_ptr^.ccolumnn,
                      ord (a4col_ptr^.ccolumnn_len))
            ELSE
                a40move (acv, a41v, NIL, 0);
            (*ENDIF*) 
            col_cnt := 5
            END;
        sh_st_monitor :
            ak42monitor_type (acv, a41v, col_cnt);
        sh_st_table, sh_odbc_st_table,
        sh_pages :
            BEGIN
            a40table_column_to_shbuf (acv, a41v, a4p_arr.pbasep, -1, c_with_owner);
            col_cnt := 3
            END;
        OTHERWISE ;
        END;
    (*ENDCASE*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42monitor_type (
            VAR acv     : tak_all_command_glob;
            VAR a41v    : tak40_show_glob;
            VAR col_cnt : integer);
 
VAR
      c8 : tsp00_C8;
 
BEGIN
CASE a41v.a4ti OF
    cak_i_caches :
        c8 := 'CACHES  ';
    cak_i_load :
        c8 := 'LOAD    ';
    cak_i_lock :
        c8 := 'LOCK    ';
    cak_i_log :
        c8 := 'LOG     ';
    cak_i_long :
        c8 := 'LONG    ';
    cak_i_pages :
        c8 := 'PAGES   ';
    cak_i_row :
        c8 := 'ROW     ';
    cak_i_serverdb :
        c8 := 'SERVERDB';
    cak_i_transaction :
        c8 := 'TRANS   ';
    cak_i_object :
        c8 := 'OBJECT  ';
    cak_i_trim :
        c8 := 'REWRITE ';
    END;
(*ENDCASE*) 
a40move_const (acv, a41v, @c8, sizeof (c8));
col_cnt := 1
END;
 
(*------------------------------*) 
 
FUNCTION
      ak42evalpercent (cnt, max : tsp00_Int4) : tsp00_Int4;
 
BEGIN
IF  (cnt > 0) AND (max > 0)
THEN
    BEGIN
    IF  max >= (MAX_INT4_SP00 DIV 1000)
    THEN
        BEGIN
        max := max DIV 1000;
        cnt := cnt DIV 1000
        END;
    (*ENDIF*) 
    cnt             := cnt * 1000;
    ak42evalpercent := ((cnt DIV max) + 5) DIV 10
    END
ELSE
    ak42evalpercent := 0
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak42evalpercent_cnt (cnt, max : tsp00_8ByteCounter) : tsp00_Int4;
 
BEGIN
(* PTS 1103743 JA 1999-08-25 *)
IF  (cnt > 0) AND (max > 0)
THEN
    BEGIN
    ak42evalpercent_cnt := round (cnt * 100 / max);
    END
ELSE
    ak42evalpercent_cnt := 0
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak42evalpercent_real (cnt, max : tsp00_Longreal) : tsp00_Int4;
 
BEGIN
IF  (cnt > 0) AND (max > 0)
THEN
    BEGIN
    ak42evalpercent_real := round (cnt * 100 / max);
    END
ELSE
    ak42evalpercent_real := 0
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42datab_statistic (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            v30      : tsp00_C30;    (* called with constants *)
            lint     : tsp00_Int4);
 
BEGIN
ak42datab_stat_undef (acv, a41v, v30, lint, false);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42datab_stat_undef (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            v30        : tsp00_C30;  (* called with constants *)
            lint       : tsp00_Int4;
            zero_undef : boolean);
 
VAR
      col_cnt  : integer;
 
BEGIN
WITH acv, a41v  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak42prefix (acv, a41v, col_cnt);
        a40move_const (acv, a41v, @v30, sizeof (v30));
        a40move_i4 (acv, a41v, lint,
              NOT c_null, 0, zero_undef);
        a40move    (acv, a41v, NIL, 0)
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42user_statistics  (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a4sh_kind := sh_st_user;
    a40get_catalog_table (acv, a41v);
    IF  a_returncode = 0
    THEN
        BEGIN
        a4sysbuf := NIL;
        IF  a4authname = a01_il_b_identifier
        THEN
            IF  (a_current_user_kind = usysdba) OR
                (a_current_user_kind = udba)    OR
                (a_current_user_kind = ucontroluser)
            THEN
                ak42all_user_st_show (acv, a41v)
            ELSE
                BEGIN
                a4authname := a_curr_user_name;
                ak42one_st_user_show (acv, a41v, true)
                END
            (*ENDIF*) 
        ELSE
            BEGIN
            IF  a4authname = a01_i_current
            THEN
                a4authname := a_curr_user_name;
            (*ENDIF*) 
            ak42one_st_user_show (acv, a41v, true);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42all_user_st_show  (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      statementId : tsp00_Int4;
 
BEGIN
statementId := a101_RegisterCurrentStatement (acv);
acv.a_command_sequence := acv.a_command_sequence + 1;
acv.a_command_id       := acv.a_command_sequence;
a103AllUserStatistics (acv, a41v);
a101_UnregisterStatement (acv, statementId);
acv.a_command_id := statementId;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42UserStatisticsCallback (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            pUser    : tak_sysbufferaddress);
 
BEGIN
IF  pUser^.suser.userkind <> ucontroluser
THEN
    BEGIN
    a41v.a4sysbuf   := pUser;
    a41v.a4authname := pUser^.suser.username;
    ak42one_st_user_show (acv, a41v, false);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42one_st_user_show (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            one_show  : boolean);
 
VAR
      ok             : boolean;
      counting       : boolean;
      is_dba         : boolean;
      b_err          : tgg00_BasisError;
      priv_count     : tsp00_Int4;
      init_username  : tsp00_KnlIdentifier;
      init_userid    : tgg00_Surrogate;
      ukind          : tsp00_C8;
      userkey        : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    counting   := (a_ex_kind <> only_parsing);
    priv_count := 0;
    IF  a4sysbuf = NIL
    THEN
        BEGIN
        a06check_username (acv, a4authname, is_dba, ok);
        IF  NOT (ok)
        THEN
            counting := false
        ELSE
            BEGIN (* privilege check *)
            userkey := a01defaultkey;
            a51build_userkey (a4authname, a4sysk);
            a10get_sysinfo (acv, a4sysk, d_release, a4sysbuf, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                userkey.sauthid := a4sysbuf^.suserref.ru_user_id;
                userkey.sentrytyp := cak_euser;
                a10get_sysinfo (acv, userkey, d_fix, a4sysbuf, b_err);
                END;
            (*ENDIF*) 
            IF  b_err <> e_ok
            THEN
                counting := false;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  counting AND (a_returncode = 0)
    THEN
        WITH a4sysbuf^.suser DO
            IF  NOT (one_show)
            THEN
                BEGIN
                IF  a4authname <> a_curr_user_name
                THEN
                    IF  NOT a21is_owner (acv, a4sysbuf^.suser)
                    THEN
                        counting := false;
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                IF  NOT (is_group_rec in urecordtyp)
                THEN
                    a07_b_put_error (acv,
                          e_group_user_not_allowed,
                          a_ap_tree^[ a4ti ].n_pos)
                ELSE
                    IF  (a4authname        <> a_curr_user_name) AND
                        (userkey.sauthid <> usergroup_id)
                    THEN
                        IF  NOT a21is_owner (acv, a4sysbuf^.suser)
                        THEN
                            a07_b_put_error (acv, e_unknown_user,
                                  a_ap_tree^[ a4ti ].n_pos);
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  (a_returncode = 0) AND (counting)
    THEN
        BEGIN (* determine permanent user space *)
        init_username       := a_curr_user_name;
        init_userid         := a_curr_user_id;
        a_curr_user_name    := a4authname;
        is_dba := a4sysbuf^.suser.userkind in [udba, usysdba];
        IF  is_dba
        THEN
            a4authname := a01_il_b_identifier;
        (*ENDIF*) 
        a_curr_user_id      := a4sysbuf^.syskey.sauthid;
        a40init_table_scan (acv, a41v,
              false, true, is_dba, false, false, false);
        WHILE a40next_table (acv, a41v) DO
            WITH a4p_arr.pbasep^.sbase DO
                IF  ((btablekind = twithkey)
                    OR
                    (btablekind = twithoutkey))
                    AND
                    (bauthid = a_curr_user_id)
                    AND
                    (NOT a101_IsExtendedTempFile (acv, btreeid))
                THEN
                    a42_get_pagecount (acv,
                          a4p_arr.pbasep, priv_count);
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDWHILE*) 
        a40FinishTableScan (acv, a41v);
        a4authname          := a_curr_user_name;
        a_curr_user_name    := init_username;
        a_curr_user_id      := init_userid;
        END;
    (*ENDIF*) 
    IF  (a_returncode = 0)  AND  (counting)
    THEN
        BEGIN
        (*============================================*)
        (* return results, send them to bd            *)
        (*============================================*)
        WITH a4sysbuf^.suser DO
            BEGIN
            a40move (acv, a41v, @a4authname, sizeof (a4authname));
            CASE userkind OF
                udba      :
                    ukind := u_dba;
                uprivate  :
                    ukind := u_resource;
                OTHERWISE
                    ukind := u_standard;
                END;
            (*ENDCASE*) 
            a40move_const (acv, a41v, @ukind, sizeof (ukind));
            a40move_i4 (acv, a41v, priv_count,
                  (userkind = unoprivate), 0, NOT c_to_undef);
            IF  a4authname <> a_curr_user_name
            THEN
                a40move (acv, a41v, NIL, 0)
            ELSE
                a40move_i4 (acv, a41v,
                      a_transinf.tri_trans.trTempCount_gg00,
                      NOT c_null, 0, NOT c_to_undef);
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  (a_returncode = 0) AND (a4sysbuf <> NIL)
    THEN
        a10_key_del (acv, a4sysbuf^.syskey);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42show_config  (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
CONST
      c_with_zero = true;
 
VAR
      kb_factor       : integer;
      i               : tsp00_Int4;
      no_of_data_devs : tsp00_Int4;
      no_of_log_devs  : tsp00_Int4;
      totalPages      : tsp00_Int4;
      unMapPages      : tsp00_Int4;
      nam             : tsp00_Sname;
      v30             : tsp00_C30;
      devname         : tsp2_devname;
 
BEGIN
bd01DataCacheSize( totalPages, unMapPages );
WITH acv, a41v DO
    BEGIN
    a4sh_kind := sh_st_config;
    a40get_catalog_table (acv, a41v);
    IF  (a_ex_kind <> only_parsing) AND
        (a_returncode = 0)
    THEN
        BEGIN
        v30 := n_cf01_defaultcode;
        CASE g01code.char_default OF
            csp_ascii:
                nam := n_ascii;
            csp_codeneutral:
                nam := n_internal;
            csp_unicode:
                nam := n_unicode;
            OTHERWISE
                nam := bsp_sname;
            END;
        (*ENDCASE*) 
        ak42sname_statistic (acv, a41v, v30, nam);
        v30 := n_cf02_date_time;
        CASE g01code.date_time OF
            dtf_normal :
                nam := n_internal;
            dtf_eur, dtf_ts_eur :
                nam := n_eur;
            dtf_iso    :
                nam := n_iso;
            dtf_jis    :
                nam := n_jis;
            dtf_usa    :
                nam := n_usa;
            OTHERWISE
                nam := bsp_sname;
            END;
        (*ENDCASE*) 
        ak42sname_statistic (acv, a41v, v30, nam);
        ak42datab_statistic (acv, a41v, n_cf04_sesstimeout, g01timeout.timeCmd_gg00);
        ak42datab_statistic (acv, a41v, n_cf06_req_timeout, g01timeout.timeReq_gg00);
        v30 := n_logmode;
        IF  bd999LogIsMirrored
        THEN
            nam := 'DUAL        '
        ELSE
            nam := 'SINGLE      ';
        (*ENDIF*) 
        ak42sname_statistic (acv, a41v, v30, nam);
        ak42datab_statistic (acv, a41v, n_segmsize, g01autosave_distance);
        no_of_log_devs := b01no_of_log_devs;
        ak42datab_statistic (acv, a41v, n_cf08_no_of_logs, no_of_log_devs);
        no_of_data_devs := b01no_of_data_devs;
        ak42datab_statistic (acv, a41v, n_cf09_no_of_devs, no_of_data_devs);
        v30 := n_cf10_mirror_dev;
        nam := n_no;
        ak42sname_statistic (acv, a41v, v30, nam);
        FOR i := 1 TO no_of_log_devs DO
            BEGIN
            v30 := n_cf_logdev_size;
            g17int4to_line (i, NOT c_with_zero, 2, 12, v30);
            ak42datab_statistic (acv, a41v, v30, b01devsize (sp2dt_log, i))
            END;
        (*ENDFOR*) 
        FOR i := 1 TO no_of_log_devs DO
            BEGIN
            v30 := n_cf_logdev_name;
            g17int4to_line (i, NOT c_with_zero, 2, 12, v30);
            b01get_devname (sp2dt_log, i, devname);
            ak42hostname_statistic (acv, a41v, v30, devname);
            IF  bd999LogIsMirrored
            THEN
                nam := 'DUAL        '
            ELSE
                nam := 'SINGLE      ';
            (*ENDIF*) 
            IF  nam = 'DUAL        '
            THEN
                BEGIN
                v30 [14] := '''';
                b01get_devname (sp2dt_mirr_log, i, devname);
                ak42hostname_statistic (acv, a41v, v30, devname)
                END
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        FOR i := 1 TO no_of_data_devs DO
            BEGIN
            v30 := n_cf_dev_size;
            g17int4to_line (i, NOT c_with_zero, 3, 14, v30);
            ak42datab_statistic (acv, a41v, v30, b01devsize (sp2dt_data, i))
            END;
        (*ENDFOR*) 
        FOR i := 1 TO no_of_data_devs DO
            BEGIN
            v30 := n_cf_dev_name;
            g17int4to_line (i, NOT c_with_zero, 3, 14, v30);
            b01get_devname (sp2dt_data, i, devname);
            ak42hostname_statistic (acv, a41v, v30, devname);
            END;
        (*ENDFOR*) 
        (* PTS 1112851 *)
        kb_factor := PAGE_MXSP00 DIV 1024;
        ak42datab_statistic (acv, a41v, n_cf11_converter_sz, bd01ConverterSize * kb_factor);
        ak42datab_statistic (acv, a41v, n_cf12_datacache_sz, totalPages * kb_factor);
        IF  RTEMem_AWEAvailable (* PTS 1114026 *)
        THEN
            BEGIN
            ak42datab_statistic (acv, a41v,
                  n_cf13_awe_mapped, (totalPages - unMapPages) * kb_factor);
            ak42datab_statistic (acv, a41v,
                  n_cf14_awe_unmapped, unMapPages * kb_factor);
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42show_version (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      rdsvers  : tsp00_Version;
      lzuvers  : tsp00_Version;
 
BEGIN
WITH acv, a41v  DO
    BEGIN
    a4sh_kind := sh_version_old;
    a40get_catalog_table (acv, a41v);
    IF  (a_ex_kind <> only_parsing) AND
        (a_returncode = 0)
    THEN
        BEGIN
        g11kernel_version (rdsvers);
        vversion (rdsvers, lzuvers);
        a40move_const (acv, a41v, @rdsvers, sizeof (rdsvers));
        a40move_const (acv, a41v, @lzuvers, sizeof (lzuvers));
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42iindex_statistics   (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob);
 
VAR
      colindex       : integer;
      null_value     : tsp00_KnlIdentifier;
      indexname      : tsp00_KnlIdentifier;
      index_scan_rec : tak_index_scan_record;
      data           : tgg00_SampleInfo;
      qual           : tgg00_QualBuf;
      mblock         : tgg00_MessBlock;
      _work_buf      : tak40_int2_arr_ptr;
 
BEGIN
g01mblock_init (acv.a_transinf.tri_trans, m_nil, mm_nil, mblock);
g01stack_init    (mblock, NIL, 0, @qual, sizeof (qual));
g01datapart_init (mblock, @data, sizeof (data));
WITH acv, a41v DO
    BEGIN
    IF  a4p_arr.pbasep^.sbase.bindexexist
    THEN
        BEGIN
        a722init_epos_reccol_relation( acv, _work_buf );
        a24init_index_scan (acv, a4p_arr.pbasep^.sbase.bsurrogate,
              index_scan_rec);
        WITH index_scan_rec DO
            WHILE a24next_named_index (acv, index_scan_rec) DO
                WITH isr_buf^.smindex.indexdef[isr_index] DO
                    IF  indexno <> 0
                    THEN
                        WITH a4p_arr.pbasep^.sbase DO
                            BEGIN
                            a24get_indexname (acv, isr_buf, isr_index,
                                  indexname);
                            colindex := bextcolindex[icolseq[1]] + bfirstindex;
                            IF  (
                                a722test_col_qual (acv,
                                a41v, cak_ln_indexname, ' ', @indexname,
                                sizeof(indexname), _work_buf)
                                AND
                                a722test_col_qual (acv, a41v,
                                cak_ln_columnname, csp_undef_byte,
                                @null_value, 1, _work_buf)
                                )
                            THEN
                                BEGIN
                                (* PTS 1114312, T.A. removed code for unnamed indexes *)
                                a4col_ptr := NIL;
                                a4coln    := indexname;
                                ak42one_index_statistics (acv, a41v.a4sh_kind,
                                      a4p_arr.pbasep^.sbase,icolstack[1],
                                      mblock);
                                IF  a_returncode = 0
                                THEN
                                    ak42print_stat_tab_index (acv,
                                          a41v, mblock, true);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDWITH*) 
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDWHILE*) 
        (*ENDWITH*) 
        a24finish_index_scan (acv, index_scan_rec);
        a722finalize_epos_reccol_relation( acv, _work_buf );
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42table_statistics   (
            VAR acv    : tak_all_command_glob;
            VAR a41v   : tak40_show_glob;
            pages_only : boolean);
 
CONST
      c_estimate_pages = 7;
      c_shortcol_pages = 8;
 
VAR
      estimate_pages : boolean;
      b_err          : tgg00_BasisError;
      page_cnt       : tsp00_Int4;
      val1           : tsp00_Int4;
      val2           : tsp00_Int4;
      treeid         : tgg00_FileId;
      qual           : tgg00_QualBuf;
      data           : tgg00_SampleInfo;
      mblock         : tgg00_MessBlock;
 
BEGIN
WITH acv, a41v DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'a4sh_kind   ', ord (a4sh_kind));
&   endif
    IF  (a_returncode = 0) AND
        (a_ex_kind <> only_parsing)
    THEN
        IF  pages_only
        THEN
            BEGIN
            page_cnt       := MAX_INT4_SP00;
            treeid         := a4p_arr.pbasep^.sbase.btreeid;
            treeid.fileLeafNodes_gg00 := cgg_nil_leafnodes;
            estimate_pages := a4strategy.str_catalog.scat_col_needed[c_estimate_pages];
            a06get_page_cnt (acv, treeid, estimate_pages, page_cnt, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                IF  estimate_pages
                THEN
                    BEGIN
                    val1 := 0;
                    val2 := page_cnt
                    END
                ELSE
                    BEGIN
                    val1 := page_cnt;
                    val2 := 0
                    END;
                (*ENDIF*) 
                ak42datab_statistic (acv, a41v, n_tab05_leafnodes, val1);
                a40move_i4 (acv, a41v, val2, NOT c_null, 0, c_to_undef);
                (* h.b. PTS 1107063 *)
                val1 := 0;
                IF  (a4p_arr.pbasep^.sbase.bstringcount > 0) AND
                    (a4strategy.str_catalog.scat_col_needed[c_shortcol_pages])
                THEN
                    BEGIN
                    g04short_col_tree_build (treeid.fileTabId_gg00, treeid,
                          b_err);
                    IF  b_err = e_ok
                    THEN
                        a06get_page_cnt (acv, treeid,
                              estimate_pages, page_cnt, b_err);
                    (*ENDIF*) 
                    IF  b_err = e_ok
                    THEN
                        val1 := page_cnt
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                a40move_i4 (acv, a41v, val1, NOT c_null, 0, c_to_undef);
                END
            ELSE
                a07_b_put_error (acv, b_err, 1)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            g01mblock_init (a_transinf.tri_trans,
                  m_nil, mm_nil, mblock);
            g01stack_init    (mblock, NIL, 0, @qual, sizeof (qual));
            g01datapart_init (mblock, @data, sizeof (data));
            ak42table_statistics (acv, a4p_arr.pbasep^.sbase, mblock);
            IF  a_returncode = 0
            THEN
                BEGIN
                ak42print_stat_tab_index (acv, a41v, mblock, false);
                (*== test if implicit update statistics is usefull =*)
                WITH a4p_arr.pbasep^.sbase DO
                    a28sys_upd_statistics (acv, btreeid, m_select_row, mm_next,
                          bpages, mblock.mb_data^.mbp_sample.nodes);
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42one_index_statistics (
            VAR acv         : tak_all_command_glob;
            show_kind       : tgg00_ShowKind;
            VAR baserec     : tak_baserecord;
            VAR st_entry    : tgg00_StackEntry;
            VAR mblock      : tgg00_MessBlock);
 
CONST
      c_do_estimate = true;
 
VAR
      b_err    : tgg00_BasisError;
      tree     : tgg00_FileId;
 
BEGIN
IF  show_kind = sh_indexpages
THEN
    BEGIN
    g04index_tree_build (baserec.btreeid, tree, ord(st_entry.ecol_tab[1]));
    a06get_page_cnt (acv, tree, NOT c_do_estimate,
          mblock.mb_data^.mbp_sample.nodes, b_err);
    IF  b_err = e_file_not_accessible
    THEN
        BEGIN
        mblock.mb_data^.mbp_sample.nodes := 0;
        b_err                            := e_ok
        END;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    mblock.mb_type           := m_index_statistic;
    mblock.mb_type2          := mm_test;
    g01stack_init (mblock, @st_entry, sizeof (st_entry),
          mblock.mb_qual, mblock.mb_qual_size);
    a06set_mtree (acv, mblock, baserec.btreeid);
    (* h.b. PTS 1104683 *)
    mblock.mb_data^.mbp_sample.sam_rows    := c_undefined;
    mblock.mb_data^.mbp_sample.sam_percent := c_100_pct;
    (* h.b. PTS 1115096 *)
    mblock.mb_data^.mbp_sample.sam_with_long := true;
    mblock.mb_data^.mbp_sample.sam_fill1     := false;
    mblock.mb_data^.mbp_sample.sam_fill2     := 0;
    WITH mblock.mb_qual^ DO
        BEGIN
        mmult_pos   := 1;
        mmult_cnt   := 1;
        mfirst_free := 2
        END;
    (*ENDWITH*) 
    a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
    IF  b_err = e_file_not_accessible
    THEN
        BEGIN
        SAPDB_PascalForcedFill (mblock.mb_qual_size, @mblock.mb_qual^.buf, 1,
              mblock.mb_qual_size, chr(0));
        b_err := e_ok;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42table_statistics (
            VAR acv      : tak_all_command_glob;
            VAR baserec  : tak_baserecord;
            VAR mblock   : tgg00_MessBlock);
 
VAR
      b_err   : tgg00_BasisError;
      colindex: integer;
 
BEGIN
mblock.mb_type  := m_table_statistic;
mblock.mb_type2 := mm_nil;
IF  baserec.bstringcount > 0
THEN
    BEGIN
    mblock.mb_type2 := mm_string;
    WITH baserec DO
        FOR colindex := bfirstindex TO blastindex DO
            WITH a103GetColumn (baserec, colindex)^ DO
                IF  NOT (ctdropped in ccolpropset) AND
                    (cdatatyp in [ dstra, dstrb, dstruni ])
                THEN
                    mblock.mb_type2 := mm_nil;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDFOR*) 
    (*ENDWITH*) 
    END;
(*ENDIF*) 
mblock.mb_qual^.mtree                    := baserec.btreeid;
mblock.mb_qual^.mtree.fileLeafNodes_gg00 := cgg_nil_leafnodes;
mblock.mb_qual^.mtree.fileHandling_gg00  := [hsWithoutLock_egg00];
mblock.mb_data^.mbp_sample.sam_rows      := c_undefined;
mblock.mb_data^.mbp_sample.sam_percent   := c_100_pct;
(* h.b. PTS 1115096 *)
mblock.mb_data^.mbp_sample.sam_with_long := true;
mblock.mb_data^.mbp_sample.sam_fill1     := false;
mblock.mb_data^.mbp_sample.sam_fill2     := 0;
a06rsend_mess_buf (acv, mblock, cak_return_req, b_err);
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42print_stat_tab_index   (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            VAR mblock    : tgg00_MessBlock;
            selectivity   : boolean);
 
VAR
      col_cnt : integer;
      v30     : tsp00_C30;
      nam     : tsp00_Sname;
 
BEGIN
WITH acv, a41v , mblock.mb_data^.mbp_sample  DO
    CASE  a4sh_kind OF
        sh_odbc_st_index, sh_odbc_st_table :
            BEGIN
            ak42prefix (acv, a41v, col_cnt);
            IF  a4sh_kind = sh_odbc_st_index
            THEN
                a40move_i4 (acv, a41v, sec_key_cnt,
                      NOT c_null, 0, NOT c_to_undef)
            ELSE
                a40move_i4 (acv, a41v, records,
                      NOT c_null, 0, NOT c_to_undef);
            (*ENDIF*) 
            a40move_i4 (acv, a41v, nodes, NOT c_null, 0, NOT c_to_undef)
            END;
        sh_indexpages :
            ak42datab_statistic (acv, a41v, n_tab05_leafnodes, nodes);
        OTHERWISE
            BEGIN
            ak42datab_statistic (acv, a41v, n_tab01_root, rootsegm);
            IF  a101_IsExtendedTempFile (acv, mblock.mb_data^.mbp_sample.sam_tree_id)
            THEN
                BEGIN
                IF  ftsConcurrent_egg00 in smplFileType_gg00
                THEN
                    nam := n_temp_concurr
                ELSE
                    nam := n_temp
                (*ENDIF*) 
                END
            ELSE
                IF  ftsPerm_egg00 in smplFileType_gg00
                THEN
                    nam := n_perm
                ELSE
                    IF  ftsByteStr_egg00 in smplFileType_gg00
                    THEN
                        nam := n_bytestr
                    ELSE
                        nam := n_unknown;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            v30 := n_tab02_filetype;
            ak42sname_statistic  (acv, a41v, v30, nam);
            ak42datab_statistic  (acv, a41v, n_tab03_nodes,      nodes);
            ak42datab_statistic  (acv, a41v, n_tab04_indexnodes, indexnodes);
            ak42datab_statistic  (acv, a41v, n_tab05_leafnodes,  leafnodes);
            ak42datab_statistic  (acv, a41v, n_tab06_hight,      hight);
            ak42datab_statistic  (acv, a41v, n_tab07_covering,   treecov);
            ak42datab_statistic  (acv, a41v, n_tab08_croot,      rootcov);
            ak42datab_statistic  (acv, a41v, n_tab09_cindex,     indexcov);
            ak42ref_i4_statistic (acv, a41v, n_tab10_cmin,       min_indexcov);
            ak42ref_i4_statistic (acv, a41v, n_tab11_cmax,       max_indexcov);
            ak42datab_statistic  (acv, a41v, n_tab12_cleaf,      leafcov);
            ak42ref_i4_statistic (acv, a41v, n_tab13_lmin,       min_leafcov);
            ak42ref_i4_statistic (acv, a41v, n_tab14_lmax,       max_leafcov);
            IF  a4sh_kind in [sh_st_table]
            THEN
                BEGIN
                ak42datab_statistic  (acv, a41v, n_tab15_rows, records);
                ak42datab_stat_undef (acv, a41v, n_tab16_rows_per, rec_per_page, (records <> 0));
                ak42datab_statistic  (acv, a41v, n_tab17_min_rows, min_rec_per_page);
                ak42datab_statistic  (acv, a41v, n_tab18_max_rows, max_rec_per_page);
                ak42datab_stat_undef (acv, a41v, n_tab19_avg_rowlen,
                      ave_rec_length, (max_rec_length = 0));
                ak42datab_stat_undef (acv, a41v, n_tab20_min_rowlen,
                      min_rec_length, (max_rec_length = 0));
                ak42datab_stat_undef (acv, a41v, n_tab21_max_rowlen, max_rec_length, true);
                ak42datab_stat_undef (acv, a41v, n_tab22_avg_keylen, ave_key_length, (max_key_length = 0));
                ak42datab_stat_undef (acv, a41v, n_tab23_min_keylen, min_key_length, (max_key_length = 0));
                ak42datab_stat_undef (acv, a41v, n_tab24_max_keylen, max_key_length, true);
                ak42datab_stat_undef (acv, a41v, n_tab25_avg_seplen, ave_sep_length, (max_sep_length = 0));
                ak42datab_stat_undef (acv, a41v, n_tab26_min_seplen, min_sep_length, (max_sep_length = 0));
                ak42datab_stat_undef (acv, a41v, n_tab27_max_seplen, max_sep_length, true);
                ak42datab_statistic  (acv, a41v, n_tab28_def_str,    defined_stringcols);
                ak42datab_stat_undef (acv, a41v, n_tab29_avg_strlen,
                      ave_len_stringcol, defined_stringcols = 0);
                ak42datab_stat_undef (acv, a41v, n_tab30_min_strlen,
                      min_len_stringcol, defined_stringcols = 0);
                ak42datab_stat_undef (acv, a41v, n_tab31_max_strlen,
                      max_len_stringcol, defined_stringcols = 0);
                ak42datab_statistic (acv, a41v,  n_tab32_str_pages, all_stringcol_pages);
                ak42datab_stat_undef (acv, a41v, n_tab33_avg_spages,
                      ave_stringcol_pages, all_stringcol_pages = 0);
                ak42datab_stat_undef (acv, a41v, n_tab34_min_spages,
                      min_stringcol_pages, all_stringcol_pages = 0);
                ak42datab_stat_undef (acv, a41v, n_tab35_max_spages,
                      max_stringcol_pages, all_stringcol_pages = 0);
                END
            ELSE
                BEGIN
                ak42datab_statistic  (acv, a41v, n_inv01_cnt_seckey, sec_key_cnt);
                ak42datab_stat_undef (acv, a41v, n_inv02_avg_seclen, avg_sec_key_len, max_sec_key_len = 0);
                ak42datab_statistic  (acv, a41v, n_inv03_min_seclen, min_sec_key_len);
                ak42datab_statistic  (acv, a41v, n_inv04_max_seclen, max_sec_key_len);
                ak42datab_stat_undef (acv, a41v, n_tab25_avg_seplen, ave_sep_length, (max_sep_length = 0));
                ak42datab_stat_undef (acv, a41v, n_tab26_min_seplen, min_sep_length, (max_sep_length = 0));
                ak42datab_stat_undef (acv, a41v, n_tab27_max_seplen, max_sep_length, true);
                ak42datab_statistic  (acv, a41v, n_inv05_cnt_prim,   prim_key_cnt);
                ak42datab_stat_undef (acv, a41v, n_inv06_avg_listl,
                      avg_prim_per_list DIV 10, prim_key_cnt=0);
                ak42datab_statistic  (acv, a41v, n_inv07_min_listl,  min_prim_per_list);
                ak42datab_statistic  (acv, a41v, n_inv08_max_listl,  max_prim_per_list);
                IF  selectivity
                THEN
                    BEGIN
                    ak42datab_stat_undef (acv, a41v, n_select01,      invsel_1,      false);
                    ak42datab_stat_undef (acv, a41v, n_select05,      invsel_5,      false);
                    ak42datab_stat_undef (acv, a41v, n_select10,      invsel_10,     false);
                    ak42datab_stat_undef (acv, a41v, n_select25,      invsel_25,     false);
                    ak42datab_stat_undef (acv, a41v, n_select_notsel, invsel_notsel, false);
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        END;
    (*ENDCASE*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42_check_database (VAR acv : tak_all_command_glob);
 
VAR
      res            : tsp00_NumError;
      number         : tsp00_Number;
      i              : integer;
      sizes          : ARRAY [1..2] OF tsp00_Int4;
      parsid         : tak_parsid;
      db_space_info  : tgg00_DbSpaceInfo;
      log_device_info: tkb00_LogDeviceInfo;
      log_queue_info : tkb00_LogQueueInfo;
      name           : tak_oldidentifier;
 
BEGIN
WITH acv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  a_ex_kind = only_parsing
        THEN
            BEGIN
            (*=============================*)
            (* Shortinfo ==> return part   *)
            (*=============================*)
            ak42check_db_shortinfos (acv);
            (*=============================*)
            (* Parsid    ==> return part   *)
            (*=============================*)
            parsid.pid_session       := a_transinf.tri_trans.trSessionId_gg00;
            parsid.pid_parsk         := a_pars_last_key;
            parsid.pid_parsk.p_kind  := m_check_database;
            parsid.pid_appl_info [1] := chr(ord(a_precomp_info_byte));
            parsid.pid_dtime_info[1] := chr(ord(dtf_none));
            a06retpart_move        (acv, @parsid, sizeof (parsid));
            a06finish_curr_retpart (acv, sp1pk_parsid, 1)
            END
        ELSE
            BEGIN
            b01dbspace_statistic (a_transinf.tri_trans, db_space_info);
            IF  a_transinf.tri_trans.trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
            ELSE
                BEGIN
                kb560GetStatistics (a_transinf.tri_trans.trTaskId_gg00, log_device_info, log_queue_info);
                sizes[1] := ak42evalpercent (db_space_info.db_used_pages, db_space_info.db_total_pages);
                sizes[2] := ak42evalpercent (log_device_info.ldiPagesUsed_kb00, kb560GetLogDeviceSize);
                (* colnames into ret part *)
                (* PTS 1113268 E.Z. *)
                name := ln_serverdb;
                a06colname_retpart_move (acv, @name, 8, csp_ascii);
                name := ln_log;
                a06colname_retpart_move (acv, @name, 3, csp_ascii);
                a06finish_curr_retpart (acv, sp1pk_columnnames, 2);
                (* short infos into retpart *)
                ak42check_db_shortinfos (acv);
                (* values into retpart *)
                FOR i := 1 TO 2 DO
                    BEGIN
                    s41plint (number, 2, 2, 0, sizes[ i ], res);
                    IF  res <> num_ok
                    THEN
                        number[1] := csp_undef_byte
                    ELSE
                        number[1] := csp_defined_byte;
                    (*ENDIF*) 
                    a06retpart_move (acv, @number[1], sizeof (tsp00_C3))
                    END;
                (*ENDFOR*) 
                a06finish_curr_retpart (acv, sp1pk_data, 2)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        (* PTS 1116801 E.Z. *)
        a_result_name := a01_zero_res_name
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42check_db_shortinfos (VAR acv : tak_all_command_glob);
 
VAR
      param_info  : tsp1_param_info;
 
BEGIN
WITH param_info DO
    BEGIN
    sp1i_mode     := [sp1ot_mandatory];
    sp1i_io_type   := sp1io_output;
    sp1i_data_type := dfixed;
    sp1i_frac     := 0;
    sp1i_length   := 2;
    sp1i_in_out_len := 3;
    sp1i_bufpos   := 1;
    a06retpart_move (acv,
          @param_info, sizeof (param_info));
    sp1i_bufpos := sp1i_bufpos + sp1i_in_out_len;
    a06retpart_move (acv,
          @param_info, sizeof (param_info));
    END;
(*ENDWITH*) 
a06finish_curr_retpart (acv, sp1pk_shortinfo, 2)
END;
 
(* PTS 1113134 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak42snullname_statistic (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR v30  : tsp00_C30);
 
VAR
      col_cnt : integer;
 
BEGIN
WITH acv, a41v  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak42prefix    (acv, a41v, col_cnt);
        a40move_const (acv, a41v, @v30, sizeof (v30));
        a40move (acv, a41v, NIL, 0);
        a40move_const (acv, a41v, NIL, 0)
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42sname_statistic (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR v30  : tsp00_C30;
            VAR nam  : tsp00_Sname);
 
VAR
      col_cnt : integer;
 
BEGIN
WITH acv, a41v  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak42prefix    (acv, a41v, col_cnt);
        a40move_const (acv, a41v, @v30, sizeof (v30));
        a40move (acv, a41v, NIL, 0);
        a40move_const (acv, a41v, @nam, sizeof (nam))
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42name_and_val_statistic (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR vkw  : tak_keyword;
            value    : tsp00_Int4;
            VAR nam  : tsp00_Sname);
 
VAR
      col_cnt : integer;
 
BEGIN
WITH acv, a41v  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        ak42prefix    (acv, a41v, col_cnt);
        a40move_const (acv, a41v, @vkw, sizeof (vkw));
        IF  value = MAX_INT4_SP00
        THEN
            a40move (acv, a41v, NIL, 0)
        ELSE
            a40move_i4 (acv, a41v, value,
                  NOT c_null, 0, NOT c_to_undef);
        (*ENDIF*) 
        a40move_const (acv, a41v, @nam, sizeof (nam))
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42hostname_statistic (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR v30  : tsp00_C30;
            VAR nam  : tsp00_VFilename);
 
BEGIN
WITH acv  DO
    IF  a_returncode = 0
    THEN
        BEGIN
        a40move_const (acv, a41v, @v30, sizeof (v30));
        a40move (acv, a41v, NIL, 0);
        a40move_const (acv, a41v, @nam, sizeof (nam))
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42get_refinfo (
            VAR acv  : tak_all_command_glob;
            VAR info : tgg00_ReferenceInfo);
 
VAR
      procid            : tsp00_TaskId;
      (**)
      _sseq_cache_total : tsp00_8ByteCounter;           (* PTS 1103743 JA 1999-08-25 *)
      _sseq_cache_hit   : tsp00_8ByteCounter;
      _sseq_cache_miss  : tsp00_8ByteCounter;
      (**)
      lock_info         : tkb05_LockInfo;
      log_queue_info    : tkb00_LogQueueInfo;
      log_device_info   : tkb00_LogDeviceInfo;
 
BEGIN
(* PTS 1103033 E.Z.; PTS 1103743 JA 1999-08-25 *)
WITH acv, info DO
    BEGIN
    b01show_monitor  (a_transinf.tri_trans.trTaskId_gg00, info);
    (* PTS 1103735 E.Z. *)
    (* PTS 1111134 E.Z. *)
    k720show_monitor (info);
    procid := a_transinf.tri_trans.trTaskId_gg00;
    (* *)
    kb560GetStatistics (procid, log_device_info, log_queue_info);
    WITH log_queue_info DO
        BEGIN
        reference_array [ ilog_queue_size    ] := lqiLogQueueSize_kb00;
        reference_array [ icount_group       ] := lqiCountGroup_kb00;
        reference_array [ icount_insert      ] := lqiCountInsert_kb00;
        reference_array [ icount_request     ] := lqiCountRequest_kb00;
        reference_array [ icount_wait        ] := lqiCountWait_kb00;
        reference_array [ imaxqueue_used     ] := lqiMaxQueueUsed_kb00;
        reference_array [ imaxwait_logpage   ] := lqiMaxWaitLogpage_kb00;
        reference_array [ iavg_sum_pagewaits ] := lqiAvgSumPagewaits_kb00
        END;
    (*ENDWITH*) 
    k51info_lock (procid, lock_info);
    WITH lock_info DO
        BEGIN
        reference_array [ iavg_lock_used    ] := infAvgUsed_kb05;
        reference_array [ imax_lock_used    ] := infMaxUsed_kb05;
        reference_array [ icollisions       ] := infSqlCollisions_kb05; (* PTS 1105492 JA 2000-03-15 *)
        reference_array [ iescalations      ] := infEscalations_kb05;
        reference_array [ ideadlocks        ] := infDeadlocks_kb05;
        reference_array [ irequest_timeouts ] := infSqlReqTimeouts_kb05 + infObjReqTimeouts_kb05;
        reference_array [ inew_rows         ] := infRowEntryAmount_kb05;
        reference_array [ inew_tabs         ] := infTabEntryAmount_kb05;
        reference_array [ ikb_calls         ] := infKbCalls_kb05
        END;
    (*ENDWITH*) 
    reference_array [ itranscount       ] := 0(*ldiWriteTransCnt_kb00*);
    (* *)
    k57info_seq_cache (procid, _sseq_cache_total, _sseq_cache_hit, _sseq_cache_miss);
    reference_array [ isseq_cache_total ] := _sseq_cache_total;
    reference_array [ isseq_cache_hit   ] := _sseq_cache_hit;
    reference_array [ isseq_cache_miss  ] := _sseq_cache_miss;
    (* PTS 1103033 E.Z. *)
    a260statistics (external_dbproc_calls,  internal_dbproc_calls);
    a262statistics (external_trigger_calls, internal_trigger_calls);
    (* PTS 1109469, T.A. 2001-03-22 *)
    reference_array [idata_sql_cache_total] := reference_array [idata_cache_total];
    reference_array [idata_sql_cache_hit  ] := reference_array [idata_cache_hit];
    reference_array [idata_sql_cache_miss ] := reference_array [idata_cache_miss];
    (* PTS 1115043 E.Z. *)
    (* PTS 1111572 E.Z. *)
    reference_array [idata_cache_total] := reference_array [idata_cache_total]
          + reference_array [idata_obj_cache_total]
          + reference_array[idata_obj_log_cache_total]
          + reference_array[idata_history_cache_total];
    reference_array [idata_cache_hit] := reference_array [idata_cache_hit]
          + reference_array [idata_obj_cache_hit]
          + reference_array[idata_obj_log_cache_hit]
          + reference_array[idata_history_cache_hit];
    reference_array [idata_cache_miss] := reference_array [idata_cache_miss]
          + reference_array [idata_obj_cache_miss]
          + reference_array[idata_obj_log_cache_miss]
          + reference_array[idata_history_cache_miss];
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42get_tablename (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob;
            required_priv : tak00_PrivilegeSet);
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a4ti := a_ap_tree^[ a4ti ].n_lo_level;
    a11get_check_table (acv, false, false, false, required_priv,
          (a_is_ddl = ddl_update_statistics) AND (required_priv <> []),
          true, d_fix, a4ti, a4authname, a4tablen, a4p_arr);
    IF  a_returncode = 0
    THEN
        IF  NOT (a4p_arr.pbasep^.sbase.btablekind
            in [ twithkey, twithoutkey ])
        THEN
            a07_nb_put_error (acv, e_missing_basetable,
                  a_ap_tree^[ a4ti ].n_pos, a4tablen);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a4ti := a_ap_tree^[ a4ti ].n_sa_level;
        IF  (a4ti <> 0) AND (a_ap_tree^[ a4ti ].n_proc <> a42)
        THEN
            BEGIN
            a05_identifier_get (acv, a4ti, sizeof (a4coln), a4coln);
            a4ti := a_ap_tree^[ a4ti ].n_sa_level
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42index_inf_to_messbuf (
            VAR acv         : tak_all_command_glob;
            VAR mblock      : tgg00_MessBlock;
            VAR a41v        : tak40_show_glob;
            VAR indexn      : tsp00_KnlIdentifier;
            VAR selectivity : boolean;
            diagnose_index  : boolean);
 
CONST
      c_max_st_index   = MAX_COL_PER_INDEX_GG00;
 
VAR
      found          : boolean;
      send_messbuf   : boolean;
      required_priv  : tak00_PrivilegeSet;
      b_err          : tgg00_BasisError;
      a4save         : integer;
      j              : integer;
      mindex_no      : tsp00_Int2;
      stack          : ARRAY[1..c_max_st_index] OF tgg00_StackEntry;
      index_scan_rec : tak_index_scan_record;
 
BEGIN
WITH acv, a41v DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        b_err        := e_ok;
        send_messbuf := NOT selectivity;
        a4save       := a4ti;
        a4ti         := a_ap_tree^ [ a4ti ].n_lo_level;
        a4priv_check := true;
        indexn       := a01_il_b_identifier;
        WITH a_ap_tree^[ a4ti ] DO
            IF  n_symb = s_identifier
            THEN
                BEGIN
                (* indexname *)
                a05_identifier_get (acv, a4ti, sizeof (indexn), indexn)
                END
            ELSE
                a4ti := a4save;
            (*ENDIF*) 
        (*ENDWITH*) 
        IF  (diagnose_index AND
            (a_current_user_kind in [usysdba, ucontroluser]))
            OR (* PTS 1109358, allow update stat column for domain user *)
            ((a_is_ddl = ddl_update_statistics) AND
            ((acv.a_curr_user_name = a01_i_domain) OR (a_current_user_kind in [usysdba, ucontroluser]))
            )
        THEN
            required_priv := []
        ELSE
            required_priv := [r_owner];
        (*ENDIF*) 
        ak42get_tablename (acv, a41v, required_priv);
        END;
    (*ENDIF*) 
    IF  (a_returncode = 0) AND
        ((a_ex_kind <> only_parsing) OR (a4sh_kind = sh_no_kind))
    THEN
        BEGIN
        selectivity := NOT selectivity AND (a4ti <> 0);
        mblock.mb_struct := mbs_stack_addr;
        IF  diagnose_index
        THEN
            BEGIN
            mblock.mb_type  := m_diagnose;
            mblock.mb_type2 := mm_index
            END
        ELSE
            BEGIN
            mblock.mb_type  := m_index_statistic;
            IF  selectivity
            THEN
                mblock.mb_type2 := mm_test
            ELSE
                mblock.mb_type2 := mm_nil
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        found := false;
        IF  ( indexn = a01_il_b_identifier )
        THEN
            BEGIN
            IF  NOT a061exist_columnname (a4p_arr.pbasep^.sbase,
                a4coln, a4col_ptr)
            THEN
                a07_b_put_error (acv, e_unknown_columnname, 1)
            ELSE
                BEGIN
                IF  ( a4p_arr.pbasep^.sbase.bindexexist )
                THEN
                    BEGIN
                    a24init_index_scan (acv, a4p_arr.pbasep^.sbase.btreeid.fileTabId_gg00,
                          index_scan_rec);
                    WHILE NOT found AND
                          a24next_named_index (acv, index_scan_rec)
                          DO
                        WITH index_scan_rec, isr_buf^.smindex.indexdef[isr_index] DO
                            IF  ( icount = 1 ) AND
                                ( icolseq[ 1 ] = a4col_ptr^.creccolno )
                            THEN
                                BEGIN
                                found := true;
                                a24get_indexname( acv, isr_buf, isr_index,
                                      indexn );
                                END;
                            (*ENDIF*) 
                        (*ENDWITH*) 
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
                IF  ( NOT found )
                THEN
                    a07_b_put_error (acv, e_column_not_indexed, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (a_returncode = 0) AND
            (indexn <> a01_il_b_identifier)
        THEN
            WITH index_scan_rec DO
                BEGIN
                (*========== multiple index ==========*)
                IF  ( NOT found )
                THEN
                    BEGIN
                    IF  ( a4p_arr.pbasep^.sbase.bindexexist )
                    THEN
                        BEGIN
                        a24find_indexname (acv,
                              a4p_arr.pbasep^.sbase.bsurrogate,
                              indexn, index_scan_rec);
                        found := isr_buf <> NIL;
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  ( found )
                THEN
                    BEGIN
                    mblock.mb_qual^.mtree := a4p_arr.pbasep^.sbase.btreeid;
                    mblock.mb_st          := @stack[1];
                    mblock.mb_qual^.mst_addr := mblock.mb_st;
                    mblock.mb_st_size :=
                          c_max_st_index * sizeof (tgg00_StackEntry);
                    mblock.mb_st_max := c_max_st_index;
                    WITH isr_buf^.smindex.indexdef[isr_index],
                         mblock, mb_qual^ DO
                        BEGIN
                        mmult_pos  := 1;
                        mmult_cnt  := 1;
                        mb_st^ [1] := icolstack[ 1 ];
                        mfirst_free := 2;
                        IF  diagnose_index
                        THEN
                            FOR j := 2 TO icount DO
                                BEGIN
                                mb_st^ [j]  := icolstack[ j ];
                                mmult_cnt   := succ(mmult_cnt);
                                mfirst_free := succ(mfirst_free);
                                END;
                            (*ENDFOR*) 
                        (* h.b. PTS 1104683 *)
                        (*ENDIF*) 
                        mblock.mb_data^.mbp_sample.sam_rows    := c_undefined;
                        mblock.mb_data^.mbp_sample.sam_percent := c_100_pct;
                        (* h.b. PTS 1115096 *)
                        mblock.mb_data^.mbp_sample.sam_with_long := true;
                        mblock.mb_data^.mbp_sample.sam_fill1     := false;
                        mblock.mb_data^.mbp_sample.sam_fill2     := 0;
                        IF  send_messbuf
                        THEN
                            a06rsend_mess_buf (acv, mblock,
                                  cak_return_req, b_err);
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                    END
                ELSE
                    a07_nb_put_error (acv, e_unknown_indexname,
                          1, indexn)
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak42session_to_sname (
            session : tgg91_SessionNo;
            max_len : integer;
            VAR n   : tsp00_Sname);
 
VAR
      pos    : integer;
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
FOR ln_len := 1 TO sizeof (n) DO
    ln [ln_len] := ' ';
(*ENDFOR*) 
ln_len := 0;
gg06SessionToLine (session, ln_len, ln);
IF  ln_len > sizeof (n)
THEN
    ln_len := sizeof (n);
(*ENDIF*) 
IF  ln_len > max_len
THEN
    ln_len := max_len;
(*ENDIF*) 
IF  (ln [1] in ['0'..'9']) AND (max_len <= sizeof (n))
THEN
    pos := max_len - ln_len + 1
ELSE
    pos := 1;
(*ENDIF*) 
n := bsp_sname;
SAPDB_PascalForcedMove (sizeof (ln), sizeof (n), @ln, 1, @n, pos, ln_len)
END;
 
(* PTS 115043 U.J. ak42xparams() obsolete*)
(*------------------------------*) 
 
PROCEDURE
      ak42ascii_const_move (
            src           : tsp00_MoveObjPtr;
            srclen        : integer;
            VAR destpos   : integer;
            VAR dest      : tsp00_C256;
            VAR e         : tsp00_Int2);
 
VAR
      ix  : integer;
 
BEGIN
IF  g01unicode
THEN
    FOR ix := 1 TO srclen DO
        BEGIN
        dest [ destpos ]     := csp_unicode_mark;
        dest [ destpos + 1 ] := src^ [ ix ];
        destpos              := destpos + 2;
        END
    (*ENDFOR*) 
ELSE
    BEGIN
    SAPDB_PascalMove ('VAK42 ',   7,    
          srclen, sizeof (dest), src, 1,
          @dest, destpos, srclen, e);
    destpos := destpos + srclen;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42move_trans_no (
            VAR acv   : tak_all_command_glob;
            VAR a41v  : tak40_show_glob;
            VAR trans : tgg91_TransNo);
 
VAR
      length   : integer;
      c20      : tsp00_C20;
      aux_line : tsp00_Line;
 
BEGIN
(* PTS 1108234 JA 2001-01-19 *)
length := 0;
IF  gg06IsNilTrans (trans)
THEN
    a40move (acv, a41v, NIL, 0)  (* undef *)
ELSE
    BEGIN
    gg06TransToLine (trans, length, aux_line);
    IF  length > sizeof (c20)
    THEN
        length := sizeof (c20);
    (*ENDIF*) 
    c20 := bsp_c20;
    SAPDB_PascalMove ('VAK42 ',   8,    
          sizeof (aux_line), sizeof(c20),
          @aux_line, 1, @c20, sizeof(c20)+1-length,
          length, acv.a_returncode);
    a40move_const (acv, a41v, @c20, sizeof(c20))
    END
(*ENDIF*) 
END;
 
(* PTS 1108435 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak42internal_state (
            VAR acv       : tak_all_command_glob;
            VAR a41v      : tak40_show_glob);
 
BEGIN
WITH acv, a41v DO
    BEGIN
    a40get_catalog_table (acv, a41v);
    IF  (a_returncode = 0) AND
        (a_ex_kind <> only_parsing)
    THEN
        BEGIN
        k57select_restartrec (acv.a_transinf.tri_trans.trTaskId_gg00, @acv, @a41v);
        k57select_log_info (acv.a_transinf.tri_trans.trTaskId_gg00, @acv, @a41v);
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42bool_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            bool_val    : boolean);
 
VAR
      n : tsp00_Sname;
 
BEGIN
(* PTS 1108435 JA 2000-11-30 *)
(* inserts a result record with a bool value into INTERNAL_STATE *)
IF  bool_val
THEN
    n := n_yes
ELSE
    n := n_no;
(*ENDIF*) 
a40move_const (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_const (acv_ptr^, a41v_ptr^, @n,           sizeof (n))
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42date_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            int_date    : tsp00_Int4);
 
VAR
      ln_len     : integer;
      str_date   : tsp00_Date;
      dummy_time : tsp00_Time;
      ln         : tsp00_Line;
 
BEGIN
(* PTS 1108435 JA 2000-11-30 *)
(* inserts a result record with a date value into INTERNAL_STATE *)
ln_len := 0;
g17intdate_time (int_date, 0, str_date, dummy_time);
g17date_to_line (str_date, ln_len, ln);
a40move_const   (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const   (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_const   (acv_ptr^, a41v_ptr^, @ln,          ln_len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42int4_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            int_val     : tsp00_Int4);
 
BEGIN
(* PTS 1108435 JA 2000-11-30 *)
(* inserts a result record with an int4 into INTERNAL_STATE *)
a40move_const (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_i4    (acv_ptr^, a41v_ptr^, int_val, NOT c_null, 0, NOT c_to_undef);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42session_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            session       : tgg91_SessionNo);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
(* PTS 1108435 JA 2000-11-30 *)
(* inserts a result record with a session no into INTERNAL_STATE *)
ln_len := 0;
gg06SessionToLine (session, ln_len, ln);
a40move_const     (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const     (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_const     (acv_ptr^, a41v_ptr^, @ln,          ln_len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42str_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            str_ptr     : tsp00_MoveObjPtr;
            str_len     : integer);
 
VAR
      aux_len : integer;
 
BEGIN
(* PTS 1108435 JA 2000-11-30 *)
(* inserts a result record with a string into INTERNAL_STATE *)
IF  str_len > mxsp_c40
THEN
    aux_len := mxsp_c40
ELSE
    aux_len := str_len;
(*ENDIF*) 
a40move_const (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_const (acv_ptr^, a41v_ptr^, str_ptr,      aux_len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42surrogate_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            surrogate   : tgg00_Surrogate);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
(* PTS 1108435 JA 2000-11-30 *)
(* inserts a result record with a surrogate into INTERNAL_STATE *)
ln_len := 0;
g17surrogate_to_line (surrogate, ln_len, ln);
a40move_const (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_const (acv_ptr^, a41v_ptr^, @ln,          ln_len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42time_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            int_time    : tsp00_Int4);
 
VAR
      ln_len     : integer;
      dummy_date : tsp00_Date;
      str_time   : tsp00_Time;
      ln         : tsp00_Line;
 
BEGIN
(* PTS 1108435 JA 2000-11-30 *)
(* inserts a result record with a time value into INTERNAL_STATE *)
ln_len := 0;
g17intdate_time (0, int_time, dummy_date, str_time);
g17time_to_line (str_time, ln_len, ln);
a40move_const   (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const   (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_const   (acv_ptr^, a41v_ptr^, @ln,          ln_len)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42trans_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            trans       : tgg91_TransNo);
 
VAR
      ln_len : integer;
      ln     : tsp00_Line;
 
BEGIN
(* PTS 1108435 JA 2000-11-30 *)
(* inserts a result record with a transaction no into INTERNAL_STATE *)
ln_len := 0;
gg06TransToLine (trans, ln_len, ln);
a40move_const   (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const   (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_const   (acv_ptr^, a41v_ptr^, @ln,          ln_len)
END;
 
(* PTS 1110418 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a42uint1_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            int_val     : tsp00_Int2);
 
BEGIN
(*
      the type of the last parameter is correct.
      It is one factor too high.
      We do not want to output those integer with negative sign.
      Therefore we need the next integer available in Pascal
      able to hold the correct value.
      *)
(* inserts a result record with an UInt1/Int2 into INTERNAL_STATE *)
a40move_const (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_i4    (acv_ptr^, a41v_ptr^, int_val, NOT c_null, 0, NOT c_to_undef);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42uint2_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            int_val     : tsp00_Int4);
 
BEGIN
(*
      the type of the last parameter is correct.
      It is one factor too high.
      We do not want to output those integer with negative sign.
      Therefore we need the next integer available in Pascal
      able to hold the correct value.
      *)
(* inserts a result record with an UInt2/Int4 into INTERNAL_STATE *)
a40move_const (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_i4    (acv_ptr^, a41v_ptr^, int_val, NOT c_null, 0, NOT c_to_undef);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a42uint4_to_intern_state (
            acv_ptr     : tak_acv_address;
            a41v_ptr    : tak40_show_glob_ptr;
            component   : tsp00_C20;
            description : tsp00_C40;
            int_val     : tsp00_8ByteCounter);
 
BEGIN
(*
      the type of the last parameter is correct.
      It is one factor too high.
      We do not want to output those integer with negative sign.
      Therefore we need the next integer available in Pascal
      able to hold the correct value.
      *)
(* inserts a result record with an UInt4/8ByteCounter into INTERNAL_STATE *)
a40move_const   (acv_ptr^, a41v_ptr^, @component,   sizeof (component));
a40move_const   (acv_ptr^, a41v_ptr^, @description, sizeof (description));
a40move_counter (acv_ptr^, a41v_ptr^, int_val, NOT c_null, 0, NOT c_to_undef)
END;
 
(* END PTS 1110418 E.Z. *)
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
