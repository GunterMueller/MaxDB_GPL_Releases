.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK36$
.tt 2 $$$
.TT 3 $ThomasA$AK_cold_utility_functions$$2000-11-22$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_cold_utility_functions
=========
.sp
Purpose : Unterprogramme f?ur Utility-Auftr?age.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a36after_systable_load (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a36diag_outcopy (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a36dg_tablename_get (VAR t : tgg00_TransContext;
                    VAR tabid     : tgg00_Surrogate;
                    VAR owner_id  : tgg00_Surrogate;
                    VAR tablename : tsp00_KnlIdentifier);
 
        PROCEDURE
              a36dg_username_get (VAR t : tgg00_TransContext;
                    VAR user_id  : tgg00_Surrogate;
                    VAR username : tsp00_KnlIdentifier);
 
        PROCEDURE
              a36get_catalog_record (VAR t : tgg00_TransContext;
                    VAR sysk   : tgg00_SysInfoKey;
                    VAR sysbuf : tak_systembuffer);
 
        PROCEDURE
              a36hex_surrogate (VAR acv : tak_all_command_glob;
                    VAR surrogate : tgg00_Surrogate);
 
        PROCEDURE
              a36restart_time (VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
        FUNCTION
              a36tree_in_memory (VAR tree_id : tgg00_FileId) : boolean;
 
        PROCEDURE
              a36_call_semantic (VAR acv : tak_all_command_glob;
                    VAR util_cmd_id : tgg00_UtilCmdId);
 
        PROCEDURE
              a36devname (VAR acv : tak_all_command_glob;
                    tree_index  : integer;
                    VAR dname   : tsp00_VFilename;
                    dlen        : integer);
 
        PROCEDURE
              a36filename (
                    VAR acv     : tak_all_command_glob;
                    tree_index  : integer;
                    VAR fname   : tsp00_VFilename;
                    fnlen       : integer);
 
        PROCEDURE
              a36utilprot_needed (VAR acv : tak_all_command_glob;
                    VAR prot_needed   : boolean;
                    VAR with_tapeinfo : boolean);
 
        FUNCTION
              a36filetype (VAR acv : tak_all_command_glob;
                    tree_index   : tsp00_Int2;
                    VAR filetype : tsp00_VfType) : boolean;
 
        PROCEDURE
              a36_standby_semantic (
                    VAR acv         : tak_all_command_glob);
              (*ptocExport hak36_1.h*)
 
        PROCEDURE
              a36PrepareCatalogForUserConnect (VAR acv : tak_all_command_glob (*ptocSynonym tgg00_VoidPtr*));
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey            : tgg00_SysInfoKey;
              a01diag_monitor_on       : boolean;
              a01diag_analyze_on       : boolean;
              a01char_size             : integer;
              a01controluser           : tsp00_KnlIdentifier;
              a01_i_sys                : tsp00_KnlIdentifier;
              a01_i_syscat1            : tsp00_KnlIdentifier;
              a01_i_sysmonitor         : tsp00_KnlIdentifier;
              a01_i_sysmondata         : tsp00_KnlIdentifier;
              a01_i_syscmd_analyze     : tsp00_KnlIdentifier;
              a01_i_sysdata_analyze    : tsp00_KnlIdentifier;
              a01_i_sysparseid         : tsp00_KnlIdentifier;
              a01_i_sysupdstatwanted   : tsp00_KnlIdentifier;
              a01_il_b_identifier      : tsp00_KnlIdentifier;
 
        FUNCTION
              a01equal_char (
                    VAR m    : tsp00_Buf;
                    pos      : tsp00_Int4;
                    cmp_char : char) : boolean;
 
        PROCEDURE
              a01sets_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tak_oldidentifier);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05_int4_unsigned_get (VAR acv : tak_all_command_glob;
                    pos   : integer;
                    l     : tsp00_Int2;
                    VAR int : tsp00_Int4);
 
        PROCEDURE
              a05identifier_get (VAR acv : tak_all_command_glob;
                    tree_index  : integer;
                    obj_len     : integer;
                    VAR moveobj : tsp00_KnlIdentifier);
 
        PROCEDURE
              a05password_get (VAR acv : tak_all_command_glob;
                    tree_index   : integer;
                    VAR password : tsp00_Pw);
 
        PROCEDURE
              a05string_literal_get (VAR acv : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    VAR moveobj : tsp00_VFilename;
                    obj_pos     : integer;
                    obj_len     : integer);
 
        PROCEDURE
              a05_string_literal_get (VAR acv : tak_all_command_glob;
                    tree_index  : integer;
                    datatyp     : tsp00_DataType;
                    obj_len     : integer;
                    VAR moveobj : tsp00_C64);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06_c_send_mess_buf (VAR acv : tak_all_command_glob;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a06a_mblock_init (VAR acv : tak_all_command_glob;
                    mtype           : tgg00_MessType;
                    m2type          : tgg00_MessType2;
                    VAR tree        : tgg00_FileId);
 
        PROCEDURE
              a06finish_curr_retpart (VAR acv : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06retpart_move (VAR acv : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06char_retpart_move (VAR acv : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
        PROCEDURE
              a06colname_retpart_move (
                    VAR acv     : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4;
                    src_codeset : tsp00_Int2);
 
        PROCEDURE
              a06lsend_mess_buf (VAR acv : tak_all_command_glob;
                    VAR mbuf        : tgg00_MessBlock;
                    call_from_rsend : boolean;
                    VAR e           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        FUNCTION
              a061identifier_len (VAR id : tsp00_KnlIdentifier) : integer;
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        PROCEDURE
              a071_getmessagetext (
                    msgno          : tsp00_Int2;
                    VAR msgbuf     : tsp00_MoveObj;
                    VAR msglen     : tsp00_Int2;
                    VAR found      : boolean);
 
        PROCEDURE
              a071_nextmessagetext (
                    VAR msgno      : tsp00_Int2;
                    VAR msgbuf     : tsp00_MoveObj;
                    VAR msglen     : tsp00_Int2;
                    VAR found      : boolean);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        FUNCTION
              a10BaseRecPersistentOffset : integer;
 
        PROCEDURE
              a10expand_rec (VAR rec_buf : tgg00_Rec;
                    VAR e : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        FUNCTION
              a10TableAccessAllowed : boolean;
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        FUNCTION
              a101_IsTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId) : boolean;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId) : boolean;
 
        FUNCTION
              a101_GetExtendedTempFileType(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId) : tgg00_TfnTemp;
 
        PROCEDURE
              a101_StoreUpgradeInfo;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper: VAK103;
 
        FUNCTION
              a103CreateCatalog : integer;
 
        PROCEDURE
              a103RestartCatalog;
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11put_date_time (VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_User_Password : VAK21;
 
        PROCEDURE
              a21init_glob (VAR a20v : tak_a21_glob);
 
        PROCEDURE
              a21create_user (VAR acv : tak_all_command_glob;
                    VAR a20v : tak_a21_glob);
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24RecreateBadIndexes (VAR acv : tak_all_command_glob;
                    SysCatalogOnly : boolean);
 
      ------------------------------ 
 
        FROM
              AK_dialog_tools : VAK260;
 
        PROCEDURE
              a260sysdbproc_exist (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a260CallSystemTriggers (
                    VAR acv     : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_update_statistics : VAK28;
 
        VAR
              a28updstatwanted_tree : tgg00_FileId;
 
        FUNCTION
              a28TreeStoredInVar (VAR tree : tgg00_FileId) : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_Sink : VAK34;
 
        PROCEDURE
              a34InitOms (VAR acv : tak_all_command_glob;
                    inMigration : boolean);
 
        PROCEDURE
              a34Restart (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Catalog_Migration : VAK361;
 
        PROCEDURE
              a361migrate (VAR acv : tak_all_command_glob;
                    VAR version         : tsp00_Version);
 
      ------------------------------ 
 
        FROM
              Catalog_Migration_2 : VAK362;
 
        PROCEDURE
              a362migrate (VAR acv : tak_all_command_glob;
                    VAR in_warm_session : boolean);
 
      ------------------------------ 
 
        FROM
              AK_warm_utility_functions : VAK37;
 
        PROCEDURE
              a37return_hostname (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a37_call_semantic (VAR acv : tak_all_command_glob;
                    VAR util_cmd_id       : tgg00_UtilCmdId);
 
        FUNCTION
              a37blocksize (VAR acv : tak_all_command_glob;
                    VAR a30v         : tak_a30_utility_glob) : tsp00_Int2;
 
        FUNCTION
              a37hex2char (
                    VAR acv : tak_all_command_glob;
                    hexpos : integer) : char;
 
        PROCEDURE
              a37char2hex (
                    input      : char;
                    VAR output : tsp00_C2);
 
        PROCEDURE
              a37init_util_record (VAR acv : tak_all_command_glob;
                    m_type  : tgg00_MessType;
                    m2_type : tgg00_MessType2);
 
        PROCEDURE
              a37media_name (VAR acv : tak_all_command_glob;
                    VAR ti   : tsp00_Int2;
                    VAR qual : tgg00_QualBuf);
 
        PROCEDURE
              a37label_name (
                    VAR acv  : tak_all_command_glob;
                    VAR ti   : tsp00_Int2;
                    VAR qual : tgg00_QualBuf);
 
        PROCEDURE
              a37multi_tape_info (VAR acv : tak_all_command_glob;
                    kw_index : integer);
 
        PROCEDURE
              a37put_count_to_messbuf (VAR acv : tak_all_command_glob;
                    VAR a30v : tak_a30_utility_glob);
 
        PROCEDURE
              a37vtrace (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a37insert_event (event : tsp31_event_ident);
 
        PROCEDURE
              a37resultevent (
                    ident   : tsp31_event_ident;
                    retcode : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_data_dictionary : VAK38;
 
        PROCEDURE
              a38create_parameter_file (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Show_statistics : VAK42;
 
        PROCEDURE
              a42_monitor_init (process_id : tsp00_TaskId);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51build_userkey (VAR user_name : tsp00_KnlIdentifier;
                    VAR userkey : tgg00_SysInfoKey);
 
        PROCEDURE
              a51connect (VAR acv : tak_all_command_glob;
                    VAR connect_rec  : tak_connect_rec;
                    change_curr_user : boolean);
 
        PROCEDURE
              a51getascii_password (VAR acv : tak_all_command_glob;
                    VAR password : tsp00_CryptPw);
 
        PROCEDURE
              a51trimcn_password (VAR password : tsp00_CryptPw);
 
        PROCEDURE
              a51switch_user (VAR acv : tak_all_command_glob;
                    VAR new_user_name  : tsp00_KnlIdentifier;
                    VAR pOldContext   : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52_ex_commit_rollback (VAR acv : tak_all_command_glob;
                    m_type         : tgg00_MessType;
                    n_rel          : boolean;
                    normal_release : boolean);
 
      ------------------------------ 
 
        FROM
              KB_functions : VKB05;
 
        PROCEDURE
              k05GetBadLogVolume (VAR mblock : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_headmaster : VKB38;
 
        PROCEDURE
              k38restore_config (VAR mblock : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_locklist : VKB51;
 
        PROCEDURE
              k51del_transentry_from_locklist (TaskId : tsp00_TaskId;
                    VAR TransIndex : tgg00_TransIndex;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              k51new_session (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              k51remove_locks (TaskId : tsp00_TaskId;
                    TransIndex        : tgg00_TransIndex;
                    VAR TransState    : tgg00_TransState);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53commit (VAR t : tgg00_TransContext;
                    MessType2  : tgg00_MessType2);
 
        PROCEDURE
              k53rollback (VAR t : tgg00_TransContext;
                    MessType2    : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560CreateLogTransaction (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              kb560InvalidateIOSeq( VAR ioSeq : tsp00_Uint4);
 
        PROCEDURE
              kb560GetSys1CatalogTabId(
                    VAR tabId : tgg00_Surrogate);
 
        PROCEDURE
              kb560GetSys1CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560GetSys2CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id     : tgg00_FileId;
              b01blankfilename  : tsp00_VFilename;
 
        PROCEDURE
              b01filestate (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
        PROCEDURE
              b01shutdown_filesystem (VAR t : tgg00_TransContext);
 
        PROCEDURE
              bd01MigrateDataBase(
                    TaskId      : tsp00_TaskId;
                    VAR TrError : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02get_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Lkey;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              BD_Wrapper : VBD999;
 
        PROCEDURE
              bd999EnableConsistentRead(TaskId : tsp00_TaskId);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : vbd998;
 
        PROCEDURE
              bd998CreateNamedTempFile(
                    VAR trans          : tgg00_TransContext;
                    VAR fileNo         : tgg00_Surrogate(*ptocConst*);
                    VAR tempFileId     : tgg00_FileId;
                    isExtendedTempFile : boolean;
                    tempFileType       : tgg00_TfnTemp);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01controluser     : tgg04_ControlUser;
              g01glob            : tgg00_KernelGlobals;
              g01nls_sort        : boolean;
              g01nls_default_map : tsp00_KnlIdentifier;
              g01diag_moni_parse_on    : boolean;
              g01unicode         : boolean;
 
        PROCEDURE
              g01abort (msg_no : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
        FUNCTION
              g01auto_recreate_bad_indexes : boolean;
 
        PROCEDURE
              g01optextmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C40);
 
        FUNCTION
              g01SystemTriggersEnabled : boolean;
 
      ------------------------------ 
 
        FROM
              Codetransformation_and_Coding : VGG02;
 
        VAR
              g02codetables : tgg04_CodeTables;
 
        PROCEDURE
              g02hex (VAR source : tgg00_Surrogate;
                    source_pos : tsp00_Int4;
                    VAR dest   : tsp00_C40;
                    dest_pos   : tsp00_Int4;
                    source_len : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Check-Date-Time : VGG03;
 
        VAR
              g03dictionary : tsp6_dictionaries;
 
        PROCEDURE
              g03fdcheck_date (VAR sbuf : tsp00_C64;
                    VAR dbuf   : tsp00_Date;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03ftcheck_time (VAR sbuf : tsp00_C64;
                    VAR dbuf   : tsp00_Time;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03daynames_init (VAR buf : tsp00_MoveObj;
                    index     : integer;
                    VAR is_ok : boolean);
 
        PROCEDURE
              g03monthnames_init (VAR buf : tsp00_MoveObj;
                    index     : integer;
                    VAR is_ok : boolean);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06SetNilRef (VAR PageRef : tgg91_PageRef);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Kernel-Version : VGG11;
 
        PROCEDURE
              g11kernel_version  (VAR vers : tsp00_Version);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        PROCEDURE
              gg999InitConfig (VAR trans : tgg00_TransContext);
 
        PROCEDURE
              gg999Activate (VAR trans : tgg00_TransContext);
 
        PROCEDURE
              gg999Restart (VAR trans : tgg00_TransContext;
                    untildate : tsp00_Date;
                    untiltime : tsp00_Time;
                    untilIOSequence : tsp00_Uint4);
 
        PROCEDURE
              gg999Offline (error : tgg00_BasisError);
 
        PROCEDURE
              gg999RestoreData (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              gg999RestoreLog (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              gg999BackupRestoreHandling (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              gg999PermitBackupAndRestore;
 
        FUNCTION
              gg999DenyBackupAndRestore : tgg00_BasisError;
 
        PROCEDURE
              gg999ClearLog (taskid : tsp00_TaskId);
 
        PROCEDURE
              gg999GetRestartVersion (VAR mblock : tgg00_MessBlock);
 
        FUNCTION
              gg999IsCheckBackupConfigured : boolean;
 
        PROCEDURE
              gg999ReIntegrateBadLogVolume(
                    VAR Trans   : tgg00_TransContext;
                    VAR DevName : tsp00_VFilename );
 
        PROCEDURE
              gg999SetLogWriting (taskid : tsp00_TaskId;
                    on : boolean);
 
        PROCEDURE
              gg999InitStandby (VAR trans : tgg00_TransContext);
 
        PROCEDURE
              gg999InsertStandby(VAR trans : tgg00_TransContext;
                    VAR newNode : tsp00_NodeId);
 
        PROCEDURE
              gg999RemoveStandby(VAR trans : tgg00_TransContext;
                    VAR oldNode : tsp00_NodeId);
 
        PROCEDURE
              gg999RestartStandby (VAR trans : tgg00_TransContext);
 
        FUNCTION
              gg999Synchronize (VAR trans : tgg00_TransContext;
                    newMaxOffset : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              gg999TakeOver (VAR trans : tgg00_TransContext);
 
        FUNCTION
              gg999KernelStateIsOnline : boolean;
 
        PROCEDURE
              gg999SetKernelStateOnline;
 
        PROCEDURE
              gg999CreateSnapShot (VAR trans : tgg00_TransContext);
 
        PROCEDURE
              gg999ActivateSnapShot (VAR trans : tgg00_TransContext);
 
        PROCEDURE
              gg999DropSnapShot (VAR trans : tgg00_TransContext);
 
        PROCEDURE
              gg999MigrateVolumes( VAR Trans : tgg00_TransContext );
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30klen (VAR str : tsp00_Key;
                    val : char; cnt : integer) : integer;
 
        PROCEDURE
              s30map (VAR code_t : tsp00_Ctable;
                    VAR source   : tsp00_MoveObj;
                    spos         : tsp00_Int4;
                    VAR dest     : tsp00_MoveObj;
                    dpos         : tsp00_Int4;
                    length       : tsp00_Int4);
 
        FUNCTION
              s30lnr (
                    VAR str : tsp00_C64;
                    val   : char;
                    start : tsp00_Int4;
                    cnt   : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              date_time_formatting : VSP78;
 
        PROCEDURE
              s78language (VAR dictionaries : tsp6_dictionaries;
                    VAR language_name : tsp00_C3;
                    VAR language_no   : tsp6_language;
                    for_init          : boolean;
                    VAR is_ok         : boolean);
 
        PROCEDURE
              s78dict_next_msgno (VAR msgno : tsp00_Int2;
                    VAR done : boolean);
 
        PROCEDURE
              s78dict_insert_row (VAR dictionary : tsp6_dictionary;
                    bufptr        : tsp00_MoveObjPtr;
                    buf_len       : tsp00_Int4;
                    VAR is_ok     : boolean);
 
        PROCEDURE
              s78lang_spell_init (VAR dictionary : tsp6_dictionary;
                    bufptr        : tsp00_MoveObjPtr;
                    buf_len       : tsp00_Int4;
                    dict_kind     : integer;
                    VAR i         : integer;
                    VAR is_ok     : boolean);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vrestart (pid : tsp00_TaskId;
                    VAR sysdevspace : tsp00_DevName);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        FUNCTION
              a01equal_char;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              a05identifier_get;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              a05string_literal_get;
 
              tsp00_MoveObj  tsp00_VFilename
 
        PROCEDURE
              a05_string_literal_get;
 
              tsp00_MoveObj  tsp00_C64
 
        PROCEDURE
              g03fdcheck_date;
 
              tsp00_MoveObj tsp00_C64
              tsp00_MoveObj tsp00_Date
 
        PROCEDURE
              g03ftcheck_time;
 
              tsp00_MoveObj tsp00_C64
              tsp00_MoveObj tsp00_Time
 
        PROCEDURE
              g02hex;
 
              tsp00_MoveObj  tgg00_Surrogate
              tsp00_MoveObj  tsp00_C40
 
        FUNCTION
              s30klen;
 
              tsp00_MoveObj tsp00_Key
 
        FUNCTION
              s30lnr;
 
              tsp00_MoveObj tsp00_C64
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1985-02-06
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-22
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.cp 16
PROCEDURE  A36_CALL_SEMANTIC :
.sp;.fo
The procedure is a distributor for the Utility commands
when the system is in cold state (cold utilities).
The first element of the syntax tree specifies the
command that is to be executed. The cold Utility commands
may be executed only
by the Superdba with the password for cold operation. An exception is the
Restart command, which, in addition, may also be
executed by the Restart user.
Utility commands that require a host file (Save and
Restore commands) may optionally be operated 'Direct', i.e.
the kernel itself
writes and reads to and from the specified host file. This results in
performance improvements in environments that also
provide the virtual file for
the kernel. If 'Direct' is specified, n_pos
in the first syntax-tree element has
the value command indicator + 1000.
.sp 4
.cp 17
PROCEDURE  A36_INCOPY:
.sp 2
A distinction must be made between two cases:
.sp
i)  The length of part 2 of the request segment is 64:
.in +5
Part 2 contains the name of the file
that contains the pages to be read in. The
name is passed to KB, which means that KB reads directly from the file.
(this has been preceded by a 'Direct').
.sp
.in -5
ii) The length of part 1 of the request segment is maxbufferlength:
.in +5
The request segment contains one page
in part 1 and possibly also in part 2.
This (these) is (are) passed directly to
KB in part 1 and, if applicable, in part 2.
.in -5
.sp 4
.cp 17
PROCEDURE  A36_OUTCOPY
.sp
A distinction must be made between two cases:
.sp
i) The length of part 2 of the request segment is 64 :
.in +5
Part 2 contains the name of the file to
which the pages to be rolled out are to
be written. The name is passed to KB,
which means that KB writes directly to
the file via the virtual file.
.sp
.in -5
ii) The length of part 1 of the request segment is maxbufferlength:
.in +5
The pages provided by KB in part 1 and part 2 of the message buffer are
transferred to part 1 and part 2 of the request segment.
.in -5
.sp 4
.cp 8
PROCEDURE  AK36ALTER_CONFIG_DEVICE
.sp
The procedure builds the message buffer to be sent
to KB for the commands Alter Config and Alter Device.
Part 2 of the sql-packet contains the
configuration parameters when the procedure is called.
These parameters are written in the correct code type to part
1 of the message buffer and are sent
to KB with the message type m_change, mm_config or mm_device.
.sp 4
.cp 7
PROCEDURE  AK36COLD_CONNECT
.sp
The name of the user and the password are
read from the sql-packet and it
is checked whether they are legal. If this is the case, the necessary
initializations of the acv are made and a Vtrace entry is written.
.sp 4
.cp 10
PROCEDURE  AK36DIAGNOSE_COMMAND
.sp
The procedure builds the message buffer to be sent to KB for the various
Diagnose commands. Part 2 of the message buffer initially
contains in len a 2-Byte_Integer that informs KB of
the type of Diagnose command. Part 1 of the
message buffer contains the host file name
for all Diagnose commands starting
from position 1; stored after it in part 1,
depending on the Diagnose command,
are the following parameters:
.nf
.cp 12
      rootnr    : integer   4 Bytes long
      nr        : integer   4 Bytes long
      authid    : user_id   8 Bytes long
      tablename : name     18 Bytes long
      indexnr   : integer   1 Bytes long
      devspacen : c40      40 Bytes long
.sp;.fo
The name of the file to which the Diagnose output is to be written is
determined with ==> a37_get_hostname and is returned in Part 1 of
the message-buffer.
.sp 4
.cp 7
PROCEDURE  AK36GET_CONFIG_DEVICE
.sp
The procedure builds the message buffers for the commands Get
Device and Get Config and sends them to KB.
The parameters provided in part 1 of the message
buffer are returned in part 2 of the sql_packet
in the code type of the host computer.
.sp 4
.cp 9
PROCEDURE  AK36INIT_CONFIG
.sp
The procedure builds the message buffer to be sent to KB for the command Init
Config. Part 2 of the sql-packet contains the configuration parameters
when the procedure is called.
.sp 4
.cp 12
PROCEDURE  AK36RESTORE_CONFIG
.sp
The procedure builds the message buffer to be sent to KB for the command
Restore Config. Part 2 of the sql-packet contains the configuration
parameters when the procedure is called.
These parameters are written in the
correct code type to part 1 of the message
buffer and are sent to KB with the
message type m_restore, mm_config.
a37_get_hostname determines the name of the
file from which the information is read.
a37put_count_to_messbuf writes the
'Direct' information to part 2 of the message buffer.
The host name is returned
in part 1 of the sql-packet.
.sp 4
.cp 5
PROCEDURE  AK36RESTORE_COMMAND
.sp
The procedure builds the message buffer to be sent to KB for the commands
Restore Database, Restore Pages, Restore Log,
Restore Log from .. to .. .
.sp
.nf
.cp 12
               | Restore Database | Restore Log    | Restore Pages )
---------------+------------------+----------------+---------------+
>Request.Part1 | Command          | Command        | Command       )
>Request.Part2 |    ---           |      ---       |      ---      )
Messbuf.Part1  |    ---           | System and Log |      ---      )
               |                  | Devspace       |               )
Messbuf.Part2  | Direct/Count *   | Direct/Count * | Direct/Count *|
<Request.Part1 | Hostfilename     | Hostfilename   | Hostfilename  |
<Request.Part2 |     ---          |      ---       |      ---      |
.sp2
.cp 12
               | Save Log Cold    | Restore Log from to |
---------------+------------------+---------------------+
>Request.Part1 | Command          | Command             |
>Request.Part2 |    ---           |      ---            |
Messbuf.Part1  | First System     | System Devspace,    |
               | Devspace         | from Devspace       |
               | until data       | to Devspace         |
Messbuf.Part2  | Direct/Count *   |      ---            |
<Request.Part1 | Hostfilename     |      ---            |
<Request.Part2 |     ---          |      ---            |
.sp
.fo
.cp 8
The Devspace information is written to the message buffer by ==>
a36put_devspace.
The host name is determined by ==> a37_get_hostname; in Save Log Cold,
the until data are also written to part 1 of the message
 buffer, if necessary. The
'Direct' information is written to the message buffer by ==>
a37put_count_to_messbuf and the message buffer is sent to KB.
.sp 4
.cp 6
PROCEDURE  ak36until_param
.sp 2
The procedure fetches the time and date information
for Restore Log .. until and writes it in the form
expected by KB to part 1 of the message buffer.
.sp 4
.cp 6
PROCEDURE  AK36VAR_PART2_TO_MESS_BUF
.sp
The procedure writes to part 1 of the message
buffer part 2 of the sql-packet
starting at position 1 with length len beginning from position
Part1_len + 1. If the length is greater
than the maximum buffer length, the
rest is written to part 2 of the message buffer.
.sp 4
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      cak36_release   = true;
      cak36short_month_msgno = 17401;
      cak36short_day_msgno   = 17600;
      cak36_lmon_min_msgno   = 17700;
      cak36_lday_max_msgno   = 17711;
      cak_call_from_rsend    = true (* a06lsend_mess_buf *);
      c_for_init             = true (* s78language *);
      c_change_curr_user     = true;
      c_on                   = true;
      c_forActivation        = true;
      (* positions in kernel version string *)
      c_major      = 11;
      c_minor      = 13;
      c_correction = 15;
      c_build      = 26;
 
VAR
      ak36restart_date : tsp00_Int4;
      ak36restart_time : tsp00_Int4;
      (* PTS 1111229 E.Z. *)
 
 
(*------------------------------*) 
 
PROCEDURE
      ak36cold_session_init (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv DO
    BEGIN
    WITH a_transinf, tri_trans DO
        BEGIN
        trSessionId_gg00.ci4_gg00    := cgg_nil_session;
        trTransId_gg00.ci6_gg00      := cgg_zero_trans;
        trWriteTransId_gg00.ci6_gg00 := cgg_zero_trans;      (* PTS 1108234 JA 2000-11-17 *)
        trSubtransId_gg00            := cgg_zero_subtrans;
        tri_global_state             := [  ];
        (* PTS 1107767 E.Z. *)
        trState_gg00               := [ tsDbFullNowait_egg00 ];
        trTempCount_gg00           := 0;
        trSessionAuxCounter_gg00   := 0; (* h.b. PTS 1107826 *)
        trWarning_gg00             := [  ];
        (* PTS 1119766 E.Z. *)
        trBdTcachePtr_gg00         := NIL;
        trAcvPtr_gg00              := @acv;
        END;
    (*ENDWITH*) 
    a_pars_curr         := b01niltree_id;
    a_sqlmode           := sqlm_internal;
    a_session_sqlmode   := sqlm_internal;
    a_in_internal_subtr := false;
    a_in_session        := false;
    a_costwarn_value    := csp_maxint4;
    a_costlimit_value   := csp_maxint4;
    a_createSharedSQL   := false;
    gg06SetNilRef (a_user_perm_ref);
    a_db_full_connection:= true;  (* full for admin-mode ! see a_pars_curr above *)
    a_acc_dba_id            := cak_zerotableid;
    a_acc_dbaname           := a01_il_b_identifier;
    a_acc_user              := a_curr_user_name;
    a_acc_user_id           := cak_util_user_id;
    a_curr_user_id          := cak_util_user_id;
    a_current_user_kind     := ucontroluser;
    a_acc_groupname         := a01_il_b_identifier;
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36cold_connect  (VAR acv : tak_all_command_glob;
            VAR a30v : tak_a30_utility_glob);
 
VAR
      password  : tsp00_CryptPw;
      xpcntrlpw : tsp00_CryptPw;
 
BEGIN
WITH acv, a30v DO
    BEGIN
    a_size_ptr := NIL;
    IF  a_returncode = 0
    THEN
        BEGIN
        a3ti := 3;
        WITH a_ap_tree^[a3ti] DO
            IF  n_symb = s_authid
            THEN
                BEGIN
                a05identifier_get (acv, a3ti,
                      sizeof (a_curr_user_name), a_curr_user_name);
                a3ti  := n_sa_level;
                END
            ELSE
                BEGIN
                (* aus variable *)
                a07_b_put_error (acv, e_variable_not_allowed, 1);
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a51getascii_password (acv, password); (* PTS 1109594 *)
        xpcntrlpw := g01controluser.gg04cu_password;
        IF  g01unicode
        THEN
            a51trimcn_password (xpcntrlpw);
        (*ENDIF*) 
        a_current_user_kind := unoprivate;
        IF  (a_curr_user_name = a01controluser)
            AND (password = xpcntrlpw)
        THEN
            a_current_user_kind := usysdba;
        (* PTS 1115978 E.Z. *)
        (*ENDIF*) 
        IF  a_current_user_kind <> unoprivate
        THEN
            (* PTS 1111229 E.Z. *)
            ak36cold_session_init (acv)
        ELSE
            a07_b_put_error (acv,
                  e_unknown_user_password_pair, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36cold_release (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv DO
    BEGIN
    IF  a_transinf.tri_trans.trIndex_gg00 <> cgg_nil_transindex
    THEN
        BEGIN
        (* release trans_entry and remove locks *)
        IF  acv.a_returncode = 0
        THEN
            k53commit (a_transinf.tri_trans, mm_nil)
        ELSE
            k53rollback (a_transinf.tri_trans, mm_nil);
        (*ENDIF*) 
        IF  a_transinf.tri_trans.trError_gg00 <> e_shutdown
        THEN
            k51del_transentry_from_locklist (a_transinf.tri_trans.trTaskId_gg00,
                  a_transinf.tri_trans.trIndex_gg00,
                  a_transinf.tri_trans)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a_transinf.tri_trans.trError_gg00              := e_ok;
    a_transinf.tri_trans.trState_gg00              := [  ];
    a_transinf.tri_trans.trSessionId_gg00.ci4_gg00 := cgg_nil_session;
    a_transinf.tri_global_state                    := [  ];
    a_use_timeout                                  := false;
    a_pars_curr                                    := b01niltree_id;
    a_curr_user_name                               := a01_il_b_identifier;
    a_returncode                 := cak_e_released;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36connect (VAR acv : tak_all_command_glob;
            VAR in_warm_session : boolean);
 
VAR
      connect_rec   : tak_connect_rec;
 
BEGIN
WITH acv.a_transinf.tri_trans DO
    BEGIN
    (* remove session from lock list *)
    k51remove_locks (trTaskId_gg00, trIndex_gg00, trState_gg00);
    k51del_transentry_from_locklist (trTaskId_gg00, trIndex_gg00, acv.a_transinf.tri_trans)
    END;
(*ENDWITH*) 
WITH connect_rec DO
    BEGIN
    cn_username       := a01controluser;
    cn_password       := g01controluser.gg04cu_password;
    IF  g01unicode
    THEN
        a51trimcn_password (cn_password);
    (*ENDIF*) 
    cn_timeout        := csp_maxint2;
    cn_global_state   := [ hsConsistentLock_egg00 ];
    cn_internal       := true;
    cn_tmp_cache_size := 0;
    cn_mysql_connect  := false;
    END;
(*ENDWITH*) 
WITH acv.a_dca DO
    BEGIN
    code_size               := 0;
    value_size              := 0;
    code_p                  := NIL;
    value_p                 := NIL;
    END;
(*ENDWITH*) 
a51connect (acv, connect_rec, NOT c_change_curr_user);
in_warm_session := acv.a_returncode = 0
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36create_default_sets (VAR acv : tak_all_command_glob);
 
VAR
      b_err          : tgg00_BasisError;
      i              : integer;
      sysk           : tgg00_SysInfoKey;
 
BEGIN
(*== default mapchar set =====================================*)
sysk             := a01defaultkey;
sysk.sentrytyp   := cak_emapset;
sysk.slinkage    := cak_init_linkage;
a01sets_identifier (sysk.sidentifier, cak00_default_mapchar_set);
sysk.skeylen     := sizeof (sysk.stableid) +
      sizeof (sysk.sentrytyp) + sizeof (sysk.slinkage) +
      sizeof (sysk.sidentifier);
a10_nil_get_sysinfo (acv, sysk, d_release,
      sizeof (tak_mapset_record), acv.a_ptr1, b_err);
IF  b_err = e_ok
THEN
    WITH acv.a_ptr1^, smapset DO
        BEGIN
        map_code       := csp_ascii;
        map_count      := 0;
        i              := 1;
        map_set[ i   ] := chr (161);
        map_set[ i+1 ] := chr ( 33); (* ascii ! *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (191);
        map_set[ i+1 ] := chr ( 63); (* ascii ? *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        (* *)
        map_set[ i   ] := chr (192);
        map_set[ i+1 ] := chr ( 65); (* ascii A *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (193);
        map_set[ i+1 ] := chr ( 65); (* ascii A *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (194);
        map_set[ i+1 ] := chr ( 65); (* ascii A *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (195);
        map_set[ i+1 ] := chr ( 65); (* ascii A *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (196);
        map_set[ i+1 ] := chr ( 65); (* ascii A *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (197);
        map_set[ i+1 ] := chr ( 65); (* ascii A *)
        map_set[ i+2 ] := chr ( 97); (* ascii a *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (198);
        map_set[ i+1 ] := chr ( 65); (* ascii A *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (199);
        map_set[ i+1 ] := chr ( 67); (* ascii C *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (200);
        map_set[ i+1 ] := chr ( 69); (* ascii E *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (201);
        map_set[ i+1 ] := chr ( 69); (* ascii E *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (202);
        map_set[ i+1 ] := chr ( 69); (* ascii E *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (203);
        map_set[ i+1 ] := chr ( 69); (* ascii E *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (204);
        map_set[ i+1 ] := chr ( 73); (* ascii I *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (205);
        map_set[ i+1 ] := chr ( 73); (* ascii I *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (206);
        map_set[ i+1 ] := chr ( 73); (* ascii I *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (207);
        map_set[ i+1 ] := chr ( 73); (* ascii I *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (208);
        map_set[ i+1 ] := chr ( 68); (* ascii D *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (209);
        map_set[ i+1 ] := chr ( 78); (* ascii N *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (210);
        map_set[ i+1 ] := chr ( 79); (* ascii O *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (211);
        map_set[ i+1 ] := chr ( 79); (* ascii O *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (212);
        map_set[ i+1 ] := chr ( 79); (* ascii O *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (213);
        map_set[ i+1 ] := chr ( 79); (* ascii O *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (214);
        map_set[ i+1 ] := chr ( 79); (* ascii O *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        (* 215 / D7: multiply operator *)
        map_set[ i   ] := chr (216);
        map_set[ i+1 ] := chr ( 79); (* ascii O *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (217);
        map_set[ i+1 ] := chr ( 85); (* ascii U *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (218);
        map_set[ i+1 ] := chr ( 85); (* ascii U *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (219);
        map_set[ i+1 ] := chr ( 85); (* ascii U *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (220);
        map_set[ i+1 ] := chr ( 85); (* ascii U *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (221);
        map_set[ i+1 ] := chr ( 89); (* ascii Y *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (222);
        map_set[ i+1 ] := chr ( 80); (* ascii P *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (223);
        map_set[ i+1 ] := chr (115); (* ascii s *)
        map_set[ i+2 ] := chr (115); (* ascii s *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (224);
        map_set[ i+1 ] := chr ( 97); (* ascii a *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (225);
        map_set[ i+1 ] := chr ( 97); (* ascii a *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (226);
        map_set[ i+1 ] := chr ( 97); (* ascii a *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (227);
        map_set[ i+1 ] := chr ( 97); (* ascii a *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (228);
        map_set[ i+1 ] := chr ( 97); (* ascii a *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (229);
        map_set[ i+1 ] := chr ( 97); (* ascii a *)
        map_set[ i+2 ] := chr ( 97); (* ascii a *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (230);
        map_set[ i+1 ] := chr ( 97); (* ascii a *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (231);
        map_set[ i+1 ] := chr ( 99); (* ascii c *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (232);
        map_set[ i+1 ] := chr (101); (* ascii e *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (233);
        map_set[ i+1 ] := chr (101); (* ascii e *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (234);
        map_set[ i+1 ] := chr (101); (* ascii e *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (235);
        map_set[ i+1 ] := chr (101); (* ascii e *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (236);
        map_set[ i+1 ] := chr (105); (* ascii i *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (237);
        map_set[ i+1 ] := chr (105); (* ascii i *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (238);
        map_set[ i+1 ] := chr (105); (* ascii i *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (239);
        map_set[ i+1 ] := chr (105); (* ascii i *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (240);
        map_set[ i+1 ] := chr (100); (* ascii d *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (241);
        map_set[ i+1 ] := chr (110); (* ascii n *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (242);
        map_set[ i+1 ] := chr (111); (* ascii o *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (243);
        map_set[ i+1 ] := chr (111); (* ascii o *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (244);
        map_set[ i+1 ] := chr (111); (* ascii o *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (245);
        map_set[ i+1 ] := chr (111); (* ascii o *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (246);
        map_set[ i+1 ] := chr (111); (* ascii o *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        (* 215 / D7: divide operator *)
        map_set[ i   ] := chr (248);
        map_set[ i+1 ] := chr (111); (* ascii o *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (249);
        map_set[ i+1 ] := chr (117); (* ascii u *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (250);
        map_set[ i+1 ] := chr (117); (* ascii u *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (251);
        map_set[ i+1 ] := chr (117); (* ascii u *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (252);
        map_set[ i+1 ] := chr (117); (* ascii u *)
        map_set[ i+2 ] := chr (101); (* ascii e *)
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (253);
        map_set[ i+1 ] := chr (121); (* ascii y *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (254);
        map_set[ i+1 ] := chr (112); (* ascii p *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_set[ i   ] := chr (255);
        map_set[ i+1 ] := chr (121); (* ascii y *)
        map_set[ i+2 ] := csp_ascii_blank;
        map_count      := map_count + 1;
        i := i + 3;
        map_filler1 := false;
        map_filler2 := 0;
        map_segmentid := cak00_public_segment_id;
        map_reclen    := sizeof (smapset) - sizeof (map_set) +
              map_count * 3;
        a10add_sysinfo (acv, acv.a_ptr1, b_err)
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36default_nls (VAR acv : tak_all_command_glob);
 
VAR
      b_err : tgg00_BasisError;
      buf   : tak_sysbufferaddress;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
sysk           := a01defaultkey;
sysk.sentrytyp := cak_emapset;
a01sets_identifier (sysk.sidentifier, 'DEFAULTSORT       ');
sysk.skeylen   := sysk.skeylen + sizeof (sysk.sidentifier);
a10get_sysinfo (acv, sysk, d_release, buf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    g01nls_sort        := true;
    g01nls_default_map := sysk.sidentifier
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36install (VAR acv : tak_all_command_glob;
            VAR a30v            : tak_a30_utility_glob;
            integrate           : boolean);
 
CONST
      c_inMigration = true;
 
VAR
      b_err         : tgg00_BasisError;
      a20v          : tak_a21_glob;
 
BEGIN
WITH acv, a20v DO
    BEGIN
    a21init_glob (a20v);
    IF  NOT integrate
    THEN
        BEGIN
        a2ti := a_ap_tree^[ 0 ].n_lo_level   (* = init config *) ;
        a2ti := a_ap_tree^[ a2ti].n_sa_level (* = activate *);
        a2ti := a_ap_tree^[ a2ti].n_sa_level (* = sysdba-name *);
        a2ti := a_ap_tree^[ a2ti].n_sa_level (* = sysdba-pw *);
        a_input_data_pos := 0;
        a05password_get (acv, a2ti, a2password)
        END;
    (*ENDIF*) 
    ak36mess_buf_init (acv, m_commit, mm_nil);
    a06lsend_mess_buf (acv, a_mblock,
          NOT cak_call_from_rsend, b_err);
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    IF  (a_returncode = 0) AND NOT integrate
    THEN
        ak36create_default_sets (acv);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        a38create_parameter_file (acv);
    (*ENDIF*) 
    IF  (a_returncode = 0) AND NOT integrate
    THEN
        BEGIN
        a2user_name          := a30v.a3authname;
        g01glob.sysuser_name := a2user_name;
        a2userkind           := cak_i_sysdba;
        a2exclusive          := false; (* h.b. PTS 1107478 *)
        IF  a_returncode = 0
        THEN
            BEGIN
            a_is_ddl := ddl_create_user;
            a21create_user (acv, a20v)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (a_returncode = 0) AND NOT integrate
    THEN
        a34InitOms(acv, NOT c_inMigration);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        a_returncode := a103CreateCatalog;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        a52_ex_commit_rollback (acv, m_commit,
              NOT cak36_release, NOT cak36_release);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak36IsCurrentKnlVersion (VAR version : tsp00_Version) : boolean;
 
VAR
      isEqualVersion : boolean;
      ix             : integer;
      currVersion    : tsp00_Version;
 
BEGIN
g11kernel_version (currVersion);
isEqualVersion := true;
FOR  ix := c_major TO c_build + 2 DO
    IF  version[ix] <> currVersion[ix]
    THEN
        isEqualVersion := false;
    (*ENDIF*) 
(*ENDFOR*) 
ak36IsCurrentKnlVersion := isEqualVersion;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36diagnose_command (VAR acv : tak_all_command_glob;
            VAR a30v  : tak_a30_utility_glob);
 
VAR
      diag_kind     : tgg00_DiagType;
      i             : integer;
      aux_data_size : tsp00_Int4;
      aux_data      : tgg00_DataPartPtr;
      page_part     : tsp1_part_ptr;
      hostfilename  : tsp00_VFilename;
 
BEGIN
WITH acv, a_mblock, a30v DO
    BEGIN
    aux_data := NIL;
    a37init_util_record (acv, m_diagnose, mm_nil);
    FOR i := 1 TO a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_length DO
        mb_qual^.mut_diag_type := succ(mb_qual^.mut_diag_type);
    (*ENDFOR*) 
    diag_kind := mb_qual^.mut_diag_type;
    hostfilename := b01blankfilename;
    a3ti      := 2;
    WITH a_ap_tree^[ 2 ] DO
        IF  n_symb = s_hostfilename
        THEN
            (* diagnose command including a host filename *)
            BEGIN
            a36filename (acv, 2,
                  mb_qual^.mut_hostfn, sizeof (mb_qual^.mut_hostfn));
            a3ti := n_sa_level;
            IF  mb_qual^.mut_hostfn <> b01blankfilename
            THEN
                hostfilename := mb_qual^.mut_hostfn;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
    CASE diag_kind OF
        diagIsStateAdmin_egg00:
            BEGIN
            (* in case of state admin no error is returned *)
            (* see utility connect in vut02                *)
            END;
        diagColRoot_egg00, diagInvRoot_egg00, diagFile_egg00 :
            WITH a_ap_tree^[ a3ti ] DO
                a05_int4_unsigned_get (acv, n_pos, n_length, mb_qual^.mut_pno);
            (*ENDWITH*) 
        diagFDir1_egg00, diagFDir2_egg00:
            BEGIN
            ;
            END;
        diagDev_egg00 :
            BEGIN
            a36devname (acv, a3ti, mb_qual^.mut_dev, sizeof (mb_qual^.mut_dev));
            a3ti := a_ap_tree^[a3ti].n_sa_level;
            WITH a_ap_tree^[ a3ti ] DO
                a05_int4_unsigned_get (acv,
                      n_pos, n_length, mb_qual^.mut_pno);
            (*ENDWITH*) 
            a3ti := a_ap_tree^[ a3ti ].n_sa_level;
            WITH a_ap_tree^[ a3ti ] DO
                a05_int4_unsigned_get (acv,
                      n_pos, n_length, mb_qual^.mut_pno2);
            (*ENDWITH*) 
            IF  a_curr_retpart = NIL
            THEN
                a06init_curr_retpart (acv);
            (*ENDIF*) 
            aux_data              := a_mblock.mb_data;
            aux_data_size         := a_mblock.mb_data_size;
            a_mblock.mb_data      := @a_curr_retpart^.sp1p_buf;
            a_mblock.mb_data_size :=  a_curr_retpart^.sp1p_buf_size;
            END;
        diagLogDev_egg00, diagMirrLogDev_egg00:
            BEGIN
            WITH a_ap_tree^[ a3ti ] DO
                a05_int4_unsigned_get (acv,
                      n_pos, n_length, mb_qual^.mut_count); (* devno *)
            (*ENDWITH*) 
            a3ti := a_ap_tree^[a3ti].n_sa_level;
            WITH a_ap_tree^[ a3ti ] DO
                a05_int4_unsigned_get (acv,
                      n_pos, n_length, mb_qual^.mut_pno);
            (*ENDWITH*) 
            a3ti := a_ap_tree^[ a3ti ].n_sa_level;
            WITH a_ap_tree^[ a3ti ] DO
                a05_int4_unsigned_get (acv,
                      n_pos, n_length, mb_qual^.mut_pno2);
            (*ENDWITH*) 
            IF  a_curr_retpart = NIL
            THEN
                a06init_curr_retpart (acv);
            (*ENDIF*) 
            aux_data              := a_mblock.mb_data;
            aux_data_size         := a_mblock.mb_data_size;
            a_mblock.mb_data      := @a_curr_retpart^.sp1p_buf;
            a_mblock.mb_data_size :=  a_curr_retpart^.sp1p_buf_size;
            END;
        diagLoginfoPage_egg00, diagRestart_egg00,
        diagPermPages_egg00, diagStaticPages_egg00:
            BEGIN
            IF  (diag_kind <> diagLoginfoPage_egg00) AND
                (diag_kind <> diagRestart_egg00    )
            THEN
                WITH a_ap_tree^[ a3ti ] DO
                    a05_int4_unsigned_get (acv,
                          n_pos, n_length, mb_qual^.mut_pno);
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  a_curr_retpart = NIL
            THEN
                a06init_curr_retpart (acv);
            (*ENDIF*) 
            aux_data              := a_mblock.mb_data;
            aux_data_size         := a_mblock.mb_data_size;
            a_mblock.mb_data      := @a_curr_retpart^.sp1p_buf;
            a_mblock.mb_data_size :=  a_curr_retpart^.sp1p_buf_size;
            END;
        diagRestore_egg00 :
            BEGIN
            mb_qual^.mut_diag_type := diagNil_egg00;
            FOR i := 1 TO a_ap_tree^[2].n_length DO
                mb_qual^.mut_diag_type := succ(mb_qual^.mut_diag_type);
            (*ENDFOR*) 
            aux_data      := mb_data;
            aux_data_size := mb_data_size;
            (* PTS 1128732 E.Z. *)
            page_part     := acv.a_data_part;
            IF  page_part = NIL
            THEN
                a07_b_put_error (acv, e_too_short_datapart, 1)
            ELSE
                BEGIN
                mb_type2     := mm_device_restore;
                mb_data      := @page_part^.sp1p_buf;
                mb_data_size :=  page_part^.sp1p_buf_size;
                mb_data_len  :=  page_part^.sp1p_buf_len;
                a3ti         := a_ap_tree^[2].n_sa_level;
                IF  (a3ti <> 0)
                    AND (mb_qual^.mut_diag_type <> diagLoginfoPage_egg00)
                    AND (mb_qual^.mut_diag_type <> diagPermPages_egg00  )
                    AND (mb_qual^.mut_diag_type <> diagStaticPages_egg00)
                    AND (mb_qual^.mut_diag_type <> diagRestart_egg00    )
                THEN
                    BEGIN
                    CASE mb_qual^.mut_diag_type OF
                        diagDev_egg00:
                            BEGIN
                            a36devname (acv, a3ti, mb_qual^.mut_dev,
                                  sizeof (mb_qual^.mut_dev));
                            a3ti := a_ap_tree^[a3ti].n_sa_level
                            END;
                        diagLogDev_egg00, diagMirrLogDev_egg00:
                            BEGIN
                            WITH a_ap_tree^[a3ti] DO
                                a05_int4_unsigned_get (acv,
                                      n_pos, n_length,
                                      mb_qual^.mut_count); (* devno *)
                            (*ENDWITH*) 
                            a3ti := a_ap_tree^[a3ti].n_sa_level;
                            END;
                        OTHERWISE ;
                        END;
                    (*ENDCASE*) 
                    WITH a_ap_tree^[ a3ti ] DO
                        a05_int4_unsigned_get (acv,
                              n_pos, n_length, mb_qual^.mut_pno);
                    (*ENDWITH*) 
                    mb_qual^.mut_pno2 := mb_qual^.mut_pno
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        OTHERWISE
            a07_b_put_error (acv, e_invalid_command, 1);
        END;
    (*ENDCASE*) 
    IF  diag_kind <> diagIsStateAdmin_egg00
    THEN
        ak36send_mess_buf_cold  (acv);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  (diag_kind = diagLoginfoPage_egg00) OR
            (diag_kind = diagPermPages_egg00  ) OR
            (diag_kind = diagStaticPages_egg00) OR
            (diag_kind = diagRestart_egg00    ) OR
            (diag_kind = diagDev_egg00        ) OR
            (diag_kind = diagLogDev_egg00     ) OR
            (diag_kind = diagMirrLogDev_egg00 )
        THEN
            BEGIN
            IF  a_mblock.mb_data_len > 0
            THEN
                BEGIN
                a_curr_retpart^.sp1p_buf_len:= a_mblock.mb_data_len;
                a06finish_curr_retpart (acv, sp1pk_page, 1)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  hostfilename <> b01blankfilename
        THEN
            (* put host filename to new data part of return segm *)
            a37return_hostname (acv);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  aux_data <> NIL
    THEN
        BEGIN
        a_mblock.mb_data      := aux_data;
        a_mblock.mb_data_size := aux_data_size
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36diag_outcopy (VAR acv : tak_all_command_glob);
 
VAR
      b_err         : tgg00_BasisError;
      arg_count     : integer;
      aux_data_size : tsp00_Int4;
      aux_data      : tgg00_DataPartPtr;
 
BEGIN
WITH acv DO
    BEGIN
    aux_data      := a_mblock.mb_data;
    aux_data_size := a_mblock.mb_data_size;
    a37init_util_record (acv, m_outcopy, mm_nil);
    IF  a_curr_retpart = NIL
    THEN
        a06init_curr_retpart (acv);
    (*ENDIF*) 
    IF  a_curr_retpart = NIL
    THEN
        b_err := e_not_implemented
    ELSE
        BEGIN
        a_mblock.mb_data      := @a_curr_retpart^.sp1p_buf;
        a_mblock.mb_data_size :=  a_curr_retpart^.sp1p_buf_size;
        IF  NOT gg999KernelStateIsOnline
        THEN
            a06_c_send_mess_buf (acv, b_err)
        ELSE
            b_err := e_not_implemented
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (b_err <> e_ok            ) AND
        (b_err <> e_no_next_record)
    THEN
        a07_b_put_error (acv, b_err, 1)
    ELSE
        WITH a_curr_retpart^ DO
            BEGIN
            sp1p_buf_len := a_mblock.mb_data_len;
            IF  b_err = e_no_next_record
            THEN
                sp1p_attributes :=
                      sp1p_attributes + [sp1pa_last_packet];
            (*ENDIF*) 
            arg_count := sp1p_buf_len DIV sizeof (tsp00_Page);
            a06finish_curr_retpart (acv, sp1pk_page, arg_count)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    a_mblock.mb_data      := aux_data;
    a_mblock.mb_data_size := aux_data_size
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36dg_tablename_get (VAR t : tgg00_TransContext;
            VAR tabid     : tgg00_Surrogate;
            VAR owner_id  : tgg00_Surrogate;
            VAR tablename : tsp00_KnlIdentifier);
 
VAR
      pos    : integer;
      sysk   : tgg00_SysInfoKey;
      sysbuf : tak_systembuffer;
 
BEGIN
tablename     := a01_il_b_identifier;
sysk          := a01defaultkey;
sysk.stableid := tabid;
a36get_catalog_record (t, sysk, sysbuf);
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    owner_id  := sysbuf.sbase.bauthid;
    pos       := a10BaseRecPersistentOffset + 1; (* PTS 1105713, T.A. 24.02.2000 *)
    SAPDB_PascalMove ('VAK36 ',   1,    
          sizeof (sysbuf.sbase), sizeof (tablename),
          @sysbuf, pos + 1, @tablename, 1, ord (sysbuf.ssysbuf[pos]), t.trError_gg00)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36dg_username_get (VAR t : tgg00_TransContext;
            VAR user_id  : tgg00_Surrogate;
            VAR username : tsp00_KnlIdentifier);
 
VAR
      sysk   : tgg00_SysInfoKey;
      sysbuf : tak_systembuffer;
 
BEGIN
sysk           := a01defaultkey;
sysk.sauthid   := user_id;
sysk.sentrytyp := cak_euser;
a36get_catalog_record (t, sysk, sysbuf);
IF  t.trError_gg00 = e_ok
THEN
    username := sysbuf.suser.username
ELSE
    username := a01_il_b_identifier
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36get_bad_log_volume (VAR acv : tak_all_command_glob;
            VAR a30v            : tak_a30_utility_glob);
 
VAR
      aux_data_size   : tsp00_Int4;
      mess_data_buf   : tsp00_Buf;
      aux_data_ptr    : tgg00_DataPartPtr;
      shortinfo       : tak_shortinforecord;
      name            : tsp00_C28;
 
BEGIN
WITH acv, a_mblock, a30v DO
    BEGIN
    aux_data_ptr  := mb_data;
    aux_data_size := mb_data_size;
    mb_data       := @mess_data_buf;
    mb_data_size  := sizeof (mess_data_buf);
    k05GetBadLogVolume (a_mblock);
    IF  a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        name := 'VOLUME                      ';
        a06colname_retpart_move (acv, @name, 6, csp_ascii);
        WITH shortinfo.siinfo[1] DO
            BEGIN (* restart lpno *)
            sp1i_mode       := [ sp1ot_mandatory ];
            sp1i_io_type    := sp1io_output;
            sp1i_data_type  := dcha;
            sp1i_frac       := 0;
            sp1i_length     := pred(acv.a_mblock.mb_data_len);
            sp1i_in_out_len := acv.a_mblock.mb_data_len;
            sp1i_bufpos     := 1;
            END;
        (*ENDWITH*) 
        a06finish_curr_retpart (acv, sp1pk_columnnames, 1);
        shortinfo.sicount := 1;
        a06retpart_move (acv, @shortinfo.siinfo,
              shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
        a06finish_curr_retpart (acv, sp1pk_shortinfo, shortinfo.sicount);
        a06char_retpart_move (acv,
              @acv.a_mblock.mb_data^.mbp_buf, acv.a_mblock.mb_data_len);
        a06finish_curr_retpart (acv, sp1pk_data, 1);
        END;
    (*ENDIF*) 
    mb_data      := aux_data_ptr;
    mb_data_size := aux_data_size
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36get_config_device (VAR acv : tak_all_command_glob;
            VAR a30v : tak_a30_utility_glob;
            mm_type  : tgg00_MessType2);
 
VAR
      mess_double_buf : tgg00_DoubleBuf;
 
BEGIN
ak36get_config2_device (acv, a30v, mm_type, mess_double_buf)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36get_restart_version (VAR acv : tak_all_command_glob);
 
VAR
      shortinfo : tak_shortinforecord;
      pos       : tsp00_Int4; (* PTS 1000449 UH 19980909 *)
      name      : tsp00_C28;
 
BEGIN
pos := 1;
a37init_util_record (acv, m_get, mm_log);
gg999GetRestartVersion (acv.a_mblock);
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    (* PTS 1113268 E.Z. *)
    name := 'FIRST IO SEQUENCE NEEDED    ';
    a06colname_retpart_move (acv, @name, 24, csp_ascii);
    WITH shortinfo.siinfo[1] DO
        BEGIN (* restart lpno *)
        sp1i_mode       := [ sp1ot_mandatory ];
        sp1i_io_type    := sp1io_output;
        sp1i_data_type  := dfixed;
        sp1i_frac       := 0;
        sp1i_length     := csp_resnum_deflen;
        sp1i_in_out_len := mxsp_resnum;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len
        END;
    (*ENDWITH*) 
    (* PTS 1000286 UH *)
    name := 'FIRST IO SEQUENCE ON LOG    ';
    a06colname_retpart_move (acv, @name, 24, csp_ascii);
    shortinfo.siinfo[2]             := shortinfo.siinfo[1];
    shortinfo.siinfo[2].sp1i_bufpos := pos;
    pos := pos + shortinfo.siinfo[2].sp1i_in_out_len;
    (* *)
    name := 'RESTARTABLE                 ';
    a06colname_retpart_move (acv, @name, 11, csp_ascii);
    shortinfo.siinfo[3]             := shortinfo.siinfo[1];
    shortinfo.siinfo[3].sp1i_bufpos := pos;
    pos := pos + shortinfo.siinfo[3].sp1i_in_out_len;
    (* *)
    name := 'DB IDENT FROM RESTARTRECORD ';
    a06colname_retpart_move (acv, @name, 27, csp_ascii);
    (* PTS 1000449 UH 19980909 begin *)
    WITH shortinfo.siinfo[4] DO
        BEGIN
        sp1i_mode       := [ sp1ot_mandatory ];
        sp1i_io_type    := sp1io_output;
        sp1i_data_type  := dcha;
        sp1i_frac       := 0;
        sp1i_length     := sizeof (tsp00_Line);
        sp1i_in_out_len := sp1i_length + 1;
        sp1i_bufpos     := pos;
        pos             := pos + sp1i_in_out_len;
        END;
    (*ENDWITH*) 
    name := 'DB IDENT FROM LOGINFO       ';
    a06colname_retpart_move (acv, @name, 21, csp_ascii);
    shortinfo.siinfo[5]             := shortinfo.siinfo[4];
    shortinfo.siinfo[5].sp1i_bufpos := pos;
    pos := pos + shortinfo.siinfo[5].sp1i_in_out_len;
    (* *)
    name := 'RESTARTABLE WITHOUT LOG     ';
    a06colname_retpart_move (acv, @name, 23, csp_ascii);
    (* PTS 1106528 UH 20000509 begin *)
    shortinfo.siinfo[6]             := shortinfo.siinfo[1];
    shortinfo.siinfo[6].sp1i_bufpos := pos;
    pos := pos + shortinfo.siinfo[6].sp1i_in_out_len;
    (* PTS 1106528 UH 20000509 end *)
    (* *)
    (* PTS 1114658 UH 2002-03-06 begin *)
    name := 'LOG VOLUME ENABLED          ';
    a06colname_retpart_move (acv, @name, 18, csp_ascii);
    shortinfo.siinfo[7]             := shortinfo.siinfo[1];
    shortinfo.siinfo[7].sp1i_bufpos := pos;
    pos := pos + shortinfo.siinfo[7].sp1i_in_out_len;
    (* PTS 1114658 UH 2002-03-06 end *)
    (* *)
    name := 'LOG AUTO OVERWRITE          ';
    a06colname_retpart_move (acv, @name, 18, csp_ascii);
    shortinfo.siinfo[8]             := shortinfo.siinfo[1];
    shortinfo.siinfo[8].sp1i_bufpos := pos;
    pos := pos + shortinfo.siinfo[8].sp1i_in_out_len;
    (* *)
    (* PTS 1111229 E.Z. *)
    name := 'MASTER SERVERNODE           ';
    a06colname_retpart_move (acv, @name, 17, csp_ascii);
    shortinfo.siinfo[9]                 := shortinfo.siinfo[4];
    shortinfo.siinfo[9].sp1i_bufpos     := pos;
    shortinfo.siinfo[9].sp1i_length     := NODEID_MXSP00;
    shortinfo.siinfo[9].sp1i_in_out_len := NODEID_MXSP00 + 1;
    pos := pos + shortinfo.siinfo[9].sp1i_in_out_len;
    (* *)
    (* PTS 1115847 E.Z. *)
    name := 'CONVERTER VERSION           ';
    a06colname_retpart_move (acv, @name, 17, csp_ascii);
    shortinfo.siinfo[10]             := shortinfo.siinfo[1];
    shortinfo.siinfo[10].sp1i_bufpos := pos;
    pos := pos + shortinfo.siinfo[10].sp1i_in_out_len;
    (* END PTS 1115847 E.Z. *)
    (* *)
    name := 'OLDEST COMPATIBLE VERSION   ';
    a06colname_retpart_move (acv, @name, 25, csp_ascii);
    shortinfo.siinfo[11]                 := shortinfo.siinfo[4];
    shortinfo.siinfo[11].sp1i_bufpos     := pos;
    shortinfo.siinfo[11].sp1i_length     := 11 (* MM.MM.CC.BB *);
    shortinfo.siinfo[11].sp1i_in_out_len := 11 (* MM.MM.CC.BB *) + 1;
    pos := pos + shortinfo.siinfo[11].sp1i_in_out_len;
    (* *)
    (* PTS 1130336 mb 2004-08-13 queue count added *)
    name := 'QUEUE COUNT                 ';
    a06colname_retpart_move (acv, @name, 11, csp_ascii);
    shortinfo.siinfo[12]             := shortinfo.siinfo[1];
    shortinfo.siinfo[12].sp1i_bufpos := pos;
    pos := pos + shortinfo.siinfo[12].sp1i_in_out_len;
    (* *)
    a06finish_curr_retpart (acv, sp1pk_columnnames, 12);
    shortinfo.sicount := 12;
    a06retpart_move (acv, @shortinfo.siinfo,
          shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
    a06finish_curr_retpart (acv, sp1pk_shortinfo, shortinfo.sicount);
    (* PTS 1000449 UH 19980909 end *)
    a06char_retpart_move (acv,
          @acv.a_mblock.mb_data^.mbp_buf, acv.a_mblock.mb_data_len);
    a06finish_curr_retpart (acv, sp1pk_data, 1);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36get_config2_device (VAR acv : tak_all_command_glob;
            VAR a30v            : tak_a30_utility_glob;
            mm_type             : tgg00_MessType2;
            VAR mess_double_buf : tgg00_DoubleBuf);
 
VAR
      aux_data_size : tsp00_Int4;
      aux_data_ptr  : tgg00_DataPartPtr;
 
BEGIN
WITH acv, a_mblock, a30v DO
    BEGIN
    ak36mess_buf_init (acv, m_get, mm_type);
    aux_data_ptr  := mb_data;
    aux_data_size := mb_data_size;
    mb_data       := @mess_double_buf;
    mb_data_size  := sizeof (mess_double_buf);
    ak36send_mess_buf_cold (acv);
    IF  a_returncode = 0
    THEN
        BEGIN
        a06char_retpart_move (acv, @mb_data^.mbp_buf, mb_data_len);
        a06finish_curr_retpart (acv, sp1pk_data, 1)
        END;
    (*ENDIF*) 
    mb_data      := aux_data_ptr;
    mb_data_size := aux_data_size
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36get_sysdba (VAR acv : tak_all_command_glob;
            VAR userid   : tgg00_Surrogate;
            VAR username : tsp00_KnlIdentifier;
            VAR version  : tsp00_Version);
 
VAR
      b_err          : tgg00_BasisError;
      buf            : tak_sysbufferaddress;
      syskey         : tgg00_SysInfoKey;
      msg            : tsp00_C40;
 
BEGIN
syskey           := a01defaultkey;
syskey.ssite     := cgg_zero_c2;
syskey.sentrytyp := cak_esysdba;
a10get_sysinfo (acv, syskey, d_release, buf, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    userid  := buf^.ssysdba.sysauthid;
    IF  buf^.b_sl < sizeof(tak_sysdbarecord)
    THEN
        BEGIN (* old layout without version info, check release via old version info *)
        g11kernel_version (version);
        version[c_major+1]      := '.';
        version[c_minor+1]      := '.';
        CASE buf^.ssysdba.sysversion OF
            35 : (* >= 7.3.0.35 *)
                BEGIN
                version[c_major     ] := '7';
                version[c_minor     ] := '3';
                version[c_correction] := '0';
                version[c_build     ] := '0';
                version[c_build+1   ] := '3';
                version[c_build+2   ] := '5';
                END;
            34 : (* >= 7.3.0.25 *)
                BEGIN
                version[c_major     ] := '7';
                version[c_minor     ] := '3';
                version[c_correction] := '0';
                version[c_build     ] := '0';
                version[c_build+1   ] := '2';
                version[c_build+2   ] := '5';
                END;
            32 : (* 7.4.2 *)
                BEGIN
                version[c_major     ] := '7';
                version[c_minor     ] := '4';
                version[c_correction] := '2';
                version[c_build     ] := '0';
                version[c_build+1   ] := '0';
                version[c_build+2   ] := '0';
                END;
            40 : (* 7.4.3.3 *)
                BEGIN
                version[c_major     ] := '7';
                version[c_minor     ] := '4';
                version[c_correction] := '3';
                version[c_build     ] := '0';
                version[c_build+1   ] := '0';
                version[c_build+2   ] := '3';
                END;
            41 : (* 7.4.3.4 *)
                BEGIN
                version[c_major     ] := '7';
                version[c_minor     ] := '4';
                version[c_correction] := '3';
                version[c_build     ] := '0';
                version[c_build+1   ] := '0';
                version[c_build+2   ] := '4';
                END;
            42 : (* 7.4.4 *)
                BEGIN
                version[c_major     ] := '7';
                version[c_minor     ] := '4';
                version[c_correction] := '4';
                version[c_build     ] := '0';
                version[c_build+1   ] := '0';
                version[c_build+2   ] := '0';
                END;
            OTHERWISE
                version := bsp_c40;
            END;
        (*ENDCASE*) 
        msg := 'unknown catalog version, assuming       ';
        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
              csp3_n_migration, msg);
        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
              csp3_n_migration, version);
        END
    ELSE
        version := buf^.ssysdba.sysKnlVersion;
    (*ENDIF*) 
    syskey.sauthid   := userid;
    syskey.sentrytyp := cak_euser;
    syskey.slinkage  := cak_init_linkage;
    a10get_sysinfo (acv, syskey, d_release, buf, b_err);
    IF  b_err = e_ok
    THEN
        username := buf^.suser.username
    ELSE
        username := a01_il_b_identifier
    (*ENDIF*) 
    END
ELSE
    username := a01_il_b_identifier
(*ENDIF*) 
END;
 
(* PTS 1115043 U.J. ak36get_xparameters() obsolete*)
(* PTS 1120611 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak36init_config (VAR acv : tak_all_command_glob;
            VAR a30v        : tak_a30_utility_glob;
            VAR util_cmd_id : tgg00_UtilCmdId);
 
BEGIN
(* UH 2003-01-03 removed: sending message buffer *)
WITH acv.a_transinf DO
    BEGIN
    gg999InitConfig (tri_trans);
    IF  tri_trans.trError_gg00 = e_ok
    THEN
        b01shutdown_filesystem (tri_trans);
    (*ENDIF*) 
    IF  tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, tri_trans.trError_gg00, 1)
    ELSE
        IF  acv.a_ap_tree^[a30v.a3ti].n_sa_level > 0
        THEN
            BEGIN
            a30v.a3ti := acv.a_ap_tree^[a30v.a3ti].n_sa_level;
            IF  acv.a_ap_tree^[a30v.a3ti].n_subproc =
                cak_x_activate
            THEN
                ak36activate (acv, a30v)
            ELSE
                IF  acv.a_ap_tree^[a30v.a3ti].n_length <> cak_i_no_keyword
                THEN
                    ak36user_restore_reaction (acv, a30v)
                ELSE
                    ak36restore_command (acv, a30v, util_cmd_id);
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1111229 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak36init_standby (VAR acv : tak_all_command_glob);
 
BEGIN
(* UH 2003-01-03 removed: sending message buffer *)
WITH acv.a_transinf DO
    BEGIN
    gg999InitStandby (tri_trans);
    IF  tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36mess_buf_init (VAR acv : tak_all_command_glob;
            m_type  : tgg00_MessType;
            mm_type : tgg00_MessType2);
 
VAR
      sys_cat : tgg00_FileId;
 
BEGIN
WITH acv DO
    BEGIN
    kb560GetSys1CatalogTreeId (sys_cat);
    a06a_mblock_init (acv, m_type, mm_type, sys_cat);
    a_mblock.mb_qual_len  := 0;
    IF  m_type in [m_change]
    THEN
        a_mblock.mb_struct := mbs_double_buf
    ELSE
        a_mblock.mb_struct := mbs_util
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36multi_tape_restore (VAR acv : tak_all_command_glob;
            VAR a30v         : tak_a30_utility_glob;
            VAR save_restore_param  : tgg00_SaveRestoreInputParam);
 
VAR
      exit_loop : boolean;
      ix        : integer;
 
BEGIN
WITH acv, a30v, save_restore_param DO
    BEGIN
    sripBlocksize_gg00   := 0;
    sripHostTapeNum_gg00 := 0;
    FOR ix := 1 TO MAX_TAPES_GG00 DO
        BEGIN
        sripHostTapecount_gg00 [ix] := 0;
        sripHostTapenames_gg00 [ix] := b01blankfilename;
        END;
    (*ENDFOR*) 
    REPEAT
        sripHostTapeNum_gg00 := sripHostTapeNum_gg00 + 1;
        a36filename (acv, a3ti,
              sripHostTapenames_gg00[sripHostTapeNum_gg00],
              sizeof(sripHostTapenames_gg00[sripHostTapeNum_gg00]));
        a3ti := a_ap_tree^[a3ti].n_sa_level;
        IF  a36filetype (acv, a3ti,
            sripHostFiletypes_gg00[sripHostTapeNum_gg00])
        THEN
            a3ti := a_ap_tree^[ a3ti ].n_sa_level;
        (*ENDIF*) 
        IF  a3ti = 0
        THEN
            exit_loop := true
        ELSE
            exit_loop := a_ap_tree^[a3ti].n_symb <> s_hostfilename;
        (*ENDIF*) 
    UNTIL
        exit_loop;
    (*ENDREPEAT*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36activate (VAR acv : tak_all_command_glob;
            VAR a30v : tak_a30_utility_glob);
 
BEGIN
WITH acv, a_mblock, a30v DO
    BEGIN
    (* PTS 1120611 E.Z. *)
    a05identifier_get (acv, a_ap_tree^[ a3ti ].n_sa_level,
          sizeof (a3authname), a3authname);
    IF  (a3authname = a01controluser) OR
        (a3authname = a01_i_sys )
    THEN
        a07_b_put_error (acv, e_user_not_allowed,
              a_ap_tree^[a_ap_tree^[a3ti].n_sa_level].n_pos);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        ak36restart (acv, a30v, true);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak36eop_st_entry (etype : tgg00_StackEntryType) : boolean;
 
BEGIN
ak36eop_st_entry := (etype <> st_func) AND
      (etype <> st_build_in_func)    AND
      (etype <> st_output)           AND
      (etype <> st_rec_output)       AND
      (etype <> st_output_join)      AND
      (etype <> st_output_build_rec)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36fill_daynames (VAR acv : tak_all_command_glob);
 
VAR
      is_ok        : boolean;
      msglen       : tsp00_Int2;
 
BEGIN
is_ok := true;
a071_getmessagetext (cak36short_day_msgno, acv.a_mblock.mb_data^.mbp_buf, msglen, is_ok);
IF  is_ok
THEN
    WITH acv.a_mblock.mb_data^, g02codetables DO
        BEGIN
        s30map (tables[ cgg04_up_ascii ], mbp_buf, 1, mbp_buf, 1, msglen);
        g03daynames_init (mbp_buf, 1, is_ok);
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36fill_monthnames (VAR acv : tak_all_command_glob);
 
VAR
      is_ok        : boolean;
      msglen       : tsp00_Int2;
 
BEGIN
is_ok := true;
a071_getmessagetext (cak36short_month_msgno, acv.a_mblock.mb_data^.mbp_buf, msglen, is_ok);
IF  is_ok
THEN
    WITH acv.a_mblock.mb_data^, g02codetables DO
        BEGIN
        s30map (tables[ cgg04_up_ascii ], mbp_buf, 1, mbp_buf, 1, msglen);
        g03monthnames_init (mbp_buf, 1, is_ok);
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36init_lang_spell (VAR acv : tak_all_command_glob);
 
VAR
      is_ok        : boolean;
      done         : boolean;
      curr_dict    : integer;
      index        : integer;
      j            : integer;
      msglen       : tsp00_Int2;
      msgno        : tsp00_Int2;
      language     : tsp00_C3;
 
BEGIN
done  := false;
msgno := cak36_lmon_min_msgno;
language := 'ENG';
is_ok := true;
j := 0;
WHILE (is_ok AND (msgno <= cak36_lday_max_msgno)) DO
    BEGIN
    j := succ(j);
    IF  j = 1
    THEN
        a071_getmessagetext (msgno, acv.a_mblock.mb_data^.mbp_buf, msglen, is_ok)
    ELSE
        a071_nextmessagetext (msgno, acv.a_mblock.mb_data^.mbp_buf, msglen, is_ok);
    (*ENDIF*) 
    IF  is_ok AND (msgno <= cak36_lday_max_msgno)
    THEN
        WITH acv.a_mblock.mb_data^ DO
            BEGIN
            curr_dict := ord (mbp_buf[ 1 ]) - ord ('0');
            index     := (ord (mbp_buf[ 3 ]) - ord ('0')) * 10
                  +ord (mbp_buf[ 4 ]) - ord ('0');
            IF  (index     >= 0) AND (index     <= 12) AND
                (curr_dict >= 1) AND (curr_dict <= 7)
            THEN
                s78lang_spell_init (g03dictionary.dict[ 1 ],
                      @mbp_buf[ 5 ], cgg04_msgtext_len,
                      curr_dict, index, is_ok)
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36init_spell_dict (VAR acv : tak_all_command_glob);
 
VAR
      is_ok        : boolean;
      msgno        : tsp00_Int2;
      done         : boolean;
      msglen       : tsp00_Int2;
 
BEGIN
(* switch to the first message number. *)
done := true;
s78dict_next_msgno (msgno, done);
WHILE NOT done DO
    BEGIN
    is_ok := true;
    a071_getmessagetext (msgno, acv.a_mblock.mb_data^.mbp_buf, msglen, is_ok);
    IF  is_ok
    THEN
        WITH acv.a_mblock.mb_data^ DO
            s78dict_insert_row (g03dictionary.dict[ 1 ],
                  @mbp_buf[ 1 ], msglen, is_ok);
        (*ENDWITH*) 
    (* switch to the next message number. *)
    (*ENDIF*) 
    s78dict_next_msgno (msgno, done);
    END;
(*ENDWHILE*) 
WITH g03dictionary.dict[ 1 ] DO
    BEGIN
    dict_upp_table := @g02codetables.tables[ cgg04_up_ascii ];
    dict_low_table := @g02codetables.tables[ cgg04_low_ascii ];
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36after_systable_load (VAR acv : tak_all_command_glob);
 
VAR
      is_ok       : boolean;
      dummy_tree  : tgg00_FileId;
      language    : tsp00_C3;
      language_no : tsp6_language;
 
BEGIN
(* PTS 1115043 U.J. ak36get_xparameters() obsolete *)
(* PTS 1115978 E.Z. *)
ak36_systable_state (acv, a01_i_sysparseid   , dummy_tree);
ak36_systable_state (acv, a01_i_sysmondata   , dummy_tree);
ak36_systable_state (acv, a01_i_sysmonitor   , dummy_tree);
ak36_systable_state (acv, a01_i_syscmd_analyze, dummy_tree);
ak36_systable_state (acv, a01_i_sysdata_analyze, dummy_tree);
(* PTS 1104393 E.Z. *)
ak36_systable_state (acv, a01_i_sysupdstatwanted, a28updstatwanted_tree);
(* PTS 1121957 *)
a28updstatwanted_tree.fileRoot_gg00             := NIL_PAGE_NO_GG00;
a28updstatwanted_tree.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
language := 'ENG';
s78language (g03dictionary, language, language_no, c_for_init, is_ok);
ak36fill_monthnames (acv);
ak36fill_daynames   (acv);
ak36init_spell_dict (acv);
ak36init_lang_spell (acv);
ak36default_nls     (acv);
a260sysdbproc_exist (acv);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36restart (VAR acv : tak_all_command_glob;
            VAR a30v         : tak_a30_utility_glob;
            forActivation    : boolean);
 
VAR
      auxBuffer : tgg00_SaveRestoreInputParam;
 
BEGIN
WITH acv, a_mblock, a30v DO
    BEGIN
    auxBuffer.sripUntilDate_gg00 := bsp_c8;
    auxBuffer.sripUntilTime_gg00 := bsp_c8;
    kb560InvalidateIOSeq( auxBuffer.sripUntilIOSequence_gg00);
    IF  a_ap_tree^[ a3ti ].n_lo_level <> 0
    THEN
        WITH a_ap_tree^[a_ap_tree^[ a3ti ].n_lo_level] DO
            IF  n_subproc = cak_i_until
            THEN
                BEGIN
                a3ti := n_sa_level;
                ak36until_param (acv, a30v, auxBuffer);
                END;
            (* PTS 1124793 E.Z. *)
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  forActivation
        THEN
            gg999Activate (a_transinf.tri_trans)
        ELSE
            gg999Restart (a_transinf.tri_trans,
                  auxBuffer.sripUntilDate_gg00,
                  auxBuffer.sripUntilTime_gg00,
                  auxBuffer.sripUntilIOSequence_gg00);
        (*ENDIF*) 
        IF  a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        ak36restart_second_part (acv, a30v, forActivation)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36PrepareCatalogForUserConnect (VAR acv : tak_all_command_glob);
 
VAR
      version : tsp00_Version;
 
BEGIN
(* PTS 1139689 UH 2005-01-11 can be called before redo log *)
ak36get_sysdba (acv, g01glob.sysuser_id, g01glob.sysuser_name, version);
a103RestartCatalog;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36restart_second_part (VAR acv : tak_all_command_glob;
            VAR a30v      : tak_a30_utility_glob;
            forActivation : boolean);
 
CONST
      retcode_incomplete = -9212;
 
VAR
      is_incomplete    : boolean;
      is_activated     : boolean;
      in_warm_session  : boolean;
      aux_return       : tsp00_Int2;
      aux_errorpos     : tsp00_Int4;
      pOldContext      : tsp00_Addr;
      version          : tsp00_Version;
 
      opmsg            : RECORD
            CASE boolean OF
                true :
                    (msg : tsp00_Opmsg);
                false :
                    (c30 : tsp00_C30);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH acv, a_mblock, a30v DO
    BEGIN
    a01diag_monitor_on    := false;
    a01diag_analyze_on    := false;
    g01diag_moni_parse_on := false;
    in_warm_session       := false;
    is_incomplete         := a_returncode = retcode_incomplete;
    IF  a_returncode = 0
    THEN
        k51new_session (a_transinf.tri_trans);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        is_activated := false;
        ak36connect (acv, in_warm_session);
        IF  a_returncode = 0
        THEN
            BEGIN
            (* PTS 1139689 UH 2005-01-11 removed CONTROL USER CHECK - TODO find another place for it *)
            ak36get_sysdba (acv, g01glob.sysuser_id, g01glob.sysuser_name, version);
            is_activated := g01glob.sysuser_name <> a01_il_b_identifier;
            IF  NOT forActivation AND NOT a10TableAccessAllowed
            THEN
                a36PrepareCatalogForUserConnect (acv);
            (* PTS 1105614 E.Z. *)
            (*ENDIF*) 
            a42_monitor_init (a_transinf.tri_trans.trTaskId_gg00);
            a34Restart (acv);
            IF  is_activated
            THEN
                (* PTS 1120287 E.Z. *)
                BEGIN
                a361migrate    (acv, version);
                ak36get_sysdba (acv, g01glob.sysuser_id, g01glob.sysuser_name, version);
                a36after_systable_load (acv);
                IF  acv.a_returncode = e_ok
                THEN
                    a24RecreateBadIndexes (acv, NOT g01auto_recreate_bad_indexes);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (a_returncode = 0)
        THEN
            IF  forActivation
            THEN
                (* PTS 1103645 E.Z. *)
                BEGIN
                ak36install (acv, a30v,
                      a_ap_tree^[ a_ap_tree^[ 0 ].n_lo_level ].n_lo_level <> 0);
                (* PTS 1115043 U.J. ak36get_xparameters() obsolete *)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (a_returncode = 0) AND g01SystemTriggersEnabled
        THEN
            BEGIN
            (* k50new_restart_transid (a_transinf.tri_trans); *)
            a260CallSystemTriggers (acv);
            IF  acv.a_returncode <> 0
            THEN
                acv.a_systemTriggerFailed := true;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (a_returncode <> 0) AND
            (a_returncode <> retcode_incomplete) AND
            NOT acv.a_systemTriggerFailed
        THEN
            BEGIN
            (* PTS 1111289 E.Z. *)
            gg999Offline (a_transinf.tri_trans.trError_gg00);
            in_warm_session := false  (* ++++ J.A. +++*)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  in_warm_session
    THEN
        BEGIN
        IF  NOT acv.a_systemTriggerFailed
        THEN
            BEGIN
            a51switch_user (acv, g01glob.sysuser_name, pOldContext);
            a101_StoreUpgradeInfo;
            aux_return   := acv.a_returncode;
            aux_errorpos := acv.a_errorpos;
            a52_ex_commit_rollback (acv, m_commit,
                  cak36_release, cak36_release);
            IF  aux_return <> 0
            THEN
                BEGIN
                acv.a_returncode := aux_return;
                acv.a_errorpos   := aux_errorpos;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        IF  (acv.a_returncode = 0)
        THEN
            ak36cold_release (acv);
        (*ENDIF*) 
    (*ENDIF*) 
    a11put_date_time (ak36restart_date, ak36restart_time);
    IF  acv.a_returncode = cak_e_released
    THEN
        ak36after_restart (acv);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1111229 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak36restart_standby (VAR acv : tak_all_command_glob);
 
VAR
      version          : tsp00_Version;
      aux_return       : tsp00_Int2;
      aux_errorpos     : tsp00_Int4;
 
BEGIN
(* trigger of pending restart *)
WITH acv, a_transinf.tri_trans DO
    BEGIN
    gg999RestartStandby(a_transinf.tri_trans);
    IF  trError_gg00 <> e_ok
    THEN
        gg999Offline (trError_gg00)
    ELSE
        BEGIN
        k51new_session (a_transinf.tri_trans);
        IF  trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, trError_gg00, 1);
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            kb560CreateLogTransaction (a_transinf.tri_trans);
            IF  trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, trError_gg00, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            ak36get_sysdba (acv, g01glob.sysuser_id,
                  g01glob.sysuser_name, version);
            a42_monitor_init (a_transinf.tri_trans.trTaskId_gg00);
            a34Restart (acv);
            aux_return   := acv.a_returncode;
            aux_errorpos := acv.a_errorpos;
            a52_ex_commit_rollback (acv, m_commit,
                  cak36_release, cak36_release);
            IF  aux_return <> 0
            THEN
                BEGIN
                acv.a_returncode := aux_return;
                acv.a_errorpos   := aux_errorpos;
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak36CheckSysCatTableName (VAR acv : tak_all_command_glob) : boolean;
 
VAR
      migrationNeeded : boolean;
      pos             : integer;
      ix              : integer;
      sysk            : tgg00_SysInfoKey;
      buf             : tsp00_Buf;
      pSysBuf         : tak_sysbufferaddress;
 
BEGIN
(* returns true, if 64 BIT migration is needed *)
migrationNeeded          := false;
sysk                     := a01defaultkey;
kb560GetSys1CatalogTabId (sysk.stableid);
pSysBuf                  := @buf;
a36get_catalog_record (acv.a_transinf.tri_trans, sysk, pSysBuf^);
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    pos := a10BaseRecPersistentOffset + 1;
    IF  buf[pos] <> chr(a061identifier_len (a01_i_syscat1))
    THEN
        migrationNeeded := true
    ELSE
        BEGIN
        pos := pos + 1;
        FOR ix := 1 TO (a061identifier_len (a01_i_syscat1) DIV a01char_size) DO
            BEGIN
            IF  NOT a01equal_char (buf, pos, a01_i_syscat1[ix * a01char_size])
            THEN
                migrationNeeded := true;
            (*ENDIF*) 
            pos := pos + a01char_size
            END;
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
ak36CheckSysCatTableName := migrationNeeded
END;
 
(* PTS 1117472 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak36restore_bad_log (VAR acv : tak_all_command_glob;
            VAR a30v : tak_a30_utility_glob);
 
VAR
      devname : tsp00_VFilename;
 
BEGIN
a30v.a3ti := acv.a_ap_tree^[a30v.a3ti].n_lo_level;
a36devname (acv, a30v.a3ti, devname, sizeof (devname));
IF  acv.a_returncode = 0
THEN
    BEGIN
    gg999ReIntegrateBadLogVolume(acv.a_transinf.tri_trans, devname);
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36restore_command (VAR acv : tak_all_command_glob;
            VAR a30v        : tak_a30_utility_glob;
            VAR util_cmd_id : tgg00_UtilCmdId);
 
VAR
      restore_log : boolean;
      multi_buf   : tgg00_QualBuf;
 
BEGIN
WITH acv, a_mblock, a30v DO
    BEGIN
    restore_log := false;
    a37init_util_record (acv, m_restore_parallel, mm_nil);
    CASE a_ap_tree^[ a30v.a3ti ].n_subproc OF
        cak_x_restore_db :
            a_mblock.mb_type2 := mm_database;
        cak_x_restore_config :
            a_mblock.mb_type2 := mm_config;
        cak_x_restore_pages :
            a_mblock.mb_type2 := mm_pages;
        cak_x_restore_log   :
            a_mblock.mb_type2 := mm_log;
        END;
    (*ENDCASE*) 
    a3ti := succ(a3ti);
    a_mblock.mb_struct := mbs_save_restore;
    multi_buf.msave_restore.sripWithCheckpoint_gg00 := false;
    a_mblock.mb_type := m_restore_parallel;
    restore_log := a_mblock.mb_type2 = mm_log;
    ak36multi_tape_restore (acv, a30v, multi_buf.msave_restore);
    IF  a_mblock.mb_type2 = mm_config
    THEN
        ak36to_db (acv, a30v,  multi_buf.msave_restore);
    (*ENDIF*) 
    ak36until_param (acv, a30v, multi_buf.msave_restore);
    multi_buf.msave_restore.sripBlocksize_gg00 := a37blocksize (acv, a30v);
    a37put_count_to_messbuf (acv, a30v);
    WITH a_ap_tree^[a3ti] DO
        IF  (n_proc = a36) AND (n_subproc = cak_i_config)
        THEN
            BEGIN
            a_mblock.mb_qual^.mut_config := true;
            a3ti := n_sa_level
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
    WITH multi_buf.msave_restore, a_mblock.mb_qual^ DO
        BEGIN
        sripUtilCmdId_gg00  := util_cmd_id; (* PTS 1104845 UH 02-12-1999 *)
        sripIsAutoLoad_gg00 := false;
        sripTapeLabel_gg00  := bsp_c14;     (* PTS 1128100 mb 1004-03-01 *)
        sripWithFormat_gg00 := false;       (* PTS 1139725 UH 2005-01-13 *)
        IF  a3ti <> 0
        THEN
            WITH a_ap_tree^[a3ti] DO
                IF  (n_proc = a37) AND
                    (n_subproc = cak_i_cascade)
                THEN
                    BEGIN
                    sripIsAutoLoad_gg00 := true;
                    a3ti := n_sa_level;
                    END;
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        a37media_name (acv, a3ti, multi_buf);
        a37label_name (acv, a3ti, multi_buf);  (* PTS 1128100 mb 1004-03-01 *)
        a_mblock.mb_qual^    := multi_buf;
        a_mblock.mb_qual_len := sizeof (multi_buf.msave_restore)
        END;
    (*ENDWITH*) 
    CASE a_mblock.mb_type2 OF
        mm_database, mm_pages:
            gg999RestoreData (a_mblock);
        mm_log:
            gg999RestoreLog (a_mblock);
        mm_config:
            k38restore_config (a_mblock);
        END;
    (*ENDCASE*) 
    IF  mb_trns^.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, mb_trns^.trError_gg00, 1)
    ELSE
        IF  restore_log AND NOT gg999IsCheckBackupConfigured
        THEN
            ak36restore_log_restart (acv, a30v);
        (*ENDIF*) 
    (*ENDIF*) 
    a37multi_tape_info (acv, cak_i_no_keyword)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36restore_log_restart (VAR acv : tak_all_command_glob;
            VAR a30v   : tak_a30_utility_glob);
 
VAR
      qual : tgg00_QualBuf;
 
BEGIN
qual := acv.a_mblock.mb_qual^;
ak36restart_second_part (acv, a30v, false);
acv.a_mblock.mb_qual^ := qual
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36send_mess_buf_cold (VAR acv : tak_all_command_glob);
 
VAR
      b_err : tgg00_BasisError;
 
BEGIN
a06_c_send_mess_buf (acv, b_err);
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36to_db (VAR acv : tak_all_command_glob;
            VAR a30v               : tak_a30_utility_glob;
            VAR save_restore_param : tgg00_SaveRestoreInputParam);
 
VAR
      help_c64 : tsp00_C64;
 
BEGIN
WITH acv, a30v DO
    BEGIN
    save_restore_param.sripConfigDbName_gg00 := bsp_dbname;
    IF  a3ti <> 0
    THEN
        IF  a_ap_tree^[ a3ti ].n_symb = s_string_literal
        THEN
            WITH a_ap_tree^[ a3ti ] DO
                BEGIN
                a05_string_literal_get (acv, a3ti, dcha,
                      sizeof(save_restore_param.sripConfigDbName_gg00),
                      help_c64);
                SAPDB_PascalForcedMove (sizeof(help_c64),
                      sizeof(save_restore_param.sripConfigDbName_gg00),
                      @help_c64, 1,
                      @save_restore_param.sripConfigDbName_gg00, 1,
                      sizeof(save_restore_param.sripConfigDbName_gg00));
                a3ti := n_sa_level
                END
            (*ENDWITH*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36until_param (VAR acv : tak_all_command_glob;
            VAR a30v         : tak_a30_utility_glob;
            VAR save_restore_param  : tgg00_SaveRestoreInputParam);
 
VAR
      e        : tgg00_BasisError;
      help_c64 : tsp00_C64;
      vallen   : tsp00_Int4;
 
BEGIN
WITH acv, a_mblock, a30v DO
    BEGIN
    save_restore_param.sripUntilDate_gg00 := bsp_date;
    save_restore_param.sripUntilTime_gg00 := bsp_time;
    kb560InvalidateIOSeq( save_restore_param.sripUntilIOSequence_gg00 );
    IF  a3ti <> 0
    THEN
        BEGIN
        IF  a_ap_tree^[ a3ti ].n_symb = s_unsigned_integer
        THEN
            BEGIN (* PTS 1121539 mb 2003-06-18 *)
            WITH a_ap_tree^[a3ti] DO
                BEGIN
                a05_int4_unsigned_get (acv, n_pos, n_length,
                      save_restore_param.sripUntilIOSequence_gg00 );
                a3ti := a_ap_tree^[a3ti].n_sa_level;
                END;
            (*ENDWITH*) 
            END
        ELSE
            IF  a_ap_tree^[ a3ti ].n_symb = s_string_literal
            THEN
                BEGIN
                (* PTS 1116405 E.Z. *)
                e := e_ok;
                a05_string_literal_get (acv, a3ti, dcha,
                      sizeof(save_restore_param.sripUntilDate_gg00),
                      help_c64);
                vallen := s30lnr (help_c64, csp_ascii_blank, 1,
                      sizeof(save_restore_param.sripUntilDate_gg00));
                g03fdcheck_date (help_c64,
                      save_restore_param.sripUntilDate_gg00,
                      1, 1, vallen,
                      dtf_normal, (* PTS 1000517 UH *)
                      e);
                a3ti := a_ap_tree^[ a3ti ].n_sa_level;
                IF  e = e_ok
                THEN
                    BEGIN
                    a05_string_literal_get (acv, a3ti, dcha,
                          sizeof(save_restore_param.sripUntilTime_gg00),
                          help_c64);
                    vallen := s30lnr (help_c64, csp_ascii_blank, 1,
                          sizeof(save_restore_param.sripUntilTime_gg00));
                    g03ftcheck_time (help_c64,
                          save_restore_param.sripUntilTime_gg00,
                          1, 1, vallen,
                          dtf_normal, (* PTS 1000517 UH *)
                          e);
                    a3ti := a_ap_tree^[ a3ti ].n_sa_level
                    END;
                (*ENDIF*) 
                IF  e <> e_ok
                THEN
                    a07_b_put_error (acv, e, 1)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36user_restore_reaction (VAR acv : tak_all_command_glob;
            VAR a30v      : tak_a30_utility_glob);
      (*
      ********************************
      hb 24.02.95 restore data replace
      with hostfilename
      ********************************
      *)
 
VAR
      m2type       : tgg00_MessType2;
      restore_kind : integer;
      reaction     : integer;
 
BEGIN
WITH acv, a_mblock, a30v DO
    BEGIN
    reaction     := a_ap_tree^[a3ti].n_length;
    restore_kind := a_ap_tree^[a3ti].n_subproc;
    CASE reaction OF
        cak_i_ignore :
            m2type := mm_ignore;
        cak_i_cancel :
            m2type := mm_abort;
        cak_i_replace :
            m2type := mm_newtape;
        END;
    (*ENDCASE*) 
    ak36mess_buf_init (acv, m_restore_parallel, m2type);
    IF  reaction = cak_i_replace
    THEN
        BEGIN
        a3ti := a_ap_tree^[a3ti].n_sa_level;
        mb_qual^.msave_restore.sripIsAutoLoad_gg00 := false;
        IF  a_ap_tree^[a3ti].n_symb = s_hostfilename
        THEN
            BEGIN
            mb_struct := mbs_save_restore;
            mb_qual^.msave_restore.sripWithCheckpoint_gg00 := false;
            a36filename (acv, a3ti,
                  mb_qual^.msave_restore.sripHostTapenames_gg00[1],
                  VFILENAME_MXSP00);
            a_mblock.mb_qual_len := sizeof(mb_qual^.msave_restore);
            a3ti := a_ap_tree^[a3ti].n_sa_level;
            IF  a36filetype (acv, a3ti,
                mb_qual^.msave_restore.sripHostFiletypes_gg00[1])
            THEN
                a3ti := a_ap_tree^[a3ti].n_sa_level
            (*ENDIF*) 
            END
        ELSE
            mb_qual^.msave_restore.sripHostTapenames_gg00[1] :=
                  b01blankfilename;
        (*ENDIF*) 
        IF  a3ti <> 0
        THEN
            WITH a_ap_tree^[a3ti] DO
                IF  (n_proc = a37) AND (n_subproc = cak_i_cascade)
                THEN
                    mb_qual^.msave_restore.sripIsAutoLoad_gg00 := true
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    gg999BackupRestoreHandling(a_mblock);
    IF  a_mblock.mb_trns^.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, a_mblock.mb_trns^.trError_gg00, 1)
    ELSE
        IF  (restore_kind = cak_x_restore_log) AND
            (reaction <> cak_i_cancel        )
        THEN
            ak36restore_log_restart (acv, a30v);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  reaction <> cak_i_cancel
    THEN
        a37multi_tape_info (acv, cak_i_no_keyword)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36_call_semantic (VAR acv : tak_all_command_glob;
            VAR util_cmd_id : tgg00_UtilCmdId);
 
VAR
      a30v : tak_a30_utility_glob;
 
BEGIN
WITH acv, a_mblock, a30v  DO
    BEGIN
    a3ti            := 1;
    (* PTS 1113190 E.Z. *)
    CASE a_ap_tree^[ a3ti ].n_subproc OF
        cak_x_activate :
            ak36activate (acv, a30v);
        cak_x_connect :
            ak36cold_connect (acv, a30v);
        cak_x_util_commit :
            BEGIN
            END;
        cak_x_commit_release :
            ak36cold_release (acv);
        cak_x_clear_log:
            BEGIN
            gg999ClearLog (acv.a_transinf.tri_trans.trTaskId_gg00);
            IF  a_transinf.tri_trans.trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1);
            (*ENDIF*) 
            END;
        cak_x_create_snapshot,
        cak_x_drop_snapshot,
        cak_x_restore_snapshot :
            ak36snapshot (acv, a_ap_tree^[ a3ti ].n_subproc);
        (* PTS 1117472 E.Z. *)
        cak_x_get_bad_log_volume :
            ak36get_bad_log_volume (acv, a30v);
        cak_x_get_config :
            ak36get_config_device  (acv, a30v, mm_config);
        cak_x_get_dev_config :
            ak36get_config_device  (acv, a30v, mm_device);
        cak_x_get_restart_version :
            ak36get_restart_version (acv);
        cak_x_init_config :
            (* PTS 1120611 E.Z. *)
            ak36init_config (acv, a30v, util_cmd_id);
        (* PTS 1111229 E.Z. *)
        cak_x_init_standby :
            ak36init_standby (acv);
        cak_x_insert_standby :
            ak36insert_standby (acv);
        (* PTS 1113190 E.Z. *)
        cak_x_log_devspace_on :
            gg999SetLogWriting (acv.a_transinf.tri_trans.trTaskId_gg00, c_on);
        cak_x_log_devspace_off :
            gg999SetLogWriting (acv.a_transinf.tri_trans.trTaskId_gg00, NOT c_on);
        (* PTS 1117050 E.Z. *)
        cak_x_migrate_database :
            BEGIN
            bd01MigrateDataBase( acv.a_transinf.tri_trans.trTaskId_gg00,
                  acv.a_transinf.tri_trans.trError_gg00 );
            IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
            (*ENDIF*) 
            END;
        cak_x_migrate_to_unicode :
            (* PTS 1117498 M.Ki. *)
            ak36migrate_to_unicode (acv);
        (* PTS 1124973 E.Z. *)
        cak_x_migrate_volumes :
            BEGIN
            gg999MigrateVolumes(acv.a_transinf.tri_trans);
            IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
            (*ENDIF*) 
            END;
        cak_x_remove_standby :
            ak36remove_standby (acv);
        cak_x_restart :
            ak36restart (acv, a30v, false);
        (* PTS 1111229 E.Z. *)
        cak_x_restart_standby :
            ak36restart_standby (acv);
        (* PTS 1117472 E.Z. *)
        cak_x_restore_bad_log :
            ak36restore_bad_log (acv, a30v);
        cak_x_restore_db, cak_x_restore_config, cak_x_restore_pages,
        cak_x_restore_log, cak_x_rest_log_from :
            IF  a_ap_tree^[a3ti].n_length <> cak_i_no_keyword
            THEN
                ak36user_restore_reaction (acv, a30v)
            ELSE
                ak36restore_command (acv, a30v, util_cmd_id);
            (*ENDIF*) 
        cak_x_synchronize_log :
            ak36synchronize_log (acv);
        cak_x_takeover :
            ak36takeover (acv, a30v);
        cak_x_verify :
            ak36verify (acv, a30v);
        cak_x_vtrace_on, cak_x_vtrace_off :
            a37vtrace (acv);
        cak_x_diagnose :
            ak36diagnose_command (acv, a30v);
        cak_x_diag_dump :
            a37_call_semantic (acv, util_cmd_id);
        OTHERWISE
            a07_b_put_error (acv, e_invalid_command, 1);
        END;
    (*ENDCASE*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1120611 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a36utilprot_needed (VAR acv : tak_all_command_glob;
            VAR prot_needed   : boolean;
            VAR with_tapeinfo : boolean);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
curr_n := acv.a_ap_tree^[ 0 ].n_lo_level;
prot_needed := acv.a_ap_tree^[curr_n].n_subproc in [
      cak_x_activate,
      cak_x_clear_log,
      cak_x_init_config,
      cak_x_restart,
      cak_x_restore_db,
      cak_x_restore_config,
      cak_x_restore_pages,
      cak_x_restore_log,
      (* PTS 1117472 E.Z. *)
      cak_x_restore_bad_log,
      cak_x_rest_log_from,
      cak_x_verify,
      (* PTS 1113190 E.Z. *)
      cak_x_log_devspace_on,
      cak_x_log_devspace_off,
      (* PTS 1111229 E.Z. *)
      cak_x_init_standby,
      cak_x_restart_standby,
      cak_x_takeover,
      cak_x_migrate_to_unicode,
      cak_x_migrate_database, (* PTS 1122494 E.Z. *)
      cak_x_migrate_volumes,
      cak_x_create_snapshot,
      cak_x_drop_snapshot,
      cak_x_restore_snapshot
      ];
IF  (acv.a_ap_tree^[curr_n].n_subproc = cak_x_init_config) AND
    (acv.a_ap_tree^[curr_n].n_sa_level > 0)
THEN
    curr_n := acv.a_ap_tree^[curr_n].n_sa_level;
(*ENDIF*) 
with_tapeinfo := acv.a_ap_tree^[curr_n].n_subproc in [
      cak_x_restart,
      cak_x_restore_db,
      cak_x_restore_config,
      cak_x_restore_pages,
      cak_x_restore_log
      ]
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36_systable_state (VAR acv : tak_all_command_glob;
            tablename : tsp00_KnlIdentifier;     (* called with constants *)
            VAR tree  : tgg00_FileId);
 
VAR
      isExtendedTempFile : boolean;
      tempFileType       : tgg00_TfnTemp;
      syskey             : tgg00_SysInfoKey;
      buf                : tak_systembuffer;
 
BEGIN
tree := b01niltree_id;
IF  acv.a_returncode = 0
THEN
    BEGIN
    WITH syskey DO
        BEGIN
        sauthid       := g01glob.sysuser_id;
        sidentifier   := tablename;
        sentrytyp     := cak_etableref;
        slinkage      := cak_init_linkage
        END;
    (*ENDWITH*) 
    syskey.skeylen := mxak_standard_sysk + sizeof (syskey.sidentifier);
    a36get_catalog_record (acv.a_transinf.tri_trans, syskey, buf);
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        BEGIN
        syskey          := a01defaultkey;
        syskey.stableid := buf.stableref.rtableid;
        a36get_catalog_record (acv.a_transinf.tri_trans, syskey, buf)
        END;
    (*ENDIF*) 
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
    THEN
        BEGIN
        tree := buf.sbase.btreeid;
        (* PTS 1104393 E.Z. *)
        IF  (tablename = a01_i_sysmonitor      ) OR
            (tablename = a01_i_sysmondata      ) OR
            (tablename = a01_i_sysparseid      ) OR
            (tablename = a01_i_syscmd_analyze  ) OR
            (tablename = a01_i_sysdata_analyze )
            (* a01_i_sysupdstatwanted might still be registered as a temp *)
            (* file in catalog until system tables are reloaded           *)
            OR ( (tablename = a01_i_sysupdstatwanted)
            AND   a101_IsTempFile (acv, tree) )
        THEN
            BEGIN
            isExtendedTempFile := a101_IsExtendedTempFile (acv, tree);
            tempFileType       := ttfnNone_egg00;
            IF  isExtendedTempFile
            THEN
                tempFileType := a101_GetExtendedTempFileType (acv, tree);
            (*ENDIF*) 
            bd998CreateNamedTempFile (acv.a_transinf.tri_trans,
                  tree.fileTabId_gg00, tree, isExtendedTempFile, tempFileType);
            IF  acv.a_transinf.tri_trans.trError_gg00 =  e_duplicate_filename
            THEN
                b01filestate (acv.a_transinf.tri_trans, tree)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            b01filestate (acv.a_transinf.tri_trans, tree);
            tree.fileLeafNodes_gg00 := cgg_nil_leafnodes;
            IF  acv.a_transinf.tri_trans.trError_gg00 = e_file_read_only
            THEN
                acv.a_transinf.tri_trans.trError_gg00 := e_ok
                      (* PTS 1115978 E.Z. *)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (acv.a_transinf.tri_trans.trError_gg00 <> e_ok) AND
        (acv.a_transinf.tri_trans.trError_gg00 <> e_key_not_found)
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36get_catalog_record (VAR t : tgg00_TransContext;
            VAR sysk   : tgg00_SysInfoKey;
            VAR sysbuf : tak_systembuffer);
 
VAR
      tree        : tgg00_FileId;
      skey        : tgg00_Lkey;
      buf         : tgg00_Rec;
 
BEGIN
IF  sysk.sentrytyp[2] = cak_cuserref
THEN
    SAPDB_PascalForcedMove (sizeof (a01_il_b_identifier), sizeof (sysk.sidentifier),
          @a01_il_b_identifier, 1, @sysk.sidentifier,
          sizeof (tsp00_KnlIdentifier) - SURROGATE_MXGG00 + 1,
          SURROGATE_MXGG00);
(*ENDIF*) 
IF  sysk.sentrytyp[2] in
    [cak_ctableref, cak_cdomainref,
    cak_cconstraintname, cak_cmapset, cak_cuserref]
THEN
    sysk.skeylen := mxak_standard_sysk +
          a061identifier_len (sysk.sidentifier);
(*ENDIF*) 
t.trError_gg00 := e_ok;
SAPDB_PascalMove ('VAK36 ',   2,    
      sizeof (sysk), sizeof (skey.k),
      @sysk, cgg_rec_key_offset+1, @skey.k, 1, sysk.skeylen, t.trError_gg00);
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    skey.len := s30klen (skey.k, chr(0), sysk.skeylen);
    IF  sysk.sentrytyp < cak_esysfile2
    THEN
        kb560GetSys1CatalogTreeId (tree)
    ELSE
        kb560GetSys2CatalogTreeId (tree);
    (*ENDIF*) 
    b02get_record (t, tree, skey, buf);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        a10expand_rec (buf, t.trError_gg00);
        SAPDB_PascalMove  ('VAK36 ',   3,    
              sizeof (buf), sizeof (sysbuf),
              @buf, 1, @sysbuf, 1, buf.len, t.trError_gg00)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36hex_surrogate (VAR acv : tak_all_command_glob;
            VAR surrogate : tgg00_Surrogate);
 
VAR
      ret_text : tsp00_C40;
 
BEGIN
WITH acv DO
    BEGIN
    ret_text[  1 ] := 'S';
    ret_text[  2 ] := 'U';
    ret_text[  3 ] := 'R';
    ret_text[  4 ] := 'R';
    ret_text[  5 ] := 'O';
    ret_text[  6 ] := 'G';
    ret_text[  7 ] := 'A';
    ret_text[  8 ] := 'T';
    ret_text[  9 ] := 'E';
    ret_text[ 10 ] := ' ';
    ret_text[ 11 ] := ':';
    ret_text[ 12 ] := ' ';
    g02hex (surrogate, 1, ret_text, 13, SURROGATE_MXGG00);
    a06char_retpart_move (acv, @ret_text,
          12 + SURROGATE_MXGG00 + SURROGATE_MXGG00);
    a06finish_curr_retpart (acv, sp1pk_data, 1)
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36restart_time (VAR date : tsp00_Int4;
            VAR time : tsp00_Int4);
 
BEGIN
date := ak36restart_date;
time := ak36restart_time
END;
 
(*------------------------------*) 
 
FUNCTION
      a36tree_in_memory (VAR tree_id : tgg00_FileId) : boolean;
 
BEGIN
a36tree_in_memory :=
      (a28TreeStoredInVar (tree_id)                              )
      (* PTS 1115978 E.Z. *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36devname (VAR acv : tak_all_command_glob;
            tree_index  : integer;
            VAR dname   : tsp00_VFilename;
            dlen        : integer);
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    a05string_literal_get (acv, tree_index, dcha, dname, 1, dlen);
    IF  acv.a_returncode <> 0
    THEN
        BEGIN
        acv.a_returncode := 0;
        a07_b_put_error (acv, e_devname_invalid, acv.a_errorpos)
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a36filename (VAR acv     : tak_all_command_glob;
            tree_index  : integer;
            VAR fname   : tsp00_VFilename;
            fnlen       : integer);
 
BEGIN
a05string_literal_get (acv, tree_index, dcha, fname, 1, fnlen);
END;
 
(*------------------------------*) 
 
FUNCTION
      a36filetype (VAR acv : tak_all_command_glob;
            tree_index   : tsp00_Int2;
            VAR filetype : tsp00_VfType) : boolean;
 
VAR
      curr_node : ^tak_ap_node;
      result    : boolean;
 
BEGIN
filetype := vf_t_unknown;
result   := true;
IF  tree_index <> 0
THEN
    BEGIN
    curr_node := @acv.a_ap_tree^[ tree_index ];
    IF  curr_node^.n_proc = a37
    THEN
        CASE curr_node^.n_subproc OF
            cak_i_file:
                filetype := vf_t_file;
            cak_i_norewind:
                filetype := vf_t_tape_norew;
            cak_i_pipe:
                filetype := vf_t_pipe;
            cak_i_raw:
                filetype := vf_t_raw;
            cak_i_tape :
                filetype := vf_t_tape_rew;
            cak_i_unknown:
                filetype := vf_t_unknown;
            cak_i_dafs:
                filetype := vf_t_dafs_file;
            OTHERWISE
                result := false;
            END
        (*ENDCASE*) 
    ELSE
        result := false
    (*ENDIF*) 
    END
ELSE
    result := false;
(*ENDIF*) 
a36filetype := result
END;
 
(* PTS 1111229 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a36_standby_semantic (
            VAR acv         : tak_all_command_glob);
 
VAR
      special_session : boolean;
      aux_return      : tsp00_Int2;
      aux_errorpos    : tsp00_Int4;
      a30v            : tak_a30_utility_glob;
 
BEGIN
WITH acv DO
    BEGIN
    special_session := false;
    IF  a_curr_user_name = a01_il_b_identifier
    THEN
        BEGIN
        special_session     := true;
        (* PTS 1113190 E.Z. *)
        a_size_ptr          := NIL;
        a_curr_user_name    := a01controluser;
        a_current_user_kind := usysdba;
        ak36cold_session_init (acv);
        END;
    (*ENDIF*) 
    CASE a_ap_tree^[ a_ap_tree^[0].n_lo_level ].n_subproc OF
        cak_x_remove_standby :
            ak36remove_standby (acv);
        cak_x_insert_standby :
            ak36insert_standby (acv);
        cak_x_synchronize_log :
            ak36synchronize_log (acv);
        cak_x_takeover :
            ak36takeover (acv, a30v);
        OTHERWISE
            a07_b_put_error (acv, e_invalid_command, 1);
        END;
    (*ENDCASE*) 
    IF  special_session
    THEN
        BEGIN
        aux_return   := acv.a_returncode;
        aux_errorpos := acv.a_errorpos;
        ak36cold_release (acv);
        acv.a_returncode := aux_return;
        acv.a_errorpos   := aux_errorpos;
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36remove_standby (
            VAR acv         : tak_all_command_glob);
 
VAR
      rem_standby : tsp00_NodeId;
 
BEGIN
WITH acv, a_transinf.tri_trans DO
    IF  a_returncode  = 0
    THEN
        BEGIN
        a05_string_literal_get (acv,
              a_ap_tree^[a_ap_tree^[0].n_lo_level].n_sa_level, dcha,
              sizeof(rem_standby), rem_standby);
        IF  a_returncode = 0
        THEN
            BEGIN
            gg999RemoveStandby(a_transinf.tri_trans, rem_standby);
            IF  trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, trError_gg00, 1);
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36insert_standby (
            VAR acv : tak_all_command_glob);
 
VAR
      new_standby : tsp00_NodeId;
 
BEGIN
WITH acv, a_transinf.tri_trans DO
    IF  a_returncode  = 0
    THEN
        BEGIN
        a05_string_literal_get (acv,
              a_ap_tree^[a_ap_tree^[0].n_lo_level].n_sa_level, dcha,
              sizeof(new_standby), new_standby);
        IF  a_returncode = 0
        THEN
            BEGIN
            gg999InsertStandby(a_transinf.tri_trans, new_standby);
            IF  trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, trError_gg00, 1);
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36synchronize_log (
            VAR acv         : tak_all_command_glob);
 
VAR
 
      logpos : RECORD
            CASE boolean OF
                true :
                    (c4 : tsp00_C4);
                false :
                    (i4 : tsp00_Int4);
                END;
            (*ENDCASE*) 
 
      i           : integer;
      curr_n      : tsp00_Int2;
      shortinfo   : tak_shortinforecord;
      pos         : tsp00_Int4;
      name        : tsp00_C18;
      c           : tsp00_C1;
      asciihexbyte: tsp00_C2;
 
BEGIN
WITH acv DO
    BEGIN
    curr_n := a_ap_tree^[a_ap_tree^[0].n_lo_level].n_sa_level;
    WITH a_ap_tree^[curr_n] DO
        BEGIN
        (* n_symb = s_byte_string *)
        IF  n_length <> 8 * a01char_size
        THEN
            a07_b_put_error (acv, e_missing_string_literal, n_pos)
        ELSE
            BEGIN
            IF  g01unicode
            THEN
                FOR i := 1 TO sizeof(logpos.c4) DO
                    IF  acv.a_cmd_part^.sp1p_buf[ n_pos + (i - 1) * 2 * a01char_size ] <> csp_unicode_mark
                    THEN
                        a07_b_put_error (acv, e_missing_string_literal, n_pos);
                    (*ENDIF*) 
                (*ENDFOR*) 
            (*ENDIF*) 
            FOR i := 1 TO 4 DO
                logpos.c4[i] := a37hex2char(acv, n_pos + (i - 1) * 2 * a01char_size);
            (*ENDFOR*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  a_returncode  = 0
    THEN
        BEGIN
        logpos.i4 := gg999Synchronize (a_transinf.tri_trans, logpos.i4);
        IF  a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            pos := 1;
            (* PTS 1113268 E.Z. *)
            name := 'LOGPOS            ';
            a06colname_retpart_move (acv, @name, 6, csp_ascii);
            WITH shortinfo.siinfo[1] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dcha;
                sp1i_frac       := 0;
                sp1i_length     := 8;
                sp1i_in_out_len := succ(sp1i_length);
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            a06finish_curr_retpart (acv, sp1pk_columnnames, 1);
            shortinfo.sicount := 1;
            a06retpart_move (acv, @shortinfo.siinfo,
                  shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
            a06finish_curr_retpart (acv, sp1pk_shortinfo, shortinfo.sicount);
            c[1] := csp_defined_byte;
            a06retpart_move (acv, @c[1], 1);
            FOR i := 1 TO sizeof(logpos.c4) DO
                BEGIN
                a37char2hex(logpos.c4[i], asciihexbyte);
                a06char_retpart_move (acv, @asciihexbyte[1], 2);
                END;
            (*ENDFOR*) 
            a06finish_curr_retpart (acv, sp1pk_data, 1)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36takeover (
            VAR acv   : tak_all_command_glob;
            VAR a30v  : tak_a30_utility_glob);
 
BEGIN
WITH acv, a_transinf.tri_trans DO
    BEGIN
    (* release old standby-session,                            *)
    (* start a 'cold one' anew (restart_second_part expects it *)
    a52_ex_commit_rollback (acv, m_commit, cak36_release, cak36_release);
    IF  a_returncode = cak_e_released
    THEN
        BEGIN
        a_returncode := 0;
        a_size_ptr := NIL;
        a_curr_user_name := a01controluser;
        a_current_user_kind := usysdba;
        ak36cold_session_init (acv);
        trError_gg00 := e_ok;
        gg999TakeOver (a_transinf.tri_trans);
        IF  trError_gg00 <> e_ok
        THEN
            BEGIN
            a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1);
            gg999Offline (trError_gg00);
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            ak36restart_second_part (acv, a30v, NOT c_forActivation)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36verify (
            VAR acv   : tak_all_command_glob;
            VAR a30v  : tak_a30_utility_glob);
 
VAR
      shortinfo   : tak_shortinforecord;
      pos         : tsp00_Int4;
      name        : tsp00_C18;
      c           : tsp00_C1;
 
BEGIN
WITH acv, a_transinf.tri_trans DO
    BEGIN
    ak36mess_buf_init (acv, m_verify, mm_nil);
    (* PTS 1125096 E.Z. *)
    a30v.a3ti := a_ap_tree^[a30v.a3ti].n_sa_level;
    IF  a30v.a3ti <> 0
    THEN
        IF  (a_ap_tree^[a30v.a3ti].n_proc = a30) AND
            (a_ap_tree^[a30v.a3ti].n_subproc = cak_x_extended_check)
        THEN
            BEGIN
            a_mblock.mb_qual^.mv_extended := true;
            a30v.a3ti := a_ap_tree^[a30v.a3ti].n_sa_level (* PTS 1133300 EZ 2005-01-11 *)
            END
        ELSE
            a_mblock.mb_qual^.mv_extended := false;
        (*ENDIF*) 
    (* PTS 1133300 EZ 2005-01-11 *)
    (*ENDIF*) 
    IF  a30v.a3ti <> 0
    THEN
        IF  (a_ap_tree^[a30v.a3ti].n_proc = a30) AND
            (a_ap_tree^[a30v.a3ti].n_subproc = cak_x_delete_block)
        THEN
            BEGIN
            a_mblock.mb_qual^.mv_delete_longfile := true;
            a30v.a3ti := a_ap_tree^[a30v.a3ti].n_sa_level
            END
        ELSE
            a_mblock.mb_qual^.mv_delete_longfile := false;
        (*ENDIF*) 
    (*ENDIF*) 
    ak36send_mess_buf_cold (acv);
    IF  a_mblock.mb_qual_len  > 0
    THEN
        IF  (a_returncode <> 0)
        THEN
            BEGIN
            a06char_retpart_move (acv, @a_mblock.mb_qual^.buf, a_mblock.mb_qual_len );
            a06finish_curr_retpart (acv, sp1pk_errortext, 1);
            END
        ELSE
            BEGIN
            pos := 1;
            name := 'PAGES_USED        ';
            a06colname_retpart_move (acv, @name, 10, csp_ascii);
            WITH shortinfo.siinfo[1] DO
                BEGIN
                sp1i_mode       := [ sp1ot_mandatory ];
                sp1i_io_type    := sp1io_output;
                sp1i_data_type  := dcha;
                sp1i_frac       := 0;
                sp1i_length     := 10;
                sp1i_in_out_len := succ(sp1i_length);
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            name := 'BLOCKS_RELEASED   ';
            a06colname_retpart_move (acv, @name, 15, csp_ascii);
            a06finish_curr_retpart (acv, sp1pk_columnnames, 2);
            shortinfo.siinfo[2] := shortinfo.siinfo[1];
            WITH shortinfo.siinfo[2] DO
                BEGIN
                sp1i_bufpos     := pos;
                pos             := pos + sp1i_in_out_len
                END;
            (*ENDWITH*) 
            shortinfo.sicount := 2;
            a06retpart_move (acv, @shortinfo.siinfo,
                  shortinfo.sicount * sizeof (shortinfo.siinfo[1]));
            a06finish_curr_retpart (acv, sp1pk_shortinfo, shortinfo.sicount);
            c[1] := csp_ascii_blank;
            a06retpart_move (acv, @c[1], 1);
            a06retpart_move (acv, @a_mblock.mb_qual^.buf, 10);
            a06retpart_move (acv, @c[1], 1);
            a06retpart_move (acv, @a_mblock.mb_qual^.buf[11], 10);
            a06finish_curr_retpart (acv, sp1pk_data, 1)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    a37resultevent (sp31ei_checkdata, acv.a_returncode);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36migrate_to_unicode (
            VAR acv   : tak_all_command_glob);
 
CONST
      retcode_incomplete = -9212;
 
VAR
      is_incomplete   : boolean;
      is_activated    : boolean;
      in_warm_session : boolean;
      aux_return      : tsp00_Int2;
      aux_errorpos    : tsp00_Int4;
      b_err           : tgg00_BasisError;
      locbuf          : tak_sysbufferaddress;
      version         : tsp00_Version;
      sysk            : tgg00_SysInfoKey;
      nil_date        : tsp00_Date;
      nil_time        : tsp00_Time;
      nil_iosequence  : tsp00_Uint4;
 
BEGIN
(* PTS 1117498 M.Ki. *)
WITH acv, a_mblock, a_transinf.tri_trans DO
    BEGIN
    nil_date := bsp_c8;
    nil_time := bsp_c8;
    kb560InvalidateIOSeq( nil_iosequence );
    trError_gg00 := gg999DenyBackupAndRestore;
    IF  trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, trError_gg00, 1)
    ELSE
        BEGIN
        gg999Restart (a_transinf.tri_trans, nil_date, nil_time, nil_iosequence);
        IF  trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, trError_gg00, 1);
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            a01diag_monitor_on    := false;
            a01diag_analyze_on    := false;
            g01diag_moni_parse_on := false;
            in_warm_session       := false;
            is_incomplete         := false;
            k51new_session (a_transinf.tri_trans);
            IF  trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, trError_gg00, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            kb560CreateLogTransaction (a_transinf.tri_trans);
            IF  trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, trError_gg00, 1);
            (*ENDIF*) 
            is_activated := false;
            IF  a_returncode = 0
            THEN
                BEGIN
                (* check if control user collides with any other user *)
                a51build_userkey (a01controluser, sysk);
                a10get_sysinfo (acv, sysk, d_release,
                      locbuf, b_err);
                IF  b_err = e_ok
                THEN
                    g01abort (csp3_a36_control_exists, csp3_n_restart,
                          'CONTROL USER ALR. EXISTS', 0);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  a_returncode = 0
            THEN
                BEGIN
                ak36get_sysdba (acv, g01glob.sysuser_id,
                      g01glob.sysuser_name, version);
                is_activated := g01glob.sysuser_name <> a01_il_b_identifier;
                (* PTS 1105614 E.Z. *)
                a42_monitor_init (a_transinf.tri_trans.trTaskId_gg00);
                a34Restart (acv);
                IF  (a_returncode <> 0) AND
                    (a_returncode <> retcode_incomplete)
                THEN
                    BEGIN
                    (* PTS 1111289 E.Z. *)
                    gg999Offline (a_transinf.tri_trans.trError_gg00);
                    in_warm_session := false  (* ++++ J.A. +++*)
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  is_activated
            THEN
                BEGIN
                IF  ak36IsCurrentKnlVersion(version)
                THEN
                    a362migrate (acv, in_warm_session)
                ELSE
                    BEGIN
                    g01optextmsg (sp3p_knldiag, sp3m_error,
                          csp3_a362_migrate_ascii_to_uni,
                          csp3_n_migration,
                          'RESTART REQUIRED BEFORE MIGRATION       ');
                    acv.a_returncode := e_migration_error;
                    END;
                (*ENDIF*) 
                IF  (acv.a_returncode <> e_ok)
                THEN (* if the migration failed we have to shutdown  *)
                    (* since the database was restarted as a unicode *)
                    (* instance that now would be operating on an    *)
                    (* ASCII catalog                                 *)
                    gg999Offline (e_ok);
                (*ENDIF*) 
                ak36get_sysdba (acv, g01glob.sysuser_id,
                      g01glob.sysuser_name, version);
                a36after_systable_load (acv);
                END;
            (*ENDIF*) 
            IF  in_warm_session
            THEN
                BEGIN
                aux_return   := acv.a_returncode;
                aux_errorpos := acv.a_errorpos;
                a52_ex_commit_rollback (acv, m_commit,
                      cak36_release, cak36_release);
                IF  aux_return <> 0
                THEN
                    BEGIN
                    acv.a_returncode := aux_return;
                    acv.a_errorpos   := aux_errorpos;
                    END;
                (*ENDIF*) 
                END
            ELSE
                IF  (acv.a_returncode = 0)
                THEN
                    ak36cold_release (acv);
                (*ENDIF*) 
            (*ENDIF*) 
            a11put_date_time (ak36restart_date, ak36restart_time);
            IF  acv.a_returncode = cak_e_released
            THEN
                ak36after_restart (acv);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        gg999PermitBackupAndRestore;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36after_restart (VAR acv : tak_all_command_glob);
 
VAR
      hostn : tsp00_DevName;
 
BEGIN
bd999EnableConsistentRead (acv.a_transinf.tri_trans.trTaskId_gg00);
vrestart (acv.a_transinf.tri_trans.trTaskId_gg00, hostn);
a37insert_event (sp31ei_online);
acv.a_use_timeout := true;
gg999SetKernelStateOnline;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak36snapshot (VAR acv : tak_all_command_glob;
            command_id : tsp00_Int2);
 
BEGIN
CASE command_id OF
    cak_x_create_snapshot :
        BEGIN
        gg999CreateSnapShot (acv.a_transinf.tri_trans);
        END;
    cak_x_drop_snapshot :
        BEGIN
        gg999DropSnapShot (acv.a_transinf.tri_trans);
        END;
    (* PTS 1123439 E.Z. *)
    cak_x_restore_snapshot :
        BEGIN
        gg999ActivateSnapShot (acv.a_transinf.tri_trans);
        END;
    END;
(*ENDCASE*) 
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
