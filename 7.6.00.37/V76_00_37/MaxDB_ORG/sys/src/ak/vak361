.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-11-17
*****************************************************
modname : VAK361
changed : 2000-11-17
module  : Catalog_Migration
 
Author  : ThomasA
Created : 1985-02-06
*****************************************************
 
Purpose : Catalog migrations due to catalog changes
 
Define  :
 
        PROCEDURE
              a361migrate (
                    VAR acv             : tak_all_command_glob;
                    VAR prevKnlVersion  : tsp00_Version);
 
        PROCEDURE
              a361CreateProtTable (
                    VAR acv        : tak_all_command_glob;
                    VAR prot_tree  : tgg00_FileId;
                    createUnicode  : boolean;
                    isUnicodeMig   : boolean);
 
        PROCEDURE
              a361WriteProt (
                    VAR acv           : tak_all_command_glob;
                    VAR prot_tree     : tgg00_FileId;
                    VAR migrationId   : tsp00_C64;
                    migIdLength       : integer;
                    VAR schema        : tsp00_C64;
                    schemaLength      : integer;
                    VAR owner         : tsp00_C64;
                    ownerLength       : integer;
                    unicodeText       : boolean;
                    errCode           : integer;
                    errPos            : integer);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey            : tgg00_SysInfoKey;
              a01controluser           : tsp00_KnlIdentifier;
              a01_il_b_identifier      : tsp00_KnlIdentifier;
              a01_i_catalog            : tsp00_KnlIdentifier;
              a01_i_oms_schema         : tsp00_KnlIdentifier;
              a01_i_sysmonitor         : tsp00_KnlIdentifier;
              a01_i_sysmondata         : tsp00_KnlIdentifier;
              a01_i_syscmd_analyze     : tsp00_KnlIdentifier;
              a01_i_sysdata_analyze    : tsp00_KnlIdentifier;
              a01_i_sysparseid         : tsp00_KnlIdentifier;
              a01_i_sysupdstatwanted   : tsp00_KnlIdentifier;
 
        PROCEDURE
              a01sets_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tak_oldidentifier);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : vak05;
 
        PROCEDURE
              a05_stamp_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tgg00_Surrogate;
                    destpos    : integer;
                    mv_dest    : integer);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06a_mblock_init (
                    VAR acv   : tak_all_command_glob;
                    mtype     : tgg00_MessType;
                    m2type    : tgg00_MessType2;
                    VAR tree  : tgg00_FileId);
 
        PROCEDURE
              a06determine_username (
                    VAR acv       : tak_all_command_glob;
                    VAR userid    : tgg00_Surrogate;
                    VAR user_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a06extcolno (
                    VAR baserec     : tak_baserecord;
                    extcolno        : integer;
                    VAR colinfo_ptr : tak00_colinfo_ptr);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06lsend_mess_buf (
                    VAR acv         : tak_all_command_glob;
                    VAR mbuf        : tgg00_MessBlock;
                    call_from_rsend : boolean;
                    VAR e           : tgg00_BasisError);
 
        FUNCTION
              a06_table_exist (
                    VAR acv      : tak_all_command_glob;
                    dstate       : tak_directory_state;
                    VAR schema   : tsp00_KnlIdentifier;
                    VAR tablen   : tsp00_KnlIdentifier;
                    VAR sparr    : tak_syspointerarr;
                    get_all      : boolean) : boolean;
 
        PROCEDURE
              a06userid_get (
                    VAR acv    : tak_all_command_glob;
                    VAR userid : tgg00_Surrogate;
                    VAR ok     : boolean);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061assign_colname (value : tsp00_C18;
                    VAR colname : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache   : VAK10;
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_cache_delete  (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10DisableTableAccess;
 
        PROCEDURE
              a10EnableTableAccess;
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10key_del  (
                    VAR acv         : tak_all_command_glob;
                    VAR  syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10_key_del  (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey);
 
        PROCEDURE
              a10MigrateBaseRecords (doMigrate : boolean);
 
        PROCEDURE
              a10next_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    reckind      : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_param_info_ptr);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10SetMigrationProtTabid (
                    tableNo   : integer;
                    VAR Tabid : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_CatalogCollectUpgradeInfo (
                    msg : tsp00_C40);
 
        PROCEDURE
              a101_CollectNewSoftwareVersion;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        FUNCTION
              a103GetColumn (
                    VAR BaseRec : tak_baserecord;
                    ColIndex    : integer
                    ) : tak00_colinfo_ptr;
 
        FUNCTION
              a103CreateCatalog : integer;
 
        PROCEDURE
              a103MigrateCatalog;
 
      ------------------------------ 
 
        FROM
              Drop_Table : VAK111;
 
        PROCEDURE
              a111drop_table (
                    VAR acv       : tak_all_command_glob;
                    VAR tabid     : tgg00_Surrogate;
                    tab_kind      : tgg00_TableKind;
                    succ_vers     : boolean;
                    do_cascade    : boolean;
                    no_references : boolean);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : vta01;
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int4     : tsp00_Int4);
 
        PROCEDURE
              t01buf (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_Buf;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01moveobj (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              t01treeid (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname (*ptocSynonym const char**);
                    VAR treeid : tgg00_FileId);
&       ENDIF
 
      ------------------------------ 
 
        FROM
              AK_Grant_Revoke : VAK22;
 
        FUNCTION
              a22exist_user  (
                    VAR acv       : tak_all_command_glob;
                    VAR user      : tsp00_KnlIdentifier;
                    errorpos      : integer;
                    VAR user_info : tak_user_info) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Index : VAK24;
 
        PROCEDURE
              a24init_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR tabid          : tgg00_Surrogate;
                    VAR index_scan_rec : tak_index_scan_record);
 
        PROCEDURE
              a24MigrateUnnamedIndex (
                    VAR acv        : tak_all_command_glob;
                    pBase          : tak_sysbufferaddress;
                    opType         : tgg00_StackOpType;
                    colptr         : tak00_colinfo_ptr;
                    VAR newindexno : tsp00_Int2);
 
        FUNCTION
              a24next_named_index (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record) : boolean;
 
        PROCEDURE
              a24finish_index_scan (
                    VAR acv            : tak_all_command_glob;
                    VAR index_scan_rec : tak_index_scan_record);
 
      ------------------------------ 
 
        FROM
              Kernel_Sink: VAK34;
 
        PROCEDURE
              a34InitOms (VAR acv : tak_all_command_glob;
                    inMigration : boolean);
 
      ------------------------------ 
 
        FROM
              AK_distributor : VAK35;
 
        PROCEDURE
              a35_asql_statement (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              Catalog_Migration_2 : VAK362;
 
        VAR
              a362OnlineTaskId : tsp00_TaskId;
 
        PROCEDURE
              a362SetUserAndSchema (
                    VAR acv      : tak_all_command_glob;
                    VAR userName : tsp00_KnlIdentifier;
                    VAR userId   : tgg00_Surrogate;
                    VAR schemaId : tgg00_Surrogate;
                    VAR userInfo : tak_user_info);
 
      ------------------------------ 
 
        FROM
              AK_warm_utility_functions : VAK37;
 
        PROCEDURE
              a37verify_catalog (
                    VAR acv      : tak_all_command_glob;
                    do_repair    : boolean;
                    in_migration : boolean);
 
      ------------------------------ 
 
        FROM
              Executing_finish : VAK507;
 
        PROCEDURE
              a507_literal (
                    VAR acv             : tak_all_command_glob;
                    VAR longliteralrec  : tak_longliteral_rec;
                    useliteralbuf       : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51build_userkey (VAR user_name : tsp00_KnlIdentifier (* ptocConst *);
                    VAR userkey : tgg00_SysInfoKey);
 
        PROCEDURE
              a51RestoreUserContext (
                    VAR acv          : tak_all_command_glob;
                    VAR pOldContext  : tsp00_Addr);
 
        PROCEDURE
              a51switch_user (
                    VAR acv            : tak_all_command_glob;
                    VAR new_user_name  : tsp00_KnlIdentifier;
                    VAR pOldContext    : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
        PROCEDURE
              a542pop_packet (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a542reset_packet (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52_ex_commit_rollback (
                    VAR acv        : tak_all_command_glob;
                    m_type         : tgg00_MessType;
                    n_rel          : boolean;
                    normal_release : boolean);
 
        PROCEDURE
              a52new_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier);
 
        PROCEDURE
              a52end_rollback_subtrans (
                    VAR acv           : tak_all_command_glob;
                    VAR subtrans_name : tsp00_KnlIdentifier;
                    m_type : tgg00_MessType);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
        PROCEDURE
              b01tcreate_file (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_3 : VBD03;
 
        PROCEDURE
              bd03SetToNotAccessible(
                    VAR Trans   : tgg00_TransContext;
                    VAR FiledId : tgg00_FileId );
 
      ------------------------------ 
 
        FROM
              filesysteminterface_7 : VBD07;
 
        PROCEDURE
              b07cadd_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cnext_record (
                    VAR t            : tgg00_TransContext;
                    VAR curr         : tgg00_FileId;
                    VAR rk           : tgg00_Lkey;
                    VAR set_result   : tgg00_BdSetResultRecord;
                    VAR tree_pos     : tgg00_FilePos;
                    VAR b            : tsp00_Buf);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02next_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_SysInfoKey;
                    inclusive   : boolean;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b02get_record (
                    VAR t       : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_SysInfoKey;
                    VAR b       : tgg00_Rec);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              error_text_handling : VBD06;
 
        VAR
              b06check_rec : boolean;
&       endif
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : VBD998;
 
        PROCEDURE
              bd998MigSwitchSingleIndexToMulti(
                    VAR trans          : tgg00_TransContext;
                    VAR tableSurrogate : tgg00_Surrogate;
                    oldSingleIndexId   : tsp00_Int4;
                    newMultiIndexId    : tsp00_Int4);
 
        PROCEDURE
              bd998MigCleanupSingleIndexes (
                    VAR trans : tgg00_TransContext);
 
        PROCEDURE
              bd998DestroyTempFile(
                    VAR trans         : tgg00_TransContext;
                    VAR tempSurrogate : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              KB_index_handling : VKB33;
 
        PROCEDURE
              k33build_new_index_id (
                    VAR table_treeid : tgg00_FileId;
                    indexNo          : tsp00_Int2;
                    VAR inv_id       : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              KB_CreateDropFile_interface : VKB641;
 
        PROCEDURE
              kb641CreateIndexFile (
                    VAR trans       : tgg00_TransContext;
                    VAR tableFileId : tgg00_FileId;
                    VAR indexFileId : tgg00_FileId;
                    indexId         : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560StartSavepointAndWait (VAR Trans : tgg00_TransContext;
                    MessType2 : tgg00_MessType2);
 
        PROCEDURE
              kb560GetSys1CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560GetSys2CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vtimestamp (VAR t   : tsp00_Timestamp);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01glob        : tgg00_KernelGlobals;
              g01unicode     : boolean;
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
        PROCEDURE
              g01optextmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C40);
 
        FUNCTION
              g01packet_size : tsp00_Int4;
 
        PROCEDURE
              g01stack_init (
                    VAR mblock : tgg00_MessBlock;
                    stack_ptr  : tgg00_StackListPtr;
                    stack_size : tsp00_Int4;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
        PROCEDURE
              g01unioptextmsg (
                    msg_enc   : tsp00_Int4;
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C80);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures :  vgg04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t    : tgg00_TransContext);
 
        PROCEDURE
              g04index_tree_build (
                    VAR file_id    : tgg00_FileId (*ptocConst*);
                    VAR index_tree : tgg00_FileId;
                    index_no       : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              Kernel-Version : VGG11;
 
        PROCEDURE
              g11kernel_version  (VAR vers : tsp00_Version);
 
        PROCEDURE
              g11ParseVersion    (VAR vers : tsp00_Version;
                    VAR majorRelease    : integer;
                    VAR minorRelease    : integer;
                    VAR correctionLevel : integer;
                    VAR buildNumber     : integer);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (
                    intval    : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_C40 (*ptocSynonym char**));
 
        PROCEDURE
              g17hexto_line (
                    c          : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_C40 (*ptocSynonym char**));
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        FUNCTION
              gg941Allocate(VAR TransContext : tgg00_TransContext;
                    wantedBytes : integer) : tsp1_packet_ptr;
 
        PROCEDURE
              gg941Deallocate(VAR TransContext : tgg00_TransContext;
                    VAR p : tsp1_packet_ptr);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr (VAR str : tsp00_KnlIdentifier;
                    skip_val  : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30unilnr (str  : tsp00_MoveObjPtr (*ptocSynonym const void**);
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plint (
                    VAR buf : tsp00_MoveObj;
                    pos     : tsp00_Int4;
                    len     : integer;
                    frac    : integer;
                    source  : tsp00_Int4;
                    VAR res : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Packet_handling : VSP26;
 
        PROCEDURE
              s26init_cmd_packet (
                    packet_ptr               : tsp1_packet_ptr;
                    VAR first_segm_ptr       : tsp1_segment_ptr);
 
        PROCEDURE
              s26finish_part (
                    packet_ptr           : tsp1_packet_ptr;
                    VAR finish_part      : tsp1_part);
 
        PROCEDURE
              s26new_part_init (
                    packet_ptr             : tsp1_packet_ptr;
                    VAR segm               : tsp1_segment;
                    VAR new_part_ptr       : tsp1_part_ptr);
 
      ------------------------------ 
 
        FROM
              Version : VSP100;
 
        PROCEDURE
              sp100_GetSenderIDVersionP  (VAR SenderIDP  : tsp00_C5 );
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              a05_stamp_get;
 
              tsp00_MoveObj tgg00_Surrogate
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tak_systembuffer
 
        PROCEDURE
              b02next_record;
 
              tgg00_Lkey tgg00_SysInfoKey
 
        PROCEDURE
              b02get_record;
 
              tgg00_Lkey tgg00_SysInfoKey;
 
        PROCEDURE
              b07cnext_record;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              g17int4to_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              g17hexto_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              a10new;
 
              tak_sysbufferaddress tak_param_info_ptr
 
        FUNCTION
              gg941Allocate;
 
              tsp00_Addr tsp1_packet_ptr
 
        PROCEDURE
              gg941Deallocate;
 
              tsp00_Addr tsp1_packet_ptr
 
        PROCEDURE
              s30lnr;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
.CM *-END-* synonym -------------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_call_from_rsend         = true;
      c_is_rollback             = true;
      c_release                 = true;
      c_inclusive               = true;
      c_migrationId             = 'Implicit Migration                                              ';
      c_migrationIdLength       = 18;
      cak361_csmindex           = '\04';
      cak361_ctermset           = '\4F';
      cak361_etermset           = '\00\4F';
      c_protTable               = 'POSTUPGRADECHECKLIST                                            ';
      c_uniProtTable            = 'POSTUPGRADECHECKLISTUNICODE                                     ';
 
TYPE
 
      tak361_MigrationGlob = RECORD
            prot_tree          : tgg00_FileId;
            refConstraint_tree : tgg00_FileId;
            view_tree          : tgg00_FileId;
            synonym_tree       : tgg00_FileId;
            surrogateMap_tree  : tgg00_FileId;
            cntRefConstraints  : tsp00_Int4;
            cntViews           : tsp00_Int4;
            cntSynonyms        : tsp00_Int4;
            viewsScanned       : boolean;
      END;
 
 
      tak361_SurrogateInfoRecord = RECORD
            CASE boolean OF
                true :
                    (r : tgg00_Rec);
                false :
                    (recOffset    : ARRAY[1..cgg_rec_key_offset] OF char;
                    oldSurrogate : tgg00_Surrogate;
                    newSurrogate : tgg00_Surrogate;
                    );
                END;
            (*ENDCASE*) 
 
      tak361_migratphase = (
            create_users,
            sysfile1,
            sysfile2,
            finished);
 
      tak361_Rec = RECORD
            CASE integer OF
                1 :
                    (align : tsp00_Addr);
                2 :
                    (syskey : tgg00_SysInfoKey);
                3 :
                    (rec : tgg00_Rec);
                END;
            (*ENDCASE*) 
 
 
 
(*------------------------------*) 
 
PROCEDURE
      a361migrate (
            VAR acv             : tak_all_command_glob;
            VAR prevKnlVersion  : tsp00_Version);
 
CONST
      c_msg_users          = 'Migrating User Catalog Data             ';
      c_msg_cat1           = 'Migrating Catalog File 1                ';
      c_msg_cat2           = 'Migrating Catalog File 2                ';
      c_msg_ref_constraint = 'Migrating Referential Constraints       ';
      c_inMigration        = true;
      c_unicodeMigration   = true;
      c_do_repair          = true;
      c_in_migration       = true;
 
VAR
      _ok                  : boolean;
      _migrationRequired   : boolean;
      _defCodeMigrated     : boolean;
      _schemaTableMigration: boolean;
      _schemaMigration     : boolean;
      _createProtTable     : boolean;
      _ColStackMigrated    : boolean;
      _uparams             : tak_userparams;
      _ix                  : integer;
      _majorRelease        : integer;
      _minorRelease        : integer;
      _correctionLevel     : integer;
      _buildNumber         : integer;
      _currMajorRelease    : integer;
      _currMinorRelease    : integer;
      _currCorrectionLevel : integer;
      _currBuildNumber     : integer;
      _phase               : tak361_migratphase;
      _mtype               : tgg00_MessType;
      _rec_buf             : tak361_Rec;
      _b_err               : tgg00_BasisError;
      _upb                 : tsp00_Int4;
      _recFill             : tsp00_Int4;
      _pageCnt             : tsp00_Int4;
      _buf                 : tak_sysbufferaddress;
      _pSchema             : tak_sysbufferaddress;
      _catalogSchemaId     : tgg00_Surrogate;
      _protTableId         : tgg00_Surrogate;
      _sysk                : tgg00_SysInfoKey;
      _schemaKey           : tgg00_SysInfoKey;
      _userRefKey          : tgg00_SysInfoKey;
      _sequenceKey         : tgg00_SysInfoKey;
      _catalog_tree        : tgg00_FileId;
      _msg                 : tsp00_C40;
      _currVersion         : tsp00_Version;
      _sysdbaName          : tsp00_KnlIdentifier;
      _MGlob               : tak361_MigrationGlob;
 
BEGIN
acv.a_localCacheUsageOnly := true;
_protTableId              := cgg_zero_id;
IF  prevKnlVersion = bsp_c40
THEN
    BEGIN
    _msg := 'unknown source release, no migration    ';
    g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
          csp3_n_migration, _msg);
    g01abort (csp3_a361_no_direct_migration, csp3_n_migration,
          'NO MIGRATION            ', 0)
    END;
(*ENDIF*) 
g11ParseVersion (prevKnlVersion,
      _majorRelease, _minorRelease, _correctionLevel, _buildNumber);
g11kernel_version  (_currVersion);
g11ParseVersion (_currVersion,
      _currMajorRelease, _currMinorRelease, _currCorrectionLevel, _currBuildNumber);
_migrationRequired :=
      (_currMajorRelease > _majorRelease)
      OR
      ((_currMajorRelease = _majorRelease) AND
      ( _currMinorRelease > _minorRelease))
      OR
      ((_currMajorRelease    = _majorRelease   ) AND
      ( _currMinorRelease    = _minorRelease   ) AND
      ( _currCorrectionLevel > _correctionLevel))
      OR
      ((_currMajorRelease    = _majorRelease   ) AND
      ( _currMinorRelease    = _minorRelease   ) AND
      ( _currCorrectionLevel = _correctionLevel) AND
      ( _currBuildNumber     > _buildNumber));
_catalogSchemaId := cgg_zero_id;
_catalogSchemaId[1] := chr(255);
_catalogSchemaId[2] := chr(255);
_catalogSchemaId[8] := chr(8);
a06userid_get (acv, _catalogSchemaId, _ok);
_schemaMigration      := NOT _ok;
_schemaTableMigration := _schemaMigration;
;
_createProtTable  := false;
IF  (_currMajorRelease    <> _majorRelease   ) OR
    (_currMinorRelease    <> _minorRelease   ) OR
    (_currCorrectionLevel <> _correctionLevel) OR
    (_currBuildNumber     <> _buildNumber    )
THEN (* PTS 1131859 M.Ki. *)
    _createProtTable := true;
(*ENDIF*) 
IF  _migrationRequired OR _schemaMigration
THEN
    BEGIN
    _ColStackMigrated         := false;
    _defCodeMigrated          := false;
    a362OnlineTaskId          := acv.a_transinf.tri_trans.trTaskId_gg00; (* allow sql statements *)
    acv.a_in_ddl_trigger      := true; (* allows sql statements in current mode *)
    _createProtTable          := false;
    ak361RenameProtTable (acv, _majorRelease, _minorRelease,
          _correctionLevel, _buildNumber, _schemaMigration);
    IF  acv.a_returncode = 0
    THEN
        ak361CreateProtTable( acv,
              _MGlob.prot_tree, g01unicode,
              _schemaMigration,
              NOT c_unicodeMigration);
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        a10SetMigrationProtTabid (1,
              acv.a_p_arr1.pbasep^.sbase.bsurrogate);
    (*ENDIF*) 
    acv.a_in_ddl_trigger := false;
    ;
    _msg                := 'start of catalog migration : source is  ';
    g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
          csp3_n_migration, _msg);
    g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
          csp3_n_migration, prevKnlVersion);
    ;
    a10_cache_delete (acv, NOT c_is_rollback);
    acv.a_p_arr1.pbasep := NIL;
    ak361InitMigrationGlob( acv, _MGlob);
    IF  (_minorRelease = 2) OR (_minorRelease = 3)
    THEN
        BEGIN
        a101_CatalogCollectUpgradeInfo ('UPGRADE FROM VERSION 7.3.XX.XX          ');
        _ColStackMigrated     := true;
        _MGlob.viewsScanned   := true;
        _schemaTableMigration := false;
        _buf                  := @_rec_buf;
        _sysk                 := a01defaultkey;
        _msg                  := c_msg_users;
        kb560GetSys1CatalogTreeId (_catalog_tree);
        _sysk.sauthid    := cgg_zero_id;
        (* build cgg_local_site *)
        _sysk.skeylen    := 0;
        _recFill         := 0;
        _phase           := sysfile1;
        a10MigrateBaseRecords (true);
        REPEAT
&           ifdef trace
            b06check_rec := false;
&           endif
            b02next_record( acv.a_transinf.tri_trans, _catalog_tree,
                  _sysk, NOT c_inclusive, _rec_buf.rec );
&           ifdef trace
            b06check_rec := true;
&           endif
            _b_err := acv.a_transinf.tri_trans.trError_gg00;
            IF  (_b_err = e_ok) OR (_b_err = e_key_not_found)
            THEN
                BEGIN
&               ifdef trace
                t01buf (ak_sem, _rec_buf.rec.recBuf_gg00, 1, _rec_buf.rec.recLen_gg00);
&               endif
                _b_err   := e_ok;
                _sysk    := _buf^.syskey;
                CASE _buf^.syskey.sentrytyp[2] OF
                    cak_cforeignkey :
                        BEGIN
                        _MGlob.cntRefConstraints  :=
                              _MGlob.cntRefConstraints + 1;
                        ak361TempStoreRecord (acv, _MGlob.refConstraint_tree,
                              _buf, _b_err)
                        END;
                    (* PTS 1117920 M.Ki. *)
                    cak_cpermmessblock :
                        ak361Messblock (acv, _catalog_tree, _sysk, _buf, _b_err);
                    cak_cprimarykey :
                        BEGIN
                        _MGlob.cntRefConstraints := _MGlob.cntRefConstraints + 1;
                        ak361TempStoreRecord (acv, _MGlob.refConstraint_tree,
                              _buf, _b_err);
                        END;
                    cak361_csmindex :
                        ak361SingleIndexRecord  (acv, _buf, _b_err);
                    cak_csysdba :
                        ak361SysdbaRecord       (acv, _sysk, _buf, _b_err);
                    cak_ctable :
                        BEGIN
                        ak361TableRecord  (acv, _MGlob, _sysk, _schemaMigration, _b_err);
                        _sysk.slinkage[1] := chr(255);
                        _sysk.slinkage[2] := chr(255)
                        END;
                    cak361_ctermset :
                        a10del_sysinfo (acv, _sysk, _b_err);
                    cak_ccontainer :
                        ak361ContainerRecord (acv, _sysk, _b_err);
                    cak_cviewdesc :
                        (* view desc records have already been migrated with 7.3.35 *)
                        IF  (_minorRelease = 2) OR (_buildNumber < 35)
                        THEN
                            ak361ViewDescRecord (acv, _sysk, _b_err);
                        (*ENDIF*) 
                    OTHERWISE
                        BEGIN
                        (* nothing to do *)
                        END;
                    END;
                (*ENDCASE*) 
                END
            ELSE
                IF  _b_err = e_no_next_record
                THEN
                    BEGIN
                    _phase := succ(_phase);
                    IF  _phase = finished
                    THEN
                        BEGIN
                        _msg := c_msg_ref_constraint;
                        _upb := _MGlob.cntRefConstraints;
                        END
                    ELSE
                        BEGIN
                        _b_err   := e_ok;
                        _pageCnt := 0;
                        CASE _phase OF
                            sysfile1:
                                BEGIN
                                _msg            := c_msg_cat1;
                                kb560GetSys1CatalogTreeId (_catalog_tree);
                                _sysk           := a01defaultkey;
                                _sysk.skeylen   := 0;
                                END;
                            sysfile2 :
                                BEGIN
                                _msg            := c_msg_cat2;
                                kb560GetSys2CatalogTreeId (_catalog_tree);
                                _sysk           := a01defaultkey;
                                _sysk.sentrytyp := cak_esysfile2;
                                END;
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        UNTIL
            (_b_err <> e_ok);
        (*ENDREPEAT*) 
        a10MigrateBaseRecords (false);
        a10_cache_delete (acv, NOT c_is_rollback);
        IF  _b_err <> e_no_next_record
        THEN
            a07_b_put_error (acv, _b_err, 1)
        ELSE
            BEGIN
            ak361MigrateRefConstraints (acv, _MGlob, _b_err);
            IF  _b_err <> e_no_next_record
            THEN
                a07_b_put_error (acv, _b_err, 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            bd998MigCleanupSingleIndexes (acv.a_transinf.tri_trans);
        (*ENDIF*) 
        END
    ELSE
        (* (_minorRelease <> 2) AND (_minorRelease <> 3) *)
        BEGIN
        END;
    (*ENDIF*) 
    IF  _minorRelease < 5
    THEN
        BEGIN
        IF  ((_minorRelease < 4    ) OR                        (* 7.2 + 7.3  *)
            ( _correctionLevel <= 2) OR                        (* <= 7.4.2   *)
            (( _correctionLevel = 3) AND (_buildNumber < 2)))  (* <  7.4.3.2 *)
            AND
            (acv.a_returncode = 0)
        THEN
            ak361MigrateDBProcedures(acv, _minorRelease, _correctionLevel, _buildNumber);
        (* PTS 1117216 E.Z. *)
        (*ENDIF*) 
        IF  ((_minorRelease < 4    ) OR                        (* 7.2 + 7.3  *)
            ( _correctionLevel <= 2) OR                        (* <= 7.4.2   *)
            ((_correctionLevel  = 3) AND (_buildNumber < 4)))  (* <  7.4.3.4 *)
            AND
            (acv.a_returncode = 0)
        THEN
            BEGIN
            ak361InitDefCodeInUserRec (acv);
            _defCodeMigrated := true;
            END;
        (* delete term char info's for certain 7.4 releases, for 7.2 and 7.3 already done *)
        (* by catalog scan                                                                *)
        (*ENDIF*) 
        IF  ((_minorRelease = 4) AND (_correctionLevel < 4)) OR
            ((_minorRelease = 4) AND (_correctionLevel = 4) AND (_buildNumber < 1))
        THEN
            IF  acv.a_returncode = 0
            THEN
                ak361DeleteTermcharInfo (acv);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  ((_minorRelease < 4    ) OR                        (* 7.2 + 7.3   *)
            ( _correctionLevel <= 2) OR                        (* <= 7.4.2    *)
            ((_correctionLevel  = 3) AND (_buildNumber < 15))) (* <  7.4.3.15 *)
            AND
            g01unicode
            AND
            (acv.a_returncode = 0)
        THEN
            ak361MigrateMapcharSet (acv);
        (*ENDIF*) 
        IF   (_minorRelease = 4) AND (acv.a_returncode = 0)
        THEN (* releases < 7.4 already handled by catalog scan *)
            IF  (_correctionLevel = 2)
                OR
                ((_correctionLevel = 3) AND (_buildNumber < 18))
                OR
                ((_correctionLevel = 4) AND (_buildNumber < 1))
            THEN
                ak361MigrateViewDesc(acv);
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  _schemaMigration AND (acv.a_returncode = 0)
    THEN
        BEGIN
        _msg := 'start of schema migration               ';
        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration, csp3_n_migration, _msg);
        IF  _schemaTableMigration
        THEN
            BEGIN
            _b_err          := e_ok;
            _sysk           := a01defaultkey;
            _sysk.sentrytyp := cak_edummy;
            a10MigrateBaseRecords (true);
            REPEAT
                a10next_sysinfo (acv, _sysk, 0, d_release, cak_edummy, _buf, _b_err);
                IF  _b_err = e_ok
                THEN
                    BEGIN
                    CASE _sysk.sentrytyp[2] OF
                        cak_ctable :
                            BEGIN
                            IF  _buf^.sbase.btablekind <> tsynonym
                            THEN
                                BEGIN
                                IF  NOT _ColStackMigrated AND
                                    (_buf^.sbase.btablekind in [twithkey, twithoutkey])
                                THEN
                                    ak361ColStackMigrate(acv, _buf);
                                (*ENDIF*) 
                                a10repl_sysinfo (acv, _buf, _b_err);
                                IF  (_b_err = e_ok)
                                    AND
                                    ( _majorRelease = 7 ) AND ( _minorRelease > 3 ) AND ( _minorRelease < 6 )
                                THEN
                                    BEGIN
                                    IF  _buf^.sbase.btablekind in [tonebase, tview, tcomplexview]
                                    THEN
                                        BEGIN
                                        _MGlob.viewsScanned := true;
                                        IF  (ftsTemp_egg00 in _buf^.sbase.btreeid.fileType_gg00             ) AND
                                            (_buf^.sbase.btreeid.fileName_gg00 = b01niltree_id.fileName_gg00)
                                        THEN
                                            _buf^.sbase.btreeid := b01niltree_id;
                                        (*ENDIF*) 
                                        ak361StoreCreateViewStmt (acv, _MGlob, _sysk,
                                              _buf^.sbase.bauthid, _buf^.sbase.bauthid, _b_err);
                                        END;
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                IF  (_b_err = e_ok) AND
                                    (_buf^.sbase.blinkexist * [ins_trigger, del_trigger, upd_trigger, internal_trigger] <> [])
                                THEN
                                    ak361MigrateTriggers (acv, _buf^.sbase.bsurrogate);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            _sysk.slinkage[2] := chr(255);
                            END;
                        cak_cpermmessblock :
                            IF  _sysk.skeylen = mxak_standard_sysk
                            THEN
                                IF  _buf^.smessblock.mbr_mess_block.mb_type = m_procedure
                                THEN
                                    BEGIN
                                    _buf^.smessblock.mbr_fieldSequenceInfo := [];
                                    a10repl_sysinfo (acv, _buf, _b_err);
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                        OTHERWISE ;
                        END;
                    (*ENDCASE*) 
                    a10_key_del  (acv, _buf^.syskey);
                    END;
                (*ENDIF*) 
            UNTIL
                (_b_err  <> e_ok) OR (acv.a_returncode <> 0);
            (*ENDREPEAT*) 
            IF  _b_err <> e_no_next_record
            THEN
                a07_b_put_error (acv, _b_err , 1);
            (*ENDIF*) 
            a10MigrateBaseRecords (false);
            _ColStackMigrated := true;
            END;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            a34InitOms(acv, c_inMigration);
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            acv.a_returncode := a103CreateCatalog;
        (*ENDIF*) 
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            _b_err          := e_ok;
            _sysk           := a01defaultkey;
            _sysk.sentrytyp := cak_esysfile2;
            REPEAT
                a10next_sysinfo (acv, _sysk, 0, d_release, cak_esysfile2, _buf, _b_err);
                IF  _b_err = e_ok
                THEN
                    CASE _buf^.syskey.sentrytyp[2] OF
                        cak_cuser :
                            BEGIN
                            IF  NOT _buf^.suser.usersysdba AND
                                (_buf^.suser.username <> a01_i_catalog)
                            THEN
                                BEGIN
                                _buf^.suser.ureplication := false;
                                _buf^.suser.userconnect  :=
                                      (is_user_rec  in _buf^.suser.urecordtyp) OR
                                      (is_group_rec in _buf^.suser.urecordtyp);
                                a10add_sysinfo (acv, _buf, _b_err);
                                IF  _b_err = e_ok
                                THEN
                                    BEGIN
                                    a10DisableTableAccess;
                                    a51build_userkey (_buf^.suser.username, _userRefKey);
                                    a10del_sysinfo (acv, _userRefKey, _b_err);
                                    IF  _b_err = e_ok
                                    THEN
                                        a10del_sysinfo (acv, _buf^.syskey, _b_err);
                                    (*ENDIF*) 
                                    a10EnableTableAccess;
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  _buf^.suser.usersysdba
                            THEN
                                _sysdbaName := _buf^.suser.username;
                            (*ENDIF*) 
                            END;
                        cak_cschema :
                            IF  _buf^.sschema.sch_name <> a01_i_oms_schema
                            THEN
                                BEGIN
                                _schemaKey           := _sysk;
                                _schemaKey.sentrytyp := cak_euser;
                                a10_nil_get_sysinfo (acv, _schemaKey, d_release,
                                      sizeof(tak_userrecord), _pSchema, _b_err);
                                IF  _b_err = e_ok
                                THEN
                                    BEGIN
                                    _pSchema^.suser.userchardefcode := 0;
                                    _pSchema^.suser.userroleinfo    := role_none;
                                    _pSchema^.suser.urecordtyp      := [is_schema_rec];
                                    _pSchema^.suser.userkind        := uprivate;
                                    _pSchema^.suser.usersysdba      := false;
                                    _pSchema^.suser.uexclusive      := false;
                                    _pSchema^.suser.ureplication    := false;
                                    _pSchema^.suser.userconnect     := false;
                                    _pSchema^.suser.userfiller3     := 0;
                                    FOR _ix := 1 TO sizeof(tsp00_CryptPw) DO
                                        BEGIN
                                        _pSchema^.suser.userpassw[_ix]      := chr(0);
                                        _pSchema^.suser.usupportpasspw[_ix] := chr(0);
                                        END;
                                    (*ENDFOR*) 
                                    _pSchema^.suser.usergroup_id   := cgg_zero_id;
                                    _pSchema^.suser.userowner_id   := acv.a_curr_user_id;
                                    _pSchema^.suser.upwcreatedate  := _buf^.sschema.sch_date;
                                    _pSchema^.suser.upwcreatetime  := _buf^.sschema.sch_time;
                                    _pSchema^.suser.ucreatedate    := _buf^.sschema.sch_date;
                                    _pSchema^.suser.ucreatetime    := _buf^.sschema.sch_time;
                                    FOR _uparams := up_unused2 TO cachelimit DO
                                        _pSchema^.suser.uparams[_uparams] := csp_maxint4;
                                    (*ENDFOR*) 
                                    _pSchema^.suser.uparams[schemaid] :=
                                          ord(_buf^.syskey.sschema_id[4]) +
                                          ord(_buf^.syskey.sschema_id[3]) * 256 +
                                          ord(_buf^.syskey.sschema_id[2]) * 256 * 256 +
                                          ord(_buf^.syskey.sschema_id[1]) * 256 * 256 * 256;
                                    _pSchema^.suser.ucomment       := false;
                                    _pSchema^.suser.userrolecnt    := 0;
                                    _pSchema^.suser.ualterdate     := _buf^.sschema.sch_date;
                                    _pSchema^.suser.ualtertime     := _buf^.sschema.sch_time;
                                    _pSchema^.suser.username       := _buf^.sschema.sch_name;
                                    a10add_sysinfo (acv, _pSchema, _b_err);
                                    IF  _b_err = e_ok
                                    THEN
                                        BEGIN
                                        _schemaKey.sauthid     := cgg_zero_id;
                                        _schemaKey.sentrytyp   := cak_eschemaref;
                                        _schemaKey.slinkage    := cak_init_linkage;
                                        _schemaKey.sidentifier := _buf^.sschema.sch_name;
                                        _schemaKey.skeylen   := sizeof(_schemaKey.sauthid) + sizeof(_schemaKey.sentrytyp) +
                                              sizeof (_schemaKey.slinkage) + sizeof(_schemaKey.sidentifier);
                                        a10del_sysinfo (acv, _buf^.syskey, _b_err);
                                        IF  _b_err = e_ok
                                        THEN
                                            a10del_sysinfo (acv, _schemaKey, _b_err);
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        cak_csequence :
                            BEGIN
                            SAPDB_PascalForcedMove (_buf^.b_sl, sizeof( _rec_buf.rec),
                                  @_buf^, 1, @_rec_buf.rec, 1, _buf^.b_sl);
                            ak361MigrateSequenceRecord (acv, _rec_buf.rec);
                            END;
                        OTHERWISE ;
                        END;
                    (*ENDCASE*) 
                (*ENDIF*) 
            UNTIL
                (_b_err  <> e_ok) OR (acv.a_returncode <> 0);
            (*ENDREPEAT*) 
            IF  _b_err <> e_no_next_record
            THEN
                a07_b_put_error (acv, _b_err, 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        a101_CatalogCollectUpgradeInfo ('CREATED CATALOG TABLES                  ');
        END;
    (*ENDIF*) 
    IF  (_minorRelease < 6) AND (acv.a_returncode = 0)
    THEN
        BEGIN
        ak361MigrateMethodInfo (acv);
        ak361DropTempTables    (acv, _MGlob, _sysdbaName);
        END;
    (*ENDIF*) 
    IF  NOT _schemaMigration
        AND (_majorRelease    = 7)
        AND (_minorRelease    = 6)
        AND (_correctionLevel = 0)
        AND (_buildNumber    <= 6)
        AND (acv.a_returncode = 0)
    THEN
        BEGIN
        a101_CatalogCollectUpgradeInfo ('UPGRADED CATALOG TABLES                 ');
        a103MigrateCatalog;
        END;
    (*ENDIF*) 
    IF  (acv.a_returncode = 0)
    THEN
        BEGIN
        IF  ((_majorRelease = 7 ) AND ( _minorRelease < 6 ))
            OR
            (( _majorRelease = 7 ) AND ( _minorRelease = 6 ) AND
            ( _correctionLevel = 0 ) AND ( _buildNumber < 24 ))
        THEN
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                a101_CatalogCollectUpgradeInfo ('RECREATE VIEWS                          ');
                ak361ReCreateViews( acv, _MGlob );
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (
        (_minorRelease < 6)
        OR
        ((_minorRelease = 6) AND (_correctionLevel = 0) AND (_buildNumber < 10))
        ) AND
        g01unicode
        AND (acv.a_returncode = 0)
    THEN
        BEGIN
        a101_CatalogCollectUpgradeInfo ('VERIFIED CATALOG TABLES                 ');
        a37verify_catalog (acv, c_do_repair, c_in_migration);
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        a101_CollectNewSoftwareVersion;
        ak361SetNewVersion (acv);
        END;
    (*ENDIF*) 
    acv.a_curr_user_name := a01controluser;
    acv.a_curr_user_id   := cak_util_user_id;
    IF  acv.a_returncode = 0
    THEN
        _mtype := m_commit
    ELSE
        BEGIN
        _msg := 'migration failed with error             ';
        g17int4to_line (acv.a_returncode,
              false, 5, 29, _msg);
        g01optextmsg (sp3p_console, sp3m_error, csp3_a361_no_direct_migration,
              csp3_n_migration, _msg);
        _mtype := m_rollback;
        END;
    (*ENDIF*) 
    a52_ex_commit_rollback (acv, _mtype,
          NOT c_release, NOT c_release);
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        kb560StartSavepointAndWait (acv.a_transinf.tri_trans, mm_config);
        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a10MigrateBaseRecords (false);
    ak361CleanupMigrationGlob( acv, _MGlob);
    a362OnlineTaskId := UNDEF_SP00;
    END;
(*ENDIF*) 
IF  (acv.a_returncode = 0) AND _createProtTable
THEN
    BEGIN
    a362OnlineTaskId     := acv.a_transinf.tri_trans.trTaskId_gg00; (* allow sql statements *)
    acv.a_in_ddl_trigger := true; (* allows sql statements in current mode *)
    ak361RenameProtTable (acv, _majorRelease, _minorRelease,
          _correctionLevel, _buildNumber, _schemaMigration);
    IF  acv.a_returncode = 0
    THEN
        ak361CreateProtTable( acv,
              _MGlob.prot_tree, g01unicode,
              (_majorRelease = 7) AND (_minorRelease < 6),
              NOT c_unicodeMigration);
    (*ENDIF*) 
    acv.a_in_ddl_trigger := false;
    a362OnlineTaskId := UNDEF_SP00;
    acv.a_returncode := 0; (* ignore errors *)
    END;
(*ENDIF*) 
acv.a_localCacheUsageOnly := false;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361ColStackMigrate (
            VAR acv      : tak_all_command_glob;
            VAR baseptr  : tak_sysbufferaddress);
 
VAR
      _ix       : integer;
      _col_ptr  : tak00_colinfo_ptr;
 
BEGIN
FOR _ix := baseptr^.sbase.bfirstindex TO baseptr^.sbase.blastindex DO
    BEGIN
    _col_ptr := a103GetColumn (baseptr^.sbase, _ix);
    IF  _col_ptr <> NIL
    THEN
        BEGIN
&       ifdef trace
        t01int4 (test_ak, 'check colsta', _ix);
&       endif
        IF  _col_ptr^.ccolstack.eop in [op_unique, op_unique_desc,
            op_order_desc, op_order_asc]
        THEN
            BEGIN
&           ifdef trace
            t01int4 (test_ak, 'repaircolsta', _ix);
&           endif
            _col_ptr^.ccolstack.eop := op_none;
            IF  ctunused in _col_ptr^.ccolpropset
            THEN
                _col_ptr^.ccolpropset := _col_ptr^.ccolpropset - [ ctunused ];
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361MigrateSequenceRecord (
            VAR acv         : tak_all_command_glob;
            VAR oldSequence : tgg00_Rec);
 
TYPE
 
      tak_oldsequencerecord  =  RECORD
            seq_reclen        : tsp00_Int2;
            seq_keylen        : tsp00_Int2;
            seq_varcol_offset : tsp00_Int2;
            seq_varcol_cnt    : tsp00_Int2;
            seq_surrogate     : tgg00_Surrogate;
            seq_entrytype     : tsp00_C2;
            seq_linkage       : tsp00_C2;
            seq_segmentid     : tsp00_C2;
            seq_comment       : boolean;
            seq_public        : boolean;
            seq_date          : tsp00_Int4;
            seq_time          : tsp00_Int4;
            seq_value         : tsp00_Number;
            seq_owner         : tgg00_Surrogate;
            seq_info          : tgg00_SeqInfo;
            seq_name          : tsp00_KnlIdentifier;
      END;
 
 
VAR
      e         : tgg00_BasisError;
      pSequence : tak_sysbufferaddress;
      pOldRec   : ^tak_oldsequencerecord;
      pSyskey   : ^tgg00_SysInfoKey;
 
BEGIN
pOldRec := @oldSequence;
pSyskey := @oldSequence;
a10_key_del  (acv, pSyskey^);
a10_nil_get_sysinfo (acv, pSyskey^, d_release,
      sizeof(tak_sequencerecord), pSequence, e);
IF  e = e_ok
THEN
    BEGIN
    pSequence^.ssequence.seq_reclen        := pOldRec^.seq_reclen + sizeof(tgg00_Surrogate);
    pSequence^.ssequence.seq_keylen        := pOldRec^.seq_keylen;
    pSequence^.ssequence.seq_varcol_offset := pOldRec^.seq_varcol_offset;
    pSequence^.ssequence.seq_varcol_cnt    := pOldRec^.seq_varcol_cnt;
    pSequence^.ssequence.seq_surrogate     := pOldRec^.seq_surrogate;
    pSequence^.ssequence.seq_entrytype     := pOldRec^.seq_entrytype;
    pSequence^.ssequence.seq_linkage       := pOldRec^.seq_linkage;
    pSequence^.ssequence.seq_segmentid     := pOldRec^.seq_segmentid;
    pSequence^.ssequence.seq_comment       := pOldRec^.seq_comment;
    pSequence^.ssequence.seq_public        := pOldRec^.seq_public;
    pSequence^.ssequence.seq_date          := pOldRec^.seq_date;
    pSequence^.ssequence.seq_time          := pOldRec^.seq_time;
    pSequence^.ssequence.seq_value         := pOldRec^.seq_value;
    pSequence^.ssequence.seq_owner         := pOldRec^.seq_owner;
    pSequence^.ssequence.seq_schema        := pOldRec^.seq_owner;
    pSequence^.ssequence.seq_info          := pOldRec^.seq_info;
    pSequence^.ssequence.seq_name          := pOldRec^.seq_name;
    a10repl_sysinfo(acv, pSequence, e);
    END;
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361RenameProtTable(
            VAR acv              : tak_all_command_glob;
            majorRelease        : integer;
            minorRelease        : integer;
            correctionLevel     : integer;
            buildNumber         : integer;
            isSchemaMigration   : boolean);
 
CONST
      c_lineCnt = 2;
      c_blanks = '                                                  ';
      cmd1  =   'RENAME TABLE POSTUPGRADECHECKLIST TO              ';
      cmd2  =   'POSTUPGRADECHECKLIST                              ';
      c_startPos = 21; (* position of first blank in cmd2 *)
 
TYPE
      TStatement = ARRAY[1..c_lineCnt] OF tsp00_C50;
 
VAR
      _table_found    : boolean;
      _pStmt          : ^TStatement;
      _b_err          : tgg00_BasisError;
      _buf            : tak_sysbufferaddress;
      _pos            : integer;
      _pUserContext   : tsp00_Addr;
      _partPtr        : tsp1_part_ptr;
      _p_arr          : tak_syspointerarr;
      _syskey         : tgg00_SysInfoKey;
      _tableName      : tsp00_KnlIdentifier;
      _sysdbaName     : tsp00_KnlIdentifier;
      _msg            : tsp00_C40;
      (* PTS 1131859 M.Ki. *)
 
BEGIN
_table_found  := false;
_pUserContext := NIL;
a542internal_packet (acv, true, 2 * sizeof(TStatement));
IF  acv.a_returncode = 0
THEN
    BEGIN
    _pStmt := @acv.a_cmd_part^.sp1p_buf;
    FOR _pos := 1 TO c_lineCnt DO
        _pStmt^[_pos] := c_blanks;
    (*ENDFOR*) 
    (* get sysdba user *)
    _syskey           := a01defaultkey;
    _syskey.sentrytyp := cak_esysdba;
    _syskey.ssite     := cgg_zero_c2;
    a10get_sysinfo (acv, _syskey, d_release, _buf, _b_err);
    IF  _b_err = e_ok
    THEN
        BEGIN
        _syskey.sauthid   := _buf^.ssysdba.sysauthid;
        _syskey.sentrytyp := cak_euser;
        _syskey.slinkage  := cak_init_linkage;
        a10get_sysinfo (acv, _syskey, d_release, _buf, _b_err);
        IF  _b_err = e_ok
        THEN
            BEGIN
            _sysdbaName          := _buf^.suser.username;
            g01glob.sysuser_name := _buf^.suser.username;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  _b_err <> e_ok
    THEN
        g01glob.sysuser_name := a01controluser;
    (*ENDIF*) 
    a51switch_user( acv, g01glob.sysuser_name, _pUserContext );
    _partPtr   := acv.a_cmd_part;
    (* get table if it exists *)
    _tableName := c_protTable;
    IF  g01unicode
    THEN
        FOR _pos := sizeof(_tableName) DIV 2 DOWNTO 1 DO
            BEGIN
            _tableName[2*_pos  ] := _tableName[_pos];
            _tableName[2*_pos-1] := chr(0);
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    IF  isSchemaMigration
    THEN
        a10MigrateBaseRecords (true);
    (*ENDIF*) 
    IF  a06_table_exist (acv, d_release,
        g01glob.sysuser_name,
        _tableName, _p_arr, false)
    THEN
        BEGIN
        IF  (_p_arr.pbasep^.sbase.btablekind = twithoutkey)
            AND (_p_arr.pbasep^.sbase.btablen^ = _tableName)
        THEN
            _table_found := true
        ELSE
            BEGIN
            _msg := 'POSTUPGRADECHECKLIST: must be a         ';
            g01optextmsg (sp3p_console, sp3m_error,
                  csp3_a361_no_direct_migration, csp3_n_migration, _msg);
            _msg := 'regular table                           ';
            g01optextmsg (sp3p_console, sp3m_error,
                  csp3_a361_no_direct_migration, csp3_n_migration, _msg);
            a07_b_put_error (acv, e_invalid_tabletype, 1);
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        acv.a_transinf.tri_trans.trError_gg00 := e_ok;
        acv.a_returncode := 0;
        END;
    (*ENDIF*) 
    IF  _table_found
    THEN
        BEGIN
        (* do rename *)
        acv.a_cmd_part := _partPtr;
        _pStmt^[1] := cmd1;
        _pStmt^[2] := cmd2;
        _pos := c_startPos;
        ak361Int4ToStr (majorRelease,    2, _pStmt^[2], _pos);
        ak361Int4ToStr (minorRelease,    2, _pStmt^[2], _pos);
        ak361Int4ToStr (correctionLevel, 2, _pStmt^[2], _pos);
        ak361Int4ToStr (buildNumber,     2, _pStmt^[2], _pos);
        acv.a_cmd_part^.sp1p_buf_len := sizeof(_pStmt^);
        ak361StatementToUnicode ( acv );
        a35_asql_statement( acv );
        IF  acv.a_returncode = 0
        THEN
            a10SetMigrationProtTabid (2,
                  acv.a_p_arr1.pbasep^.sbase.bsurrogate);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  isSchemaMigration
    THEN
        a10MigrateBaseRecords (false);
    (*ENDIF*) 
    a51RestoreUserContext ( acv, _pUserContext );
    END;
(*ENDIF*) 
a542pop_packet( acv );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361Int4ToStr(
            number     : integer ;
            minLen     : integer ;
            VAR string : tsp00_C50;
            VAR pos    : integer);
 
VAR
      exp : integer;
      i   : integer;
 
BEGIN
exp := 1;
FOR i := 1 TO minLen - 1 DO
    exp := exp * 10;
(*ENDFOR*) 
WHILE exp < (number DIV 10) DO
    exp := exp * 10;
(*ENDWHILE*) 
WHILE exp > 0 DO
    BEGIN
    string [pos] := chr(ord('0') + (number DIV exp));
    (* *)
    number := number - (number DIV exp) * exp;
    pos    := succ (pos);
    exp    := exp DIV 10;
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a361CreateProtTable (
            VAR acv        : tak_all_command_glob;
            VAR prot_tree  : tgg00_FileId;
            createUnicode  : boolean;
            isUnicodeMig   : boolean);
 
CONST
      c_isSchemaMigration = true;
 
BEGIN
ak361CreateProtTable (acv, prot_tree, createUnicode,
      NOT c_isSchemaMigration, isUnicodeMig);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361CreateProtTable (
            VAR acv           : tak_all_command_glob;
            VAR prot_tree     : tgg00_FileId;
            createUnicode     : boolean;
            isSchemaMigration : boolean;
            isUnicodeMig      : boolean);
      (* table_name must be in ASCII *)
 
CONST
      (* PTS 1131859 M.Ki. *)
      c_blanks = '                                                  ';
      cmd1v =   'CREATE TABLE POSTUPGRADECHECKLIST                 ';
      cmd1v_uni = 'CREATE TABLE POSTUPGRADECHECKLISTUNICODE          ';
      cmd2v =   '(UPGRADETYPE CHAR(40),                            ';
      cmd3v =   ' SCHEMANAME CHAR(32),                             ';
      cmd3v_u = ' SCHEMANAME CHAR(32) UNICODE,                     ';
      cmd4v =   ' OWNER CHAR(32),                                  ';
      cmd4v_u = ' OWNER CHAR(32) UNICODE,                          ';
      cmd5v =   'UPGRADEDATE TIMESTAMP DEFAULT TIMESTAMP, ERRORNUMB';
      cmd6v =   'ER INTEGER, ERRORPOSITION INTEGER,                ';
      cmd7v =   'STATEMENT LONG) INTERNAL                          ';
      cmd7v_u = 'STATEMENT LONG UNICODE) INTERNAL                  ';
 
TYPE
      TStatement = ARRAY[1..7] OF tsp00_C50;
 
VAR
      _table_found    : boolean;
      _pStmt          : ^TStatement;
      _b_err          : tgg00_BasisError;
      _pos            : integer;
      _buf            : tak_sysbufferaddress;
      _pUserContext   : tsp00_Addr;
      _partPtr        : tsp1_part_ptr;
      _p_arr          : tak_syspointerarr;
      _syskey         : tgg00_SysInfoKey;
      _msg            : tsp00_C40;
      _tableName      : tsp00_KnlIdentifier;
      _sysdbaName     : tsp00_KnlIdentifier;
 
BEGIN
_table_found  := false;
_pUserContext := NIL;
a542internal_packet (acv, true, 2 * sizeof(TStatement));
IF  acv.a_returncode = 0
THEN
    BEGIN
    _pStmt := @acv.a_cmd_part^.sp1p_buf;
    FOR _pos := 1 TO 7 DO
        _pStmt^[_pos] := c_blanks;
    (*ENDFOR*) 
    (* get sysdba user *)
    _syskey           := a01defaultkey;
    _syskey.sentrytyp := cak_esysdba;
    _syskey.ssite     := cgg_zero_c2;
    a10get_sysinfo (acv, _syskey, d_release, _buf, _b_err);
    IF  _b_err = e_ok
    THEN
        BEGIN
        _syskey.sauthid   := _buf^.ssysdba.sysauthid;
        _syskey.sentrytyp := cak_euser;
        _syskey.slinkage  := cak_init_linkage;
        a10get_sysinfo (acv, _syskey, d_release, _buf, _b_err);
        IF  _b_err = e_ok
        THEN
            BEGIN
            _sysdbaName          := _buf^.suser.username;
            g01glob.sysuser_name := _buf^.suser.username;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  _b_err <> e_ok
    THEN
        g01glob.sysuser_name := a01controluser;
    (*ENDIF*) 
    a51switch_user( acv, g01glob.sysuser_name, _pUserContext );
    _partPtr   := acv.a_cmd_part;
    (* get table if it exists *)
    IF  isUnicodeMig
    THEN
        _tableName := c_uniProtTable
    ELSE
        _tableName := c_protTable;
    (*ENDIF*) 
    IF  g01unicode
    THEN
        FOR _pos := sizeof(_tableName) DIV 2 DOWNTO 1 DO
            BEGIN
            _tableName[2*_pos  ] := _tableName[_pos];
            _tableName[2*_pos-1] := chr(0);
            END;
        (*ENDFOR*) 
    (*ENDIF*) 
    IF  isSchemaMigration
    THEN
        a10MigrateBaseRecords (true);
    (*ENDIF*) 
    IF  a06_table_exist (acv, d_release,
        g01glob.sysuser_name,
        _tableName, _p_arr, false)
    THEN
        BEGIN
        prot_tree    := _p_arr.pbasep^.sbase.btreeid;
        IF  isUnicodeMig
        THEN
            _msg := 'POSTUPGRADECHECKLISTUNICODE: table must '
        ELSE
            _msg := 'POSTUPGRADECHECKLIST: table must        ';
        (*ENDIF*) 
        g01optextmsg (sp3p_console, sp3m_error,
              csp3_a361_no_direct_migration, csp3_n_migration, _msg);
        _msg := 'not exist                               ';
        g01optextmsg (sp3p_console, sp3m_error,
              csp3_a361_no_direct_migration, csp3_n_migration, _msg);
        prot_tree.fileName_gg00 := cgg_zero_fn;
        a07_b_put_error (acv, e_duplicate_tablename, 1);
        END;
    (*ENDIF*) 
    IF  isSchemaMigration
    THEN
        a10MigrateBaseRecords (false);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    acv.a_cmd_part := _partPtr;
    IF  isUnicodeMig
    THEN
        _pStmt^[1]     := cmd1v_uni
    ELSE
        _pStmt^[1]     := cmd1v;
    (*ENDIF*) 
    _pStmt^[2]     := cmd2v;
    _pStmt^[5]     := cmd5v;
    _pStmt^[6]     := cmd6v;
    IF  createUnicode (* PTS 1123632 M.Ki.*)
    THEN
        BEGIN
        _pStmt^[3]     := cmd3v_u;
        _pStmt^[4]     := cmd4v_u;
        _pStmt^[7]     := cmd7v_u;
        END
    ELSE
        BEGIN
        _pStmt^[3]     := cmd3v;
        _pStmt^[4]     := cmd4v;
        _pStmt^[7]     := cmd7v;
        END;
    (*ENDIF*) 
    acv.a_cmd_part^.sp1p_buf_len := sizeof(_pStmt^);
    ak361StatementToUnicode ( acv );
    a35_asql_statement( acv );
    IF  acv.a_returncode = 0
    THEN
        prot_tree := acv.a_p_arr1.pbasep^.sbase.btreeid;
    (*ENDIF*) 
    END;
(*ENDIF*) 
a51RestoreUserContext ( acv, _pUserContext );
IF  acv.a_returncode <> 0
THEN
    BEGIN
    _msg := 'Could not create prot table             ';
    g01optextmsg (sp3p_console, sp3m_error, csp3_a361_no_direct_migration,
          csp3_n_migration, _msg);
    END;
(*ENDIF*) 
a542pop_packet( acv );
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361InitMigrationGlob (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak361_MigrationGlob);
 
BEGIN
MGlob.cntRefConstraints             := 0;
MGlob.cntViews                      := 0;
MGlob.cntSynonyms                   := 0;
MGlob.view_tree                     := b01niltree_id;
MGlob.refConstraint_tree            := b01niltree_id;
MGlob.synonym_tree                  := b01niltree_id;
MGlob.surrogateMap_tree             := b01niltree_id;
g04build_temp_tree_id (MGlob.view_tree, acv.a_transinf.tri_trans);
MGlob.view_tree.fileTfnTemp_gg00    := ttfnTrigger_egg00;
b01tcreate_file( acv.a_transinf.tri_trans, MGlob.view_tree );
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    g04build_temp_tree_id (MGlob.refConstraint_tree, acv.a_transinf.tri_trans);
    MGlob.refConstraint_tree.fileTfnTemp_gg00 := ttfnTrigger_egg00;
    b01tcreate_file (acv.a_transinf.tri_trans, MGlob.refConstraint_tree);
    END;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    g04build_temp_tree_id (MGlob.synonym_tree, acv.a_transinf.tri_trans);
    MGlob.synonym_tree.fileTfnTemp_gg00 := ttfnTrigger_egg00;
    b01tcreate_file (acv.a_transinf.tri_trans, MGlob.synonym_tree);
    END;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
THEN
    BEGIN
    g04build_temp_tree_id (MGlob.surrogateMap_tree, acv.a_transinf.tri_trans);
    MGlob.surrogateMap_tree.fileTfnTemp_gg00 := ttfnTrigger_egg00;
    b01tcreate_file (acv.a_transinf.tri_trans, MGlob.surrogateMap_tree);
    END;
(*ENDIF*) 
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
(*ENDIF*) 
MGlob.viewsScanned := false;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361CleanupMigrationGlob (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak361_MigrationGlob);
 
VAR
      aux_err : tgg00_BasisError;
 
BEGIN
aux_err := acv.a_transinf.tri_trans.trError_gg00;
IF  MGlob.view_tree.fileTabId_gg00 <> cgg_zero_id
THEN
    bd998DestroyTempFile (acv.a_transinf.tri_trans,
          MGlob.view_tree.fileTabId_gg00 );
(*ENDIF*) 
MGlob.view_tree := b01niltree_id;
(* *)
IF  MGlob.refConstraint_tree.fileTabId_gg00 <> cgg_zero_id
THEN
    bd998DestroyTempFile (acv.a_transinf.tri_trans,
          MGlob.refConstraint_tree.fileTabId_gg00 );
(*ENDIF*) 
MGlob.refConstraint_tree := b01niltree_id;
(* *)
IF  MGlob.synonym_tree.fileTabId_gg00 <> cgg_zero_id
THEN
    bd998DestroyTempFile (acv.a_transinf.tri_trans,
          MGlob.synonym_tree.fileTabId_gg00 );
(*ENDIF*) 
MGlob.synonym_tree := b01niltree_id;
(* *)
IF  MGlob.surrogateMap_tree.fileTabId_gg00 <> cgg_zero_id
THEN
    bd998DestroyTempFile (acv.a_transinf.tri_trans,
          MGlob.surrogateMap_tree.fileTabId_gg00 );
(*ENDIF*) 
MGlob.surrogateMap_tree := b01niltree_id;
acv.a_transinf.tri_trans.trError_gg00 := aux_err;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361SetNewVersion (VAR acv : tak_all_command_glob);
 
VAR
      b_err : tgg00_BasisError;
      pBuf  : tak_sysbufferaddress;
      sysk  : tgg00_SysInfoKey;
      msg   : tsp00_C40;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    sysk           := a01defaultkey;
    sysk.sentrytyp := cak_esysdba;
    a10_fix_len_get_sysinfo (acv, sysk, d_release,
          sizeof(tak_sysdbarecord), 0, pBuf, b_err );
    IF  b_err = e_ok
    THEN
        BEGIN
        pBuf^.ssysdba.sysversion := cak_sysdba_version;
        g11kernel_version  (pBuf^.ssysdba.sysKnlVersion);
        msg := 'new sysdba version is                   ';
        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
              csp3_n_migration, msg);
        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
              csp3_n_migration, pBuf^.ssysdba.sysKnlVersion);
        pBuf^.b_sl := sizeof(tak_sysdbarecord);
        a10repl_sysinfo( acv, pBuf, b_err );
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361StatementToUnicode (VAR acv : tak_all_command_glob);
 
VAR
      ix : integer;
 
BEGIN
IF  g01unicode
THEN
    IF  acv.a_cmd_part^.sp1p_buf_len * 2 > acv.a_cmd_part^.sp1p_buf_size
    THEN
        a07_b_put_error (acv, e_too_small_packet_size, 1)
    ELSE
        BEGIN
        FOR ix := acv.a_cmd_part^.sp1p_buf_len DOWNTO 1 DO
            BEGIN
            acv.a_cmd_part^.sp1p_buf[2*ix  ] := acv.a_cmd_part^.sp1p_buf[ix];
            acv.a_cmd_part^.sp1p_buf[2*ix-1] := chr(0);
            END;
        (*ENDFOR*) 
        acv.a_cmd_part^.sp1p_buf_len := acv.a_cmd_part^.sp1p_buf_len * 2;
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361MigrateMapcharSet (
            VAR acv : tak_all_command_glob);
 
VAR
      e           : tgg00_BasisError;
      offset      : integer;
      pCharSet    : tak_sysbufferaddress;
      pNewCharSet : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
      newSysk     : tgg00_SysInfoKey;
      msg         : tsp00_C40;
 
BEGIN
msg := 'migrating mapset                        ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
      csp3_n_migration, msg);
sysk             := a01defaultkey;
sysk.sentrytyp   := cak_emapset;
sysk.slinkage    := cak_init_linkage;
a061assign_colname (cak00_default_mapchar_set, sysk.sidentifier);
sysk.skeylen     := sizeof (sysk.stableid) +
      sizeof (sysk.sentrytyp) + sizeof (sysk.slinkage) +
      sizeof (sysk.sidentifier);
a10get_sysinfo (acv, sysk, d_release, pCharSet, e);
IF  e = e_ok
THEN
    BEGIN
    newSysk := sysk;
    a01sets_identifier (sysk.sidentifier, cak00_default_mapchar_set);
    a10_nil_get_sysinfo (acv, sysk, d_release,
          pCharSet^.b_sl, pNewCharSet, e);
    IF  e = e_ok
    THEN
        BEGIN
        offset := cgg_rec_key_offset + pCharSet^.b_kl;
        SAPDB_PascalMove('VAK361',   1,    
              pCharSet^.b_sl, pCharSet^.b_sl,
              @pCharSet^, offset + 1,
              @pNewCharSet^, offset + 1,
              pCharSet^.b_sl - offset, e);
        IF  e = e_ok
        THEN
            a10add_sysinfo (acv, pNewCharSet, e);
        (*ENDIF*) 
        IF  e = e_ok
        THEN
            a10del_sysinfo (acv, sysk, e)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361MigrateTriggers (
            VAR acv   : tak_all_command_glob;
            VAR tabid : tgg00_Surrogate);
 
VAR
      b_err       : tgg00_BasisError;
      sysk        : tgg00_SysInfoKey;
      pTrigger    : tak_sysbufferaddress;
      msg         : tsp00_C40;
 
BEGIN
WITH acv DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        msg := 'migrating triggers                      ';
        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
              csp3_n_migration, msg);
        sysk            := a01defaultkey;
        sysk.stableid   := tabid;
        sysk.sentrytyp  := cak_etrigger;
        REPEAT
            a10next_sysinfo (acv, sysk, sizeof(tabid), d_release,
                  cak_etrigger, pTrigger, b_err);
            IF  (b_err = e_ok) AND
                (ord (sysk.slinkage[2]) in [1,3,5,11,13,15])
            THEN
                BEGIN
                pTrigger^.strigger.tr_maxUpdatedColno := 0;
                pTrigger^.strigger.tr_language        := lang_pl;
                a10repl_sysinfo (acv, pTrigger, b_err);
                a10key_del (acv, pTrigger);
                END;
            (*ENDIF*) 
        UNTIL
            b_err <> e_ok;
        (*ENDREPEAT*) 
        IF  b_err <> e_no_next_record
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361MigrateViewDesc(
            VAR acv : tak_all_command_glob);
 
VAR
      e           : tgg00_BasisError;
      ix          : integer;
      cnt         : integer;
      pViewDesc   : tak_sysbufferaddress;
      pNewCharSet : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
      newSysk     : tgg00_SysInfoKey;
      msg         : tsp00_C40;
 
BEGIN
msg := 'migrating view descriptions             ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
      csp3_n_migration, msg);
sysk             := a01defaultkey;
sysk.sentrytyp   := cak_emapset;
sysk.slinkage    := cak_init_linkage;
cnt              := 0;
REPEAT
    a10next_sysinfo (acv, sysk, 0, d_release, cak_eviewdesc, pViewDesc, e);
    IF  e = e_ok
    THEN
        IF  pViewDesc^.sviewdesc.vdesc_cnt > 0
        THEN
            BEGIN
            ak361MigrateViewDescRecord (pViewDesc^.sviewdesc);
            a10repl_sysinfo( acv, pViewDesc, e );
            IF  e = e_ok
            THEN
                cnt := cnt + 1;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    e <> e_ok;
(*ENDREPEAT*) 
IF  e <> e_no_next_record
THEN
    a07_b_put_error (acv, e, 1)
ELSE
    BEGIN
    msg := 'view descs migrated :                   ';
    g17int4to_line (cnt, false, 10, 22, msg);
    g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
          csp3_n_migration, msg);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361MigrateViewDescRecord (
            VAR viewDescRecord : tak_viewdescrecord);
 
TYPE
 
      old_vcolumndescription  =  PACKED RECORD
            vfromtabno    : tsp00_Int2;
            vn_pos        : tsp00_Int2;
            vfromextcolno : tsp00_Int2;
            vextcolno     : tsp00_Int2;
            vdatatype     : tsp00_DataType;
            vfiller       : boolean;
            vfiller1      : tsp00_Int2;
      END;
 
 
VAR
      ix          : integer;
      pOldDesc    : ^old_vcolumndescription;
      oldDesc     : old_vcolumndescription;
 
BEGIN
WITH viewDescRecord DO
    BEGIN
    FOR ix := 1 TO vdesc_cnt DO
        BEGIN
        pOldDesc := @vdescription[ix];
        oldDesc  := pOldDesc^;
        vdescription[ix].vfromtabno    := oldDesc.vfromtabno;
        vdescription[ix].vn_pos        := oldDesc.vn_pos;
        vdescription[ix].vfromextcolno := oldDesc.vfromextcolno;
        vdescription[ix].vextcolno     := oldDesc.vextcolno;
        vdescription[ix].vdatatype     := oldDesc.vdatatype;
        vdescription[ix].vfiller       := false;
        END;
    (*ENDFOR*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361ViewDescRecord (VAR acv : tak_all_command_glob;
            VAR Syskey  : tgg00_SysInfoKey;
            VAR e       : tgg00_BasisError);
 
VAR
      pViewDesc : tak_sysbufferaddress;
 
BEGIN
a10get_sysinfo (acv, Syskey, d_release, pViewDesc, e);
IF  e = e_ok
THEN
    BEGIN
    ak361MigrateViewDescRecord (pViewDesc^.sviewdesc);
    a10repl_sysinfo (acv, pViewDesc, e);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361DeleteTermcharInfo (
            VAR acv : tak_all_command_glob);
 
VAR
      e        : tgg00_BasisError;
      syskey   : tgg00_SysInfoKey;
      pTermSet : tak_sysbufferaddress;
      msg      : tsp00_C40;
 
BEGIN
msg := 'deleting termchar info ...              ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
      csp3_n_migration, msg);
syskey           := a01defaultkey;
syskey.sentrytyp := cak361_etermset;
REPEAT
    a10next_sysinfo (acv, syskey, sizeof(syskey.stableid), d_release, cak361_etermset,
          pTermSet, e);
    IF  e = e_ok
    THEN
        a10del_sysinfo (acv, syskey, e);
    (*ENDIF*) 
UNTIL
    e <> e_ok;
(*ENDREPEAT*) 
IF  e <> e_no_next_record
THEN
    a07_b_put_error (acv, e, 1)
ELSE
    ak361DoneMessage;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361DoneMessage;
 
VAR
      msg : tsp00_C40;
 
BEGIN
msg := 'done                                    ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
      csp3_n_migration, msg);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361DropTempTables (VAR acv : tak_all_command_glob;
            VAR MGlob      : tak361_MigrationGlob;
            VAR SysdbaName : tsp00_KnlIdentifier);
 
VAR
      ok   : boolean;
      msg  : tsp00_C40;
 
BEGIN
msg := 'dropping temp catalog table ...         ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
      csp3_n_migration, msg);
ok := true;
ak361DropTempTable (acv, MGlob, SysdbaName, a01_i_sysmonitor, ok);
ak361DropTempTable (acv, MGlob, SysdbaName, a01_i_sysmondata, ok);
ak361DropTempTable (acv, MGlob, SysdbaName, a01_i_sysparseid, ok);
ak361DropTempTable (acv, MGlob, SysdbaName, a01_i_syscmd_analyze, ok);
ak361DropTempTable (acv, MGlob, SysdbaName, a01_i_sysdata_analyze, ok);
ak361DropTempTable (acv, MGlob, SysdbaName, a01_i_sysupdstatwanted, ok);
IF  ok
THEN
    msg := 'dropping temp catalog table ok          '
ELSE
    msg := 'dropping temp catalog table with errors ';
(*ENDIF*) 
g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
      csp3_n_migration, msg);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361DropTempTable (VAR acv : tak_all_command_glob;
            VAR MGlob      : tak361_MigrationGlob;
            VAR SysdbaName : tsp00_KnlIdentifier;
            Var TableName  : tsp00_KnlIdentifier;
            VAR Ok         : boolean);
 
VAR
      p_arr        : tak_syspointerarr;
      _migrationId : tsp00_C64;
      _pMoveObj    : ^tsp00_MoveObj;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    IF  a06_table_exist (acv, d_fix, SysdbaName, TableName, p_arr, true)
    THEN
        BEGIN
        a111drop_table (acv, p_arr.pbasep^.sbase.bsurrogate,
              p_arr.pbasep^.sbase.btablekind, false, true, false);
        IF  acv.a_returncode <> 0
        THEN
            BEGIN
            Ok := false;
            _migrationId := c_migrationId;
            _pMoveObj    := @TableName;
            ak361WriteProt (acv, MGlob.prot_tree, _migrationId,
                  c_migrationIdLength,
                  SysdbaName, sizeof(SysdbaName),
                  SysdbaName, sizeof(SysdbaName),
                  g01unicode, _pMoveObj^, sizeof(TableName), acv.a_returncode, 1);
            acv.a_returncode := 0;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(* PTS 1117216 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak361InitDefCodeInUserRec (VAR acv : tak_all_command_glob);
 
VAR
      b_err       : tgg00_BasisError;
      sysk        : tgg00_SysInfoKey;
      sysbuf      : tak_sysbufferaddress;
      msg         : tsp00_C40;
 
BEGIN
WITH acv DO
    BEGIN
    IF  a_returncode = 0
    THEN
        BEGIN
        msg := 'initializing user default code ...      ';
        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
              csp3_n_migration, msg);
        sysk            := a01defaultkey;
        sysk.sauthid[1] := chr(255);
        sysk.sauthid[2] := chr(255);
        sysk.sentrytyp  := cak_euser;
        REPEAT
            a10next_sysinfo (acv, sysk, 0, d_release,
                  cak_euser, sysbuf, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                sysbuf^.suser.userchardefcode := csp_instance_code;
                sysbuf^.suser.ureplication    := false;
                sysbuf^.suser.userconnect     := true;
                sysbuf^.suser.userfiller3     := 0;
                a10repl_sysinfo (acv, sysbuf, b_err);
                END;
            (*ENDIF*) 
            a10key_del (acv, sysbuf);
        UNTIL
            b_err <> e_ok;
        (*ENDREPEAT*) 
        IF  b_err <> e_no_next_record
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361MigrateDBProcedures(VAR acv : tak_all_command_glob;
            minorRelease    : integer;
            correctionLevel : integer;
            buildNumber     : integer);
 
TYPE
 
      tak_old_param_info  =  RECORD
            param_datatype     : tsp00_DataType;
            param_datafrac     : tsp00_Uint1;
            param_datalength   : tsp00_Int2;
            param_inoutlength  : tsp00_Int2;
            param_in_out       : tsp00_C2;
            param_com_datatype : tsp00_Int2;
            param_type_id      : tsp00_C2;
            param_offset       : tsp00_Int2;
            param_new_old      : tak_param_state;
            param_name_len     : char;
            param_name         : tsp00_C256;
      END;
 
 
VAR
      b_err             : tgg00_BasisError;
      migrationRequired : boolean;
      pos               : integer;
      ix                : integer;
      jx                : integer;
      length            : integer;
      mBuf              : ^tak_methodrecord;
      pBuf              : tak_sysbufferaddress;
      sysk              : tgg00_SysInfoKey;
      oldParamInfo      : tak_old_param_info;
      pOldParamInfo     : ^tsp00_MoveObj;
      b                 : tak361_Rec;
      msg               : tsp00_C40;
      sys2_cat          : tgg00_FileId;
 
BEGIN
(* 7.4.3 introduced offsets for ascii and unicode clients into parameter description *)
(* expand olf parameter descriptions if necessary                                    *)
migrationRequired := true;
IF  (minorRelease = 4)
    AND
    ((correctionLevel = 2) OR ((correctionLevel = 3) AND (buildNumber < 2)))
THEN
    BEGIN
    (* this may be a 7.4.2 or an early internal 7.4.3 release *)
    (* check if migration is necessary                        *)
    sysk           := a01defaultkey;
    sysk.sauthid   := g01glob.sysuser_id;
    sysk.sentrytyp := cak_emethodref;
    a01sets_identifier (sysk.sappl, 'FORCE_CHECKPOINT  ');
    sysk.skeylen   := sysk.skeylen + sizeof (sysk.sappl);
    a10get_sysinfo (acv, sysk,
          d_release, pBuf, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        sysk           := a01defaultkey;
        sysk.stableid  := pBuf^.smethodref.mrf_method_id;
        sysk.sentrytyp := cak_emethod;
&       ifdef trace
        b06check_rec := false;
&       endif
        kb560GetSys2CatalogTreeId (sys2_cat);
        b02get_record( acv.a_transinf.tri_trans, sys2_cat, sysk, b.rec );
&       ifdef trace
        b06check_rec := true;
&       endif
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        END;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        pos := sizeof (tak_methodrecord) -
              sizeof (tak_param_array)        +
              sizeof (tak_old_param_info)     -
              sizeof (tsp00_C256)               - 1;
        migrationRequired :=
              (b.rec.recBuf_gg00[pos] <> chr(0)) OR (b.rec.recBuf_gg00[pos+1] <> chr(0));
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  migrationRequired
THEN
    BEGIN (* scan all db procedures *)
    kb560GetSys2CatalogTreeId (sys2_cat);
    msg := 'migrating db-procedures to 7.4.3 layout ';
    g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
          csp3_n_migration, msg);
    pOldParamInfo := @oldParamInfo;
    sysk.skeylen  := 0;
    REPEAT
&       ifdef trace
        b06check_rec := false;
&       endif
        b02next_record( acv.a_transinf.tri_trans, sys2_cat,
              sysk, NOT c_inclusive, b.rec );
&       ifdef trace
        b06check_rec := true;
&       endif
        b_err := acv.a_transinf.tri_trans.trError_gg00;
        IF  (b_err = e_ok) OR (b_err = e_key_not_found)
        THEN
            BEGIN
&           ifdef trace
            t01buf (ak_sem, b.rec.recBuf_gg00, 1, b.rec.recLen_gg00);
&           endif
            b_err   := e_ok;
            sysk    := b.syskey;
            IF  (sysk.sentrytyp[2] = cak_cmethod) AND (sysk.slinkage <> cak_init_linkage)
            THEN
                BEGIN
                msg := 'unexpected record found, skipped        ';
                g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
                      csp3_n_migration, msg);
                msg    := bsp_c40;
                length := 0;
                FOR ix := 1 TO sysk.skeylen DO
                    BEGIN
                    g17hexto_line (sysk.sstandardkey[ix], length, msg);
                    END;
                (*ENDFOR*) 
                g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
                      csp3_n_migration, msg);
                END;
            (*ENDIF*) 
            IF  (sysk.sentrytyp[2] = cak_cmethod) AND (sysk.slinkage = cak_init_linkage)
            THEN
                BEGIN
                mBuf := @b.rec;
                a10del_sysinfo (acv, sysk, b_err);
                IF  b_err = e_ok
                THEN
                    a10_nil_get_sysinfo (acv, sysk, d_fix,
                          sizeof (tak_methodrecord) - sizeof(tak_param_array) +
                          mBuf^.me_param_cnt * sizeof(mBuf^.me_param_list[1]),
                          pBuf, b_err);
                (*ENDIF*) 
                IF  b_err = e_ok
                THEN
                    BEGIN
                    FOR ix := 1 TO mBuf^.me_param_cnt DO
                        pBuf^.smethod.me_param_list[ix] := NIL;
                    (*ENDFOR*) 
                    pBuf^.smethod.me_segmentid  := mBuf^.me_segmentid;
                    pBuf^.smethod.me_param_cnt  := mBuf^.me_param_cnt;
                    pBuf^.smethod.me_type       := mBuf^.me_type;
                    pBuf^.smethod.me_debug      := mBuf^.me_debug;
                    pBuf^.smethod.me_sql        := mBuf^.me_sql;
                    pBuf^.smethod.me_cursor     := mBuf^.me_cursor;
                    pBuf^.smethod.me_dispid     := mBuf^.me_dispid;
                    pBuf^.smethod.me_coclsid    := mBuf^.me_coclsid;
                    pBuf^.smethod.me_iid        := mBuf^.me_iid;
                    pBuf^.smethod.me_package_id := mBuf^.me_package_id;
                    pos := sizeof (tak_methodrecord) - sizeof (tak_param_array) + 1;
                    ix  := 1;
                    WHILE ix <= pBuf^.smethod.me_param_cnt DO
                        BEGIN
                        IF  pos > mBuf^.me_reclen
                        THEN
                            BEGIN
                            a06inc_linkage (sysk.slinkage);
&                           ifdef trace
                            b06check_rec := false;
&                           endif
                            b02get_record( acv.a_transinf.tri_trans, sys2_cat, sysk, b.rec );
&                           ifdef trace
                            b06check_rec := true;
&                           endif
                            b_err := acv.a_transinf.tri_trans.trError_gg00;
                            IF  b_err = e_ok
                            THEN
                                a10del_sysinfo (acv, sysk, b_err);
                            (*ENDIF*) 
                            IF  b_err <> e_ok
                            THEN
                                b_err := acv.a_transinf.tri_trans.trError_gg00;
                            (*ENDIF*) 
                            pos   := cak_sysbufferoffset + sizeof (mBuf^.me_segmentid) + 1
                            END;
                        (*ENDIF*) 
                        IF  b_err = e_ok
                        THEN
                            BEGIN
                            length := sizeof (tak_old_param_info) - sizeof (tsp00_C256) +
                                  ord (b.rec.recBuf_gg00[pos + sizeof (tak_old_param_info)  -
                                  sizeof (tsp00_C256) - 1]);
&                           ifdef trace
                            t01int4 (ak_sem, 'length      ', length);
&                           endif
                            a10new (acv,
                                  length + sizeof(tak_param_info) - sizeof(tak_old_param_info),
                                  pBuf^.smethod.me_param_list[ix]);
                            IF  pBuf^.smethod.me_param_list[ix] = NIL
                            THEN
                                b_err := e_no_more_memory
                            ELSE
                                BEGIN
                                SAPDB_PascalMove('VAK361',   2,    
                                      sizeof( b.rec.recBuf_gg00 ), sizeof( oldParamInfo ),
                                      @b.rec.recBuf_gg00, pos, @pOldParamInfo^, 1,
                                      length, b_err);
                                IF  b_err = e_ok
                                THEN
                                    WITH pBuf^.smethod.me_param_list[ix]^ DO
                                        BEGIN
                                        param_datatype       := oldParamInfo.param_datatype;
                                        param_datafrac       := oldParamInfo.param_datafrac;
                                        param_datalength     := oldParamInfo.param_datalength;
                                        param_inoutlength    := oldParamInfo.param_inoutlength;
                                        param_in_out         := oldParamInfo.param_in_out;
                                        param_com_datatype   := oldParamInfo.param_com_datatype;
                                        param_type_id        := oldParamInfo.param_type_id;
                                        param_cpp_offset     := oldParamInfo.param_offset;
                                        param_ascii_offset   := oldParamInfo.param_offset;
                                        param_unicode_offset := oldParamInfo.param_offset;
                                        param_state          := oldParamInfo.param_new_old;
                                        param_name_len       := oldParamInfo.param_name_len;
                                        FOR jx := 1 TO ord(param_name_len) DO
                                            param_name[jx] := oldParamInfo.param_name[jx];
                                        (*ENDFOR*) 
                                        END;
                                    (*ENDWITH*) 
                                (*ENDIF*) 
                                pos := pos + length;
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  b_err <> e_ok
                        THEN
                            ix := csp_maxint2 (* exit loop *)
                        ELSE
                            ix := ix + 1;
                        (*ENDIF*) 
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
                IF  b_err = e_ok
                THEN
                    BEGIN
                    a10rel_sysinfo  (pBuf);
                    a10add_sysinfo (acv, pBuf, b_err);
                    END;
                (*ENDIF*) 
                sysk.slinkage[1] := chr(255);
                sysk.slinkage[2] := chr(255);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok);
    (*ENDREPEAT*) 
    IF  b_err = e_no_next_record
    THEN
        b_err := e_ok;
    (*ENDIF*) 
    END;
(* PTS 1117216 E.Z. *)
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    a07_b_put_error (acv, b_err, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361MigrateMethodInfo (
            VAR acv         : tak_all_command_glob);
 
TYPE
 
      old_method_inforecord = RECORD
            mei_reclen         : tsp00_Int2;
            mei_keylen         : tsp00_Int2;
            mei_varcol_offset  : tsp00_Int2;
            mei_varcol_cnt     : tsp00_Int2;
            mei_surrogate      : tgg00_Surrogate;
            mei_entrytype      : tsp00_C2;
            mei_linkage        : tsp00_C2;
            mei_segmentid      : tsp00_C2;
            mei_comment        : boolean;
            mei_filler         : boolean;
            mei_owner          : tgg00_Surrogate;
            mei_date           : tsp00_Int4;
            mei_time           : tsp00_Int4;
            mei_prog_id        : tsp00_C64;
            mei_name           : tsp00_KnlIdentifier;
      END;
 
 
VAR
      e             : tgg00_BasisError;
      p             : tak_sysbufferaddress;
      sysk          : tgg00_SysInfoKey;
      oldMethodInfo : old_method_inforecord;
      msg           : tsp00_C40;
 
BEGIN
msg := 'method info migration                   ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration, csp3_n_migration, msg);
sysk.skeylen := 0;
REPEAT
    a10next_sysinfo (acv, sysk, 0, d_release, cak_emethodinfo, p, e);
    IF  e = e_ok
    THEN
        BEGIN
        SAPDB_PascalForcedMove (p^.b_sl, sizeof(oldMethodInfo),
              @p^, 1, @oldMethodInfo, 1, sizeof(oldMethodInfo));
        a10del_sysinfo (acv, sysk, e);
        IF  e = e_ok
        THEN
            a10_nil_get_sysinfo (acv, sysk, d_release, sizeof (tak_method_inforecord), p, e);
        (*ENDIF*) 
        IF  e = e_ok
        THEN
            BEGIN
            p^.smethodinfo.mei_segmentid := oldMethodInfo.mei_segmentid;
            p^.smethodinfo.mei_comment   := oldMethodInfo.mei_comment;
            p^.smethodinfo.mei_filler    := false;
            p^.smethodinfo.mei_owner     := oldMethodInfo.mei_owner;
            p^.smethodinfo.mei_schema    := oldMethodInfo.mei_owner;
            p^.smethodinfo.mei_date      := oldMethodInfo.mei_date;
            p^.smethodinfo.mei_time      := oldMethodInfo.mei_time;
            p^.smethodinfo.mei_prog_id   := oldMethodInfo.mei_prog_id;
            p^.smethodinfo.mei_name      := oldMethodInfo.mei_name;
            p^.smethodinfo.mei_language  := a01_il_b_identifier;
            a10add_sysinfo (acv, p, e);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    e <> e_ok;
(*ENDREPEAT*) 
IF  e <> e_no_next_record
THEN
    a07_b_put_error (acv, e, 1)
ELSE
    a101_CatalogCollectUpgradeInfo ('UPGRADED DBPROC METHOD INFORMATION      ');
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361MigrateRefConstraints (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak361_MigrationGlob;
            VAR e           : tgg00_BasisError);
 
VAR
      indexFound     : boolean;
      updateRec      : boolean;
      set_result     : tgg00_BdSetResultRecord;
      tree_pos       : tgg00_FilePos;
      b              : tak361_Rec;
      pKey           : ^tgg00_Lkey;
      pos            : integer;
      ix             : integer;
      surrogate      : tgg00_Surrogate;
      pLink          : ^tak_linkrecord;
      index_scan_rec : tak_index_scan_record;
 
BEGIN
WITH set_result DO
    BEGIN
    bd_key_check_len := 0;
    bd_max_rec_cnt   := 1;
    bd_max_fill_len  := sizeof( b.rec.recBuf_gg00 );
    bd_next          := true;
    bd_drop_page     := false
    END;
(*ENDWITH*) 
pKey      := @b;
pKey^.len := 0;
pLink     := @b;
REPEAT
    tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
    b07cnext_record (acv.a_transinf.tri_trans, MGlob.refConstraint_tree,
          pKey^, set_result, tree_pos, b.rec.recBuf_gg00);
    e := acv.a_transinf.tri_trans.trError_gg00;
    IF  (e = e_ok) OR (e = e_key_not_found)
    THEN
        BEGIN
        e         := e_ok;
        updateRec := false;
        pos       := sizeof(tak_linkrecord) - sizeof(pLink^.linkdef) + 1;
        ix        := 0;
        WHILE (pos < pLink^.lreclen) AND (e = e_ok) DO
            BEGIN
            ix  := ix + 1;
            IF  (pLink^.linkdef[ix].lindexid[1] > chr(0)) AND
                (pLink^.linkdef[ix].lcolcount = 1)        AND
                (pLink^.linkdef[ix].lprimcolseq[1] <= 255)
            THEN
                BEGIN
                IF  pLink^.lentrytype = cak_eprimarykey
                THEN
                    surrogate := pLink^.lsurrogate
                ELSE
                    surrogate := pLink^.linkdef[ix].ltableid;
                (*ENDIF*) 
                indexFound := false;
                a24init_index_scan (acv, surrogate, index_scan_rec);
                WHILE NOT indexFound AND a24next_named_index (acv, index_scan_rec) DO
                    WITH index_scan_rec.isr_buf^.smindex.indexdef[index_scan_rec.isr_index] DO
                        BEGIN
                        IF  (icount = 1) AND
                            (icolseq[1] = pLink^.linkdef[ix].lprimcolseq[1])
                        THEN
                            BEGIN
&                           ifdef trace
                            t01int4 (td_always, 'new indexid ', indexno);
&                           endif
                            pLink^.linkdef[ix].lindexid[1] := chr(indexno);
                            indexFound := true;
                            updateRec  := true;
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
                (*ENDWHILE*) 
                a24finish_index_scan (acv, index_scan_rec);
                END;
            (*ENDIF*) 
            pos := pos +  sizeof(pLink^.linkdef[ix])
            END;
        (*ENDWHILE*) 
        IF  updateRec
        THEN
            ak361UpdateRecord (acv, @b, e);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    e <> e_ok;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361ReCreateViews (
            VAR acv        : tak_all_command_glob;
            VAR MGlob      : tak361_MigrationGlob);
 
VAR
      _e                   : tgg00_BasisError;
      _m_type              : tgg00_MessType;
      _compType            : tak_appl_type;
      _retCode             : integer;
      _tabcount            : tsp00_Int2;
      _recreated           : integer;
      _pos                 : integer;
      _move_len            : integer;
      _selectStart         : integer;    (* PTS 1123632 M.Ki.*)
      _sql_save            : tak_internal_sql_kind;
      _set_result          : tgg00_BdSetResultRecord;
      _tree_pos            : tgg00_FilePos;
      _b                   : tak361_Rec;
      create_or_replace    : tsp00_C20;
      _cre_or_repl_len     : integer;
      _cre_or_repl_save    : tsp00_C40;
      _drop_view           : tsp00_C20;
      _pKey                : ^tgg00_Lkey;
      _pSyskey             : ^tgg00_SysInfoKey;
      _user_info           : tak_user_info;
      _oldTabId            : tgg00_Surrogate;
      _ownerId             : tgg00_Surrogate;
      _schemaId            : tgg00_Surrogate;
      _pView               : tak_sysbufferaddress;
      _pViewtext           : ^tak_viewtextrecord;
      _part_ptr            : tsp1_part_ptr;
      _segm_ptr            : tsp1_segment_ptr;
      _mem_ptr             : tsp1_packet_ptr;
      _packet_ptr          : tsp1_packet_ptr;
      _cnt                 : tsp00_Int4;
      _size                : tsp00_Int4;
      _migrationId         : tsp00_C64;
      _msg                 : tsp00_C40;
      _pMsg                : ^tsp00_C40;
      _pUMsg               : ^tsp00_C80;
      _userInfo            : tak_user_info;
 
BEGIN
_msg := 'Migrating Views                         ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
      csp3_n_migration, _msg);
IF  NOT MGlob.viewsScanned
THEN
    ak361StoreCreateViewStatements (acv, MGlob);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    _recreated   := 0;
    _migrationId := c_migrationId;
    _packet_ptr     := acv.a_in_packet;
    _size           := g01packet_size;
    acv.a_in_packet := gg941Allocate(acv.a_transinf.tri_trans, _size);
    _mem_ptr        := acv.a_in_packet;
    IF  acv.a_in_packet = NIL
    THEN
        a07_b_put_error (acv, e_no_more_memory, 1)
    ELSE
        BEGIN
        _sql_save := acv.a_internal_sql;
        acv.a_in_packet^.sp1_header.sp1h_varpart_size :=
              _size - sizeof( acv.a_cmd_packet_header );
        s26init_cmd_packet( acv.a_in_packet, _segm_ptr );
        sp100_GetSenderIDVersionP( acv.a_cmd_packet_header.sp1h_appl_version );
        _segm_ptr^.sp1s_segm_header.sp1c_parsing_again := false;
        _segm_ptr^.sp1s_segm_header.sp1c_mess_type     := sp1m_dbs;
        _segm_ptr^.sp1s_segm_header.sp1c_producer      := sp1pr_installation;
        _segm_ptr^.sp1p_buf_size                       :=
              _size - sizeof (tsp1_segment_header);
        s26new_part_init (acv.a_in_packet, _segm_ptr^, _part_ptr);
        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
              csp3_n_migration, _msg);
        acv.a_cmd_part            := _part_ptr;
        _part_ptr^.sp1p_part_kind := sp1pk_command;
        _part_ptr^.sp1p_buf_len   := 0;
        acv.a_cmd_segm  := @acv.a_in_packet^.sp1_segm;
        _pViewtext      := @_b;
        _pKey           := @_b;
        _pSyskey        := @_b;
        _pKey^.len      := 0;
        WITH _set_result DO
            BEGIN
            bd_key_check_len := 0;
            bd_max_rec_cnt   := 1;
            bd_max_fill_len  := sizeof( _b.rec.recBuf_gg00 );
            bd_next          := true;
            bd_drop_page     := false
            END;
        (*ENDWITH*) 
        acv.a_curr_user_id := cgg_zero_id;
        _pView             := NIL;
        _cnt               := 0;
        REPEAT
            BEGIN
            _tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
            b07cnext_record( acv.a_transinf.tri_trans, MGlob.view_tree,
                  _pKey^, _set_result, _tree_pos, _b.rec.recBuf_gg00 );
            _e := acv.a_transinf.tri_trans.trError_gg00;
            IF  ( _e = e_ok ) OR ( _e = e_key_not_found )
            THEN
                BEGIN
                _e := e_ok;
                IF  _pViewtext^.vtsegno = cak_init_linkage
                THEN
                    BEGIN
                    IF  _pView <> NIL
                    THEN
                        BEGIN
                        a10rel_sysinfo( _pView );
                        a10repl_sysinfo( acv, _pView, _e );
                        _pView := NIL;
                        END;
                    (*ENDIF*) 
                    _oldTabId               := _pSyskey^.stableid;
                    _part_ptr^.sp1p_buf_len := 0;
                    IF  _pViewtext^.vtcontext >= 30
                    THEN
                        acv.a_sqlmode := sqlm_oracle
                    ELSE
                        IF  _pViewtext^.vtcontext >= 20
                        THEN
                            acv.a_sqlmode := sqlm_db2
                        ELSE
                            IF  _pViewtext^.vtcontext >= 10
                            THEN
                                acv.a_sqlmode := sqlm_ansi
                            ELSE
                                acv.a_sqlmode := sqlm_internal;
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    CASE _pViewtext^.vtcontext MOD 10 OF
                        0 :
                            acv.a_dt_format := dtf_none;
                        1 :
                            acv.a_dt_format := dtf_normal;
                        2 :
                            acv.a_dt_format := dtf_iso;
                        3 :
                            acv.a_dt_format := dtf_usa;
                        4 :
                            acv.a_dt_format := dtf_eur;
                        5 :
                            acv.a_dt_format := dtf_jis;
                        6 :
                            acv.a_dt_format := dtf_oracle_date;
                        7 :
                            (* PTS 1112472 E.Z. *)
                            acv.a_dt_format := dtf_iso;
                        8 :
                            acv.a_dt_format := dtf_ts_eur;
                        9 :
                            acv.a_dt_format := dtf_future;
                        END;
                    (*ENDCASE*) 
                    _ownerId  := _pViewtext^.vttab[ 1 ].vtttableid;
                    _schemaId := _pViewtext^.vttab[ 1 ].vttreftabid;
                    a06determine_username( acv, _ownerId, acv.a_curr_user_name );
                    a362SetUserAndSchema (acv, acv.a_curr_user_name, _ownerId, _schemaId, _userInfo);
                    END;
                (*ENDIF*) 
                _tabcount := _pViewtext^.vttabcount;
                _pos := sizeof( _pViewtext^ ) -
                      sizeof( _pViewtext^.vttbuf ) +
                      _tabcount * sizeof( _pViewtext^.vttab[1] ) + 1;
                _move_len := _pViewtext^.vtreclen - _pos + 1;
                IF  _pViewtext^.vtsegno = cak_init_linkage
                THEN
                    BEGIN
                    IF  g01unicode (* PTS 1123632 M.Ki. *)
                    THEN
                        BEGIN
                        _pos      := _pos + 12; (* remove keyword SELECT *)
                        _move_len := _move_len - 12;
                        END
                    ELSE
                        BEGIN
                        (* for ASCII there used to be a problem determining   *)
                        (* whitespaces, so the statement does not necessarily *)
                        (* start at the buffer's beginning                    *)
                        _selectStart := 0;
                        WHILE (_b.rec.recBuf_gg00[ _pos + _selectStart ] in
                              ['\09','\20','\0A']) DO
                            (* skip whitespaces at beginning of statement *)
                            _selectStart := succ (_selectStart);
                        (*ENDWHILE*) 
                        _pos      := _pos + 6 + _selectStart; (* remove keyword SELECT *)
                        _move_len := _move_len - 6 - _selectStart;
                        END;
                    (*ENDIF*) 
                    create_or_replace := 'CREATE OR REPLACE   ';
                    SAPDB_PascalForcedMove (sizeof(create_or_replace), _part_ptr^.sp1p_buf_size,
                          @create_or_replace, 1, @_part_ptr^.sp1p_buf, _part_ptr^.sp1p_buf_len + 1,
                          sizeof(create_or_replace));
                    _part_ptr^.sp1p_buf_len :=
                          _part_ptr^.sp1p_buf_len + sizeof(create_or_replace);
                    ak361StatementToUnicode ( acv ); (* PTS 1123632 M.Ki. *)
                    _cre_or_repl_len := _part_ptr^.sp1p_buf_len;
                    SAPDB_PascalForcedMove (_part_ptr^.sp1p_buf_size, sizeof (_cre_or_repl_save),
                          @_part_ptr^.sp1p_buf, 1, @_cre_or_repl_save, 1, _cre_or_repl_len);
                    END;
                (*ENDIF*) 
                IF  _part_ptr^.sp1p_buf_len + _move_len <=
                    _part_ptr^.sp1p_buf_size (* PTS 1123632 M.Ki. *)
                THEN
                    BEGIN
                    SAPDB_PascalMove('VAK361',   3,    
                          sizeof( _b.rec.recBuf_gg00 ), _part_ptr^.sp1p_buf_size,
                          @_b.rec.recBuf_gg00, _pos, @_part_ptr^.sp1p_buf,
                          _part_ptr^.sp1p_buf_len + 1,
                          _move_len, _e );
                    _part_ptr^.sp1p_buf_len := _part_ptr^.sp1p_buf_len +
                          _move_len;
                    END
                ELSE
                    _e := e_too_small_packet_size;
                (*ENDIF*) 
                IF  (NOT  _pViewtext^.vtnextexist) AND (_e = e_ok)
                THEN
                    BEGIN
                    s26finish_part( acv.a_in_packet, _part_ptr^ );
                    a10_cache_delete( acv, NOT c_is_rollback );
                    a52new_subtrans( acv, a01_il_b_identifier );
                    acv.a_internal_sql := sql_restore_schema; (* PTS 1117920 M.Ki. *)
                    acv.a_p_arr1.pcount := -1;
                    a35_asql_statement( acv );
                    IF  (acv.a_returncode <> 0) AND (acv.a_p_arr1.pcount = -1)
                    THEN
                        BEGIN
                        (* if a_p_arr1.pcount ist still -1, a syntax error must have been occurred. Try with odbc syntax *)
                        acv.a_returncode := 0;
                        SAPDB_PascalForcedMove (sizeof (_cre_or_repl_save), _part_ptr^.sp1p_buf_size,
                              @_cre_or_repl_save, 1, @_part_ptr^.sp1p_buf, 1, _cre_or_repl_len);
                        _compType        := acv.a_comp_type;
                        acv.a_comp_type  := at_odbc;
                        a35_asql_statement( acv );
                        acv.a_comp_type := _compType;
                        END;
                    (*ENDIF*) 
                    _cnt := _cnt + 1;
                    _retCode := acv.a_returncode;
                    _pos     := acv.a_errorpos;
                    IF  _retCode = 0
                    THEN
                        BEGIN
                        _recreated := _recreated + 1;
                        _m_type    := m_end;
                        END
                    ELSE
                        _m_type := m_rollback;
                    (*ENDIF*) 
                    acv.a_returncode := 0;
                    a52end_rollback_subtrans( acv, a01_il_b_identifier,
                          _m_type );
                    a542reset_packet (acv);
                    IF  _retCode <> 0
                    THEN
                        BEGIN
                        (* PTS 1129464 M.Ki. *)
                        IF  g01unicode
                        THEN
                            _move_len := s30unilnr (
                                  @acv.a_curr_user_name,
                                  csp_unicode_blank, 1,
                                  sizeof (acv.a_curr_user_name))
                        ELSE
                            _move_len := s30lnr (acv.a_curr_user_name,
                                  csp_ascii_blank, 1,
                                  sizeof (acv.a_curr_user_name));
                        (*ENDIF*) 
                        a361WriteProt (acv, MGlob.prot_tree, _migrationId,
                              c_migrationIdLength, acv.a_curr_user_name, _move_len,
                              acv.a_curr_user_name, _move_len,
                              g01unicode, _retCode, _pos);
                        _pSyskey^.sentrytyp[ 1 ] := chr( 255 ); (* skip all of this view *)
                        (*---------------------------------------------------*)
                        (* try to drop the view now                          *)
                        (*---------------------------------------------------*)
                        _part_ptr^.sp1p_buf_len := 0;
                        _drop_view := 'DROP VIEW          "';
                        SAPDB_PascalForcedMove (sizeof(_drop_view), _part_ptr^.sp1p_buf_size,
                              @_drop_view, 1, @_part_ptr^.sp1p_buf, _part_ptr^.sp1p_buf_len + 1,
                              sizeof(_drop_view));
                        _part_ptr^.sp1p_buf_len :=
                              _part_ptr^.sp1p_buf_len + sizeof(_drop_view);
                        ak361StatementToUnicode ( acv ); (* PTS 1123632 M.Ki. *)
                        SAPDB_PascalMove ('VAK361',   4,    
                              sizeof(acv.a_viewname), _part_ptr^.sp1p_buf_size,
                              @acv.a_viewname, 1, @_part_ptr^.sp1p_buf, _part_ptr^.sp1p_buf_len + 1,
                              sizeof(acv.a_viewname),  acv.a_returncode);
                        IF  g01unicode
                        THEN
                            BEGIN
                            _part_ptr^.sp1p_buf_len :=
                                  _part_ptr^.sp1p_buf_len
                                  + s30unilnr (@acv.a_viewname,
                                  csp_unicode_blank, 1,
                                  sizeof (acv.a_viewname))
                                  + 2;
                            _part_ptr^.sp1p_buf [_part_ptr^.sp1p_buf_len-1] := '\00';
                            _part_ptr^.sp1p_buf [_part_ptr^.sp1p_buf_len  ] := '"';
                            END
                        ELSE
                            BEGIN
                            _part_ptr^.sp1p_buf_len :=
                                  _part_ptr^.sp1p_buf_len
                                  + s30lnr (acv.a_viewname,
                                  csp_ascii_blank, 1,
                                  sizeof (acv.a_viewname))
                                  + 1;
                            _part_ptr^.sp1p_buf [_part_ptr^.sp1p_buf_len] := '"';
                            END;
                        (*ENDIF*) 
                        s26finish_part( acv.a_in_packet, _part_ptr^ );
                        a52new_subtrans( acv, a01_il_b_identifier );
                        acv.a_internal_sql   := sql_restore_schema; (* PTS 1117920 M.Ki. *)
                        acv.a_in_ddl_trigger := true;
                        a35_asql_statement( acv );
                        acv.a_in_ddl_trigger := false;
                        _retCode := acv.a_returncode;
                        IF  (_retCode = 0) OR (_retCode = -4004) OR (_retCode = -942)
                        THEN
                            BEGIN
                            _msg    := 'dropped view                            ';
                            _m_type := m_end
                            END
                        ELSE
                            BEGIN
                            _msg    := 'could not drop view :                   ';
                            g17int4to_line (_retCode, false, 5, 22, _msg);
                            _m_type := m_rollback;
                            END;
                        (*ENDIF*) 
                        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
                              csp3_n_migration, _msg);
                        IF  g01unicode (* PTS 1123632 M.Ki. *)
                        THEN
                            BEGIN
                            _pUMsg := @acv.a_viewname;
                            g01unioptextmsg (csp_unicode,
                                  sp3p_console, sp3m_info,
                                  csp3_a361_no_direct_migration,
                                  csp3_n_migration, _pUMsg^);
                            END
                        ELSE
                            BEGIN
                            _pMsg := @acv.a_viewname;
                            g01optextmsg (sp3p_console, sp3m_info,
                                  csp3_a361_no_direct_migration,
                                  csp3_n_migration, _pMsg^);
                            END;
                        (*ENDIF*) 
                        acv.a_returncode := 0;
                        a52end_rollback_subtrans( acv, a01_il_b_identifier,
                              _m_type );
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        UNTIL
            ( _e <> e_ok ) OR ( acv.a_returncode <> 0 );
        (*ENDREPEAT*) 
        _msg    := 'recreated views :                       ';
        g17int4to_line (_recreated, false, 5, 19, _msg);
        g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration, csp3_n_migration, _msg);
        IF  _e <> e_no_next_record
        THEN
            a07_b_put_error (acv, _e, 1)
        ELSE
            IF  _pView <> NIL
            THEN
                BEGIN
                a10rel_sysinfo( _pView );
                a10repl_sysinfo( acv, _pView, _e );
                IF  _e <> e_ok
                THEN
                    a07_b_put_error (acv, _e, 1);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        acv.a_internal_sql := _sql_save;
        gg941Deallocate(acv.a_transinf.tri_trans, _mem_ptr);
        END;
    (*ENDIF*) 
    acv.a_in_packet := _packet_ptr;
    IF  acv.a_in_packet <> NIL
    THEN
        acv.a_cmd_segm  := @acv.a_in_packet^.sp1_segm
    ELSE
        acv.a_cmd_segm := NIL;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361SingleIndexRecord (
            VAR acv     : tak_all_command_glob;
            oldIndexRec : tak_sysbufferaddress;
            VAR e       : tgg00_BasisError);
 
BEGIN
a10del_sysinfo (acv, oldIndexRec^.syskey, e)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361StoreCreateViewStatements (
            VAR acv         : tak_all_command_glob;
            VAR MGlob       : tak361_MigrationGlob);
 
VAR
      e     : tgg00_BasisError;
      pBase : tak_sysbufferaddress;
      msg   : tsp00_C40;
      sysk  : tgg00_SysInfoKey;
 
BEGIN
msg := 'Storing view definition strings         ';
g01optextmsg (sp3p_console, sp3m_info, csp3_a361_no_direct_migration,
      csp3_n_migration, msg);
sysk := a01defaultkey;
REPEAT
    a10next_sysinfo (acv, sysk, 0, d_release, cak_etable, pBase, e);
    IF  e = e_ok
    THEN
        IF  pBase^.sbase.btablekind in [tonebase, tview, tcomplexview]
        THEN
            BEGIN
            IF  (ftsTemp_egg00 in pBase^.sbase.btreeid.fileType_gg00             ) AND
                (pBase^.sbase.btreeid.fileName_gg00 = b01niltree_id.fileName_gg00)
            THEN
                pBase^.sbase.btreeid := b01niltree_id;
            (*ENDIF*) 
            ak361StoreCreateViewStmt (acv, MGlob, sysk,
                  pBase^.sbase.bauthid, pBase^.sbase.bschemacontext, e);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    sysk.sentrytyp := cak_esysfile2;
UNTIL
    (e <> e_ok) OR (acv.a_returncode <> 0);
(*ENDREPEAT*) 
IF  e <> e_no_next_record
THEN
    a07_b_put_error (acv, e, 1)
ELSE
    MGlob.viewsScanned := true
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361StoreCreateViewStmt (
            VAR acv           : tak_all_command_glob;
            VAR MGlob         : tak361_MigrationGlob;
            Syskey            : tgg00_SysInfoKey; (* must not be VAR !! *)
            VAR ownerId       : tgg00_Surrogate;
            VAR schemaContext : tgg00_Surrogate;
            VAR e             : tgg00_BasisError);
 
VAR
      next_exist   : boolean;
      b            : tak361_Rec;
      pViewText    : ^tak_viewtextrecord;
      sys1_cat     : tgg00_FileId;
 
BEGIN
pViewText        := @b;
Syskey.sentrytyp := cak_eviewtext;
REPEAT
&   ifdef trace
    b06check_rec := false;
&   endif
    kb560GetSys1CatalogTreeId (sys1_cat);
    b02get_record( acv.a_transinf.tri_trans, sys1_cat, Syskey, b.rec );
&   ifdef trace
    b06check_rec := true;
&   endif
    e := acv.a_transinf.tri_trans.trError_gg00;
    IF  e = e_ok
    THEN
        BEGIN
        next_exist := pViewText^.vtnextexist;
        IF  Syskey.slinkage = cak_init_linkage
        THEN
            BEGIN
            pViewText^.vttab[ 1 ]. vtttableid := ownerId;
            pViewText^.vttab[ 1 ].vttreftabid := schemaContext;
            END;
        (*ENDIF*) 
        b07cadd_record ( acv.a_transinf.tri_trans, MGlob.view_tree, b.rec );
        e := acv.a_transinf.tri_trans.trError_gg00;
        a06inc_linkage( Syskey.slinkage );
        END
    ELSE
        IF  (e = e_key_not_found) AND (Syskey.slinkage = cak_init_linkage)
        THEN
            BEGIN (* PTS 1137274, ignore views without viewtext definition *)
            e              := e_ok;
            next_exist     := false;
            MGlob.cntViews := MGlob.cntViews - 1;
            END;
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    NOT next_exist OR ( e <> e_ok );
(*ENDREPEAT*) 
MGlob.cntViews := MGlob.cntViews + 1;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361SysdbaRecord (
            VAR acv      : tak_all_command_glob;
            VAR Syskey   : tgg00_SysInfoKey;
            oldSysdbaRec : tak_sysbufferaddress;
            VAR e        : tgg00_BasisError);
 
VAR
      sysbuf : tak_sysbufferaddress;
 
BEGIN
a10_nil_get_sysinfo (acv, Syskey, d_release, sizeof (tak_sysdbarecord), sysbuf, e);
IF  e = e_ok
THEN
    BEGIN
    sysbuf^.ssysdba.syssegmentid := cak00_local_segment_id;
    sysbuf^.ssysdba.sysactivated := oldSysdbaRec^.ssysdba.sysactivated;
    sysbuf^.ssysdba.sysversion   := cak_sysdba_version;
    sysbuf^.ssysdba.sysauthid    := oldSysdbaRec^.ssysdba.sysauthid
    END;
(*ENDIF*) 
IF  e = e_ok
THEN
    a10repl_sysinfo (acv, sysbuf, e)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361Messblock (
            VAR acv          : tak_all_command_glob;
            VAR catalog_tree : tgg00_FileId;
            VAR Syskey       : tgg00_SysInfoKey;
            oldMessblock     : tak_sysbufferaddress;
            VAR e            : tgg00_BasisError);
 
TYPE
 
      tak361_73MessBufHeader = RECORD
            mb_qual_len   : tsp00_Int4;
            mb_data_len   : tsp00_Int4;
            (* *)
            mb_src_site   : tgg00_ServerdbNo;
            mb_reply      : boolean;
            mb_fill3      : boolean;
            mb_type       : tgg00_MessType;
            mb_type2      : tgg00_MessType2;
            mb_struct     : tgg00_MessBufStruct;
            mb_fill1      : boolean;
      END;
 
 
VAR
      messblock : tak_messblock_record;
      mess73    : ^tak361_73MessBufHeader;
      (* PTS 1117920 M.Ki. *)
 
BEGIN
IF  Syskey.skeylen = mxak_standard_sysk
THEN
    BEGIN
    mess73 := @oldMessblock^.smessblock.mbr_mess_block;
    messblock.mbr_keylen        := oldMessblock^.smessblock.mbr_keylen;
    messblock.mbr_varcol_offset := oldMessblock^.smessblock.mbr_varcol_offset;
    messblock.mbr_varcol_cnt    := oldMessblock^.smessblock.mbr_varcol_cnt;
    messblock.mbr_surrogate     := oldMessblock^.smessblock.mbr_surrogate;
    messblock.mbr_entrytype     := oldMessblock^.smessblock.mbr_entrytype;
    messblock.mbr_linkage       := oldMessblock^.smessblock.mbr_linkage;
    messblock.mbr_segment_id    := oldMessblock^.smessblock.mbr_segment_id;
    messblock.mbr_stack_len     := oldMessblock^.smessblock.mbr_stack_len;
    messblock.mbr_fieldSequenceInfo        := [];
    messblock.mbr_recCount                 := chr(0);
    messblock.mbr_mess_block.mb_qual_len   := mess73^.mb_qual_len;
    messblock.mbr_mess_block.mb_data_len   := mess73^.mb_data_len;
    messblock.mbr_mess_block.mb_strat_len  := 0;
    messblock.mbr_mess_block.mb_fill2      := 0;
    messblock.mbr_mess_block.mb_src_site   := mess73^.mb_src_site;
    messblock.mbr_mess_block.mb_type       := mess73^.mb_type;
    messblock.mbr_mess_block.mb_type2      := mess73^.mb_type2;
    messblock.mbr_mess_block.mb_struct     := mess73^.mb_struct;
    messblock.mbr_mess_block.mb_reply      := mess73^.mb_reply;
    messblock.mbr_mess_block.mb_fill1      := false;
    (* record grows by 2*sizeof(tsp00_Int4) *)
    messblock.mbr_reclen := oldMessblock^.smessblock.mbr_reclen
          + 2*sizeof(tsp00_Int4);
    a06a_mblock_init (acv, m_update_rec, mm_nil, catalog_tree );
    SAPDB_PascalMove('VAK361',   5,    
          sizeof (tak_messblock_record), acv.a_mblock.mb_data_size,
          @messblock, 1,
          @acv.a_mblock.mb_data^.mbp_buf, 1,
          messblock.mbr_reclen,
          e);
    acv.a_mblock.mb_data_len := messblock.mbr_reclen;
    a06lsend_mess_buf(acv, acv.a_mblock, NOT c_call_from_rsend, e);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361TableRecord (
            VAR acv           : tak_all_command_glob;
            VAR MGlob         : tak361_MigrationGlob;
            VAR Syskey        : tgg00_SysInfoKey;
            schemaMigration   : boolean;
            VAR e             : tgg00_BasisError);
 
CONST
      cak72_max_sindex_colno = 255;
 
VAR
      indexnoset             : SET OF 1..MAX_INV_PER_TAB_GG00;
      unnamedIndexedColumns  : tak_columnset;
      nullableIndexedColumns : tak_columnset; (* PTS 1118568 *)
      checkIndexes           : boolean;
      updIndexRec            : boolean;
      indexExist             : boolean;
      newindexno             : tsp00_Int2;
      ix                     : integer;
      colno                  : integer;
      colptr                 : tak00_colinfo_ptr;
      pBase                  : tak_sysbufferaddress;
      index_scan_rec         : tak_index_scan_record;
      pTable                 : ^tak_baserecord;
      opType                 : ARRAY[1..cak72_max_sindex_colno] OF tgg00_StackOpType;
 
BEGIN
a10get_sysinfo (acv, Syskey, d_fix, pBase, e);
IF  e = e_ok
THEN
    BEGIN
    unnamedIndexedColumns  := [];
    nullableIndexedColumns := []; (* PTS 1118568 *)
    checkIndexes           := false;
    pTable                 := @pBase^.sbase;
    indexExist             := false; (* PTS 1112699 *)
    IF  pTable^.btablekind in [twithkey, twithoutkey]
    THEN
        BEGIN
        indexExist := pTable^.bindexexist; (* PTS 1112699 *)
        FOR ix := pTable^.bfirstindex TO pTable^.blastindex DO
            BEGIN
            IF  ctunused in pTable^.bcolumn[ix]^.ccolpropset
            THEN
                BEGIN
                checkIndexes          := true;
                IF  pTable^.bcolumn[ix]^.creccolno <= cak72_max_sindex_colno
                THEN
                    BEGIN
                    unnamedIndexedColumns := unnamedIndexedColumns +
                          [pTable^.bcolumn[ix]^.creccolno];
                    IF  ctopt in pTable^.bcolumn[ix]^.ccolpropset (* PTS 1118568 *)
                    THEN
                        nullableIndexedColumns := nullableIndexedColumns +
                              [pTable^.bcolumn[ix]^.creccolno];
                    (*ENDIF*) 
                    opType[pTable^.bcolumn[ix]^.creccolno] := pTable^.bcolumn[ix]^.ccolstack.eop;
                    pTable^.bindexexist := true
                    END;
                (*ENDIF*) 
                pTable^.bcolumn[ix]^.ccolpropset :=
                      pTable^.bcolumn[ix]^.ccolpropset - [ctunused] + [ctmulti];
                IF  pTable^.bcolumn[ix]^.ccolstack.eop in
                    [op_unique, op_unique_desc, op_order_desc, op_order_asc]
                THEN
                    pTable^.bcolumn[ix]^.ccolstack.eop := op_none;
                (*ENDIF*) 
                pTable^.bcolumn[ix]^.ccolstack.ecol_tab[1] := chr(0);
                END;
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        IF  checkIndexes OR schemaMigration
        THEN
            a10repl_sysinfo( acv, pBase, e)
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  (pTable^.btablekind <> tsynonym) AND
            (pTable^.btablekind <> tempty  )
        THEN
            BEGIN
            IF  (ftsTemp_egg00 in pTable^.btreeid.fileType_gg00             ) AND
                (pTable^.btreeid.fileName_gg00 = b01niltree_id.fileName_gg00)
            THEN
                pTable^.btreeid := b01niltree_id;
            (*ENDIF*) 
            ak361StoreCreateViewStmt (acv, MGlob, Syskey, pTable^.bauthid, pTable^.bauthid, e);
            IF  (e = e_ok) AND schemaMigration
            THEN
                a10repl_sysinfo( acv, pBase, e);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  checkIndexes AND pTable^.bindexexist AND (e = e_ok)
    THEN
        BEGIN
        indexnoset := [];
        IF  indexExist
        THEN
            BEGIN
            a24init_index_scan (acv, pTable^.bsurrogate, index_scan_rec);
            WHILE a24next_named_index (acv, index_scan_rec) DO
                WITH index_scan_rec.isr_buf^.smindex.indexdef[index_scan_rec.isr_index] DO
                    BEGIN
                    IF  icount > 1
                    THEN
                        BEGIN
                        indexnoset := indexnoset + [indexno];
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDWHILE*) 
            a24finish_index_scan (acv, index_scan_rec);
            a24init_index_scan (acv, pTable^.bsurrogate, index_scan_rec);
            WHILE a24next_named_index (acv, index_scan_rec) AND (e = e_ok) DO
                WITH index_scan_rec.isr_buf^.smindex.indexdef[index_scan_rec.isr_index] DO
                    BEGIN
                    IF  index_scan_rec.isr_index = 1
                    THEN
                        updIndexRec := false;
                    (*ENDIF*) 
                    IF  (icount = 1) AND (icolseq[1] <= cak72_max_sindex_colno)
                    THEN
                        BEGIN
                        unnamedIndexedColumns := unnamedIndexedColumns -
                              [icolseq[1]];
                        updIndexRec    := true;
                        indexno        := -1;
                        ix             := 1;
                        (* PTS 1124454 E.Z. *)
                        WHILE (ix <= MAX_INV_PER_TAB_GG00) AND (indexno < 0) DO
                            BEGIN
                            IF  ix in indexnoset
                            THEN
                                ix := ix + 1
                            ELSE
                                indexno := ix;
                            (*ENDIF*) 
                            END;
                        (*ENDWHILE*) 
                        indexnoset := indexnoset + [indexno];
                        (* PTS 1135326 M.Ki. *)
                        ak361MigSingleIndexFDirEntry (acv, pTable^.btreeid,
                              icolseq[1], indexno,
                              (icolseq[1] in nullableIndexedColumns));
                        IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                        THEN
                            a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1)
                                  (* PTS 1118230 E.Z. *)
                        ELSE
                            icolstack[1].ecol_tab[1] := chr (indexno);
                        (*ENDIF*) 
                        nullableIndexedColumns := nullableIndexedColumns - [icolseq[1]];
                        END;
                    (*ENDIF*) 
                    IF  updIndexRec
                        AND
                        ((index_scan_rec.isr_index = cak_max_index_per_rec)
                        OR
                        ((index_scan_rec.isr_index = index_scan_rec.isr_buf^.smindex.indexcount) AND
                        ( index_scan_rec.isr_buf^.smindex.indexcount < cak_max_index_per_rec)))
                    THEN
                        BEGIN
                        a10repl_sysinfo( acv, index_scan_rec.isr_buf, e );
                        updIndexRec := false
                        END
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDWHILE*) 
            a24finish_index_scan (acv, index_scan_rec);
            END;
        (*ENDIF*) 
        IF  unnamedIndexedColumns <> []
        THEN
            BEGIN
            (* PTS 1135326 M.Ki. *)
            colno := 1;
            WHILE (colno <= cak72_max_sindex_colno) AND (e = e_ok) DO
                BEGIN
                IF  colno in unnamedIndexedColumns
                THEN
                    BEGIN
                    a06extcolno (pTable^, colno, colptr);
                    a24MigrateUnnamedIndex (acv, pBase, opType[colno],
                          colptr, newindexno);
                    ak361MigSingleIndexFDirEntry (acv, pTable^.btreeid,
                          colno, newindexno,
                          (colno in nullableIndexedColumns));
                    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                    THEN
                        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
                    (*ENDIF*) 
                    nullableIndexedColumns := nullableIndexedColumns - [colno];
                    END;
                (*ENDIF*) 
                colno := colno + 1;
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    a10key_del(acv, pBase);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361ContainerRecord (VAR acv : tak_all_command_glob;
            VAR Syskey  : tgg00_SysInfoKey;
            VAR e       : tgg00_BasisError);
 
VAR
      pContainer : tak_sysbufferaddress;
 
BEGIN
a10get_sysinfo (acv, Syskey, d_release, pContainer, e);
IF  e = e_ok
THEN
    IF  pContainer^.sclass.findexexist
    THEN
        IF  pContainer^.sclass.ftree.fileNumObjKeyFiles_gg00 = 0
        THEN
            BEGIN
            pContainer^.sclass.ftree.fileNumObjKeyFiles_gg00 := 1;
            a10repl_sysinfo (acv, pContainer, e);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361TempStoreRecord (
            VAR acv  : tak_all_command_glob;
            VAR tree : tgg00_FileId;
            sysbuf   : tak_sysbufferaddress;
            VAR e    : tgg00_BasisError);
 
VAR
      pRecBuf : ^tgg00_Rec;
 
BEGIN
pRecBuf := @sysbuf^;
b07cadd_record (acv.a_transinf.tri_trans, tree, pRecBuf^);
e := acv.a_transinf.tri_trans.trError_gg00;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361MigSingleIndexFDirEntry (
            VAR acv           : tak_all_command_glob;
            VAR tableId       : tgg00_FileId;
            oldSingleIdxNo    : tsp00_Int2;
            newMultIdxNo      : tsp00_Int2;
            bSetNotAccessible : boolean);
 
VAR
      newIndexId : tgg00_FileId;
 
BEGIN
(* PTS 1135326 M.Ki. *)
bd998MigSwitchSingleIndexToMulti(
      acv.a_transinf.tri_trans,
      tableId.fileTabId_gg00,
      oldSingleIdxNo,
      newMultIdxNo);
g04index_tree_build (
      tableId,
      newIndexId,
      newMultIdxNo);
&ifdef trace
t01treeid (ak_sem, 'table fileid', tableId);
t01treeid (ak_sem, 'index fileid', newIndexId);
&endif
IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
THEN
    IF  acv.a_transinf.tri_trans.trError_gg00 = e_file_not_found
    THEN
        BEGIN
        k33build_new_index_id (tableId, newMultIdxNo, newIndexId);
        kb641CreateIndexFile (acv.a_transinf.tri_trans,
              tableId, newIndexId, newMultIdxNo);
        IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
        THEN
            bSetNotAccessible := true;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  bSetNotAccessible
THEN
    bd03SetToNotAccessible(acv.a_transinf.tri_trans, newIndexId);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361UpdateRecord (
            VAR acv      : tak_all_command_glob;
            oldRec       : tak_sysbufferaddress;
            VAR e        : tgg00_BasisError);
 
VAR
      pRec   : ^tgg00_Rec;
      auxC2  : tsp00_C2;
      mblock : tgg00_MessBlock;
      qual   : tgg00_Rec;
      stack  : ARRAY[0..1] OF tgg00_StackEntry;
 
BEGIN
pRec  := @oldRec^;
auxC2 := cak00_local_segment_id;
pRec^.recBody_gg00[pRec^.recKeyLen_gg00 + 1] := auxC2[1];
pRec^.recBody_gg00[pRec^.recKeyLen_gg00 + 2] := auxC2[2];
g01mblock_init( acv.a_transinf.tri_trans, m_update_rec, mm_nil, mblock );
g01stack_init( mblock, @stack, sizeof( stack ), @qual, sizeof( qual ) );
mblock.mb_data      := @pRec^;
mblock.mb_data_size := pRec^.recLen_gg00;
mblock.mb_data_len  := pRec^.recLen_gg00;
IF  oldRec^.syskey.sentrytyp < cak_esysfile2
THEN
    kb560GetSys1CatalogTreeId (mblock.mb_qual^.mtree)
ELSE
    kb560GetSys2CatalogTreeId (mblock.mb_qual^.mtree);
(*ENDIF*) 
a06lsend_mess_buf  (acv, mblock, NOT c_call_from_rsend, e)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a361WriteProt (
            VAR acv           : tak_all_command_glob;
            VAR prot_tree     : tgg00_FileId;
            VAR migrationId   : tsp00_C64;
            migIdLength       : integer;
            VAR schema        : tsp00_C64;
            schemaLength      : integer;
            VAR owner         : tsp00_C64;
            ownerLength       : integer;
            unicodeText       : boolean;
            errCode           : integer;
            errPos            : integer);
 
BEGIN
ak361WriteProt (acv, prot_tree, migrationId, migIdLength, schema, schemaLength,
      owner, ownerLength, unicodeText,
      acv.a_cmd_part^.sp1p_buf, acv.a_cmd_part^.sp1p_buf_len, errCode, errPos);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361WriteProt (
            VAR acv           : tak_all_command_glob;
            VAR prot_tree     : tgg00_FileId;
            VAR migrationId   : tsp00_C64;
            migIdLength       : integer;
            VAR schema        : tsp00_C64;
            schemaLength      : integer;
            VAR owner         : tsp00_C64;
            ownerLength       : integer;
            unicodeText       : boolean;
            VAR LongInfo      : tsp00_MoveObj;
            LongSize          : tsp00_Int4;
            errCode           : integer;
            errPos            : integer);
 
VAR
      _e           : tgg00_BasisError;
      _res         : tsp00_NumError;
      _pos         : integer;
      _digits      : integer;
      _intInOutLen : integer;
      _timeStamp   : tsp00_Timestamp;
      _longSurrogate : tgg00_Surrogate;
 
BEGIN
&ifdef trace
t01moveobj (ak_sem, LongInfo, 1, LongSize);
&endif
(* PTS 1129464 M.Ki. *)
IF  prot_tree.fileName_gg00 <> cgg_zero_fn
THEN
    BEGIN
    _digits      := 10;
    _intInOutLen := ( _digits + 1 ) DIV 2 + 2;
    a06a_mblock_init( acv, m_insert, mm_nokey, prot_tree );
    acv.a_mblock.mb_data^.mbp_rec.recLen_gg00          :=
          cgg_rec_key_offset + 1 + sizeof(tgg00_Surrogate) (* header + syskey *)
          + sizeof(_longSurrogate) + 1 (* STATMENT            *)
          + sizeof(_timeStamp) + 1     (* TS                  *)
          + 2 * _intInOutLen           (* ERROR_NO, ERROR_POS *)
          + migIdLength + 2            (* MIGRATION_TYPE      *)
          + schemaLength + 2           (* SCHEMA              *)
          + ownerLength + 2;           (* OWNER               *)
    acv.a_mblock.mb_data^.mbp_rec.recKeyLen_gg00       := 1 + sizeof( tgg00_Surrogate );
    acv.a_mblock.mb_data^.mbp_rec.recVarcolOffset_gg00 :=
          sizeof(_longSurrogate) + 1
          + sizeof(_timeStamp) + 1
          + 2 * _intInOutLen;
    acv.a_mblock.mb_data^.mbp_rec.recVarcolCnt_gg00    := 3;
    _pos := cgg_rec_key_offset + 1 + sizeof( tgg00_Surrogate ) + 1;
    (* PTS 1129464 M.Ki. *)
    (* store statement text *)
    acv.a_mblock.mb_data^.mbp_buf[ _pos ] := csp_defined_byte;
    ak361StoreCreateStatement (acv, prot_tree.fileTabId_gg00, _longSurrogate, LongInfo, LongSize);
    SAPDB_PascalMove('VAK361',   6,    
          sizeof(_longSurrogate), acv.a_mblock.mb_data_size,
          @_longSurrogate, 1, @acv.a_mblock.mb_data^.mbp_buf, _pos + 1,
          sizeof(_longSurrogate), acv.a_returncode );
    _pos := _pos + sizeof(_longSurrogate) + 1;
    (* PTS 1128229 M.Ki. *)
    (* fill in timestamp *)
    vtimestamp(_timeStamp);
    acv.a_mblock.mb_data^.mbp_buf[ _pos ] := csp_ascii_blank;
    SAPDB_PascalMove('VAK361',   7,    
          sizeof(_timeStamp), acv.a_mblock.mb_data_size,
          @_timeStamp, 1, @acv.a_mblock.mb_data^.mbp_buf, _pos + 1,
          sizeof(_timeStamp), acv.a_returncode );
    _pos := _pos + sizeof(_timeStamp) + 1;
    (* fill in error code *)
    acv.a_mblock.mb_data^.mbp_buf[ _pos ] := csp_defined_byte;
    s41plint( acv.a_mblock.mb_data^.mbp_buf, _pos + 1, _digits, 0, errCode, _res );
    _pos := _pos + _intInOutLen;
    (* fill in error pos *)
    acv.a_mblock.mb_data^.mbp_buf[ _pos ] := csp_defined_byte;
    s41plint( acv.a_mblock.mb_data^.mbp_buf, _pos + 1, _digits, 0, errPos, _res );
    _pos := _pos + _intInOutLen;
    (* fill in migrationId *)
    acv.a_mblock.mb_data^.mbp_buf[ _pos     ] := chr (migIdLength + 1);
    acv.a_mblock.mb_data^.mbp_buf[ _pos + 1 ] := csp_ascii_blank;
    SAPDB_PascalMove('VAK361',   8,    
          migIdLength, acv.a_mblock.mb_data_size,
          @migrationId, 1, @acv.a_mblock.mb_data^.mbp_buf, _pos + 2,
          migIdLength, acv.a_returncode );
    _pos := _pos + migIdLength + 2;
    (* fill in schema *)
    acv.a_mblock.mb_data^.mbp_buf[ _pos     ] := chr (schemaLength + 1);
    IF  unicodeText
    THEN
        acv.a_mblock.mb_data^.mbp_buf[ _pos + 1 ] := csp_unicode_def_byte
    ELSE
        acv.a_mblock.mb_data^.mbp_buf[ _pos + 1 ] := csp_ascii_blank;
    (*ENDIF*) 
    SAPDB_PascalMove('VAK361',   9,    
          schemaLength, acv.a_mblock.mb_data_size,
          @schema, 1, @acv.a_mblock.mb_data^.mbp_buf, _pos + 2,
          schemaLength, acv.a_returncode );
    _pos := _pos + schemaLength + 2;
    (* fill in owner *)
    acv.a_mblock.mb_data^.mbp_buf[ _pos     ] := chr (ownerLength + 1);
    IF  unicodeText
    THEN
        acv.a_mblock.mb_data^.mbp_buf[ _pos + 1 ] := csp_unicode_def_byte
    ELSE
        acv.a_mblock.mb_data^.mbp_buf[ _pos + 1 ] := csp_ascii_blank;
    (*ENDIF*) 
    SAPDB_PascalMove('VAK361',  10,    
          ownerLength, acv.a_mblock.mb_data_size,
          @owner, 1, @acv.a_mblock.mb_data^.mbp_buf, _pos + 2,
          ownerLength, acv.a_returncode );
    _pos := _pos + ownerLength + 2;
    (* *)
    acv.a_mblock.mb_data_len := acv.a_mblock.mb_data^.mbp_rec.recLen_gg00;
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        a06lsend_mess_buf( acv, acv.a_mblock, NOT c_call_from_rsend, _e );
        IF  _e <> e_ok
        THEN
            a07_b_put_error (acv, _e, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak361StoreCreateStatement(
            VAR acv            : tak_all_command_glob;
            VAR tableSurrogate : tgg00_Surrogate;
            VAR longSurrogate  : tgg00_Surrogate;
            VAR LongInfo       : tsp00_MoveObj;
            LongSize           : tsp00_Int4);
 
CONST
      c_useLiteralBuf = true;
 
VAR
      longinfo : tak_longliteral_rec;
 
BEGIN
(* make sure record header is initialized with something *)
longinfo.litreclen := 56 + sizeof(tak_litcoldesc);
longinfo.litkeylen :=  0;
longinfo.litvarcol_offset := 0;
longinfo.litvarcol_cnt    := 0;
longinfo.litentrytype     := '\00\00';
longinfo.litsurrogate     := cgg_zero_id;
longinfo.litlinkage       := cak_zero_linkage;
longinfo.litfullen        := longinfo.litreclen;
longinfo.litreclen := 56 + sizeof(tak_litcoldesc);
longinfo.litfiller1       := 0;
(* now put in the interesting parts *)
longinfo.littabid         := tableSurrogate;
longinfo.litcolcount      := 1;
longinfo.litlen           := LongSize;
longinfo.litsize          := LongSize;
longinfo.litdataptr       := @LongInfo;
a05_stamp_get (acv, longSurrogate, 1, sizeof(longSurrogate));
longinfo.litcoldesc[1].llclongid       := longSurrogate;
longinfo.litcoldesc[1].llcdatapos      := 1;
longinfo.litcoldesc[1].llcdatalen      := longinfo.litlen;
longinfo.litcoldesc[1].llwith_shortcol := true;
IF  acv.a_returncode = 0
THEN
    a507_literal (acv, longinfo, c_useLiteralBuf);
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
