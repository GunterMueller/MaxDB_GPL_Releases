.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :  7.2    Date : 2001-08-30
*****************************************************
modname : VAK10
changed : 2001-08-30
module  : Systeminfo_cache
 
Author  : ThomasA
Created : 1985-02-05
*****************************************************
 
Purpose : Verwaltung des Cache fuer Syteminformationen.
 
Define  :
 
        VAR
              a10chk               : boolean;
 
        PROCEDURE
              a10_add_repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    add_sysinfo  : boolean;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10alter_long_version (
                    VAR acv        : tak_all_command_glob;
                    VAR base_rec   : tak_baserecord;
                    old_long_cnt   : integer;
                    m_type         : tgg00_MessType;
                    view_scan      : boolean);
 
        PROCEDURE
              a10ak_cache_init;
 
        FUNCTION
              a10BaseRecPersistentOffset : integer;
 
        FUNCTION
              a10cache_used : tsp00_Int4;
 
        PROCEDURE
              a10clean_cache (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10cmd_rollback (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10_copy_catalog_rec (
                    VAR acv         : tak_all_command_glob;
                    VAR old_key     : tgg00_SysInfoKey;
                    del_old_rec     : boolean;
                    VAR new_key     : tgg00_SysInfoKey;
                    new_segment_id  : tsp00_C2;
                    add_new_rec     : boolean;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              a10cpy_result (
                    VAR acv         : tak_all_command_glob;
                    VAR pars_syskey : tgg00_SysInfoKey;
                    VAR res_syskey  : tgg00_SysInfoKey;
                    rescnt          : tsp00_Int4;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              a10CopyFromSharedSQL (VAR acv : tak_all_command_glob;
                    VAR Sysinfo : tak_systembuffer (* ptocConst *));
 
        PROCEDURE
              a10DeallocTemp(
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10DeallocAll (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10Displace (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10_del_tab_sysinfo  (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate;
                    VAR qual    : tak_del_tab_qual;
                    temp_table  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10DeleteRollbackFiles (
                    VAR acv     : tak_all_command_glob);
 
        PROCEDURE
              a10del_user_sysinfo  (
                    VAR acv     : tak_all_command_glob;
                    VAR auth    : tgg00_Surrogate;
                    VAR b_err   : tgg00_BasisError);
 
        FUNCTION
              a10akdump (
                    VAR acv : tak_all_command_glob) : boolean;
 
        PROCEDURE
              a10dump (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10DisableTableAccess;
 
        PROCEDURE
              a10EnableTableAccess;
 
        FUNCTION
              a10TableAccessAllowed : boolean;
 
        PROCEDURE
              a10expand_rec (
                    VAR rec_buf : tgg00_Rec;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10dispose (
                    VAR acv : tak_all_command_glob;
                    VAR p   : tak_sysbufferaddress);
 
        PROCEDURE
              a10find_result (
                    VAR acv        : tak_all_command_glob;
                    VAR pars_key   : tak_parskey;
                    dstate         : tak_directory_state;
                    VAR syspoint   : tak_sysbufferaddress;
                    VAR b_err      : tgg00_BasisError);
 
        PROCEDURE
              a10_fix_len_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    required_len : integer;
                    plus         : integer;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        FUNCTION
              a10GetCreateCommandId (syspointer : tak_sysbufferaddress) : tsp00_Int4;
 
        FUNCTION
              a10GetRefCount (
                    syspoint   : tak_sysbufferaddress) : integer;
 
        FUNCTION
              a10IncopyTableInit (VAR acv : tak_all_command_glob;
                    VAR key     : tgg00_SysInfoKey (* ptocConst *);
                    colCount    : integer) : tak_sysbufferaddress;
 
        PROCEDURE
              a10InsertIntoCatalog (
                    VAR acv      : tak_all_command_glob;
                    VAR rec      : tgg00_Rec (* ptocConst *);
                    doInsert     : boolean);
 
        PROCEDURE
              a10flush (
                    VAR acv              : tak_all_command_glob;
                    VAR syskey           : tgg00_SysInfoKey;
                    disable_cmd_rollback : boolean);
 
        PROCEDURE
              a10FlushResnames (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10free_cache (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10GetStatistics (
                    VAR acv         : tak_all_command_glob;
                    resetStatistics : boolean;
                    VAR accessCount : tsp00_Int4;
                    VAR successful  : tsp00_Int4;
                    VAR hitRate     : integer);
 
        FUNCTION
              a10hit_rate (
                    VAR acv : tak_all_command_glob) : integer;
 
        PROCEDURE
              a10increment_ap_tree (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10intermediate_mblock (
                    VAR acv        : tak_all_command_glob;
                    VAR mblock     : tgg00_MessBlock;
                    VAR mblock_ptr : tgg00_MessBlockPtr);
 
        PROCEDURE
              a10inquire_resnames (
                    VAR acv         : tak_all_command_glob;
                    VAR cnt         : tsp00_Int4;
                    VAR resname_arr : tak_resn_rec_arr);
 
        PROCEDURE
              a10ins_or_upd (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10InsertKeptRecord (
                    VAR acv    : tak_all_command_glob;
                    syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10invalidate_root (
                    VAR acv    : tak_all_command_glob;
                    VAR treeid : tgg00_FileId);
 
        FUNCTION
              a10is_fixed (
                    VAR acv : tak_all_command_glob;
                    p       : tak_sysbufferaddress) : boolean;
 
        PROCEDURE
              a10lock_fixed (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10look_for_gaps (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10mark_updated (
                    p       : tak_sysbufferaddress);
 
        PROCEDURE
              a10MarkGlobalReferencesUnused (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10Lock (
                    VAR acv : tak_all_command_glob;
                    p       : tak_sysbufferaddress);
 
        PROCEDURE
              a10Unlock (
                    VAR acv : tak_all_command_glob;
                    p       : tak_sysbufferaddress);
 
        PROCEDURE
              a10mblock_into_cache (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR mblock   : tgg00_MessBlock;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10MigrateBaseRecords (doMigrate : boolean);
 
        PROCEDURE
              a10new (
                    VAR acv  : tak_all_command_glob;
                    obj_size : tsp00_Int4;
                    VAR p    : tak_sysbufferaddress);
 
        PROCEDURE
              a10new_packet (
                    VAR acv : tak_all_command_glob;
                    size    : tsp00_Int4;
                    VAR ptr : tsp00_MoveObjPtr);
 
        PROCEDURE
              a10prefix_parsid_delete (
                    VAR acv       : tak_all_command_glob;
                    VAR parsk     : tak_parskey;
                    VAR del_cnt   : integer;
                    prefix_length : integer);
 
        PROCEDURE
              a10ReadFromCatalog (
                    VAR acv : tak_all_command_glob;
                    VAR row : tgg00_Rec);
 
        PROCEDURE
              a10refresh_cache (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10release_table (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate);
 
        PROCEDURE
              a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10remove_parsinfos (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10shrink_syntax_tree (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10table_cache_delete (
                    VAR acv     : tak_all_command_glob;
                    VAR tableid : tgg00_Surrogate);
 
        PROCEDURE
              a10unlock_fixed (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10add_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_all_release (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10_cache_delete  (
                    VAR acv     : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10del_sysinfo (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_init_cache (
                    VAR acv : tak_all_command_glob);
 
        FUNCTION
              a10KeepRecord (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey) : tak_sysbufferaddress;
 
        PROCEDURE
              a10_key_del  (
                    VAR acv     : tak_all_command_glob;
                    VAR syskey  : tgg00_SysInfoKey);
 
        PROCEDURE
              a10key_del  (
                    VAR acv         : tak_all_command_glob;
                    VAR  syspointer : tak_sysbufferaddress);
 
        PROCEDURE
              a10_lock_sysinfo (
                    VAR acv    : tak_all_command_glob;
                    VAR syskey : tgg00_SysInfoKey;
                    lockm      : tgg00_LockReqMode);
 
        FUNCTION
              a10NextDisplacedKey (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey) : boolean;
 
        PROCEDURE
              a10next_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    stop_prefix  : integer;
                    dstate       : tak_directory_state;
                    rec_kind     : tsp00_C2;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_nil_get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    syslen       : tsp00_Int4;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        FUNCTION
              a10NoTableInfoInCache (
                    VAR acv  : tak_all_command_glob) : boolean;
 
        PROCEDURE
              a10_rel_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey);
 
        PROCEDURE
              a10repl_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
              (* PTS 1103813 *)
 
        PROCEDURE
              a10ResetStatistics (
                    VAR acv         : tak_all_command_glob);
 
        PROCEDURE
              a10SessionCacheInit (
                    VAR acv : tak_all_command_glob);
 
        FUNCTION
              a10SetColumnAndName (VAR acv : tak_all_command_glob;
                    VAR base_rec     : tak_baserecord;
                    columnIndex      : integer;
                    columnNameLength : integer) : tak00_colinfo_ptr;
 
        PROCEDURE
              a10SetMigrationProtTabid (
                    tableNo   : integer;
                    VAR Tabid : tgg00_Surrogate);
 
        PROCEDURE
              a10StoreAs (
                    VAR acv         : tak_all_command_glob;
                    syskey          : tgg00_SysInfoKey; (* must not be var *)
                    VAR storeSyskey : tgg00_SysInfoKey;
                    VAR e           : tgg00_BasisError);
 
        PROCEDURE
              a10_upd_key (
                    VAR acv      : tak_all_command_glob;
                    VAR parsk    : tak_parskey;
                    displacement : integer;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10_version (
                    VAR acv        : tak_all_command_glob;
                    VAR base_rec   : tak_baserecord;
                    m_type         : tgg00_MessType;
                    view_scan      : boolean);
 
        PROCEDURE
              a10parsinfos (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Scanner   : VAK01;
 
        VAR
              a01defaultkey       : tgg00_SysInfoKey;
              a01sysnullkey       : tgg00_SysInfoKey;
              a01_i_ak_cache      : tsp00_KnlIdentifier;
              a01_il_b_identifier : tsp00_KnlIdentifier;
              a01_zero_res_name   : tsp00_KnlIdentifier;
              a01identifier_size  : integer;
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06cpy_mblock (
                    VAR acv        : tak_all_command_glob;
                    VAR src_mblock : tgg00_MessBlock;
                    VAR dst_mblock : tgg00_MessBlock;
                    withoutData    : boolean;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              a06get_page_cnt (
                    VAR acv          : tak_all_command_glob;
                    VAR file_id      : tgg00_FileId;
                    do_sample        : boolean;
                    VAR page_count   : tsp00_Int4;
                    VAR b_err        : tgg00_BasisError);
 
        PROCEDURE
              a06inc_linkage (
                    VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06lsend_mess_buf (
                    VAR acv         : tak_all_command_glob;
                    VAR mblock      : tgg00_MessBlock;
                    call_from_rsend : boolean;
                    VAR b_err       : tgg00_BasisError);
 
        PROCEDURE
              a06set_mtree (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock;
                    VAR tree   : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              AK_Identifier_Handling : VAK061;
 
        PROCEDURE
              a061app_columnname (
                    VAR acv               : tak_all_command_glob;
                    VAR base_rec          : tak_baserecord;
                    VAR column            : tsp00_KnlIdentifier;
                    VAR index             : integer);
 
        PROCEDURE
              a061add_name (
                    VAR acv      : tak_all_command_glob;
                    VAR base_rec : tak_baserecord;
                    VAR name     : tsp00_KnlIdentifier;
                    VAR p        : tsp00_KnlIdentifierPtr);
 
        PROCEDURE
              a061copy_colinfo (
                    VAR src_col : tak00_columninfo;
                    VAR dst_col : tak00_columninfo);
 
        PROCEDURE
              a061get_colname (
                    VAR col_info : tak00_columninfo;
                    VAR colname  : tsp00_KnlIdentifier);
 
        FUNCTION
              a061identifier_len (
                    VAR id : tsp00_KnlIdentifier) : integer;
 
        PROCEDURE
              a061compress_baserec (
                    VAR base_rec : tak_baserecord;
                    VAR b_err    : tgg00_BasisError);
&       ifdef trace
 
        PROCEDURE
              a061td_colinfo (
                    VAR colinfo : tak00_columninfo;
                    index       : integer);
&       endif
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_const_b_put_error (
                    VAR acv    : tak_all_command_glob;
                    b_err      : tgg00_BasisError;
                    err_code   : tsp00_Int4;
                    param_addr : tsp00_MoveObjPtr;
                    const_len  : integer);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        PROCEDURE
              a101_AttachColumnBuffer (
                    pColBuffer : tak_sysbufferaddress);
 
        FUNCTION
              a101_DescribeParseId (
                    pExecuteHandle   : tgg00_VoidPtr) : tak_sysbufferaddress;
 
        PROCEDURE
              a101_DestroyGroupedTempFiles(
                    VAR trans      : tgg00_TransContext;
                    fileType       : tgg00_TfnTemp(*ptocConst*);
                    level          : tsp00_Int4(*ptocConst*);
                    subLevel       : tsp00_Int2(*ptocConst*);
                    VAR fileName   : tgg00_Filename);
 
        PROCEDURE
              a101_DetachColumnBuffer (
                    VAR acv    : tak_all_command_glob;
                    pTable    : tak_sysbufferaddress);
 
        PROCEDURE
              a101_DumpSessionInfo (
                    VAR acv         : tak_all_command_glob;
                    VAR dmpFileName : tsp00_VFilename;
                    dmpFileNo       : tsp00_Int4;
                    VAR dmpPageNo   : tsp00_Int4;
                    dmpBufAddr      : tsp00_BufAddr;
                    dmpBufSize      : tsp00_Int4);
 
        FUNCTION
              a101_GetPlanElement (
                    pPlanHandle   : tgg00_VoidPtr;
                    VAR syskey    : tgg00_SysInfoKey) : tak_sysbufferaddress;
 
        PROCEDURE
              a101_IncrementSyntaxTree (
                    VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a101_InvalidateListAppend (
                    VAR acv       : tak_all_command_glob;
                    VAR SchemaId  : tgg00_Surrogate;
                    VAR Tablename : tsp00_KnlIdentifier);
 
        FUNCTION
              a101_IsStatementActive(
                    VAR acv     : tak_all_command_glob;
                    statementId : tsp00_Int4) : boolean;
 
        PROCEDURE
              a101_SetTempFileIndex(
                    VAR acv        : tak_all_command_glob;
                    VAR tempFileId : tgg00_FileId;
                    sublevel       : tsp00_Int4(*ptocConst*));
 
        PROCEDURE
              a101_DestroyGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId);
 
        PROCEDURE
              a101_ResetGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId;
                    tempFileType   : tgg00_TfnTemp);
&       ifdef KERNEL80
 
        PROCEDURE
              a101_StoreTable (
                    VAR acv        : tak_all_command_glob;
                    VAR BaseRecord : tak_baserecord);
&       endif
 
      ------------------------------ 
 
        FROM
              AKDump : VAK102;
 
        FUNCTION
              a102IsCacheOk(
                    VAR acv : tak_all_command_glob) : boolean;
 
        FUNCTION
              a102PtrOK (
                    VAR acv : tak_all_command_glob;
                    p       : tak_cache_dir_pointer) : boolean;
 
      ------------------------------ 
 
        FROM
              CatalogWrapper : VAK103;
 
        PROCEDURE
              a103AttachCatalogRecord (
                    VAR acv     : tak_all_command_glob;
                    VAR key     : tgg00_SysInfoKey;
                    VAR pHandle : tgg00_VoidPtr;
                    VAR p       : tak_sysbufferaddress;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              a103DeleteAuthorizationObject (
                    VAR acv      : tak_all_command_glob;
                    VAR authName : tsp00_KnlIdentifier (* ptocConst *));
 
        FUNCTION
              a103HandleInvalid (
                    pHandle : tgg00_VoidPtr) : boolean;
 
        PROCEDURE
              a103CatalogCacheInvalidateTable (
                    TaskId       : tsp00_TaskId;
                    VAR  TableId : tgg00_Surrogate);
 
        PROCEDURE
              a103LoadAuthorizationById (
                    VAR acv    : tak_all_command_glob;
                    VAR authId : tgg00_Surrogate;
                    VAR buf    : tsp00_Buf;
                    VAR e      : tgg00_BasisError);
 
        PROCEDURE
              a103LoadAuthorizationByName (
                    VAR acv    : tak_all_command_glob;
                    VAR name   : tsp00_KnlIdentifier;
                    useCache   : boolean;
                    VAR buf    : tsp00_Buf;
                    VAR e      : tgg00_BasisError);
 
        PROCEDURE
              a103ReleaseCacheHandle (
                    VAR acv     : tak_all_command_glob;
                    Handle      : tgg00_VoidPtr;
                    DecRefCount : boolean);
 
        FUNCTION
              a103RestoreMessBlockFieldSequences (
                    VAR acv    : tak_all_command_glob;
                    VAR Key    : tgg00_SysInfoKey;
                    VAR MBlock : tak_messblock_record) : integer;
 
        PROCEDURE
              a103SetCacheHandleInUse (
                    VAR acv     : tak_all_command_glob;
                    Handle      : tgg00_VoidPtr;
                    InUse       : boolean);
 
        PROCEDURE
              a103StoreCatalogObject (
                    VAR acv        : tak_all_command_glob;
                    pObject        : tak_sysbufferaddress;
                    doUpdate       : boolean);
 
        FUNCTION
              a103StoreMessBlockFieldSequences (
                    VAR acv      : tak_all_command_glob;
                    VAR Key      : tgg00_SysInfoKey;
                    VAR MBlock   : tgg00_MessBlock;
                    MaxStoredKey : integer) : integer;
 
      ------------------------------ 
 
        FROM
              SequenceWrapper : VAK104;
 
        PROCEDURE
              ak104_DropReference_MS (
                    VAR sequence     : tsp00_MoveObjPtr);
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        FUNCTION
              a11firstindex (
                    colcount    : integer;
                    VAR baserec : tak_baserecord) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              AK_Trigger : VAK262;
 
        PROCEDURE
              a262DeleteTriggerParsinfo (
                    VAR acv         : tak_all_command_glob;
                    VAR BaseRec     : tak_baserecord);
 
        PROCEDURE
              a262DropParseIds (
                    VAR acv    : tak_all_command_glob;
                    VAR mblock : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              AK_VIEW_SCAN : VAK27;
 
        PROCEDURE
              a27init_viewscanpar (
                    VAR acv         : tak_all_command_glob;
                    VAR viewscanpar : tak_save_viewscan_par;
                    v_type          : tak_viewscantype);
 
        PROCEDURE
              a27view_scan   (
                    VAR acv         : tak_all_command_glob;
                    VAR tableid     : tgg00_Surrogate;
                    VAR viewscanpar : tak_save_viewscan_par);
 
      ------------------------------ 
 
        FROM
              AK_universal_show_tools : VAK40;
 
        PROCEDURE
              a40get_catalog_table (
                    VAR acv  : tak_all_command_glob;
                    VAR a41v : tak40_show_glob);
 
        PROCEDURE
              a40move (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_const (
                    VAR acv     : tak_all_command_glob;
                    VAR a41v    : tak40_show_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : integer);
 
        PROCEDURE
              a40move_i4 (
                    VAR acv       : tak_all_command_glob;
                    VAR a41v      : tak40_show_glob;
                    i4_val        : tsp00_Int4;
                    is_null       : boolean;
                    frac          : integer;
                    zero_to_undef : boolean);
 
      ------------------------------ 
 
        FROM
              AK_Connect : VAK51;
 
        PROCEDURE
              a51build_userkey (VAR user_name : tsp00_KnlIdentifier;
                    VAR userkey : tgg00_SysInfoKey);
 
        PROCEDURE
              a51inc_ak_cache_size (
                    size_info_ptr : tak_size_ptr;
                    increment     : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Resultname_handling : VAK663;
 
        FUNCTION
              a663parse_for_execute (
                    VAR acv : tak_all_command_glob) : boolean;
 
      ------------------------------ 
 
        FROM
              Build_Strategy_2 : VAK71;
 
        PROCEDURE
              a71add_default_strat (
                    VAR mbuf : tgg00_MessBlock);
 
        PROCEDURE
              a71del_sysinfo_strategy (
                    keylen     : tsp00_Int4;
                    VAR mblock : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01unicode       : boolean;
 
        FUNCTION
              g01cache_size (cache_type : tgg04_CacheType) : tsp00_Int4;
 
        FUNCTION
              g01catalog_cache_init_size : tsp00_Int4;
 
        PROCEDURE
              g01datapart_init (
                    VAR mblock    : tgg00_MessBlock;
                    datapart_ptr  : tgg00_DataPartPtr;
                    datapart_size : tsp00_Int4);
 
        FUNCTION
              g01maxuser : tsp00_Int4;
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans    : tgg00_TransContext;
                    mess_type           : tgg00_MessType;
                    mess2_type          : tgg00_MessType2;
                    VAR mblock          : tgg00_MessBlock);
 
        PROCEDURE
              g01qual_init (
                    VAR mblock : tgg00_MessBlock;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
        PROCEDURE
              g01stack_init (
                    VAR mblock : tgg00_MessBlock;
                    stack_ptr  : tgg00_StackListPtr;
                    stack_size : tsp00_Int4;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
        PROCEDURE
              g01stratpart_init (
                    VAR mblock     : tgg00_MessBlock;
                    stratpart_ptr  : tsp00_MoveObjPtr;
                    stratpart_size : tsp00_Int4);
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
        PROCEDURE
              g01opmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C24;
                    msg_value : tsp00_Int4);
 
        PROCEDURE
              g01optextmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C40);
 
        PROCEDURE
              g01new_dump_page (
                    VAR hostfile : tgg00_VfFileref;
                    VAR buf      : tsp00_Buf;
                    VAR out_pno  : tsp00_Int4;
                    VAR out_pos  : integer;
                    VAR host_err : tsp00_VfReturn;
                    VAR errtext  : tsp00_ErrText);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : vgg04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t    : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        VAR
              g08diagcache : tsp00_RegionId;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17hexto_line (
                    c          : char;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_C40);
 
        PROCEDURE
              g17int4to_line (
                    intval    : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line (*ptocSynonym char**));
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        FUNCTION
              gg999KernelStateIsRedoLogProcessing : boolean;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01blankfilename  : tsp00_VFilename;
              b01niltree_id     : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD07;
 
        PROCEDURE
              b07cnext_record (
                    VAR t          : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR rk         : tgg00_Lkey;
                    VAR set_result : tgg00_BdSetResultRecord;
                    VAR tree_pos   : tgg00_FilePos;
                    VAR b          : tsp00_Buf);
 
        PROCEDURE
              b07cadd_record (
                    VAR t    : tgg00_TransContext;
                    VAR curr : tgg00_FileId;
                    VAR b    : tak_systembuffer);
 
        PROCEDURE
              b07cget_record (
                    VAR t    : tgg00_TransContext;
                    VAR curr : tgg00_FileId;
                    VAR rk   : tgg00_SysInfoKey;
                    VAR b    : tgg00_Rec);
 
        PROCEDURE
              b07crepl_record (
                    VAR t           : tgg00_TransContext;
                    VAR act_tree_id : tgg00_FileId;
                    VAR b           : tak_systembuffer);
 
        PROCEDURE
              b07cdel_record (
                    VAR t           : tgg00_TransContext;
                    VAR act_tree_id : tgg00_FileId;
                    VAR rk          : tgg00_SysInfoKey);
 
      ------------------------------ 
 
        FROM
              ref_statistic  : VBD73;
 
        PROCEDURE
              b73directory_ref_statistic
                    (op_code : tgg00_DirectoryMonitorOp);
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (
                    VAR Trans  : tgg00_TransContext;
                    TraceLayer : tgg00_Debug;
                    TraceType  : tgg00_VtraceType;
                    BodyLen    : tsp00_Int2;
                    pEntry     : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53wait (
                    VAR t  : tgg00_TransContext;
                    MessType  : tgg00_MessType;
                    MessType2 : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              KB_Logging : vkb560;
 
        PROCEDURE
              kb560GetSys1CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560GetSys2CatalogTreeId(
                    VAR treeId : tgg00_FileId);
 
        PROCEDURE
              kb560GetSys2CatalogTabId(
                    VAR tabId : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30cmp (
                    VAR buf1     : tgg00_SysInfoKey;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tgg00_SysInfoKey;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
        FUNCTION
              s30lnr (
                    VAR str : tsp00_KnlIdentifier;
                    val     : char;
                    start   : tsp00_Int4;
                    cnt     : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Pointer-Arithmetik : VSP35;
 
        FUNCTION
              s35add_bufaddr_ptocm (
                    buf_addr : tsp00_BufAddr;
                    pos      : tsp00_Int4) : tsp00_BufAddr;
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbegexcl (
                    pid     : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vendexcl (
                    pid     : tsp00_TaskId;
                    region  : tsp00_RegionId);
 
        PROCEDURE
              vfclose (
                    hostfileno        : tsp00_Int4;
                    VAR error         : tsp00_VfReturn;
                    VAR errtext       : tsp00_ErrText);
 
        PROCEDURE
              vfopen (
                    VAR hostfile   : tsp00_VFilename;
                    VAR hostfileno : tsp00_Int4;
                    VAR error      : tsp00_VfReturn;
                    VAR errtext    : tsp00_ErrText);
 
        PROCEDURE
              vfwrite (
                    hostfileno        : tsp00_Int4;
                    buf               : tsp_vf_bufaddr;
                    VAR error         : tsp00_VfReturn;
                    VAR errtext       : tsp00_ErrText);
 
        PROCEDURE
              vmfree  (p : tsp00_ObjAddr);
 
        PROCEDURE
              vmalloc (
                    length    : tsp00_Int4;
                    VAR p     : tsp00_BufAddr;
                    VAR ok    : boolean);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01sname (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    bufaddr  : tsp00_BufAddr);
 
        PROCEDURE
              t01catalog_entrytype (
                    debug      : tgg00_Debug;
                    etype      : tsp00_Char);
 
        PROCEDURE
              t01str30 (
                    layer : tgg00_Debug;
                    str30 : tsp00_C30);
 
        PROCEDURE
              t01p2int4 (
                    layer : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01int4 (
                    layer   : tgg00_Debug;
                    nam     : tsp00_Sname;
                    int     : tsp00_Int4);
 
        PROCEDURE
              t01buf  (
                    layer   : tgg00_Debug;
                    VAR buf : tak_systembuffer;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              t01buf1 (
                    layer   : tgg00_Debug;
                    VAR buf : tgg00_SysInfoKey;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              t01moveobj (
                    layer   : tgg00_Debug;
                    VAR buf : tsp00_MoveObj;
                    pos_anf : tsp00_Int4;
                    pos_end : tsp00_Int4);
 
        PROCEDURE
              t01site (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    site     : tgg00_ServerdbNo);
 
        PROCEDURE
              t01stackentry (
                    debug          : tgg00_Debug;
                    VAR st         : tgg00_StackEntry;
                    entry_index    : integer);
 
        PROCEDURE
              t01surrogate (debug : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        FUNCTION
              t01trace (debug : tgg00_Debug) : boolean;
&       endif
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              ak104_DropReference_MS;
 
              tak104_MemorySequence tsp00_MoveObjPtr;
 
        FUNCTION
              a101_GetPlanElement;
 
              tgg00_VoidPtr tak_sysbufferaddress;
 
        PROCEDURE
              a101_AttachColumnBuffer;
 
              tgg00_VoidPtr tak_sysbufferaddress;
 
        PROCEDURE
              a101_DetachColumnBuffer;
 
              tgg00_VoidPtr tak_sysbufferaddress;
 
        PROCEDURE
              a27init_viewscanpar;
 
              tak_viewscan_par tak_save_viewscan_par
 
        PROCEDURE
              a27view_scan;
 
              tak_viewscan_par tak_save_viewscan_par
 
        PROCEDURE
              g17hexto_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              b07cdel_record;
 
              tgg00_Lkey tgg00_SysInfoKey;
 
        PROCEDURE
              b07cget_record;
 
              tgg00_Lkey tgg00_SysInfoKey;
 
        PROCEDURE
              b07crepl_record;
 
              tgg00_Rec   tak_systembuffer
 
        PROCEDURE
              b07cadd_record;
 
              tgg00_Rec   tak_systembuffer
 
        PROCEDURE
              b07cnext_record;
 
              tsp00_MoveObj   tsp00_Buf
 
        PROCEDURE
              b120InsertTrace;
 
              tgg11_VtraceBodyPtr tsp00_Addr
 
        PROCEDURE
              s35add_bufaddr_ptocm;
 
              tsp00_Int4 tsp00_BufAddr
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tak_systembuffer
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tgg00_SysInfoKey
 
        PROCEDURE
              g01new_dump_page;
 
              tsp00_Page tsp00_Buf
 
        PROCEDURE
              s30cmp;
 
              tsp00_MoveObj tgg00_SysInfoKey
 
        FUNCTION
              s30lnr;
 
              tsp00_MoveObj tsp00_KnlIdentifier;
 
        PROCEDURE
              vmalloc;
 
              tsp00_ObjAddr tsp00_BufAddr
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
 
.pb '@'
.pa
General :
.sp
The AK cache is a 48-K area of memory that forms the interface
between the AK modules and the catalog, i.e. catalog records
are transferred from the system files to an area in the cache and the
AK modules then access these records via pointers. Newly built
catalog records are also first of all built in the cache and
then are they passed to KB for inserting or updating.
.br
Because of the size of the cache and the locality principle of
applications, frequent KB requests are reduced to the system files,
which is important particularly in distribution.
Cache management is accomplished by means of the cache
directory and the free-memory management.
The cache directory contains information about the catalog records
allocated in the cache. For each catalog record, the
following information is stored in the directory:
.sp
.hi +12
d_pointer^: ^is the pointer to the cache address starting at which
the catalog record is stored in the cache.
.br
d_posp^@@@: ^relative position of the record in the cache.
.br
d_state^@@: ^specifies the state of the record allocated in cache.
If the record may not be shifted within the cache or may not be
displaced from the cache, dfix is specified. Otherwise the record may be
shifted or displaced.
The d_state = dnot_exist is assigned if, on accessing the
system file, it is found that a catalog record that has been
requested does not exist. In subsequent accessing of the same record,
it is then possible without KB access to decide that the record does
not exist (access to Public Tables without PUBLIC). The states dwritten
and dadd_rec are used for temporary catalog records only.
Temporary records are
not written through immediately upon the Insert or Update command,
but only when the record is to be displaced from the cache.
This frequently dispenses with the need for BD operations
in the case of separate parsing/executing. The state dwritten indicates
that the record must be viewed as inserted into the temporary
catalog file, whereas dwritten indicates that the record has already
been inserted into the temporary catalog file.
.br
d_syslen^@: ^Length occupied by the block in the cache.
.br
d_sysclock: contains a kind of access counter of the record.
This counter is used in displacing in order to decide which
record will be displaced.
.br
.sp;.hi -12
The directory entries are sorted in ascending order according to
the keys of the catalog records, so that the search for a record
can be conducted by means of a binary search.
In order, when searching, not always to have to search through
the entire directory, a subdivision has been made
into records with key x'FF...' and those with
key <> x'FF...'. d_first_x_ff identifies the
first directory entry with key x'FF...'.
.br
The free-memory management is stored a structure called tfreelist, where
the positions of the free blocks are stored.
The first 4 bytes of each free block contain the length of the block
and the next 4 bytes contain the position of the free block.
This position is checked against the position stored in the freelist in
order to be able to determine cache violations.
.sp 4
PROCEDURE  A10_INIT_CACHE (
VAR acv : all_command_glob;
                           cachep  : takcachebufaddress);
.sp
Initializes the cache buffer and the directory.
The entire cache is then a free block.
.sp 4
PROCEDURE  A10_CACHE_DELETE (
VAR acv : all_command_glob)
.sp
The entire cache is emptied. Since catalog records of the parse file are not
written through immediately, they must be inserted beforehand into the parse
file by means of a10temp_add.
.sp 4
PROCEDURE A10_NIL_GET_SYSINFO (
VAR acv : all_command_glob;
.nf
                  VAR syskey   : tsysinfokey;
                  dstate       : directory_state;
                  syslen       : int2;
                  VAR syspoint : tsysbufferaddress;
                  VAR b_err    : basis_error);
.sp;.fo
By this procedure, an empty cache area of length syslen is requested for the
catalog record with key syskey. For this purpose, the key is first
searched for in the directory in order to find the insertion point in the
directory. If the key is found during this search, the error message
duplicate_key is reported back.
.br
Otherwise a10_put_mbuf_into_cache is called in  order to search a
free area of length syslen and to store the key in the cache and the
cache directory.
.br
.sp 4;.nf
PROCEDURE  A10_GET_SYSINFO (
VAR acv : all_command_glob;
                  VAR syskey   : tsysinfokey;
                  dstate       : directory_state;
                  sysloc       : location;
                  VAR syspoint : tsysbufferaddress;
                  VAR b_err    : basis_error);
.sp;.fo
The catalog record with key syskey is loaded into the cache. For this purpose,
the record is first of all searched for in the cache directory. If the record
is found there, the syspoint is set to the address in the cache under which the
record is allocated.
.br
If the record does not yet exist in the cache directory, it must first of all
be read from the corresponding system file. For this purpose, either the parse
file or one of the system files (KB request) must be accessed. By means of
a10_put_mbuf_into_cache, the record that has been read is transferred to an
area in the cache and the corresponding address is entered in syspoint.
.sp 4;.nf
.sp 4;.nf
PROCEDURE a10_next_sysinfo (
VAR acv : all_command_glob;
                  VAR syskey   : tsysinfokey;
                  dstate       : directory_state;
                  sysloc       : location;
                  rec_kind     : int2;
                  VAR syspoint : tsysbufferaddress;
                  VAR b_err    : basis_error);
.sp;.fo
From the location sysloc, the procedure reads the next catalog record with
sreckind = rec_kind into the cache. If rec_kind < 0, the next catalog record is
fetched without examining the sreckind. If the record already exists in the
cache, the old entry is passed to the free-memory management and the new one is
entered in the cache. The next record is read into the message buffer by a KB
request and is then transferred to the cache by means of
a10_put_mbuf_into_cache. The key of the record that has been found is passed in
syskey; syspoint is the address in the cache under which the record is
allocated.
.sp 4;.nf
PROCEDURE  A10_PUT_MBUF_INTO_CACHE (
VAR acv : all_command_glob;
                  VAR mbuf     : rel3_mess_buffer;
                  dstate       : directory_state;
                  VAR syskey   : tsysinfokey;
                  VAR syspoint : tsysbufferaddress;
                  VAR b_err    : basis_error);
.sp;.fo
The catalog record in part 2 of mbuf is entered into the cache.
The key of the record and cache address of the record are returned in
syskey and syspoint.
.br
At first the record (i.e. the key of the record) is searched in the
cache directory. If the record is already stored in the cache, nothing
happens. Otherwise the search returns the position in the directory
where the record in part2 of mbuf must be described.
If all directory entries are accupied, a record must be diplaced from
the cache in order to get a free directory entry for the  new record
(a10_search_del_buf).
The next step is to request for a free block of length syslen
(a10_freepos_get). If the request cannot be satisfied, an attempt is
made to satisfy the request by displacing records (a10_search_del_buf). In this
case, it is necessary to redetermine the index where the record is stored
in the directory (a10_index_get).
.br
If, even after records have been displaced, there is no free block available
for the record, there is a programming error and the error message
ak_cachedirectory_full is returned. If this is not the case, a directory entry
is generated for the record (ak10add_ind_in_dir), an entry is made in it,
and the record is copied from mbuf to the allocated cache area.
.sp 4;.nf
PROCEDURE  A10_ALL_RELEASE (
VAR acv : all_command_glob)
.sp;.fo
The state dfix is removed from all cache directory entries.
.sp 4;.nf
PROCEDURE  A10_REL_SYSINFO (
VAR acv : all_command_glob;
                  VAR syskey   : tsysinfokey);
.sp;.fo
In the directory entry representing the catalog record with key syskey,
the state dfix is removed.
.sp 4;.nf
PROCEDURE  A10_ADD_SYSINFO (
VAR acv : all_command_glob;
                  VAR locset   : locnoset;
                  VAR syspoint : tsysbufferaddress;
                  VAR b_err    : basis_error);
.sp;.fo
The catalog record starting at address syspoint in the cache is inserted
into the corresponding system file if it is a permanent catalog record.
If the record is a temporary catalog record, merely the flag
dadd_rec is set, which means that the record is inserted into the parse
file when it must be displaced.
.br
If the record is shorter than the reserved cache area, the remainder is
passed to the free-memory management as a free block (a10_in_freelist).
.sp 4;.nf
PROCEDURE  A10_REPL_SYSINFO (
VAR acv : all_command_glob;
                  VAR locset   : locnoset;
                  VAR syspoint : tsysbufferaddress;
                  VAR b_err    : basis_error);
.sp;.fo
If the catalog record starting at address syspoint in the cache is
a permanent catalog record, it is inserted into the corresponding
system file by  a KB Update order.
Since temporary catalog records are not written through directly,
nothing needs to be done for them.
.sp 4;.nf
PROCEDURE  A10_UPD_KEY (
VAR acv : all_command_glob;
                  VAR parsk    : parskey;
                  displacement : integer;
                  VAR b_err    : basis_error);
.sp;.fo
In all related parse information records with key parsk,
the parsk.p_no part is reduced by displacement, i.e. virtually a
key update is performed for the records.
.br
The number of records to be handled is determined from the first parse
information record.
.br
Each record to be handled is loaded into the cache by a10_get_sysinfo. The
associated directory entry is placed in intermediate storage and is then
deleted in the directory. By means of a10_index_get, a search is
then made for the insertion point in the directory for the new key
and the original entry that was saved is transferred there.
By means of a10_add_sysinfo, the record is then marked as to be inserted.
.sp 4;.nf
PROCEDURE  A10_DEL_SYSINFO (
VAR acv : all_command_glob;
                  VAR locset   : locnoset;
                  VAR syskey   : tsysinfokey;
                  VAR b_err    : basis_error);
.sp;.fo
The catalog record with key syskey is deleted. For this purpose,
the record is
first of all removed from the cache and from the directory
(a10_buf_in_freelist). If the record to be deleted is a permanent record,
it is removed from the corresponding system file by a KB Delete
command. Conversely, a temporary catalog record only needs
to be deleted from the parse file if it
has already been written through (dwritten in state).
.sp 4;.nf
PROCEDURE  A10DEL_USER_TAB_SYSINFO  (
VAR acv : all_command_glob;
                  VAR locset : locnoset;
                  VAR tabid  : tableid;
                  VAR b_err  : basis_error);
.sp;.fo
All catalog records whose keys have the value of tabib in the stableid
field are deleted both from system file 1 and from system file 2.
For this purpose the corresponding delete order is sent to KB.
By means of a10table_cache_delete,
all relevant catalog records are then deleted from the cache.
.sp 4;.nf
PROCEDURE  A10RELEASE_TABLE (
VAR acv : all_command_glob;
                  VAR tabid  : tableid);
.sp;.fo
In all cache directory entries
concerning the table determined by tabid the state dfix is removed, which
means that the corresponding catalog records allocated in cache are
allowed to be shifted or displaced.
.sp 4;.nf
PROCEDURE  A10_INDEX_GET (
VAR acv : all_command_glob;
                  VAR syskey : tsysinfokey;
                  VAR keyind : integer;
                  VAR newind : integer);
.sp;.fo
The catalog record with key syskey is searched for in the directory
by means of a binary search. If the key is found, keyind subsequently
contains the corresponding directory index;
otherwise, keyind = 0 and newind conains the
directory index where the syskey must be inserted.
.sp 4;.nf
PROCEDURE  A10_LOCK_SYSINFO (
VAR acv : all_command_glob;
                  VAR locset : locnoset;
                  VAR syskey : tsysinfokey;
                  lockm      : lockmode);
.sp;.fo
By calling the procedure, it is possible to lock catalog records with
the lock mode lockm. The corresponding command is sent to KB.
.br
The locking of individual records is not possible in system file 1;
instead, all records with tableid = syskey.stableid are locked by KB.
.br
In system file 2, on the other hand, only the syskey that has been
transferred is locked.
.sp 4;.nf
PROCEDURE  A10TABLE_CACHE_DELETE (
VAR acv : all_command_glob;
                  VAR tabid  : tableid);
.sp;.fo
All catalog records of the table determined by tabid
are removed from the cache. This is
done for each relevant record by means of a10_buf_in_freelist.
.sp 4;.nf
PROCEDURE  A10_KEY_DEL  (
VAR acv : all_command_glob;
                  VAR syskey : tsysinfokey);
.sp;.fo
The catalog record with key syskey is removed from the cache. By means of
a10_index_get, first of all, the corresponding directory index
is determined and the record is removed from the cache and
from the directory by  means of a10_buf_in_freelist.
.sp 4;.nf
PROCEDURE  A10_SEARCH_DEL_BUF (
VAR acv : all_command_glob;
                  VAR sl      : integer;
                  VAR freepos : int4);
.sp;.fo
The procedure attempts to generate a free block of length sl
in the cache by the displacing of entries.
If the attempt is successful, the position of the
free block is returned in freepos.
.br
If no free memory is found and if there is no more entry that
can be displaced (no entry which does not contain dfix in its state),
there is an error message.
.br
In a loop, a search is made in the directory for the next entry to be
displaced. For this purpose, starting at index d_pos+1, the clock pointer
d_clock of the respective directory entry is decremented by 1
until a clockpointer containing 0 is found.
If the record is allowed to be displaced,
the corresponding entry is deleted from the directory
and the associated cache area is made available as free memory.
.br
If memory has been released in the cache,
there is a check as to whether a free block of the
requested length is now available (a10_freepos_get).
If sl = 0, freepos is set to = -1.
.br
This is repeated until freepos <> 0, or until there is
no further entry which can be released.
If no available block of the requested length has been found until now,
its possible that a block of the requested length can be created by cache
compactification. Cache compactification is allowed, if the flag
acv.compact_allowed is TRUE.
In this case the compactification is done and an
attempt is then made to satisfy the request by means of a10_freepos_get.
If at the end of the procedure no block has been found which satisfies
the request, this is an error that must not occur in actual fact.
(Incorrect implementation or the cache buffer has been
defined too small (at least 10 * maxbufferlength)).
.sp 4;.nf
PROCEDURE  A10_TEMP_ADD  (
VAR acv : all_command_glob;
                  index      : integer);
.sp;.fo
The procedure is called whenever a catalog record
is displaced from the cache.
Temporary entries may possibly be written through only at this point. If
the catalog record described by the directory entry index is a temporary,
one, it must, if applicable, be written into the parse file.
If dwritten in state, this means that the record is already stored
in the parse file and, therefore, an update must be performed.
If only dadd_rec in state, the record has been built in the cache and
an a10_add_sysinfo has been performed. The record must, therefore, now be
inserted.
.sp 4;.nf
PROCEDURE  A10_FREEPOS_GET  (
VAR acv : all_command_glob;
                  VAR required_len : integer;
                  VAR freepos      : int4);
.sp;.fo
According to the first fit method, a free block of
length >= required_len is searched for in the free-memory list.
If a free block is not found, freepos is
then = 0. Otherwise, freepos contains the position of the free block.
Required_len is always aligned to 4 bytes, so that freepos,
too, is always aligned to 4 bytes.
.sp 4;.nf
PROCEDURE  A10_BUF_IN_FREELIST (
VAR acv : all_command_glob;
                  dirind : integer);
.sp;.fo
The directory entry with index dirind is removed from the directory
(a10del_ind_in_dir) and the associated cache area is passed
to the free-memory management (a10_in_freelist).
.sp 4;.nf
PROCEDURE  A10_IN_FREELIST (
VAR acv : all_command_glob;
                  block_pos : int4;
                  block_len : integer);
.sp;.fo
The block starting at position block_pos of length block_len
is marked as a free block by insertion into the free-memory list.
If the block adjoins free
blocks on right and/or left, these are combined to form one free block.
.sp 4;.nf
PROCEDURE  AK10ADD_IND_IN_DIR (
VAR acv : all_command_glob;
                  ind            : integer;
                  is_x_ff        : boolean);
.sp;.fo
At position ind in the directory, space is created for a directory entry.
This is done by shifting the following entries to the right.
If an entry with syskey x'FF...' is to be entered,
it may be necessary for d_first_ff to have a new
entry made in it.
.sp 4;.nf
PROCEDURE  A10DEL_IND_IN_DIR (
VAR acv : all_command_glob;
                  ind     : integer;
                  is_x_ff : boolean);
.sp;.fo
The directory entry with index ind is removed from the directory.
The position
of the first key x'FF...' d_first_xx may have to be updated.
.sp 4;.nf
PROCEDURE  A10PUT_BLOCK_LENGTH (
VAR acv : all_command_glob;
                  pos  : int4;
                  len  : int4;
                  check_pos : boolean);
.sp;.fo
The value of the parameter len is written into
the cache at postion pos + 4.
If check_pos is true, the value of pos is compared with the value
stored at position pos. If the values are not equal, a cache violation
has been occured and the corresponding errormessage is returned.
If check_pos is false the value of pos is stored at position pos in the
cache.
.sp 4;.nf
PROCEDURE a10get_block_length (
VAR acv : all_command_glob;
            block_pos        : int4;
            VAR block_length : int4);
.sp;.fo
The procedure determines the length of the free block starting at
position block_pos. To be able to determine cache violations,
block_pos is first of all compared with the position stored in
the free block. If the result is unequal, a cache violation has been
occured and the corresponding errormessage is returned. Otherwise
the length of the block is returned in block_length.
.sp 4;.nf
PROCEDURE  A10_VERSION (
VAR acv : all_command_glob;
            VAR p_arr      : tsyspointerarr;
            m_type         : message_type;
            view_scan      : boolean);
.sp;.fo
The file version number of the table determined by p_arr
is increased (m_type = m_succ_file_version) or initialized.
The new file version is stored in the treeid of the first tbaserecord of
p_arr.
If view_scan is TRUE, the version number
is updated in all dependent views by a27view_scan.
.CM *-END-* specification -------------------------------
***********************************************************
 
Description:
 
.CM *-END-* description ---------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      c_del_in_directory     = true;
      c_del_dependecies      = true;
      c_in_cache             = true;
      c_is_null              = true;
      c_zero_to_undef        = true;
      cak10init_cache        = true;
      cak10required_hit_rate =  900;
      cak10min_temp_reads    =  100;
      cak10supplement        = 4;
      cak10dump_id_cache     = 1801;
      cak10dump_id_freecache = 1802;
      cak10sync              = true;
      cak10displaceTypesCnt  = 5;
      cak10withoutData       = true;
      cak10CheckReferences   = true;
      msg_no_temp_sysk       = 'NO TEMP SYSKEY          ';
      msg_wrong_less         = 'WRONG LESS PTR          ';
      msg_wrong_greater      = 'WRONG GREATER PTR       ';
      msg_wrong_lru          = 'NOT IN LRU              ';
      msg_gap_found          = 'GAP IN CACHE FOUND      ';
      c_call_from_rsend      = true;
      c_is_rollback          = true;
      c_flush_temp           = true;
      c_via_kb               = true;
      c_explicitMigTableCount= 2;
 
TYPE
      tak10_find_kind = (nil_get, get, get_next);
 
      tak10_find_info = RECORD
            fi_ptr        : tak_cache_dir_pointer;
            fi_res        : tsp00_LcompResult;
            fi_kind       : tak10_find_kind;
      END;
 
      tak10_SysKeyPointer = ^tgg00_SysInfoKey;
      (* whenever changed change structure in vak102.cpp too !! *)
 
      tak10cache_header = RECORD
            ch_label      : tsp00_C4;
            ch_size       : tsp00_Int4;
            ch_next_cache : tsp00_BufAddr;
&           ifndef BIT64
            ch_filler     : tsp00_Int4;
&           endif
      END;
 
 
      tak10_mblock_info = ARRAY[1..4] OF RECORD
            addr : tsp00_MoveObjPtr;
            size : tsp00_Int4;
            len  : tsp00_Int4;
      END;
 
 
      tak10qual = RECORD
            q_hd : ARRAY[1..MB_PART1_HEAD_MXGG00] OF char;
            q_st : ARRAY[1..cgg04_return_stack_entries] OF tgg00_StackEntry;
      END;
 
      tak10cache_header_ptr = ^tak10cache_header;
 
      tak10_dump_context = RECORD
            dmp_pno        : tsp00_Int4;
            dmp_pos        : integer;
            dmp_header_pos : integer;
            dmp_error      : tsp00_VfReturn;
            dmp_b_err      : tgg00_BasisError;
            dmp_file       : tgg00_VfFileref;
            dmp_buf        : tsp00_Buf;
      END;
 
 
      tak10_used_blocks = ARRAY[1..10000] OF RECORD
            pos : tsp00_Int4;
            len : tsp00_Int4;
      END;
 
 
VAR
      ak10DumpId               : tsp00_Int2;
      ak10CatalogTablesEnabled : boolean;
      ak10migrate              : boolean;
      ak10ChunkLabel           : tsp00_C4;
      ak10offset               : tsp00_Int4;
      ak10all_cache_size       : tsp00_Int4;
      ak10init_cache_size      : tsp00_Int4;
      ak10cache_cnt            : tsp00_Int4;
      ak10ExplicitMigTables    : ARRAY [1..c_explicitMigTableCount] OF tgg00_Surrogate;
      ak10joinViewVersion      : tsp_int_map_c2; (* PTS 1111114 *)
      ak10displaceTypes        : ARRAY[1..cak10displaceTypesCnt] OF tsp00_C2; (* PTS 1110796 *)
 
 
(*------------------------------*) 
 
FUNCTION
      ak10_IsSharedRecord (p : tak_sysbufferaddress) : boolean;
 
VAR
 
      univPtr : RECORD
            CASE integer OF
                1 :
                    (sysPtr : tak_sysbufferaddress);
                2 :
                    (bufPtr : tsp00_BufAddr);
                3 :
                    (i4Ptr  : ^tsp00_Int4);
                END;
            (*ENDCASE*) 
 
 
BEGIN
univPtr.sysPtr      := p;
univPtr.bufPtr      := s35add_bufaddr_ptocm (univPtr.bufPtr, - sizeof(tsp00_Int4));
ak10_IsSharedRecord := univPtr.i4Ptr^ = 0;
END;
 
(*------------------------------*) 
 
FUNCTION
      ak10IsSharedSQLRecord (p : tak_cache_dir_pointer) : boolean;
 
BEGIN
ak10IsSharedSQLRecord := p.cdir_ptr^.cd_pos = 0;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_add_repl_sysinfo (
            VAR acv : tak_all_command_glob;
            VAR syspoint : tak_sysbufferaddress;
            add_sysinfo  : boolean;
            VAR b_err    : tgg00_BasisError);
 
BEGIN
&ifdef trace
t01buf1 (ak_cach, syspoint^.syskey, 1,
      syspoint^.syskey.skeylen + cgg_rec_key_offset);
&endif
b_err := e_ok;
IF  NOT add_sysinfo
THEN
    a10repl_sysinfo (acv, syspoint, b_err);
(*ENDIF*) 
IF  add_sysinfo OR (b_err = e_sysinfo_not_found)
THEN
    a10add_sysinfo (acv, syspoint, b_err)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10ak_cache_init;
 
VAR
      required_len : integer;
      i            : integer;
 
BEGIN
ak10CatalogTablesEnabled := false;
ak10migrate             := false;
ak10ChunkLabel[1]       := 'A';
ak10ChunkLabel[2]       := 'C';
ak10ChunkLabel[3]       := chr(ord('0') + sizeof(tsp00_Addr));
ak10ChunkLabel[4]       := chr(ord('0'));
ak10DumpId              := 0;
ak10all_cache_size      := 0;
ak10cache_cnt           := 0;
ak10offset              := 0;
ak10joinViewVersion.map_int := 0; (* PTS 1111114 *)
ak10init_cache_size := g01catalog_cache_init_size DIV sizeof (tsp00_Page);
required_len := 2;
(* determine the offset of structures in front         *)
(* of the AK-Cache,                                    *)
required_len := sizeof (tgg00_SysInfoKey);
IF  required_len MOD ALIGNMENT_GG00 <> 0
THEN
    required_len := required_len -
          (required_len MOD ALIGNMENT_GG00) + ALIGNMENT_GG00;
(*ENDIF*) 
IF  required_len < mxak_cache_dir_entry
THEN
    required_len := mxak_cache_dir_entry;
(*ENDIF*) 
ak10offset := ak10offset + required_len;
ak10displaceTypes[1]   := cak_emindex;     (* PTS 1110796 *)
ak10displaceTypes[2]   := cak_estatistics;
ak10displaceTypes[3]   := cak_econstraint;
ak10displaceTypes[4]   := cak_edefault;
ak10displaceTypes[5]   := cak_epriv;
FOR i := 1 TO c_explicitMigTableCount DO
    ak10ExplicitMigTables [i] := cgg_zero_id;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10alter_long_version (
            VAR acv        : tak_all_command_glob;
            VAR base_rec   : tak_baserecord;
            old_long_cnt   : integer;
            m_type         : tgg00_MessType;
            view_scan      : boolean);
 
VAR
      b_err          : tgg00_BasisError;
      aux_arr        : tak_syspointerarr;
      viewscanpar    : tak_save_viewscan_par;
      mblock         : tgg00_MessBlock;
      qual           : tak10qual;
 
BEGIN
(* just to make usecheck happy *)
qual.q_st[1].etype := st_value;
b_err := e_ok;
WITH acv DO
    IF  a_returncode = 0
    THEN
        IF  (base_rec.btablekind in [twithkey, twithoutkey]) AND
            NOT (base_rec.bunloaded)                         AND
            (base_rec.btreeid.fileTfn_gg00 <> tfnTemp_egg00)
        THEN
            BEGIN
            a101_InvalidateListAppend (acv, base_rec.bschema, base_rec.btablen^);
            a_localCacheUsageOnly := true;
            g01mblock_init (acv.a_transinf.tri_trans,
                  m_type, mm_file, mblock);
            mblock.mb_struct := mbs_buf;
            g01qual_init (mblock, @qual, sizeof (qual));
            a06set_mtree (acv, mblock, base_rec.btreeid);
            mblock.mb_qual^.mold_long_cnt := old_long_cnt;
            mblock.mb_qual^.mnew_long_cnt := base_rec.bstringcount;
            mblock.mb_qual_len :=
                  sizeof (tgg00_FileId) + 2 * sizeof (tsp00_Int2);
            a06lsend_mess_buf (acv,
                  mblock, NOT c_call_from_rsend, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                a262DeleteTriggerParsinfo (acv, base_rec); (* PTS 1106286 *)
                base_rec.btreeid.fileVersion_gg00 :=
                      mblock.mb_qual^.mtree.fileVersion_gg00;
                IF  view_scan AND (b_err = e_ok) AND
                    (a_returncode = 0)
                THEN
                    BEGIN
                    a27init_viewscanpar (acv, viewscanpar, v_version);
                    viewscanpar.vsc_filevers :=
                          base_rec.btreeid.fileVersion_gg00;
                    aux_arr         := a_p_arr1;
                    a_p_arr1.pbasep := @base_rec;
                    a27view_scan (acv, mblock.mb_qual^.mtree.fileTabId_gg00,
                          viewscanpar);
                    a_p_arr1 := aux_arr
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  b_err <> e_ok
            THEN
                IF  b_err = e_file_not_found
                THEN
                    a07_b_put_error (acv, e_old_fileversion, 1)
                ELSE
                    a07_b_put_error (acv, b_err, 1);
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a10cache_used : tsp00_Int4;
 
BEGIN
a10cache_used := ak10all_cache_size
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10clean_cache (
            VAR acv : tak_all_command_glob);
 
VAR
      curr : tak_cache_dir_pointer;
      prev : tak_cache_dir_pointer;
      sysp : tak_sysbufferaddress;
 
BEGIN
(* this procedure removes all catalog records from the cache     *)
(* that have been allocated in the course of the current command *)
(* but have not been inserted into the catalog                   *)
prev := acv.a_sysdir.ci_cache_dir_header;
curr := acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_lru_next;
WHILE curr.cdir_ptr <> acv.a_sysdir.ci_cache_dir_trailor.cdir_ptr DO
    BEGIN
    IF  (curr.cdir_ptr^.cd_cmd_no = acv.a_command_id) AND
        NOT (dadd_rec in curr.cdir_ptr^.cd_state)     AND
        NOT (dwritten in curr.cdir_ptr^.cd_state)     AND
        NOT (dreference in curr.cdir_ptr^.cd_state)
    THEN
        BEGIN
        sysp := @curr.cdir_ptr^.cd_sysinfo;
        a10key_del (acv, sysp);
        curr := prev
        END;
    (*ENDIF*) 
    prev := curr;
    curr := curr.cdir_ptr^.cd_lru_next
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak10GlobalCacheGetKeyPointer(curr : tak_cache_dir_pointer) : tak10_SysKeyPointer;
 
BEGIN
ak10GlobalCacheGetKeyPointer := @curr.cdir_ptr^.cd_ref.cd_globalSysinfoPtr^.syskey;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10cmd_rollback (
            VAR acv : tak_all_command_glob);
 
VAR
      last_rec_buf : boolean;
      del_succ     : boolean;
      b_err        : tgg00_BasisError;
      curr_keylen  : tsp_int_map_c2;
      first_keylen : integer;
      rec_pos      : integer;
      rec_len      : integer;
      curr         : tak_cache_dir_pointer;
      prev         : tak_cache_dir_pointer;
      tree_pos     : tgg00_FilePos;
      set_result   : tgg00_BdSetResultRecord;
      find_info    : tak10_find_info;
      zerokey      : tgg00_Lkey;
      syskey       : tgg00_SysInfoKey;
      pKey         : tak10_SysKeyPointer;
      b            : tgg00_Rec;
 
BEGIN
prev := acv.a_sysdir.ci_cache_dir_header;
curr := acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_lru_next;
&ifdef trace
WHILE curr.cdir_ptr <> acv.a_sysdir.ci_cache_dir_trailor.cdir_ptr DO
    BEGIN
    xtd_directory (ak_cach, curr);
    curr := curr.cdir_ptr^.cd_lru_next
    END;
(*ENDWHILE*) 
curr := acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_lru_next;
&endif
acv.a_sysdir.ci_inIterator := true;
WHILE curr.cdir_ptr <> acv.a_sysdir.ci_cache_dir_trailor.cdir_ptr DO
    BEGIN
    IF  curr.cdir_ptr^.cd_cmd_no = acv.a_command_id
    THEN
        BEGIN
&       ifdef trace
        xtd_directory (ak_cach, curr);
&       endif
        IF  dreference in curr.cdir_ptr^.cd_state
        THEN
            pKey := ak10GlobalCacheGetKeyPointer(curr)
        ELSE
            pKey := @curr.cdir_ptr^.cd_syskey;
        (*ENDIF*) 
        IF  (curr.cdir_ptr^.cd_create_cmd_no = cak_is_undefined) AND
            (acv.a_sysdir.ci_cmd_rollback_tree.fileRoot_gg00 <> NIL_PAGE_NO_GG00)
        THEN
            WITH curr.cdir_ptr^ DO
                BEGIN
                (* check, if record has been created in the course *)
                (* of the current sql order                        *)
                b07cget_record (acv.a_transinf.tri_trans,
                      acv.a_sysdir.ci_cmd_rollback_tree, pKey^, b);
                IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
                THEN
                    cd_create_cmd_no := cd_cmd_no
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        IF  ((curr.cdir_ptr^.cd_create_cmd_no = acv.a_command_id) OR
            (acv.a_init_ddl <> no_ddl))
            AND
            ((pKey^.sentrytyp <> cak_eresname) OR
            NOT acv.a_intern_explain)
        THEN
            BEGIN
            ak10find_syskey (acv, pKey^, find_info, NOT cak10CheckReferences);
            IF  find_info.fi_res = l_equal
            THEN
                ak10block_into_freelist (acv, find_info.fi_ptr,
                      c_del_in_directory, c_del_dependecies)
            (*ENDIF*) 
            END
        ELSE
            prev := curr;
        (*ENDIF*) 
        END
    ELSE
        prev := curr;
    (*ENDIF*) 
    curr := prev.cdir_ptr^.cd_lru_next
    END;
(*ENDWHILE*) 
acv.a_sysdir.ci_inIterator := false;
IF  acv.a_sysdir.ci_cmd_rollback_tree.fileRoot_gg00 <> NIL_PAGE_NO_GG00
THEN
    BEGIN
    WITH set_result DO
        BEGIN
        bd_key_check_len:= 0;
        bd_max_rec_cnt  := csp_maxint2;
        bd_max_fill_len := sizeof(b.buf);
        bd_next         := false;
        END;
    (*ENDWITH*) 
    rec_pos         := 1;
    rec_len         := 0;
    zerokey.len     := 0;
    tree_pos.tpsPno_gg00  := NIL_PAGE_NO_GG00;
    last_rec_buf    := false;
    REPEAT
        b_err := e_ok;
        IF  rec_pos >= rec_len
        THEN
            BEGIN
            rec_pos := 0;
            IF  last_rec_buf
            THEN
                b_err := e_no_next_record
            ELSE
                BEGIN
                b07cnext_record (acv.a_transinf.tri_trans,
                      acv.a_sysdir.ci_cmd_rollback_tree,
                      zerokey, set_result, tree_pos, b.buf);
                b_err := acv.a_transinf.tri_trans.trError_gg00;
                acv.a_transinf.tri_trans.trError_gg00 := e_ok
                END;
            (*ENDIF*) 
            IF  (b_err = e_ok) OR (b_err = e_key_not_found) OR
                (b_err = e_buffer_limit)
            THEN
                BEGIN
                IF  b_err <> e_buffer_limit
                THEN
                    last_rec_buf := true;
                (*ENDIF*) 
                rec_len := set_result.bd_fill_len;
                b_err   := e_ok
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            curr_keylen.map_c2[ 1 ] := b.buf[ rec_pos+3 ];
            curr_keylen.map_c2[ 2 ] := b.buf[ rec_pos+4 ];
            syskey.skeylen          := curr_keylen.map_int;
            SAPDB_PascalMove ('VAK10 ',   1,    
                  sizeof (b.buf), sizeof (syskey),
                  @b.buf, rec_pos+1,
                  @syskey, 1, syskey.skeylen + cgg_rec_key_offset, b_err);
            del_succ := false;
            IF  syskey.sentrytyp[2] in
                [cak_cresult, cak_ccolnames, cak_clongliteral,
                cak_cjparsinfo, cak_cparsinfo, cak_ctriggerparsinfo,
                cak_cmessblock, cak_cpermmessblock, cak_cshortinfo,
                cak_creskey, cak_clinkpos]
            THEN
                del_succ     := true;
            (*ENDIF*) 
            first_keylen := syskey.skeylen;
            IF  b_err = e_ok
            THEN
                BEGIN
                REPEAT
                    b07cdel_record (acv.a_transinf.tri_trans,
                          acv.a_pars_curr, syskey);
                    IF  del_succ
                    THEN
                        BEGIN
                        IF  syskey.skeylen = first_keylen
                        THEN
                            BEGIN
                            syskey.skeylen := syskey.skeylen + 1;
                            syskey.all[syskey.skeylen] := chr(1);
                            END
                        ELSE
                            syskey.all[syskey.skeylen] :=
                                  succ (syskey.all[syskey.skeylen])
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                UNTIL
                    NOT del_succ OR
                    (acv.a_transinf.tri_trans.trError_gg00 <> e_ok);
                (*ENDREPEAT*) 
                IF  acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found
                THEN
                    b_err := e_ok
                ELSE
                    b_err := acv.a_transinf.tri_trans.trError_gg00;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            acv.a_transinf.tri_trans.trError_gg00 := e_ok;
            rec_pos := rec_pos +
                  curr_keylen.map_int + cgg_rec_key_offset
            END;
        (*ENDIF*) 
    UNTIL
        (b_err <> e_ok);
    (*ENDREPEAT*) 
    a101_DestroyGroupedTempFile (acv.a_transinf.tri_trans,
          acv.a_sysdir.ci_cmd_rollback_tree);
    IF  acv.a_transinf.tri_trans.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv, acv.a_transinf.tri_trans.trError_gg00, 1);
    (*ENDIF*) 
    acv.a_sysdir.ci_cmd_rollback_tree.fileRoot_gg00 := NIL_PAGE_NO_GG00;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_copy_catalog_rec (
            VAR acv : tak_all_command_glob;
            VAR old_key     : tgg00_SysInfoKey;
            del_old_rec     : boolean;
            VAR new_key     : tgg00_SysInfoKey;
            new_segment_id  : tsp00_C2;
            add_new_rec     : boolean;
            VAR b_err       : tgg00_BasisError);
 
VAR
      old_deleted : boolean;
      dummy       : boolean;
      segmentid   : tsp00_C2;
      ix          : integer;
      firstindex  : integer;
      lastindex   : integer;
      new_index   : integer;
      base_colptr : tak_basecolinfo_ptr;
      sysp        : tak_sysbufferaddress;
      pColNames   : tak_sysbufferaddress;
      p           : tak_cache_dir_pointer;
      curr_col    : tak00_colinfo_ptr;
      find_info   : tak10_find_info;
      colname     : tsp00_KnlIdentifier;
 
BEGIN
ak10find_syskey (acv, old_key, find_info, NOT cak10CheckReferences);
IF  find_info.fi_res <> l_equal
THEN
    BEGIN
    a10get_sysinfo (acv, old_key, d_release, sysp, b_err);
    ak10find_syskey (acv, old_key, find_info, NOT cak10CheckReferences)
    END
ELSE
    BEGIN
    sysp  := @find_info.fi_ptr.cdir_ptr^.cd_sysinfo;
    b_err := e_ok
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    BEGIN
    (*=========== find directory entry of old record ============*)
&   ifdef trace
    IF  t01trace( ak_cach )
    THEN
        BEGIN
        t01bool (ak_cach, 'del_old_rec ', del_old_rec);
        t01bool (ak_cach, 'add_new_rec ', add_new_rec);
        t01sname (ak_cach, 'old key    :');
        t01catalog_entrytype( ak_cach, old_key.sentrytyp[ 2 ] );
        t01buf1 (ak_cach, old_key, cgg_rec_key_offset+1,
              old_key.skeylen + cgg_rec_key_offset);
        t01sname (ak_cach, 'new key    :');
        t01catalog_entrytype( ak_cach, new_key.sentrytyp[ 2 ] );
        t01buf1 (ak_cach, new_key, cgg_rec_key_offset+1,
              new_key.skeylen + cgg_rec_key_offset);
        END
    ELSE
        BEGIN
        t01bool (ak_sem, 'del_old_rec ', del_old_rec);
        t01bool (ak_sem, 'add_new_rec ', add_new_rec);
        t01sname (ak_sem, 'old key    :');
        t01catalog_entrytype( ak_sem, old_key.sentrytyp[ 2 ] );
        t01buf1 (ak_sem, old_key, cgg_rec_key_offset+1,
              old_key.skeylen + cgg_rec_key_offset);
        t01sname (ak_sem, 'new key    :');
        t01catalog_entrytype( ak_sem, new_key.sentrytyp[ 2 ] );
        t01buf1 (ak_sem, new_key, cgg_rec_key_offset+1,
              new_key.skeylen + cgg_rec_key_offset);
        END;
    (*ENDIF*) 
&   endif
    (*=========== remove old record from directory ==============*)
    ak10del_in_dir (acv, old_key);
    IF  (old_key.sentrytyp[2] in [cak_ctable, cak_cresult])
    THEN
        BEGIN
        base_colptr      := sysp^.sbase.bptr;
        sysp^.sbase.bptr := NIL
        END
    ELSE
        base_colptr := NIL;
    (*ENDIF*) 
    IF  del_old_rec AND
        ((dwritten in find_info.fi_ptr.cdir_ptr^.cd_state) OR
        ( old_key.sentrytyp < cak_etemp))
    THEN
        BEGIN
        (*============ delete old record =============*)
        old_deleted := true;
        IF  old_key.sentrytyp <= cak_etemp
        THEN
            BEGIN
            segmentid[1] :=
                  sysp^.ssysbuf[cgg_rec_key_offset + sysp^.b_kl + 1];
            segmentid[2] :=
                  sysp^.ssysbuf[cgg_rec_key_offset + sysp^.b_kl + 2];
            END;
        (*ENDIF*) 
        a10del_sysinfo (acv, old_key, b_err)
        END
    ELSE
        old_deleted := false;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        (*== find insert position of directory entry of new record ==*)
        p := find_info.fi_ptr;
        ak10find_syskey (acv, new_key, find_info, NOT cak10CheckReferences);
        IF  find_info.fi_res = l_equal
        THEN
            BEGIN
            (*== new key already exists in cache directory ===*)
            b_err := e_duplicate_sysinfo;
            ak10store_syskey (acv, new_key);
            IF  NOT old_deleted
            THEN
                ak10block_into_freelist (acv, p, c_del_in_directory,
                      c_del_dependecies)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            (*========== copy new key into old record ============*)
            SAPDB_PascalForcedMove (sizeof (new_key), sizeof (sysp^.syskey), @new_key,
                  cgg_rec_key_offset+1,
                  @sysp^.syskey, cgg_rec_key_offset+1, new_key.skeylen);
            IF  base_colptr <> NIL
            THEN
                BEGIN
                sysp^.sbase.breccnt := 0;
                sysp^.sbase.bptr    := base_colptr
                END
            ELSE
                IF  old_key.sentrytyp[2] in [cak_ctable, cak_cresult]
                THEN
                    WITH sysp^.sbase DO
                        BEGIN
                        breccnt    := 0;
                        bptr       := NIL;
                        firstindex := bfirstindex;
                        lastindex  := blastindex;
                        blastindex := bfirstindex - 1;
                        bmaxcol    := 0;
                        a061add_name (acv, sysp^.sbase, btablen^, btablen);
                        FOR ix := firstindex TO lastindex DO
                            BEGIN
                            curr_col := bcolumn[ix];
                            a061get_colname    (curr_col^, colname);
                            a061app_columnname (acv,
                                  sysp^.sbase, colname, new_index);
                            IF  acv.a_returncode = 0
                            THEN
                                a061copy_colinfo (curr_col^,
                                      bcolumn[new_index]^)
                            (*ENDIF*) 
                            END;
                        (*ENDFOR*) 
                        END
                    (*ENDWITH*) 
                ELSE
                    IF  (old_key.sentrytyp[2] = cak_ccolnames) AND (sysp^.b_sl = MAX_RECLEN_GG00)
                    THEN
                        BEGIN
                        pColNames := sysp^.scolnames.cnnext;
                        WHILE pColNames <> NIL DO
                            BEGIN
                            pColNames^.syskey.sauthid := sysp^.syskey.sauthid;
                            IF  pColNames^.b_sl = MAX_RECLEN_GG00
                            THEN
                                pColNames := pColNames^.scolnames.cnnext
                            ELSE
                                pColNames := NIL;
                            (*ENDIF*) 
                            END;
                        (*ENDWHILE*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            ak10ins_directory (acv, find_info,
                  acv.a_sysdir.ci_dir [ ord (new_key.sentrytyp[ 2 ]) ],
                  p, dummy);
            p.cdir_ptr^.cd_state := p.cdir_ptr^.cd_state -
                  [ dadd_rec, dmodified, dwritten ];
            IF  new_key.sentrytyp < cak_etemp
            THEN
                BEGIN
                (* new record is permanent, copy new segmentid *)
                (* into old record                             *)
                sysp^.ssysbuf[ cgg_rec_key_offset+new_key.skeylen+1 ] :=
                      new_segment_id[ 1 ];
                sysp^.ssysbuf[ cgg_rec_key_offset+new_key.skeylen+2 ] :=
                      new_segment_id[ 2 ];
                IF  add_new_rec
                THEN
                    a10add_sysinfo (acv, sysp, b_err)
                (*ENDIF*) 
                END
            ELSE
                IF  add_new_rec
                THEN
                    BEGIN
                    p.cdir_ptr^.cd_state :=
                          p.cdir_ptr^.cd_state + [dadd_rec];
                    IF  sysp^.syskey.sentrytyp[2] in
                        [cak_cjparsinfo, cak_cparsinfo, cak_cshortinfo,
                        cak_creskey, cak_clinkpos, cak_clongliteral]
                    THEN
                        sysp^.sparsinfo.p_fullen := sysp^.b_sl
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
ak10verify_cache (acv)
&     endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10cpy_result (
            VAR acv : tak_all_command_glob;
            VAR pars_syskey : tgg00_SysInfoKey;
            VAR res_syskey  : tgg00_SysInfoKey;
            rescnt          : tsp00_Int4;
            VAR b_err       : tgg00_BasisError);
 
CONST
      c_rescnt_unknown = -1;
 
VAR
      isShared   : boolean;
      dummy      : boolean;
      is_fixed   : boolean;
      ix         : integer;
      p          : tak_cache_dir_pointer;
      dir_header : tak_cache_dir_pointer;
      sysbuf     : tak_cache_dir_pointer;
      curr       : tak_cache_dir_pointer;
      syslen     : tsp00_Int4;
      find_info  : tak10_find_info;
 
BEGIN
(* copies a result description identified by pars_syskey *)
(* to a result description identified by res_syskey      *)
dir_header := acv.a_sysdir.ci_cache_dir_header;
is_fixed   := true;
&ifdef trace
t01sname (ak_sem, 'renam result');
&endif
a10get_sysinfo (acv, pars_syskey,
      d_release, sysbuf.sys_ptr, b_err);
IF  b_err = e_ok
THEN
    BEGIN
&   ifdef trace
    t01sname (ak_sem, 'new result :');
    t01buf1 (ak_sem, res_syskey, cgg_rec_key_offset+1,
          res_syskey.skeylen + cgg_rec_key_offset);
    t01sname (ak_sem, '------------');
    FOR ix := sysbuf.sys_ptr^.sresult.bfirstindex TO sysbuf.sys_ptr^.sresult.blastindex DO
        a061td_colinfo (sysbuf.sys_ptr^.sresult.bcolumn[ix]^, ix);
    (*ENDFOR*) 
    t01sname (ak_sem, '------------');
&   endif
    isShared := sysbuf.sys_ptr^.sresult.bptr^.bci_index = 0;
    IF  NOT isShared
    THEN
        BEGIN
        curr.buf_ptr := s35add_bufaddr_ptocm (sysbuf.buf_ptr,
              - mxak_cache_dir_entry);
        is_fixed := curr.cdir_ptr^.cd_fix_next.cdir_ptr <> NIL;
        IF  NOT is_fixed
        THEN (* avoid replacement of pars_syskey *)
            curr.cdir_ptr^.cd_fix_next := curr;
        (*ENDIF*) 
        END
    ELSE
        is_fixed := true;
    (*ENDIF*) 
    ak10find_syskey (acv, res_syskey, find_info, NOT cak10CheckReferences);
    IF  find_info.fi_res = l_equal
    THEN
        BEGIN
        ak10store_syskey (acv, res_syskey);
        b_err := e_duplicate_sysinfo
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  b_err = e_ok
THEN
    BEGIN
    syslen := mxak_cache_dir_entry + sysbuf.sys_ptr^.b_sl;
    ak10getmem (acv, cak_is_undefined, syslen, p.buf_ptr);
    IF  p.buf_ptr <> NIL
    THEN
        WITH p.cdir_ptr^ DO
            BEGIN
            cd_cmd_no        := acv.a_command_id;
            cd_create_cmd_no := acv.a_command_id;
            cd_state         := [dadd_rec];
            SAPDB_PascalMove ('VAK10 ',   2,    
                  sysbuf.sys_ptr^.b_sl, sizeof (cd_sysinfo),
                  @sysbuf.sys_ptr^, 1, @cd_sysinfo, 1,
                  sysbuf.sys_ptr^.b_sl, acv.a_returncode);
            SAPDB_PascalForcedMove (sizeof (res_syskey), sizeof (cd_syskey),
                  @res_syskey, cgg_rec_key_offset + 1,
                  @cd_syskey, cgg_rec_key_offset + 1,
                  res_syskey.skeylen);
            WITH cd_sysinfo.sresult DO
                BEGIN
                IF  isShared
                THEN
                    a101_AttachColumnBuffer (@cd_sysinfo)
                ELSE
                    bptr^.bci_ref_cnt := bptr^.bci_ref_cnt + 1;
                (*ENDIF*) 
                IF  rescnt <> c_rescnt_unknown
                THEN
                    BEGIN
                    brows  := rescnt;
                    IF  bmaxreclen > cak_page80percent
                    THEN
                        IF  rescnt = 0
                        THEN
                            bpages := 1
                        ELSE
                            bpages := rescnt
                        (*ENDIF*) 
                    ELSE
                        bpages := brows DIV
                              (cak_page80percent DIV bmaxreclen) + 1
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
&           ifdef trace
            t01buf (ak_cach, cd_sysinfo, 1, cd_sysinfo.b_sl);
            IF  t01trace(ak_cach)
            THEN
                BEGIN
                WITH cd_sysinfo.sresult DO
                    FOR ix := bfirstindex TO blastindex DO
                        a061td_colinfo (bcolumn[ix]^, ix);
                    (*ENDFOR*) 
                (*ENDWITH*) 
                END;
&           endif
            (*ENDIF*) 
            ak10ins_directory (acv, find_info,
                  acv.a_sysdir.ci_dir [ord(res_syskey.sentrytyp[2])],
                  p, dummy);
            IF  acv.a_returncode = 0
            THEN
                BEGIN
                (*=========== Chain into LRU-List =============*)
                cd_lru_next :=
                      dir_header.cdir_ptr^.cd_lru_next;
                cd_lru_prev := dir_header;
                dir_header.cdir_ptr^.
                      cd_lru_next.cdir_ptr^.cd_lru_prev := p;
                dir_header.cdir_ptr^.cd_lru_next := p;
                p.cdir_ptr^.cd_fix_next.cdir_ptr := NIL;
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT is_fixed
THEN
    curr.cdir_ptr^.cd_fix_next.cdir_ptr := NIL;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10CopyFromSharedSQL (VAR acv : tak_all_command_glob;
            VAR Sysinfo : tak_systembuffer);
 
CONST
      cDelSource = true;
 
VAR
      e          : tgg00_BasisError;
      ix         : integer;
      firstindex : integer;
      lastindex  : integer;
      newIndex   : integer;
      colno      : integer;
      pCol       : tak00_colinfo_ptr;
      p          : tak_sysbufferaddress;
      colname    : tsp00_KnlIdentifier;
      c2         : tsp00_C2;
 
BEGIN
e := e_ok;
CASE Sysinfo.syskey.sentrytyp[2] OF
    cak_cresult :
        BEGIN
        c2 := Sysinfo.sresult.bsegmentid;
        a10_nil_get_sysinfo (acv, Sysinfo.syskey, d_fix,
              sizeof(tak_baserecord) - sizeof(tak_columnarr) +
              Sysinfo.sbase.blastindex * sizeof(Sysinfo.sbase.bcolumn[1]),
              p, e);
        IF  e = e_ok
        THEN
            SAPDB_PascalMove ('VAK10 ',   3,    
                  Sysinfo.b_sl, Sysinfo.b_sl, @Sysinfo, 1, @p^, 1, a10BaseRecPersistentOffset, e);
        (*ENDIF*) 
        IF  e = e_ok
        THEN
            BEGIN
            p^.sbase.bcolumnSplitIdx  := csp_maxint2;
            p^.sbase.bupdstatinserted := false;
            p^.sbase.breccnt          := 0;
            p^.sbase.bptr             := NIL;
            firstindex                := Sysinfo.sbase.bfirstindex;
            lastindex                 := Sysinfo.sbase.blastindex;
            p^.sbase.blastindex       := Sysinfo.sbase.bfirstindex - 1;
            p^.sbase.bmaxcol          := 0;
            a061add_name (acv, p^.sbase, Sysinfo.sbase.btablen^, p^.sbase.btablen);
            colno := 0;
            FOR ix := firstindex TO lastindex DO
                BEGIN
                pCol := Sysinfo.sbase.bcolumn[ix];
                a061get_colname    (pCol^, colname);
                a061app_columnname (acv,
                      p^.sbase, colname, newIndex);
                IF  acv.a_returncode = 0
                THEN
                    a061copy_colinfo (pCol^, p^.sbase.bcolumn[newIndex]^);
                (*ENDIF*) 
                p^.sbase.bextcolindex[pCol^.cextcolno] := colno;
                colno := colno + 1;
                END;
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END;
    cak_cmessblock :
        BEGIN
        a10mblock_into_cache (acv, Sysinfo.syskey, Sysinfo.smessblock.mbr_mess_block, d_release, p, e);
        END;
    OTHERWISE
        BEGIN
        a10_nil_get_sysinfo (acv, Sysinfo.syskey, d_release, Sysinfo.b_sl, p, e);
        IF  e = e_ok
        THEN
            SAPDB_PascalMove ('VAK10 ',   4,    
                  Sysinfo.b_sl, Sysinfo.b_sl, @Sysinfo, 1, @p^, 1, Sysinfo.b_sl, e);
        (*ENDIF*) 
        END;
    END;
(*ENDCASE*) 
IF  e = e_ok
THEN
    a10add_sysinfo (acv, p, e);
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(* PTS 1109670 *)
(*------------------------------*) 
 
PROCEDURE
      a10DeallocAll (
            VAR acv : tak_all_command_glob);
 
VAR
      restartIter : boolean;
      next        : tak_cache_dir_pointer;
      curr        : tak_cache_dir_pointer;
      ix          : integer;
      ln_len      : integer;
      maxLen      : integer;
      dummy       : integer;
      pC40        : ^tsp00_C40;
      pKey        : tak10_SysKeyPointer;
 
      msg    : RECORD
            CASE boolean OF
                true :
                    (c18 : tsp00_C18);
                false :
                    (ln : tsp00_Line);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH acv.a_sysdir  DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        msg.c18 := 'deallocating      ';
        next := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
        WHILE next.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
            BEGIN
            curr := next;
            next := next.cdir_ptr^.cd_lru_prev;
            IF  NOT (a101_IsStatementActive(acv, curr.cdir_ptr^.cd_cmd_no)) AND
                (curr.cdir_ptr^.cd_refCount = 0)
            THEN
                BEGIN
                IF  dreference in curr.cdir_ptr^.cd_state
                THEN
                    pKey := ak10GlobalCacheGetKeyPointer(curr)
                ELSE
                    pKey := @curr.cdir_ptr^.cd_syskey;
                (*ENDIF*) 
                ln_len := 14;
                IF  pKey^.skeylen > 40
                THEN
                    maxLen := 40
                ELSE
                    maxLen := pKey^.skeylen;
                (*ENDIF*) 
                FOR ix := 1 TO maxLen DO
                    BEGIN
                    pC40 := @msg.ln[ln_len];
                    dummy := 0;
                    g17hexto_line (pKey^.all[ix], dummy, pC40^);
                    ln_len := ln_len + 2;
                    END;
                (*ENDFOR*) 
                msg.ln[ln_len] := ' ';
                g17int4to_line (curr.cdir_ptr^.cd_cmd_no, false, 10, ln_len + 1, msg.ln);
                ln_len := ln_len + 10;
                b120InsertTrace (acv.a_transinf.tri_trans,
                      ta, td_none, ln_len, @msg);
                ak10temp_add (acv, curr, NOT c_is_rollback);
                restartIter := ak10RestartIterator(curr); (* PTS 1126940 *)
                ak10block_into_freelist (acv, curr, c_del_in_directory, c_del_dependecies);
                IF  restartIter (* PTS 1126940 *)
                THEN
                    next := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10TraceKey ( VAR acv : tak_all_command_glob;
            VAR syskey : tgg00_SysInfoKey;
            cmdNo      : integer;
            VAR c18    : tsp00_C18);
 
VAR
      ix          : integer;
      ln_len      : integer;
      maxLen      : integer;
      dummy       : integer;
      pC40        : ^tsp00_C40;
 
      msg    : RECORD
            CASE boolean OF
                true :
                    (c18 : tsp00_C18);
                false :
                    (ln : tsp00_Line);
                END;
            (*ENDCASE*) 
 
 
BEGIN
msg.c18 := c18;
ln_len  := 14;
IF  syskey.skeylen > 40
THEN
    maxLen := 40
ELSE
    maxLen := syskey.skeylen;
(*ENDIF*) 
FOR ix := 1 TO maxLen DO
    BEGIN
    pC40 := @msg.ln[ln_len];
    dummy := 0;
    g17hexto_line (syskey.all[ix], dummy, pC40^);
    ln_len := ln_len + 2;
    END;
(*ENDFOR*) 
IF  cmdNo >= 0
THEN
    BEGIN
    msg.ln[ln_len] := ' ';
    g17int4to_line (cmdNo, false, 10, ln_len + 1, msg.ln);
    ln_len := ln_len + 10;
    END;
(*ENDIF*) 
b120InsertTrace (acv.a_transinf.tri_trans,
      ta, td_none, ln_len, @msg);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10DeallocTemp(
            VAR acv : tak_all_command_glob);
 
VAR
      next : tak_cache_dir_pointer;
      curr : tak_cache_dir_pointer;
 
BEGIN
(* removes all temporary record from cache without writting any changes *)
WITH acv.a_sysdir  DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        next := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
        WHILE next.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
            BEGIN
            curr := next;
            next := next.cdir_ptr^.cd_lru_prev;
            IF  NOT (dreference in curr.cdir_ptr^.cd_state)
                AND
                (curr.cdir_ptr^.cd_syskey.sentrytyp > cak_etemp)
                AND
                (curr.cdir_ptr^.cd_refCount = 0)
            THEN
                ak10block_into_freelist (acv, curr, c_del_in_directory,
                      c_del_dependecies)
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
&       ifdef trace
        ak10td_dirlist  (acv, ak_cach);
        ak10td_freelist (acv, ak_cach);
&       endif
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_del_tab_sysinfo  (
            VAR acv     : tak_all_command_glob;
            VAR tableid : tgg00_Surrogate;
            VAR qual    : tak_del_tab_qual;
            temp_table  : boolean;
            VAR b_err   : tgg00_BasisError);
 
CONST
      c_max_stack_index = 30;
 
VAR
      send_mess              : boolean;
      i                      : integer;
      cnt_in                 : integer;
      systemfileno           : integer;
      sysk                   : tgg00_SysInfoKey;
      stack        : ARRAY[1..c_max_stack_index] OF tgg00_StackEntry;
      mblock       : tgg00_MessBlock;
      qual_buf     : tak10qual;
 
      data         : RECORD
            CASE integer OF
                1 :
                    (dt_tabid : tgg00_Surrogate);
                2 :
                    (dt_site  : tgg00_ServerdbNo);
                3 :
                    (buf : tsp00_Buf);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH acv, mblock DO
    IF  a_returncode = 0
    THEN
        BEGIN
        systemfileno := 1;
        b_err        := e_ok;
        REPEAT
            send_mess := true;
            g01mblock_init (acv.a_transinf.tri_trans,
                  m_delete, mm_qual, mblock);
            g01stack_init (mblock, @stack[1], sizeof (stack),
                  @qual_buf, sizeof (qual_buf));
            mb_qual_len := sizeof (qual_buf.q_hd);
            g01datapart_init ( mblock, @data, sizeof( data ) );
            g01stratpart_init( mblock, a_mb_strat_addr, a_mb_strat_size );
            WITH mb_qual^ DO
                BEGIN
                IF  temp_table
                THEN
                    BEGIN
                    mtree := a_pars_curr
                    END
                ELSE
                    BEGIN
                    IF  systemfileno = 1
                    THEN
                        kb560GetSys1CatalogTreeId (mtree)
                    ELSE
                        kb560GetSys2CatalogTreeId (mtree);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                mqual_pos     := 1;
                mqual_cnt     := 2;
                data.dt_tabid := tableid;
                mb_data_len   := sizeof (data.dt_tabid);
                WITH mb_st^[1] DO
                    BEGIN
                    etype         := st_fixkey;
                    eop           := op_none;
                    epos          := 1;
                    elen_var      := SURROGATE_MXGG00;
                    ecol_tab[ 1 ] := chr(0);
                    ecol_tab[ 2 ] := chr(0);
                    END;
                (*ENDWITH*) 
                WITH mb_st^[2] DO
                    BEGIN
                    etype         := st_value;
                    eop           := op_eq_all;
                    epos          := 1;
                    elen_var      := SURROGATE_MXGG00;
                    ecol_tab      := cgg_zero_c2
                    END;
                (*ENDWITH*) 
                IF  qual.del_colno > 0
                THEN
                    BEGIN (* delete catalog records of column colno *)
                    mb_st^ [3]          := mb_st^ [1];
                    mb_st^ [3].epos     := SURROGATE_MXGG00 + 2 + 1;
                    mb_st^ [3].elen_var := 2;
                    mb_st^ [4]          := mb_st^ [2];
                    mb_st^ [4].epos     := SURROGATE_MXGG00 + 1;
                    mb_st^ [4].elen_var := 2;
                    mb_data^.mbp_buf [SURROGATE_MXGG00+1] :=
                          chr (qual.del_colno DIV 256);
                    mb_data^.mbp_buf [SURROGATE_MXGG00+2] :=
                          chr (qual.del_colno MOD 256);
                    mb_data_len         := SURROGATE_MXGG00 + mxsp_c2;
                    mb_st^ [5]          := mb_st^ [3];
                    mb_st^ [5].epos     := SURROGATE_MXGG00 + 1;
                    mfirst_free      := 6;
                    cnt_in           := 0;
                    FOR i := 1 TO qual.del_qual_cnt DO
                        IF  ((systemfileno = 1) AND
                            (qual.del_qual[ i ] < cak_esysfile2)) OR
                            ((systemfileno = 2) AND
                            (qual.del_qual[ i ] > cak_esysfile2))
                        THEN
                            BEGIN
                            cnt_in                   := succ(cnt_in);
                            mb_st^[mfirst_free]      := mb_st^ [4];
                            mb_st^[mfirst_free].epos := mb_data_len + 1;
                            mb_st^[mfirst_free].eop  := op_none;
                            mb_data^.mbp_buf[ mb_data_len + 1 ] :=
                                  qual.del_qual[ i, 1 ];
                            mb_data^.mbp_buf[ mb_data_len + 2 ] :=
                                  qual.del_qual[ i, 2 ];
                            mb_data_len  := mb_data_len + mxsp_c2;
                            mfirst_free  := mfirst_free + 1
                            END;
                        (*ENDIF*) 
                    (*ENDFOR*) 
                    mb_st^ [mfirst_free].etype    := st_op;
                    mb_st^ [mfirst_free].eop      := op_in;
                    mb_st^ [mfirst_free].epos     := 1;
                    mb_st^ [mfirst_free].elen_var := cnt_in;
                    mb_st^ [mfirst_free].ecol_pos := 0;
                    IF  cnt_in = qual.del_qual_cnt
                    THEN
                        systemfileno := 2
                    ELSE
                        IF  cnt_in = 0
                        THEN
                            send_mess := false;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    mb_st^[mfirst_free+1]     := mb_st^ [mfirst_free];
                    mb_st^[mfirst_free+1].eop := op_and;
                    mb_st^[mfirst_free+2]     := mb_st^ [mfirst_free+1];
                    mqual_cnt := mfirst_free + 2;
                    END;
                (*ENDIF*) 
                IF  send_mess
                THEN
                    BEGIN
                    mfirst_free := mqual_cnt + 1;
                    a71del_sysinfo_strategy (SYSKEY_MXGG00, mblock);
                    a06lsend_mess_buf (acv,
                          mblock, NOT c_call_from_rsend, b_err);
                    IF  b_err = e_key_not_found
                    THEN
                        b_err := e_ok;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
            systemfileno := succ(systemfileno);
        UNTIL
            (b_err <> e_ok) OR (systemfileno > 2) OR
            (temp_table);
        (*ENDREPEAT*) 
        a_transinf.tri_trans.trWarning_gg00 :=
              a_transinf.tri_trans.trWarning_gg00 - [warn8_scan_or_sort];
        IF  a_transinf.tri_trans.trWarning_gg00 = [warn0_exist]
        THEN
            a_transinf.tri_trans.trWarning_gg00 := [];
        (*ENDIF*) 
        a103CatalogCacheInvalidateTable (acv.a_transinf.tri_trans.trTaskId_gg00, tableid);
        IF  qual.del_colno = 0
        THEN
            ak10table_cache_delete (acv, tableid, NOT c_flush_temp)
        ELSE
            BEGIN
            sysk               := a01defaultkey;
            sysk.stableid      := tableid;
            sysk.slinkage[ 1 ] :=
                  chr (qual.del_colno DIV 256);
            sysk.slinkage[ 2 ] :=
                  chr (qual.del_colno MOD 256);
            FOR i := 1 TO qual.del_qual_cnt DO
                BEGIN
                sysk.sentrytyp := qual.del_qual[ i ];
                a10_key_del (acv, sysk)
                END;
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        b_err := e_cancelled;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10del_user_sysinfo  (
            VAR acv     : tak_all_command_glob;
            VAR auth    : tgg00_Surrogate;
            VAR b_err   : tgg00_BasisError);
 
CONST
      c_in_cnt          = 5;
      c_max_stack_index = 30;
 
VAR
      ix           : integer;
      st_pos       : integer;
      systemfileno : integer;
      in_list      : ARRAY[1..c_in_cnt] OF tsp00_C2;
      stack        : ARRAY[1..c_max_stack_index] OF tgg00_StackEntry;
      mblock       : tgg00_MessBlock;
      qual         : tak10qual;
 
      data : RECORD
            CASE boolean OF
                true :
                    (dt_epriv    : tsp00_C2;
                    dt_link      : tsp00_C2;
                    dt_userid    : tgg00_Surrogate;
                    dt_eprivuser : tsp00_C2;
                    dt_link2     : tsp00_C2;
                    dt_userid2   : tgg00_Surrogate);
                false :
                    (dt_buf : tsp00_Buf);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH acv, mblock DO
    IF  a_returncode = 0
    THEN
        BEGIN
        systemfileno := 1;
        REPEAT
            g01mblock_init (acv.a_transinf.tri_trans,
                  m_delete, mm_qual, mblock);
            g01stack_init (mblock, @stack[1], sizeof (stack),
                  @qual, sizeof (qual));
            g01datapart_init (mblock, @data, sizeof (data));
            g01stratpart_init( mblock, a_mb_strat_addr, a_mb_strat_size );
            IF  systemfileno = 1
            THEN
                kb560GetSys1CatalogTreeId (mb_qual^.mtree)
            ELSE
                kb560GetSys2CatalogTreeId (mb_qual^.mtree);
            (*ENDIF*) 
            mb_qual^.mqual_pos := 1;
            data.dt_epriv      := cak_epriv;
            data.dt_link       := cak_init_linkage;
            data.dt_userid     := auth;
            mb_data_len        := sizeof (data.dt_epriv) +
                  sizeof (data.dt_link) + sizeof (data.dt_userid);
            IF  systemfileno = 1
            THEN
                BEGIN
                data.dt_eprivuser := cak_eprivuser;
                data.dt_link2     := cak_init_linkage;
                data.dt_userid2   := auth;
                mb_data_len       := mb_data_len +
                      sizeof (data.dt_eprivuser) +
                      sizeof (data.dt_link2) + sizeof (data.dt_userid2);
                WITH mb_st^ [1] DO
                    BEGIN
                    etype         := st_fixkey;
                    eop           := op_none;
                    epos          := SURROGATE_MXGG00 + 1;
                    elen_var      := sizeof (data.dt_epriv) +
                          sizeof (data.dt_link) + SURROGATE_MXGG00;
                    ecol_tab[ 1 ] := chr(0);
                    ecol_tab[ 2 ] := chr(0)
                    END;
                (*ENDWITH*) 
                WITH mb_st^ [2] DO
                    BEGIN
                    etype         := st_value;
                    eop           := op_eq_all;
                    epos          := 1;
                    elen_var      := sizeof (data.dt_epriv) +
                          sizeof (data.dt_link) + SURROGATE_MXGG00;
                    ecol_tab      := cgg_zero_c2
                    END;
                (*ENDWITH*) 
                WITH mb_st^ [3] DO
                    BEGIN
                    etype    := st_jump_true;
                    eop      := op_none;
                    epos     := 4;
                    elen_var := 0;
                    ecol_pos := 0;
                    END;
                (*ENDWITH*) 
                mb_st^ [4] := mb_st^ [1];
                mb_st^ [5] := mb_st^ [2];
                mb_st^ [5].epos := sizeof (data.dt_epriv) +
                      sizeof (data.dt_link) + SURROGATE_MXGG00 + 1;
                WITH mb_st^ [6] DO
                    BEGIN
                    etype    := st_op;
                    eop      := op_or;
                    epos     := 0;
                    elen_var := 0;
                    ecol_pos := 0;
                    END;
                (*ENDWITH*) 
                mb_qual^.mqual_cnt   := 6;
                mb_qual^.mfirst_free := 7;
                a71add_default_strat (mblock);
                END
            ELSE
                BEGIN (* delete in catalog 2 *)
                WITH mb_st^ [1] DO
                    BEGIN
                    etype         := st_fixkey;
                    eop           := op_none;
                    epos          := 1;
                    elen_var      := SURROGATE_MXGG00;
                    ecol_tab[ 1 ] := chr(0);
                    ecol_tab[ 2 ] := chr(0);
                    END;
                (*ENDWITH*) 
                WITH mb_st^ [2] DO
                    BEGIN
                    etype         := st_value;
                    eop           := op_eq_all;
                    epos          := sizeof (data.dt_epriv) +
                          sizeof (data.dt_link)+1;
                    elen_var      := SURROGATE_MXGG00;
                    ecol_tab      := cgg_zero_c2
                    END;
                (*ENDWITH*) 
                WITH mb_st^ [3] DO
                    BEGIN
                    etype    := st_jump_false;
                    eop      := op_none;
                    epos     := 1 + c_in_cnt + 3;
                    elen_var := 0;
                    ecol_pos := 0;
                    END;
                (*ENDWITH*) 
                mb_st^ [4] := mb_st^ [1];
                WITH mb_st^ [4] DO
                    BEGIN
                    epos     := SURROGATE_MXGG00 + 1;
                    elen_var := 2
                    END;
                (*ENDWITH*) 
                st_pos     := 4;
                in_list[1] := cak_etableref;
                in_list[2] := cak_euser;
                in_list[3] := cak_eusertab;
                in_list[4] := cak_esequence;
                in_list[5] := cak_ecomment;
                FOR ix := 1 TO c_in_cnt DO
                    BEGIN
                    st_pos := st_pos + 1;
                    mb_st^ [st_pos] := mb_st^ [2];
                    WITH mb_st^ [st_pos] DO
                        BEGIN
                        eop       := op_none;
                        epos      := mb_data_len + 1;
                        elen_var  := 2;
                        END;
                    (*ENDWITH*) 
                    mb_data^.mbp_buf[mb_data_len +1] := in_list[ix, 1];
                    mb_data^.mbp_buf[mb_data_len +2] := in_list[ix, 2];
                    mb_data_len                  := mb_data_len + 2;
                    END;
                (*ENDFOR*) 
                st_pos := st_pos + 1;
                WITH mb_st^ [st_pos] DO
                    BEGIN
                    etype    := st_op;
                    eop      := op_in;
                    epos     := 1;
                    elen_var := c_in_cnt;
                    ecol_pos := 0;
                    END;
                (*ENDWITH*) 
                st_pos               := st_pos + 1;
                mb_st^ [st_pos]      := mb_st^ [st_pos - 1];
                mb_st^ [st_pos].eop  := op_and;
                mb_qual^.mqual_cnt   := st_pos;
                mb_qual^.mfirst_free := st_pos + 1;
                a71del_sysinfo_strategy (SYSKEY_MXGG00, mblock);
                END;
            (*ENDIF*) 
            a06lsend_mess_buf (acv,
                  mblock, NOT c_call_from_rsend, b_err);
            IF  b_err = e_key_not_found
            THEN
                b_err := e_ok;
            (*ENDIF*) 
            systemfileno := succ(systemfileno);
        UNTIL
            (b_err <> e_ok) OR (systemfileno > 2);
        (*ENDREPEAT*) 
        a_transinf.tri_trans.trWarning_gg00 :=
              a_transinf.tri_trans.trWarning_gg00 - [warn8_scan_or_sort];
        IF  a_transinf.tri_trans.trWarning_gg00 = [warn0_exist]
        THEN
            a_transinf.tri_trans.trWarning_gg00 := [];
        (*ENDIF*) 
        END
    ELSE
        b_err := e_cancelled;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10DeleteRollbackFiles (
            VAR acv     : tak_all_command_glob);
 
BEGIN
IF  acv.a_sysdir.ci_rollbackFileExists
THEN
    BEGIN
    a101_DestroyGroupedTempFiles(acv.a_transinf.tri_trans,
          ttfnCacheRollback_egg00, -1, -1, acv.a_sysdir.ci_cmd_rollback_tree.fileName_gg00);
    acv.a_sysdir.ci_rollbackFileExists := false;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10dispose (
            VAR acv : tak_all_command_glob;
            VAR p : tak_sysbufferaddress);
 
VAR
      curr       : tak_cache_dir_pointer;
      mblock_ptr : tgg00_MessBlockPtr;
 
BEGIN
curr.sys_ptr := p;
curr.buf_ptr := s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
&ifdef trace
t01int4 (ak_cach, 'pos         ', curr.cdir_ptr^.cd_pos);
t01int4 (ak_cach, 'mem_type    ', ord (curr.cdir_ptr^.cd_mem_type));
t01addr (ak_cach, 'ADDR        ', curr.buf_ptr);
&endif
IF  curr.cdir_ptr^.cd_mem_type = dyn_mess_block
THEN
    BEGIN
    (* memory to dispose contains a mess_block *)
    (* i.e. mb_qual, mb_st and mb_data must be *)
    (* disposed too                            *)
    mblock_ptr := @curr.cdir_ptr^.cd_sysinfo;
    ak10free_mblock (acv, mblock_ptr^)
    END;
(*ENDIF*) 
curr.cdir_ptr^.cd_lru_next.cdir_ptr := NIL;
curr.cdir_ptr^.cd_fix_next.cdir_ptr := NIL;
ak10block_into_freelist (acv, curr, NOT c_del_in_directory, c_del_dependecies);
p := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10find_result (
            VAR acv        : tak_all_command_glob;
            VAR pars_key   : tak_parskey;
            dstate         : tak_directory_state;
            VAR syspoint   : tak_sysbufferaddress;
            VAR b_err      : tgg00_BasisError);
 
CONST
      c_prefix_len = 4;
 
VAR
      res     : tsp00_LcompResult;
      curr    : tak_cache_dir_pointer;
      syskey  : tgg00_SysInfoKey;
 
BEGIN
IF  acv.a_planHandle <> NIL
THEN
    BEGIN
    syspoint := a101_DescribeParseId (acv.a_planHandle);
    IF  syspoint = NIL
    THEN
        b_err := e_no_next_record
    ELSE
        b_err := e_ok;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    syskey              := a01sysnullkey;
    syskey.sentrytyp    := cak_eresult;
    syskey.sauthid      := cgg_zero_id;
    syskey.sauthid[ 1 ] := chr(255);
    SAPDB_PascalForcedMove (sizeof (pars_key), sizeof(syskey.sauthid),
          @pars_key, 1, @syskey.sauthid, 2, 3);
&   ifdef trace
    t01catalog_entrytype( ak_sem, syskey.sentrytyp[ 2 ] );
    t01buf1 (ak_cach, syskey, cgg_rec_key_offset+1,
          syskey.skeylen + cgg_rec_key_offset);
&   endif
    b_err := e_no_next_record;
    curr  := acv.a_sysdir.ci_dir [ord (syskey.sentrytyp[2])];
    WHILE curr.cdir_ptr <> NIL DO
        WITH curr.cdir_ptr^ DO
            BEGIN
            IF  cd_check <> cak_cache_chunk_flag
            THEN
                BEGIN
                ak10cache_error (acv, 'a10find_result          ', curr);
                curr.cdir_ptr := NIL
                END
            ELSE
                BEGIN
                s30cmp (syskey, cgg_rec_key_offset+1, c_prefix_len,
                      cd_syskey, cgg_rec_key_offset+1, c_prefix_len, res);
                IF  res = l_equal
                THEN
                    BEGIN
                    (* PTS 1112421 E.Z. *)
                    (* do not find a from-select-eresult-buffer ! *)
                    (* they have ffill (byte 5/6) set to 0        *)
                    IF  (cd_syskey.stableid[5] = chr(0)) AND
                        (cd_syskey.stableid[6] = chr(0))
                    THEN
                        BEGIN
                        (* from-select-eresult-buffer found *)
                        curr := curr.cdir_ptr^.cd_greater
                        END
                    ELSE
                        BEGIN
                        syskey          := cd_syskey;
                        syskey.slinkage := cak_init_linkage;
                        a10get_sysinfo (acv, syskey,
                              dstate, syspoint, b_err);
                        curr.cdir_ptr := NIL
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  res = l_greater
                    THEN
                        curr := curr.cdir_ptr^.cd_greater
                    ELSE
                        curr := curr.cdir_ptr^.cd_less
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
    IF  b_err = e_no_next_record
    THEN
        BEGIN
        IF  (syskey.stableid[5] = chr(0)) AND
            (syskey.stableid[6] = chr(0))
        THEN
            syskey.stableid[6] := chr(1);
        (*ENDIF*) 
        a10next_sysinfo (acv, syskey, c_prefix_len, dstate,
              syskey.sentrytyp, syspoint, b_err)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_fix_len_get_sysinfo (
            VAR acv      : tak_all_command_glob;
            VAR syskey   : tgg00_SysInfoKey;
            dstate       : tak_directory_state;
            required_len : integer;
            plus         : integer;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
VAR
      dummy       : boolean;
      rel_sysinfo : boolean;
      fix_next    : tak_cache_dir_pointer;
      fix_prev    : tak_cache_dir_pointer;
      p           : tak_cache_dir_pointer;
      old_entry   : tak_cache_dir_e_ptr;
      req_len     : tsp00_Int4;
      find_info   : tak10_find_info;
 
BEGIN
&ifdef trace
t01int4 (ak_cach, 'required_len', required_len);
t01int4 (ak_cach, 'plus        ', plus);
&endif
a10get_sysinfo (acv, syskey, dstate, syspoint, b_err);
IF  b_err = e_ok
THEN
    BEGIN
    req_len := required_len;
    IF  plus <= 0
    THEN
        plus := req_len - syspoint^.b_sl;
    (*ENDIF*) 
    IF  (syspoint^.b_sl + plus > sizeof (tsp00_Buf)) AND
        NOT (syskey.sentrytyp[2] in
        [cak_ccolnames, cak_cjparsinfo, cak_cparsinfo, cak_cshortinfo,
        cak_creskey, cak_clinkpos, cak_clongliteral])
    THEN
        plus := sizeof (tsp00_Buf) - syspoint^.b_sl;
    (*ENDIF*) 
    IF  plus > 0
    THEN
        BEGIN
&       ifdef trace
        t01buf1 (ak_cach, syskey, 1,
              syskey.skeylen + cgg_rec_key_offset);
&       endif
        ak10find_syskey (acv, syskey, find_info, NOT cak10CheckReferences);
&       ifdef trace
        t01buf1 (ak_cach, syskey, 1,
              syskey.skeylen + cgg_rec_key_offset);
&       endif
        WITH acv.a_sysdir DO
            IF  find_info.fi_ptr.cdir_ptr^.cd_syslen <
                mxak_cache_dir_entry + syspoint^.b_sl + plus
            THEN
                BEGIN
&               ifdef trace
                xtd_directory (ak_cach, find_info.fi_ptr);
&               endif
                old_entry := find_info.fi_ptr.cdir_ptr;
                fix_next  := old_entry^.cd_fix_next;
                fix_prev  := old_entry^.cd_fix_prev;
                IF  fix_next.cdir_ptr = NIL
                THEN
                    BEGIN
                    (* prevent record from being removed from cache *)
                    a10get_sysinfo (acv, syskey,
                          d_fix, syspoint, b_err);
                    rel_sysinfo := dstate = d_release
                    END
                ELSE
                    rel_sysinfo := false;
                (*ENDIF*) 
                req_len   :=
                      mxak_cache_dir_entry + syspoint^.b_sl + plus;
                IF  syskey.sentrytyp[2] in
                    [cak_ccolnames, cak_cjparsinfo, cak_cparsinfo,
                    cak_cshortinfo, cak_creskey, cak_clinkpos, cak_clongliteral]
                THEN
                    ak10size_check (acv,
                          syskey.sentrytyp, syspoint^.b_sl + plus);
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    ak10getmem (acv,
                          cak_is_undefined, req_len, p.buf_ptr);
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    WITH p.cdir_ptr^ DO
                        BEGIN
                        SAPDB_PascalMove ('VAK10 ',   5,    
                              sizeof (syspoint^),
                              sizeof (p.sys_ptr^), @syspoint^, 1,
                              @cd_sysinfo, 1, syspoint^.b_sl,
                              acv.a_returncode);
                        syspoint         := @cd_sysinfo;
                        cd_create_cmd_no := acv.a_command_id;
                        cd_cmd_no        := old_entry^.cd_cmd_no;
                        cd_state         := old_entry^.cd_state;
                        (*===== release old block ============*)
                        old_entry^.cd_state := old_entry^.cd_state - [ddisplace]; (* PTS 1110796 *)
                        ak10block_into_freelist (acv,
                              find_info.fi_ptr, c_del_in_directory,
                              NOT c_del_dependecies);
                        (*===== chain to top of lru list =====*)
                        p.cdir_ptr^.cd_lru_next :=
                              ci_cache_dir_header.cdir_ptr^.cd_lru_next;
                        p.cdir_ptr^.cd_lru_prev := ci_cache_dir_header;
                        ci_cache_dir_header.cdir_ptr^.cd_lru_next := p;
                        p.cdir_ptr^.cd_lru_next.cdir_ptr^.cd_lru_prev := p;
                        p.cdir_ptr^.cd_fix_next := fix_next;
                        p.cdir_ptr^.cd_fix_prev := fix_prev;
                        IF  fix_next.cdir_ptr <> NIL
                        THEN
                            BEGIN
                            fix_prev.cdir_ptr^.cd_fix_next := p;
                            fix_next.cdir_ptr^.cd_fix_prev := p
                            END;
                        (*ENDIF*) 
                        ak10ins_directory (acv, find_info,
                              ci_dir [ord (cd_syskey.sentrytyp[2])],
                              p, dummy);
                        IF  rel_sysinfo
                        THEN
                            a10rel_sysinfo (syspoint)
                        (*ENDIF*) 
                        END;
                    (*ENDWITH*) 
&               ifdef trace
                (*ENDIF*) 
                xtd_directory (ak_cach, p);
&               endif
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        END
    (*ENDIF*) 
    END
ELSE
    IF  b_err = e_sysinfo_not_found
    THEN
        BEGIN
        a10_nil_get_sysinfo (acv, syskey, dstate,
              required_len, syspoint, b_err);
        IF  b_err = e_ok
        THEN
            b_err := e_sysinfo_not_found;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  (b_err <> e_ok) AND (b_err <> e_sysinfo_not_found)
THEN
    a07_b_put_error (acv, b_err, 1);
&ifdef TRACE
(*ENDIF*) 
ak10verify_cache (acv)
&     endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10fill_mblock_info (
            VAR mblock_rec  : tak_messblock_record;
            VAR mblock_info : tak10_mblock_info;
            VAR part_cnt    : integer);
&     ifdef trace
 
VAR
      ix  : integer;
      len : integer;
&     endif
 
BEGIN
WITH mblock_rec, mbr_mess_block DO
    BEGIN
&   ifdef trace
    t01int4 (ak_cach, 'mbs_stack_le', mbr_stack_len);
&   endif
    part_cnt := 0;
    IF  (mb_qual_len > 0) AND (mb_qual <> NIL)
    THEN
        BEGIN
        mblock_info[1].addr := @mb_qual^;
        mblock_info[1].size := mb_qual_size;
        mblock_info[1].len  := mb_qual_len;
        part_cnt            := 1;
        END;
    (*ENDIF*) 
    IF  mbr_stack_len > 0
    THEN
        BEGIN
        part_cnt                   := part_cnt + 1;
        mblock_info[part_cnt].addr := @mb_st^;
        mblock_info[part_cnt].size := mb_st_size;
        mblock_info[part_cnt].len  := mbr_stack_len
&             ifdef trace
              ;
        ix  := 1;
        len := 0;
        WHILE len < mbr_stack_len DO
            BEGIN
            t01stackentry (ak_cach, mb_st^[ix], ix);
            len := len + sizeof (tgg00_StackEntry);
            ix  := ix + 1;
            END;
        (*ENDWHILE*) 
&       endif
        END;
    (*ENDIF*) 
    IF  (mb_data_len > 0) AND (mb_data <> NIL)
    THEN
        BEGIN
        part_cnt := part_cnt + 1;
        mblock_info[part_cnt].addr := @mb_data^;
        mblock_info[part_cnt].size := mb_data_size;
        mblock_info[part_cnt].len  := mb_data_len;
        END;
    (*ENDIF*) 
    IF  (mb_strat_len > 0) AND (mb_strat <> NIL)
    THEN
        BEGIN
        part_cnt := part_cnt + 1;
        mblock_info[part_cnt].addr := @mb_strat^;
        mblock_info[part_cnt].size := mb_strat_size;
        mblock_info[part_cnt].len  := mb_strat_len;
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef trace
FOR ix := 1 TO part_cnt DO
    t01p2int4 (ak_cach, 'size        ', mblock_info[ix].size,
          'len         ', mblock_info[ix].len);
(*ENDFOR*) 
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      a10GetRefCount (
            syspoint   : tak_sysbufferaddress) : integer;
 
VAR
      curr : tak_cache_dir_pointer;
 
BEGIN
IF  syspoint <> NIL
THEN
    BEGIN
    curr.sys_ptr := syspoint;
    curr.buf_ptr := s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
    a10GetRefCount := curr.cdir_ptr^.cd_refCount;
    END
ELSE
    a10GetRefCount := 0;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a10IncopyTableInit (VAR acv : tak_all_command_glob;
            VAR key     : tgg00_SysInfoKey;
            colCount    : integer) : tak_sysbufferaddress;
 
VAR
      colinfoHeadLen : integer;
      requiredLen    : integer;
      e              : tgg00_BasisError;
      firstindex     : integer;
      pBase          : ^tak_baserecord;
      syspoint       : tak_sysbufferaddress;
      syskey         : tgg00_SysInfoKey;
 
      p         : RECORD
            CASE boolean OF
                true :
                    (mobj : tak_sysbufferaddress);
                false :
                    (cip  : tak_basecolinfo_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  acv.a_is_ddl <> no_ddl
THEN
    colCount := MAX_COL_PER_TAB_GG00;
(*ENDIF*) 
pBase           := @acv;
firstindex      := a11firstindex (colCount, pBase^);
syskey          := key;
a10_nil_get_sysinfo (acv, syskey, d_release,
      sizeof (tak_baserecord) -
      sizeof (pBase^.bcolumn) +
      (firstindex + colCount) * sizeof (pBase^.bcolumn[1]), syspoint, e);
IF  e = e_ok
THEN
    WITH syspoint^.sbase DO
        BEGIN
        bfirstindex := firstindex;
        (* 4096 is a constant from heaven, has nothing to do with tsp00_Buf or so *)
        colinfoHeadLen := sizeof(tak_basecolinfo) - 4096;
        requiredLen    := colinfoHeadLen
              +
              1 *
              ((sizeof(tsp00_KnlIdentifier) - 1) DIV sizeof (tak_align) + 1) * sizeof (tak_align)
              +
              colCount *
              ((sizeof(tak00_columninfo) - sizeof(tsp00_KnlIdentifier) + a01identifier_size - 1)
              DIV sizeof (tak_align) + 1) * sizeof (tak_align);
        IF  requiredLen > sizeof (tak_basecolinfo)
        THEN
            requiredLen := sizeof (tak_basecolinfo);
        (*ENDIF*) 
        a10new (acv, requiredLen, p.mobj);
        IF  p.mobj <> NIL
        THEN
            BEGIN
            p.cip^.bci_buf_size := requiredLen - colinfoHeadLen;
            bptr                := p.cip;
            bptr^.bci_index     := 1;
            breccnt             := 1;
            bptr^.bci_next      := NIL;
            bptr^.bci_ref_cnt   := 1;
            END
        ELSE
            BEGIN
            bptr := NIL;
            a10key_del (acv, syspoint);
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
a10IncopyTableInit := syspoint;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10InsertIntoCatalog (
            VAR acv      : tak_all_command_glob;
            VAR rec      : tgg00_Rec;
            doInsert     : boolean);
 
VAR
      e : tgg00_BasisError;
      p : tak_sysbufferaddress;
 
VAR
      mType : tgg00_MessType;
 
BEGIN
p := @rec;
IF  p^.syskey.sentrytyp > cak_etemp
THEN
    BEGIN
    IF  doInsert
    THEN
        b07cadd_record (acv.a_transinf.tri_trans, acv.a_pars_curr, p^)
    ELSE
        b07crepl_record (acv.a_transinf.tri_trans, acv.a_pars_curr, p^);
    (*ENDIF*) 
    e := acv.a_transinf.tri_trans.trError_gg00;
    END
ELSE
    BEGIN
    IF  doInsert
    THEN
        mType := m_insert
    ELSE
        mType := m_update_rec;
    (*ENDIF*) 
    ak10send_ins_upd (acv, p, mType, e);
    END;
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a10SetColumnAndName (VAR acv : tak_all_command_glob;
            VAR base_rec     : tak_baserecord;
            columnIndex      : integer;
            columnNameLength : integer) : tak00_colinfo_ptr;
 
VAR
      colinfo_len     : integer;
      curr            : tak_basecolinfo_ptr;
 
      p         : RECORD
            CASE boolean OF
                true :
                    (mobj : tak_sysbufferaddress);
                false :
                    (cip  : tak_basecolinfo_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
curr := base_rec.bptr;
(* find last column buffer *)
WHILE curr^.bci_next <> NIL DO
    curr := curr^.bci_next;
(*ENDWHILE*) 
&ifdef trace
t01int4 (ak_sem, 'bci_index   ', curr^.bci_index);
t01int4 (ak_sem, 'bci_buf_size', curr^.bci_buf_size);
&endif
colinfo_len := sizeof (tak00_columninfo) -
      sizeof(tsp00_KnlIdentifier) + columnNameLength;
IF  curr^.bci_index - 1 + colinfo_len > curr^.bci_buf_size
THEN
    BEGIN
    (* column info does not fit into current buffer *)
    (* allocate succ buffer                         *)
    a10new (acv, sizeof (tak_basecolinfo), p.mobj);
    curr^.bci_next := p.cip;
    IF  curr^.bci_next <> NIL
    THEN
        BEGIN
        curr               := curr^.bci_next;
        curr^.bci_buf_size := sizeof(curr^.bci_buf);
        curr^.bci_index    := 1;
        curr^.bci_ref_cnt  := 1;
        curr^.bci_next     := NIL
        END
    ELSE
        a07_b_put_error (acv, e_no_more_memory, 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    base_rec.bcolumn[columnIndex] := @curr^.bci_buf[curr^.bci_index];
    base_rec.bcolumn[columnIndex]^.ccolumnn_len := chr(columnNameLength);
    curr^.bci_index := curr^.bci_index +
          ((colinfo_len - 1) DIV sizeof (tak_align) + 1)
          * sizeof(tak_align);
    a10SetColumnAndName := base_rec.bcolumn[columnIndex];
    END
ELSE
    a10SetColumnAndName := NIL;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10SetMigrationProtTabid (
            tableNo   : integer;
            VAR Tabid : tgg00_Surrogate);
 
BEGIN
ak10ExplicitMigTables [tableNo] := Tabid;
END;
 
(*------------------------------*) 
 
FUNCTION
      ak10IsExplicitMigTable (
            VAR tabId : tgg00_Surrogate) : boolean;
 
VAR
      i     : integer;
      found : boolean;
 
BEGIN
ak10IsExplicitMigTable := false;
i     := 1;
found := false;
WHILE (i <= c_explicitMigTableCount) AND
      NOT found DO
    BEGIN
    IF  tabId = ak10ExplicitMigTables [i]
    THEN
        BEGIN
        ak10IsExplicitMigTable := true;
        found                  := true;
        END;
    (*ENDIF*) 
    i := succ(i);
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10flush (
            VAR acv : tak_all_command_glob;
            VAR syskey           : tgg00_SysInfoKey;
            disable_cmd_rollback : boolean);
 
VAR
      cmdId     : tsp00_Int4;
      find_info : tak10_find_info;
 
BEGIN
ak10find_syskey (acv, syskey, find_info, NOT cak10CheckReferences);
IF  (find_info.fi_res = l_equal) AND (syskey.sentrytyp > cak_etemp)
THEN
    BEGIN
    cmdId := acv.a_command_id;
    IF  disable_cmd_rollback
    THEN
        acv.a_command_id := -1;
    (*ENDIF*) 
    ak10temp_add (acv, find_info.fi_ptr, NOT c_is_rollback);
    acv.a_command_id := cmdId
    END
ELSE
    BEGIN
    a07_b_put_error  (acv, e_sysinfo_not_found, 1);
    ak10store_syskey (acv, syskey)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10FlushResnames (
            VAR acv : tak_all_command_glob;
            p               : tak_cache_dir_pointer);
 
BEGIN
IF  p.cdir_ptr <> NIL
THEN
    WITH p.cdir_ptr^ DO
        BEGIN
        ak10temp_add      (acv, p, NOT c_is_rollback);
        ak10FlushResnames (acv, cd_less);
        ak10FlushResnames (acv, cd_greater);
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10FlushResnames (
            VAR acv : tak_all_command_glob);
 
VAR
      aux : tsp00_C2;
 
BEGIN
aux := cak_eresname;
ak10FlushResnames (acv, acv.a_sysdir.ci_dir[ord(aux[2])])
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10free_cache (
            VAR acv : tak_all_command_glob);
 
VAR
      p         : tsp00_ObjAddr;
      next      : tak_cache_dir_pointer;
 
      aux_ptr : RECORD
            CASE integer OF
                1 :
                    (bufaddr : tsp00_BufAddr);
                2 :
                    (chptr   : tak10cache_header_ptr);
                3 :
                    (objptr  : tsp00_ObjAddr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  acv.a_sysdir.ci_cache_p <> NIL
THEN
    BEGIN
    WITH acv.a_sysdir DO
        BEGIN
        next := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
        WHILE next.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
            WITH next.cdir_ptr^ DO
                BEGIN
                IF  dreference in cd_state
                THEN
                    a103ReleaseCacheHandle (acv, cd_ref.cd_globalCacheHandle, cd_ref.cd_nextRef.cdir_ptr <> NIL)
                ELSE
                    IF  cd_syskey.sentrytyp[2] = cak_cresult
                    THEN
                        IF  (cd_sysinfo.sbase.bptr <> NIL) AND (cd_sysinfo.sbase.bptr^.bci_index = 0)
                        THEN (* reference to shared column buffer, release it *)
                            a101_DetachColumnBuffer (acv, @cd_sysinfo.sbase);
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                next := next.cdir_ptr^.cd_lru_prev;
                END;
            (*ENDWITH*) 
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
    aux_ptr.bufaddr := acv.a_sysdir.ci_cache_p;
    vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
    WHILE aux_ptr.bufaddr <> NIL DO
        BEGIN
        ak10all_cache_size :=
              ak10all_cache_size - aux_ptr.chptr^.ch_size;
        p               := aux_ptr.objptr;
        aux_ptr.bufaddr := aux_ptr.chptr^.ch_next_cache;
        vmfree (p)
        END;
    (*ENDWHILE*) 
    ak10cache_cnt := ak10cache_cnt - 1;
    vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
    acv.a_sysdir.ci_cache_p := NIL
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10ResetStatistics (
            VAR acv         : tak_all_command_glob);
 
BEGIN
acv.a_sysdir.ci_tmp_read_cnt := 0;
acv.a_sysdir.ci_tmp_read_cnt := 0;
END;
 
(*------------------------------*) 
 
FUNCTION
      a10GetCreateCommandId (syspointer : tak_sysbufferaddress) : tsp00_Int4;
 
VAR
      curr   : tak_cache_dir_pointer;
 
BEGIN
a10GetCreateCommandId := cak_is_undefined;
IF  syspointer <> NIL
THEN
    BEGIN
    IF  NOT ak10_IsSharedRecord (syspointer)
    THEN
        BEGIN
        curr.sys_ptr := syspointer;
        curr.buf_ptr :=
              s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
        a10GetCreateCommandId := curr.cdir_ptr^.cd_create_cmd_no;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10GetStatistics (
            VAR acv         : tak_all_command_glob;
            resetStatistics : boolean;
            VAR accessCount : tsp00_Int4;
            VAR successful  : tsp00_Int4;
            VAR hitRate     : integer);
 
BEGIN
accessCount := acv.a_sysdir.ci_tmp_read_cnt;
successful  := acv.a_sysdir.ci_tmp_read_cnt;
hitRate     := a10hit_rate (acv) DIV 10;
END;
 
(*------------------------------*) 
 
FUNCTION
      ak10RestartIterator (p : tak_cache_dir_pointer) : boolean;
 
VAR
      doRestart  : boolean;
      mblock_ptr : tgg00_MessBlockPtr;
 
BEGIN
doRestart := false;
IF  NOT (dreference in p.cdir_ptr^.cd_state)
    AND
    (p.cdir_ptr^.cd_syskey.sentrytyp[2] in [cak_cmessblock, cak_cpermmessblock, cak_ctriggerparsinfo])
THEN
    WITH p.cdir_ptr^.cd_sysinfo.smessblock.mbr_mess_block DO
        BEGIN
        (* this is the code of a user defined function, which will drop all parse infos *)
        (* stored in that code. This invalidates iterators runnung over the cache       *)
        doRestart := (mb_type = m_procedure) AND (mb_type2 = mm_ignore);
        END;
    (*ENDWITH*) 
&ifdef trace
(*ENDIF*) 
t01int4 (ak_cach, 'RestartItera', ord(doRestart));
&endif
ak10RestartIterator := doRestart
END;
 
(*------------------------------*) 
 
FUNCTION
      a10hit_rate (
            VAR acv : tak_all_command_glob) : integer;
 
BEGIN
WITH acv.a_sysdir DO
    a10hit_rate := ak10hit_rate (ci_tmp_read_found, ci_tmp_read_cnt)
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10increment_ap_tree (
            VAR acv : tak_all_command_glob);
 
VAR
      e              : tgg00_BasisError;
      curr           : tak_cache_dir_pointer;
      prev           : tak_cache_dir_pointer;
      found          : tak_cache_dir_pointer;
      ap_ptr         : tak_cache_dir_pointer;
      p              : tak_sysbufferaddress;
      required_len   : tsp00_Int4;
      assigned_len   : tsp00_Int4;
      pos            : tsp00_Int4;
      tree_start_pos : tsp00_Int4;
      new_max_node   : tsp00_Int4;
 
      aux_ptr : RECORD
            CASE integer OF
                1 :
                    (ap : tak_ap_max_tree_ptr);
                2 :
                    (cdir : tak_cache_dir_e_ptr);
                3 :
                    (buf_ptr : tsp00_BufAddr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  acv.a_ap_max_node < cak_max_node
THEN
    BEGIN
    IF  acv.a_ap_tree = acv.a_session_ap_tree
    THEN
        BEGIN (* session syntax tree lying in ak cache *)
&       ifdef trace
        t01int4 (ak_sem, 'scv_index   ', acv.a_scv_index);
        t01int4 (ak_sem, 'max_ap_node ', acv.a_ap_max_node);
        ak10td_freelist (acv, ak_cach);
&       endif
        aux_ptr.ap      := acv.a_ap_tree;
        ap_ptr.buf_ptr  :=
              s35add_bufaddr_ptocm (aux_ptr.buf_ptr, - mxak_cache_dir_entry);
        tree_start_pos := ap_ptr.cdir_ptr^.cd_pos + mxak_cache_dir_entry;
&       ifdef trace
        t01int4 (ak_sem, 'tree_start_p', tree_start_pos);
&       endif
        found := ap_ptr;
        WHILE found.cdir_ptr <> NIL DO
            BEGIN
            pos   := found.cdir_ptr^.cd_pos;
&           ifdef trace
            t01int4 (ak_sem, 'pos         ', pos);
            t01int4 (ak_sem, 'len         ',
                  found.cdir_ptr^.cd_syslen - mxak_cache_dir_entry);
            t01int4 (ak_sem, 'syslen      ',
                  found.cdir_ptr^.cd_syslen);
&           endif
            prev  := found;
            found := found.cdir_ptr^.cd_fix_next
            END;
        (*ENDWHILE*) 
        required_len := (cak_next_node + 1) * sizeof (tak_ap_node);
        ak10get_next_avail (acv, required_len,
              pos, assigned_len, curr.buf_ptr);
        IF  curr.buf_ptr <> NIL
        THEN
            BEGIN
&           ifdef trace
            ak10td_freelist (acv, ak_cach);
            t01int4 (ak_sem, 'curr addr   ', curr.i + mxak_cache_dir_entry);
&           endif
            WITH curr.cdir_ptr^ DO
                BEGIN
                cd_fix_next.cdir_ptr   := NIL;
                cd_syslen              := assigned_len +
                      mxak_cache_dir_entry;
                cd_mem_type        := dyn_syntax_tree;
                p                  := @cd_sysinfo
                END;
            (*ENDWITH*) 
            prev.cdir_ptr^.cd_fix_next := curr;
&           ifdef trace
            t01int4 (ak_sem, 'assigned pos', curr.cdir_ptr^.cd_pos);
            t01int4 (ak_sem, 'assigned len', assigned_len);
&           endif
            pos              := tree_start_pos;
            acv.a_scv_index  := 0;
            WHILE pos < curr.cdir_ptr^.cd_pos + mxak_cache_dir_entry DO
                BEGIN
                acv.a_scv_index := acv.a_scv_index + 1;
                pos             := pos + sizeof (tak_ap_node);
                END;
            (*ENDWHILE*) 
            (* Let last tree node of prev piece of syntax *)
            (* tree point to first index of succ piece    *)
            acv.a_ap_tree^[acv.a_ap_max_node + 1].n_pos := acv.a_scv_index;
            ;
            acv.a_scv_index    := acv.a_scv_index - 1;
            new_max_node       := acv.a_scv_index + (assigned_len -
                  (pos - curr.cdir_ptr^.cd_pos - mxak_cache_dir_entry))
                  DIV  sizeof (tak_ap_node);
            IF  ( new_max_node < cak_max_node )
            THEN
                BEGIN
                acv.a_ap_max_node := new_max_node;
                WITH acv.a_ap_tree^[acv.a_ap_max_node] DO
                    BEGIN (* mark end of current piece *)
                    n_proc     := a10;
                    n_special  := [ni_skip_node];
                    n_pos      := 0;
                    n_sa_level := 0;
                    n_lo_level := 0
                    END;
                (*ENDWITH*) 
                acv.a_ap_max_node := acv.a_ap_max_node - 1;
                END
            ELSE
                BEGIN
                a07_b_put_error (acv, e_stack_overflow, 1);
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
&           ifdef trace
            ak10td_dirlist  (acv, td_always);
&           endif
            ak10no_more_memory (acv, e);
            a07_b_put_error (acv, e, 1)
            END;
        (*ENDIF*) 
&       ifdef trace
        FOR pos := acv.a_scv_index + 1 TO acv.a_ap_max_node DO
            WITH acv.a_ap_tree^[pos] DO
                BEGIN
                n_proc     := a90;
                n_special  := [];
                n_symb     := s_identifier;
                n_datatype := dunknown;
                n_subproc  := 0;
                n_length   := 0;
                n_pos      := 0;
                n_lo_level := 0;
                n_sa_level := 0;
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
        t01int4 (ak_sem, 'scv_index   ', acv.a_scv_index);
        t01int4 (ak_sem, 'max_ap_node ', acv.a_ap_max_node);
        ak10verify_cache (acv);
&       endif
        END
    ELSE
        BEGIN (* syntax tree of stacked sql statement *)
        a101_IncrementSyntaxTree (acv);
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    a07_b_put_error (acv, e_stack_overflow, 1);
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10inquire_resnames (
            VAR acv         : tak_all_command_glob;
            VAR cnt         : tsp00_Int4;
            VAR resname_arr : tak_resn_rec_arr);
 
VAR
      aux    : tsp00_C2;
      syskey : tgg00_SysInfoKey;
 
BEGIN
syskey.sauthid        := resname_arr[ cnt ].reskey_idfill;
syskey.sentrytyp      := cak_eresname;
syskey.srestablen     := resname_arr[ cnt ].reskey_name;
syskey.sresmodul_name := resname_arr[ cnt ].reskey_modul_name;
syskey.skeylen        := SURROGATE_MXGG00 + mxak_entry_type +
      sizeof (resname_arr[ cnt ].reskey_name) +
      sizeof (resname_arr[ cnt ].reskey_modul_name);
cnt                   := 0;
aux                   := cak_eresname;
ak10inq_resname (acv, syskey,
      acv.a_sysdir.ci_dir[ ord(aux[ 2 ]) ], cnt, resname_arr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10intermediate_mblock (
            VAR acv        : tak_all_command_glob;
            VAR mblock     : tgg00_MessBlock;
            VAR mblock_ptr : tgg00_MessBlockPtr);
 
VAR
      b_err        : tgg00_BasisError;
      stack_len    : tsp00_Int4;
      required_len : tsp00_Int4;
      univ_p       : tak_cache_dir_pointer;
 
BEGIN
required_len := mxak_cache_dir_entry + sizeof (mblock);
ak10getmem (acv, cak_is_undefined, required_len, univ_p.buf_ptr);
IF  univ_p.buf_ptr <> NIL
THEN
    WITH univ_p.cdir_ptr^ DO
        BEGIN
        cd_mem_type := dyn_mess_block;
        mblock_ptr  := @cd_sysinfo
        END
    (*ENDWITH*) 
ELSE
    mblock_ptr := NIL;
(*ENDIF*) 
IF  mblock_ptr <> NIL
THEN
    BEGIN
    mblock_ptr^  := mblock;
    stack_len    := cak_is_undefined;
    ak10space_for_mblock (acv, mblock, stack_len, mblock_ptr^, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        mblock_ptr^.mb_data_len := 0;
        a06cpy_mblock (acv, mblock, mblock_ptr^, NOT cak10withoutData, b_err)
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        BEGIN
        mblock_ptr := NIL;
        a10dispose (acv, univ_p.sys_ptr);
        a07_b_put_error (acv, b_err, 1)
        END
    ELSE
        mblock_ptr^.mb_trailer.mb_trns := @acv.a_transinf.tri_trans
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10inq_resname (
            VAR acv         : tak_all_command_glob;
            VAR syskey      : tgg00_SysInfoKey;
            p               : tak_cache_dir_pointer;
            VAR cnt         : tsp00_Int4;
            VAR resname_arr : tak_resn_rec_arr);
 
VAR
      res : tsp00_LcompResult;
 
BEGIN
IF  (p.cdir_ptr <> NIL) AND (cnt < cak_max_resn)
THEN
    WITH p.cdir_ptr^ DO
        BEGIN
        s30cmp (syskey, cgg_rec_key_offset+1, syskey.skeylen,
              cd_syskey, cgg_rec_key_offset+1, syskey.skeylen, res);
        IF  res = l_less
        THEN
            BEGIN
            ak10inq_resname (acv, syskey, cd_less, cnt, resname_arr);
            IF  cnt < cak_max_resn
            THEN
                BEGIN
                (* PTS 1106167 E.Z. *)
                IF  (NOT (dwritten in cd_state)) AND
                    NOT
                    (
                    (cd_syskey.sentrytyp[2] = cak_cresname) AND
                    (cd_syskey.sauthid = acv.a_curr_user_id)
                    )
                THEN
                    BEGIN
                    cnt := cnt + 1;
                    resname_arr[cnt] := cd_sysinfo.sresname;
                    END;
                (*ENDIF*) 
                ak10inq_resname (acv, syskey, cd_greater, cnt, resname_arr)
                END
            (*ENDIF*) 
            END
        ELSE
            ak10inq_resname (acv, syskey, cd_greater, cnt, resname_arr)
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10ins_or_upd (
            VAR acv      : tak_all_command_glob;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
VAR
      curr      : tak_cache_dir_pointer;
      find_info : tak10_find_info;
 
BEGIN
IF  syspoint^.syskey.sentrytyp > cak_etemp
THEN
    BEGIN
    curr.sys_ptr := syspoint;
    curr.buf_ptr :=
          s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
    IF  NOT ak10IsSharedSQLRecord (curr)
    THEN
        BEGIN
        ak10find_syskey (acv, syspoint^.syskey, find_info, NOT cak10CheckReferences);
        IF  find_info.fi_res = l_equal
        THEN
            BEGIN
            IF  find_info.fi_ptr.cdir_ptr <> NIL
            THEN
                WITH find_info.fi_ptr.cdir_ptr^ DO
                    IF  dwritten in cd_state
                    THEN
                        cd_state := cd_state + [dmodified]
                    ELSE
                        cd_state := cd_state + [dadd_rec];
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDIF*) 
            b_err := e_ok
            END
        ELSE
            BEGIN
            b_err := e_sysinfo_not_found;
            ak10store_syskey (acv, syspoint^.syskey)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END
ELSE
    b_err := e_illegal_key
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10InsertKeptRecord (
            VAR acv    : tak_all_command_glob;
            syspointer : tak_sysbufferaddress);
 
VAR
      curr      : tak_cache_dir_pointer;
      find_info : tak10_find_info;
      dummy     : boolean;
 
BEGIN
IF  syspointer <> NIL
THEN
    BEGIN
    ak10find_syskey (acv, syspointer^.syskey, find_info, NOT cak10CheckReferences);
    IF  find_info.fi_res = l_equal
    THEN
        a07_b_put_error (acv, e_duplicate_sysinfo, 1)
    ELSE
        BEGIN
        curr.sys_ptr := syspointer;
        curr.buf_ptr :=
              s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
        ak10ins_directory (acv, find_info,
              acv.a_sysdir.ci_dir [ord(syspointer^.syskey.sentrytyp[2])],
              curr, dummy);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10invalidate_root (
            VAR acv    : tak_all_command_glob;
            VAR treeid : tgg00_FileId);
 
VAR
      aux : tsp00_C2;
 
BEGIN
aux := cak_etable;
ak10invalidate_root (treeid,
      acv.a_sysdir.ci_dir[ ord(aux[ 2 ]) ])
END;
 
(*------------------------------*) 
 
FUNCTION
      a10is_fixed (
            VAR acv : tak_all_command_glob;
            p       : tak_sysbufferaddress) : boolean;
 
VAR
      fi : tak10_find_info;
 
BEGIN
a10is_fixed := false;
IF  p <> NIL
THEN
    ak10find_syskey (acv, p^.syskey, fi, NOT cak10CheckReferences);
(*ENDIF*) 
IF  fi.fi_ptr.cdir_ptr <> NIL
THEN
    BEGIN
&   ifdef trace
    xtd_directory (ak_sem, fi.fi_ptr);
&   endif
    a10is_fixed := fi.fi_ptr.cdir_ptr^.cd_fix_next.cdir_ptr <> NIL
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10lock_fixed (
            VAR acv : tak_all_command_glob);
 
BEGIN
ak10lock_unlock_fixed (acv, true)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10gap_dispose (
            VAR used_blocks : tak10_used_blocks;
            VAR p : tak_sysbufferaddress);
 
VAR
      curr : tak_cache_dir_pointer;
 
BEGIN
curr.sys_ptr := p;
curr.buf_ptr := s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
ak10add_block (used_blocks, curr.cdir_ptr^.cd_pos,
      curr.cdir_ptr^.cd_buf_no, curr.cdir_ptr^.cd_syslen);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10gaps_baserecord (
            VAR used_blocks : tak10_used_blocks;
            VAR baserec     : tak_baserecord);
 
VAR
      p   : tak_basecolinfo_ptr;
      aux : tak_sysbufferaddress;
 
BEGIN
IF  baserec.btablekind <> tsynonym
THEN
    IF  baserec.bptr <> NIL
    THEN
        BEGIN
        p  := baserec.bptr;
        WHILE p <> NIL DO
            BEGIN
            aux := @p^;
            p   := p^.bci_next;
            a10gap_dispose (used_blocks, aux)
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10gap_free_colnamesrecord (
            VAR used_blocks : tak10_used_blocks;
            VAR colnamesrec : tak_columnnamesrecord);
 
VAR
      p    : tak_sysbufferaddress;
      next : tak_sysbufferaddress;
 
BEGIN
IF  colnamesrec.cnreclen = MAX_RECLEN_GG00
THEN
    BEGIN (* succ record(s) exist *)
    p := colnamesrec.cnnext;
    WHILE p <> NIL DO
        BEGIN
        IF  p^.b_sl = MAX_RECLEN_GG00
        THEN
            next := p^.scolnames.cnnext
        ELSE
            next := NIL;
        (*ENDIF*) 
        a10gap_dispose (used_blocks, p);
        p := next
        END
    (*ENDWHILE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10gap_free_mblock (
            VAR used_blocks : tak10_used_blocks;
            VAR mblock      : tgg00_MessBlock);
 
VAR
      ix            : integer;
 
      p             : ARRAY[1..4] OF RECORD
            CASE integer OF
                1 :
                    (buf_ptr  : tsp00_BufAddr);
                2 :
                    (qual_ptr : tgg00_QualBufPtr);
                3 :
                    (cdir_ptr : tak_cache_dir_pointer);
                4 :
                    (data_ptr : tgg00_DataPartPtr);
                5 :
                    (st_ptr   : tgg00_StackListPtr);
                6 :
                    (strat_ptr : tsp00_MoveObjPtr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
p[1].qual_ptr := mblock.mb_qual;
p[2].data_ptr := mblock.mb_data;
p[3].st_ptr   := mblock.mb_st;
p[4].strat_ptr := mblock.mb_strat;
FOR ix := 1 TO 4 DO
    IF  p[ix].buf_ptr <> NIL
    THEN
        BEGIN
&       ifdef trace
        t01addr (ak_cach, 'addr        ', p[ix].buf_ptr);
&       endif
        p[ix].buf_ptr :=
              s35add_bufaddr_ptocm (p[ix].buf_ptr,
              - mxak_cache_dir_entry);
&       ifdef trace
        t01addr (ak_cach, 'addr        ', p[ix].buf_ptr);
&       endif
        ak10add_block (used_blocks, p[ix].cdir_ptr.cdir_ptr^.cd_pos,
              p[ix].cdir_ptr.cdir_ptr^.cd_buf_no,
              p[ix].cdir_ptr.cdir_ptr^.cd_syslen);
        END;
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10gap_free_method_record (
            VAR used_blocks : tak10_used_blocks;
            VAR method : tak_methodrecord);
 
VAR
      ix : integer;
 
      p  : RECORD
            CASE boolean OF
                true :
                    (parm_ptr : tak_param_info_ptr);
                false :
                    (sys_ptr  : tak_sysbufferaddress);
                END;
            (*ENDCASE*) 
 
 
BEGIN
FOR ix := 1 TO method.me_param_cnt DO
    BEGIN
    p.parm_ptr := method.me_param_list[ix];
    IF  p.sys_ptr <> NIL
    THEN
        a10gap_dispose (used_blocks, p.sys_ptr)
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10look_for_gaps (
            VAR acv : tak_all_command_glob);
 
VAR
      ix          : integer;
      used_blocks : tak10_used_blocks;
      next        : tak_cache_dir_pointer;
      curr        : tak_cache_dir_pointer;
      ap_ptr      : tak_cache_dir_pointer;
      bufno       : integer;
      gap_pos     : tsp00_Int4;
      gap_len     : tsp00_Int4;
 
      prev_cache : RECORD
            CASE boolean OF
                true :
                    (bufaddr : tsp00_BufAddr);
                false :
                    (chptr   : tak10cache_header_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
used_blocks[1].pos := 0;
used_blocks[1].len := 0;
used_blocks[2].pos := csp_maxint4;
used_blocks[2].len := 0;
WITH acv.a_sysdir  DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        (* scan lru list first *)
        next := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
        WHILE next.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
            BEGIN
            curr := next;
            WITH curr.cdir_ptr^ DO
                BEGIN
&               ifdef trace
                t01buf1 (ak_cach, cd_syskey, cgg_rec_key_offset+1,
                      cd_syskey.skeylen + cgg_rec_key_offset);
&               endif
                next    := next.cdir_ptr^.cd_lru_prev;
                ak10add_block (used_blocks, cd_pos, cd_buf_no, cd_syslen);
                CASE cd_syskey.sentrytyp[2] OF
                    cak_ccolnames :
                        ak10gap_free_colnamesrecord (used_blocks, cd_sysinfo.scolnames);
                    cak_ctable, cak_cresult :
                        ak10gaps_baserecord (used_blocks, cd_sysinfo.sbase);
                    cak_cmessblock, cak_cpermmessblock, cak_ctriggerparsinfo :
                        ak10gap_free_mblock (used_blocks,
                              cd_sysinfo.smessblock.mbr_mess_block);
                    cak_cmethod :
                        ak10gap_free_method_record (used_blocks, cd_sysinfo.smethod);
                    OTHERWISE ;
                    END;
                (*ENDCASE*) 
                END;
            (*ENDWITH*) 
            END;
        (*ENDWHILE*) 
        (* scan free list *)
&       ifdef trace
        t01int4 (ak_cach, 'Free List   ', 1);
&       endif
        curr := acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_next_free;
        WHILE curr.buf_ptr <> acv.a_sysdir.ci_cache_dir_trailor.buf_ptr DO
            BEGIN
            WITH curr.cdir_ptr^ DO
                BEGIN
                ak10add_block (used_blocks, cd_block_pos, cd_buf_no, cd_syslen);
                curr := curr.cdir_ptr^.cd_next_free
                END;
            (*ENDWITH*) 
            END;
        (*ENDWHILE*) 
        (* syntax tree *)
        ap_ptr.buf_ptr := @acv.a_ap_tree^;
        ap_ptr.buf_ptr :=
              s35add_bufaddr_ptocm (ap_ptr.buf_ptr, - mxak_cache_dir_entry);
        ak10add_block (used_blocks, ap_ptr.cdir_ptr^.cd_pos,
              ap_ptr.cdir_ptr^.cd_buf_no, ap_ptr.cdir_ptr^.cd_syslen);
        curr := ap_ptr.cdir_ptr^.cd_fix_next;
        WHILE curr.cdir_ptr <> NIL DO
            BEGIN
            a10gap_dispose (used_blocks, curr.sys_ptr);
            curr := curr.cdir_ptr^.cd_fix_next
            END;
        (*ENDWHILE*) 
        prev_cache.bufaddr := acv.a_sysdir.ci_cache_p;
        bufno              := 0;
        WHILE prev_cache.chptr^.ch_next_cache <> NIL DO
            BEGIN
            bufno := bufno + 1;
            ak10add_block (used_blocks, 1, bufno, sizeof (prev_cache.chptr^));
            prev_cache.bufaddr := prev_cache.chptr^.ch_next_cache;
            END;
        (*ENDWHILE*) 
        ix := 2;
        WHILE used_blocks[ix].pos <> csp_maxint4 DO
            BEGIN
            gap_pos := used_blocks[ix-1].pos + used_blocks[ix-1].len;
            gap_len := used_blocks[ix].pos - gap_pos;
            IF  ix > 2
            THEN
                BEGIN
&               ifdef trace
                t01int4 (td_always, 'gap pos     ', gap_pos);
                t01int4 (td_always, 'gap len     ', gap_len);
&               endif
                g01abort (csp3_a10_cache_error, csp3_n_akcache, msg_gap_found, gap_pos);
                g01abort (csp3_a10_cache_error, csp3_n_akcache, msg_gap_found, gap_len);
                END;
            (*ENDIF*) 
            ix := ix + 1;
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10add_block (
            VAR used_blocks : tak10_used_blocks;
            pos             : tsp00_Int4;
            buf_no          : integer;
            len             : tsp00_Int4);
 
VAR
      ix : integer;
      jx : integer;
      kx : integer;
 
BEGIN
IF  buf_no > 0
THEN
    pos := pos + g01catalog_cache_init_size + (buf_no - 1) * cak10supplement * sizeof (tsp00_Page);
&ifdef trace
(*ENDIF*) 
t01p2int4 (ak_cach, 'Pos         ', pos, 'Len         ', len);
&endif
ix := 1;
WHILE used_blocks[ix].pos < pos DO
    ix := ix + 1;
(*ENDWHILE*) 
IF  (used_blocks[ix].pos <> pos) AND
    (used_blocks[ix-1].pos + used_blocks[ix-1].len <= pos)
THEN
    IF  used_blocks[ix-1].pos + used_blocks[ix-1].len = pos
    THEN
        BEGIN
        used_blocks[ix-1].len := used_blocks[ix-1].len + len;
        IF  used_blocks[ix-1].pos + used_blocks[ix-1].len = used_blocks[ix].pos
        THEN
            BEGIN
            used_blocks[ix-1].len := used_blocks[ix-1].len + used_blocks[ix].len;
            WHILE used_blocks[ix+1].pos <> csp_maxint4 DO
                BEGIN
                used_blocks[ix] := used_blocks[ix+1];
                ix              := ix + 1;
                END;
            (*ENDWHILE*) 
            used_blocks[ix].pos := csp_maxint4;
            used_blocks[ix].len := 0;
            END;
        (*ENDIF*) 
        END
    ELSE
        IF  pos + len = used_blocks[ix].pos
        THEN
            BEGIN
            used_blocks[ix].pos := pos;
            used_blocks[ix].len := used_blocks[ix].len + len;
            END
        ELSE
            BEGIN
            jx := ix;
            WHILE used_blocks[jx].pos <> csp_maxint4 DO
                jx := jx + 1;
            (*ENDWHILE*) 
            FOR kx := jx DOWNTO ix DO
                used_blocks[kx+1] := used_blocks[kx];
            (*ENDFOR*) 
            used_blocks[ix].pos := pos;
            used_blocks[ix].len := len
            END;
        (*ENDIF*) 
    (*ENDIF*) 
&ifdef trace
(*ENDIF*) 
ix := 2;
WHILE used_blocks[ix].pos <> csp_maxint4 DO
    BEGIN
    t01p2int4 (ak_cach, 'BlockPos    ', used_blocks[ix].pos,
          'BlockLen    ', used_blocks[ix].len);
    ix := ix + 1;
    END;
(*ENDWHILE*) 
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10mark_updated (p : tak_sysbufferaddress);
 
VAR
      curr : tak_cache_dir_pointer;
 
BEGIN
&ifdef trace
IF  p^.syskey.sentrytyp < cak_etemp
THEN
    g01abort (csp3_a10_cache_error, csp3_n_akcache, msg_no_temp_sysk, 0);
&endif
(*ENDIF*) 
IF  p <> NIL
THEN
    BEGIN
    curr.sys_ptr := p;
    curr.buf_ptr := s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
    WITH curr.cdir_ptr^ DO
        IF  dwritten in cd_state
        THEN
            cd_state := cd_state + [ dmodified ]
        (*ENDIF*) 
    (*ENDWITH*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10Lock (
            VAR acv : tak_all_command_glob;
            p       : tak_sysbufferaddress);
 
VAR
      curr      : tak_cache_dir_pointer;
      find_info : tak10_find_info;
 
BEGIN
IF  p <> NIL
THEN
    BEGIN
    IF  ak10_IsSharedRecord (p)
    THEN
        BEGIN
        ak10find_syskey (acv, p^.syskey, find_info, NOT cak10CheckReferences);
        IF  find_info.fi_res = l_equal
        THEN
            curr.cdir_ptr := find_info.fi_ptr.cdir_ptr
        ELSE
            curr.cdir_ptr := NIL;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        curr.sys_ptr := p;
        curr.buf_ptr := s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
        END;
    (*ENDIF*) 
    IF  curr.cdir_ptr <> NIL
    THEN
        WITH curr.cdir_ptr^ DO
            cd_refCount := cd_refCount + 1;
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10Unlock (
            VAR acv : tak_all_command_glob;
            p       : tak_sysbufferaddress);
 
VAR
      curr      : tak_cache_dir_pointer;
      find_info : tak10_find_info;
 
BEGIN
IF  p <> NIL
THEN
    BEGIN
    IF  ak10_IsSharedRecord (p)
    THEN
        BEGIN
        ak10find_syskey (acv, p^.syskey, find_info, NOT cak10CheckReferences);
        IF  find_info.fi_res = l_equal
        THEN
            curr.cdir_ptr := find_info.fi_ptr.cdir_ptr
        ELSE
            curr.cdir_ptr := NIL;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        curr.sys_ptr := p;
        curr.buf_ptr := s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
        END;
    (*ENDIF*) 
    IF  curr.cdir_ptr <> NIL
    THEN
        WITH curr.cdir_ptr^ DO
            BEGIN
            cd_refCount := cd_refCount - 1;
&           ifdef trace
            IF  cd_refCount < 0
            THEN
                g01abort (csp3_a10_cache_error,
                      csp3_n_akcache, 'refCount < 0            ', cd_refCount);
&           endif
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10mblock_into_cache (
            VAR acv      : tak_all_command_glob;
            VAR syskey   : tgg00_SysInfoKey;
            VAR mblock   : tgg00_MessBlock;
            dstate       : tak_directory_state;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
BEGIN
a10_nil_get_sysinfo (acv, syskey, d_fix,
      sizeof (tak_messblock_record), syspoint, b_err);
IF  b_err = e_ok
THEN
    WITH syspoint^.smessblock DO
        BEGIN
        mbr_stack_len := cak_is_undefined;
        mbr_recCount     := chr(0);
        mbr_fieldSequenceInfo := [];
        ak10space_for_mblock (acv, mblock,
              mbr_stack_len, mbr_mess_block, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            mbr_mess_block.mb_data_len := 0;
            a06cpy_mblock (acv, mblock, mbr_mess_block, NOT cak10withoutData, b_err);
            IF  b_err = e_ok
            THEN
                BEGIN
                mbr_mess_block.mb_trailer.mb_trns :=
                      @acv.a_transinf.tri_trans;
                IF  mblock.mb_fieldlists[cgg_idx_literal_valuefieldlist] <> NIL
                THEN
                    mbr_fieldSequenceInfo := mbr_fieldSequenceInfo + [mfs_literals];
                (*ENDIF*) 
                IF  mblock.mb_fieldlists[cgg_idx_param_valuefieldlist] <> NIL
                THEN
                    mbr_fieldSequenceInfo := mbr_fieldSequenceInfo + [mfs_parameters];
                (*ENDIF*) 
                IF  mblock.mb_fieldlists[cgg_idx_pars_result_valuefieldlist] <> NIL
                THEN
                    mbr_fieldSequenceInfo := mbr_fieldSequenceInfo + [mfs_pars_result];
                (*ENDIF*) 
                IF  mblock.mb_fieldlists[cgg_idx_ex_result_valuefieldlist] <> NIL
                THEN
                    mbr_fieldSequenceInfo := mbr_fieldSequenceInfo + [mfs_ex_result];
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  dstate <> d_fix
        THEN
            a10_rel_sysinfo (acv, syskey);
&       ifdef TRACE
        (*ENDIF*) 
        ak10verify_cache (acv)
&             endif
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10MigrateBaseRecords (doMigrate : boolean);
 
BEGIN
ak10migrate := doMigrate;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10new (
            VAR acv  : tak_all_command_glob;
            obj_size : tsp00_Int4;
            VAR p    : tak_sysbufferaddress);
 
VAR
      required_len : tsp00_Int4;
      univ_p       : tak_cache_dir_pointer;
      aux_ptr1     : tsp00_Addr;
      aux_ptr2     : tsp00_Addr;
 
BEGIN
required_len := obj_size + mxak_cache_dir_entry;
ak10getmem (acv, cak_is_undefined, required_len, univ_p.buf_ptr);
IF  univ_p.buf_ptr <> NIL
THEN
    BEGIN
    aux_ptr1 := @acv.a_ap_tree;
    aux_ptr2 := @p;
    IF  aux_ptr1 = aux_ptr2
    THEN
        univ_p.cdir_ptr^.cd_mem_type := dyn_syntax_tree
    ELSE
        univ_p.cdir_ptr^.cd_mem_type := dyn_normal;
    (*ENDIF*) 
    p := @univ_p.cdir_ptr^.cd_sysinfo
    END
ELSE
    p := NIL;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10new_packet (
            VAR acv : tak_all_command_glob;
            size    : tsp00_Int4;
            VAR ptr : tsp00_MoveObjPtr);
 
VAR
      required_len : tsp00_Int4;
      univ_p       : tak_cache_dir_pointer;
 
      p            : RECORD
            CASE boolean OF
                true :
                    (sys : tak_sysbufferaddress);
                false :
                    (packet_ptr : tsp00_MoveObjPtr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
required_len := size + mxak_cache_dir_entry;
ak10getmem (acv, cak_is_undefined, required_len, univ_p.buf_ptr);
IF  univ_p.buf_ptr <> NIL
THEN
    WITH univ_p.cdir_ptr^ DO
        BEGIN
        cd_mem_type        := dyn_packet;
        p.sys              := @cd_sysinfo;
        ptr                := p.packet_ptr
        END
    (*ENDWITH*) 
ELSE
    ptr := NIL;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10prefix_parsid_delete (
            VAR acv       : tak_all_command_glob;
            VAR parsk     : tak_parskey;
            VAR del_cnt   : integer;
            prefix_length : integer);
 
VAR
      nothing_found : boolean;
      b_err         : tgg00_BasisError;
      res           : tsp00_LcompResult;
      i             : integer;
      p             : tak_cache_dir_pointer;
      syskey        : tgg00_SysInfoKey;
 
BEGIN
syskey := a01sysnullkey;
WITH syskey DO
    BEGIN
    sauthid[ 1 ] := cak_tempinfo_byte;
    SAPDB_PascalForcedMove (sizeof (parsk), sizeof (sauthid), @parsk, 1, @sauthid, 2,
          prefix_length)
    END;
(*ENDWITH*) 
del_cnt := 0;
i       := ord (cak_ctemp);
REPEAT
    i := i + 1;
    REPEAT
        nothing_found := true;
        p             := acv.a_sysdir.ci_dir[ i ];
        WHILE p.cdir_ptr <> NIL DO
            BEGIN
            IF  p.cdir_ptr^.cd_check <> cak_cache_chunk_flag
            THEN
                BEGIN
                ak10cache_error (acv, 'a10prefix_parsid        ', p);
                p.cdir_ptr := NIL
                END
            ELSE
                BEGIN
                s30cmp (syskey, cgg_rec_key_offset+1, prefix_length + 1,
                      p.cdir_ptr^.cd_syskey, cgg_rec_key_offset+1, prefix_length+1, res);
                IF  res = l_equal
                THEN
                    BEGIN
                    nothing_found := false;
                    a10del_sysinfo (acv, p.cdir_ptr^.cd_syskey, b_err);
                    IF  b_err <> e_ok
                    THEN
                        BEGIN
                        nothing_found := true;
                        a07_b_put_error (acv, b_err, 1)
                        END
                    ELSE
                        del_cnt := del_cnt + 1;
                    (*ENDIF*) 
                    p.cdir_ptr := NIL
                    END
                ELSE
                    IF  res = l_less
                    THEN
                        p := p.cdir_ptr^.cd_less
                    ELSE
                        p := p.cdir_ptr^.cd_greater
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
    UNTIL
        nothing_found;
    (*ENDREPEAT*) 
UNTIL
    i = cak_emax;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10ReadFromCatalog (
            VAR acv : tak_all_command_glob;
            VAR row : tgg00_Rec);
 
VAR
      e      : tgg00_BasisError;
      sysbuf : tak_sysbufferaddress;
 
BEGIN
sysbuf := @row;
IF  sysbuf^.syskey.sentrytyp < cak_etemp
THEN
    ak10get_perm_record (acv, sysbuf^.syskey, row, e)
ELSE
    BEGIN
    acv.a_transinf.tri_trans.trError_gg00 := e_ok;
    b07cget_record (acv.a_transinf.tri_trans,
          acv.a_pars_curr, sysbuf^.syskey, row);
    e := acv.a_transinf.tri_trans.trError_gg00;
    acv.a_transinf.tri_trans.trError_gg00 := e_ok
    END;
(*ENDIF*) 
IF  e <> e_ok
THEN
    a07_b_put_error (acv, e, 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10refresh_cache (
            VAR acv : tak_all_command_glob);
 
VAR
      next : tak_cache_dir_pointer;
      curr : tak_cache_dir_pointer;
      prev : tak_cache_dir_e_ptr;
      pKey : tak10_SysKeyPointer;
 
BEGIN
WITH acv.a_sysdir  DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        next := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
        prev := ci_cache_dir_trailor.cdir_ptr;
        WHILE next.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
            BEGIN
            curr := next;
            next := next.cdir_ptr^.cd_lru_prev;
            IF  dreference in curr.cdir_ptr^.cd_state
            THEN
                pKey := ak10GlobalCacheGetKeyPointer(curr)
            ELSE
                pKey := @curr.cdir_ptr^.cd_syskey;
            (*ENDIF*) 
            IF  pKey^.sentrytyp < cak_etemp
            THEN
                BEGIN
                ak10block_into_freelist (acv, curr, c_del_in_directory,
                      c_del_dependecies);
                next := prev^.cd_lru_prev;
                END
            ELSE
                prev := curr.cdir_ptr;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
&       ifdef TRACE
        ak10td_dirlist  (acv, ak_cach);
        ak10td_freelist (acv, ak_cach);
&       endif
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10release_table (
            VAR acv     : tak_all_command_glob;
            VAR tableid : tgg00_Surrogate);
 
VAR
      i      : integer;
      res    : tsp00_LcompResult;
      p      : tak_cache_dir_pointer;
      syskey : tgg00_SysInfoKey;
      pKey   : tak10_SysKeyPointer;
 
BEGIN
syskey.stableid := tableid;
i               := 1;
WHILE i < cak_emax DO
    BEGIN
    p := acv.a_sysdir.ci_dir [ i ];
    WHILE p.cdir_ptr <> NIL DO
        WITH p.cdir_ptr^ DO
            IF  cd_check <> cak_cache_chunk_flag
            THEN
                BEGIN
                ak10cache_error (acv, 'a10release_table        ', p);
                p.cdir_ptr := NIL;
                i          := cak_emax
                END
            ELSE
                BEGIN
                IF  dreference in cd_state
                THEN
                    pKey := ak10GlobalCacheGetKeyPointer(p)
                ELSE
                    pKey := @cd_syskey;
                (*ENDIF*) 
                s30cmp (syskey, cgg_rec_key_offset+1, SURROGATE_MXGG00,
                      pKey^, cgg_rec_key_offset+1, SURROGATE_MXGG00, res);
                IF  res = l_equal
                THEN
                    BEGIN
                    ak10release_table (tableid, p);
                    p.cdir_ptr := NIL
                    END
                ELSE
                    IF  res = l_less
                    THEN
                        p := cd_less
                    ELSE
                        p := cd_greater
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDWHILE*) 
    i := i + 1
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10remove_parsinfos (
            VAR acv : tak_all_command_glob);
 
VAR
      curr      : tak_cache_dir_pointer;
      prev      : tak_cache_dir_pointer;
      find_info : tak10_find_info;
 
BEGIN
(* this procedure removes all temp catalog records from the cache *)
(* that have been allocated in the course of a ddl trigger        *)
prev := acv.a_sysdir.ci_cache_dir_header;
curr := acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_lru_next;
WHILE curr.cdir_ptr <> acv.a_sysdir.ci_cache_dir_trailor.cdir_ptr DO
    BEGIN
    IF  curr.cdir_ptr^.cd_cmd_no < 0
    THEN
        IF  NOT (dreference in curr.cdir_ptr^.cd_state)
            AND
            (curr.cdir_ptr^.cd_syskey.sentrytyp > cak_etemp)
        THEN
            BEGIN
            ak10find_syskey (acv, curr.cdir_ptr^.cd_syskey, find_info, NOT cak10CheckReferences);
            IF  find_info.fi_res = l_equal
            THEN
                BEGIN
                ak10block_into_freelist (acv, find_info.fi_ptr,
                      c_del_in_directory, c_del_dependecies);
                curr := prev
                END;
            (*ENDIF*) 
            END
        ELSE
            curr.cdir_ptr^.cd_cmd_no := acv.a_command_id;
        (*ENDIF*) 
    (*ENDIF*) 
    prev := curr;
    curr := curr.cdir_ptr^.cd_lru_next
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10shrink_syntax_tree (
            VAR acv : tak_all_command_glob);
 
VAR
      ap_ptr : tak_cache_dir_pointer;
      curr   : tak_cache_dir_pointer;
      found  : tak_cache_dir_pointer;
 
BEGIN
IF  acv.a_ap_tree = acv.a_session_ap_tree
THEN
    BEGIN
    ap_ptr.buf_ptr := @acv.a_ap_tree^;
    ap_ptr.buf_ptr :=
          s35add_bufaddr_ptocm (ap_ptr.buf_ptr, - mxak_cache_dir_entry);
    curr := ap_ptr.cdir_ptr^.cd_fix_next;
    WHILE curr.cdir_ptr <> NIL DO
        BEGIN
        found.sys_ptr := @curr.cdir_ptr^.cd_sysinfo;
        curr          := curr.cdir_ptr^.cd_fix_next;
        a10dispose (acv, found.sys_ptr)
        END;
    (*ENDWHILE*) 
    ap_ptr.cdir_ptr^.cd_fix_next.buf_ptr    := NIL;
    acv.a_ap_max_node                       := cak_init_node;
    acv.a_ap_tree^[cak_init_node + 1].n_pos := 0
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10table_cache_delete (
            VAR acv     : tak_all_command_glob;
            VAR tableid : tgg00_Surrogate);
 
BEGIN
ak10table_cache_delete (acv, tableid, c_flush_temp)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10unlock_fixed (
            VAR acv : tak_all_command_glob);
 
BEGIN
ak10lock_unlock_fixed (acv, false)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10add_sysinfo (
            VAR acv      : tak_all_command_glob;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
VAR
      via_kb    : boolean;
      rest      : integer;
      find_info : tak10_find_info;
 
      last     : RECORD
            CASE boolean OF
                true :
                    (colp : tak_basecolinfo_ptr);
                false :
                    (sysp : tak_sysbufferaddress);
                END;
            (*ENDCASE*) 
 
 
BEGIN
&ifdef trace
IF  t01trace( ak_cach )
THEN
    BEGIN
    t01catalog_entrytype( ak_cach, syspoint^.syskey.sentrytyp[ 2 ] );
    t01buf1 (ak_cach, syspoint^.syskey, 1 + cgg_rec_key_offset,
          syspoint^.syskey.skeylen + cgg_rec_key_offset);
    END
ELSE
    BEGIN
    t01catalog_entrytype( ak_sem, syspoint^.syskey.sentrytyp[ 2 ] );
    t01buf1 (ak_sem, syspoint^.syskey, 1 + cgg_rec_key_offset,
          syspoint^.syskey.skeylen + cgg_rec_key_offset);
    END;
(*ENDIF*) 
&endif
IF  acv.a_returncode = 0
THEN
    WITH acv, syspoint^, syskey DO
        BEGIN
        ak10find_syskey (acv, syspoint^.syskey, find_info, NOT cak10CheckReferences);
        IF  find_info.fi_res = l_equal
        THEN
            BEGIN
            via_kb := (sentrytyp < cak_etemp)
                  OR
                  ((sentrytyp > cak_elogged_temp)        AND
                  NOT a_in_ddl_trigger                   AND
                  NOT (hsNoLog_egg00 in a_pars_curr.fileHandling_gg00) AND
                  NOT a663parse_for_execute (acv));
            b_err := e_ok;
            IF  (sentrytyp[2] in [cak_ctable, cak_cresult]) AND
                (slinkage = cak_init_linkage)
            THEN
                IF  sbase.btablekind <> tsynonym
                THEN
                    a061compress_baserec (sbase, b_err);
                (*ENDIF*) 
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                IF  via_kb
                THEN
                    BEGIN
                    ak10add_upd_perm_record (acv, find_info,
                          syspoint, m_insert, b_err);
                    IF  b_err = e_duplicate_key
                    THEN
                        BEGIN
                        b_err := e_duplicate_sysinfo;
                        ak10store_syskey (acv, syspoint^.syskey)
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  syspoint^.syskey.sentrytyp[2] in
                        [cak_cjparsinfo, cak_cparsinfo, cak_cshortinfo,
                        cak_creskey, cak_clinkpos, cak_clongliteral]
                    THEN
                        syspoint^.sparsinfo.p_fullen := syspoint^.b_sl;
&                   ifdef TRACE
                    (*ENDIF*) 
                    t01buf (ak_sem, syspoint^, 1, syspoint^.b_sl);
&                   endif
                    (*
                          b07cadd_record (a_transinf.tri_trans,
                          a_pars_curr, syspoint^);
                          IF  a_transinf.tri_trans.trError_gg00 = e_duplicate_key
                          THEN
                          BEGIN
                          b_err := e_duplicate_sysinfo;
                          ak10store_syskey (acv, syspoint^.syskey)
                          END
                          ELSE
                          b_err := a_transinf.tri_trans.trError_gg00
                          *)
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                WITH find_info.fi_ptr.cdir_ptr^ DO
                    BEGIN
                    IF  NOT via_kb
                    THEN
                        IF  (dadd_rec in cd_state) OR
                            (dwritten in cd_state)
                        THEN
                            BEGIN
                            b_err := e_duplicate_sysinfo;
                            ak10store_syskey (acv, cd_syskey)
                            END
                        ELSE
                            cd_state := cd_state + [ dadd_rec ];
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  syspoint^.syskey.sentrytyp = cak_ecolnames
                    THEN (* release rest of last colnames buffer *)
                        syspoint := syspoint^.scolnames.cnlast;
                    (*ENDIF*) 
                    ak10free_rest (acv, syspoint, syspoint^.b_sl);
                    IF  syspoint^.syskey.sentrytyp[2] in
                        [cak_ctable, cak_cresult]
                    THEN
                        IF  syspoint^.sbase.btablekind <> tsynonym
                        THEN
                            BEGIN (* release rest of last colname buffer *)
                            last.colp := syspoint^.sbase.bptr;
                            (* find last column buffer *)
                            WHILE last.colp^.bci_next <> NIL DO
                                last.colp := last.colp^.bci_next;
                            (*ENDWHILE*) 
                            (* free unused part of last column buffer *)
                            ak10free_rest (acv, last.sysp,
                                  sizeof (last.colp^) -
                                  sizeof (last.colp^.bci_buf) +
                                  last.colp^.bci_index - 1);
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            b_err := e_sysinfo_not_found;
            ak10store_syskey (acv, syskey)
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
&ifdef TRACE
(*ENDIF*) 
ak10verify_cache (acv);
&endif
IF  acv.a_returncode <> 0
THEN
    b_err := e_cancelled
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_all_release  (
            VAR acv : tak_all_command_glob);
 
VAR
&     ifdef trace
      pReleased : tak_sysbufferaddress;
&     endif
      p         : tak_cache_dir_pointer;
      first     : tak_cache_dir_pointer;
 
BEGIN
p.cdir_ptr := NIL;
IF  a10chk
THEN
    ak10CacheCheck (acv);
(*ENDIF*) 
WITH acv.a_sysdir DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        first := ci_cache_dir_trailor;
        p     := ci_cache_dir_trailor.cdir_ptr^.cd_fix_prev;
        WHILE p.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
            BEGIN
            IF  p.cdir_ptr^.cd_check <> cak_cache_chunk_flag
            THEN
                BEGIN
                ak10cache_error (acv, 'a10all_release          ', p);
                p := ci_cache_dir_header
                END
            ELSE
                BEGIN
&               ifdef trace
                pReleased := NIL;
&               endif
                IF  (p.cdir_ptr^.cd_refCount > 0) OR
                    (a101_IsStatementActive(acv, p.cdir_ptr^.cd_cmd_no))
                THEN
                    BEGIN
                    first.cdir_ptr^.cd_fix_prev := p;
                    p.cdir_ptr^.cd_fix_next     := first;
                    first                       := p;
                    END
                ELSE
                    BEGIN
&                   ifdef trace
                    IF  NOT (dreference in p.cdir_ptr^.cd_state)
                    THEN
                        pReleased := @p.cdir_ptr^.cd_sysinfo;
&                   endif
                    (*ENDIF*) 
                    p.cdir_ptr^.cd_fix_next.cdir_ptr := NIL;
                    END;
                (*ENDIF*) 
                p := p.cdir_ptr^.cd_fix_prev;
&               ifdef trace
                IF  (pReleased <> NIL) AND (acv.a_dbproc_level > 0)
                THEN
                    BEGIN
                    a10key_del(acv, pReleased);
                    END;
&               endif
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        ci_cache_dir_header.cdir_ptr^.cd_fix_next  := first;
        first.cdir_ptr^.cd_fix_prev                := ci_cache_dir_header;
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10MarkGlobalReferencesUnused (
            VAR acv : tak_all_command_glob);
 
VAR
      p : tak_cache_dir_pointer;
 
BEGIN
WITH acv.a_sysdir DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        p     := ci_cache_dir_trailor.cdir_ptr^.cd_ref.cd_prevRef;
        WHILE p.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
            BEGIN
            IF  p.cdir_ptr^.cd_check <> cak_cache_chunk_flag
            THEN
                BEGIN
                ak10cache_error (acv, 'a10all_release          ', p);
                p := ci_cache_dir_header
                END
            ELSE
                BEGIN
                a103SetCacheHandleInUse (acv, p.cdir_ptr^.cd_ref.cd_globalCacheHandle, false);
                p.cdir_ptr^.cd_ref.cd_nextRef.cdir_ptr := NIL;
                p := p.cdir_ptr^.cd_ref.cd_prevRef;
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        ci_cache_dir_header.cdir_ptr^.cd_ref.cd_nextRef  := ci_cache_dir_trailor;
        ci_cache_dir_trailor.cdir_ptr^.cd_ref.cd_prevRef := ci_cache_dir_header;
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(* PTS 1110796 *)
(*------------------------------*) 
 
PROCEDURE
      a10Displace (
            VAR acv : tak_all_command_glob);
 
VAR
      next            : tak_cache_dir_pointer;
      curr            : tak_cache_dir_pointer;
      notDisplacedCnt : integer;
&     ifdef trace
      displaceCnt     : integer;
&     endif
 
BEGIN
(* removes all catalog records with displace flag from cache *)
WITH acv.a_sysdir DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        IF  ci_displaceCnt > 0
        THEN
            BEGIN
&           ifdef trace
            displaceCnt := ci_displaceCnt;
            t01int4 (ak_cach, 'displaceCnt ', ci_displaceCnt);
&           endif
            notDisplacedCnt := 0;
            next            := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
            WHILE next.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
                BEGIN
                curr := next;
                WITH curr.cdir_ptr^ DO
                    BEGIN
                    next := next.cdir_ptr^.cd_lru_prev;
                    IF  ddisplace in cd_state (* PTS 1110796 *)
                    THEN
                        BEGIN
&                       ifdef trace
                        displaceCnt := displaceCnt -1;
&                       endif
                        IF  cd_refCount > 0
                        THEN
                            notDisplacedCnt := notDisplacedCnt + 1
                        ELSE
                            BEGIN
                            ak10block_into_freelist (acv,
                                  curr, c_del_in_directory, c_del_dependecies);
                            IF  ci_displaceCnt = 0
                            THEN (* exit loop *)
                                next.cdir_ptr := ci_cache_dir_header.cdir_ptr
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                END;
            (*ENDWHILE*) 
&           ifdef trace
            IF  displaceCnt <> 0
            THEN
                g01abort (csp3_a10_cache_error,
                      csp3_n_akcache, 'ci_displaceCnt <> 0     ', displaceCnt);
&           endif
            (*ENDIF*) 
            ci_displaceCnt := notDisplacedCnt
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_cache_delete  (
            VAR acv     : tak_all_command_glob;
            is_rollback : boolean);
 
VAR
      isResname   : boolean;
      restartIter : boolean;
      next        : tak_cache_dir_pointer;
      curr        : tak_cache_dir_pointer;
 
BEGIN
WITH acv.a_sysdir  DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        (* PTS 1111576 E.Z. *)
        next := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
        WHILE next.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
            BEGIN
            curr := next;
            WITH curr.cdir_ptr^ DO
                BEGIN
                next      := next.cdir_ptr^.cd_lru_prev;
                isResname := NOT (dreference in cd_state) AND (cd_syskey.sentrytyp = cak_eresname);
                IF  ((NOT isResname) OR NOT acv.a_intern_explain)
                    AND
                    (cd_refCount = 0)
                    AND
                    NOT (a101_IsStatementActive(acv, cd_cmd_no))
                THEN
                    BEGIN
&                   ifdef trace
                    t01str30 (ak_cach,
                          'dislodge block                ');
                    IF  NOT (dreference in cd_state)
                    THEN
                        t01buf1 (ak_cach, cd_syskey, cgg_rec_key_offset+1,
                              cd_syskey.skeylen + cgg_rec_key_offset);
&                   endif
                    (*ENDIF*) 
                    ak10temp_add (acv, curr, is_rollback);
                    restartIter := ak10RestartIterator(curr); (* PTS 1126940 *)
                    ak10block_into_freelist (acv,
                          curr, c_del_in_directory, c_del_dependecies);
                    IF  restartIter (* PTS 1126940 *)
                    THEN
                        next := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
                    (*ENDIF*) 
                    END
&               ifdef trace
                ELSE
                    BEGIN
                    IF  isResname
                    THEN
                        t01str30 (ak_cach, 'do not displace resname record')
                    ELSE
                        IF  acv.a_intern_explain
                        THEN
                            t01str30 (ak_cach, 'do not displace due to explain')
                        ELSE
                            IF  cd_refCount > 0
                            THEN
                                t01str30 (ak_cach, 'do not displace due to locked ')
                            ELSE
                                IF  a101_IsStatementActive(acv, cd_cmd_no)
                                THEN
                                    t01str30 (ak_cach, 'do not displace due to active ');
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  NOT (dreference in cd_state)
                    THEN
                        BEGIN
                        t01catalog_entrytype( ak_cach, cd_syskey.sentrytyp[ 2 ] );
                        t01buf1 (ak_cach, cd_syskey, 1 + cgg_rec_key_offset,
                              cd_syskey.skeylen + cgg_rec_key_offset);
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&               endif
                END;
            (*ENDWITH*) 
            END;
        (*ENDWHILE*) 
        ci_tmp_dislodged              := false;
&       ifdef trace
        ak10td_dirlist  (acv, ak_cach);
        ak10td_freelist (acv, ak_cach);
&       endif
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10del_sysinfo (
            VAR acv     : tak_all_command_glob;
            VAR syskey  : tgg00_SysInfoKey;
            VAR b_err   : tgg00_BasisError);
 
VAR
      isShared  : boolean;
      del       : boolean;
      del_succ  : boolean;
      find_info : tak10_find_info;
      authName  : tsp00_KnlIdentifier;
      aux_key   : tgg00_SysInfoKey;
      mblock    : tgg00_MessBlock;
      qual      : tak10qual;
 
      data      : RECORD
            CASE boolean OF
                true :
                    (dt_syskey : tgg00_SysInfoKey);
                false :
                    (dt_buf    : tsp00_Buf);
                END;
            (*ENDCASE*) 
 
 
BEGIN
del_succ := false;
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef trace
    IF  t01trace( ak_cach )
    THEN
        BEGIN
        t01catalog_entrytype( ak_cach, syskey.sentrytyp[ 2 ] );
        t01buf1 (ak_cach, syskey, 1 + cgg_rec_key_offset,
              syskey.skeylen + cgg_rec_key_offset);
        END
    ELSE
        BEGIN
        t01catalog_entrytype( ak_sem, syskey.sentrytyp[ 2 ] );
        t01buf1 (ak_sem, syskey, 1 + cgg_rec_key_offset,
              syskey.skeylen + cgg_rec_key_offset);
        END;
    (*ENDIF*) 
&   endif
    b_err := e_ok;
    ak10find_syskey (acv, syskey, find_info, NOT cak10CheckReferences);
&   ifdef TRACE
    IF  find_info.fi_res = l_equal
    THEN
        xtd_directory (ak_cach, find_info.fi_ptr);
&   endif
    (*ENDIF*) 
    isShared := false;
    del      := true;
    IF  find_info.fi_res = l_equal
    THEN
        BEGIN
        IF  syskey.sentrytyp > cak_etemp
        THEN
            BEGIN
            isShared := ak10IsSharedSQLRecord (find_info.fi_ptr);
            IF  NOT(dwritten in find_info.fi_ptr.cdir_ptr^.cd_state) OR isShared
            THEN
                del := false
            ELSE
                CASE syskey.sentrytyp[2] OF
                    cak_cjparsinfo, cak_cparsinfo, cak_cshortinfo,
                    cak_creskey, cak_clinkpos, cak_clongliteral :
                        IF  find_info.fi_ptr.cdir_ptr^.
                            cd_sysinfo.sparsinfo.p_fullen >
                            MAX_RECLEN_GG00
                        THEN
                            del_succ := true;
                        (*ENDIF*) 
                    cak_ccolnames :
                        del_succ := find_info.fi_ptr.cdir_ptr^.
                              cd_sysinfo.b_sl = MAX_RECLEN_GG00;
                    cak_cmessblock, cak_cpermmessblock, cak_ctriggerparsinfo :
                        del_succ := true;
                    cak_cresult :
                        del_succ := true;
                    OTHERWISE ;
                    END
                (*ENDCASE*) 
            (*ENDIF*) 
            END
        ELSE
            del_succ := syskey.sentrytyp = cak_epermmessblock
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  (syskey.sentrytyp[2] = cak_ccolnames       ) OR
            (syskey.sentrytyp[2] = cak_cjparsinfo      ) OR
            (syskey.sentrytyp[2] = cak_cparsinfo       ) OR
            (syskey.sentrytyp[2] = cak_clongliteral    ) OR
            (syskey.sentrytyp[2] = cak_creskey         ) OR
            (syskey.sentrytyp[2] = cak_clinkpos        ) OR
            (syskey.sentrytyp[2] = cak_cmessblock      ) OR
            (syskey.sentrytyp[2] = cak_cpermmessblock  ) OR
            (syskey.sentrytyp[2] = cak_cshortinfo      ) OR
            (syskey.sentrytyp[2] = cak_ctriggerparsinfo) OR
            (syskey.sentrytyp[2] = cak_cresult         )
        THEN
            del_succ := true;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  del
    THEN
        BEGIN
        aux_key := syskey;
        CASE aux_key.sentrytyp[2] OF
            cak_cuserref, cak_cfuncref :
                IF  g01unicode
                THEN
                    aux_key.skeylen := mxak_standard_sysk +
                          s30unilnr (@aux_key.sidentifier,
                          csp_unicode_blank, 1,
                          sizeof (aux_key.sidentifier) -
                          sizeof (aux_key.sauthid))
                ELSE
                    aux_key.skeylen := mxak_standard_sysk +
                          s30lnr (aux_key.sidentifier, bsp_c1, 1,
                          sizeof (aux_key.sidentifier) -
                          sizeof (aux_key.sauthid));
                (*ENDIF*) 
            cak_ctableref, cak_cdomainref,
            cak_cconstraintname, cak_cmapset :
                aux_key.skeylen := mxak_standard_sysk +
                      a061identifier_len (aux_key.sidentifier);
            OTHERWISE ;
            END;
        (*ENDCASE*) 
        aux_key.sreclen := 0;
        IF  (syskey.sentrytyp < cak_etemp) OR
            ((syskey.sentrytyp > cak_elogged_temp) AND
            NOT acv.a_in_ddl_trigger                   AND
            NOT (hsNoLog_egg00 in acv.a_pars_curr.fileHandling_gg00) AND
            NOT a663parse_for_execute (acv))
        THEN
            BEGIN
            IF  (syskey.sentrytyp = cak_euserref) AND ak10CatalogTablesEnabled AND
                NOT acv.a_modifyBootStrapCatalog
            THEN
                BEGIN
                SAPDB_PascalForcedMove (sizeof(syskey.stableid), sizeof(authName),
                      @syskey.stableid, 1, @authName, 1, sizeof(syskey.stableid));
                SAPDB_PascalForcedMove (sizeof(syskey.sidentifier), sizeof(authName),
                      @syskey.sidentifier, 1,
                      @authName, sizeof(syskey.stableid) + 1, sizeof(authName) - sizeof(syskey.stableid));
                IF  find_info.fi_res = l_equal
                THEN
                    ak10block_into_freelist (acv,
                          find_info.fi_ptr, c_del_in_directory, c_del_dependecies);
                (*ENDIF*) 
                find_info.fi_res := l_less;
                a103DeleteAuthorizationObject (acv, authName);
                END
            ELSE
                REPEAT
                    g01mblock_init (acv.a_transinf.tri_trans,
                          m_delete, mm_nil, mblock);
                    g01stack_init (mblock,
                          NIL, 0, @qual, sizeof (qual));
                    g01datapart_init (mblock, @data, sizeof (data));
                    mblock.mb_qual_len    := sizeof (qual.q_hd);
                    mblock.mb_data_len    :=
                          cgg_rec_key_offset + aux_key.skeylen;
                    data.dt_syskey := aux_key;
                    ak10send_mess_block (acv, mblock,
                          syskey.sentrytyp, false, b_err);
                    IF  del_succ
                    THEN
                        IF  aux_key.skeylen = syskey.skeylen
                        THEN
                            BEGIN
                            aux_key.skeylen := aux_key.skeylen + 1;
                            aux_key.all[aux_key.skeylen] := chr(1);
                            END
                        ELSE
                            aux_key.all[aux_key.skeylen] :=
                                  succ (aux_key.all[aux_key.skeylen]);
                        (*ENDIF*) 
                    (*ENDIF*) 
                UNTIL
                    NOT del_succ OR (b_err <> e_ok);
                (*ENDREPEAT*) 
            (*ENDIF*) 
            IF  (b_err = e_key_not_found) AND del_succ AND
                (aux_key.skeylen > syskey.skeylen)
            THEN
                b_err := e_ok;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            b07cdel_record (acv.a_transinf.tri_trans,
                  acv.a_pars_curr, syskey);
            IF  (find_info.fi_res <> l_equal) AND
                (acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found)
            THEN
                b_err := e_ok
            ELSE
                BEGIN
                b_err := acv.a_transinf.tri_trans.trError_gg00;
                IF  del_succ AND (b_err = e_ok)
                THEN
                    (* PTS 1106238 E.Z. *)
                    IF  syskey.sentrytyp[2] = cak_cresult
                    THEN
                        REPEAT
                            a06inc_linkage (aux_key.slinkage);
                            b07cdel_record (acv.a_transinf.tri_trans,
                                  acv.a_pars_curr, aux_key);
                        UNTIL
                            acv.a_transinf.tri_trans.trError_gg00 <> e_ok
                        (*ENDREPEAT*) 
                    ELSE
                        BEGIN
                        aux_key.skeylen := aux_key.skeylen + 1;
                        aux_key.all[aux_key.skeylen] := chr(0);
                        REPEAT
                            aux_key.all[aux_key.skeylen] :=
                                  succ (aux_key.all[aux_key.skeylen]);
                            b07cdel_record (acv.a_transinf.tri_trans,
                                  acv.a_pars_curr, aux_key);
                        UNTIL
                            acv.a_transinf.tri_trans.trError_gg00 <> e_ok;
                        (*ENDREPEAT*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            acv.a_transinf.tri_trans.trError_gg00 := e_ok
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (find_info.fi_res = l_equal) AND NOT isShared
    THEN
        ak10block_into_freelist (acv,
              find_info.fi_ptr, c_del_in_directory, c_del_dependecies);
    (*ENDIF*) 
    IF  b_err = e_key_not_found
    THEN
        BEGIN
        b_err := e_sysinfo_not_found;
        ak10store_syskey (acv, syskey)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode <> 0
THEN
    b_err := e_cancelled;
&ifdef TRACE
(*ENDIF*) 
ak10verify_cache (acv)
&     endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10get_sysinfo (
            VAR acv      : tak_all_command_glob;
            VAR syskey   : tgg00_SysInfoKey;
            dstate       : tak_directory_state;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
VAR
      tableAccess      : boolean;
      dummy            : boolean;
      refState         : tak_directory_state;
      handle           : tsp00_Addr;
      cacheHandle      : tgg00_VoidPtr;
      keylen           : integer;
      requiredLen      : tsp00_Int4;
      aux              : tak_cache_dir_pointer;
      find_info        : tak10_find_info;
      pAuthRef         : tak_sysbufferaddress;
      pAux             : tak_sysbufferaddress;
      authName         : tsp00_KnlIdentifier;
      authSyskey       : tgg00_SysInfoKey;
      pAuth            : ^tak_userrecord;
      rbuf             : tgg00_Rec;
&     ifdef trace
      pObj             : tsp00_MoveObjPtr;
&     endif
 
BEGIN
syspoint := NIL;
WITH acv, a_sysdir DO
    IF  a_returncode = 0
    THEN
        BEGIN
        IF  (a_planHandle <> NIL) AND (syskey.sentrytyp > cak_etemp)
        THEN
            BEGIN
            syspoint := a101_GetPlanElement (a_planHandle, syskey);
            b_err    := e_ok;
            END;
        (*ENDIF*) 
        IF  syspoint = NIL
        THEN
            BEGIN
            b_err             := e_ok;
            find_info.fi_kind := get;
&           ifdef trace
            IF  t01trace( ak_cach )
            THEN
                BEGIN
                t01catalog_entrytype( ak_cach, syskey.sentrytyp[ 2 ] );
                t01buf1 (ak_cach, syskey, cgg_rec_key_offset+1,
                      syskey.skeylen + cgg_rec_key_offset);
                END
            ELSE
                BEGIN
                t01catalog_entrytype( ak_sem, syskey.sentrytyp[ 2 ] );
                t01buf1 (ak_sem, syskey, cgg_rec_key_offset+1,
                      syskey.skeylen + cgg_rec_key_offset);
                END;
            (*ENDIF*) 
&           endif
            ak10find_syskey (acv, syskey, find_info, cak10CheckReferences);
            IF  find_info.fi_res = l_equal
            THEN
                BEGIN (* Required syskey found in directory *)
                b73directory_ref_statistic (dir_hit);
                WITH find_info.fi_ptr.cdir_ptr^ DO
                    IF  ((acv.a_iso_level    > 0           )       AND
                        (acv.a_command_kind = show_command)        AND
                        (syskey.sentrytyp   < cak_etemp   )        AND
                        NOT a101_IsStatementActive(acv, cd_cmd_no) AND
                        (cd_cmd_no      <  acv.a_cmd_start_id    ) AND
                        NOT (dreference in cd_state))
                        OR
                        (ddisplace in cd_state)
                    THEN
                        BEGIN
                        (* read record again from catalog *)
                        find_info.fi_res := l_less;
                        syspoint         := @cd_sysinfo;
                        a10key_del (acv, syspoint)
                        END
                    ELSE
                        BEGIN (* required catalog record found *)
                        IF  syskey.sentrytyp > cak_etemp
                        THEN
                            BEGIN
                            IF  ci_tmp_read_cnt < csp_maxint4
                            THEN
                                BEGIN
                                ci_tmp_read_cnt   := ci_tmp_read_cnt + 1;
                                ci_tmp_read_found := ci_tmp_read_found + 1;
                                END
                            ELSE
                                BEGIN
                                ci_tmp_read_found :=
                                      ak10hit_rate (ci_tmp_read_found,
                                      ci_tmp_read_cnt);
                                ci_tmp_read_cnt := 1000
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  NOT a101_IsStatementActive(acv, cd_cmd_no)
                        THEN
                            cd_cmd_no := acv.a_command_id;
                        (*ENDIF*) 
                        IF  dreference in cd_state
                        THEN
                            BEGIN
                            syspoint := cd_ref.cd_globalSysinfoPtr;
                            IF  cd_ref.cd_nextRef.cdir_ptr = NIL
                            THEN
                                BEGIN
                                a103SetCacheHandleInUse (acv, cd_ref.cd_globalCacheHandle, true);
                                IF  a_returncode = 0
                                THEN
                                    BEGIN
                                    cd_ref.cd_nextRef :=
                                          ci_cache_dir_header.cdir_ptr^.cd_ref.cd_nextRef;
                                    cd_ref.cd_prevRef := ci_cache_dir_header;
                                    ci_cache_dir_header.cdir_ptr^.cd_ref.
                                          cd_nextRef.cdir_ptr^.cd_ref.cd_prevRef :=
                                          find_info.fi_ptr;
                                    ci_cache_dir_header.cdir_ptr^.cd_ref.cd_nextRef :=
                                          find_info.fi_ptr;
                                    END
                                ELSE
                                    BEGIN
                                    (* handle is no longer valid, give it up *)
                                    acv.a_returncode := 0;
                                    ak10block_into_freelist (acv, find_info.fi_ptr,
                                          c_del_in_directory, c_del_dependecies);
                                    find_info.fi_res := l_less;
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  (syspoint = NIL) AND (find_info.fi_res = l_equal)
                            THEN
                                BEGIN
                                b_err := e_sysinfo_not_found;
                                ak10store_syskey (acv, syskey)
                                END;
                            (*ENDIF*) 
                            END
                        ELSE
                            syspoint  := @cd_sysinfo;
                        (*ENDIF*) 
                        IF  find_info.fi_res = l_equal
                        THEN
                            BEGIN
                            (*============== remove from LRU-List ===============*)
                            cd_lru_prev.cdir_ptr^.cd_lru_next := cd_lru_next;
                            cd_lru_next.cdir_ptr^.cd_lru_prev := cd_lru_prev;
                            (*============== Chain into LRU-List ================*)
                            cd_lru_next :=
                                  ci_cache_dir_header.cdir_ptr^.cd_lru_next;
                            cd_lru_prev := ci_cache_dir_header;
                            ci_cache_dir_header.cdir_ptr^.
                                  cd_lru_next.cdir_ptr^.cd_lru_prev :=
                                  find_info.fi_ptr;
                            ci_cache_dir_header.cdir_ptr^.cd_lru_next :=
                                  find_info.fi_ptr;
                            IF  (dstate = d_fix) AND
                                (cd_fix_next.cdir_ptr = NIL)
                            THEN
                                BEGIN
                                (*============ Chain into FIX-List ==============*)
                                cd_fix_next :=
                                      ci_cache_dir_header.cdir_ptr^.cd_fix_next;
                                cd_fix_prev := ci_cache_dir_header;
                                ci_cache_dir_header.cdir_ptr^.
                                      cd_fix_next.cdir_ptr^.cd_fix_prev :=
                                      find_info.fi_ptr;
                                ci_cache_dir_header.cdir_ptr^.cd_fix_next :=
                                      find_info.fi_ptr
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            IF  (find_info.fi_res <> l_equal) AND (acv.a_returncode = 0)
            THEN
                BEGIN (* required catalog record not found in cache *)
                keylen := syskey.skeylen;
                CASE syskey.sentrytyp[2] OF
                    cak_cuserref, cak_cfuncref :
                        IF  NOT ak10CatalogTablesEnabled OR acv.a_modifyBootStrapCatalog
                        THEN
                            IF  g01unicode
                            THEN
                                syskey.skeylen := mxak_standard_sysk +
                                      s30unilnr (@syskey.sidentifier,
                                      csp_unicode_blank, 1,
                                      sizeof (syskey.sidentifier) -
                                      sizeof (syskey.sauthid))
                            ELSE
                                syskey.skeylen := mxak_standard_sysk +
                                      s30lnr (syskey.sidentifier, bsp_c1, 1,
                                      sizeof (syskey.sidentifier) -
                                      sizeof (syskey.sauthid));
                            (*ENDIF*) 
                        (*ENDIF*) 
                    cak_ctableref, cak_cdomainref,
                    cak_cconstraintname, cak_cmapset :
                        syskey.skeylen := mxak_standard_sysk +
                              a061identifier_len (syskey.sidentifier);
                    OTHERWISE ;
                    END;
                (*ENDCASE*) 
                tableAccess := false;
                IF  (syskey.sentrytyp > cak_etemp)
                THEN
                    BEGIN
                    b07cget_record (a_transinf.tri_trans,
                          a_pars_curr, syskey, rbuf);
                    b_err := a_transinf.tri_trans.trError_gg00;
                    a_transinf.tri_trans.trError_gg00 := e_ok;
                    IF  ci_tmp_dislodged AND (b_err = e_ok)
                    THEN
                        ak10check_hit_rate (acv);
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  ak10CatalogTablesEnabled
                        AND
                        NOT acv.a_modifyBootStrapCatalog
                        AND
                        ((syskey.sentrytyp = cak_euser) OR (syskey.sentrytyp = cak_euserref))
                    THEN
                        BEGIN
                        tableAccess := true;
                        IF  (acv.a_is_ddl = no_ddl) AND NOT acv.a_localCacheUsageOnly
                        THEN
                            BEGIN
                            a103AttachCatalogRecord (acv, syskey, cacheHandle, syspoint, b_err);
                            IF  acv.a_returncode = 0
                            THEN
                                ak10InsertReference (acv, cacheHandle, syspoint, b_err);
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            IF  syskey.sentrytyp = cak_euser
                            THEN
                                BEGIN
                                refState := d_release;
                                a103LoadAuthorizationById (acv, syskey.stableid, rbuf.buf, b_err)
                                END
                            ELSE
                                BEGIN
                                refState := dstate;
                                dstate   := d_release;
                                SAPDB_PascalForcedMove (sizeof(syskey.stableid), sizeof(authName),
                                      @syskey.stableid, 1, @authName, 1, sizeof(syskey.stableid));
                                SAPDB_PascalForcedMove (sizeof(syskey.sidentifier), sizeof(authName),
                                      @syskey.sidentifier, 1,
                                      @authName, sizeof(syskey.stableid) + 1, sizeof(authName) - sizeof(syskey.stableid));
                                a103LoadAuthorizationByName (acv, authName,
                                      NOT (acv.a_is_ddl in [ddl_alter_password, ddl_alter_user]), rbuf.buf, b_err);
                                END;
                            (*ENDIF*) 
                            IF  b_err = e_ok
                            THEN
                                BEGIN
                                pAuth := @rbuf;
                                a51build_userkey    (pAuth^.username, authSyskey);
                                a10_nil_get_sysinfo (acv, authSyskey, refState, sizeof(tak_userrefrecord), pAuthRef, b_err);
                                IF  b_err = e_ok
                                THEN
                                    BEGIN
                                    pAuthRef^.suserref.ru_user_id := pAuth^.usurrogate;
                                    aux.sys_ptr := pAuthRef;
                                    aux.buf_ptr := s35add_bufaddr_ptocm (aux.buf_ptr, - mxak_cache_dir_entry);
                                    aux.cdir_ptr^.cd_create_cmd_no := cak_is_undefined;
                                    END
                                ELSE
                                    IF  b_err = e_duplicate_sysinfo
                                    THEN
                                        b_err := e_ok;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                SAPDB_PascalMove ('VAK10 ',   6,    
                                      sizeof (rbuf.buf), sizeof (authSyskey),
                                      @rbuf.buf, 1, @authSyskey, 1, rbuf.recKeyLen_gg00 + cgg_rec_key_offset, b_err);
&                               ifdef trace
                                pObj := @rbuf;
                                t01moveobj (ak_cach, pObj^, 1, rbuf.recLen_gg00);
&                               endif
                                find_info.fi_kind := get;
                                ak10find_syskey (acv, authSyskey, find_info, NOT cak10CheckReferences);
                                IF  find_info.fi_res <> l_equal
                                THEN
                                    ak10put_mbuf_into_cache (acv, rbuf,
                                          dstate, find_info, authSyskey, syspoint);
                                (*ENDIF*) 
                                IF  syskey.sentrytyp = cak_euserref
                                THEN
                                    syspoint := pAuthRef;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        IF  (syskey.sentrytyp = cak_etable) AND
                            (a_is_ddl = no_ddl)             AND
                            NOT a_localCacheUsageOnly       AND
                            (acv.a_command_kind <> show_command)
                        THEN
                            BEGIN
                            tableAccess := true;
                            a103AttachCatalogRecord (acv, syskey, cacheHandle, syspoint, b_err);
                            IF  acv.a_returncode = 0
                            THEN
                                ak10InsertReference (acv, cacheHandle, syspoint, b_err);
                            (*ENDIF*) 
                            END
                        ELSE
                            ak10get_perm_record (acv, syskey, rbuf, b_err);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                syskey.skeylen := keylen;
                IF  b_err = e_ok
                THEN
                    BEGIN
                    b73directory_ref_statistic (dir_miss); (* PTS 1105560, T.A. *)
                    IF  NOT tableAccess
                    THEN
                        ak10put_mbuf_into_cache (acv, rbuf,
                              dstate, find_info, syskey, syspoint)
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  b_err = e_key_not_found
                    THEN
                        BEGIN
                        b_err := e_sysinfo_not_found;
                        ak10store_syskey (acv, syskey)
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
IF  acv.a_returncode <> 0
THEN
    b_err := e_cancelled;
&ifdef TRACE
(*ENDIF*) 
ak10verify_cache (acv)
&     endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_init_cache (
            VAR acv : tak_all_command_glob);
 
VAR
      e             : tgg00_BasisError;
      required_len  : tsp00_Int4;
      dummy         : tsp00_Int4;
 
      aux_ptr   : RECORD
            CASE integer OF
                1 :
                    (sbuf : tsp00_BufAddr);
                2 :
                    (sptr : tak_site_state_ptr);
                3 :
                    (sysp : tak_sysbufferaddress);
                4 :
                    (chptr : tak10cache_header_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
ak10alloc_mem (acv, cak10init_cache, 0, acv.a_sysdir.ci_cache_p, dummy);
WITH acv.a_sysdir  DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        ci_cmd_rollback_tree := b01niltree_id;
        ci_tmp_dislodged     := false;
        ci_inIterator        := false;
        ci_rollbackFileExists:= false;
        ci_displaceCnt       := 0;
        ci_tmp_read_cnt      := 0;
        ci_tmp_read_found    := 0;
        aux_ptr.sbuf         := ci_cache_p;
        aux_ptr.chptr^.ch_label      := ak10ChunkLabel;
        aux_ptr.chptr^.ch_size       := ak10init_cache_size;
        aux_ptr.chptr^.ch_next_cache := NIL;
&       ifndef BIT64
        aux_ptr.chptr^.ch_filler     := 0;
&       endif
        ci_cache_dir_header.buf_ptr :=
              s35add_bufaddr_ptocm (ci_cache_p, sizeof (aux_ptr.chptr^));
        ci_cache_dir_trailor.buf_ptr :=
              s35add_bufaddr_ptocm (ci_cache_p, sizeof (aux_ptr.chptr^) +
              sizeof(tak_globalCacheReference));
        ak10free_cache (acv, 0);
        required_len := sizeof (tgg00_SysInfoKey);
        a10new (acv, required_len, acv.a_error_key_ptr);
        END
    ELSE
        BEGIN
        ak10no_more_memory (acv, e);
        a07_nb_put_error (acv, e, 1, a01_i_ak_cache)
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a10KeepRecord (
            VAR acv    : tak_all_command_glob;
            VAR syskey : tgg00_SysInfoKey) : tak_sysbufferaddress;
 
VAR
      find_info : tak10_find_info;
 
BEGIN
ak10find_syskey (acv, syskey, find_info, NOT cak10CheckReferences);
IF  find_info.fi_res = l_equal
THEN
    BEGIN
    a10KeepRecord := @find_info.fi_ptr.cdir_ptr^.cd_sysinfo;
    ak10del_in_dir (acv, syskey);
    END
ELSE
    a10KeepRecord := NIL;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_key_del (
            VAR acv    : tak_all_command_glob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      find_info : tak10_find_info;
 
BEGIN
&ifdef trace
IF  t01trace( ak_cach )
THEN
    BEGIN
    t01catalog_entrytype( ak_cach, syskey.sentrytyp[ 2 ] );
    t01buf1 (ak_cach, syskey, 1 + cgg_rec_key_offset,
          syskey.skeylen + cgg_rec_key_offset);
    END
ELSE
    BEGIN
    t01catalog_entrytype( ak_sem, syskey.sentrytyp[ 2 ] );
    t01buf1 (ak_sem, syskey, 1 + cgg_rec_key_offset,
          syskey.skeylen + cgg_rec_key_offset);
    END;
(*ENDIF*) 
&endif
ak10find_syskey (acv, syskey, find_info, NOT cak10CheckReferences);
IF  find_info.fi_res = l_equal
THEN
    BEGIN
    ak10temp_add (acv, find_info.fi_ptr, NOT c_is_rollback);
    ak10block_into_freelist (acv, find_info.fi_ptr, c_del_in_directory,
          c_del_dependecies)
    END;
&ifdef TRACE
(*ENDIF*) 
ak10verify_cache (acv)
&     endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10key_del  (
            VAR acv         : tak_all_command_glob;
            VAR  syspointer : tak_sysbufferaddress);
 
VAR
      curr   : tak_cache_dir_pointer;
 
BEGIN
IF  (syspointer <> NIL) AND NOT ak10_IsSharedRecord(syspointer)
THEN
    BEGIN
    curr.sys_ptr := syspointer;
    curr.buf_ptr :=
          s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
&   ifdef trace
    IF  t01trace( ak_cach )
    THEN
        BEGIN
        t01catalog_entrytype( ak_cach, syspointer^.syskey.sentrytyp[ 2 ] );
        t01buf1 (ak_cach, syspointer^.syskey, 1 + cgg_rec_key_offset,
              syspointer^.syskey.skeylen + cgg_rec_key_offset);
        END
    ELSE
        BEGIN
        t01catalog_entrytype( ak_sem, syspointer^.syskey.sentrytyp[ 2 ] );
        t01buf1 (ak_sem, syspointer^.syskey, 1 + cgg_rec_key_offset,
              syspointer^.syskey.skeylen + cgg_rec_key_offset);
        END;
    (*ENDIF*) 
    IF  (syspointer^.syskey.sentrytyp[1] <> chr(0)) OR
        (syspointer^.syskey.sentrytyp[2] > chr(cak_emax))
    THEN
        ak10cache_error (acv,  'no pointer to sysinfo   ', curr);
&   endif
    (*ENDIF*) 
    syspointer := NIL;
    IF  NOT ak10IsSharedSQLRecord (curr)
    THEN
        BEGIN
&       ifdef trace
        IF  curr.cdir_ptr^.cd_check <> cak_cache_chunk_flag
        THEN
            ak10cache_error (acv,  'no pointer to sysinfo   ', curr);
&       endif
        (*ENDIF*) 
        ak10temp_add (acv, curr, NOT c_is_rollback);
        IF  curr.cdir_ptr^.cd_lru_next.cdir_ptr = NIL
        THEN
            ak10cache_error (acv,  'releasing unused ptr    ', curr);
        (*ENDIF*) 
        ak10block_into_freelist (acv, curr, c_del_in_directory, c_del_dependecies);
        END;
&   ifdef TRACE
    (*ENDIF*) 
    ak10verify_cache (acv)
&         endif
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_lock_sysinfo (
            VAR acv    : tak_all_command_glob;
            VAR syskey : tgg00_SysInfoKey;
            lockm      : tgg00_LockReqMode);
 
VAR
      b_err      : tgg00_BasisError;
      mblock     : tgg00_MessBlock;
      qual       : tgg00_QualBuf;
      data       : tsp00_Buf;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef trace
    t01buf1 (ak_sem, syskey, cgg_rec_key_offset+1,
          syskey.skeylen+cgg_rec_key_offset);
&   endif
    b_err := e_ok;
    g01mblock_init (acv.a_transinf.tri_trans,
          m_lock, mm_nil, mblock);
    g01qual_init     (mblock, @qual, sizeof (qual));
    g01datapart_init (mblock, @data, sizeof (data));
    mblock.mb_struct          := mbs_lock;
    mblock.mb_qual^.mlock_cnt := 1;
    WITH mblock.mb_qual^.mlock[ 1 ] DO
        BEGIN
        IF  syskey.sentrytyp > cak_esysfile2
        THEN
            BEGIN
            kb560GetSys2CatalogTabId (lockTabId_gg00);
            lockKeyLen_gg00 := syskey.skeylen
            END
        ELSE
            BEGIN
            lockTabId_gg00  := syskey.stableid;
            lockKeyLen_gg00 := mxsp_c8
            END;
        (*ENDIF*) 
        lockMode_gg00   := lockm;
        IF  lockMode_gg00 = lckSysExcl_egg00
        THEN
            lockState_gg00 := [ lrsEotExcl_egg00 ]
        ELSE
            lockState_gg00 := [  ];
        (*ENDIF*) 
        lockKeyPos_gg00 := 1;
        (* PTS 1116837 E.Z. *)
        (* lockKeyPos means BEHIND cgg_rec_key_offset ! *)
        SAPDB_PascalMove ('VAK10 ',   7,    
              sizeof (syskey), mblock.mb_data_size,
              @syskey, cgg_rec_key_offset + 1,
              @mblock.mb_data^.mbp_buf, cgg_rec_key_offset + lockKeyPos_gg00,
              lockKeyLen_gg00, b_err);
        mblock.mb_qual_len  := MB_PART1_LOCKHEAD_MXGG04 + LOCK_MXGG04;
        mblock.mb_data_len  := lockKeyLen_gg00 + cgg_rec_key_offset
        END;
    (*ENDWITH*) 
    IF  b_err = e_ok
    THEN
        a06lsend_mess_buf (acv, mblock, NOT c_call_from_rsend, b_err);
    (*ENDIF*) 
    IF  b_err = e_wait_for_lock_release
    THEN
        BEGIN
        k53wait (mblock.mb_trns^, m_lock, mm_nil);   (* PTS 1106270 JA 2000-04-06 *)
        b_err := mblock.mb_trns^.trError_gg00;       (* PTS 1106270 JA 2000-04-06 *)
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1);
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a10NextDisplacedKey (
            VAR acv      : tak_all_command_glob;
            VAR syskey   : tgg00_SysInfoKey) : boolean;
 
VAR
      e            : tgg00_BasisError;
      nextFound    : boolean;
      pKey         : ^tgg00_Lkey;
      tree_pos     : tgg00_FilePos;
      set_result   : tgg00_BdSetResultRecord;
 
      buf          : RECORD
            CASE integer OF
                1 :
                    (sb : tak_systembuffer);
                2 :
                    (b : tsp00_Buf);
                END;
            (*ENDCASE*) 
 
 
BEGIN
nextFound := false;
IF  acv.a_sysdir.ci_cmd_rollback_tree.fileRoot_gg00 <> NIL_PAGE_NO_GG00
THEN
    BEGIN
    pKey := @syskey;
    tree_pos.tpsPno_gg00 := NIL_PAGE_NO_GG00;
    WITH set_result DO
        BEGIN
        bd_key_check_len:= 0;
        bd_max_rec_cnt  := 1;
        bd_max_fill_len := sizeof (buf);
        bd_next         := true;
        END;
    (*ENDWITH*) 
    b07cnext_record (acv.a_transinf.tri_trans,
          acv.a_sysdir.ci_cmd_rollback_tree,
          pKey^, set_result, tree_pos, buf.b);
    e := acv.a_transinf.tri_trans.trError_gg00;
    IF  (e = e_ok           ) OR
        (e = e_key_not_found)
    THEN
        BEGIN
        nextFound := true;
        syskey    := buf.sb.syskey;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
a10NextDisplacedKey := nextFound;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10next_sysinfo (
            VAR acv      : tak_all_command_glob;
            VAR syskey   : tgg00_SysInfoKey;
            stop_prefix  : integer;
            dstate       : tak_directory_state;
            rec_kind     : tsp00_C2;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
CONST
      pos_sentrytyp     = 9;
      c_max_stack_index = 6;
 
VAR
      entrypos  : integer;
      find_info : tak10_find_info;
      stack     : ARRAY[1..c_max_stack_index] OF tgg00_StackEntry;
      data      : tsp00_Buf;
      qual      : tak10qual;
      mblock    : tgg00_MessBlock;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    CASE syskey.sentrytyp[2] OF
        cak_cpermmessblock :
            IF  syskey.skeylen = a01defaultkey.skeylen
            THEN
                BEGIN
                syskey.skeylen := syskey.skeylen + 1;
                syskey.all[syskey.skeylen] := chr(255);
                END;
            (*ENDIF*) 
        cak_cmethod :
            BEGIN
            syskey.slinkage[1] := chr(255);
            syskey.slinkage[2] := chr(255);
            END;
        OTHERWISE ;
        END;
    (*ENDCASE*) 
&   ifdef trace
    t01buf1 (ak_sem, syskey, cgg_rec_key_offset + 1, cgg_rec_key_offset
          + syskey.skeylen);
&   endif
    entrypos  := pos_sentrytyp;
    g01mblock_init (acv.a_transinf.tri_trans,
          m_select_row, mm_next, mblock);
    g01stack_init (mblock,
          @stack, sizeof (stack), @qual, sizeof (qual));
    g01datapart_init (mblock, @data, sizeof (data));
    mblock.mb_qual_len := sizeof (qual.q_hd);
    WITH mblock.mb_qual^ DO
        BEGIN
        mqual_pos := mfirst_free;
        IF  (rec_kind = cak_edummy)    OR
            (rec_kind = cak_esysfile2) OR
            (rec_kind = cak_etemp)
        THEN
            BEGIN
            mqual_cnt := 1;
            WITH  mblock.mb_st^ [1] DO
                BEGIN
                etype          := st_rec_output;
                eop            := op_none;
                epos           := 0;
                elen_var       := 0;
                ecol_tab [ 1 ] := chr(0);
                ecol_tab [ 2 ] := chr(0);
                END;
            (*ENDWITH*) 
            END
        ELSE
            BEGIN
            mqual_cnt := 3;
            WITH  mblock.mb_st^ [1] DO
                BEGIN
                etype          := st_fixkey;
                eop            := op_none;
                epos           := entrypos;
                elen_var       := 2;
                ecol_tab [ 1 ] := chr(0);
                ecol_tab [ 2 ] := chr(0);
                END;
            (*ENDWITH*) 
            WITH  mblock.mb_st^ [2] DO
                BEGIN
                etype          := st_value;
                eop            := op_eq_all;
                (*=============================*)
                (* op_eq_all to force KB to    *)
                (* use lcomp  !!!              *)
                (*=============================*)
                epos           := cgg_rec_key_offset + 1;
                elen_var       := 2;
                ecol_tab       := cgg_zero_c2
                END;
            (*ENDWITH*) 
            WITH  mblock.mb_st^ [3] DO
                BEGIN
                etype          := st_rec_output;
                eop            := op_none;
                epos           := 0;
                elen_var       := 0;
                ecol_tab       := cgg_zero_c2
                END;
            (*ENDWITH*) 
            mblock.mb_data^.mbp_buf [cgg_rec_key_offset+1] := rec_kind[1];
            mblock.mb_data^.mbp_buf [cgg_rec_key_offset+2] := rec_kind[2];
            END;
        (*ENDIF*) 
        mfirst_free := succ(mqual_cnt);
        (* startkey buildup: *)
        mstrat_pos  := mfirst_free;
        WITH mblock.mb_st^ [mfirst_free] DO
            BEGIN
            etype         := st_strat;
            eop           := op_none;
            epos          := cgg_rec_key_offset + 3;
            elen_var      := syskey.skeylen;
            ecol_tab[ 1 ] := chr(0);
            ecol_tab[ 2 ] := chr(0);
            END;
        (*ENDWITH*) 
        SAPDB_PascalMove ('VAK10 ',   8,    
              sizeof (syskey), mblock.mb_data_size,
              @syskey, cgg_rec_key_offset + 1,
              @mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 3,
              syskey.skeylen,  acv.a_returncode);
        mblock.mb_data_len := cgg_rec_key_offset + 2 +
              syskey.skeylen;
        mfirst_free := succ(mfirst_free);
        (* stopkey buildup: *)
        mblock.mb_st^ [mfirst_free] := mblock.mb_st^ [mstrat_pos];
        WITH mblock.mb_st^ [mfirst_free] DO
            BEGIN
            IF  stop_prefix > 0
            THEN
                BEGIN
                epos     := cgg_rec_key_offset + syskey.skeylen + 3;
                elen_var := SYSKEY_MXGG00
                END
            ELSE
                BEGIN
                epos     := 0;
                elen_var := 0
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        mfirst_free := succ(mfirst_free);
        mstrat_cnt  := 2;
        IF  stop_prefix > 0
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK10 ',   9,    
                  sizeof (syskey), mblock.mb_data_size,
                  @syskey, cgg_rec_key_offset+1, @mblock.mb_data^.mbp_buf,
                  mblock.mb_data_len + 1, stop_prefix,
                  acv.a_returncode);
            SAPDB_PascalFill ('VAK10 ',  10,    
                  mblock.mb_data_size, @mblock.mb_data^.mbp_buf,
                  mblock.mb_data_len + stop_prefix + 1,
                  SYSKEY_MXGG00 - stop_prefix, chr(255),
                  acv.a_returncode);
            mblock.mb_data_len := mblock.mb_data_len + SYSKEY_MXGG00
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        ak10send_mess_block (acv, mblock,
              rec_kind, true, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            a10expand_rec (mblock.mb_data^.mbp_rec, b_err);
            find_info.fi_kind := get_next;
            IF  b_err = e_ok
            THEN
                ak10put_mbuf_into_cache (acv, mblock.mb_data^.mbp_rec,
                      dstate, find_info, syskey, syspoint)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_returncode <> 0
THEN
    b_err := e_cancelled;
&ifdef TRACE
(*ENDIF*) 
ak10verify_cache (acv)
&     endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_nil_get_sysinfo (
            VAR acv      : tak_all_command_glob;
            VAR syskey   : tgg00_SysInfoKey;
            dstate       : tak_directory_state;
            syslen       : tsp00_Int4;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
VAR
      find_info : tak10_find_info;
      rbuf      : tgg00_BufLenInfo;
 
      p         : RECORD
            CASE boolean OF
                true :
                    (mobj : tak_sysbufferaddress);
                false :
                    (cip  : tak_basecolinfo_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
syspoint := NIL;
IF  syslen < cak_sysbufferoffset
THEN
    a07_b_put_error (acv, e_illegal_key, 1)
ELSE
    ak10size_check (acv, syskey.sentrytyp, syslen);
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef TRACE
    IF  t01trace( ak_cach )
    THEN
        BEGIN
        t01str30 (ak_cach, '===== a10_nil_get_sysinfo ====');
        t01catalog_entrytype( ak_cach, syskey.sentrytyp[ 2 ] );
        t01buf1  (ak_cach, syskey, cgg_rec_key_offset + 1,
              syskey.skeylen + cgg_rec_key_offset);
        t01int4 (ak_cach, 'required len', syslen);
        END
    ELSE
        BEGIN
        t01str30 (ak_sem, '===== a10_nil_get_sysinfo ====');
        t01catalog_entrytype( ak_sem, syskey.sentrytyp[ 2 ] );
        t01buf1  (ak_sem, syskey, cgg_rec_key_offset + 1,
              syskey.skeylen + cgg_rec_key_offset);
        t01int4 (ak_sem, 'required len', syslen);
        END;
    (*ENDIF*) 
&   endif
    b_err             := e_ok;
    find_info.fi_kind := nil_get;
    ak10find_syskey (acv, syskey, find_info, NOT cak10CheckReferences);
    IF  find_info.fi_res = l_equal
    THEN
        BEGIN
        syspoint := @find_info.fi_ptr.cdir_ptr^.cd_sysinfo;
        IF  (dstate = d_fix) AND
            (find_info.fi_ptr.cdir_ptr^.cd_fix_next.cdir_ptr = NIL)
        THEN
            BEGIN
            (*========== Chain into FIX-List ============*)
            find_info.fi_ptr.cdir_ptr^.cd_fix_next :=
                  acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_fix_next;
            find_info.fi_ptr.cdir_ptr^.cd_fix_prev :=
                  acv.a_sysdir.ci_cache_dir_header;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.
                  cd_fix_next.cdir_ptr^.cd_fix_prev :=
                  find_info.fi_ptr;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_fix_next
                  := find_info.fi_ptr
            END;
        (*ENDIF*) 
        IF  NOT a101_IsStatementActive(acv, find_info.fi_ptr.cdir_ptr^.cd_cmd_no)
        THEN
            find_info.fi_ptr.cdir_ptr^.cd_cmd_no := acv.a_command_id;
        (*ENDIF*) 
        b_err := e_duplicate_sysinfo;
        ak10store_syskey (acv, syskey)
        END
    ELSE
        BEGIN
        rbuf.ri.basesyskey       := syskey;
        rbuf.ri.rb_len           := syslen;
        rbuf.ri.rb_varcol_offset := 0;
        rbuf.ri.rb_varcol_cnt    := 0;
        ak10put_mbuf_into_cache (acv, rbuf.rb,
              dstate, find_info, syskey, syspoint)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (syskey.sentrytyp[2] in [cak_ctable, cak_cresult]) AND
    (find_info.fi_res <> l_equal)                      AND
    (acv.a_returncode = 0)
THEN
    IF  (syslen >=
        sizeof (tak_baserecord) - sizeof (syspoint^.sbase.bcolumn))
    THEN
        BEGIN
        syspoint^.sbase.breccnt := 0;
        syspoint^.sbase.bptr    := NIL
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_returncode <> 0
THEN
    b_err := e_cancelled;
&ifdef trace
(*ENDIF*) 
IF  (b_err = e_ok) AND
    (syskey.sentrytyp[2] in [cak_cmessblock, cak_cpermmessblock, cak_ctriggerparsinfo])
THEN
    BEGIN
    syspoint^.smessblock.mbr_mess_block.mb_qual := NIL;
    syspoint^.smessblock.mbr_mess_block.mb_data := NIL;
    syspoint^.smessblock.mbr_mess_block.mb_st   := NIL;
    syspoint^.smessblock.mbr_mess_block.mb_strat:= NIL;
    END;
&endif
&ifdef TRACE
(*ENDIF*) 
ak10verify_cache (acv)
&     endif
END;
 
(*------------------------------*) 
 
FUNCTION
      a10NoTableInfoInCache (
            VAR acv  : tak_all_command_glob) : boolean;
 
VAR
      ln_len : integer;
 
      msg    : RECORD
            CASE boolean OF
                true :
                    (c40 : tsp00_C40);
                false :
                    (ln : tsp00_Line);
                END;
            (*ENDCASE*) 
 
      curr   : tak_cache_dir_pointer;
 
BEGIN
curr := acv.a_sysdir.ci_dir [ord(cak_ctable)];
IF  curr.cdir_ptr <> NIL
THEN
    BEGIN
    ak10writeln (curr);
    msg.c40 := 'refCount :                              ';
    ln_len  := 11;
    g17int4to_line (curr.cdir_ptr^.cd_refCount, false, 10, ln_len + 1, msg.ln);
    g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_dump,
          csp3_n_akcache, msg.c40);
    b120InsertTrace (acv.a_transinf.tri_trans,
          ta, td_none, ln_len, @msg);
    msg.c40 := 'is active :                             ';
    IF  a101_IsStatementActive(acv, curr.cdir_ptr^.cd_cmd_no)
    THEN
        msg.c40[13] := 'T'
    ELSE
        msg.c40[13] := 'F';
    (*ENDIF*) 
    g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_dump,
          csp3_n_akcache, msg.c40);
    b120InsertTrace (acv.a_transinf.tri_trans,
          ta, td_none, 14, @msg);
    msg.c40 := 'is active :                             ';
    msg.c40 := 'is reference :                          ';
    IF  dreference in curr.cdir_ptr^.cd_state
    THEN
        msg.c40[15] := 'T'
    ELSE
        msg.c40[15] := 'F';
    (*ENDIF*) 
    g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_dump,
          csp3_n_akcache, msg.c40);
    b120InsertTrace (acv.a_transinf.tri_trans,
          ta, td_none, 16, @msg);
    a10NoTableInfoInCache := false;
    END
ELSE
    a10NoTableInfoInCache := true;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_rel_sysinfo (
            VAR acv    : tak_all_command_glob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      find_info : tak10_find_info;
 
BEGIN
ak10find_syskey (acv, syskey, find_info, NOT cak10CheckReferences);
IF  (find_info.fi_res = l_equal) AND NOT ak10IsSharedSQLRecord (find_info.fi_ptr)
THEN
    WITH find_info.fi_ptr.cdir_ptr^ DO
        BEGIN
&       ifdef trace
        xtd_directory (ak_cach, find_info.fi_ptr);
&       endif
        IF  (cd_fix_next.cdir_ptr <> NIL) AND (cd_refCount = 0)
        THEN
            BEGIN
            (* syskey found in cache, remove block from fix list *)
            cd_fix_next.cdir_ptr^.cd_fix_prev := cd_fix_prev;
            cd_fix_prev.cdir_ptr^.cd_fix_next := cd_fix_next;
            cd_fix_next.cdir_ptr := NIL
            END;
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
&ifdef trace
(*ENDIF*) 
ak10verify_cache (acv);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10rel_sysinfo (syspointer : tak_sysbufferaddress);
 
VAR
      curr   : tak_cache_dir_pointer;
 
BEGIN
IF  syspointer <> NIL
THEN
    BEGIN
&   ifdef trace
    IF  t01trace( ak_cach )
    THEN
        BEGIN
        t01catalog_entrytype( ak_cach, syspointer^.syskey.sentrytyp[ 2 ] );
        t01buf1  (ak_cach, syspointer^.syskey, cgg_rec_key_offset + 1,
              syspointer^.syskey.skeylen + cgg_rec_key_offset);
        END
    ELSE
        BEGIN
        t01catalog_entrytype( ak_sem, syspointer^.syskey.sentrytyp[ 2 ] );
        t01buf1  (ak_sem, syspointer^.syskey, cgg_rec_key_offset + 1,
              syspointer^.syskey.skeylen + cgg_rec_key_offset);
        END;
    (*ENDIF*) 
&   endif
    IF  NOT ak10_IsSharedRecord (syspointer)
    THEN
        BEGIN
        curr.sys_ptr := syspointer;
        curr.buf_ptr :=
              s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
        WITH curr.cdir_ptr^ DO
            BEGIN
&           ifdef trace
            xtd_directory (ak_cach, curr);
&           endif
            IF  (cd_fix_next.cdir_ptr <> NIL) AND (cd_refCount = 0)
            THEN
                BEGIN
                (* remove block from fix list *)
                cd_fix_next.cdir_ptr^.cd_fix_prev := cd_fix_prev;
                cd_fix_prev.cdir_ptr^.cd_fix_next := cd_fix_next;
                cd_fix_next.cdir_ptr := NIL
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10repl_sysinfo (
            VAR acv      : tak_all_command_glob;
            VAR syspoint : tak_sysbufferaddress;
            VAR b_err    : tgg00_BasisError);
 
VAR
      find_info : tak10_find_info;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
&   ifdef trace
    IF  t01trace( ak_cach )
    THEN
        BEGIN
        t01catalog_entrytype( ak_cach, syspoint^.syskey.sentrytyp[ 2 ] );
        t01buf1 (ak_cach,
              syspoint^.syskey, 1 + cgg_rec_key_offset,
              syspoint^.syskey.skeylen + cgg_rec_key_offset);
        END
    ELSE
        BEGIN
        t01catalog_entrytype( ak_sem, syspoint^.syskey.sentrytyp[ 2 ] );
        t01buf1 (ak_sem,
              syspoint^.syskey, 1 + cgg_rec_key_offset,
              syspoint^.syskey.skeylen + cgg_rec_key_offset);
        END;
    (*ENDIF*) 
&   endif
    ak10find_syskey (acv, syspoint^.syskey, find_info, NOT cak10CheckReferences);
    IF  find_info.fi_res = l_equal
    THEN
        BEGIN
&       ifdef trace
        xtd_directory (ak_cach, find_info.fi_ptr);
&       endif
        IF  (syspoint^.syskey.sentrytyp < cak_etemp) OR
            ((syspoint^.syskey.sentrytyp > cak_elogged_temp)         AND
            NOT acv.a_in_ddl_trigger                                 AND
            NOT (hsNoLog_egg00 in acv.a_pars_curr.fileHandling_gg00) AND
            NOT a663parse_for_execute (acv))
        THEN
            ak10add_upd_perm_record (acv, find_info,
                  syspoint, m_update_rec, b_err)
        ELSE
            WITH find_info.fi_ptr.cdir_ptr^ DO
                BEGIN
                IF  dwritten in cd_state
                THEN
                    cd_state := cd_state + [ dmodified ];
                (*ENDIF*) 
                b_err  := e_ok;
                IF  syspoint^.syskey.sentrytyp[2] in
                    [cak_cjparsinfo, cak_cparsinfo, cak_cshortinfo,
                    cak_creskey, cak_clinkpos, cak_clongliteral]
                THEN
                    syspoint^.sparsinfo.p_fullen :=
                          syspoint^.b_sl;
                (*ENDIF*) 
                IF  NOT (dadd_rec in cd_state) AND
                    NOT (dwritten in cd_state)
                THEN
                    b_err := e_key_not_found;
                (*ENDIF*) 
                END
            (*ENDWITH*) 
        (*ENDIF*) 
        END
    ELSE
        b_err := e_key_not_found;
    (*ENDIF*) 
    IF  b_err = e_key_not_found
    THEN
        BEGIN
        b_err := e_sysinfo_not_found;
        ak10store_syskey (acv, syspoint^.syskey)
        END;
    (*ENDIF*) 
    END
ELSE
    b_err := e_cancelled;
(*ENDIF*) 
&ifdef TRACE
ak10verify_cache (acv)
&     endif
END;
 
(* PTS 1103813 *)
(*------------------------------*) 
 
PROCEDURE
      a10SessionCacheInit (
            VAR acv : tak_all_command_glob);
 
VAR
      next : tak_cache_dir_pointer;
      curr : tak_cache_dir_pointer;
 
BEGIN
WITH acv.a_sysdir  DO
    IF  ci_cache_p <> NIL
    THEN
        BEGIN
        next := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
        WHILE next.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
            BEGIN
            curr := next;
            next := next.cdir_ptr^.cd_lru_prev;
            ak10block_into_freelist (acv,
                  curr, c_del_in_directory, c_del_dependecies)
            END;
        (*ENDWHILE*) 
        ci_tmp_dislodged := false;
&       ifdef trace
        ak10td_dirlist  (acv, ak_cach);
        ak10td_freelist (acv, ak_cach);
&       endif
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10StoreAs (
            VAR acv         : tak_all_command_glob;
            syskey          : tgg00_SysInfoKey; (* must not be var *)
            VAR storeSyskey : tgg00_SysInfoKey;
            VAR e           : tgg00_BasisError);
 
VAR
      reccnt    : integer;
      p         : tak_sysbufferaddress;
      find_info : tak10_find_info;
      dummy     : boolean;
 
BEGIN
IF  acv.a_returncode <> 0
THEN
    e := e_cancelled
ELSE
    BEGIN
    ak10find_syskey (acv, syskey, find_info, NOT cak10CheckReferences);
    IF  find_info.fi_ptr.cdir_ptr <> NIL
    THEN
        WITH find_info.fi_ptr.cdir_ptr^ DO
            BEGIN
            reccnt := 0;
            IF  cd_syskey.sentrytyp[2] in [cak_ctable, cak_cresult]
            THEN
                BEGIN
                reccnt                   := cd_sysinfo.sbase.breccnt;
                cd_sysinfo.sbase.breccnt := 0;
                END;
            (* copy store key into catalog record *)
            (*ENDIF*) 
            SAPDB_PascalForcedMove (sizeof (storeSyskey), sizeof (cd_syskey), @storeSyskey,
                  cgg_rec_key_offset+1,
                  @cd_syskey, cgg_rec_key_offset+1, storeSyskey.skeylen);
            (* insert store key into directory (temporary) *)
            ak10ins_directory (acv, find_info,
                  acv.a_sysdir.ci_dir [ord(storeSyskey.sentrytyp[2])],
                  find_info.fi_ptr, dummy);
            p := @cd_sysinfo;
            a10add_sysinfo (acv, p, e);
            ak10del_in_dir  (acv, storeSyskey);
            SAPDB_PascalForcedMove (sizeof (syskey), sizeof (cd_syskey), @syskey,
                  cgg_rec_key_offset+1,
                  @cd_syskey, cgg_rec_key_offset+1, syskey.skeylen);
            IF  reccnt > 0
            THEN
                cd_sysinfo.sbase.breccnt := reccnt;
            (*ENDIF*) 
            END
        (*ENDWITH*) 
    ELSE
        e := e_sysinfo_not_found;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_upd_key (
            VAR acv      : tak_all_command_glob;
            VAR parsk    : tak_parskey;
            displacement : integer;
            VAR b_err    : tgg00_BasisError);
 
VAR
      dummy     : boolean;
      cnt       : integer;
      max_cnt   : integer;
      sysp      : tak_sysbufferaddress;
      p         : tak_cache_dir_pointer;
      old_parsk : tak_parskey;
      find_info : tak10_find_info;
      sysk      : tgg00_SysInfoKey;
 
BEGIN
cnt               := 0;
max_cnt           := 1;
sysk              := a01sysnullkey;
sysk.sauthid[ 1 ] := cak_tempinfo_byte;
sysk.sentrytyp    := cak_eparsinfo;
old_parsk         := parsk;
parsk.p_no        := parsk.p_no - displacement;
REPEAT
    cnt   := succ(cnt);
    SAPDB_PascalForcedMove (sizeof (parsk), sizeof (sysk.sauthid),
          @old_parsk, 1, @sysk.sauthid, 2, mxak_parskey);
    a10get_sysinfo (acv, sysk, d_release, sysp, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        ak10find_syskey (acv, sysk, find_info, NOT cak10CheckReferences);
        ak10del_in_dir  (acv, sysk);
        IF  dwritten in find_info.fi_ptr.cdir_ptr^.cd_state
        THEN
            a10del_sysinfo (acv, sysk, b_err);
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            SAPDB_PascalForcedMove (sizeof (parsk), sizeof (sysk.sauthid),
                  @parsk, 1, @sysk.sauthid, 2, mxak_parskey);
            p := find_info.fi_ptr;
            ak10find_syskey (acv, sysk, find_info, NOT cak10CheckReferences);
            IF  find_info.fi_res = l_equal
            THEN
                BEGIN
                b_err := e_duplicate_sysinfo;
                ak10store_syskey (acv, sysk)
                END
            ELSE
                BEGIN
                sysp^.syskey.sstandardkey  := sysk.sstandardkey;
                ak10ins_directory (acv, find_info,
                      acv.a_sysdir.ci_dir [ ord (sysk.sentrytyp[ 2 ]) ],
                      p, dummy);
                WITH p.cdir_ptr^  DO
                    cd_state := cd_state -
                          [ dadd_rec, dmodified, dwritten ];
                (*ENDWITH*) 
                a10add_sysinfo (acv, sysp, b_err);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    sysk.sauthid[ 1 + mxak_parskey + 1 ] :=
          chr(ord(sysk.sauthid[ 1 + mxak_parskey + 1 ]) + 1);
    IF  cnt = max_cnt
    THEN
        IF  sysk.sentrytyp[2] in [cak_cparsinfo, cak_cmessblock]
        THEN
            BEGIN
            b_err          := e_ok;
            max_cnt        := max_cnt + 1;
            sysk.slinkage  := cgg_zero_c2;
            IF  sysk.sentrytyp = cak_eparsinfo
            THEN
                sysk.sentrytyp := cak_emessblock
            ELSE
                sysk.sentrytyp := cak_echangeinfos;
            (*ENDIF*) 
            sysk.sauthid[1 + mxak_parskey + 1] :=
                  a01sysnullkey.sauthid[1 + mxak_parskey + 1]
            END;
        (*ENDIF*) 
    (*ENDIF*) 
UNTIL
    (b_err <> e_ok) OR (cnt = max_cnt);
(*ENDREPEAT*) 
IF  (b_err = e_sysinfo_not_found) AND
    (sysk.sentrytyp[2] in [cak_cchangeinfos, cak_cmessblock])
THEN
    b_err := e_ok
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10_version (
            VAR acv : tak_all_command_glob;
            VAR base_rec   : tak_baserecord;
            m_type         : tgg00_MessType;
            view_scan      : boolean);
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a10alter_long_version (acv, base_rec,
          base_rec.bstringcount, m_type, view_scan)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10add_base_record (
            VAR acv     : tak_all_command_glob;
            syspoint    : tak_sysbufferaddress;
            via_kb      : boolean;
            m_type      : tgg00_MessType;
            VAR b_err   : tgg00_BasisError);
 
VAR
      version  : tsp00_C2;
      ix       : integer;
      move_len : integer;
      p        : tak_sysbufferaddress;
      buf_cnt  : integer;
      rec_cnt  : integer;
      rec      : tgg00_Rec;
      colptr   : tak00_colinfo_ptr;
 
      last     : RECORD
            CASE boolean OF
                true :
                    (colp : tak_basecolinfo_ptr);
                false :
                    (sysp : tak_sysbufferaddress);
                END;
            (*ENDCASE*) 
 
      sysk     : tgg00_SysInfoKey;
 
BEGIN
b_err := e_ok;
p     := @rec;
IF  syspoint^.sbase.btablekind = tsynonym
THEN
    BEGIN
    move_len := mxak_synonymrec_offset;
    SAPDB_PascalMove ('VAK10 ',  11,    
          sizeof (syspoint^.sbase), sizeof (rec.buf),
          @syspoint^, 1, @rec.buf, 1, move_len, b_err);
    rec.len  := move_len;
    (* move tablename into buffer *)
    move_len := a061identifier_len (syspoint^.ssynonym.syn_tablen);
    rec.buf[rec.len+1] := chr(move_len);
    SAPDB_PascalMove ('VAK10 ',  12,    
          sizeof (syspoint^.ssynonym.syn_tablen), sizeof (rec.buf),
          @syspoint^.ssynonym.syn_tablen, 1, @rec.buf, rec.len + 2, move_len,
          b_err);
    rec.len := rec.len + 1 + move_len;
    IF  b_err = e_ok
    THEN
        ak10send_ins_upd (acv, p, m_type, b_err)
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  syspoint^.sbase.btablekind in [tview, tcomplexview]
    THEN
        BEGIN (* PTS 1111114 *)
        vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
        ak10joinViewVersion.map_int := ak10joinViewVersion.map_int + 1;
        vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
        version := ak10joinViewVersion.map_c2
        END
    ELSE
        version  := syspoint^.sbase.btreeid.fileVersion_gg00.ci2_gg00;
    (*ENDIF*) 
    buf_cnt  := syspoint^.sbase.breccnt;
&   ifdef trace
    t01int4 (ak_cach, 'buf_cnt     ', buf_cnt);
&   endif
    syspoint^.sbase.breccnt := 0;
    move_len                := a10BaseRecPersistentOffset; (* PTS 1105713, T.A. 24.02.2000 *)
    SAPDB_PascalMove ('VAK10 ',  13,    
          sizeof (syspoint^.sbase), sizeof (rec.buf),
          @syspoint^, 1, @rec.buf, 1, move_len, b_err);
    rec.len  := move_len;
    (* move tablename into buffer *)
    move_len := a061identifier_len (syspoint^.sbase.btablen^);
    rec.buf[rec.len+1] := chr(move_len);
    SAPDB_PascalMove ('VAK10 ',  14,    
          sizeof (syspoint^.sbase.btablen^), sizeof (rec.buf),
          @syspoint^.sbase.btablen^, 1, @rec.buf, rec.len + 2, move_len, b_err);
    rec.len := rec.len + 1 + move_len;
    (* move column infos into buffer *)
    rec_cnt := 0;
&   ifdef trace
    t01int4 (ak_sem, 'bfirstindex ', syspoint^.sbase.bfirstindex);
    t01int4 (ak_sem, 'blastindex  ', syspoint^.sbase.blastindex);
&   endif
    ix      := syspoint^.sbase.bfirstindex;
    WHILE (ix <= syspoint^.sbase.blastindex) AND (b_err = e_ok) DO
        BEGIN
        colptr   := syspoint^.sbase.bcolumn[ix];
&       ifdef trace
        a061td_colinfo (colptr^, ix);
&       endif
        move_len := sizeof (colptr^) - sizeof (colptr^.ccolumnn) +
              ord (colptr^.ccolumnn_len);
        IF  rec.len + move_len > MAX_RECLEN_GG00
        THEN
            BEGIN
            IF  via_kb
            THEN
                BEGIN
                IF  rec_cnt + 1 > buf_cnt
                THEN
                    m_type := m_insert
                ELSE
                    m_type := m_update_rec;
                (*ENDIF*) 
                p^.sbase.bsegmentid := version; (* PTS 1111114 *)
                ak10send_ins_upd (acv,
                      p, m_type, b_err)
                END
            ELSE
                BEGIN
                IF  m_type = m_insert
                THEN
                    b07cadd_record (acv.a_transinf.tri_trans,
                          acv.a_pars_curr, p^)
                ELSE
                    b07crepl_record (acv.a_transinf.tri_trans,
                          acv.a_pars_curr, p^);
                (*ENDIF*) 
                b_err := acv.a_transinf.tri_trans.trError_gg00
                END;
            (*ENDIF*) 
            a06inc_linkage (p^.syskey.slinkage);
            IF  b_err = e_ok
            THEN
                BEGIN
                rec_cnt                 := rec_cnt + 1;
                syspoint^.sbase.breccnt :=
                      syspoint^.sbase.breccnt + 1;
                rec.len := cak_sysbufferoffset +
                      sizeof (syspoint^.sbase.bsegmentid)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK10 ',  15,    
              move_len, sizeof (rec.buf),
              @colptr^, 1, @rec.buf, rec.len + 1, move_len, b_err);
        rec.len := rec.len + move_len;
        ix      := ix + 1
        END;
    (*ENDWHILE*) 
    IF  b_err = e_ok
    THEN
        BEGIN
        IF  via_kb
        THEN
            BEGIN
            IF  rec_cnt + 1 > buf_cnt
            THEN
                m_type := m_insert
            ELSE
                m_type := m_update_rec;
            (*ENDIF*) 
            p^.sbase.bsegmentid := version; (* PTS 1111114 *)
            ak10send_ins_upd (acv,
                  p, m_type, b_err)
            END
        ELSE
            BEGIN
            IF  m_type = m_insert
            THEN
                b07cadd_record (acv.a_transinf.tri_trans,
                      acv.a_pars_curr, p^)
            ELSE
                b07crepl_record (acv.a_transinf.tri_trans,
                      acv.a_pars_curr, p^);
            (*ENDIF*) 
            b_err := acv.a_transinf.tri_trans.trError_gg00
            END;
        (*ENDIF*) 
        syspoint^.sbase.breccnt := syspoint^.sbase.breccnt + 1;
        IF  (syspoint^.sbase.breccnt < buf_cnt) AND
            (b_err = e_ok)
        THEN
            BEGIN
            sysk := p^.syskey;
            buf_cnt := buf_cnt - syspoint^.sbase.breccnt;
            WHILE (buf_cnt > 0) AND (b_err = e_ok) DO
                BEGIN
                buf_cnt := buf_cnt - 1;
                a06inc_linkage (sysk.slinkage);
                IF  via_kb
                THEN
                    a10del_sysinfo (acv, sysk, b_err)
                ELSE
                    b07cdel_record (acv.a_transinf.tri_trans,
                          acv.a_pars_curr, sysk);
                (*ENDIF*) 
                END;
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        END;
&   ifdef trace
    (*ENDIF*) 
    t01int4 (ak_sem, 'bci_index   ', syspoint^.sbase.bptr^.bci_index);
&   endif
    IF  syspoint^.sbase.bptr^.bci_index <> 0
    THEN
        BEGIN (* no shared column buffer *)
        last.colp := syspoint^.sbase.bptr;
        (* find last column buffer *)
        WHILE last.colp^.bci_next <> NIL DO
            last.colp := last.colp^.bci_next;
        (*ENDWHILE*) 
        (* free unused part of last column buffer *)
        ak10free_rest (acv, last.sysp, sizeof (last.colp^) -
              sizeof (last.colp^.bci_buf) + last.colp^.bci_index - 1)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10add_method_record (
            VAR acv     : tak_all_command_glob;
            syspoint    : tak_sysbufferaddress;
            m_type      : tgg00_MessType;
            VAR b_err   : tgg00_BasisError);
 
VAR
      parm_no  : integer;
      move_len : integer;
      p        : tak_sysbufferaddress;
      rec      : tgg00_Rec;
 
BEGIN
p      := @rec;
b_err  := e_ok;
move_len :=
      sizeof (syspoint^.smethod) - sizeof (syspoint^.smethod.me_param_list);
SAPDB_PascalMove ('VAK10 ',  16,    
      sizeof (syspoint^.smethod), sizeof (rec.buf), @syspoint^, 1, @rec.buf, 1,
      move_len, b_err);
rec.len    := move_len;
parm_no    := 1;
WHILE (parm_no <= syspoint^.smethod.me_param_cnt) AND
      (b_err = e_ok)  DO
    WITH syspoint^.smethod.me_param_list[parm_no]^ DO
        BEGIN
        move_len := sizeof (syspoint^.smethod.me_param_list[parm_no]^) -
              sizeof (param_name) + ord (param_name_len);
        IF  rec.len + move_len > MAX_RECLEN_GG00
        THEN
            BEGIN
            ak10send_ins_upd (acv,
                  p, m_type, b_err);
            a06inc_linkage (p^.syskey.slinkage);
            rec.len := cak_sysbufferoffset +
                  sizeof (syspoint^.smethod.me_segmentid)
            END;
        (*ENDIF*) 
        IF  b_err = e_ok
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK10 ',  17,    
                  move_len, sizeof (rec.buf),
                  @syspoint^.smethod.me_param_list[parm_no]^, 1,
                  @rec.buf, rec.len + 1, move_len, b_err);
            rec.len := rec.len + move_len;
            parm_no := parm_no + 1;
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDWHILE*) 
IF  b_err = e_ok
THEN
    ak10send_ins_upd (acv, p, m_type, b_err)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10MigateBaseRecord (
            VAR acv  : tak_all_command_glob;
            VAR rbuf : tgg00_Rec);
 
VAR
      pos      : integer;
      rbuf_ptr : tak_sysbufferaddress;
 
BEGIN
rbuf_ptr := @rbuf;
pos      := sizeof (rbuf_ptr^.sbase.breclen       ) +
      sizeof (rbuf_ptr^.sbase.bkeylen       ) +
      sizeof (rbuf_ptr^.sbase.bvarcol_offset) +
      sizeof (rbuf_ptr^.sbase.bvarcol_cnt   ) +
      sizeof (rbuf_ptr^.sbase.bsurrogate    ) +
      sizeof (rbuf_ptr^.sbase.bentrytype    ) +
      sizeof (rbuf_ptr^.sbase.bseqno        ) +
      sizeof (rbuf_ptr^.sbase.bsegmentid    ) +
      sizeof (rbuf_ptr^.sbase.bfirstindex   ) +
      sizeof (rbuf_ptr^.sbase.blastindex    ) +
      sizeof (rbuf_ptr^.sbase.btablekind    ) +
      sizeof (rbuf_ptr^.sbase.blinkexist    ) +
      sizeof (rbuf_ptr^.sbase.btreeid       ) +
      sizeof (rbuf_ptr^.sbase.bauthid       ) + 1;
SAPDB_PascalOverlappingMove ('VAK10 ',  18,    
      sizeof (rbuf.buf), sizeof (rbuf.buf),
      @rbuf.buf, pos, @rbuf.buf,
      pos + sizeof(rbuf_ptr^.sbase.bschema) + sizeof(rbuf_ptr^.sbase.bschemacontext),
      rbuf.len - pos + 1, acv.a_returncode);
rbuf_ptr^.sbase.bschema        := rbuf_ptr^.sbase.bauthid;
rbuf_ptr^.sbase.bschemacontext := rbuf_ptr^.sbase.bauthid;
rbuf.len := rbuf.len + sizeof(rbuf_ptr^.sbase.bschema) + sizeof(rbuf_ptr^.sbase.bschemacontext);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10store_colnames_record (
            VAR acv     : tak_all_command_glob;
            syspoint    : tak_sysbufferaddress;
            m_type      : tgg00_MessType;
            VAR b_err   : tgg00_BasisError);
 
BEGIN
WHILE syspoint <> NIL DO
    BEGIN
    IF  m_type = m_insert
    THEN
        b07cadd_record (acv.a_transinf.tri_trans,
              acv.a_pars_curr, syspoint^)
    ELSE
        b07crepl_record (acv.a_transinf.tri_trans,
              acv.a_pars_curr, syspoint^);
    (*ENDIF*) 
    b_err := acv.a_transinf.tri_trans.trError_gg00;
    IF  (b_err = e_ok) AND (syspoint^.b_sl = MAX_RECLEN_GG00)
    THEN
        syspoint := syspoint^.scolnames.cnnext
    ELSE
        syspoint := NIL;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10add_upd_perm_record (
            VAR acv       : tak_all_command_glob;
            VAR find_info : tak10_find_info;
            syspoint      : tak_sysbufferaddress;
            m_type        : tgg00_MessType;
            VAR b_err     : tgg00_BasisError);
 
VAR
      store_root : tsp00_PageNo;
 
BEGIN
store_root := NIL_PAGE_NO_GG00;
IF  syspoint^.syskey.sentrytyp > cak_etemp
THEN
    BEGIN
    WITH find_info.fi_ptr.cdir_ptr^ DO
        IF  (m_type = m_update_rec) AND
            NOT (dwritten in cd_state)
        THEN
            m_type := m_insert
        (*ENDIF*) 
    (*ENDWITH*) 
    END
ELSE
    IF  syspoint^.syskey.sentrytyp = cak_etable
    THEN
        WITH syspoint^.sbase DO
            BEGIN
            IF  (btablekind = twithkey   ) OR
                (btablekind = twithoutkey) OR
                (btablekind = tonebase   )
            THEN
                BEGIN
                store_root := btreeid.fileRoot_gg00;
                btreeid.fileRoot_gg00 := NIL_PAGE_NO_GG00;
                END;
            (*ENDIF*) 
            a103CatalogCacheInvalidateTable (acv.a_transinf.tri_trans.trTaskId_gg00, bsurrogate);
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDIF*) 
CASE syspoint^.syskey.sentrytyp[2] OF
    cak_cpermmessblock :
        ak10store_mess_block (acv, syspoint^.smessblock,
              m_type = m_insert, b_err);
    cak_ctable, cak_cresult :
        BEGIN
        ak10add_base_record (acv, syspoint, c_via_kb, m_type, b_err);
&       ifdef KERNEL80
        IF  (m_type = m_insert) AND (syspoint^.syskey.ssite <> cak_catalog_id)
        THEN
            a101_StoreTable (acv, syspoint^.sbase);
&       endif
        (*ENDIF*) 
        END;
    cak_cmethod :
        ak10add_method_record (acv, syspoint, m_type, b_err);
    OTHERWISE
        IF  ak10CatalogTablesEnabled AND  NOT acv.a_modifyBootStrapCatalog AND
            (syspoint^.syskey.sentrytyp[2] = cak_cuserref)
        THEN
            b_err := e_ok
        ELSE
            ak10send_ins_upd (acv, syspoint, m_type, b_err);
        (*ENDIF*) 
    END;
(*ENDCASE*) 
IF  b_err = e_ok
THEN
    BEGIN
    WITH find_info.fi_ptr.cdir_ptr^ DO
        cd_state := cd_state + [dwritten] - [dadd_rec] - [dmodified];
    (*ENDWITH*) 
    IF  syspoint^.syskey.sentrytyp = cak_etable
    THEN
        WITH syspoint^.sbase DO
            IF  (btablekind = twithkey   ) OR
                (btablekind = twithoutkey) OR
                (btablekind = tonebase   )
            THEN
                btreeid.fileRoot_gg00 := store_root;
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10no_more_memory (
            VAR acv : tak_all_command_glob;
            VAR e : tgg00_BasisError);
 
BEGIN
a10dump (acv);
IF  acv.a_parsing_again OR ( acv.a_cmd_part = NIL ) OR
    ( acv.a_init_ex_kind = only_executing )
THEN
    e := e_no_more_memory
ELSE
    e := e_old_fileversion;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10send_ins_upd (
            VAR acv       : tak_all_command_glob;
            syspoint      : tak_sysbufferaddress;
            m_type        : tgg00_MessType;
            VAR b_err     : tgg00_BasisError);
 
VAR
      tableAccess   : boolean;
      initLen       : integer;
      keylen        : integer;
      trunc         : integer;
      move_len      : integer;
      mblock        : tgg00_MessBlock;
      data          : tgg00_Rec;
      qual          : tak10qual;
 
BEGIN
&ifdef trace
t01buf (ak_cach, syspoint^, 1, syspoint^.b_sl);
&endif
initLen := syspoint^.b_sl; (* PTS 1114093 *)
b_err   := e_ok;
g01mblock_init   (acv.a_transinf.tri_trans, m_type, mm_nil, mblock);
g01stack_init    (mblock, NIL, 0, @qual, sizeof (qual));
g01datapart_init (mblock, @data, sizeof (data));
mblock.mb_qual_len := sizeof (qual.q_hd);
tableAccess        := false;
CASE  syspoint^.syskey.sentrytyp[2] OF
    cak_cuserref, cak_cfuncref, cak_ctableref,
    cak_cdomainref, cak_cconstraintname, cak_cmapset :
        BEGIN
        CASE chr(syspoint^.syskey.sentrytyp[2]) OF
            cak_cuserref, cak_cfuncref :
                trunc := sizeof (syspoint^.suserref.ru_rest_key);
            OTHERWISE
                trunc := sizeof (syspoint^.syskey.sidentifier);
            END;
        (*ENDCASE*) 
&       ifdef trace
        t01int4 (ak_sem, 'trunc       ', trunc);
&       endif
        IF  g01unicode
        THEN
            keylen := mxak_standard_sysk +
                  s30unilnr (@syspoint^.syskey.sidentifier,
                  csp_unicode_blank, 1, trunc)
        ELSE
            keylen := mxak_standard_sysk +
                  s30lnr (syspoint^.syskey.sidentifier, bsp_c1, 1, trunc);
        (*ENDIF*) 
&       ifdef trace
        t01int4 (ak_sem, 'keylen      ', keylen);
&       endif
        SAPDB_PascalMove ('VAK10 ',  19,    
              sizeof (syspoint^), mblock.mb_data_size,
              @syspoint^, 1, @mblock.mb_data^.mbp_buf, 1,
              cgg_rec_key_offset + keylen, b_err);
        mblock.mb_data^.mbp_keylen := keylen;
        move_len := syspoint^.b_sl -
              cgg_rec_key_offset - syspoint^.syskey.skeylen;
        SAPDB_PascalMove ('VAK10 ',  20,    
              sizeof (syspoint^), mblock.mb_data_size,
              @syspoint^, cgg_rec_key_offset + syspoint^.syskey.skeylen + 1,
              @mblock.mb_data^.mbp_buf, cgg_rec_key_offset + keylen + 1,
              move_len, b_err);
        mblock.mb_data^.mbp_reclen :=
              cgg_rec_key_offset + keylen + move_len
        END
    OTHERWISE
        BEGIN
        CASE syspoint^.syskey.sentrytyp[2] OF
            cak_cdomainusage :
                syspoint^.b_sl := mxak_col_uses_offset +
                      a061identifier_len (syspoint^.scol_uses_dom.cud_name);
            cak_cuser :
                IF  ak10CatalogTablesEnabled AND  NOT acv.a_modifyBootStrapCatalog
                THEN
                    BEGIN
                    tableAccess := true;
                    a103StoreCatalogObject (acv, syspoint, m_type <> m_insert);
                    IF  acv.a_returncode = a071_return_code (e_duplicate_key, sqlm_internal)
                    THEN
                        BEGIN
                        acv.a_returncode := 0;
                        b_err := e_duplicate_sysinfo;
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    syspoint^.b_sl := mxak_userrec_offset +
                          a061identifier_len (syspoint^.suser.username);
                (*ENDIF*) 
            cak_csequence :
                IF  syspoint^.b_sl >= mxak_sequence_offset
                THEN
                    syspoint^.b_sl := mxak_sequence_offset +
                          a061identifier_len (syspoint^.ssequence.seq_name);
                (*ENDIF*) 
            cak_cdomain :
                syspoint^.b_sl := mxak_domainrec_offset +
                      sizeof (syspoint^.sdomain.dom_colinfo) -
                      sizeof (syspoint^.sdomain.dom_colinfo.ccolumnn) +
                      a061identifier_len (syspoint^.sdomain.dom_colinfo.ccolumnn);
            OTHERWISE ;
            END;
        (*ENDCASE*) 
        SAPDB_PascalMove ('VAK10 ',  21,    
              sizeof (syspoint^), mblock.mb_data_size,
              @syspoint^, 1, @mblock.mb_data^.mbp_buf, 1, syspoint^.b_sl, b_err)
        END;
    END;
(*ENDCASE*) 
IF  NOT tableAccess AND (b_err = e_ok)
THEN
    BEGIN
    mblock.mb_data_len := mblock.mb_data^.mbp_reclen;
    IF  m_type = m_insert
    THEN
        mblock.mb_qual^.mstack_desc.mfixedcol_len := cak_is_undefined;
    (*ENDIF*) 
    IF  b_err = e_ok
    THEN
        ak10send_mess_block (acv, mblock, syspoint^.syskey.sentrytyp,
              false, b_err);
    (*ENDIF*) 
    syspoint^.b_sl := initLen (* PTS 1114093 *)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak10IsUnmigratedSerialSequence (pSequence : tak_sysbufferaddress) : boolean;
 
VAR
      seqRecord : tak_sequencerecord;
 
BEGIN
ak10IsUnmigratedSerialSequence :=
      pSequence^.b_sl < mxak_sequence_offset -
      sizeof (seqRecord.seq_info) +
      sizeof (seqRecord.seq_info.seq_increment);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10MigrateSerialSequence (p : tak_sysbufferaddress);
 
TYPE
 
      tak_oldsequencerecord  =  RECORD
            seq_reclen        : tsp00_Int2;
            seq_keylen        : tsp00_Int2;
            seq_varcol_offset : tsp00_Int2;
            seq_varcol_cnt    : tsp00_Int2;
            seq_surrogate     : tgg00_Surrogate;
            seq_entrytype     : tsp00_C2;
            seq_linkage       : tsp00_C2;
            seq_segmentid     : tsp00_C2;
            seq_comment       : boolean;
            seq_public        : boolean;
            seq_date          : tsp00_Int4;
            seq_time          : tsp00_Int4;
            seq_value         : tsp00_Number;
            seq_owner         : tgg00_Surrogate;
            seq_info          : tgg00_SeqInfo;
            seq_name          : tsp00_KnlIdentifier;
      END;
 
 
VAR
      pOldSequence : ^tak_oldsequencerecord;
      increment    : tsp00_C20;
 
BEGIN
pOldSequence                        := @p^;
increment                           := pOldSequence^.seq_info.seq_increment;
p^.ssequence.seq_schema             := pOldSequence^.seq_owner;
p^.ssequence.seq_info.seq_increment := increment;
p^.b_sl                             := mxak_sequence_offset -
      sizeof (p^.ssequence.seq_info) + sizeof (p^.ssequence.seq_info.seq_increment);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10all_temp_add (
            VAR acv : tak_all_command_glob;
            p       : tak_cache_dir_pointer);
 
BEGIN
IF  p.cdir_ptr <> NIL
THEN
    BEGIN
    ak10temp_add (acv, p, NOT c_is_rollback);
    ak10all_temp_add (acv, p.cdir_ptr^.cd_less);
    ak10all_temp_add (acv, p.cdir_ptr^.cd_greater)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10alloc_mem (
            VAR acv         : tak_all_command_glob;
            do_init_cache   : boolean;
            required_bytes  : tsp00_Int4;
            VAR p           : tsp00_BufAddr;
            VAR supplement  : tsp00_Int4);
 
VAR
      ok : boolean;
 
BEGIN
p  := NIL;
IF  do_init_cache
THEN
    supplement := ak10init_cache_size
ELSE
    BEGIN
    supplement     := cak10supplement;
    required_bytes := required_bytes + sizeof (tak10cache_header);
    IF  supplement * sizeof (tsp00_Page) < required_bytes
    THEN
        supplement := (required_bytes - 1) DIV sizeof (tsp00_Page) + 1
    (*ENDIF*) 
    END;
(*ENDIF*) 
vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
IF  do_init_cache
THEN
    ak10cache_cnt := ak10cache_cnt + 1;
(*ENDIF*) 
IF  supplement + ak10all_cache_size +
    (g01maxuser - ak10cache_cnt) * ak10init_cache_size  <=
    g01cache_size (cachCatalog_egg04)
THEN
    BEGIN
    vmalloc (supplement * sizeof(tsp00_Page) + sizeof(tgg00_SysInfoKey), p, ok);
    IF  ok
    THEN
        ak10all_cache_size := ak10all_cache_size + supplement
    ELSE
        IF  do_init_cache
        THEN
            ak10cache_cnt := ak10cache_cnt - 1
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
END;
 
(* PTS 1105713, T.A. 24.02.2000 *)
(*------------------------------*) 
 
FUNCTION
      a10BaseRecPersistentOffset : integer;
 
VAR
      pBaseRec : ^tak_baserecord;
 
      auxBuf   : RECORD
            CASE boolean OF
                true :
                    (align : tsp00_Addr);
                false :
                    (buf : tsp00_C256);
                END;
            (*ENDCASE*) 
 
 
BEGIN
pBaseRec := @auxBuf;
a10BaseRecPersistentOffset :=
      sizeof(pBaseRec^.breclen)
      + sizeof(pBaseRec^.bkeylen)
      + sizeof(pBaseRec^.bvarcol_offset)
      + sizeof(pBaseRec^.bvarcol_cnt)
      + sizeof(pBaseRec^.bsurrogate)
      + sizeof(pBaseRec^.bentrytype)
      + sizeof(pBaseRec^.bseqno)
      + sizeof(pBaseRec^.bsegmentid)
      + sizeof(pBaseRec^.bfirstindex)
      + sizeof(pBaseRec^.blastindex)
      + sizeof(pBaseRec^.btablekind)
      + sizeof(pBaseRec^.blinkexist)
      + sizeof(pBaseRec^.btreeid)
      + sizeof(pBaseRec^.bauthid)
      + sizeof(pBaseRec^.bschema)
      + sizeof(pBaseRec^.bschemacontext)
      + sizeof(pBaseRec^.breccnt)
      + sizeof(pBaseRec^.bmaxcol)
      + sizeof(pBaseRec^.bmaxreclen)
      + sizeof(pBaseRec^.bkeycolcount)
      + sizeof(pBaseRec^.blenfixedcol)
      + sizeof(pBaseRec^.bvarcolcount)
      + sizeof(pBaseRec^.bcntdropcol)
      + sizeof(pBaseRec^.bstringcount)
      + sizeof(pBaseRec^.blongvarcolcnt)
      + sizeof(pBaseRec^.bcomment)
      + sizeof(pBaseRec^.bavgrowlen)
      + sizeof(pBaseRec^.blastkeyind)
      + sizeof(pBaseRec^.bfirstcolind)
      + sizeof(pBaseRec^.bdatecreate)
      + sizeof(pBaseRec^.btimecreate)
      + sizeof(pBaseRec^.bupdstatdate)
      + sizeof(pBaseRec^.bupdstattime)
      + sizeof(pBaseRec^.bpages)
      + sizeof(pBaseRec^.brows)
      + sizeof(pBaseRec^.balterdate)
      + sizeof(pBaseRec^.baltertime)
      + sizeof(pBaseRec^.bsample)
      + sizeof(pBaseRec^.bpriv_all_set)
      + sizeof(pBaseRec^.bpriv_col_exist)
      + sizeof(pBaseRec^.bunloaded)
      + sizeof(pBaseRec^.bindexexist)
      + sizeof(pBaseRec^.bv_level)
      + sizeof(pBaseRec^.bv_tabcount)
      + sizeof(pBaseRec^.bv_tablekind)
      + sizeof(pBaseRec^.bv_checkopt)
      + sizeof(pBaseRec^.bv_qualexist)
      + sizeof(pBaseRec^.bv_distinct)
      + sizeof(pBaseRec^.bv_viewlist)
      + sizeof(pBaseRec^.bdef_stamp)
      + sizeof(pBaseRec^.bview_attributes)
      + sizeof(pBaseRec^.bsqlmode)
      + sizeof(pBaseRec^.bnamed_constr)
      + sizeof(pBaseRec^.bshow_kind)
      + sizeof(pBaseRec^.brecreate_view)
      + sizeof(pBaseRec^.bshowkind)
      + sizeof(pBaseRec^.battributes)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10base_record (
            VAR acv  : tak_all_command_glob;
            VAR rec  : tgg00_Rec;
            syspoint : tak_sysbufferaddress);
 
VAR
      b_err            : tgg00_BasisError;
      version          : tsp00_C2;
      colinfo_head_len : integer;
      cnext_delta      : integer;
      pos              : integer;
      colno            : integer;
      move_len         : integer;
      colindex         : integer;
      needed_ident_cnt : integer;
      needed_len       : integer;
      rec_ptr          : tak_sysbufferaddress;
      colptr           : tak_basecolinfo_ptr;
 
      p         : RECORD
            CASE boolean OF
                true :
                    (mobj : tak_sysbufferaddress);
                false :
                    (cip  : tak_basecolinfo_ptr);
                END;
            (*ENDCASE*) 
 
      sysk : tgg00_SysInfoKey;
 
BEGIN
b_err            := e_ok;
pos              := a10BaseRecPersistentOffset + 1; (* PTS 1105713, T.A. 24.02.2000 *)
needed_ident_cnt := 1;
(* 4096 is a constant from heaven, has nothing to do with tsp00_Buf or so *)
colinfo_head_len := sizeof(tak_basecolinfo) - 4096;
needed_len := colinfo_head_len
      +
      needed_ident_cnt *
      ((sizeof(tsp00_KnlIdentifier) - 1) DIV sizeof (tak_align) + 1) * sizeof (tak_align)
      +
      syspoint^.sbase.bmaxcol *
      ((sizeof(tak00_columninfo) - sizeof(tsp00_KnlIdentifier) + a01identifier_size - 1)
      DIV sizeof (tak_align) + 1) * sizeof (tak_align);
IF  needed_len > sizeof (tak_basecolinfo)
THEN
    needed_len := sizeof (tak_basecolinfo);
(*ENDIF*) 
a10new (acv, needed_len, p.mobj);
IF  p.mobj <> NIL
THEN
    WITH syspoint^.sbase DO
        BEGIN
        version             := bsegmentid;
        p.cip^.bci_buf_size := needed_len - colinfo_head_len;
&       ifdef trace
        t01int4 (ak_cach, 'blastindex  ', blastindex);
        t01int4 (ak_cach, 'bfirstindex ', bfirstindex);
        t01int4 (ak_cach, 'pos         ', pos);
        t01addr (ak_cach, 'bptr        ', @p.cip^);
&       endif
        cnext_delta       := (blastindex - bmaxcol + 1) - bfirstindex;
        bfirstcolind      := bfirstcolind - cnext_delta;
        bcolumnSplitIdx   := csp_maxint2;
        bupdstatinserted  := false;
        (* PTS 1112311 E.Z. *)
        IF  blastkeyind > 0
        THEN
            blastkeyind       := blastkeyind  - cnext_delta;
        (*ENDIF*) 
        bptr              := p.cip;
        bptr^.bci_index   := 1;
        breccnt           := 1;
        bptr^.bci_next    := NIL;
        bptr^.bci_ref_cnt := 1;
        btablen           := @bptr^.bci_buf[bptr^.bci_index];
        bptr^.bci_index   := bptr^.bci_index +
              ((sizeof (btablen^) - 1) DIV sizeof (tak_align) + 1) *
              sizeof (tak_align);
        btablen^ := a01_il_b_identifier;
        SAPDB_PascalMove ('VAK10 ',  22,    
              sizeof (rec.buf), sizeof (btablen^), @rec.buf, pos + 1,
              @btablen^, 1, ord (rec.buf[pos]), b_err);
        pos := pos + 1 + ord (rec.buf[pos]);
        (* construct column infos now *)
        colptr   := bptr;
        rec_ptr  := NIL;
        colindex := bfirstindex;
        colno    := 0;
        WHILE (colno < bmaxcol) AND (b_err = e_ok) DO
            BEGIN
&           ifdef trace
            t01int4 (ak_cach, 'pos         ', pos);
            t01int4 (ak_cach, 'rec.len     ', rec.len);
&           endif
            IF  pos > rec.len
            THEN
                BEGIN
                IF  rec_ptr = NIL
                THEN
                    BEGIN
                    rec_ptr := @rec;
                    sysk    := rec_ptr^.syskey;
                    END;
                (*ENDIF*) 
                a06inc_linkage (sysk.slinkage);
                IF  b_err = e_ok
                THEN
                    IF  sysk.sentrytyp < cak_etemp
                    THEN
                        BEGIN
                        ak10get_perm_record (acv,
                              sysk, rec, b_err);
                        IF  b_err = e_ok
                        THEN
                            BEGIN
                            IF  version <> rec_ptr^.sbase.bsegmentid (* 1110898 *)
                            THEN
                                BEGIN
                                b_err := e_old_fileversion
                                END;
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        b07cget_record (acv.a_transinf.tri_trans,
                              acv.a_pars_curr, sysk, rec);
                        b_err := acv.a_transinf.tri_trans.trError_gg00;
                        acv.a_transinf.tri_trans.trError_gg00 := e_ok
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  b_err = e_ok
                THEN
                    BEGIN
                    breccnt := breccnt + 1;
                    pos     := cak_sysbufferoffset +
                          sizeof (syspoint^.sbase.bsegmentid) + 1
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            move_len := sizeof (tak00_columninfo) -
                  sizeof (tsp00_KnlIdentifier) + ord (rec.buf[pos - 1 +
                  sizeof (tak00_columninfo) - sizeof (tsp00_KnlIdentifier)]);
            IF  (needed_len - colinfo_head_len -
                (colptr^.bci_index - 1) < move_len)
                AND (b_err = e_ok)
            THEN
                BEGIN
                needed_len := colinfo_head_len +
                      (bmaxcol - colno) *
                      ((sizeof(tak00_columninfo) - sizeof(tsp00_KnlIdentifier) + a01identifier_size - 1)
                      DIV sizeof (tak_align) + 1) * sizeof (tak_align);
                IF  needed_len > sizeof (tak_basecolinfo)
                THEN
                    needed_len := sizeof (tak_basecolinfo);
                (*ENDIF*) 
                a10new (acv, needed_len, p.mobj);
                IF  p.mobj <> NIL
                THEN
                    BEGIN
                    p.cip^.bci_buf_size := needed_len - colinfo_head_len;
                    colptr^.bci_next  := p.cip;
                    colptr            := p.cip;
                    colptr^.bci_index := 1;
                    colptr^.bci_next  := NIL
                    END
                ELSE
                    ak10no_more_memory (acv, b_err)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                BEGIN
&               ifdef trace
                t01int4 (ak_sem, 'move_len    ', move_len);
                t01int4 (ak_sem, 'bci_index   ', colptr^.bci_index);
                t01int4 (ak_sem, 'colindex    ', colindex);
&               endif
                bcolumn[colindex] := @colptr^.bci_buf[colptr^.bci_index];
                colptr^.bci_index := colptr^.bci_index +
                      ((move_len - 1) DIV sizeof (tak_align) + 1) *
                      sizeof (tak_align);
                SAPDB_PascalMove ('VAK10 ',  23,    
                      sizeof (rec.buf), sizeof (bptr^.bci_buf),
                      @rec.buf, pos, @bcolumn[colindex]^, 1, move_len, b_err);
                bextcolindex[bcolumn[colindex]^.cextcolno] := colno;
                IF  bcolumn[colindex]^.cnextind <> 0
                THEN
                    bcolumn[colindex]^.cnextind :=
                          bcolumn[colindex]^.cnextind - cnext_delta;
                (*ENDIF*) 
                blastindex := colindex;
                colindex   := colindex + 1;
                pos        := pos + move_len;
                colno      := colno + 1
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END
    (*ENDWITH*) 
ELSE
    BEGIN
    ak10no_more_memory (acv, b_err);
    a07_b_put_error (acv, b_err, 1)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10block_into_freelist (
            VAR acv          : tak_all_command_glob;
            block_addr       : tak_cache_dir_pointer;
            del_in_directory : boolean;
            del_dependecies  : boolean);
 
VAR
      p             : tak_sysbufferaddress;
      curr          : tak_cache_dir_pointer;
      prev          : tak_cache_dir_pointer;
 
BEGIN
WITH acv.a_sysdir, block_addr.cdir_ptr^ DO
    IF  cd_check <> cak_cache_chunk_flag
    THEN
        BEGIN
&       ifdef trace
        xtd_directory (ak_cach, block_addr);
&       endif
        ak10cache_error (acv, 'ak10block_into_freelist ', block_addr)
        END
    ELSE
        BEGIN
&       ifdef trace
        xtd_directory (ak_cach, block_addr);
&       endif
        IF  dreference in cd_state
        THEN
            BEGIN
            IF  del_in_directory
            THEN
                ak10del_in_dir (acv, cd_ref.cd_globalSysinfoPtr^.syskey);
            (*ENDIF*) 
            IF  cd_ref.cd_nextRef.cdir_ptr <> NIL
            THEN
                BEGIN
                a103ReleaseCacheHandle (acv, cd_ref.cd_globalCacheHandle, true);
                (* remove from list *)
                cd_ref.cd_prevRef.cdir_ptr^.cd_ref.cd_nextRef := cd_ref.cd_nextRef;
                cd_ref.cd_nextRef.cdir_ptr^.cd_ref.cd_prevRef := cd_ref.cd_prevRef;
                cd_ref.cd_prevRef.cdir_ptr                    := NIL;
                cd_ref.cd_nextRef.cdir_ptr                    := NIL;
                END
            ELSE
                a103ReleaseCacheHandle (acv, cd_ref.cd_globalCacheHandle, false);
            (*ENDIF*) 
            END
        ELSE
            IF  del_in_directory
            THEN
                BEGIN
                IF  (ddisplace in cd_state) (* PTS 1110796 *)
                THEN
                    BEGIN
                    acv.a_sysdir.ci_displaceCnt := acv.a_sysdir.ci_displaceCnt - 1;
&                   ifdef trace
                    t01int4 (ak_cach, '-displaceCnt', acv.a_sysdir.ci_displaceCnt);
                    t01buf1 (ak_cach, cd_syskey, cgg_rec_key_offset+1,
                          cd_syskey.skeylen + cgg_rec_key_offset);
                    IF  acv.a_sysdir.ci_displaceCnt < 0
                    THEN
                        g01abort (csp3_a10_cache_error,
                              csp3_n_akcache, 'ci_displaceCnt < 0      ', 0);
&                   endif
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  del_dependecies
                THEN
                    CASE cd_syskey.sentrytyp[2] OF
                        cak_ccolnames :
                            ak10free_colnamesrecord (acv, cd_sysinfo.scolnames);
                        cak_ctable, cak_cresult :
                            ak10free_baserecord (acv, cd_sysinfo.sbase);
                        cak_cmessblock, cak_cpermmessblock, cak_ctriggerparsinfo :
                            ak10free_mblock (acv,
                                  cd_sysinfo.smessblock.mbr_mess_block);
                        cak_cresname :
                            IF  cd_syskey.sentrytyp = cak_eresname
                            THEN
                                BEGIN
                                p := @cd_sysinfo;
                                IF  acv.a_resname_addr[cak_extern_pos] = p
                                THEN
                                    acv.a_resname_addr[cak_extern_pos] := NIL
                                ELSE
                                    IF  acv.a_resname_addr[cak_intern_pos] = p
                                    THEN
                                        acv.a_resname_addr[cak_intern_pos]:= NIL
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        cak_cmethod :
                            ak10free_method_record (acv, cd_sysinfo.smethod);
                        OTHERWISE ;
                        END;
                    (*ENDCASE*) 
                (*ENDIF*) 
                ak10del_in_dir (acv, cd_syskey)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        cd_state    := [dno_meaning];
        cd_mem_type := dyn_free;
        IF  cd_lru_next.cdir_ptr <> NIL
        THEN
            BEGIN
            (*---------- remove block from lru-list ----------*)
            cd_lru_prev.cdir_ptr^.cd_lru_next :=
                  cd_lru_next;
            cd_lru_next.cdir_ptr^.cd_lru_prev :=
                  cd_lru_prev;
            cd_lru_next.cdir_ptr := NIL;
            cd_lru_prev.cdir_ptr := NIL
            END;
        (*ENDIF*) 
        IF  cd_fix_next.cdir_ptr <> NIL
        THEN
            BEGIN
            (*---------- remove block from fix-list ----------*)
            cd_fix_prev.cdir_ptr^.cd_fix_next := cd_fix_next;
            cd_fix_next.cdir_ptr^.cd_fix_prev := cd_fix_prev;
            cd_fix_next.cdir_ptr := NIL;
            cd_fix_prev.cdir_ptr := NIL;
            END;
        (*ENDIF*) 
        cd_fix_next.cdir_ptr := NIL;
        cd_fix_prev.cdir_ptr := NIL;
        cd_less.cdir_ptr     := NIL;
        cd_greater.cdir_ptr  := NIL;
        curr := ci_cache_dir_header.cdir_ptr^.cd_next_free;
        prev := ci_cache_dir_header;
&       ifdef trace
        t01int4 (ak_cach, 'block_pos   ', cd_pos);
        t01int4 (ak_cach, 'block_len   ', cd_syslen);
        t01int4 (ak_cach, 'buf_no      ', cd_buf_no);
&       endif
        WHILE (curr.cdir_ptr^.cd_buf_no < cd_buf_no)
              OR
              ((curr.cdir_ptr^.cd_pos < cd_pos) AND
              (curr.cdir_ptr^.cd_buf_no = cd_buf_no)) DO
            BEGIN
&           ifdef trace
            t01p2int4 (ak_cach, 'curr bl pos ',
                  curr.cdir_ptr^.cd_pos,
                  'curr bl buf ', curr.cdir_ptr^.cd_buf_no);
&           endif
            prev := curr;
            curr := curr.cdir_ptr^.cd_next_free;
&           ifdef trace
            IF  (prev.cdir_ptr^.cd_buf_no = curr.cdir_ptr^.cd_buf_no) AND
                (prev.cdir_ptr^.cd_pos = curr.cdir_ptr^.cd_pos)
            THEN
                BEGIN
                t01p2int4 (ak_cach, 'curr bl pos ',
                      curr.cdir_ptr^.cd_pos,
                      'curr bl buf ', curr.cdir_ptr^.cd_buf_no);
                a10dump (acv);
                g01abort (csp3_a10_cache_verify,
                      csp3_n_akcache, 'DUPLICATE IN FREELIST   ', 0);
                END;
&           endif
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  (prev.cdir_ptr^.cd_pos+prev.cdir_ptr^.cd_syslen =
            cd_pos)
            AND
            (prev.cdir_ptr^.cd_buf_no = cd_buf_no)
        THEN
            BEGIN (* merge left block with block to be released *)
            prev.cdir_ptr^.cd_syslen :=
                  prev.cdir_ptr^.cd_syslen + cd_syslen;
            IF  (prev.cdir_ptr^.cd_pos + prev.cdir_ptr^.cd_syslen
                = curr.cdir_ptr^.cd_pos) AND
                (prev.cdir_ptr^.cd_buf_no =
                curr.cdir_ptr^.cd_buf_no)
            THEN
                BEGIN
                (* merge left + block + right into one block *)
                prev.cdir_ptr^.cd_syslen :=
                      prev.cdir_ptr^.cd_syslen +
                      curr.cdir_ptr^.cd_syslen;
                prev.cdir_ptr^.cd_next_free :=
                      curr.cdir_ptr^.cd_next_free
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            prev.cdir_ptr^.cd_next_free := block_addr;
            IF  (cd_pos + cd_syslen = curr.cdir_ptr^.cd_pos) AND
                (cd_buf_no = curr.cdir_ptr^.cd_buf_no)
            THEN
                BEGIN (* merge block with next block *)
                cd_next_free := curr.cdir_ptr^.cd_next_free;
                cd_syslen :=
                      curr.cdir_ptr^.cd_syslen + cd_syslen
                END
            ELSE
                BEGIN
                cd_next_free := curr;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10CacheCheck(
            VAR acv : tak_all_command_glob);
 
BEGIN
IF  NOT a102IsCacheOk(acv)
THEN
    BEGIN
    a10dump (acv);
&   ifdef trace
    ak10td_freelist (acv, td_always);
&   endif
    g01abort (csp3_a10_cache_verify, csp3_n_akcache,
          'VERIFY FAILED           ', 0)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10cache_error (
            VAR acv   : tak_all_command_glob;
            desc      : tsp00_C24;
            ptr       : tak_cache_dir_pointer);
 
BEGIN
IF  a10chk
THEN
    BEGIN
    IF  ptr.cdir_ptr <> NIL
    THEN
        ak10writeln (ptr);
    (*ENDIF*) 
    ak10CacheCheck(acv);
    g01opmsg (sp3p_console, sp3m_error, csp3_a10_cache_dump,
          csp3_n_akcache, 'DUMP                    ', 0);
    ak10verify_cache (acv);
    g01abort (csp3_a10_cache_error,
          csp3_n_akcache, desc, 0)
    END;
(*ENDIF*) 
a10dump (acv);
&ifdef trace
g01abort (csp3_a10_cache_dir_full,
      csp3_n_akcache, desc, 0);
&else
a07_b_put_error (acv, e_cachedirectory_full, 1);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10check_hit_rate (
            VAR acv : tak_all_command_glob);
 
VAR
      dummy : tsp00_BufAddr;
 
BEGIN
WITH acv, a_sysdir DO
    IF  ci_tmp_read_cnt > cak10min_temp_reads
    THEN
        BEGIN
        IF  ci_tmp_read_cnt < csp_maxint4
        THEN
            ci_tmp_read_cnt := ci_tmp_read_cnt + 1
        ELSE
            BEGIN
            ci_tmp_read_found := ak10hit_rate (ci_tmp_read_found,
                  ci_tmp_read_cnt);
            ci_tmp_read_cnt := 1001
            END;
        (*ENDIF*) 
        IF  ak10hit_rate (ci_tmp_read_found, ci_tmp_read_cnt) <
            cak10required_hit_rate
        THEN
            BEGIN
            ak10get_supplement (acv, dummy, 0);
            ci_tmp_read_found := 0;
            ci_tmp_read_cnt   := 0;
            ci_tmp_dislodged  := false
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10del (
            VAR acv         : tak_all_command_glob;
            VAR p           : tak_cache_dir_pointer;
            VAR deleted_p   : tak_cache_dir_pointer;
            VAR decremented : boolean);
 
BEGIN
IF  p.cdir_ptr^.cd_greater.cdir_ptr <> NIL
THEN
    BEGIN
    ak10del (acv, p.cdir_ptr^.cd_greater, deleted_p, decremented);
    IF  decremented
    THEN
        ak10del_balance_right (acv, p, decremented)
    (*ENDIF*) 
    END
ELSE
    BEGIN
    deleted_p   := p;
    p           := p.cdir_ptr^.cd_less;
    decremented := true;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10del_balance_left (
            VAR acv         : tak_all_command_glob;
            VAR p           : tak_cache_dir_pointer;
            VAR decremented : boolean);
 
VAR
      b1 : tak_balance_info;
      b2 : tak_balance_info;
      p1 : tak_cache_dir_pointer;
      p2 : tak_cache_dir_pointer;
 
BEGIN
(* left branch of tree became shorter *)
&ifdef trace
xtd_directory (ak_cach, p);
&endif
IF  p.cdir_ptr^.cd_check <> cak_cache_chunk_flag
THEN
    ak10cache_error (acv, 'ak10del_bal_left        ', p)
ELSE
    CASE p.cdir_ptr^.cd_balance OF
        left_weighted :
            p.cdir_ptr^.cd_balance := balanced;
        balanced :
            BEGIN
            p.cdir_ptr^.cd_balance :=right_weighted;
            decremented            := false
            END;
        right_weighted :
            BEGIN
            p1 := p.cdir_ptr^.cd_greater;
            b1 := p1.cdir_ptr^.cd_balance;
            IF  b1 >= balanced
            THEN
                BEGIN (* simple RR rotation *)
                p.cdir_ptr^.cd_greater := p1.cdir_ptr^.cd_less;
                p1.cdir_ptr^.cd_less    := p;
                IF  b1 = balanced
                THEN
                    BEGIN
                    p.cdir_ptr^.cd_balance  :=right_weighted;
                    p1.cdir_ptr^.cd_balance := left_weighted;
                    decremented             := false
                    END
                ELSE
                    BEGIN
                    p.cdir_ptr^.cd_balance  := balanced;
                    p1.cdir_ptr^.cd_balance := balanced
                    END;
                (*ENDIF*) 
                p := p1
                END
            ELSE
                BEGIN (* double RL rotation *)
                p2 := p1.cdir_ptr^.cd_less;
                b2 := p2.cdir_ptr^.cd_balance;
                p1.cdir_ptr^.cd_less := p2.cdir_ptr^.cd_greater;
                p2.cdir_ptr^.cd_greater := p1;
                p.cdir_ptr^.cd_greater  := p2.cdir_ptr^.cd_less;
                p2.cdir_ptr^.cd_less    := p;
                IF  b2 =right_weighted
                THEN
                    p.cdir_ptr^.cd_balance := left_weighted
                ELSE
                    p.cdir_ptr^.cd_balance := balanced;
                (*ENDIF*) 
                IF  b2 = left_weighted
                THEN
                    p1.cdir_ptr^.cd_balance := right_weighted
                ELSE
                    p1.cdir_ptr^.cd_balance := balanced;
                (*ENDIF*) 
                p                       := p2;
                p2.cdir_ptr^.cd_balance := balanced
                END;
            (*ENDIF*) 
            END;
        OTHERWISE
            ak10cache_error (acv, 'ak10del_bal_left1       ', p);
        END;
    (*ENDCASE*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10del_balance_right (
            VAR acv         : tak_all_command_glob;
            VAR p           : tak_cache_dir_pointer;
            VAR decremented : boolean);
 
VAR
      b1 : tak_balance_info;
      b2 : tak_balance_info;
      p1 : tak_cache_dir_pointer;
      p2 : tak_cache_dir_pointer;
 
BEGIN
(* right branch of tree became shorter *)
&ifdef trace
xtd_directory (ak_cach, p);
&endif
IF  p.cdir_ptr^.cd_check <> cak_cache_chunk_flag
THEN
    ak10cache_error (acv, 'ak10del_bal_right       ', p)
ELSE
    CASE p.cdir_ptr^.cd_balance OF
        left_weighted :
            BEGIN
            p1 := p.cdir_ptr^.cd_less;
&           ifdef trace
            xtd_directory (ak_cach, p1);
&           endif
            b1 := p1.cdir_ptr^.cd_balance;
            IF  b1 <= balanced
            THEN
                BEGIN (* simple LL rotation *)
                p.cdir_ptr^.cd_less     := p1.cdir_ptr^.cd_greater;
                p1.cdir_ptr^.cd_greater := p;
                IF  b1 = balanced
                THEN
                    BEGIN
                    p.cdir_ptr^.cd_balance  := left_weighted;
                    p1.cdir_ptr^.cd_balance := right_weighted;
                    decremented             := false
                    END
                ELSE
                    BEGIN
                    p.cdir_ptr^.cd_balance  := balanced;
                    p1.cdir_ptr^.cd_balance := balanced
                    END;
                (*ENDIF*) 
                p := p1
                END
            ELSE
                BEGIN (* double LR rotation *)
                p2 := p1.cdir_ptr^.cd_greater;
                b2 := p2.cdir_ptr^.cd_balance;
&               ifdef trace
                xtd_directory (ak_cach, p2);
&               endif
                p1.cdir_ptr^.cd_greater := p2.cdir_ptr^.cd_less;
                p2.cdir_ptr^.cd_less    := p1;
                p.cdir_ptr^.cd_less     := p2.cdir_ptr^.cd_greater;
                p2.cdir_ptr^.cd_greater := p;
                IF  b2 = left_weighted
                THEN
                    p.cdir_ptr^.cd_balance := right_weighted
                ELSE
                    p.cdir_ptr^.cd_balance := balanced;
                (*ENDIF*) 
                IF  b2 =right_weighted
                THEN
                    p1.cdir_ptr^.cd_balance := left_weighted
                ELSE
                    p1.cdir_ptr^.cd_balance := balanced;
                (*ENDIF*) 
                p                       := p2;
                p2.cdir_ptr^.cd_balance := balanced
                END;
            (*ENDIF*) 
            END;
        balanced :
            BEGIN
            p.cdir_ptr^.cd_balance := left_weighted;
            decremented            := false
            END;
        right_weighted :
            p.cdir_ptr^.cd_balance := balanced;
        OTHERWISE
            ak10cache_error (acv, 'ak10del_bal_right1      ', p)
        END;
    (*ENDCASE*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10del_in_dir (
            VAR acv    : tak_all_command_glob;
            VAR syskey : tgg00_SysInfoKey);
 
VAR
      etype       : integer;
      decremented : boolean;
      currkey     : tgg00_SysInfoKey;
      find_info   : tak10_find_info;
 
BEGIN
decremented := false;
IF  syskey.sentrytyp = cak_etable (* PTS 1110796 *)
THEN
    BEGIN
    SAPDB_PascalMove ('VAK10 ',  24,    
          sizeof (syskey), sizeof (currkey),
          @syskey, 1, @currkey, 1, syskey.skeylen + cgg_rec_key_offset, acv.a_returncode);
    FOR etype := 1 TO cak10displaceTypesCnt DO
        BEGIN
        currkey.sentrytyp := ak10displaceTypes[etype] ;
        IF  currkey.sentrytyp = cak_epriv
        THEN
            BEGIN
            IF  acv.a_sysdir.ci_dir[ord(currkey.sentrytyp[2])].cdir_ptr <> NIL
            THEN
                ak10DisplacePrivilege (acv, currkey, acv.a_sysdir.ci_dir[ord(currkey.sentrytyp[2])]);
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            ak10find_syskey (acv, currkey, find_info, NOT cak10CheckReferences);
            IF  find_info.fi_res = l_equal
            THEN
                BEGIN
                IF  NOT (ddisplace in find_info.fi_ptr.cdir_ptr^.cd_state) (* PTS 1110796 *)
                    AND
                    (acv.a_is_ddl <> ddl_update_statistics)
                THEN
                    BEGIN
                    find_info.fi_ptr.cdir_ptr^.cd_state :=
                          find_info.fi_ptr.cdir_ptr^.cd_state + [ddisplace];
                    acv.a_sysdir.ci_displaceCnt := acv.a_sysdir.ci_displaceCnt + 1;
&                   ifdef trace
                    t01int4 (ak_cach, '+displaceCnt', acv.a_sysdir.ci_displaceCnt);
                    WITH find_info.fi_ptr.cdir_ptr^ DO
                        t01buf1 (ak_cach, cd_syskey, cgg_rec_key_offset+1,
                              cd_syskey.skeylen + cgg_rec_key_offset);
                    (*ENDWITH*) 
&                   endif
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDFOR*) 
    currkey.sentrytyp := cak_eroletab;
    IF  acv.a_sysdir.ci_dir[ord(currkey.sentrytyp[2])].cdir_ptr <> NIL
    THEN
        ak10DisplaceRoles (acv, acv.a_sysdir.ci_dir[ord(currkey.sentrytyp[2])])
    (*ENDIF*) 
    END;
(*ENDIF*) 
ak10del_in_directory (acv, syskey,
      acv.a_sysdir.ci_dir[ord(syskey.sentrytyp[2])], decremented)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10DisplacePrivilege (
            VAR acv    : tak_all_command_glob;
            VAR syskey : tgg00_SysInfoKey;
            p          : tak_cache_dir_pointer);
 
VAR
      pKey      : tak10_SysKeyPointer;
 
BEGIN
IF  dreference in p.cdir_ptr^.cd_state
THEN
    pKey := ak10GlobalCacheGetKeyPointer(p)
ELSE
    pKey := @p.cdir_ptr^.cd_syskey;
(*ENDIF*) 
IF  pKey^.stableid = syskey.stableid
THEN
    IF  NOT (ddisplace in p.cdir_ptr^.cd_state)
    THEN
        BEGIN
        p.cdir_ptr^.cd_state := p.cdir_ptr^.cd_state + [ddisplace];
        acv.a_sysdir.ci_displaceCnt := acv.a_sysdir.ci_displaceCnt + 1;
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  p.cdir_ptr^.cd_less.cdir_ptr <> NIL
THEN
    ak10DisplacePrivilege (acv, syskey, p.cdir_ptr^.cd_less);
(*ENDIF*) 
IF  p.cdir_ptr^.cd_greater.cdir_ptr <> NIL
THEN
    ak10DisplacePrivilege (acv, syskey, p.cdir_ptr^.cd_greater);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10DisplaceRoles (
            VAR acv    : tak_all_command_glob;
            p          : tak_cache_dir_pointer);
 
BEGIN
IF  NOT (ddisplace in p.cdir_ptr^.cd_state)
THEN
    BEGIN
    p.cdir_ptr^.cd_state := p.cdir_ptr^.cd_state + [ddisplace];
    acv.a_sysdir.ci_displaceCnt := acv.a_sysdir.ci_displaceCnt + 1;
    END;
(*ENDIF*) 
IF  p.cdir_ptr^.cd_less.cdir_ptr <> NIL
THEN
    ak10DisplaceRoles (acv, p.cdir_ptr^.cd_less);
(*ENDIF*) 
IF  p.cdir_ptr^.cd_greater.cdir_ptr <> NIL
THEN
    ak10DisplaceRoles (acv, p.cdir_ptr^.cd_greater);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10del_in_directory (
            VAR acv         : tak_all_command_glob;
            VAR syskey      : tgg00_SysInfoKey;
            VAR p           : tak_cache_dir_pointer;
            VAR decremented : boolean);
 
VAR
      aux       : tak_cache_dir_pointer;
      deleted_p : tak_cache_dir_pointer;
      res       : tsp00_LcompResult;
      pKey      : tak10_SysKeyPointer;
 
BEGIN
IF  p.cdir_ptr <> NIL
THEN
    BEGIN
    IF  dreference in p.cdir_ptr^.cd_state
    THEN
        pKey := ak10GlobalCacheGetKeyPointer(p)
    ELSE
        pKey := @p.cdir_ptr^.cd_syskey;
    (*ENDIF*) 
    s30cmp (syskey, cgg_rec_key_offset+1, syskey.skeylen,
          pKey^, cgg_rec_key_offset+1, pKey^.skeylen, res);
    CASE res OF
        l_less :
            BEGIN
            ak10del_in_directory (acv, syskey,
                  p.cdir_ptr^.cd_less, decremented);
            IF  decremented
            THEN
                ak10del_balance_left (acv, p, decremented);
            (*ENDIF*) 
            END;
        l_greater :
            BEGIN
            ak10del_in_directory (acv, syskey,
                  p.cdir_ptr^.cd_greater, decremented);
            IF  decremented
            THEN
                ak10del_balance_right (acv, p, decremented);
            (*ENDIF*) 
            END;
        OTHERWISE
            BEGIN
            aux := p;
            IF  aux.cdir_ptr^.cd_greater.cdir_ptr = NIL
            THEN
                BEGIN
                p := aux.cdir_ptr^.cd_less;
                decremented := true
                END
            ELSE
                IF  aux.cdir_ptr^.cd_less.cdir_ptr = NIL
                THEN
                    BEGIN
                    p := aux.cdir_ptr^.cd_greater;
                    decremented := true
                    END
                ELSE
                    BEGIN
                    ak10del (acv, aux.cdir_ptr^.cd_less,
                          deleted_p, decremented);
                    deleted_p.cdir_ptr^.cd_less    :=
                          p.cdir_ptr^.cd_less;
                    deleted_p.cdir_ptr^.cd_greater :=
                          p.cdir_ptr^.cd_greater;
                    deleted_p.cdir_ptr^.cd_balance :=
                          p.cdir_ptr^.cd_balance;
                    p := deleted_p;
                    IF  decremented
                    THEN
                        ak10del_balance_left (acv, p, decremented)
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        END;
    (*ENDCASE*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10DisableTableAccess;
 
BEGIN
ak10CatalogTablesEnabled := false;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10EnableTableAccess;
 
BEGIN
ak10CatalogTablesEnabled := true;
END;
 
(*------------------------------*) 
 
FUNCTION
      a10TableAccessAllowed : boolean;
 
BEGIN
a10TableAccessAllowed := ak10CatalogTablesEnabled;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10expand_rec (
            VAR rec_buf : tgg00_Rec; VAR b_err : tgg00_BasisError);
 
VAR
      p            : tak_sysbufferaddress;
      ix           : integer;
      len          : integer;
      diff         : integer;
 
BEGIN
p     := @rec_buf;
diff  := 0;
b_err := e_ok;
CASE p^.syskey.sentrytyp[2] OF
    cak_csequence :
        IF  (p^.b_sl >= mxak_sequence_offset) AND
            (p^.b_sl < mxak_sequence_offset + sizeof (tsp00_KnlIdentifier))
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK10 ',  25,    
                  sizeof (a01_il_b_identifier), sizeof (rec_buf.buf),
                  @a01_il_b_identifier, 1, @rec_buf.buf,
                  p^.b_sl + 1, sizeof (tak_sequencerecord) - p^.b_sl, b_err);
            p^.b_sl := sizeof (tak_sequencerecord)
            END
        ELSE
            IF  ak10IsUnmigratedSerialSequence (p)
            THEN
                ak10MigrateSerialSequence(p);
            (*ENDIF*) 
        (*ENDIF*) 
    cak_ctableref, cak_cdomainref, cak_cconstraintname,
    cak_cmapset :
        diff := mxak_standard_sysk +
              sizeof (p^.syskey.sidentifier) - p^.syskey.skeylen;
    cak_cuser :
        BEGIN
        IF  p^.suser.userfiller3 <> 0
        THEN
            BEGIN
            p^.suser.ureplication := false;
            p^.suser.userconnect  := true;
            p^.suser.userfiller3  := 0;
            END;
        (*ENDIF*) 
        IF  p^.b_sl < mxak_userrec_offset + sizeof (tsp00_KnlIdentifier)
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK10 ',  26,    
                  sizeof (a01_il_b_identifier), sizeof (rec_buf.buf),
                  @a01_il_b_identifier, 1, @rec_buf.buf,
                  p^.b_sl + 1, sizeof (tak_userrecord) - p^.b_sl, b_err);
            p^.b_sl := sizeof (tak_userrecord)
            END;
        (*ENDIF*) 
        END;
    cak_cdomain :
        IF  p^.b_sl < mxak_domainrec_offset + sizeof (tsp00_KnlIdentifier)
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK10 ',  27,    
                  sizeof (a01_il_b_identifier), sizeof (rec_buf.buf),
                  @a01_il_b_identifier, 1, @rec_buf.buf,
                  p^.b_sl + 1, sizeof (tak_domainrecord) - p^.b_sl, b_err);
            p^.b_sl := sizeof (tak_domainrecord)
            END;
        (*ENDIF*) 
    cak_cdomainusage :
        IF  p^.b_sl < mxak_col_uses_offset + sizeof (tsp00_KnlIdentifier)
        THEN
            BEGIN
            SAPDB_PascalMove ('VAK10 ',  28,    
                  sizeof (a01_il_b_identifier), sizeof (rec_buf.buf),
                  @a01_il_b_identifier, 1, @rec_buf.buf,
                  p^.b_sl + 1, sizeof (p^.scol_uses_dom) - p^.b_sl, b_err);
            p^.b_sl := sizeof (p^.scol_uses_dom);
            END;
        (*ENDIF*) 
    cak_cuserref, cak_cfuncref :
        diff := mxak_standard_sysk + sizeof (p^.suserref.ru_rest_key) -
              p^.syskey.skeylen;
    cak_cmindex : (* check if migration is necessary *)
        IF  p^.syskey.slinkage[1] = chr(0)
        THEN
            FOR ix := 1 TO p^.smindex.indexcount DO
                WITH p^.smindex.indexdef[ix] DO
                    IF  iinittime = cak_initinvlist
                    THEN
                        BEGIN
                        iinitdate := idatecre;
                        iinittime := itimecre;
                        END;
                    (*ENDIF*) 
                (*ENDWITH*) 
            (*ENDFOR*) 
        (*ENDIF*) 
    OTHERWISE
        ;
    END;
(*ENDCASE*) 
IF  diff > 0
THEN
    BEGIN
    SAPDB_PascalOverlappingMove ('VAK10 ',  29,    
          sizeof (rec_buf.buf), sizeof (rec_buf.buf),
          @rec_buf.buf, cgg_rec_key_offset + rec_buf.keylen + 1,
          @rec_buf.buf, cgg_rec_key_offset + rec_buf.keylen + 1 + diff,
          rec_buf.len - cgg_rec_key_offset - rec_buf.keylen, b_err);
    SAPDB_PascalMove ('VAK10 ',  30,    
          sizeof (a01_il_b_identifier), sizeof (rec_buf.buf),
          @a01_il_b_identifier, 1, @rec_buf.buf,
          cgg_rec_key_offset + rec_buf.keylen + 1, diff, b_err);
    rec_buf.keylen := rec_buf.keylen + diff;
    rec_buf.len    := rec_buf.len    + diff;
    END;
&ifdef trace
(*ENDIF*) 
t01buf (ak_sem, p^, 1, p^.b_sl);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10find_syskey (
            VAR acv         : tak_all_command_glob;
            VAR syskey      : tgg00_SysInfoKey;
            VAR find_info   : tak10_find_info;
            checkReferences : boolean);
 
TYPE
      t_refreshAction = (rf_none, rf_oldVersion, rf_continue);
 
VAR
      curr          : tak_cache_dir_pointer;
      entrytype     : integer;
      pKey          : tak10_SysKeyPointer;
      refreshAction : t_refreshAction;
      tableid       : tgg00_Surrogate;
      msg           : tsp00_C18;
 
LABEL
      999; (* return *)
 
LABEL
      998; (* repeat *)
 
BEGIN
&ifdef trace
t01buf1 (ak_cach, syskey, cgg_rec_key_offset+1,
      syskey.skeylen + cgg_rec_key_offset);
&endif
entrytype                    := ord (syskey.sentrytyp[2]);
IF  (entrytype = 0) OR (entrytype > cak_emax) OR
    (syskey.skeylen < 1) OR (syskey.skeylen >
    sizeof (syskey) - cgg_rec_key_offset)
THEN
    a07ak_system_error (acv, 10, 2)
ELSE
    BEGIN
    998 :
          ;
    find_info.fi_ptr.cdir_ptr    := NIL;
    find_info.fi_res             := l_less;
    curr := acv.a_sysdir.ci_dir [entrytype];
    WHILE curr.cdir_ptr <> NIL DO
        WITH curr.cdir_ptr^ DO
            BEGIN
            IF  cd_check <> cak_cache_chunk_flag
            THEN
                BEGIN
                ak10cache_error (acv, 'ak10find_syskey         ', curr);
                curr.cdir_ptr := NIL
                END
            ELSE
                BEGIN
                find_info.fi_ptr := curr;
                IF  dreference in cd_state
                THEN
                    BEGIN
                    pKey := ak10GlobalCacheGetKeyPointer(curr);
                    IF  checkReferences
                        AND
                        a103HandleInvalid (curr.cdir_ptr^.cd_ref.cd_globalCacheHandle)
                    THEN
                        BEGIN (* this handle is no longer valid, give it up *)
                        refreshAction := rf_none;
                        IF  pKey^.sentrytyp = cak_etable
                        THEN
                            IF  curr.cdir_ptr^.cd_ref.cd_nextRef.cdir_ptr <> NIL
                            THEN
                                refreshAction := rf_oldVersion
                            ELSE
                                refreshAction := rf_continue;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        ak10block_into_freelist (acv, curr,
                              c_del_in_directory, c_del_dependecies);
                        IF  (refreshAction      = rf_oldVersion) AND
                            (acv.a_command_kind = show_command )
                        THEN
                            refreshAction := rf_continue;
                        (*ENDIF*) 
                        CASE refreshAction OF
                            rf_oldVersion :
                                BEGIN
                                msg := 'old_fileversion(1)';
                                ak10TraceKey (acv, pKey^, -1, msg);
                                a07_b_put_error (acv, e_old_fileversion, 1);
                                curr.cdir_ptr    := NIL;
                                find_info.fi_res := l_less;
                                goto 999;
                                END;
                            OTHERWISE
                                goto 998;
                            END;
                        (*ENDCASE*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    pKey := @cd_syskey;
                (*ENDIF*) 
                s30cmp (syskey, cgg_rec_key_offset+1, syskey.skeylen,
                      pKey^, cgg_rec_key_offset+1, pKey^.skeylen,
                      find_info.fi_res);
                IF  find_info.fi_res = l_equal
                THEN
                    curr.cdir_ptr := NIL
                ELSE
                    BEGIN
                    IF  find_info.fi_res = l_greater
                    THEN
                        curr := curr.cdir_ptr^.cd_greater
                    ELSE
                        curr := curr.cdir_ptr^.cd_less
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
999 : ;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10free_cache (
            VAR acv : tak_all_command_glob;
            offset  : tsp00_Int4);
 
VAR
      i             : integer;
      cache_dir_ptr : tak_cache_dir_pointer;
      prev_dir_ptr  : tak_cache_dir_pointer;
 
      univ_ptr      : RECORD
            CASE integer OF
                1 :
                    (bufaddr : tsp00_BufAddr);
                2 :
                    (chptr   : tak10cache_header_ptr);
                3 :
                    (cdptr   : tak_cache_dir_pointer);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH acv, a_sysdir DO
    BEGIN
    WITH ci_cache_dir_header.cdir_ptr^ DO
        BEGIN
        cd_buf_no                 := 0;
        cd_pos                    := -1;
        cd_check                  := cak_cache_chunk_flag;
        cd_syslen                 := 0;
        cd_less.buf_ptr           := NIL;
        cd_lru_next               := ci_cache_dir_trailor;
        cd_lru_prev.buf_ptr       := NIL;
        cd_fix_next               := ci_cache_dir_trailor;
        cd_fix_prev.buf_ptr       := NIL;
        cd_ref.cd_nextRef         := ci_cache_dir_trailor;
        cd_ref.cd_prevRef.buf_ptr := NIL;
        END;
    (*ENDWITH*) 
    WITH ci_cache_dir_trailor.cdir_ptr^ DO
        BEGIN
        cd_buf_no                 := csp_maxint2;
        cd_pos                    := csp_maxint4;
        cd_check                  := cak_cache_chunk_flag;
        cd_syslen                 := 0;
        cd_next_free.cdir_ptr     := NIL;
        cd_lru_next.buf_ptr       := NIL;
        cd_lru_prev               :=  ci_cache_dir_header;
        cd_fix_next.buf_ptr       := NIL;
        cd_fix_prev               := ci_cache_dir_header;
        cd_ref.cd_nextRef.buf_ptr := NIL;
        cd_ref.cd_prevRef         := ci_cache_dir_header;
        END;
    (*ENDWITH*) 
    cache_dir_ptr.buf_ptr :=
          s35add_bufaddr_ptocm (ci_cache_p, sizeof (tak10cache_header) +
          2 * sizeof(tak_globalCacheReference) + offset);
    WITH cache_dir_ptr.cdir_ptr^ DO
        BEGIN
        cd_buf_no    := 0;
        cd_less.cdir_ptr     := NIL;
        cd_greater.cdir_ptr  := NIL;
        cd_fix_next.cdir_ptr := NIL;
        cd_fix_prev.cdir_ptr := NIL;
        cd_lru_next.cdir_ptr := NIL;
        cd_lru_prev.cdir_ptr := NIL;
        cd_pos       := sizeof (tak10cache_header) +
              2 * sizeof(tak_globalCacheReference) + offset + 1;
        cd_state     := [dno_meaning];
        cd_mem_type  := dyn_free;
        cd_check     := cak_cache_chunk_flag;
        cd_syslen    := ak10init_cache_size * sizeof (tsp00_Page) -
              sizeof (tak10cache_header) -
              2 * mxak_cache_dir_entry - offset;
        cd_next_free := ci_cache_dir_trailor
        END;
    (*ENDWITH*) 
    ci_cache_dir_header.cdir_ptr^.cd_next_free := cache_dir_ptr;
    prev_dir_ptr     := cache_dir_ptr;
    univ_ptr.bufaddr := ci_cache_p;
    WHILE univ_ptr.chptr^.ch_next_cache <> NIL DO
        BEGIN
&       ifdef trace
        t01str30 (ak_cach, 'succ cache found              ');
&       endif
        cache_dir_ptr.buf_ptr :=
              s35add_bufaddr_ptocm (univ_ptr.chptr^.ch_next_cache,
              sizeof (tak10cache_header));
        prev_dir_ptr.cdir_ptr^.cd_next_free := cache_dir_ptr;
        WITH cache_dir_ptr.cdir_ptr^ DO
            BEGIN
            cd_pos       := sizeof (tak10cache_header) + 1;
            cd_check     := cak_cache_chunk_flag;
            cd_syslen   := cak10supplement * sizeof (tsp00_Page) -
                  sizeof (tak10cache_header);
            cd_next_free := ci_cache_dir_trailor
            END;
        (*ENDWITH*) 
        prev_dir_ptr     := cache_dir_ptr;
        univ_ptr.bufaddr := univ_ptr.chptr^.ch_next_cache
        END;
    (*ENDWHILE*) 
    FOR i := 1 TO cak_emax DO
        ci_dir [ i ].cdir_ptr := NIL;
    (*ENDFOR*) 
&   ifdef trace
    ;
    ak10td_freelist (acv, ak_cach);
    IF  offset > 0
    THEN
        ak10verify_cache (acv)
&             endif
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10free_baserecord (
            VAR acv     : tak_all_command_glob;
            VAR baserec : tak_baserecord);
 
VAR
      p   : tak_basecolinfo_ptr;
      aux : tak_sysbufferaddress;
 
BEGIN
IF  baserec.btablekind <> tsynonym
THEN
    IF  baserec.bptr <> NIL
    THEN
        BEGIN
&       ifdef trace
        t01addr    (ak_cach, 'bptr        ', @baserec.bptr^);
&       endif
        IF  baserec.bptr^.bci_index = 0
        THEN
            a101_DetachColumnBuffer (acv, @baserec)
        ELSE
            BEGIN
            baserec.bptr^.bci_ref_cnt := baserec.bptr^.bci_ref_cnt - 1;
            IF  baserec.bptr^.bci_ref_cnt = 0
            THEN
                BEGIN
                p            := baserec.bptr;
                baserec.bptr := NIL;
                WHILE p <> NIL DO
                    BEGIN
                    aux := @p^;
                    p   := p^.bci_next;
                    a10dispose (acv, aux)
                    END;
                (*ENDWHILE*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10free_colnamesrecord (
            VAR acv         : tak_all_command_glob;
            VAR colnamesrec : tak_columnnamesrecord);
 
VAR
      p    : tak_sysbufferaddress;
      next : tak_sysbufferaddress;
 
BEGIN
IF  colnamesrec.cnreclen = MAX_RECLEN_GG00
THEN
    BEGIN (* succ record(s) exist *)
    p := colnamesrec.cnnext;
    WHILE p <> NIL DO
        BEGIN
        IF  p^.b_sl = MAX_RECLEN_GG00
        THEN
            next := p^.scolnames.cnnext
        ELSE
            next := NIL;
        (*ENDIF*) 
        a10dispose (acv, p);
        p := next
        END
    (*ENDWHILE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10free_method_record (
            VAR acv    : tak_all_command_glob;
            VAR method : tak_methodrecord);
 
VAR
      ix : integer;
 
      p  : RECORD
            CASE boolean OF
                true :
                    (parm_ptr : tak_param_info_ptr);
                false :
                    (sys_ptr  : tak_sysbufferaddress);
                END;
            (*ENDCASE*) 
 
 
BEGIN
FOR ix := 1 TO method.me_param_cnt DO
    BEGIN
    p.parm_ptr := method.me_param_list[ix];
    IF  p.sys_ptr <> NIL
    THEN
        a10dispose (acv, p.sys_ptr)
    (*ENDIF*) 
    END;
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10free_mblock (
            VAR acv    : tak_all_command_glob;
            VAR mblock : tgg00_MessBlock);
 
VAR
      ix            : integer;
 
      p             : ARRAY[1..4] OF RECORD
            CASE integer OF
                1 :
                    (buf_ptr  : tsp00_BufAddr);
                2 :
                    (qual_ptr : tgg00_QualBufPtr);
                3 :
                    (cdir_ptr : tak_cache_dir_pointer);
                4 :
                    (data_ptr : tgg00_DataPartPtr);
                5 :
                    (st_ptr   : tgg00_StackListPtr);
                6 :
                    (strat_ptr : tsp00_MoveObjPtr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  (mblock.mb_type = m_procedure) AND (mblock.mb_type2 = mm_ignore)
THEN
    a262DropParseIds (acv, mblock);
(*ENDIF*) 
p[1].qual_ptr := mblock.mb_qual;
p[2].data_ptr := mblock.mb_data;
p[3].st_ptr   := mblock.mb_st;
p[4].strat_ptr := mblock.mb_strat;
FOR ix := 1 TO 4 DO
    IF  p[ix].buf_ptr <> NIL
    THEN
        BEGIN
&       ifdef trace
        t01addr (ak_cach, 'addr        ', p[ix].buf_ptr);
&       endif
        p[ix].buf_ptr :=
              s35add_bufaddr_ptocm (p[ix].buf_ptr,
              - mxak_cache_dir_entry);
&       ifdef trace
        t01addr (ak_cach, 'addr        ', p[ix].buf_ptr);
&       endif
        ak10block_into_freelist (acv, p[ix].cdir_ptr,
              NOT c_del_in_directory, c_del_dependecies)
        END;
    (*ENDIF*) 
(*ENDFOR*) 
FOR ix := 0 TO cgg_idx_max_valuefieldlist DO
    IF  mblock.mb_fieldlists[ix] <> NIL
    THEN
        ak104_DropReference_MS (mblock.mb_fieldlists[ix]);
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10free_rest (
            VAR acv        : tak_all_command_glob;
            syspointer     : tak_sysbufferaddress;
            used_len       : tsp00_Int4);
 
VAR
      curr      : tak_cache_dir_pointer;
      free      : tak_cache_dir_pointer;
      block_pos : tsp00_Int4;
      rest_len  : tsp00_Int4;
 
BEGIN
curr.sys_ptr := syspointer;
curr.buf_ptr := s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
IF  used_len MOD ALIGNMENT_GG00 <> 0
THEN
    used_len := used_len -
          (used_len MOD ALIGNMENT_GG00) + ALIGNMENT_GG00;
(*ENDIF*) 
rest_len := curr.cdir_ptr^.cd_syslen - mxak_cache_dir_entry - used_len;
&ifdef trace
t01int4 (ak_cach, 'used        ', used_len);
t01int4 (ak_cach, 'cd_syslen   ', curr.cdir_ptr^.cd_syslen);
&endif
IF  rest_len >= cak_maxcacherest
THEN
    BEGIN
    curr.cdir_ptr^.cd_syslen := mxak_cache_dir_entry + used_len;
    free.buf_ptr :=
          s35add_bufaddr_ptocm (curr.buf_ptr, mxak_cache_dir_entry + used_len);
    free.cdir_ptr^.cd_buf_no      := curr.cdir_ptr^.cd_buf_no;
    block_pos                     := curr.cdir_ptr^.cd_block_pos +
          mxak_cache_dir_entry + used_len;
    free.cdir_ptr^.cd_block_pos   := block_pos;
    free.cdir_ptr^.cd_block_check := cak_cache_chunk_flag;
    free.cdir_ptr^.cd_state       := [];
    free.cdir_ptr^.cd_syslen      := rest_len;
    free.cdir_ptr^.cd_lru_next.cdir_ptr := NIL;
    free.cdir_ptr^.cd_fix_next.cdir_ptr := NIL;
    free.cdir_ptr^.cd_lru_prev.cdir_ptr := NIL;
    free.cdir_ptr^.cd_fix_prev.cdir_ptr := NIL;
    ak10block_into_freelist (acv, free, NOT c_del_in_directory,
          c_del_dependecies)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10get_next_avail (
            VAR acv          : tak_all_command_glob;
            required_len     : tsp00_Int4;
            required_pos     : tsp00_Int4;
            VAR assigned_len : tsp00_Int4;
            VAR p            : tsp00_BufAddr);
 
VAR
      min_pos    : tsp00_Int4;
      min_len    : integer;
      first_free : tak_cache_dir_pointer;
      curr       : tak_cache_dir_pointer;
      prev       : tak_cache_dir_pointer;
      ptr        : tak_cache_dir_pointer;
 
BEGIN
WITH acv, a_sysdir DO
    BEGIN
&   ifdef trace
    t01int4 (ak_cach, 'required_len', required_len);
    t01int4 (ak_cach, 'required_pos', required_pos);
&   endif
    min_len      := mxak_cache_dir_entry + 5 * sizeof (tak_ap_node);
    required_len := required_len + mxak_cache_dir_entry;
    IF  required_len MOD ALIGNMENT_GG00 <> 0
    THEN
        required_len := required_len -
              (required_len MOD ALIGNMENT_GG00) + ALIGNMENT_GG00;
    (*ENDIF*) 
    p                   := NIL;
    first_free.cdir_ptr := NIL;
    curr := ci_cache_dir_header.cdir_ptr^.cd_next_free;
    prev := ci_cache_dir_header;
    WHILE (curr.buf_ptr <> ci_cache_dir_trailor.buf_ptr) DO
        WITH curr.cdir_ptr^ DO
            IF  cd_buf_no > 0
            THEN
                curr := ci_cache_dir_trailor
            ELSE
                IF  (cd_block_pos > required_pos) AND
                    (cd_syslen > min_len        )
                THEN
                    BEGIN
                    first_free := curr;
                    curr       := ci_cache_dir_trailor
                    END
                ELSE
                    BEGIN
                    prev := curr;
                    curr := curr.cdir_ptr^.cd_next_free
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDWHILE*) 
    ptr           := ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
    min_pos       := csp_maxint4;
    curr.cdir_ptr := NIL;
    WHILE ptr.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
        WITH ptr.cdir_ptr^ DO
            BEGIN
            IF  (cd_fix_next.cdir_ptr = NIL) AND
                (cd_pos < min_pos)           AND
                (cd_pos > required_pos)      AND
                (cd_buf_no = 0)              AND
                (cd_syslen > min_len)        AND
                NOT (a101_IsStatementActive(acv, cd_cmd_no))
            THEN
                BEGIN
                min_pos := cd_pos;
                curr    := ptr;
                END;
&           ifdef trace
            (*ENDIF*) 
            xtd_directory (ak_cach, ptr);
&           endif
            ptr := ptr.cdir_ptr^.cd_lru_prev
            END;
        (*ENDWITH*) 
    (*ENDWHILE*) 
&   ifdef trace
    t01int4 (ak_cach, 'min_pos     ', min_pos);
    IF  first_free.cdir_ptr <> NIL
    THEN
        t01int4 (ak_cach, 'free_pos    ',
              first_free.cdir_ptr^.cd_block_pos);
&   endif
    (*ENDIF*) 
    IF  first_free.cdir_ptr <> NIL
    THEN
        IF  first_free.cdir_ptr^.cd_block_pos < min_pos
        THEN
            BEGIN
            curr := ci_cache_dir_header.cdir_ptr^.cd_next_free;
            ci_cache_dir_header.cdir_ptr^.cd_next_free := first_free;
            IF  required_len > first_free.cdir_ptr^.cd_syslen
            THEN
                required_len := first_free.cdir_ptr^.cd_syslen;
            (*ENDIF*) 
            ak10getmem (acv, cak_is_undefined, required_len, p);
            IF  prev.cdir_ptr <> ci_cache_dir_header.cdir_ptr
            THEN
                BEGIN
                prev.cdir_ptr^.cd_next_free :=
                      ci_cache_dir_header.cdir_ptr^.cd_next_free;
                ci_cache_dir_header.cdir_ptr^.cd_next_free := curr
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (p = NIL) AND (curr.cdir_ptr <> NIL)
    THEN
        BEGIN
        IF  curr.cdir_ptr^.cd_syslen < required_len
        THEN
            required_len := curr.cdir_ptr^.cd_syslen;
        (*ENDIF*) 
        ak10temp_add (acv, curr, NOT c_is_rollback);
        IF  NOT (dreference in curr.cdir_ptr^.cd_state)
            AND
            (curr.cdir_ptr^.cd_syskey.sentrytyp > cak_etemp)
        THEN
            ci_tmp_dislodged := true;
        (*ENDIF*) 
        ak10block_into_freelist (acv, curr, c_del_in_directory,
              c_del_dependecies);
&       ifdef trace
        ak10td_freelist (acv, ak_cach);
        ak10verify_cache (acv);
&       endif
        ak10getmem (acv, required_pos, required_len, p);
        END;
    (*ENDIF*) 
    assigned_len := required_len - mxak_cache_dir_entry
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10getmem (
            VAR acv          : tak_all_command_glob;
            required_pos     : tsp00_Int4;
            VAR required_len : tsp00_Int4;
            VAR p            : tsp00_BufAddr);
 
VAR
      b_err     : tgg00_BasisError;
      use_block : boolean;
      exit_loop : boolean;
      loop_cnt  : integer;
      curr      : tak_cache_dir_pointer;
      prev      : tak_cache_dir_pointer;
      ptr       : tak_cache_dir_pointer;
      block_pos : tsp00_Int4;
      block_len : tsp00_Int4;
      param     : tsp00_C16;
 
BEGIN
&ifdef trace
t01int4 (ak_cach, 'required_len', required_len);
&endif
IF  required_len MOD ALIGNMENT_GG00 <> 0
THEN
    required_len := required_len -
          (required_len MOD ALIGNMENT_GG00) + ALIGNMENT_GG00;
(*ENDIF*) 
IF  required_len < mxak_cache_dir_entry
THEN
    required_len := mxak_cache_dir_entry;
(*ENDIF*) 
p         := NIL;
loop_cnt  := 0;
exit_loop := false;
WHILE (p = NIL)     AND
      NOT exit_loop AND
      (acv.a_returncode = 0) DO
    BEGIN
    loop_cnt := loop_cnt + 1;
    curr := acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_next_free;
    prev := acv.a_sysdir.ci_cache_dir_header;
    WHILE curr.buf_ptr <> acv.a_sysdir.ci_cache_dir_trailor.buf_ptr DO
        BEGIN
        WITH curr.cdir_ptr^ DO
            IF  cd_block_check <> cak_cache_chunk_flag
            THEN
                BEGIN
&               ifdef trace
                t01int4 (ak_cach, 'cd_block_pos', cd_block_pos);
                t01int4 (ak_cach, 'cd_block_chk', cd_block_check);
                t01int4 (ak_cach, 'curr.i      ', curr.i);
&               endif
                ak10cache_error (acv, 'ak10getmem              ', curr);
                curr := acv.a_sysdir.ci_cache_dir_trailor
                END
            ELSE
                BEGIN
                loop_cnt := loop_cnt + 1;
&               ifdef trace
                IF  cd_mem_type <> dyn_free
                THEN
                    g01abort (1, csp3_n_akcache,
                          'dyn_free <> mem_ytpe    ', ord(cd_mem_type));
                (*ENDIF*) 
                t01p2int4 (ak_cach, 'free bl pos ', cd_block_pos,
                      'free bl len ', cd_syslen);
                t01p2int4 (ak_cach, 'free bl buf ', cd_buf_no,
                      'free bl adr ', curr.i);
                t01addr (ak_cach, 'free bl addr', curr.buf_ptr);
&               endif
                IF  required_pos > 0
                THEN
                    use_block :=
                          (cd_buf_no = 0               ) AND
                          (cd_block_pos >  required_pos) AND
                          (cd_syslen >= required_len)
                ELSE
                    use_block := cd_syslen >= required_len;
                (*ENDIF*) 
                IF  use_block
                THEN
                    BEGIN (* curr free block fulfills requirement *)
                    p := curr.buf_ptr;
                    IF  cd_syslen - required_len >=
                        cak_maxcacherest
                    THEN
                        BEGIN
                        block_len   := cd_syslen - required_len;
                        block_pos   := cd_block_pos + required_len;
                        ptr.buf_ptr :=
                              s35add_bufaddr_ptocm (p, required_len);
                        ptr.cdir_ptr^.cd_buf_no        := cd_buf_no;
                        ptr.cdir_ptr^.cd_block_pos     := block_pos;
                        ptr.cdir_ptr^.cd_block_check   := cak_cache_chunk_flag;
                        ptr.cdir_ptr^.cd_blockRefCount := 0;
                        ptr.cdir_ptr^.cd_state         := [dno_meaning];
                        ptr.cdir_ptr^.cd_mem_type      := dyn_free;
                        ptr.cdir_ptr^.cd_syslen        := block_len;
                        ptr.cdir_ptr^.cd_less.cdir_ptr     := NIL;
                        ptr.cdir_ptr^.cd_greater.cdir_ptr  := NIL;
                        ptr.cdir_ptr^.cd_fix_next.cdir_ptr := NIL;
                        ptr.cdir_ptr^.cd_fix_prev.cdir_ptr := NIL;
                        ptr.cdir_ptr^.cd_lru_next.cdir_ptr := NIL;
                        ptr.cdir_ptr^.cd_lru_prev.cdir_ptr := NIL;
                        ptr.cdir_ptr^.cd_next_free  := cd_next_free;
                        prev.cdir_ptr^.cd_next_free := ptr
                        END
                    ELSE
                        BEGIN
                        required_len := cd_syslen;
                        prev.cdir_ptr^.cd_next_free := cd_next_free
                        END;
                    (*ENDIF*) 
                    cd_syslen   := required_len;
                    cd_refCount := 0;
                    curr        := acv.a_sysdir.ci_cache_dir_trailor
                    END
                ELSE
                    BEGIN
                    prev := curr;
                    curr := curr.cdir_ptr^.cd_next_free
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDWITH*) 
        END;
    (*ENDWHILE*) 
    exit_loop := true;
    IF  (p = NIL)
        AND (required_pos = cak_is_undefined       )
        AND (acv.a_returncode = 0)
    THEN
        BEGIN (* dislodge block *)
        ptr := acv.a_sysdir.ci_cache_dir_trailor.cdir_ptr^.cd_lru_prev;
        WHILE ptr.cdir_ptr <>
              acv.a_sysdir.ci_cache_dir_header.cdir_ptr DO
            WITH ptr.cdir_ptr^ DO
                IF  (cd_fix_next.cdir_ptr = NIL) AND
                    (cd_refCount          = 0  ) AND
                    NOT (a101_IsStatementActive(acv, cd_cmd_no))
                THEN
                    BEGIN
&                   ifdef trace
                    t01str30 (ak_cach,
                          'dislodge block                ');
                    IF  NOT (dreference in cd_state)
                    THEN
                        t01buf1 (ak_cach, cd_syskey, cgg_rec_key_offset+1,
                              cd_syskey.skeylen + cgg_rec_key_offset);
&                   endif
                    (*ENDIF*) 
                    ak10temp_add (acv, ptr, NOT c_is_rollback);
                    IF  NOT (dreference in cd_state)
                        AND
                        (cd_syskey.sentrytyp > cak_etemp)
                    THEN
                        acv.a_sysdir.ci_tmp_dislodged := true;
                    (*ENDIF*) 
                    ak10block_into_freelist (acv, ptr,
                          c_del_in_directory, c_del_dependecies);
                    ptr       := acv.a_sysdir.ci_cache_dir_header;
&                   ifdef trace
                    ak10td_freelist (acv, ak_cach);
                    ak10verify_cache (acv);
&                   endif
                    exit_loop := false
                    END
                ELSE
                    ptr := ptr.cdir_ptr^.cd_lru_prev
                (*ENDIF*) 
            (*ENDWITH*) 
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
IF  (p = NIL) AND
    (acv.a_returncode = 0)
THEN
    BEGIN
&   ifdef trace
    g01optextmsg (sp3p_console, sp3m_info, csp3_a10_get_mem,
          csp3_n_akcache, 'REQUIRE CACHE DUE TO OVERFLOW           ');
&   endif
    ak10get_supplement (acv, p, required_len)
    END;
(*ENDIF*) 
IF  p = NIL
THEN
    BEGIN
&   ifdef trace
    ak10td_freelist (acv, ak_cach);
    ak10td_dirlist (acv, ak_cach);
&   endif
    ak10no_more_memory (acv, b_err);
    param := 'CAT_CACHE_SUPPLY';
    a07_const_b_put_error (acv, b_err, 1, @param, sizeof (param))
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10get_mess_block (
            VAR acv : tak_all_command_glob;
            sysbuf  : tak_sysbufferaddress);
 
VAR
      release_mem : boolean;
      b_err       : tgg00_BasisError;
      cnt         : integer;
      ix          : integer;
      part_pos    : integer;
      rec_pos     : integer;
      move_len    : integer;
      sysk        : tgg00_SysInfoKey;
      part_cnt    : integer;
      mblock_info : tak10_mblock_info;
      b           : tgg00_Rec;
 
BEGIN
WITH sysbuf^.smessblock DO
    BEGIN
    mbr_mess_block.mb_trns := @acv.a_transinf.tri_trans;
    mbr_recCount              := chr(0);
&   ifdef trace
    t01int4 (ak_cach, 'mbr_stack_le', mbr_stack_len);
&   endif
    ak10space_for_mblock (acv,
          mbr_mess_block, mbr_stack_len, mbr_mess_block, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        release_mem  := true;
        sysk         := sysbuf^.syskey;
        sysk.skeylen := sysk.skeylen + 1;
        cnt          := 0;
        sysk.all[sysk.skeylen] := chr(0);
        ak10fill_mblock_info (sysbuf^.smessblock,
              mblock_info, part_cnt)
        END
    ELSE
        release_mem := false;
    (*ENDIF*) 
    ix      := 1;
    rec_pos := 1;
    b.len   := 0;
    WHILE (ix <= part_cnt) AND (b_err = e_ok) DO
        BEGIN
        part_pos := 1;
        REPEAT
            IF  rec_pos > b.len
            THEN
                BEGIN
                cnt := cnt + 1;
                sysk.all[sysk.skeylen] := chr(cnt);
                IF  sysbuf^.syskey.sentrytyp = cak_epermmessblock
                THEN
                    ak10get_perm_record (acv, sysk, b, b_err)
                ELSE
                    BEGIN
                    b07cget_record (acv.a_transinf.tri_trans,
                          acv.a_pars_curr, sysk, b);
                    b_err := acv.a_transinf.tri_trans.trError_gg00;
                    acv.a_transinf.tri_trans.trError_gg00 := e_ok
                    END;
                (*ENDIF*) 
                rec_pos := cgg_rec_key_offset + sysk.skeylen + 1;
                END;
            (*ENDIF*) 
            IF  b_err = e_ok
            THEN
                BEGIN
                move_len := b.len - rec_pos + 1;
                IF  part_pos + move_len - 1 > mblock_info[ix].len
                THEN
                    move_len := mblock_info[ix].len - part_pos + 1;
                (*ENDIF*) 
                SAPDB_PascalMove ('VAK10 ',  31,    
                      sizeof (b.buf), mblock_info[ix].size,
                      @b.buf, rec_pos, @mblock_info[ix].addr^, part_pos,
                      move_len, b_err);
                part_pos := part_pos + move_len;
                rec_pos  := rec_pos  + move_len
                END;
            (*ENDIF*) 
        UNTIL
            (part_pos > mblock_info[ix].len) OR (b_err <> e_ok);
        (*ENDREPEAT*) 
        IF  (mbr_mess_block.mb_qual <> NIL) AND
            (mbr_mess_block.mb_st <> NIL)
        THEN
            mbr_mess_block.mb_qual^.mst_addr := mbr_mess_block.mb_st;
        (*ENDIF*) 
        ix := ix + 1;
        END;
    (*ENDWHILE*) 
    IF  NOT ak10migrate
    THEN
        IF  mbr_fieldSequenceInfo <> []
        THEN
            BEGIN
            sysk         := sysbuf^.syskey;
            sysk.skeylen := sysk.skeylen + 1;
            sysk.all[sysk.skeylen] := chr(cnt + 1);
            cnt := cnt + a103RestoreMessBlockFieldSequences (acv, sysk, sysbuf^.smessblock);
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (b_err <> e_ok) OR (acv.a_returncode <> 0)
    THEN
        BEGIN
        IF  release_mem
        THEN
            ak10free_mblock (acv, mbr_mess_block);
        (*ENDIF*) 
        a07_b_put_error (acv, b_err, 1)
        END
    ELSE
        mbr_recCount   := chr(cnt);
    (*ENDIF*) 
&   ifdef trace
    t01messblock (ak_cach, 'get_mess_blo', mbr_mess_block);
&   endif
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak10hit_rate (hits  : tsp00_Int4;
            reads : tsp00_Int4) : integer;
&     ifdef trace
 
VAR
      rate  : integer;
      pos   : integer;
      msg40 : tsp00_C40;
&     endif
 
BEGIN
IF  reads > 0
THEN
    BEGIN
    IF  reads > (csp_maxint4 DIV 1000)
    THEN
        BEGIN
        hits  := hits  DIV 1000;
        reads := reads DIV 1000
        END;
    (*ENDIF*) 
    ak10hit_rate := (hits * 1000) DIV reads + 5;
&   ifdef trace
    IF  (hits * 1000) DIV reads + 5 < cak10required_hit_rate
    THEN
        BEGIN
        msg40 := 'HIT RATE : 000.0 %                      ';
        pos   := 16;
        rate  := (hits * 1000) DIV reads + 5;
        WHILE rate > 0 DO
            BEGIN
            msg40[pos] := chr (rate MOD 10 + ord ('0'));
            IF  pos = 16
            THEN
                pos := pos - 2
            ELSE
                pos := pos - 1;
            (*ENDIF*) 
            rate := rate DIV 10
            END;
        (*ENDWHILE*) 
        g01optextmsg (sp3p_console, sp3m_info, csp3_a10_hit_rate,
              csp3_n_akcache, msg40)
        END;
&   endif
    (*ENDIF*) 
    END
ELSE
    ak10hit_rate := 0
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10get_colnames_record (
            VAR acv  : tak_all_command_glob;
            syspoint : tak_sysbufferaddress);
 
VAR
      b_err    : tgg00_BasisError;
      restlen  : tsp00_Int4;
      required : tsp00_Int4;
      curr     : tak_sysbufferaddress;
      sysk     : tgg00_SysInfoKey;
 
      p        : RECORD
            CASE boolean OF
                true :
                    (sysp : tak_sysbufferaddress);
                false :
                    (rbuf : ^tgg00_Rec);
                END;
            (*ENDCASE*) 
 
      aux : tak_cache_dir_pointer;
 
BEGIN
syspoint^.scolnames.cnnext := NIL;
syspoint^.scolnames.cnlast := syspoint;
&ifdef trace
t01int4 (ak_cach, 'cnfullen    ', syspoint^.scolnames.cnfullen);
&endif
restlen := syspoint^.scolnames.cnfullen - cgg_rec_key_offset -
      syspoint^.b_kl -
      sizeof (syspoint^.scolnames.cnbit64fill) -
      (sizeof (syspoint^.scolnames.cnbuf) -
      sizeof (syspoint^.scolnames.cnfullen) -
      sizeof (syspoint^.scolnames.cncount));
&ifdef trace
t01int4 (ak_cach, 'restlen     ', restlen);
&endif
IF  restlen > 0
THEN
    BEGIN
    curr := syspoint;
    SAPDB_PascalForcedMove (sizeof (syspoint^.syskey), sizeof (sysk),
          @syspoint^.syskey, 1, @sysk, 1,
          cgg_rec_key_offset + syspoint^.syskey.skeylen);
    REPEAT
        a06inc_linkage (sysk.slinkage);
        required := restlen;
        IF  required >= MAX_RECLEN_GG00
        THEN
            required := sizeof (tak_columnnamesrecord);
        (*ENDIF*) 
        a10new (acv, required, p.sysp);
        IF  p.sysp <> NIL
        THEN
            BEGIN
            b07cget_record (acv.a_transinf.tri_trans,
                  acv.a_pars_curr, sysk, p.rbuf^);
            b_err := acv.a_transinf.tri_trans.trError_gg00;
            IF  b_err = e_ok
            THEN
                BEGIN
                restlen                    := restlen - p.rbuf^.len;
&               ifdef trace
                t01int4 (ak_cach, 'restlen     ', restlen);
&               endif
                curr^.scolnames.cnnext     := p.sysp;
                syspoint^.scolnames.cnlast := p.sysp;
                curr                       := p.sysp;
                IF  curr^.b_sl = MAX_RECLEN_GG00
                THEN
                    curr^.scolnames.cnnext := NIL
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            ak10no_more_memory (acv, b_err);
        (*ENDIF*) 
    UNTIL
        (restlen <= 0) OR (b_err <> e_ok);
    (*ENDREPEAT*) 
    IF  b_err <> e_ok
    THEN
        BEGIN
        aux.sys_ptr := curr;
        aux.buf_ptr := s35add_bufaddr_ptocm (aux.buf_ptr, - mxak_cache_dir_entry);
        ak10block_into_freelist (acv, aux, NOT c_del_in_directory,
              c_del_dependecies);
        a07_b_put_error (acv, b_err, 1)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10get_method_record (
            VAR acv  : tak_all_command_glob;
            VAR rec  : tgg00_Rec;
            syspoint : tak_sysbufferaddress);
 
VAR
      e         : tgg00_BasisError;
      ix        : integer;
      pos       : integer;
      parm_no   : integer;
      move_len  : integer;
      rec_ptr   : tak_sysbufferaddress;
      sysk      : tgg00_SysInfoKey;
 
      p         : RECORD
            CASE boolean OF
                true :
                    (mobj : tak_sysbufferaddress);
                false :
                    (pp   : tak_param_info_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
e        := e_ok;
rec_ptr  := NIL;
pos      := sizeof (syspoint^.smethod) -
      sizeof (syspoint^.smethod.me_param_list) + 1;
parm_no  := 1;
WHILE parm_no <= syspoint^.smethod.me_param_cnt DO
    BEGIN
    IF  pos > rec.len
    THEN
        BEGIN
        IF  rec_ptr = NIL
        THEN
            BEGIN
            rec_ptr := @rec;
            sysk    := rec_ptr^.syskey;
            END;
        (*ENDIF*) 
        a06inc_linkage (sysk.slinkage);
        ak10get_perm_record (acv, sysk, rec, e);
        pos := cak_sysbufferoffset +
              sizeof (syspoint^.smethod.me_segmentid) + 1
        END;
    (*ENDIF*) 
    IF  e = e_ok
    THEN
        BEGIN
        move_len := sizeof (tak_param_info) - sizeof (tsp00_C256) +
              ord (rec.buf[pos + sizeof (tak_param_info)  -
              sizeof (tsp00_C256) - 1]);
&       ifdef trace
        t01int4 (ak_sem, 'move_len    ', move_len);
&       endif
        a10new (acv, move_len, p.mobj);
        IF  p.mobj = NIL
        THEN
            ak10no_more_memory (acv, e)
        ELSE
            BEGIN
            syspoint^.smethod.me_param_list[parm_no] := p.pp;
            SAPDB_PascalMove ('VAK10 ',  32,    
                  sizeof (rec.buf), move_len,
                  @rec.buf, pos, @p.pp^, 1, move_len, e);
            pos := pos + move_len
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  e <> e_ok
    THEN
        BEGIN
        FOR ix := 1 TO parm_no - 1 DO
            BEGIN
            p.pp := syspoint^.smethod.me_param_list[ix];
            a10dispose (acv, p.mobj)
            END;
        (*ENDFOR*) 
        IF  e = e_key_not_found
        THEN
            e := e_sysinfo_not_found;
        (*ENDIF*) 
        a07_b_put_error (acv, e, 1);
        parm_no := csp_maxint2 (* exit loop *)
        END
    ELSE
        parm_no := parm_no + 1;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10get_perm_record (
            VAR acv    : tak_all_command_glob;
            VAR syskey : tgg00_SysInfoKey;
            VAR rbuf   : tgg00_Rec;
            VAR b_err  : tgg00_BasisError);
 
VAR
      mblock  : tgg00_MessBlock;
      qual    : tak10qual;
 
BEGIN
b_err := e_ok;
g01mblock_init   (acv.a_transinf.tri_trans, m_get, mm_direct, mblock);
g01stack_init    (mblock, NIL, 0, @qual, sizeof (qual));
g01datapart_init (mblock, @rbuf, sizeof (rbuf));
mblock.mb_qual_len := sizeof (qual.q_hd);
SAPDB_PascalMove ('VAK10 ',  33,    
      sizeof (syskey), mblock.mb_data_size, @syskey, cgg_rec_key_offset+1,
      @mblock.mb_data^.mbp_buf, cgg_rec_key_offset + 1, syskey.skeylen, b_err);
mblock.mb_data^.mbp_keylen := syskey.skeylen;
mblock.mb_data_len         :=
      mblock.mb_data^.mbp_keylen + cgg_rec_key_offset;
IF  b_err = e_ok
THEN
    ak10send_mess_block (acv,
          mblock, syskey.sentrytyp, true, b_err);
(*ENDIF*) 
IF  b_err = e_ok
THEN
    a10expand_rec (mblock.mb_data^.mbp_rec, b_err)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10get_supplement (
            VAR acv      : tak_all_command_glob;
            VAR p        : tsp00_BufAddr;
            required_len : tsp00_Int4);
 
VAR
      bufno      : integer;
      curr       : tak_cache_dir_pointer;
      supplement : tsp00_Int4;
 
      univ_ptr : RECORD
            CASE integer OF
                1 :
                    (cdir_ptr : tak_cache_dir_pointer);
                2 :
                    (chptr    : tak10cache_header_ptr);
                3 :
                    (i        : tsp00_Int4);
                END;
            (*ENDCASE*) 
 
 
      prev_cache : RECORD
            CASE boolean OF
                true :
                    (bufaddr : tsp00_BufAddr);
                false :
                    (chptr   : tak10cache_header_ptr);
                END;
            (*ENDCASE*) 
 
 
BEGIN
prev_cache.bufaddr := acv.a_sysdir.ci_cache_p;
bufno              := 1;
WHILE prev_cache.chptr^.ch_next_cache <> NIL DO
    BEGIN
    bufno              := bufno + 1;
    prev_cache.bufaddr := prev_cache.chptr^.ch_next_cache;
    END;
(*ENDWHILE*) 
ak10alloc_mem (acv, NOT cak10init_cache,
      required_len, univ_ptr.cdir_ptr.buf_ptr, supplement);
IF  univ_ptr.cdir_ptr.buf_ptr <> NIL
THEN
    BEGIN
&   ifdef trace
    g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_supplement,
          csp3_n_akcache, 'CACHE SUPPLEMENT GRANTED                ');
&   endif
    (* PTS 1115043 E.Z. *)
    a51inc_ak_cache_size (acv.a_size_ptr, supplement);
    prev_cache.chptr^.ch_next_cache := univ_ptr.cdir_ptr.buf_ptr;
    univ_ptr.chptr^.ch_next_cache   := NIL;
    univ_ptr.chptr^.ch_label        := ak10ChunkLabel;
    univ_ptr.chptr^.ch_label[4]     := chr(ord('0') + bufno);
    univ_ptr.chptr^.ch_size         := supplement;
    IF  required_len > 0
    THEN
        BEGIN
        curr.buf_ptr := s35add_bufaddr_ptocm (univ_ptr.cdir_ptr.buf_ptr,
              sizeof (univ_ptr.chptr^));
        WITH curr.cdir_ptr^ DO
            BEGIN
            cd_block_pos         := sizeof (univ_ptr.chptr^) + 1;
            cd_block_check       := cak_cache_chunk_flag;
            cd_refCount          := 0;
            cd_syslen            := required_len;
            (* PTS 1111327 E.Z. initialize ..prev *)
            cd_fix_next.cdir_ptr := NIL;
            cd_fix_prev.cdir_ptr := NIL;
            cd_less.cdir_ptr     := NIL;
            cd_greater.cdir_ptr  := NIL;
            cd_lru_next.cdir_ptr := NIL;
            cd_lru_prev.cdir_ptr := NIL;
            cd_state             := [dno_meaning];
            cd_buf_no            := bufno;
            p                    := curr.buf_ptr
            END;
        (*ENDWITH*) 
        END;
    (*ENDIF*) 
    IF  supplement * sizeof (tsp00_Page) - required_len -
        sizeof (univ_ptr.chptr^) >=
        mxak_cache_dir_entry + cak_maxcacherest
    THEN
        BEGIN
        curr.buf_ptr := s35add_bufaddr_ptocm (univ_ptr.cdir_ptr.buf_ptr,
              sizeof (univ_ptr.chptr^) + required_len);
        WITH curr.cdir_ptr^ DO
            BEGIN
            cd_block_pos   := sizeof (univ_ptr.chptr^) +
                  required_len + 1;
            cd_block_check := cak_cache_chunk_flag;
            cd_syslen      :=
                  supplement * sizeof (tsp00_Page) - cd_block_pos + 1;
            cd_buf_no            := bufno;
            (* PTS 1111500 E.Z. *)
            cd_lru_next.cdir_ptr := NIL;
            cd_lru_prev.cdir_ptr := NIL;
            cd_fix_next.cdir_ptr := NIL;
            cd_fix_prev.cdir_ptr := NIL;
            cd_state             := [dno_meaning];
            END;
        (*ENDWITH*) 
        ak10block_into_freelist (acv, curr, NOT c_del_in_directory,
              c_del_dependecies);
&       ifdef trace
        ak10td_freelist (acv, ak_cach);
&       endif
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10InsertReference (
            VAR acv         : tak_all_command_glob;
            pHandle         : tgg00_VoidPtr;
            p               : tak_sysbufferaddress;
            e               : tgg00_BasisError);
 
VAR
      dummy            : boolean;
      requiredLen      : tsp00_Int4;
      aux              : tak_cache_dir_pointer;
      find_info        : tak10_find_info;
      rbuf             : tgg00_Rec;
 
BEGIN
IF  pHandle = NIL
THEN
    a07ak_system_error (acv, 10, 4)
ELSE
    IF  e = e_sysinfo_not_found
    THEN
        a103ReleaseCacheHandle (acv, pHandle, true)
    ELSE
        BEGIN
        rbuf.len    := 4 * sizeof(tak_sysbufferaddress);
        requiredLen := mxak_cache_dir_entry + rbuf.len;
        ak10getmem (acv, cak_is_undefined, requiredLen, aux.buf_ptr);
        IF  aux.buf_ptr <> NIL
        THEN
            BEGIN
            aux.cdir_ptr^.cd_ref.cd_globalCacheHandle := pHandle;
            aux.cdir_ptr^.cd_ref.cd_globalSysinfoPtr  := p;
            aux.cdir_ptr^. cd_ref.cd_nextRef :=
                  acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_ref.cd_nextRef;
            aux.cdir_ptr^.cd_ref.cd_prevRef := acv.a_sysdir.ci_cache_dir_header;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_ref.
                  cd_nextRef.cdir_ptr^.cd_ref.cd_prevRef := aux;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_ref.cd_nextRef := aux;
            aux.cdir_ptr^.cd_cmd_no            := acv.a_command_id;
            aux.cdir_ptr^.cd_create_cmd_no     := acv.a_command_id;
            aux.cdir_ptr^.cd_state             := [dreference];
            aux.cdir_ptr^.cd_lru_next :=
                  acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_lru_next;
            aux.cdir_ptr^.cd_lru_prev := acv.a_sysdir.ci_cache_dir_header;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.
                  cd_lru_next.cdir_ptr^.cd_lru_prev := aux;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_lru_next := aux;
            (*========== Chain into FIX-List ============*)
            aux.cdir_ptr^.cd_fix_next :=
                  acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_fix_next;
            aux.cdir_ptr^.cd_fix_prev := acv.a_sysdir.ci_cache_dir_header;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.
                  cd_fix_next.cdir_ptr^.cd_fix_prev := aux;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_fix_next := aux;
            ak10ins_directory (acv, find_info,
                  acv.a_sysdir.ci_dir [ord(p^.syskey.sentrytyp[2])],
                  aux, dummy);
            END
        ELSE
            BEGIN
            a103ReleaseCacheHandle (acv, pHandle, true);
            a07_b_put_error (acv, e_no_more_memory, 1)
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10ins_directory (
            VAR acv         : tak_all_command_glob;
            VAR find_info   : tak10_find_info;
            VAR p           : tak_cache_dir_pointer;
            VAR ins_p       : tak_cache_dir_pointer;
            VAR incremented : boolean);
 
VAR
      p1    : tak_cache_dir_pointer;
      p2    : tak_cache_dir_pointer;
      pKey1 : tak10_SysKeyPointer;
      pKey2 : tak10_SysKeyPointer;
 
BEGIN
IF  p.cdir_ptr = NIL
THEN
    BEGIN
    p           := ins_p;
    incremented := true;
    WITH p.cdir_ptr^ DO
        BEGIN
        cd_less.cdir_ptr    := NIL;
        cd_greater.cdir_ptr := NIL;
        cd_balance          := balanced;
        END;
    (*ENDWITH*) 
    END
ELSE
    BEGIN
    IF  dreference in ins_p.cdir_ptr^.cd_state
    THEN
        pKey1 := ak10GlobalCacheGetKeyPointer(ins_p)
    ELSE
        pKey1 := @ins_p.cdir_ptr^.cd_syskey;
    (*ENDIF*) 
    IF  dreference in p.cdir_ptr^.cd_state
    THEN
        pKey2 := ak10GlobalCacheGetKeyPointer(p)
    ELSE
        pKey2 := @p.cdir_ptr^.cd_syskey;
    (*ENDIF*) 
&   ifdef trace
    t01buf1 (ak_cach, pKey1^, 1,
          pKey1^.skeylen + cgg_rec_key_offset);
    t01buf1 (ak_cach, pKey2^, 1,
          pKey2^.skeylen + cgg_rec_key_offset);
&   endif
    s30cmp (pKey1^,
          cgg_rec_key_offset+1, pKey1^.skeylen,
          pKey2^, cgg_rec_key_offset+1, pKey2^.skeylen, find_info.fi_res);
    CASE  find_info.fi_res OF
        l_less :
            BEGIN
            ak10ins_directory (acv, find_info, p.cdir_ptr^.cd_less,
                  ins_p, incremented);
            IF  incremented
            THEN (* left subtree has grown *)
                CASE p.cdir_ptr^.cd_balance OF
                    left_weighted :
                        BEGIN
                        p1 := p.cdir_ptr^.cd_less;
                        IF  p1.cdir_ptr^.cd_balance = left_weighted
                        THEN (* LL rotation *)
                            BEGIN
                            p.cdir_ptr^.cd_less     :=
                                  p1.cdir_ptr^.cd_greater;
                            p1.cdir_ptr^.cd_greater := p;
                            p.cdir_ptr^.cd_balance  := balanced;
                            p                       := p1
                            END
                        ELSE
                            BEGIN (* double LR rotation *)
                            p2 := p1.cdir_ptr^.cd_greater;
                            p1.cdir_ptr^.cd_greater :=
                                  p2.cdir_ptr^.cd_less;
                            p2.cdir_ptr^.cd_less := p1;
                            p.cdir_ptr^.cd_less := p2.cdir_ptr^.cd_greater;
                            p2.cdir_ptr^.cd_greater := p;
                            IF  p2.cdir_ptr^.cd_balance = left_weighted
                            THEN
                                p.cdir_ptr^.cd_balance := right_weighted
                            ELSE
                                p.cdir_ptr^.cd_balance := balanced;
                            (*ENDIF*) 
                            IF  p2.cdir_ptr^.cd_balance = right_weighted
                            THEN
                                p1.cdir_ptr^.cd_balance := left_weighted
                            ELSE
                                p1.cdir_ptr^.cd_balance := balanced;
                            (*ENDIF*) 
                            p := p2
                            END;
                        (*ENDIF*) 
                        p.cdir_ptr^.cd_balance := balanced;
                        incremented            := false
                        END;
                    balanced :
                        p.cdir_ptr^.cd_balance := left_weighted;
                    right_weighted :
                        BEGIN
                        p.cdir_ptr^.cd_balance := balanced;
                        incremented            := false
                        END;
                    OTHERWISE
                        ak10cache_error (acv, 'ak10ins_directory       ', p);
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
            END;
        l_greater :
            BEGIN
            ak10ins_directory (acv, find_info, p.cdir_ptr^.cd_greater,
                  ins_p, incremented);
            IF  incremented
            THEN (* left subtree has grown *)
                CASE p.cdir_ptr^.cd_balance OF
                    left_weighted :
                        BEGIN
                        p.cdir_ptr^.cd_balance := balanced;
                        incremented            := false
                        END;
                    balanced :
                        p.cdir_ptr^.cd_balance := right_weighted;
                    right_weighted :
                        BEGIN
                        p1 := p.cdir_ptr^.cd_greater;
                        IF  p1.cdir_ptr^.cd_balance = right_weighted
                        THEN (* RR rotation *)
                            BEGIN
                            p.cdir_ptr^.cd_greater  :=
                                  p1.cdir_ptr^.cd_less;
                            p1.cdir_ptr^.cd_less    := p;
                            p.cdir_ptr^.cd_balance  := balanced;
                            p                       := p1
                            END
                        ELSE
                            BEGIN (* double RL rotation *)
                            p2 := p1.cdir_ptr^.cd_less;
                            p1.cdir_ptr^.cd_less :=
                                  p2.cdir_ptr^.cd_greater;
                            p2.cdir_ptr^.cd_greater := p1;
                            p.cdir_ptr^.cd_greater := p2.cdir_ptr^.cd_less;
                            p2.cdir_ptr^.cd_less := p;
                            IF  p2.cdir_ptr^.cd_balance = right_weighted
                            THEN
                                p.cdir_ptr^.cd_balance := left_weighted
                            ELSE
                                p.cdir_ptr^.cd_balance := balanced;
                            (*ENDIF*) 
                            IF  p2.cdir_ptr^.cd_balance = left_weighted
                            THEN
                                p1.cdir_ptr^.cd_balance := right_weighted
                            ELSE
                                p1.cdir_ptr^.cd_balance := balanced;
                            (*ENDIF*) 
                            p := p2
                            END;
                        (*ENDIF*) 
                        p.cdir_ptr^.cd_balance := balanced;
                        incremented            := false
                        END;
                    OTHERWISE
                        ak10cache_error (acv, 'ak10ins_directory       ', p);
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
            END;
        OTHERWISE
            BEGIN
&           ifdef trace
            t01int4 (ak_cach, 'duplicatekey', 1);
&           endif
            incremented := false
            END;
        END;
    (*ENDCASE*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10lock_unlock_fixed (
            VAR acv : tak_all_command_glob;
            lock    : boolean);
 
VAR
      p   : tak_cache_dir_pointer;
 
BEGIN
&ifdef trace
t01int4 (ak_cach, 'lock        ', ord(lock));
&endif
WITH acv, a_sysdir DO
    BEGIN
    p   := ci_cache_dir_trailor.cdir_ptr^.cd_fix_prev;
    WHILE p.cdir_ptr <> ci_cache_dir_header.cdir_ptr DO
        BEGIN
        IF  p.cdir_ptr^.cd_check <> cak_cache_chunk_flag
        THEN
            BEGIN
            ak10cache_error (acv, 'ak10lock_unlock         ', p);
            p := ci_cache_dir_header
            END
        ELSE
            WITH p.cdir_ptr^ DO
                BEGIN
&               ifdef TRACE
                xtd_directory (ak_cach, p);
&               endif
                IF  lock
                THEN
                    BEGIN
                    cd_state    := cd_state + [dlocked];
                    cd_refCount := cd_refCount + 1
                    END
                ELSE
                    IF  dlocked in cd_state
                    THEN
                        BEGIN
                        cd_state    := cd_state - [dlocked];
                        cd_refCount := cd_refCount - 1;
&                       ifdef trace
                        IF  cd_refCount < 0
                        THEN
                            g01abort (csp3_a10_cache_error,
                                  csp3_n_akcache, 'refCount < 0            ', cd_refCount);
&                       endif
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                p := p.cdir_ptr^.cd_fix_prev
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10invalidate_root (
            VAR treeid : tgg00_FileId;
            p          : tak_cache_dir_pointer);
 
BEGIN
IF  p.cdir_ptr <> NIL
THEN
    WITH p.cdir_ptr^ DO
        BEGIN
        IF  NOT (dreference in cd_state)
            AND
            (cd_syskey.sentrytyp = cak_etable)
        THEN
            IF  cd_sysinfo.sbase.btreeid.fileName_gg00 = treeid.fileName_gg00
            THEN
                cd_sysinfo.sbase.btreeid.fileRoot_gg00 := NIL_PAGE_NO_GG00;
            (*ENDIF*) 
        (*ENDIF*) 
        ak10invalidate_root (treeid, cd_less);
        ak10invalidate_root (treeid, cd_greater)
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10put_mbuf_into_cache (
            VAR acv       : tak_all_command_glob;
            VAR rbuf      : tgg00_Rec;
            dstate        : tak_directory_state;
            VAR find_info : tak10_find_info;
            VAR syskey    : tgg00_SysInfoKey;
            VAR syspoint  : tak_sysbufferaddress);
 
VAR
      found_in_cache : boolean;
      dummy          : boolean;
      is_base_rec    : boolean;
      is_syn_rec     : boolean;
      maxcol         : integer;
      move_len       : integer;
      rest_len       : integer;
      syslen         : tsp00_Int4;
      p              : tak_cache_dir_pointer;
      rbuf_ptr       : tak_sysbufferaddress;
 
      univ_ptr       : RECORD
            CASE boolean OF
                true :
                    (buf_ptr : tsp00_BufAddr);
                false :
                    (sys_ptr : tak_sysbufferaddress);
                END;
            (*ENDCASE*) 
 
 
BEGIN
IF  acv.a_returncode = 0
THEN
    BEGIN
    rbuf_ptr       := @rbuf;
    found_in_cache := false;
    is_base_rec    := false;
    rest_len       := 0;
    IF  find_info.fi_kind = get_next
    THEN
        BEGIN (* check, if record is already stored in cache *)
        SAPDB_PascalMove ('VAK10 ',  34,    
              sizeof (rbuf.buf), sizeof (syskey),
              @rbuf.buf, 1, @syskey, 1, cgg_rec_key_offset + rbuf.keylen,
              acv.a_returncode);
        ak10find_syskey (acv, syskey, find_info, NOT cak10CheckReferences);
        IF  find_info.fi_res = l_equal
        THEN (* record found in cache *)
            BEGIN
            p  := find_info.fi_ptr;
            IF  p.cdir_ptr^.cd_cmd_no <> acv.a_command_id (* PTS 1132503 *)
            THEN
                BEGIN
                ak10temp_add (acv, p, NOT c_is_rollback);
                ak10block_into_freelist (acv, p, c_del_in_directory, c_del_dependecies);
                END
            ELSE
                BEGIN
                IF  dreference in p.cdir_ptr^.cd_state
                THEN
                    a07_b_put_error (acv, e_not_implemented, 1)
                ELSE
                    syspoint := @p.cdir_ptr^.cd_sysinfo;
                (*ENDIF*) 
                found_in_cache := true;
                (*========== remove from LRU-List ===========*)
                p.cdir_ptr^.cd_lru_prev.cdir_ptr^.cd_lru_next :=
                      p.cdir_ptr^.cd_lru_next;
                p.cdir_ptr^.cd_lru_next.cdir_ptr^.cd_lru_prev :=
                      p.cdir_ptr^.cd_lru_prev
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  NOT found_in_cache
    THEN
        BEGIN
        IF  find_info.fi_kind <> nil_get (* PTS 1113024 *)
        THEN
            IF  (syskey.sentrytyp = cak_emessblock      ) OR
                (syskey.sentrytyp = cak_epermmessblock  ) OR
                (syskey.sentrytyp = cak_etriggerparsinfo)
            THEN
                rbuf.len := sizeof (tak_messblock_record);
            (*ENDIF*) 
        (*ENDIF*) 
        syslen := rbuf.len;
        IF  find_info.fi_kind <> nil_get
        THEN
            BEGIN
            IF  rbuf.info[ SURROGATE_MXGG00 + 2 ] < cak_ctemp
            THEN
                BEGIN
                IF  syskey.sentrytyp = cak_epermmessblock
                THEN
                    ak10get_mess_block (acv, @rbuf);
                (*ENDIF*) 
                END
            ELSE
                IF  find_info.fi_kind = get
                THEN (* temporary catalog information *)
                    CASE syskey.sentrytyp[2] OF
                        cak_cjparsinfo, cak_cparsinfo, cak_cshortinfo,
                        cak_creskey, cak_clinkpos, cak_clongliteral :
                            BEGIN
                            univ_ptr.buf_ptr := @rbuf;
                            rest_len :=
                                  univ_ptr.sys_ptr^.sparsinfo.p_fullen -
                                  syslen;
                            syslen := univ_ptr.sys_ptr^.sparsinfo.p_fullen
                            END;
                        cak_ccolnames :
                            IF  syslen = MAX_RECLEN_GG00
                            THEN
                                syslen := sizeof (tak_columnnamesrecord);
                            (*ENDIF*) 
                        cak_cmessblock, cak_ctriggerparsinfo :
                            ak10get_mess_block (acv, @rbuf);
                        OTHERWISE ;
                        END;
                    (*ENDCASE*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF   (find_info.fi_kind <> nil_get) AND
            (rbuf_ptr^.syskey.sentrytyp[2] in
            [cak_ctable, cak_cresult, cak_cmethod])
        THEN
            CASE rbuf_ptr^.syskey.sentrytyp[2] OF
                cak_cmethod :
                    syslen := mxak_cache_dir_entry +
                          sizeof (rbuf_ptr^.smethod) -
                          sizeof (rbuf_ptr^.smethod.me_param_list) +
                          rbuf_ptr^.smethod.me_param_cnt *
                          sizeof (rbuf_ptr^.smethod.me_param_list[1]);
                OTHERWISE
                    BEGIN
                    is_base_rec := true;
                    IF  ak10migrate                           AND
                        (rbuf_ptr^.sbase.btablekind <> tsynonym) AND
                        (NOT ak10IsExplicitMigTable (rbuf_ptr^.sbase.bsurrogate))
                    THEN
                        ak10MigateBaseRecord (acv, rbuf);
                    (*ENDIF*) 
                    WITH rbuf_ptr^.sbase DO
                        BEGIN
                        IF  btablekind <> tsynonym
                        THEN
                            BEGIN
                            is_syn_rec := false;
                            IF  (acv.a_is_ddl = no_ddl) OR (acv.a_is_ddl = ddl_update_statistics)
                            THEN
                                maxcol := bmaxcol
                            ELSE
                                maxcol := MAX_COL_PER_TAB_GG00;
                            (*ENDIF*) 
                            bfirstindex := a11firstindex (maxcol, rbuf_ptr^.sbase);
                            syslen      := mxak_cache_dir_entry +
                                  sizeof (tak_baserecord) -
                                  sizeof (rbuf_ptr^.sbase.bcolumn) +
                                  (bfirstindex + maxcol) * sizeof (bcolumn[1])
                            END
                        ELSE
                            BEGIN (* synonym *)
                            is_syn_rec := true;
                            syslen := mxak_cache_dir_entry +
                                  sizeof (tak_synonymrecord)
                            END;
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                    END
                END
            (*ENDCASE*) 
        ELSE
            syslen := mxak_cache_dir_entry + syslen;
        (*ENDIF*) 
        ak10getmem (acv, cak_is_undefined, syslen, p.buf_ptr);
        IF  acv.a_returncode = 0
        THEN
            BEGIN
            WITH p.cdir_ptr^ DO
                BEGIN
                syspoint             := @cd_sysinfo;
                cd_cmd_no            := acv.a_command_id;
                cd_balance           := balanced;
                IF  find_info.fi_kind = nil_get
                THEN
                    BEGIN
                    cd_create_cmd_no := acv.a_command_id;
                    cd_state         := [];
                    move_len         := cgg_rec_key_offset + rbuf.keylen
                    END
                ELSE
                    BEGIN
                    cd_state         := [ dwritten ];
                    cd_create_cmd_no := cak_is_undefined;
                    IF  is_base_rec
                    THEN
                        IF  is_syn_rec
                        THEN
                            move_len := mxak_synonymrec_offset
                        ELSE
                            move_len := a10BaseRecPersistentOffset (* PTS 1105713, T.A. 24.02.2000 *)
                        (*ENDIF*) 
                    ELSE
                        CASE rbuf_ptr^.syskey.sentrytyp[2] OF
                            cak_cmethod :
                                move_len := sizeof (tak_methodrecord) -
                                      sizeof (tak_param_array);
                            OTHERWISE
                                move_len := rbuf.len;
                            END;
                        (*ENDCASE*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&               ifdef trace
                t01int4 (ak_cach, 'move_len    ', move_len);
&               endif
                SAPDB_PascalMove ('VAK10 ',  35,    
                      sizeof (rbuf.buf), sizeof (tsp00_Buf),
                      @rbuf.buf, 1, @syspoint^, 1, move_len,
                      acv.a_returncode);
                IF  rest_len > 0
                THEN
                    ak10restore_record_suffix (acv,
                          rbuf, syspoint, rest_len)
                ELSE
                    IF  is_base_rec
                    THEN
                        IF  is_syn_rec
                        THEN
                            ak10synonym_record (rbuf, syspoint,
                                  acv.a_returncode)
                        ELSE
                            BEGIN
                            syspoint^.b_sl := syslen - mxak_cache_dir_entry;
                            ak10base_record (acv, rbuf, syspoint)
                            END
                        (*ENDIF*) 
                    ELSE
                        IF  find_info.fi_kind <> nil_get
                        THEN
                            CASE syskey.sentrytyp[2] OF
                                cak_ccolnames :
                                    IF  syspoint^.b_sl = MAX_RECLEN_GG00
                                    THEN
                                        ak10get_colnames_record (acv, syspoint);
                                    (*ENDIF*) 
                                cak_cmethod :
                                    ak10get_method_record (acv,
                                          rbuf, syspoint);
                                OTHERWISE ;
                                END;
                            (*ENDCASE*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  acv.a_returncode = 0
                THEN
                    ak10ins_directory (acv, find_info,
                          acv.a_sysdir.ci_dir [ord(cd_syskey.sentrytyp[2])],
                          p, dummy);
&               ifdef TRACE
                (*ENDIF*) 
                xtd_directory (ak_cach, p);
&               endif
                END;
            (*ENDWITH*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  acv.a_returncode = 0
    THEN
        BEGIN
        (*============== Chain into LRU-List ================*)
        p.cdir_ptr^.cd_lru_next :=
              acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_lru_next;
        p.cdir_ptr^.cd_lru_prev := acv.a_sysdir.ci_cache_dir_header;
        acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.
              cd_lru_next.cdir_ptr^.cd_lru_prev := p;
        acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_lru_next := p;
        IF  (dstate = d_fix) AND
            ((NOT found_in_cache) OR
            (p.cdir_ptr^.cd_fix_next.cdir_ptr = NIL))
        THEN
            BEGIN
            (*========== Chain into FIX-List ============*)
            p.cdir_ptr^.cd_fix_next :=
                  acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_fix_next;
            p.cdir_ptr^.cd_fix_prev := acv.a_sysdir.ci_cache_dir_header;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.
                  cd_fix_next.cdir_ptr^.cd_fix_prev := p;
            acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_fix_next := p
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10release_table (
            VAR tabid : tgg00_Surrogate;
            p : tak_cache_dir_pointer);
 
VAR
      pKey : tak10_SysKeyPointer;
 
BEGIN
WITH p.cdir_ptr^ DO
    BEGIN
    IF  dreference in cd_state
    THEN
        pKey := ak10GlobalCacheGetKeyPointer(p)
    ELSE
        pKey := @cd_syskey;
    (*ENDIF*) 
    IF  (pKey^.stableid = tabid) AND (cd_fix_next.cdir_ptr <> NIL)
    THEN
        BEGIN
        cd_fix_next.cdir_ptr^.cd_fix_prev := cd_fix_prev;
        cd_fix_prev.cdir_ptr^.cd_fix_next := cd_fix_next;
        cd_fix_next.cdir_ptr := NIL
        END;
    (*ENDIF*) 
    IF  cd_less.cdir_ptr <> NIL
    THEN
        ak10release_table (tabid, cd_less);
    (*ENDIF*) 
    IF  cd_greater.cdir_ptr <> NIL
    THEN
        ak10release_table (tabid, cd_greater);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10restore_record_suffix (
            VAR acv  : tak_all_command_glob;
            VAR rbuf : tgg00_Rec;
            syspoint : tak_sysbufferaddress;
            rest_len : integer);
 
VAR
      b_err    : tgg00_BasisError;
      move_len : integer;
      syskey   : tgg00_SysInfoKey;
 
BEGIN
syskey         := syspoint^.syskey;
syskey.skeylen := syskey.skeylen + 1;
syskey.all[syskey.skeylen] := chr(0);
REPEAT
    syskey.all[syskey.skeylen] := succ(syskey.all[syskey.skeylen]);
    b07cget_record (acv.a_transinf.tri_trans,
          acv.a_pars_curr, syskey, rbuf);
    b_err := acv.a_transinf.tri_trans.trError_gg00;
    IF  b_err = e_ok
    THEN
        BEGIN
        move_len := rbuf.len - cgg_rec_key_offset - rbuf.keylen;
        SAPDB_PascalMove ('VAK10 ',  36,    
              sizeof (rbuf.buf), sizeof (syspoint^),
              @rbuf.buf, cgg_rec_key_offset + rbuf.keylen + 1,
              @syspoint^, syspoint^.b_sl + 1, move_len, b_err);
        syspoint^.b_sl := syspoint^.b_sl + move_len;
        rest_len       := rest_len - move_len
        END;
    (*ENDIF*) 
    IF  b_err <> e_ok
    THEN
        BEGIN
        a07ak_system_error (acv, 10, 3);
        rest_len := 0
        END;
    (*ENDIF*) 
UNTIL
    rest_len <= 0;
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10send_mess_block (
            VAR acv : tak_all_command_glob;
            VAR mblock : tgg00_MessBlock;
            entrytype  : tsp00_C2;
            return_req : boolean;
            VAR b_err  : tgg00_BasisError);
 
BEGIN
IF  entrytype >= cak_etemp
THEN (* access temp catalog *)
    BEGIN
    mblock.mb_qual^.mtree := acv.a_pars_curr
    END
ELSE
    IF  entrytype >= cak_esysfile2
    THEN (* access sytemfile2 *)
        kb560GetSys2CatalogTreeId (mblock.mb_qual^.mtree)
    ELSE
        kb560GetSys1CatalogTreeId (mblock.mb_qual^.mtree);
    (*ENDIF*) 
(*ENDIF*) 
IF  acv.a_command_kind = show_command
THEN
    mblock.mb_qual^.mtree.fileHandling_gg00 := [ hsCollisionTest_egg00, hsNoWait_egg00 ]
ELSE
    IF  acv.a_is_ddl = no_ddl
    THEN
        mblock.mb_qual^.mtree.fileHandling_gg00 := [ hsCollisionTest_egg00 ]
    ELSE
        IF  NOT gg999KernelStateIsRedoLogProcessing
        THEN
            mblock.mb_qual^.mtree.fileHandling_gg00 := [  ];
&       ifdef trace
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
SAPDB_PascalFill ('VAK10 ',  37,    
      mblock.mb_data_size,
      @mblock.mb_data^.mbp_buf, mblock.mb_data_len + 1,
      mblock.mb_data_size - mblock.mb_data_len, chr(0), b_err);
&endif
a06lsend_mess_buf (acv,
      mblock, NOT c_call_from_rsend, b_err);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10size_check (
            VAR acv   : tak_all_command_glob;
            entrytype : tsp00_C2;
            length    : integer);
 
VAR
      len   : integer;
      error : tgg00_BasisError;
 
BEGIN
error := e_too_long_record;
CASE entrytype[2] OF
    cak_ctable :
        len := sizeof (tak_baserecord);
    cak_ccolnames :
        len := sizeof (tak_columnnamesrecord);
    cak_ccomment :
        len := sizeof (tak_comment_record);
    cak_ccomplex :
        len := sizeof (tak_complexrecord);
    cak_cconstraint  :
        len := sizeof (tak_constraintrecord);
    cak_cconstraintname  :
        len := sizeof (tak_constraintnamerecord);
    cak_ccorrinfo :
        len := sizeof (tak_correcord);
    cak_cdefault :
        len := sizeof (tak_defaultrecord);
    cak_cdomain :
        len := sizeof (tak_domainrecord);
    cak_cdomainref :
        len := sizeof (tak_domainref);
    (* PTS 1111575 E.Z. *)
    cak_cjparsinfo :
        len := sizeof (tak68_joinparsrecord);
    cak_cprimarykey, cak_cforeignkey :
        len := sizeof (tak_linkrecord);
    cak_clinkdef :
        len := sizeof (tak_link_def_record);
    cak_clinkparsinfo :
        len := sizeof (tak_linkparsrecord);
    cak_clinkpos :
        len := sizeof (tak_linkinforecord);
    cak_cserverdb    :
        len := sizeof (tak_serverdbrecord);
    cak_cserverdbname :
        len := sizeof (tak_serverdbnamerecord);
    cak_cmethod :
        len := sizeof (tak_methodrecord);
    cak_cmindex      :
        len := sizeof ( tak_mindexrecord);
    cak_cparsinfo    :
        len := sizeof (tak_parsinforecord);
    cak_cpriv        :
        len := sizeof (tak_privrecord);
    cak_cprivuser    :
        len := sizeof (tak_privuserrecord);
    cak_creskey      :
        len := MAX_INT2_SP00;
    (* sizeof (tak_resultkeyrecord) would be > 32KB,            *)
    (* will never be used for real instances of resultkeyrecord *)
    ;
    cak_cresult      :
        len := sizeof (tak_resultrecord);
    cak_ctempscoldesc    :
        len := sizeof (tak_scoldescrecord);
    cak_csequence    :
        len := sizeof (tak_sequencerecord);
    cak_cshortinfo   :
        len := sizeof (tak_shortinforecord);
    cak_csubtrans    :
        len := sizeof (tak_subtransrecord);
    cak_csysdba      :
        len := sizeof (tak_sysdbarecord);
    cak_ctableref    :
        len := sizeof (tak_tablereference);
    cak_ctrigger     :
        len := sizeof (tak_triggerrecord);
    cak_cunionrec    :
        len := sizeof (tak_unionrecord);
    cak_cusage       :
        len := sizeof (tak_usagerecord);
    cak_cuser        :
        len := sizeof (tak_userrecord);
    cak_cuserid      :
        len := sizeof (tak_useridrecord);
    cak_cuserref     :
        len := sizeof (tak_userrefrecord);
    cak_cusertab     :
        len := sizeof (tak_usertablerecord);
    cak_cviewdesc    :
        len := sizeof (tak_viewdescrecord);
    cak_cviewkey     :
        len := sizeof (tak_viewkeyrecord);
    cak_cviewqual_basis :
        len := sizeof (tak_viewqual_basis_record);
    cak_cviewqual_join :
        len := sizeof (tak_viewqual_join_record);
    cak_cviewqual_stack :
        len := sizeof (tak_viewqual_stack_record);
    cak_cviewqual_expcol :
        len := sizeof (tak_viewqual_stack_record);
    cak_cviewqual_derivedcol :
        len := sizeof (tak_viewqual_derivedcol_record);
    cak_cviewtext    :
        len := sizeof (tak_viewtextrecord);
    cak_cresname     :
        len := sizeof (tak_resname_record);
    cak_cmapset      :
        len := sizeof (tak_mapset_record);
    cak_cfuncref     :
        len := sizeof (tak_funcrefrecord);
    cak_cprocpriv, cak_csequencepriv :
        len := sizeof (tak_proc_seq_privilege);
    cak_cdomainusage :
        len := sizeof (tak_col_uses_dom);
    cak_clongliteral :
        len := sizeof (tak_longlit_buf);
    OTHERWISE
        len := MAX_RECLEN_GG00;
    END;
(*ENDCASE*) 
IF  (length > len) OR (len > csp_maxint2)
THEN
    BEGIN
&   ifdef trace
    t01int4 (ak_cach, 'etype       ', ord (entrytype[2]));
    t01int4 (ak_cach, 'required_len', length);
    t01int4 (ak_cach, 'max_len     ', len);
&   endif
    a07_b_put_error (acv, error, 1)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10space_for_mblock (
            VAR acv          : tak_all_command_glob;
            VAR in_mblock    : tgg00_MessBlock;
            VAR stack_length : tsp00_Int4;
            VAR out_mblock   : tgg00_MessBlock;
            VAR b_err        : tgg00_BasisError);
 
VAR
      ix           : integer;
      block_cnt    : integer;
      required_len : tsp00_Int4;
      block_addr   : ARRAY[1..4] OF tak_cache_dir_pointer;
 
BEGIN
b_err                    := e_ok;
out_mblock.mb_qual_size  := 0;
out_mblock.mb_data_size  := 0;
out_mblock.mb_strat_size := 0;
out_mblock.mb_st_size    := 0;
out_mblock.mb_data       := NIL;
out_mblock.mb_qual       := NIL;
out_mblock.mb_st         := NIL;
out_mblock.mb_strat      := NIL;
block_cnt                := 0;
FOR ix := 0 TO cgg_idx_max_valuefieldlist DO
    out_mblock.mb_fieldlists[ix] := NIL;
(*ENDFOR*) 
&ifdef trace
t01int4 (ak_sem, 'in qual len ', in_mblock.mb_qual_len);
t01int4 (ak_sem, 'in data len ', in_mblock.mb_data_len);
t01int4 (ak_sem, 'in strat len', in_mblock.mb_strat_len);
&endif
IF  in_mblock.mb_qual_len > 0
THEN
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'in qual len ', in_mblock.mb_qual_len);
&   endif
    IF  (in_mblock.mb_st <> NIL) AND (stack_length = cak_is_undefined)
    THEN
        stack_length := (in_mblock.mb_qual^.mfirst_free - 1) *
              sizeof (tgg00_StackEntry);
    (*ENDIF*) 
    required_len := mxak_cache_dir_entry + in_mblock.mb_qual_len;
    IF  (stack_length > 0) AND
        (required_len < mxak_cache_dir_entry +
        sizeof (tgg00_FileId) + sizeof (tgg00_StackDesc))
    THEN
        required_len := mxak_cache_dir_entry +
              sizeof (tgg00_FileId) + sizeof (tgg00_StackDesc);
    (*ENDIF*) 
    ak10getmem (acv, cak_is_undefined,
          required_len, block_addr[1].buf_ptr);
    IF  block_addr[1].buf_ptr <> NIL
    THEN
        BEGIN
        block_cnt               := 1;
        out_mblock.mb_qual_size := in_mblock.mb_qual_len;
        out_mblock.mb_qual      :=
              @block_addr[block_cnt].cdir_ptr^.cd_sysinfo;
        block_addr[1].cdir_ptr^.cd_mem_type := dyn_mess_block_part;
        IF  stack_length > 0
        THEN
            BEGIN
            required_len := mxak_cache_dir_entry + stack_length;
            ak10getmem (acv, cak_is_undefined, required_len,
                  block_addr[block_cnt + 1].buf_ptr);
            IF  block_addr[block_cnt + 1].buf_ptr <> NIL
            THEN
                BEGIN
                block_cnt        := block_cnt + 1;
                out_mblock.mb_st :=
                      @block_addr[block_cnt].cdir_ptr^.cd_sysinfo;
                out_mblock.mb_qual^.mst_addr := out_mblock.mb_st;
                out_mblock.mb_st_size :=
                      required_len - mxak_cache_dir_entry;
                out_mblock.mb_st_max  :=
                      out_mblock.mb_st_size DIV sizeof (tgg00_StackEntry);
                block_addr[block_cnt].cdir_ptr^.cd_mem_type := dyn_mess_block_part;
                END
            ELSE
                ak10no_more_memory (acv, b_err)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        ak10no_more_memory (acv, b_err)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (in_mblock.mb_data_len > 0) AND (b_err = e_ok)
THEN
    BEGIN
    required_len := mxak_cache_dir_entry + in_mblock.mb_data_len;
    ak10getmem (acv, cak_is_undefined,
          required_len, block_addr[block_cnt + 1].buf_ptr);
    IF  block_addr[block_cnt + 1].buf_ptr <> NIL
    THEN
        BEGIN
        block_cnt               := block_cnt + 1;
        out_mblock.mb_data_size := in_mblock.mb_data_len;
        out_mblock.mb_data      :=
              @block_addr[block_cnt].cdir_ptr^.cd_sysinfo;
        block_addr[block_cnt].cdir_ptr^.cd_mem_type := dyn_mess_block_part;
        END
    ELSE
        ak10no_more_memory (acv, b_err);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (in_mblock.mb_strat_len > 0) AND (b_err = e_ok)
THEN
    BEGIN
    required_len := mxak_cache_dir_entry + in_mblock.mb_strat_len;
    ak10getmem (acv, cak_is_undefined,
          required_len, block_addr[block_cnt + 1].buf_ptr);
    IF  block_addr[block_cnt + 1].buf_ptr <> NIL
    THEN
        BEGIN
        block_cnt                := block_cnt + 1;
        out_mblock.mb_strat_size := in_mblock.mb_strat_len;
        out_mblock.mb_strat      :=
              @block_addr[block_cnt].cdir_ptr^.cd_sysinfo;
        block_addr[block_cnt].cdir_ptr^.cd_mem_type := dyn_mess_block_part;
        END
    ELSE
        ak10no_more_memory (acv, b_err);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  b_err <> e_ok
THEN
    BEGIN
    out_mblock.mb_qual_size  := 0;
    out_mblock.mb_data_size  := 0;
    out_mblock.mb_strat_size := 0;
    out_mblock.mb_st_size    := 0;
    out_mblock.mb_data       := NIL;
    out_mblock.mb_qual       := NIL;
    out_mblock.mb_strat      := NIL;
    out_mblock.mb_st         := NIL;
    FOR ix := 1 TO block_cnt DO
        ak10block_into_freelist (acv, block_addr[ix],
              NOT c_del_in_directory, c_del_dependecies);
    (*ENDFOR*) 
    END;
&ifdef trace
(*ENDIF*) 
t01int4 (ak_cach, 'mb_qual_size', out_mblock.mb_qual_size);
t01int4 (ak_cach, 'mb_data_size', out_mblock.mb_data_size);
t01int4 (ak_cach, 'mb_strat_siz', out_mblock.mb_strat_size);
t01int4 (ak_cach, 'mb_st_size  ', out_mblock.mb_st_size);
IF  out_mblock.mb_data <> NIL
THEN
    t01addr (ak_cach, 'mb_data     ', @out_mblock.mb_data^);
(*ENDIF*) 
IF  out_mblock.mb_qual <> NIL
THEN
    t01addr (ak_cach, 'mb_qual     ', @out_mblock.mb_qual^);
(*ENDIF*) 
IF  out_mblock.mb_st <> NIL
THEN
    t01addr (ak_cach, 'mb_st       ', @out_mblock.mb_st^);
(*ENDIF*) 
IF  out_mblock.mb_strat <> NIL
THEN
    t01addr (ak_cach, 'mb_strat    ', @out_mblock.mb_strat^);
&endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10store_record_suffix (
            VAR acv     : tak_all_command_glob;
            VAR sysinfo : tak_systembuffer;
            do_add      : boolean;
            rest_len    : integer;
            VAR b_err   : tgg00_BasisError);
 
VAR
      move_len : integer;
      pos      : integer;
      rec      : tsp00_Buf;
      rec_ptr  : tak_sysbufferaddress;
 
BEGIN
&ifdef trace
t01buf (ak_cach, sysinfo, 1, sysinfo.b_sl);
&endif
rec_ptr                 := @rec;
sysinfo.b_sl            := sysinfo.b_sl + rest_len;
rec_ptr^.syskey         := sysinfo.syskey;
rec_ptr^.syskey.skeylen := rec_ptr^.syskey.skeylen + 1;
rec_ptr^.syskey.all[rec_ptr^.syskey.skeylen] := chr(0);
pos := MAX_RECLEN_GG00 + 1;
WHILE (rest_len > 0) AND (b_err = e_ok) DO
    BEGIN
    rec_ptr^.syskey.all[rec_ptr^.syskey.skeylen] :=
          succ (rec_ptr^.syskey.all[rec_ptr^.syskey.skeylen]);
    IF  cgg_rec_key_offset + rec_ptr^.syskey.skeylen + rest_len >
        MAX_RECLEN_GG00
    THEN
        move_len := MAX_RECLEN_GG00 -
              rec_ptr^.syskey.skeylen - cgg_rec_key_offset
    ELSE
        move_len := rest_len;
    (*ENDIF*) 
    rec_ptr^.b_sl := cgg_rec_key_offset +
          rec_ptr^.syskey.skeylen + move_len;
    SAPDB_PascalMove ('VAK10 ',  38,    
          sizeof(sysinfo), sizeof (rec), @sysinfo, pos,
          @rec_ptr^, cgg_rec_key_offset + rec_ptr^.syskey.skeylen + 1,
          move_len, b_err);
    IF  b_err = e_ok
    THEN
        BEGIN
        IF  do_add
        THEN
            b07cadd_record (acv.a_transinf.tri_trans,
                  acv.a_pars_curr, rec_ptr^)
        ELSE
            b07crepl_record (acv.a_transinf.tri_trans,
                  acv.a_pars_curr, rec_ptr^);
        (*ENDIF*) 
        b_err    := acv.a_transinf.tri_trans.trError_gg00;
        acv.a_transinf.tri_trans.trError_gg00 := e_ok;
        rest_len := rest_len - move_len;
        pos      := pos + move_len
        END
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10store_mess_block (
            VAR acv        : tak_all_command_glob;
            VAR mblock_rec : tak_messblock_record;
            do_add         : boolean;
            VAR b_err      : tgg00_BasisError);
 
VAR
      m_type      : tgg00_MessType;
      move_len    : integer;
      part_cnt    : integer;
      ix          : integer;
      part_pos    : integer;
      cnt         : integer;
      rec_buf     : tgg00_Rec;
      rec_ptr     : tak_sysbufferaddress;
      mblock_ptr  : tak_sysbufferaddress;
      sysk        : tgg00_SysInfoKey;
      mblock_info : tak10_mblock_info;
 
BEGIN
&ifdef trace
t01messblock (ak_cach, 'ak10store_me', mblock_rec.mbr_mess_block);
&endif
mblock_rec.mbr_reclen := mblock_rec.mbr_reclen -
      sizeof (mblock_rec.mbr_mess_block.mb_trailer);
mblock_ptr := @mblock_rec;
mblock_rec.mbr_fieldSequenceInfo := [];
IF  mblock_rec.mbr_mess_block.mb_fieldlists[cgg_idx_literal_valuefieldlist] <> NIL
THEN
    mblock_rec.mbr_fieldSequenceInfo := mblock_rec.mbr_fieldSequenceInfo + [mfs_literals];
(*ENDIF*) 
IF  mblock_rec.mbr_mess_block.mb_fieldlists[cgg_idx_param_valuefieldlist] <> NIL
THEN
    mblock_rec.mbr_fieldSequenceInfo := mblock_rec.mbr_fieldSequenceInfo + [mfs_parameters];
(*ENDIF*) 
IF  mblock_rec.mbr_mess_block.mb_fieldlists[cgg_idx_pars_result_valuefieldlist] <> NIL
THEN
    mblock_rec.mbr_fieldSequenceInfo := mblock_rec.mbr_fieldSequenceInfo + [mfs_pars_result];
(*ENDIF*) 
IF  mblock_rec.mbr_mess_block.mb_fieldlists[cgg_idx_ex_result_valuefieldlist] <> NIL
THEN
    mblock_rec.mbr_fieldSequenceInfo := mblock_rec.mbr_fieldSequenceInfo + [mfs_ex_result];
(*ENDIF*) 
IF  mblock_rec.mbr_entrytype = cak_epermmessblock
THEN
    BEGIN
    IF  do_add
    THEN
        m_type := m_insert
    ELSE
        m_type := m_update_rec;
    (*ENDIF*) 
    ak10send_ins_upd (acv, @mblock_rec, m_type, b_err)
    END
ELSE
    BEGIN
    IF  do_add
    THEN
        b07cadd_record (acv.a_transinf.tri_trans,
              acv.a_pars_curr, mblock_ptr^)
    ELSE
        b07crepl_record (acv.a_transinf.tri_trans,
              acv.a_pars_curr, mblock_ptr^);
    (*ENDIF*) 
    b_err := acv.a_transinf.tri_trans.trError_gg00;
    acv.a_transinf.tri_trans.trError_gg00 := e_ok
    END;
(*ENDIF*) 
mblock_rec.mbr_reclen := mblock_rec.mbr_reclen +
      sizeof (mblock_rec.mbr_mess_block.mb_trailer);
rec_ptr                 := @rec_buf;
rec_ptr^.syskey         := mblock_ptr^.syskey;
rec_ptr^.syskey.skeylen := rec_ptr^.syskey.skeylen + 1;
rec_ptr^.syskey.all[rec_ptr^.syskey.skeylen] := chr(1);
ak10fill_mblock_info (mblock_rec, mblock_info, part_cnt);
ix          := 1;
cnt         := 1;
rec_buf.len := cgg_rec_key_offset + rec_ptr^.syskey.skeylen;
WHILE (b_err = e_ok) AND (ix <= part_cnt) DO
    BEGIN
    part_pos := 1;
    REPEAT
        move_len := mblock_info[ix].len - part_pos + 1;
        IF  rec_buf.len + move_len > MAX_RECLEN_GG00
        THEN
            move_len := MAX_RECLEN_GG00 - rec_buf.len;
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK10 ',  39,    
              mblock_info[ix].size, sizeof (rec_buf),
              @mblock_info[ix].addr^, part_pos,
              @rec_buf.buf, rec_buf.len + 1, move_len, b_err);
        rec_buf.len := rec_buf.len + move_len;
        part_pos    := part_pos + move_len;
        IF  b_err = e_ok
        THEN
            IF  (rec_buf.len = MAX_RECLEN_GG00) OR
                ((ix = part_cnt) AND (part_pos > mblock_info[ix].len))
            THEN
                BEGIN
                IF  mblock_rec.mbr_entrytype = cak_epermmessblock
                THEN
                    ak10send_ins_upd (acv,
                          @rec_ptr^, m_type, b_err)
                ELSE
                    BEGIN
                    IF  do_add
                    THEN
                        b07cadd_record (acv.a_transinf.tri_trans,
                              acv.a_pars_curr, rec_ptr^)
                    ELSE
                        b07crepl_record (acv.a_transinf.tri_trans,
                              acv.a_pars_curr, rec_ptr^);
                    (*ENDIF*) 
                    b_err := acv.a_transinf.tri_trans.trError_gg00;
                    acv.a_transinf.tri_trans.trError_gg00 := e_ok
                    END;
                (*ENDIF*) 
                rec_buf.len := cgg_rec_key_offset + rec_ptr^.syskey.skeylen;
                cnt         := cnt + 1;
                rec_buf.buf[rec_buf.len] := chr(cnt);
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    UNTIL
        (part_pos > mblock_info[ix].len) OR (b_err <> e_ok);
    (*ENDREPEAT*) 
    ix := ix + 1;
    END;
(*ENDWHILE*) 
IF  b_err = e_ok
THEN
    BEGIN
    sysk                   := mblock_ptr^.syskey;
    sysk.skeylen           := sysk.skeylen + 1;
    sysk.all[sysk.skeylen] := chr(cnt);
    cnt := cnt + a103StoreMessBlockFieldSequences (acv,
          sysk, mblock_rec.mbr_mess_block, ord(mblock_rec.mbr_recCount));
    END;
(*ENDIF*) 
IF  (b_err <> e_ok)
    AND
    (mblock_rec.mbr_entrytype[2] in [cak_cmessblock, cak_ctriggerparsinfo])
THEN
    BEGIN
    sysk := mblock_ptr^.syskey;
    b07cdel_record (acv.a_transinf.tri_trans,
          acv.a_pars_curr, sysk);
    sysk.skeylen := sysk.skeylen + 1;
    FOR ix := 1 TO cnt DO
        BEGIN
        sysk.all[sysk.skeylen] := chr(ix);
        b07cdel_record (acv.a_transinf.tri_trans,
              acv.a_pars_curr, sysk)
        END;
    (*ENDFOR*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10store_syskey (
            VAR acv    : tak_all_command_glob;
            VAR syskey : tgg00_SysInfoKey);
 
BEGIN
acv.a_error_key_ptr^.syskey.skeylen := syskey.skeylen;
SAPDB_PascalForcedMove (sizeof (tgg00_SysInfoKey), sizeof (tgg00_SysInfoKey),
      @syskey, cgg_rec_key_offset + 1,
      @acv.a_error_key_ptr^.syskey, cgg_rec_key_offset + 1,
      syskey.skeylen)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10table_cache_delete (
            VAR acv : tak_all_command_glob;
            VAR tableid : tgg00_Surrogate;
            flush_tmp   : boolean);
 
VAR
      nothing_found : boolean;
      res           : tsp00_LcompResult;
      loop_cnt      : integer;
      p             : tak_cache_dir_pointer;
      syskey        : tgg00_SysInfoKey;
      pKey          : tak10_SysKeyPointer;
 
BEGIN
syskey.stableid := tableid;
loop_cnt        := 0;
REPEAT
    loop_cnt := loop_cnt + 1;
    REPEAT
        nothing_found := true;
        p := acv.a_sysdir.ci_dir[ loop_cnt ];
        WHILE p.cdir_ptr <> NIL DO
            BEGIN
            IF  p.cdir_ptr^.cd_check <> cak_cache_chunk_flag
            THEN
                BEGIN
                ak10cache_error (acv, 'a10table_cache_delete   ', p);
                p.cdir_ptr := NIL;
                loop_cnt   := cak_emax
                END
            ELSE
                BEGIN
                IF  dreference in p.cdir_ptr^.cd_state
                THEN
                    pKey := ak10GlobalCacheGetKeyPointer(p)
                ELSE
                    pKey := @p.cdir_ptr^.cd_syskey;
                (*ENDIF*) 
                s30cmp (syskey, cgg_rec_key_offset+1, SURROGATE_MXGG00,
                      pKey^, cgg_rec_key_offset+1, SURROGATE_MXGG00, res);
                IF  (res = l_equal) AND
                    (p.cdir_ptr^.cd_refCount = 0) AND
                    NOT a101_IsStatementActive(acv, p.cdir_ptr^.cd_cmd_no)
                THEN
                    BEGIN
&                   ifdef trace
                    t01buf1 (ak_cach, pKey^, cgg_rec_key_offset+1,
                          pKey^.skeylen + cgg_rec_key_offset);
&                   endif
                    IF  flush_tmp
                    THEN
                        ak10temp_add (acv, p, NOT c_is_rollback);
                    (*ENDIF*) 
                    ak10block_into_freelist (acv,
                          p, c_del_in_directory, c_del_dependecies);
                    nothing_found := false;
                    p.cdir_ptr    := NIL
                    END
                ELSE
                    IF  res = l_less
                    THEN
                        p := p.cdir_ptr^.cd_less
                    ELSE
                        p := p.cdir_ptr^.cd_greater
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
    UNTIL
        nothing_found;
    (*ENDREPEAT*) 
UNTIL
    loop_cnt >= cak_emax;
(*ENDREPEAT*) 
&ifdef TRACE
ak10verify_cache (acv)
&     endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10temp_add  (
            VAR acv     : tak_all_command_glob;
            ptr         : tak_cache_dir_pointer;
            is_rollback : boolean);
 
CONST
      do_add = true;
      do_upd = false;
 
VAR
      b_err         : tgg00_BasisError;
      is_object     : boolean;
      aux_len       : integer;
      rest_len      : tsp00_Int4;
      full_len      : tsp00_Int4;
 
BEGIN
WITH ptr.cdir_ptr^ DO
    BEGIN
&   ifdef TRACE
    xtd_directory (ak_cach, ptr);
&   endif
    IF  NOT (dreference in cd_state)
        AND
        (cd_syskey.sentrytyp > cak_etemp)
    THEN
        BEGIN
        b_err         := e_ok;
        rest_len      := 0;
        is_object     := false;
        WITH ptr.cdir_ptr^.cd_sysinfo DO
            CASE cd_syskey.sentrytyp[2] OF
                cak_cjparsinfo, cak_cparsinfo, cak_cshortinfo,
                cak_creskey, cak_clinkpos, cak_clongliteral :
                    BEGIN
                    full_len := sparsinfo.p_fullen;
                    IF  full_len > MAX_RECLEN_GG00
                    THEN
                        BEGIN
                        b_sl     := MAX_RECLEN_GG00;
                        rest_len := full_len - MAX_RECLEN_GG00
                        END
                    ELSE
                        b_sl := full_len
                    (*ENDIF*) 
                    END;
                cak_ccolnames :
                    is_object := true;
                cak_cresult :
                    is_object := true;
                cak_cmessblock, cak_ctriggerparsinfo :
                    is_object := true;
                OTHERWISE ;
                END;
            (*ENDCASE*) 
        (*ENDWITH*) 
        IF  dmodified in cd_state
        THEN
            BEGIN
            IF  NOT is_object
            THEN
                BEGIN
                b07crepl_record (acv.a_transinf.tri_trans,
                      acv.a_pars_curr, cd_sysinfo);
                IF  acv.a_transinf.tri_trans.trError_gg00 = e_key_not_found
                THEN
                    b_err := e_ok
                ELSE
                    b_err := acv.a_transinf.tri_trans.trError_gg00;
                (*ENDIF*) 
                acv.a_transinf.tri_trans.trError_gg00 := e_ok;
                IF  rest_len > 0
                THEN
                    ak10store_record_suffix (acv,
                          ptr.cdir_ptr^.cd_sysinfo,
                          do_upd, rest_len, b_err)
                (*ENDIF*) 
                END
            ELSE
                CASE cd_syskey.sentrytyp[2] OF
                    cak_cmessblock, cak_ctriggerparsinfo :
                        ak10store_mess_block (acv,
                              ptr.cdir_ptr^.cd_sysinfo.smessblock,
                              do_upd, b_err);
                    cak_cresult :
                        ak10add_base_record (acv,
                              @cd_sysinfo, NOT c_via_kb,
                              m_update_rec, b_err);
                    cak_ccolnames :
                        ak10store_colnames_record (acv, @cd_sysinfo,
                              m_update_rec, b_err);
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
            END
        ELSE
            IF  dadd_rec in cd_state
            THEN
                BEGIN
                cd_state := cd_state + [ dwritten ] - [ dadd_rec ];
                IF  NOT is_object
                THEN
                    BEGIN
                    b07cadd_record (acv.a_transinf.tri_trans,
                          acv.a_pars_curr, cd_sysinfo);
                    IF  acv.a_transinf.tri_trans.trError_gg00 = e_duplicate_key
                    THEN
                        BEGIN
                        b_err := e_duplicate_sysinfo;
                        ak10store_syskey (acv, cd_syskey)
                        END
                    ELSE
                        b_err := acv.a_transinf.tri_trans.trError_gg00;
                    (*ENDIF*) 
                    acv.a_transinf.tri_trans.trError_gg00 := e_ok;
                    IF  rest_len > 0
                    THEN
                        ak10store_record_suffix (acv,
                              ptr.cdir_ptr^.cd_sysinfo, do_add,
                              rest_len, b_err);
                    (*ENDIF*) 
                    END
                ELSE
                    CASE  cd_syskey.sentrytyp[2] OF
                        cak_cmessblock, cak_ctriggerparsinfo :
                            ak10store_mess_block (acv,
                                  ptr.cdir_ptr^.cd_sysinfo.smessblock,
                                  do_add, b_err);
                        cak_cresult :
                            ak10add_base_record (acv,
                                  @cd_sysinfo, NOT c_via_kb, m_insert, b_err);
                        cak_ccolnames :
                            ak10store_colnames_record (acv, @cd_sysinfo,
                                  m_insert, b_err);
                        END;
                    (*ENDCASE*) 
                (*ENDIF*) 
                IF  (b_err = e_ok) AND
                    (cd_create_cmd_no = acv.a_command_id)
                THEN
                    BEGIN
                    IF  acv.a_sysdir.ci_cmd_rollback_tree.fileRoot_gg00 =
                        NIL_PAGE_NO_GG00
                    THEN
                        BEGIN
                        WITH acv.a_sysdir, ci_cmd_rollback_tree DO
                            BEGIN
                            g04build_temp_tree_id (ci_cmd_rollback_tree,
                                  acv.a_transinf.tri_trans);
                            a101_SetTempFileIndex (acv, ci_cmd_rollback_tree,
                                  acv.a_command_id);
                            END;
                        (*ENDWITH*) 
                        a101_ResetGroupedTempFile (acv.a_transinf.tri_trans,
                              acv.a_sysdir.ci_cmd_rollback_tree,
                              ttfnCacheRollback_egg00);
                        acv.a_sysdir.ci_rollbackFileExists := true;
                        END;
                    (*ENDIF*) 
                    IF  acv.a_transinf.tri_trans.trError_gg00 = e_ok
                    THEN
                        BEGIN
                        aux_len := cd_sysinfo.b_sl;
                        cd_sysinfo.b_sl :=
                              cgg_rec_key_offset + cd_sysinfo.b_kl;
                        b07cadd_record (acv.a_transinf.tri_trans,
                              acv.a_sysdir.ci_cmd_rollback_tree, cd_sysinfo);
                        cd_sysinfo.b_sl := aux_len;
                        IF  acv.a_transinf.tri_trans.trError_gg00 =
                            e_duplicate_key
                        THEN
                            acv.a_transinf.tri_trans.trError_gg00 := e_ok
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    b_err := acv.a_transinf.tri_trans.trError_gg00;
                    acv.a_transinf.tri_trans.trError_gg00 := e_ok
                    END;
                (*ENDIF*) 
                END
            ELSE
                IF  NOT (dreference in cd_state) AND
                    (cd_syskey.sauthid = acv.a_shortinfo_key)
                THEN
                    acv.a_shortinfo_key := cgg_zero_id;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (b_err <> e_ok) AND NOT is_rollback
        THEN
            a07_b_put_error (acv, b_err, 1);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10synonym_record (
            VAR rec  : tgg00_Rec;
            syspoint : tak_sysbufferaddress;
            VAR e    : tgg00_BasisError);
 
VAR
      pos : integer;
 
BEGIN
pos := sizeof (tak_synonymrecord) -
      sizeof (syspoint^.ssynonym.syn_tablen) + 1;
WITH syspoint^.ssynonym DO
    BEGIN
    syspoint^.b_sl := syspoint^.b_sl + sizeof(syn_tablen) - (ord (rec.buf[pos]) + 1);
    syn_tablen := a01_il_b_identifier;
    SAPDB_PascalMove ('VAK10 ',  40,    
          sizeof (rec.buf), sizeof (syn_tablen), @rec.buf, pos + 1,
          @syn_tablen, 1, ord (rec.buf[pos]), e);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10tdcheck_order (p : tak_cache_dir_pointer);
 
VAR
      res : tsp00_LcompResult;
 
BEGIN
IF  p.cdir_ptr <> NIL
THEN
    WITH p.cdir_ptr^ DO
        BEGIN
        IF  (cd_lru_next.cdir_ptr = NIL) OR
            (cd_lru_prev.cdir_ptr = NIL)
        THEN
            BEGIN
&           ifdef trace
            t01str30 (td_always, 'dir entry not in lru          ');
            xtd_directory (td_always, p);
&           endif
            g01abort (csp3_a10_cache_wrong_lru,
                  csp3_n_akcache, msg_wrong_lru, 0)
            END;
        (*ENDIF*) 
        IF  cd_less.cdir_ptr <> NIL
        THEN
            BEGIN
            s30cmp (cd_less.cdir_ptr^.cd_syskey, cgg_rec_key_offset+1,
                  cd_less.cdir_ptr^.cd_syskey.skeylen,
                  cd_syskey, cgg_rec_key_offset+1, cd_syskey.skeylen, res);
            IF  res <> l_less
            THEN
                BEGIN
&               ifdef trace
                t01str30 (td_always, 'ordering destroyed : less     ');
                xtd_directory (td_always, p);
                xtd_directory (td_always, cd_less);
&               endif
                g01abort (csp3_a10_cache_wrong_less,
                      csp3_n_akcache, msg_wrong_less, 0)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  cd_greater.cdir_ptr <> NIL
        THEN
            BEGIN
            s30cmp (cd_greater.cdir_ptr^.cd_syskey, cgg_rec_key_offset+1,
                  cd_greater.cdir_ptr^.cd_syskey.skeylen,
                  cd_syskey, cgg_rec_key_offset+1, cd_syskey.skeylen, res);
            IF  res <> l_greater
            THEN
                BEGIN
&               ifdef trace
                t01str30 (td_always, 'ordering destroyed : greater  ');
                xtd_directory (td_always, p);
                xtd_directory (td_always, cd_greater);
&               endif
                g01abort (csp3_a10_cache_wrong_greater,
                      csp3_n_akcache, msg_wrong_greater, 0)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ak10tdcheck_order (cd_less);
        ak10tdcheck_order (cd_greater);
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10writeln (p : tak_cache_dir_pointer);
 
VAR
      ix     : integer;
      max    : integer;
      ln_len : integer;
      pKey   : tak10_SysKeyPointer;
      msg    : tsp00_C40;
 
      i4c4   : RECORD
            CASE boolean OF
                true :
                    (i4 : tsp00_Int4);
                false :
                    (c4 : tsp00_C4);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH p.cdir_ptr^ DO
    BEGIN
    FOR ix := 1 TO sizeof (msg) DO
        msg[ix] := bsp_c1;
    (*ENDFOR*) 
    ln_len := 0;
    IF  dreference in p.cdir_ptr^.cd_state
    THEN
        pKey := ak10GlobalCacheGetKeyPointer(p)
    ELSE
        pKey := @p.cdir_ptr^.cd_syskey;
    (*ENDIF*) 
    IF  pKey^.skeylen > sizeof (msg)
    THEN
        max := sizeof (msg)
    ELSE
        max := pKey^.skeylen;
    (*ENDIF*) 
    FOR ix := 1 TO max DO
        IF  ix < sizeof (msg) DIV 2
        THEN
            g17hexto_line (pKey^.all[ix], ln_len, msg);
        (*ENDIF*) 
    (*ENDFOR*) 
    g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_dump,
          csp3_n_akcache, msg);
    msg     := 'cd_pos :                                ';
    i4c4.i4 := cd_pos;
    ln_len  := 9;
    FOR ix := 1 TO sizeof (i4c4.c4) DO
        g17hexto_line (i4c4.c4[ix], ln_len, msg);
    (*ENDFOR*) 
    g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_dump,
          csp3_n_akcache, msg);
    msg     := 'cd_less :                               ';
    i4c4.i4 := cd_less.i;
    ln_len  := 10;
    FOR ix := 1 TO sizeof (i4c4.c4) DO
        g17hexto_line (i4c4.c4[ix], ln_len, msg);
    (*ENDFOR*) 
    g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_dump,
          csp3_n_akcache, msg);
    msg     := 'cd_greater :                            ';
    i4c4.i4 := cd_greater.i;
    ln_len  := 13;
    FOR ix := 1 TO sizeof (i4c4.c4) DO
        g17hexto_line (i4c4.c4[ix], ln_len, msg);
    (*ENDFOR*) 
    g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_dump,
          csp3_n_akcache, msg);
    IF  cd_check <> cak_cache_chunk_flag
    THEN
        g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_dump,
              csp3_n_akcache, 'cd_check destroyed!!!                   ')
    (*ENDIF*) 
    END;
(*ENDWITH*) 
g01optextmsg (sp3p_console, sp3m_info, csp3_a10_cache_dump,
      csp3_n_akcache, '----------------------------------------')
END;
 
&ifdef trace
(*------------------------------*) 
 
PROCEDURE
      a10verify_cache (
            VAR acv : tak_all_command_glob);
 
BEGIN
ak10verify_cache (acv)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10verify_cache (
            VAR acv : tak_all_command_glob);
 
CONST
      c_max_stack = 500;
 
VAR
      exit_loop : boolean;
      found     : boolean;
      ix        : integer;
      hight     : integer;
      abort     : boolean;
      lru       : tak_cache_dir_pointer;
      curr      : tak_cache_dir_pointer;
      next      : tak_cache_dir_pointer;
      prev      : tak_cache_dir_pointer;
      err_p     : tak_cache_dir_pointer;
      p         : tak_cache_dir_pointer;
      descr     : tsp00_C24;
      bcp       : tak_basecolinfo_ptr;
      mblock_ptr: tgg00_MessBlockPtr;
 
      ap_ptr : RECORD
            CASE boolean OF
                true :
                    (ap : tak_ap_max_tree_ptr);
                false :
                    (cdir : tak_cache_dir_e_ptr);
                END;
            (*ENDCASE*) 
 
 
      pa             : ARRAY[1..4] OF RECORD
            CASE integer OF
                1 :
                    (buf_ptr  : tsp00_BufAddr);
                2 :
                    (qual_ptr : tgg00_QualBufPtr);
                3 :
                    (cd_ptr   : tak_cache_dir_pointer);
                4 :
                    (data_ptr : tgg00_DataPartPtr);
                5 :
                    (st_ptr   : tgg00_StackListPtr);
                6 :
                    (strat_ptr: tsp00_MoveObjPtr);
                END;
            (*ENDCASE*) 
 
      ptr_stack : ARRAY[1..c_max_stack] OF tak_cache_dir_pointer;
      stack_top : integer;
 
BEGIN
&ifdef verify
WITH acv, a_sysdir DO
    BEGIN
    prev           := ci_cache_dir_header;
    lru            := ci_cache_dir_header.cdir_ptr^.cd_lru_next;
    exit_loop      := false;
    err_p.cdir_ptr := NIL;
    descr          := 'VERIFY FAILED           ';
    stack_top      := 0;
    REPEAT
        FOR ix := 1 TO stack_top DO
            IF  ptr_stack[ix].cdir_ptr = lru.cdir_ptr
            THEN
                g01abort (csp3_a10_cache_verify, csp3_n_akcache,
                      descr, 0);
            (*ENDIF*) 
        (*ENDFOR*) 
        IF  stack_top < c_max_stack
        THEN
            BEGIN
            (*t01int4 (td_always, 'push stack  ', lru.cdir_ptr^.cd_pos);*)
            stack_top            := stack_top + 1;
            ptr_stack[stack_top] := lru;
            END;
        (*ENDIF*) 
        IF  lru.cdir_ptr^.cd_check <> cak_cache_chunk_flag
        THEN
            BEGIN
            err_p     := lru;
            exit_loop := true
            END
        ELSE
            BEGIN
            IF  lru.cdir_ptr^.cd_syskey.sentrytyp[2] in [cak_ctable, cak_cresult]
            THEN
                IF  (lru.cdir_ptr^.cd_sysinfo.sbase.btablekind <> tsynonym) AND
                    (lru.cdir_ptr^.cd_sysinfo.b_sl >=
                    sizeof (tak_baserecord) - sizeof (lru.cdir_ptr^.cd_sysinfo.sbase.bcolumn))
                THEN
                    BEGIN
                    bcp := lru.cdir_ptr^.cd_sysinfo.sbase.bptr;
                    WHILE bcp <> NIL DO
                        BEGIN
                        curr.sys_ptr := @bcp^;
                        curr.buf_ptr := s35add_bufaddr_ptocm (curr.buf_ptr, - mxak_cache_dir_entry);
                        IF  curr.cdir_ptr^.cd_check <> cak_cache_chunk_flag
                        THEN
                            BEGIN
                            descr     := 'colinfo destroyed       ';
                            err_p     := curr;
                            exit_loop := true;
                            bcp       := NIL
                            END
                        ELSE
                            bcp := bcp^.bci_next;
                        (*ENDIF*) 
                        END;
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  lru.cdir_ptr^.cd_syskey.sentrytyp[2] in
                [cak_cmessblock, cak_cpermmessblock, cak_ctriggerparsinfo]
            THEN
                BEGIN
                mblock_ptr    :=
                      @lru.cdir_ptr^.cd_sysinfo.smessblock.mbr_mess_block;
                pa[1].qual_ptr := mblock_ptr^.mb_qual;
                pa[2].data_ptr := mblock_ptr^.mb_data;
                pa[3].st_ptr   := mblock_ptr^.mb_st;
                pa[4].strat_ptr:= mblock_ptr^.mb_strat;
                FOR ix := 1 TO 4 DO
                    IF  pa[ix].buf_ptr <> NIL
                    THEN
                        BEGIN
                        pa[ix].buf_ptr :=
                              s35add_bufaddr_ptocm (pa[ix].buf_ptr,
                              - mxak_cache_dir_entry);
                        IF  pa[ix].cd_ptr.cdir_ptr^.cd_check <> cak_cache_chunk_flag
                        THEN
                            BEGIN
                            err_p     := lru;
                            exit_loop := true
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDFOR*) 
                END;
            (*ENDIF*) 
            IF  a102PtrOK (acv, lru)
            THEN
                IF  lru.buf_ptr = ci_cache_dir_trailor.buf_ptr
                THEN
                    exit_loop := true
                ELSE
                    BEGIN
                    IF  NOT a102PtrOK (acv, lru.cdir_ptr^.cd_less)
                    THEN
                        err_p := lru.cdir_ptr^.cd_less
                    ELSE
                        IF  NOT a102PtrOK (acv, lru.cdir_ptr^.cd_greater)
                        THEN
                            err_p := lru.cdir_ptr^.cd_greater
                        ELSE
                            err_p.cdir_ptr := NIL;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  err_p.cdir_ptr <> NIL
                    THEN
                        BEGIN
                        descr := 'wrong pointer found     ';
                        ak10writeln (lru);
                        IF  prev.cdir_ptr <> ci_cache_dir_header.cdir_ptr
                        THEN
                            ak10writeln (prev);
                        (*ENDIF*) 
                        exit_loop := true
                        END;
                    (*ENDIF*) 
                    prev := lru;
                    lru  := lru.cdir_ptr^.cd_lru_next
                    END
                (*ENDIF*) 
            ELSE
                BEGIN
                descr     := 'wrong lru found         ';
                err_p     := lru;
                exit_loop := true;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT exit_loop
        THEN
            BEGIN (* check, if current block overlaps with free block *)
            p  := acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_next_free;
            WHILE p.cdir_ptr <> NIL DO
                WITH p.cdir_ptr^ DO
                    BEGIN
                    IF  (cd_buf_no = prev.cdir_ptr^.cd_buf_no) AND
                        (cd_block_pos + cd_syslen >
                        prev.cdir_ptr^.cd_block_pos) AND
                        (cd_block_pos <
                        prev.cdir_ptr^.cd_block_pos + prev.cdir_ptr^.cd_syslen)
                    THEN
                        BEGIN
                        t01int4 (td_always, 'free bl pos ', cd_block_pos);
                        t01int4 (td_always, 'free bl len ', cd_syslen);
                        t01int4 (td_always, 'used bl pos ',
                              prev.cdir_ptr^.cd_block_pos);
                        t01int4 (td_always, 'used bl len ',
                              prev.cdir_ptr^.cd_syslen);
                        descr := 'Overlapping free and use';
                        g01abort (csp3_a10_cache_verify, csp3_n_akcache,
                              descr, 0)
                        END
                    ELSE
                        p := cd_next_free
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
    UNTIL
        exit_loop;
    (*ENDREPEAT*) 
    IF  err_p.cdir_ptr <> NIL
    THEN
        BEGIN
        lru := ci_cache_dir_header.cdir_ptr^.cd_lru_next;
        WHILE lru.buf_ptr <> ci_cache_dir_trailor.buf_ptr DO
            BEGIN
            ak10writeln (lru);
            lru  := lru.cdir_ptr^.cd_lru_next
            END;
        (*ENDWHILE*) 
        g01abort (csp3_a10_cache_verify, csp3_n_akcache,
              descr, 0)
        END;
    (*ENDIF*) 
    next   := ci_cache_dir_trailor.cdir_ptr^.cd_fix_prev;
    WHILE (next.cdir_ptr <> ci_cache_dir_header.cdir_ptr) DO
        BEGIN
        IF  next.cdir_ptr^.cd_check <> cak_cache_chunk_flag
        THEN
            BEGIN
            ak10cache_error (acv, 'a10all_release          ', next);
            next := ci_cache_dir_header
            END
        ELSE
            BEGIN
            (* check, if block is in lru *)
            lru   := ci_cache_dir_header.cdir_ptr^.cd_lru_next;
            found := false;
            WHILE NOT found AND
                  (lru.buf_ptr <> ci_cache_dir_trailor.buf_ptr) DO
                IF  lru.cdir_ptr = next.cdir_ptr
                THEN
                    found := true
                ELSE
                    lru  := lru.cdir_ptr^.cd_lru_next;
                (*ENDIF*) 
            (*ENDWHILE*) 
            IF  NOT found
            THEN
                BEGIN
                xtd_directory (td_always, next);
                descr := 'Fixed not in lru        ';
                g01abort (csp3_a10_cache_verify, csp3_n_akcache,
                      descr, 0)
                END
            ELSE
                next := next.cdir_ptr^.cd_fix_prev
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    descr := 'duplicate p in lru/free ';
    next := ci_cache_dir_header.cdir_ptr^.cd_next_free;
    WHILE next.buf_ptr <> ci_cache_dir_trailor.buf_ptr DO
        BEGIN
        FOR ix := 1 TO stack_top DO
            IF  ptr_stack[ix].cdir_ptr = next.cdir_ptr
            THEN
                BEGIN
                t01int4 (td_always, 'error pos   ', next.cdir_ptr^.cd_pos);
                g01abort (csp3_a10_cache_verify, csp3_n_akcache,
                      descr, 0);
                END;
            (*ENDIF*) 
        (*ENDFOR*) 
        IF  stack_top < c_max_stack
        THEN
            BEGIN
            (*t01int4 (td_always, 'push stack f', next.cdir_ptr^.cd_pos);*)
            stack_top            := stack_top + 1;
            ptr_stack[stack_top] := next;
            END;
        (*ENDIF*) 
        IF  (next.buf_ptr = NIL) OR
            NOT a102PtrOK (acv, next)
        THEN
            BEGIN
            ak10td_freelist (acv, td_always);
            g01abort (csp3_a10_cache_verify, csp3_n_akcache,
                  descr, 0)
            END
        ELSE
            next  := next.cdir_ptr^.cd_next_free
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDWITH*) 
&endif
ak10CacheCheck(acv);
END;
 
&else
(*------------------------------*) 
 
PROCEDURE
      ak10verify_cache (
            VAR acv : tak_all_command_glob);
 
BEGIN
ak10CacheCheck(acv);
END;
 
&endif
&ifdef trace
(*------------------------------*) 
 
PROCEDURE
      td_tree (p : tak_cache_dir_pointer);
 
BEGIN
IF  p.cdir_ptr <> NIL
THEN
    BEGIN
    t01str30 (ak_cach, '========== node ==============');
    xtd_directory (ak_cach, p);
    IF  p.cdir_ptr^.cd_less.cdir_ptr <> NIL
    THEN
        WITH p.cdir_ptr^.cd_less.cdir_ptr^ DO
            BEGIN
            t01str30 (ak_cach, '========== left ==============');
            xtd_directory (ak_cach, p.cdir_ptr^.cd_less);
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  p.cdir_ptr^.cd_greater.cdir_ptr <> NIL
    THEN
        WITH p.cdir_ptr^.cd_greater.cdir_ptr^ DO
            BEGIN
            t01str30 (ak_cach, '========== right =============');
            xtd_directory (ak_cach, p.cdir_ptr^.cd_greater);
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    td_tree (p.cdir_ptr^.cd_less);
    td_tree (p.cdir_ptr^.cd_greater);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10check_tree (p : tak_cache_dir_pointer;
            VAR hight : integer;
            VAR abort : boolean);
 
VAR
      h_left, h_right : integer;
      descr     : tsp00_C24;
 
BEGIN
WITH p.cdir_ptr^  DO
    BEGIN
    IF  cd_check <> cak_cache_chunk_flag
    THEN
        BEGIN
        g01abort (csp3_a10_cache_verify, csp3_n_akcache,
              descr, 0)
        END;
    (*ENDIF*) 
    IF  (cd_lru_next.cdir_ptr = NIL) OR (cd_lru_prev.cdir_ptr = NIL)
    THEN
        BEGIN
        g01abort (csp3_a10_cache_verify, csp3_n_akcache,
              descr, 0)
        END;
    (*ENDIF*) 
    IF  cd_less.cdir_ptr <> NIL
    THEN
        ak10check_tree (cd_less, h_left, abort)
    ELSE
        h_left := 0;
    (*ENDIF*) 
    IF  cd_greater.cdir_ptr <> NIL
    THEN
        ak10check_tree (cd_greater, h_right, abort)
    ELSE
        h_right := 0;
    (*ENDIF*) 
    IF  abs (h_left - h_right) > 1
    THEN
        abort := true;
    (*ENDIF*) 
    IF  h_left > h_right
    THEN
        hight := h_left + 1
    ELSE
        hight := h_right + 1;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10td_dirlist (
            VAR acv : tak_all_command_glob;
            layer     : tgg00_Debug);
 
VAR
      i : integer;
 
BEGIN
t01str30 (layer, '========== directory =========');
FOR i := 1 TO cak_emax DO
    IF  acv.a_sysdir.ci_dir[ i ].cdir_ptr <> NIL
    THEN
        ak10dirlist (layer, acv.a_sysdir.ci_dir[ i ]);
    (*ENDIF*) 
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10dirlist (layer : tgg00_Debug;
            p : tak_cache_dir_pointer);
 
BEGIN
IF  p.cdir_ptr <> NIL
THEN
    BEGIN
    xtd_directory (layer, p);
    ak10dirlist (layer, p.cdir_ptr^.cd_less);
    ak10dirlist (layer, p.cdir_ptr^.cd_greater)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10td_freelist (
            VAR acv : tak_all_command_glob;
            layer     : tgg00_Debug);
 
VAR
      p         : tak_cache_dir_pointer;
      prev      : tak_cache_dir_pointer;
      free_size : tsp00_Int4;
      maxSize   : tsp00_Int4;
 
BEGIN
t01str30 (layer, '========== free list =========');
free_size     := 0;
prev.cdir_ptr := NIL;
p         := acv.a_sysdir.ci_cache_dir_header.cdir_ptr^.cd_next_free;
IF  acv.a_size_ptr = NIL
THEN
    maxSize := g01catalog_cache_init_size
ELSE
    maxSize := acv.a_size_ptr^.csz_ak_cache * sizeof(tsp00_Buf);
(*ENDIF*) 
WHILE (p.cdir_ptr <> NIL) AND (free_size <= maxSize) DO
    WITH p.cdir_ptr^ DO
        BEGIN
        t01p2int4 (layer, 'free bl pos ', cd_block_pos,
              'free bl bno ', cd_buf_no);
        t01p2int4 (layer, '            ', 0,
              'free bl len ', cd_syslen);
        IF  prev.cdir_ptr <> NIL
        THEN
            IF  (prev.cdir_ptr^.cd_block_pos = cd_block_pos) AND
                (prev.cdir_ptr^.cd_buf_no    = cd_buf_no)
            THEN
                ak10cache_error (acv, 'duplicate in free list  ', p);
            (*ENDIF*) 
        (*ENDIF*) 
        free_size := free_size + cd_syslen;
        prev      := p;
        p         := cd_next_free
        END;
    (*ENDWITH*) 
(*ENDWHILE*) 
t01int4 (layer, 'free space  ', free_size)
END;
 
(*------------------------------*) 
 
PROCEDURE
      xtd_directory (layer : tgg00_Debug;
            ptr : tak_cache_dir_pointer);
 
BEGIN
WITH ptr.cdir_ptr^ DO
    BEGIN
    IF  dreference in cd_state
    THEN
        BEGIN
        t01addr (layer, 'handle      ', @cd_ref.cd_globalCacheHandle^);
        t01addr (layer, 'pSysinfo    ', @cd_ref.cd_globalSysinfoPtr^);
        END
    ELSE
        t01buf1 (layer, cd_syskey, cgg_rec_key_offset+1,
              cd_syskey.skeylen + cgg_rec_key_offset);
    (*ENDIF*) 
    t01p2int4 (layer, 'block pos   ', cd_pos,
          'block len   ', cd_syslen);
    t01int4 (layer, 'b_sl        ', cd_sysinfo.b_sl);
    t01int4 (layer, 'buf no      ', cd_buf_no);
    t01int4 (layer, 'balance     ', ord (cd_balance));
    IF  cd_fix_next.cdir_ptr <> NIL
    THEN
        t01int4 (layer, 'fix         ', 1)
    ELSE
        t01int4 (layer, 'not fix     ', 0);
    (*ENDIF*) 
    IF  dwritten in cd_state
    THEN
        t01int4 (layer, 'dwritten    ', 1);
    (*ENDIF*) 
    IF  dadd_rec in cd_state
    THEN
        t01int4 (layer, 'dadd_rec    ', 1);
    (*ENDIF*) 
    IF  dmodified in cd_state
    THEN
        t01int4 (layer, 'dmodified   ', 1);
    (*ENDIF*) 
    t01int4 (layer, 'refCount    ', cd_refCount);
    t01int4 (layer, 'cmd_no      ', cd_cmd_no);
    t01int4 (layer, 'create_cmdno', cd_create_cmd_no);
    t01int4 (layer, 'block addr i', ptr.i);
    t01addr (layer, 'block addr  ', ptr.buf_ptr);
    t01addr (layer, 'less        ', cd_less.buf_ptr);
    t01addr (layer, 'greater     ', cd_greater.buf_ptr);
    t01addr (layer, 'lruprev     ', cd_lru_prev.buf_ptr);
    t01addr (layer, 'lrunext     ', cd_lru_next.buf_ptr);
    IF  cd_check <> cak_cache_chunk_flag
    THEN
        t01int4 (layer, 'wrong check ', 1);
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      ak10count (p : tak_cache_dir_pointer) : integer;
 
VAR
      cnt : integer;
 
BEGIN
IF  p.cdir_ptr = NIL
THEN
    cnt := 0
ELSE
    BEGIN
    cnt := 1 + ak10count (p.cdir_ptr^.cd_less) +
          ak10count (p.cdir_ptr^.cd_greater);
    END;
(*ENDIF*) 
ak10count := cnt
END;
 
&endif
(*------------------------------*) 
 
PROCEDURE
      ak10dump_write (
            VAR dump_context : tak10_dump_context;
            dump_id : integer);
 
VAR
      i2c2      : tsp_int_map_c2;
      pos       : integer;
      dmp_label : tsp00_C8;
      label_ptr : ^tsp00_C8;
      errtext   : tsp00_ErrText;
&     ifdef trace
      mobj_ptr  : tsp00_MoveObjPtr;
&     endif
 
BEGIN
CASE dump_id OF
    cak10dump_id_cache :
        dmp_label := 'A10CACHE';
    cak10dump_id_freecache :
        dmp_label := 'A10FREE ';
    OTHERWISE ;
    END;
(*ENDCASE*) 
WITH dump_context DO
    BEGIN
    IF  dmp_b_err = e_ok
    THEN
        BEGIN
        pos            := dmp_header_pos;
        label_ptr      := @dmp_buf[ pos ];
        label_ptr^     := dmp_label;
        pos            := pos + sizeof (dmp_label);
        i2c2.map_int   := dump_id;
        dmp_buf[pos  ] := i2c2.map_c2[1];
        dmp_buf[pos+1] := i2c2.map_c2[2];
        pos            := pos + 2;
        i2c2.map_int   := dmp_pos - 1;
        dmp_buf[pos  ] := i2c2.map_c2[1];
        dmp_buf[pos+1] := i2c2.map_c2[2];
        dmp_pos        := pos + 2;
&       ifdef trace
        mobj_ptr := @dmp_buf;
        t01moveobj (ak_cach, mobj_ptr^, 1, mxsp_buf);
&       endif
        g01new_dump_page (dmp_file, dmp_buf, dmp_pno,
              dmp_pos, dmp_error, errtext);
        dmp_header_pos := dmp_pos;
        IF  dmp_error <> vf_ok
        THEN
            dmp_b_err := e_hostfile_error
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a10akdump (
            VAR acv : tak_all_command_glob) : boolean;
 
BEGIN
(* h.b. CR 1103950 *)
ak10dump (acv, NOT cak10sync);
a10akdump := true;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a10dump (
            VAR acv : tak_all_command_glob);
 
BEGIN
ak10dump(acv, cak10sync);
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10dump(
            VAR acv : tak_all_command_glob;
            synchronize : boolean);
 
CONST
      c_dump_header_len  = 12;
      c_with_zero        = true;
 
VAR
      cnt          : integer;
      buf_cnt      : integer;
      bufpos       : integer;
      movelen      : integer;
      errtext      : tsp00_ErrText;
      dump_context : tak10_dump_context;
 
      dump_fn      : RECORD
            CASE boolean OF
                true :
                    (fn : tsp00_VFilename);
                false :
                    (c16 : tsp00_C16);
                END;
            (*ENDCASE*) 
 
 
      aux_ptr : RECORD
            CASE boolean OF
                true :
                    (bufaddr : tsp00_BufAddr);
                false :
                    (chptr   : tak10cache_header_ptr);
                END;
            (*ENDCASE*) 
 
      bufaddr : tsp00_BufAddr;
      pLine   : ^tsp00_Line;
 
BEGIN
dump_context.dmp_pno          := 1;
dump_context.dmp_pos          := 1;
dump_context.dmp_file.buf_cnt := 0;
dump_fn.fn                    := b01blankfilename;
dump_fn.c16                   := 'AK     .dmp     '; (* h.b. PTS 1108277 *)
IF  synchronize
THEN
    vbegexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
(*ENDIF*) 
ak10DumpId := ak10DumpId + 1;
pLine      := @dump_fn;
g17int4to_line (ak10DumpId, c_with_zero, 5, 3, pLine^);
WITH dump_context DO
    BEGIN
    vfopen (dump_fn.fn, dmp_file.no, dmp_error, errtext);
    IF  dmp_error = vf_ok
    THEN
        g01new_dump_page (dmp_file, dmp_buf, dmp_pno,
              dmp_pos, dmp_error, errtext);
    (*ENDIF*) 
    IF  dmp_error = vf_ok
    THEN
        BEGIN
        dmp_header_pos := dmp_pos;
        dmp_pos        := dmp_pos + c_dump_header_len;
        dmp_b_err      := e_ok;
        ak10dump_write (dump_context, cak10dump_id_cache);
        aux_ptr.bufaddr := acv.a_sysdir.ci_cache_p;
        WHILE (aux_ptr.bufaddr <> NIL) AND (dmp_error = vf_ok) DO
            BEGIN
            bufaddr := aux_ptr.bufaddr;
            buf_cnt := aux_ptr.chptr^.ch_size;
            cnt     := 0;
            REPEAT
                cnt  := cnt + 1;
                vfwrite (dmp_file.no, @bufaddr^, dmp_error, errtext);
                bufaddr := s35add_bufaddr_ptocm (bufaddr, sizeof (tsp00_Page));
            UNTIL
                (cnt = buf_cnt) OR (dmp_error <> vf_ok);
            (*ENDREPEAT*) 
            buf_cnt         := cak10supplement;
            aux_ptr.bufaddr := aux_ptr.chptr^.ch_next_cache;
            END;
        (*ENDWHILE*) 
        bufaddr := @dmp_buf;
        a101_DumpSessionInfo (acv, dump_fn.fn, dmp_file.no,
              dmp_pno, bufaddr, sizeof(dmp_buf));
        vfclose (dmp_file.no, dmp_error, errtext)
        END;
    (*ENDIF*) 
    IF  (acv.a_cmd_part <> NIL) (* h.b. PTS 1107205 *)
    THEN
        BEGIN
        dump_fn.c16[4] := 's';
        dump_fn.c16[5] := 't';
        dump_fn.c16[6] := 'm';
        vfopen (dump_fn.fn, dmp_file.no, dmp_error, errtext);
        IF  dmp_error = vf_ok
        THEN
            BEGIN
            dmp_pos := 1;
            bufpos  := 1;
            IF  (acv.a_abap_part <> NIL)
            THEN
                BEGIN
                movelen := ord(acv.a_abap_part^.sp1p_buf[1]);
                SAPDB_PascalMove ('VAK10 ',  41,    
                      acv.a_abap_part^.sp1p_buf_size, sizeof(dmp_buf),
                      @acv.a_abap_part^.sp1p_buf, 2, @dmp_buf, dmp_pos,
                      movelen, dmp_b_err);
                dmp_pos := dmp_pos + movelen + 1;
                movelen := ord(acv.a_abap_part^.sp1p_buf[movelen+2]);
                dmp_buf[dmp_pos - 1] := ',';
                SAPDB_PascalMove ('VAK10 ',  42,    
                      acv.a_abap_part^.sp1p_buf_size, sizeof(dmp_buf),
                      @acv.a_abap_part^.sp1p_buf,
                      ord(acv.a_abap_part^.sp1p_buf[1])+3,
                      @dmp_buf, dmp_pos, movelen, dmp_b_err);
                dmp_pos := dmp_pos + movelen + 1;
                dmp_buf[dmp_pos - 1] := ',';
                END;
            (*ENDIF*) 
            WHILE (bufpos < acv.a_cmd_part^.sp1p_buf_len) AND
                  (dmp_error = vf_ok) DO
                BEGIN
                IF  (acv.a_cmd_part^.sp1p_buf_len - bufpos + 1)
                    > (sizeof(dmp_buf) - dmp_pos + 1)
                THEN
                    movelen := sizeof(dmp_buf) - dmp_pos + 1
                ELSE
                    movelen := acv.a_cmd_part^.sp1p_buf_len - bufpos + 1;
                (*ENDIF*) 
                SAPDB_PascalMove ('VAK10 ',  43,    
                      acv.a_cmd_part^.sp1p_buf_size, sizeof(dmp_buf),
                      @acv.a_cmd_part^.sp1p_buf, bufpos,
                      @dmp_buf, dmp_pos, movelen, dmp_b_err);
                dmp_pos := dmp_pos + movelen;
                IF  (sizeof(dmp_buf) > dmp_pos - 1)
                THEN
                    SAPDB_PascalFill ('VAK10 ',  44,    
                          sizeof(dmp_buf), @dmp_buf, dmp_pos,
                          sizeof(dmp_buf) - dmp_pos + 1, bsp_c1,
                          dmp_b_err);
                (*ENDIF*) 
                vfwrite (dmp_file.no, @dmp_buf, dmp_error, errtext);
                dmp_pos := 1;
                bufpos  := bufpos + movelen;
                END;
            (*ENDWHILE*) 
            vfclose (dmp_file.no, dmp_error, errtext);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  synchronize
THEN
    vendexcl (acv.a_transinf.tri_trans.trTaskId_gg00, g08diagcache);
(*ENDIF*) 
END;
 
(* PTS 1106167 E.Z. BEGIN *)
(*------------------------------*) 
 
PROCEDURE
      a10parsinfos (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      i : integer;
 
BEGIN
IF  acv.a_returncode = 0
THEN
    a40get_catalog_table (acv, a41v);
(*ENDIF*) 
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    FOR i := ord(cak_ctemp) TO cak_emax DO
        IF  acv.a_sysdir.ci_dir[ i ].cdir_ptr <> NIL
        THEN
            ak10cache_parsinfos (acv, a41v, acv.a_sysdir.ci_dir[ i ]);
        (*ENDIF*) 
    (*ENDFOR*) 
(*ENDIF*) 
IF  (acv.a_returncode = 0) AND
    (acv.a_ex_kind <> only_parsing)
THEN
    ak10parsfile_infos (acv, a41v);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10cache_parsinfos (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            p        : tak_cache_dir_pointer);
 
BEGIN
IF  p.cdir_ptr <> NIL
THEN
    BEGIN
    IF  NOT (
        (dwritten in p.cdir_ptr^.cd_state)
        OR
        (dmodified in p.cdir_ptr^.cd_state)
        )
    THEN
        ak10one_parsinfo (acv, a41v, p.cdir_ptr^.cd_sysinfo, c_in_cache);
    (*ENDIF*) 
    ak10cache_parsinfos (acv, a41v, p.cdir_ptr^.cd_less);
    ak10cache_parsinfos (acv, a41v, p.cdir_ptr^.cd_greater)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10parsfile_infos (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob);
 
VAR
      b_err        : tgg00_BasisError;
      tree_pos     : tgg00_FilePos;
      set_result   : tgg00_BdSetResultRecord;
      zerokey      : tgg00_Lkey;
 
      b            : RECORD
            CASE integer OF
                1 :
                    (sb : tak_systembuffer);
                2 :
                    (b : tsp00_Buf);
                3 :
                    (rb : tgg00_Rec);
                END;
            (*ENDCASE*) 
 
 
BEGIN
WITH set_result DO
    BEGIN
    bd_key_check_len:= 0;
    bd_max_rec_cnt  := 1;
    bd_max_fill_len := sizeof(b);
    bd_next         := false;
    END;
(*ENDWITH*) 
zerokey.len := 0;
tree_pos.tpsPno_gg00  := NIL_PAGE_NO_GG00;
REPEAT
    b_err := e_ok;
    b07cnext_record (acv.a_transinf.tri_trans,
          acv.a_pars_curr,
          zerokey, set_result, tree_pos, b.b);
    b_err := acv.a_transinf.tri_trans.trError_gg00;
    acv.a_transinf.tri_trans.trError_gg00 := e_ok;
    IF  (b_err = e_ok) OR (b_err = e_key_not_found) OR
        (b_err = e_buffer_limit)
    THEN
        BEGIN
        b_err   := e_ok;
        set_result.bd_next := true;
        a10expand_rec (b.rb, b_err);
        IF  b_err = e_ok
        THEN
            ak10one_parsinfo (acv, a41v, b.sb, NOT c_in_cache);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
UNTIL
    (b_err <> e_ok) OR (acv.a_returncode <> 0);
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak10one_parsinfo (
            VAR acv  : tak_all_command_glob;
            VAR a41v : tak40_show_glob;
            VAR p    : tak_systembuffer;
            in_cache : boolean);
 
VAR
      offset  : integer;
      i4      : tsp00_Int4;
      tabtype : tsp00_C12;
 
BEGIN
&ifdef TRACE
t01buf (ak_cach, p, 1, 40);
t01int4 (ak_cach, 'stempid     ', p.syskey.stempid);
t01int4 (ak_cach, 'curr_res_id ', acv.a_curr_res_id);
t01surrogate (ak_cach, 'sauthid     ', p.syskey.sauthid);
t01surrogate (ak_cach, 'curr_user_id', acv.a_curr_user_id);
t01site (ak_cach, 'ssite       ', p.syskey.ssite);
t01site (ak_cach, 'show_table_s', cak_show_table_site);
t01int4 (ak_cach, 'sshowkind   ', ord(p.syskey.sshowkind));
t01int4 (ak_cach, 'sh_kind     ', ord(a41v.a4sh_kind));
&endif
WITH p DO
    IF  (
        (syskey.sentrytyp[2] in [
        cak_cshortinfo,
        cak_cresult,
        cak_ccolnames ])                AND
        (syskey.stempid = acv.a_curr_res_id)
        )
        OR
        (
        (syskey.sentrytyp[2] = cak_cresname)  AND
        (syskey.sauthid = acv.a_curr_user_id) AND
        ((syskey.srestablen = a41v.a4showfile_name) OR (syskey.srestablen = a01_zero_res_name))
        )
        OR
        (
        (syskey.sentrytyp[2] = cak_cresult)         AND
        (syskey.ssite        = cak_show_table_site) AND
        (syskey.sshowkind    = a41v.a4sh_kind)
        )
        OR
        (* will be created with open column, destroyed with close column   *)
        (* the existence only means that there was no correct close column *)
        (* this has nothing to do with the kernel implementation           *)
        (syskey.sentrytyp[2] = cak_ctempscoldesc)
        OR
        (
        (acv.a_init_ex_kind = only_executing)                   AND
        (syskey.sauthid[1] = cak_tempinfo_byte)                 AND
        (syskey.sauthid[2] = acv.a_curr_ex_parskey.p_count[1])  AND
        (syskey.sauthid[3] = acv.a_curr_ex_parskey.p_count[2])  AND
        (syskey.sauthid[4] = acv.a_curr_ex_parskey.p_count[3])
        )
    THEN
        BEGIN
        (* those sysinfos created by this select, forget them *)
        END
    ELSE
        BEGIN
        a40move (acv, a41v, @syskey.sstandardkey, b_kl);
        IF  syskey.sentrytyp[2] = cak_cresname
        THEN
            a40move (acv, a41v, NIL, 0)
        ELSE
            a40move (acv, a41v, @syskey.slinkage, 2);
        (*ENDIF*) 
        i4 := ord(syskey.slinkage[2]);
        CASE syskey.sentrytyp[2] OF
            cak_cparsinfo :
                BEGIN
                IF  (i4 = 1) AND (sparsinfo.p_select)
                THEN
                    a40move (acv, a41v, @sparsinfo.p_resn, sizeof(sparsinfo.p_resn))
                ELSE
                    a40move (acv, a41v, @syskey, 0);
                (*ENDIF*) 
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'PARSINFO    ';
                END;
            cak_cjparsinfo :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'JPARSINFO   ';
                END;
            cak_ccorrinfo :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'CORRINFO    ';
                END;
            cak_cshortinfo :
                BEGIN
                a40move (acv, a41v, @syskey, 0);
                i4 := sshortinfo.sicount;
                a40move_i4 (acv, a41v, i4, NOT c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'SHORTINFO   ';
                END;
            cak_chint :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'HINT        ';
                END;
            cak_cstratinfo :
                BEGIN
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, NOT c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'STRATINFO   ';
                END;
            cak_cunionrec :
                BEGIN
                a40move (acv, a41v, @sunionrec.ures_name, sizeof(sunionrec.ures_name));
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'UNIONREC    ';
                END;
            cak_cviewkey :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'VIEWKEY     ';
                END;
            cak_ccomplex :
                BEGIN
                a40move (acv, a41v, @syskey, 0);
                i4 := scomplexrec.compcnt;
                a40move_i4 (acv, a41v, i4, NOT c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'COMPLEX     ';
                END;
            cak_ctemppriv :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TEMPPRIV    ';
                END;
            cak_cressiteinfo :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'RESSITEINFO ';
                END;
            cak_clinkparsinfo :
                BEGIN
                a40move (acv, a41v, @syskey, 0);
                i4 := slinkparsinfo.lpcount;
                a40move_i4 (acv, a41v, i4, NOT c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'LINKPARSINFO';
                END;
            cak_ctriggerparsinfo :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TRIGGERPARS ';
                END;
            cak_csubtrans :
                BEGIN
                a40move (acv, a41v, @syskey, 0);
                i4 := ssubtrans.str_count;
                a40move_i4 (acv, a41v, i4, NOT c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'SUBTRANS    ';
                END;
            cak_cstored_cmd :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'STORED_CMD  ';
                END;
            cak_cchangeinfos :
                BEGIN
                a40move (acv, a41v, @syskey, 0);
                i4 := schangeinfos.ci_colcount;
                a40move_i4 (acv, a41v, i4, NOT c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'CHANGEINFOS ';
                END;
            cak_clongliteral :
                BEGIN
                a40move (acv, a41v, @syskey, 0);
                i4 := slongliteral.litcolcount;
                a40move_i4 (acv, a41v, i4, NOT c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'LONGLITERAL ';
                END;
            cak_cjparsinfo_joinarr :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'JP_JOINARR  ';
                END;
            cak_cjparsinfo_eqarr :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'JP_EQARR    ';
                END;
            cak_cjparsinfo_table :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'JP_TABLE    ';
                END;
            cak_clogged_temp :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'LOGGED_TEMP ';
                END;
            cak_cresult :
                BEGIN
                IF  (i4 = 1)
                THEN
                    IF  NOT in_cache
                    THEN
                        BEGIN
                        offset := a10BaseRecPersistentOffset;
                        i4 := ord(p.ssysbuf [offset+1]);
                        a40move (acv, a41v, @p.ssysbuf[offset+2], i4)
                        END
                    ELSE
                        a40move (acv, a41v, @sresult.btablen^, sizeof(sresult.btablen^))
                    (*ENDIF*) 
                ELSE
                    a40move (acv, a41v, @syskey, 0);
                (*ENDIF*) 
                i4 := sresult.bmaxcol;
                a40move_i4 (acv, a41v, i4, NOT c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'RESULT      ';
                END;
            cak_creskey :
                BEGIN
                IF  (i4 = 0)
                THEN
                    a40move (acv, a41v, @sreskey.res_resultname, sizeof(sreskey.res_resultname))
                ELSE
                    a40move (acv, a41v, @syskey, 0);
                (*ENDIF*) 
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'RESKEY      ';
                END;
            cak_cresname :
                BEGIN
                a40move (acv, a41v, @sresname.reskey_name, sizeof(sresname.reskey_name));
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'RESNAME     ';
                END;
            cak_ctempprocref :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TEMPPROC    ';
                END;
            cak_ctemptableref :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TEMPTABLEREF';
                END;
            cak_ctempdefault :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TEMPDEFAULT ';
                END;
            cak_ctempconstraint :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TEMPCONSTR  ';
                END;
            cak_ctempviewdesc :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TEMPVIEWDESC';
                END;
            cak_ctempscoldesc :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TEMPCOLDESC ';
                END;
            cak_ctempviewtext :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TEMPVIEWTEXT';
                END;
            cak_ctmpconstraintname :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'TMPCNSTRNAME';
                END;
            cak_clinkpos :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'LINKPOS     ';
                END;
            cak_cdbprocparsinfo :
                BEGIN
                (* cak_edbprocparsinfo not used any more *)
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'DBPROCPARS  ';
                END;
            cak_ccolnames :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'COLNAMES    ';
                END;
            cak_cmessblock :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'MESSBLOCK   ';
                END;
            cak_ccommand_info :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'COMMAND_INFO';
                END;
            cak_csharedSQL_info :
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'SHARED_SQL  ';
                END;
            OTHERWISE
                BEGIN
                (* 2 * NULL *)
                a40move (acv, a41v, @syskey, 0);
                a40move_i4 (acv, a41v, i4, c_is_null, 0, NOT c_zero_to_undef);
                tabtype := 'NOT KNOWN   ';
                END
            END;
        (*ENDCASE*) 
        a40move_const (acv, a41v, @tabtype, sizeof(tabtype));
        i4 := b_sl;
        a40move_i4 (acv, a41v, i4, NOT c_is_null, 0, NOT c_zero_to_undef);
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(* PTS 1106167 E.Z. END *)
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
