.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.tt 1 $SQL$Project Distributed Database System$VAK011$
.tt 2 $$$
.tt 3 $HolgerB$Unicode Prozeduren des Parsers$2000-01-27$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
Module  : Unicode-Scanner
=========
.sp
Purpose : Symbolerkennung f?ur UNICODE
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a011u_next_symbol (VAR acv : tak_all_command_glob);
 
        FUNCTION
              a011uni_eqkey (VAR a : tak_keyword;
                    VAR b     : tsp00_MoveObj;
                    b_pos     : tsp00_Int4;
                    length    : integer) : boolean;
 
        PROCEDURE
              a011u_get_pwd (VAR acv : tak_all_command_glob;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
.CM *-END-* define --------------------------------------
.sp
.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01letter_dig_under  : tak_sqlm_charset;
              a01digits            : tak_charset;
              a01_first_id_char    : tak_sqlm_charset;
              a01ht                : char; (* horizontal tab  *)
              a01lf                : char; (* line feed       *)
              a01cr                : char; (* carriage return *)
              a01kw                : tak_keywordtab;
 
        PROCEDURE
              a01_put_node (VAR acv : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01blank_skip_node (VAR acv : tak_all_command_glob;
                    pos : tsp00_Int4;
                    len : tsp00_Int4);
 
        FUNCTION
              a01is_whitespace_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4) : boolean;
 
        PROCEDURE
              a01_is_odbc_syntax (
                    VAR acv      : tak_all_command_glob;
                    VAR partype  : tak_odbc_partype;
                    VAR functype : tak_odbc_functiontype);
 
      ------------------------------ 
 
        FROM
              AK_error_handling: VAK07;
 
        PROCEDURE
              a07_error (VAR acv : tak_all_command_glob;
                    err : tgg00_BasisError;
                    VAR nod1 : tsp00_Int2;
                    VAR nod2 : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_hex_uni_error (
                    VAR acv     : tak_all_command_glob;
                    uni_err     : tsp8_uni_error;
                    err_code    : tsp00_Int4;
                    to_unicode  : boolean;
                    bytestr     : tsp00_MoveObjPtr;
                    len         : tsp00_Int4 );
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Unicode-Utilities : VGG20;
 
        PROCEDURE
              g20unifill (
                    size      : tsp00_Int4;
                    m         : tsp00_MoveObjPtr;
                    pos       : tsp00_Int4;
                    len       : tsp00_Int4;
                    filluchar : tsp00_C2);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures: VTA01;
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (debug : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp
.cp 3
Synonym :
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : HolgerB
.sp
.cp 3
Created : 1985-01-23
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-01-27
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 4
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
.CM *-END-* description ---------------------------------
.sp 4
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
(* PTS 1121518 E.Z. *)
CONST
      c_to_unicode = true;
 
 
(*------------------------------*) 
 
PROCEDURE
      a011u_next_symbol (VAR acv : tak_all_command_glob);
 
CONST
      dopp = ':';
 
VAR
      c                   : char;
      pred_c              : char;
      l_bracket           : char;
      r_bracket           : char;
      prev_symb           : tak_sc_symbol;
      i                   : tsp00_Int4;
      dif                 : integer;
      pos                 : tsp00_Int4;
      hint                : tsp00_Int2;
      (* PTS 1121518 E.Z. *)
      err_char_no         : tsp00_Int4;
      e                   : tsp8_uni_error;
      odbc_partype        : tak_odbc_partype;
      odbc_functype       : tak_odbc_functiontype;
      scvh                : tak_scanner_glob;
      recursive_call      : boolean; (* PTS 1118015 U.J. *)
      aux_int             : tsp00_Int2;
 
BEGIN
(* PTS 1116837 E.Z. every loop was changed *)
WITH acv, a_scv DO
    BEGIN
    recursive_call := false; (* PTS 1118015 U.J. *)
    hint        := sc_newpos - sc_sypos;
    sc_sylength := 0;
    prev_symb   := sc_symb;
    sc_symb     := s_unknown;
    sc_states   := sc_states - [ scs_pack ];
    dif         := 0;
    sc_lastpos  := sc_newpos - 2;
    pos         := sc_newpos;
    WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
          AND
          ((a_cmd_part^.sp1p_buf [ sc_newpos ] = csp_unicode_mark) AND
          ((a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = bsp_c1) OR
          (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = a01ht)   OR
          (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = a01lf)   OR
          (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = a01cr))) DO
        sc_newpos := sc_newpos + 2;
    (*ENDWHILE*) 
    IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
    THEN
        BEGIN
        IF  a_compact_varpart
        THEN
            IF  (sc_newpos > pos + 2) OR
                ((sc_newpos = pos + 2) AND
                ((a_cmd_part^.sp1p_buf[sc_newpos+1] in [',',')']) OR
                ( prev_symb = s_leftpar)))
            THEN
                BEGIN
                IF  (a_cmd_part^.sp1p_buf[sc_newpos+1] in [',',')']) OR
                    (prev_symb = s_leftpar)
                THEN
                    pos := pos - 2;
                (*ENDIF*) 
                SAPDB_PascalOverlappingMove ('VAK011',   1,    
                      a_cmd_part^.sp1p_buf_len, a_cmd_part^.sp1p_buf_len,
                      @a_cmd_part^.sp1p_buf, sc_newpos,
                      @a_cmd_part^.sp1p_buf, pos + 2,
                      a_cmd_part^.sp1p_buf_len - sc_newpos + 1,
                      a_returncode);
                a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len
                      - (sc_newpos - pos - 2);
                a01blank_skip_node (acv, pos + 2,
                      sc_newpos - pos - 2);
                sc_newpos := pos + 2;
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        pred_c := a_cmd_part^.sp1p_buf [ sc_newpos ];
        c      := a_cmd_part^.sp1p_buf [ sc_newpos + 1 ];
        (* PTS 1121518 E.Z. *)
        IF  (((c = 'X') OR (c = 'x')) AND
            ( pred_c = csp_unicode_mark) AND
            ( a_sqlmode <> sqlm_ansi))
        THEN
            BEGIN
            i := sc_newpos + 2;
            WHILE (i < a_cmd_part^.sp1p_buf_len - 1)
                  AND
                  ((a_cmd_part^.sp1p_buf [ i     ] = csp_unicode_mark) AND
                  ((a_cmd_part^.sp1p_buf [ i + 1 ] = bsp_c1) OR
                  (a_cmd_part^.sp1p_buf [ i + 1 ] = a01ht)   OR
                  (a_cmd_part^.sp1p_buf [ i + 1 ] = a01lf)   OR
                  (a_cmd_part^.sp1p_buf [ i + 1 ] = a01cr))) DO
                i := i + 2;
            (*ENDWHILE*) 
            IF  i < a_cmd_part^.sp1p_buf_len - 1
            THEN
                IF  (a_cmd_part^.sp1p_buf [ i ] = csp_unicode_mark) AND
                    (a_cmd_part^.sp1p_buf[ i + 1 ] = '''')
                THEN
                    BEGIN
                    sc_newpos := i;
                    c := a_cmd_part^.sp1p_buf[ sc_newpos+1 ];
                    sc_symb := s_byte_string;
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            (* PTS 1141563 E.Z. *)
            IF  (((c = 'N') OR (c = 'n')) AND
                ( pred_c = csp_unicode_mark))
            THEN
                BEGIN
                i := sc_newpos + 2;
                WHILE (i < a_cmd_part^.sp1p_buf_len - 1)
                      AND
                      ((a_cmd_part^.sp1p_buf [ i     ] = csp_unicode_mark) AND
                      ((a_cmd_part^.sp1p_buf [ i + 1 ] = bsp_c1) OR
                      ( a_cmd_part^.sp1p_buf [ i + 1 ] = a01ht)  OR
                      ( a_cmd_part^.sp1p_buf [ i + 1 ] = a01lf)  OR
                      ( a_cmd_part^.sp1p_buf [ i + 1 ] = a01cr))) DO
                    i := i + 2;
                (*ENDWHILE*) 
                IF  i < a_cmd_part^.sp1p_buf_len - 1
                THEN
                    IF  (a_cmd_part^.sp1p_buf [ i     ] = csp_unicode_mark) AND
                        (a_cmd_part^.sp1p_buf [ i + 1 ] = '''')
                    THEN
                        BEGIN
                        (* overwrite 'n' with ' ' *)
                        a_cmd_part^.sp1p_buf [ sc_newpos+1 ] := bsp_c1;
                        sc_newpos := i;
                        c := a_cmd_part^.sp1p_buf[ sc_newpos+1 ];
                        (* search for final ' of this literal, skip ''    *)
                        (* and change from unicode to ascii        -->    *)
                        (* in reality from double_unicode to real unicode *)
                        pos := i + 2;
                        IF  NOT
                            ((a_cmd_part^.sp1p_buf [ pos     ] = csp_unicode_mark) AND
                            ( a_cmd_part^.sp1p_buf [ pos + 1 ] = ''''))
                        THEN
                            BEGIN
                            REPEAT
                                pos := pos + 4;
                            UNTIL
                                ((pos > a_cmd_part^.sp1p_buf_len)
                                OR
                                ((a_cmd_part^.sp1p_buf [ pos     ] = csp_unicode_mark) AND
                                ( a_cmd_part^.sp1p_buf [ pos + 1 ] = '''')             AND
                                NOT
                                (( a_cmd_part^.sp1p_buf [ pos - 2 ] = csp_unicode_mark) AND
                                (  a_cmd_part^.sp1p_buf [ pos - 1 ] = csp_unicode_mark))));
                            (*ENDREPEAT*) 
                            IF  pos > a_cmd_part^.sp1p_buf_len
                            THEN
                                a07_error (acv, e_invalid_end_of_command,
                                      aux_int, aux_int)
                            ELSE
                                BEGIN
                                i := (pos - sc_newpos - 2) DIV 2;
                                s80uni_trans (@a_cmd_part^.sp1p_buf[ sc_newpos+2 ], pos - sc_newpos - 2,
                                      csp_unicode,
                                      @a_cmd_part^.sp1p_buf[ sc_newpos+2 ], i,
                                      csp_ascii, [  ], e, err_char_no);
                                IF  e <> uni_ok
                                THEN
                                    a07_hex_uni_error (acv, e, err_char_no,
                                          c_to_unicode, @a_cmd_part^.sp1p_buf[ sc_newpos+1 + err_char_no ],
                                          a_max_codewidth)
                                ELSE
                                    BEGIN
                                    a_cmd_part^.sp1p_buf [ sc_newpos + 2 + i     ] := csp_unicode_mark;
                                    a_cmd_part^.sp1p_buf [ sc_newpos + 2 + i + 1 ] := '''';
                                    g20unifill (a_cmd_part^.sp1p_buf_size,
                                          @a_cmd_part^.sp1p_buf,
                                          sc_newpos + 2 + i + 2,
                                          pos + 1 - (sc_newpos + 2 + i + 1), csp_unicode_blank)
                                    END;
                                (*ENDIF*) 
&                               IFDEF TRACE
                                t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len);
&                               ENDIF
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        sc_sypos := sc_newpos;
        IF  ((c in a01_first_id_char[a_sqlmode])
            AND (pred_c = csp_unicode_mark))
            OR
            (ord(c) > 127)
            OR
            (pred_c <> csp_unicode_mark)
        THEN
            BEGIN
            sc_symb := s_identifier;
            sc_double_quote := 0;
            REPEAT
                sc_newpos := sc_newpos + 2;
            UNTIL
                ((sc_newpos > a_cmd_part^.sp1p_buf_len)
                OR
                ((a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark) AND
                (ord(a_cmd_part^.sp1p_buf[ sc_newpos + 1 ]) <= 127) AND
                NOT (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] in
                a01letter_dig_under[a_sqlmode])));
            (*ENDREPEAT*) 
            (* PTS 1121518 E.Z. *)
            i := sc_newpos - sc_sypos;
            s80uni_trans (@a_cmd_part^.sp1p_buf[ sc_sypos ], sc_newpos - sc_sypos,
                  csp_unicode,
                  @a_cmd_part^.sp1p_buf[ sc_sypos ], i,
                  csp_unicode, [ uni_change_to_upper ], e, err_char_no);
            IF  e <> uni_ok
            THEN
                a07_hex_uni_error (acv, e, err_char_no,
                      c_to_unicode, @a_cmd_part^.sp1p_buf[ sc_sypos - 1 + err_char_no ],
                      a_max_codewidth);
            (*ENDIF*) 
            IF  acv.a_scv.sc_eof_kw <> cak_i_no_keyword
            THEN
                BEGIN
                sc_sylength := sc_newpos - sc_sypos;
                IF  a011uni_eqkey (a01kw[acv.a_scv.sc_eof_kw],
                    acv.a_cmd_part^.sp1p_buf,
                    acv.a_scv.sc_sypos, acv.a_scv.sc_sylength)
                THEN
                    BEGIN
                    sc_symb   := s_eof;
                    sc_newpos := sc_sypos
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            IF  c = '"'
            THEN
                ak011special_identifier (acv, dif)
            ELSE
                IF  ((c >= '0') AND (c <= '9')) OR
                    (c = '.')
                THEN
                    BEGIN
                    sc_symb := s_unknown;
                    IF  c = '.'
                    THEN
                        BEGIN
                        sc_symb   := s_point;
                        sc_newpos := sc_newpos + 2;
                        WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                              AND
                              (a_cmd_part^.sp1p_buf [ sc_newpos ]
                              = csp_unicode_mark)
                              AND
                              (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] >= '0')
                              AND
                              (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] <= '9') DO
                            BEGIN
                            sc_symb := s_fixed_point_literal;
                            sc_newpos := sc_newpos + 2;
                            END;
                        (*ENDWHILE*) 
                        END
                    ELSE
                        BEGIN
                        sc_symb := s_unsigned_integer;
                        REPEAT
                            sc_newpos := sc_newpos + 2;
                            IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                            THEN
                                BEGIN
                                pred_c    := a_cmd_part^.sp1p_buf[ sc_newpos ];
                                c         := a_cmd_part^.sp1p_buf[ sc_newpos + 1 ];
                                END
                            (*ENDIF*) 
                        UNTIL
                            ((sc_newpos > a_cmd_part^.sp1p_buf_len)
                            OR
                            (pred_c <> csp_unicode_mark) OR
                            (c < '0') OR (c > '9'));
                        (*ENDREPEAT*) 
                        IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                        THEN
                            IF  (a_cmd_part^.sp1p_buf [ sc_newpos ]
                                = csp_unicode_mark) AND
                                (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = '.')
                            THEN
                                BEGIN
                                sc_symb := s_fixed_point_literal;
                                REPEAT
                                    sc_newpos := sc_newpos + 2;
                                    IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                                    THEN
                                        BEGIN
                                        pred_c    := a_cmd_part^.sp1p_buf[ sc_newpos ];
                                        c         := a_cmd_part^.sp1p_buf[ sc_newpos + 1 ];
                                        END
                                    (*ENDIF*) 
                                UNTIL
                                    ((sc_newpos > a_cmd_part^.sp1p_buf_len)
                                    OR
                                    (pred_c <> csp_unicode_mark) OR
                                    (c < '0') OR (c > '9'));
                                (*ENDREPEAT*) 
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                    THEN
                        IF  (a_cmd_part^.sp1p_buf [ sc_newpos ]
                            = csp_unicode_mark) AND
                            (* PTS 1121518 E.Z. *)
                            (
                            (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = 'E') OR
                            (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = 'e')
                            ) AND
                            (sc_symb <> s_point)
                        THEN
                            BEGIN
                            (* PTS 1121518 E.Z. *)
                            a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] := 'E';
                            sc_newpos := sc_newpos + 2;
                            IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                            THEN
                                IF  ((a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = '+') OR
                                    (a_cmd_part^.sp1p_buf[ sc_newpos + 1] = '-')) AND
                                    (a_cmd_part^.sp1p_buf [ sc_newpos ]
                                    = csp_unicode_mark)
                                THEN
                                    sc_newpos := sc_newpos + 2;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                AND
                                (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                = csp_unicode_mark)
                                AND
                                (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] >= '0')
                                AND
                                (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] <= '9')
                            THEN
                                BEGIN
                                sc_symb := s_floating_point_literal;
                                i := 0;
                                REPEAT
                                    i := succ(i);
                                    sc_newpos := sc_newpos + 2;
                                    IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                                    THEN
                                        BEGIN
                                        pred_c    := a_cmd_part^.sp1p_buf[ sc_newpos ];
                                        c         := a_cmd_part^.sp1p_buf[ sc_newpos + 1 ];
                                        END
                                    (*ENDIF*) 
                                UNTIL
                                    ((sc_newpos > a_cmd_part^.sp1p_buf_len) OR
                                    (pred_c <> csp_unicode_mark) OR
                                    (c < '0') OR (c > '9'));
                                (*ENDREPEAT*) 
                                IF  i > 3
                                THEN
                                    sc_symb := s_unknown;
                                (*ENDIF*) 
                                END
                            ELSE
                                sc_symb := s_unknown;
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  c = ''''
                    THEN
                        ak011string_literal (acv, dif)
                    ELSE
                        IF  c = csp_ascii_tilde
                        THEN
                            BEGIN
                            sc_symb   := s_unknown;
                            sc_newpos := sc_newpos + 2;
                            IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                            THEN
                                IF  (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                    = csp_unicode_mark) AND
                                    (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] = '=')
                                THEN
                                    BEGIN
                                    sc_symb   := s_unequal;
                                    sc_newpos := sc_newpos + 2;
                                    END
                                ELSE
                                    IF  (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                        = csp_unicode_mark) AND
                                        (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] = '<')
                                    THEN
                                        BEGIN
                                        sc_symb   := s_greater_or_eq;
                                        sc_newpos := sc_newpos + 2;
                                        END
                                    ELSE
                                        IF  (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                            = csp_unicode_mark) AND
                                            (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] = '>')
                                        THEN
                                            BEGIN
                                            sc_symb   := s_less_or_eq;
                                            sc_newpos := sc_newpos + 2;
                                            END;
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  c = csp_ascii_not
                            THEN
                                BEGIN
                                sc_symb   := s_unknown;
                                sc_newpos := sc_newpos + 2;
                                IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                                THEN
                                    IF  (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                        = csp_unicode_mark) AND
                                        (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] = '=')
                                    THEN
                                        BEGIN
                                        sc_symb   := s_unequal;
                                        sc_newpos := sc_newpos + 2;
                                        END
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END
                            ELSE
                                CASE c OF
                                    '!' :
                                        BEGIN
                                        sc_symb   := s_unknown;
                                        sc_newpos := sc_newpos + 2;
                                        IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                                        THEN
                                            IF  (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                                = csp_unicode_mark) AND
                                                (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] = '=')
                                            THEN
                                                BEGIN
                                                sc_symb   := s_unequal;
                                                sc_newpos := sc_newpos + 2;
                                                END
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        END;
                                    '>' :
                                        BEGIN
                                        sc_symb := s_greater;
                                        sc_newpos := sc_newpos + 2;
                                        IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                                        THEN
                                            IF  (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                                = csp_unicode_mark) AND
                                                (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = '=')
                                            THEN
                                                BEGIN
                                                sc_symb := s_greater_or_eq;
                                                sc_newpos := sc_newpos + 2;
                                                END;
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        END;
                                    (*less,lessequal*)
                                    '<' :
                                        BEGIN
                                        sc_newpos := sc_newpos + 2;
                                        sc_symb := s_less;
                                        IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                                        THEN
                                            IF  (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                                = csp_unicode_mark) AND
                                                (a_cmd_part^.sp1p_buf [ sc_newpos + 1] = '=')
                                            THEN
                                                BEGIN
                                                sc_symb := s_less_or_eq;
                                                sc_newpos := sc_newpos + 2;
                                                END
                                            ELSE
                                                IF  (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                                    = csp_unicode_mark) AND
                                                    (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = '>')
                                                THEN
                                                    BEGIN
                                                    sc_symb := s_unequal;
                                                    sc_newpos := sc_newpos + 2;
                                                    END;
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        END;
                                    (* colon *)
                                    dopp :
                                        BEGIN
                                        l_bracket := cak_l_ascii_sq_bracket;
                                        r_bracket := cak_r_ascii_sq_bracket;
                                        sc_symb   := s_colon;
                                        sc_newpos := sc_newpos + 2;
                                        (* PTS 1113138 E.Z. *)
                                        IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                                        THEN
                                            IF  ((a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark) AND
                                                (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] in
                                                a01letter_dig_under[a_sqlmode]))
                                                OR
                                                ((acv.a_is_ddl = ddl_create_trigger)                        AND
                                                ( a_cmd_part^.sp1p_buf [ sc_newpos    ] = csp_unicode_mark) AND
                                                ( a_cmd_part^.sp1p_buf [ sc_newpos + 1] = '"'))
                                                OR
                                                (ord(a_cmd_part^.sp1p_buf[ sc_newpos + 1 ]) > 127)
                                                OR
                                                (a_cmd_part^.sp1p_buf[ sc_newpos ] <> csp_unicode_mark)
                                            THEN
                                                IF  acv.a_is_ddl = ddl_create_trigger
                                                THEN
                                                    ak011trigger_parameter (acv)
                                                ELSE
                                                    BEGIN
                                                    sc_symb := s_parameter_name;
                                                    REPEAT
                                                     sc_newpos := sc_newpos + 2;
                                                    UNTIL
                                                     (
                                                     (sc_newpos > a_cmd_part^.sp1p_buf_len)
                                                     OR
                                                     ((a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark) AND
                                                     ( ord(a_cmd_part^.sp1p_buf[ sc_newpos + 1 ]) <= 127) AND
                                                     NOT (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] in
                                                     a01letter_dig_under[a_sqlmode] + [ '.' ]))
                                                     );
                                                    (*ENDREPEAT*) 
                                                    IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                                                    THEN
                                                     IF  ((a_cmd_part^.sp1p_buf[ sc_newpos + 1] = '(') OR
                                                      (a_cmd_part^.sp1p_buf[ sc_newpos + 1] = l_bracket))
                                                      AND
                                                      (a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark)
                                                     THEN
                                                      BEGIN
                                                      sc_newpos := sc_newpos + 2;
                                                      REPEAT
                                                       sc_newpos := sc_newpos + 2;
                                                      UNTIL
                                                       (
                                                       (sc_newpos > a_cmd_part^.sp1p_buf_len)
                                                       OR
                                                       ((a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark) AND
                                                       ( ord(a_cmd_part^.sp1p_buf[ sc_newpos + 1 ]) <= 127) AND
                                                       NOT (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] in
                                                       a01letter_dig_under[a_sqlmode] + [ '.' ]))
                                                       );
                                                      (*ENDREPEAT*) 
                                                      IF  
                                                       (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                                       AND
                                                       ((a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] = ')') OR
                                                       (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] = r_bracket)) AND
                                                       (a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark)
                                                      THEN
                                                       sc_newpos := sc_newpos + 2
                                                      ELSE
                                                       a07_error (acv, e_missing_keyword, hint, hint);
                                                      (*ENDIF*) 
                                                      END
                                                     (*ENDIF*) 
                                                    (*ENDIF*) 
                                                    END
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        END;
                                    (* question-mark = parameter *)
                                    '?' :
                                        BEGIN
                                        sc_symb := s_parameter_name;
                                        sc_newpos := sc_newpos + 2;
                                        END;
                                    (*equal*)
                                    '=' :
                                        BEGIN
                                        sc_symb := s_equal;
                                        sc_newpos := sc_newpos + 2;
                                        END;
                                    (*plus*)
                                    '+' :
                                        BEGIN
                                        sc_symb := s_plus;
                                        sc_newpos := sc_newpos + 2;
                                        END;
                                    (*minus*)
                                    '-' :
                                        BEGIN
                                        sc_symb := s_minus;
                                        sc_newpos := sc_newpos + 2;
                                        (* PTS 1113708 E.Z. *)
                                        IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len) AND
                                            (a_cmd_part^.sp1p_buf[ sc_newpos ]
                                            = csp_unicode_mark) AND
                                            (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] = '-')
                                        THEN
                                            BEGIN
                                            (* may be comment or odbc-syntax *)
                                            odbc_partype := no_odbc;
                                            scvh := a_scv;
                                            IF  (a_comp_type = at_odbc) OR (a_comp_type = at_jdbc)
                                            THEN
                                                a01_is_odbc_syntax (acv, odbc_partype, odbc_functype);
                                            (*ENDIF*) 
                                            IF  odbc_partype = no_odbc
                                            THEN
                                                BEGIN
                                                WHILE (sc_newpos < a_cmd_part^.sp1p_buf_len - 1)
                                                      AND
                                                      ((a_cmd_part^.sp1p_buf [ sc_newpos     ] <> csp_unicode_mark) OR
                                                      ((a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] <> a01lf)   AND
                                                      ( a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] <> a01cr)))
                                                      DO
                                                    sc_newpos := sc_newpos + 2;
                                                (*ENDWHILE*) 
                                                IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                                                THEN
                                                    BEGIN
                                                    sc_newpos := sc_newpos + 2;
                                                    a011u_next_symbol(acv);
                                                    recursive_call := true; (* PTS 1118015 U.J. *)
                                                    END
                                                ELSE
                                                    BEGIN
                                                    sc_sypos := a_cmd_part^.sp1p_buf_len-1;
                                                    sc_symb  := s_eof
                                                    END;
                                                (*ENDIF*) 
                                                END
                                            ELSE
                                                a_scv := scvh;
                                            (*ENDIF*) 
                                            END
                                        (* END PTS 1113708 E.Z. *)
                                        (*ENDIF*) 
                                        END;
                                    (*divide*)
                                    '/' :
                                        BEGIN
                                        sc_symb := s_divide;
                                        sc_newpos := sc_newpos + 2;
                                        IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                        THEN
                                            IF  ((a_cmd_part^.sp1p_buf [ sc_newpos ] = csp_unicode_mark ) AND
                                                (a_cmd_part^.sp1p_buf [ succ(sc_newpos) ] = '*' ) )
                                            THEN
                                                IF  (( a_cmd_part^.sp1p_buf [ sc_newpos + 2 ] = csp_unicode_mark ) AND
                                                    ( a_cmd_part^.sp1p_buf [ succ(sc_newpos) + 2 ] = '+' ) AND
                                                    ( scs_hint_allowed in a_scv.sc_states ))
                                                THEN
                                                    BEGIN
&                                                   ifdef TRACE
                                                    t01int4(ak_syn, 'start hint  ', pred(sc_newpos));
&                                                   endif
                                                    sc_symb   := s_hint;
                                                    sc_newpos := sc_newpos + 4;
                                                    END
                                                ELSE
                                                    BEGIN
&                                                   ifdef TRACE
                                                    t01int4(ak_syn, 'start commnt', sc_newpos - 2 );
&                                                   endif
                                                    WHILE (sc_newpos < a_cmd_part^.sp1p_buf_len)
                                                       AND
                                                       NOT ((
                                                       ( a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark ) AND
                                                       ( a_cmd_part^.sp1p_buf[ succ(sc_newpos) ] = '*' ))
                                                       AND
                                                       (( a_cmd_part^.sp1p_buf[ sc_newpos + 2 ] = csp_unicode_mark ) AND
                                                       ( a_cmd_part^.sp1p_buf[ succ(sc_newpos) + 2 ] = '/' ) )) DO
                                                     sc_newpos := sc_newpos + 2;
                                                    (*ENDWHILE*) 
                                                    IF  (sc_newpos < a_cmd_part^.sp1p_buf_len)
                                                    THEN
                                                     BEGIN
                                                     sc_newpos := sc_newpos + 2;
&                                                    ifdef TRACE
                                                     t01int4(ak_syn, 'stop comment', sc_newpos);
&                                                    endif
                                                     sc_newpos := sc_newpos + 2;
                                                     a011u_next_symbol(acv);
                                                     recursive_call := true; (* PTS 1118015 U.J. *)
                                                     END
                                                    ELSE
                                                     (* PTS 1119779 E.Z. *)
                                                     sc_newpos := sc_sypos + 2;
                                                    (*ENDIF*) 
                                                    END
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        END;
                                    (* comma *)
                                    ',' :
                                        BEGIN
                                        sc_symb := s_comma;
                                        sc_newpos := sc_newpos + 2;
                                        END;
                                    (* opening bracket *)
                                    '(' :
                                        BEGIN
                                        (* outer join predicate '(+)' *)
                                        i := sc_newpos + 2;
&                                       IFDEF TRACE
                                        t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, sc_sypos, sc_sypos + 10);
                                        t01p2int4 (ak_sem, 'sc_sypos    ', sc_sypos,
                                              'sc_newpos   ', sc_newpos);
&                                       ENDIF
                                        WHILE (i < a_cmd_part^.sp1p_buf_len)
                                              AND
                                              ((a_cmd_part^.sp1p_buf [ i + 1 ] = bsp_c1) OR
                                              (a_cmd_part^.sp1p_buf [ i + 1 ] = a01ht)   OR
                                              (a_cmd_part^.sp1p_buf [ i + 1 ] = a01lf)   OR
                                              (a_cmd_part^.sp1p_buf [ i + 1 ] = a01cr))
                                              AND
                                              (a_cmd_part^.sp1p_buf [ i ] = csp_unicode_mark) DO
                                            i := i + 2;
                                        (*ENDWHILE*) 
                                        IF  (i > a_cmd_part^.sp1p_buf_len)
                                            OR
                                            (a_cmd_part^.sp1p_buf [ i + 1 ] <> '+') OR
                                            (a_cmd_part^.sp1p_buf [ i ] <> csp_unicode_mark)
                                        THEN
                                            BEGIN
                                            sc_symb   := s_leftpar;
                                            sc_newpos := sc_newpos + 2;
                                            END
                                        ELSE
                                            BEGIN
                                            (* skip over '+' *)
                                            i := i + 2;
                                            WHILE (i < a_cmd_part^.sp1p_buf_len)
                                                  AND
                                                  ((a_cmd_part^.sp1p_buf [ i + 1 ] = bsp_c1) OR
                                                  (a_cmd_part^.sp1p_buf [ i + 1 ] = a01ht)   OR
                                                  (a_cmd_part^.sp1p_buf [ i + 1 ] = a01lf)   OR
                                                  (a_cmd_part^.sp1p_buf [ i + 1 ] = a01cr))
                                                  AND
                                                  (a_cmd_part^.sp1p_buf [ i ] = csp_unicode_mark) DO
                                                i := i + 2;
                                            (*ENDWHILE*) 
                                            IF  (i > a_cmd_part^.sp1p_buf_len)
                                                OR
                                                (a_cmd_part^.sp1p_buf [ i + 1 ] <> ')') OR
                                                (a_cmd_part^.sp1p_buf [ i ] <> csp_unicode_mark)
                                            THEN
                                                BEGIN
                                                sc_symb   := s_leftpar;
                                                sc_newpos := sc_newpos + 2;
                                                END
                                            ELSE
                                                BEGIN
                                                sc_symb   := s_outer_join;
                                                sc_newpos := i + 2;
&                                               IFDEF TRACE
                                                t01int4 (ak_sem, 's_outer_join', ord(s_outer_join));
&                                               ENDIF
                                                END;
                                            (*ENDIF*) 
                                            END;
                                        (*ENDIF*) 
&                                       IFDEF TRACE
                                        t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, sc_sypos, sc_sypos + 10);
                                        t01p2int4 (ak_sem, 'sc_sypos    ', sc_sypos,
                                              'sc_newpos   ', sc_newpos);
                                        t01int4 (ak_sem, 'i           ', i);
&                                       ENDIF
                                        END;
                                    (* closing bracket *)
                                    ')' :
                                        BEGIN
                                        sc_symb := s_rightpar;
                                        sc_newpos := sc_newpos + 2;
                                        END;
                                    (* semicolon *)
                                    ';' :
                                        IF  acv.a_scv.sc_eof_symb = s_semicolon
                                        THEN
                                            sc_symb := s_eof
                                        ELSE
                                            BEGIN
                                            sc_symb := s_semicolon;
                                            sc_newpos := sc_newpos + 2;
                                            END;
                                        (*ENDIF*) 
                                    '*' :
                                        BEGIN
                                        sc_symb := s_asterisk;
                                        sc_newpos := sc_newpos + 2;
                                        END;
                                    '&' :
                                        IF  acv.a_sqlmode = sqlm_internal
                                        THEN
                                            BEGIN
                                            sc_symb   := s_concat;
                                            sc_newpos := sc_newpos + 2;
                                            END
                                        ELSE
                                            BEGIN
                                            sc_symb := s_unknown;
                                            sc_newpos := sc_newpos + 2;
                                            END;
                                        (*ENDIF*) 
                                    '|' :
                                        BEGIN
                                        sc_symb   := s_unknown;
                                        sc_newpos := sc_newpos + 2;
                                        IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                                        THEN
                                            IF  (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ]='|')
                                                AND (a_cmd_part^.sp1p_buf [ sc_newpos ] = csp_unicode_mark)
                                                AND
                                                (acv.a_sqlmode <> sqlm_ansi)
                                            THEN
                                                BEGIN
                                                sc_symb   := s_concat;
                                                sc_newpos := sc_newpos + 2;
                                                END
                                            ELSE
                                                BEGIN
                                                sc_symb := s_unknown;
                                                sc_newpos := sc_newpos + 2;
                                                END;
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                        END;
                                    '%' :
                                        BEGIN
                                        REPEAT
                                            sc_newpos := sc_newpos + 2;
                                        UNTIL
                                            (sc_newpos > a_cmd_part^.sp1p_buf_len)
                                            OR
                                            (NOT(a_cmd_part^.sp1p_buf[ sc_newpos ] in a01digits)) OR
                                            (a_cmd_part^.sp1p_buf[ sc_newpos ] <> csp_unicode_mark);
                                        (*ENDREPEAT*) 
                                        IF  a_ex_kind <> only_syntax
                                        THEN
                                            sc_symb := s_unknown
                                        ELSE
                                            BEGIN
                                            sc_symb := s_identifier;
                                            sc_double_quote := 0;
                                            END
                                        (*ENDIF*) 
                                        END;
                                    (* undefsymbols *)
                                    OTHERWISE
                                        BEGIN
                                        sc_symb := s_unknown;
                                        sc_newpos := sc_newpos + 2;
                                        END
                                    END;
                                (*ENDCASE*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        (* PTS 1118015 U.J. *)
        IF  NOT recursive_call
        THEN
            sc_sylength := sc_newpos - sc_sypos - dif;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        sc_sypos := sc_sypos + hint;
        sc_symb  := s_eof
        END;
    (*ENDIF*) 
&   IFDEF TRACE
    t01p2int4 (ak_syn,'sc_sypos    ', sc_sypos,
          'sc_sylength ', sc_sylength);
&   ENDIF
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak011trigger_parameter (VAR acv : tak_all_command_glob);
 
VAR
      sy_pos  : tsp00_Int4;
      aux_scv : tak_scanner_glob;
 
BEGIN
sy_pos := acv.a_scv.sc_sypos;
a011u_next_symbol(acv);
IF  acv.a_scv.sc_symb = s_identifier
THEN
    BEGIN
    aux_scv := acv.a_scv;
    a011u_next_symbol (acv);
    IF  acv.a_scv.sc_symb = s_point
    THEN
        BEGIN
        a011u_next_symbol(acv);
        END
    ELSE
        acv.a_scv := aux_scv
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_scv.sc_symb <> s_identifier
THEN
    a07_b_put_error (acv, e_invalid_parameter, acv.a_scv.sc_sypos)
ELSE
    acv.a_scv.sc_symb := s_parameter_name;
(*ENDIF*) 
acv.a_scv.sc_sypos := sy_pos
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak011special_identifier (VAR acv : tak_all_command_glob;
            VAR dif : integer);
 
VAR
      is_blank_identifier : boolean;
      stringend           : boolean;
      c                   : char;
      pred_c              : char;
      j                   : tsp00_Int4;
      aux_int             : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_sypos := sc_newpos + 2;
    sc_symb             := s_identifier;
    sc_double_quote     := 2;
    is_blank_identifier := true;
    sc_newpos := sc_newpos + 2;
    WHILE (sc_newpos < a_cmd_part^.sp1p_buf_len)
          AND
          ((a_cmd_part^.sp1p_buf[ sc_newpos ] <> csp_unicode_mark) OR
          (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ] <> '"')) DO
        BEGIN
        IF  a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] <> bsp_c1
        THEN
            is_blank_identifier := false;
        (*ENDIF*) 
        sc_newpos := sc_newpos + 2;
        END;
    (*ENDWHILE*) 
    IF  sc_newpos > a_cmd_part^.sp1p_buf_len
    THEN
        BEGIN
        a07_error (acv, e_invalid_end_of_command,
              aux_int, aux_int);
        sc_symb := s_eof
        END
    ELSE
        BEGIN
        sc_newpos := sc_newpos + 2;
        IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
        THEN
            BEGIN
            IF  ((a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark) AND
                (a_cmd_part^.sp1p_buf [ sc_newpos + 1 ]  = '"'))
            THEN
                (* PTS 1117265 E.Z. *)
                BEGIN
                sc_states           := sc_states + [ scs_pack ];
                is_blank_identifier := false;
                (* at least '"' is the identifier *)
                stringend := false;
                j         := sc_newpos;
                pred_c    := ' ';
                c         := ' ';
                REPEAT
                    REPEAT
                        sc_newpos := sc_newpos + 2;
                        j := j + 2;
                        IF  sc_newpos < a_cmd_part^.sp1p_buf_len
                        THEN
                            BEGIN
                            pred_c := a_cmd_part^.sp1p_buf[ sc_newpos ];
                            c := a_cmd_part^.sp1p_buf[ sc_newpos + 1 ];
                            END;
                        (*ENDIF*) 
                    UNTIL
                        ((c = '"') AND (pred_c = csp_unicode_mark))
                        OR (sc_newpos > a_cmd_part^.sp1p_buf_len);
                    (*ENDREPEAT*) 
                    IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                    THEN (* Error: eof in the middle of a special id! *)
                        BEGIN
                        stringend := true;
                        sc_symb   := s_eof
                        END
                    ELSE (* c = '"' *)
                        BEGIN
                        sc_newpos := sc_newpos + 2;
                        IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                        THEN (* Correct terminated special id direct at eof *)
                            stringend := true
                        ELSE (* is there another double quote? *)
                            stringend := NOT ((a_cmd_part^.sp1p_buf[ sc_newpos ]
                                  = csp_unicode_mark) AND
                                  (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ]
                                  = '"'))
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                UNTIL
                    stringend;
                (*ENDREPEAT*) 
                dif := sc_newpos - j + 2;
                END
            ELSE
                dif := 2
            (*ENDIF*) 
            END
        ELSE
            dif := 2
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    (* PTS 1103134 E.Z. *)
    IF  is_blank_identifier AND (a_is_ddl <> no_ddl)
    THEN
        sc_symb := s_unknown;
&   IFDEF TRACE
    (*ENDIF*) 
    t01p2int4 (ak_syn, 'sc_symb     ', ord(sc_symb),
          'sc_newpos   ', sc_newpos);
    t01p2int4 (ak_syn, 'sc_sylength ', sc_sylength,
          'dif         ', dif);
&   ENDIF
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak011string_literal (VAR acv : tak_all_command_glob;
            VAR dif : integer);
 
VAR
      stringend      : boolean;
      j              : tsp00_Int4;
      aux_int        : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  sc_symb = s_unknown
    THEN
        sc_symb := s_string_literal;
    (*ENDIF*) 
    sc_sypos := sc_newpos + 2;
    REPEAT
        sc_newpos := sc_newpos + 2;
    UNTIL
        (sc_newpos > a_cmd_part^.sp1p_buf_len)
        OR
        ((a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark) AND
        (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] = ''''));
    (*ENDREPEAT*) 
    IF  sc_newpos > a_cmd_part^.sp1p_buf_len
    THEN
        BEGIN
        a07_error (acv, e_invalid_end_of_command,
              aux_int, aux_int);
        sc_symb := s_eof
        END
    ELSE
        BEGIN
        sc_newpos := sc_newpos + 2;
        IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
        THEN
            BEGIN
            IF  (a_cmd_part^.sp1p_buf[ sc_newpos ] = csp_unicode_mark) AND
                (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ] = '''')
            THEN
                BEGIN
                sc_states := sc_states + [ scs_pack ];
                stringend := false;
                j         := sc_newpos;
                REPEAT
                    REPEAT
                        sc_newpos := sc_newpos + 2;
                        j         := j + 2;
                    UNTIL
                        (sc_newpos > a_cmd_part^.sp1p_buf_len)
                        OR
                        ((a_cmd_part^.sp1p_buf[sc_newpos] = csp_unicode_mark) AND
                        (a_cmd_part^.sp1p_buf[sc_newpos+1] = ''''));
                    (*ENDREPEAT*) 
                    IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                    THEN (* Error: eof in the middle of a string! *)
                        BEGIN
                        a07_error (acv, e_invalid_end_of_command,
                              aux_int, aux_int);
                        stringend := true;
                        sc_symb   := s_eof
                        END
                    ELSE (* c = '''' *)
                        BEGIN
                        sc_newpos := sc_newpos + 2;
                        IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                        THEN (* Correct terminated string direct at eof *)
                            stringend := true
                        ELSE (* is there another quote? *)
                            stringend := NOT ((a_cmd_part^.sp1p_buf[ sc_newpos ]
                                  = csp_unicode_mark) AND
                                  (a_cmd_part^.sp1p_buf[ sc_newpos + 1 ]
                                  = ''''))
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                UNTIL
                    stringend;
                (*ENDREPEAT*) 
                dif := sc_newpos - j + 2
                END
            ELSE
                dif := 2
            (*ENDIF*) 
            END
        ELSE
            dif := 2
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (sc_newpos - sc_sypos - dif = 0) AND
        (a_sqlmode = sqlm_oracle)
    THEN
        sc_symb := s_identifier;
&   IFDEF TRACE
    (*ENDIF*) 
    t01p2int4 (ak_syn, 'sc_symb     ', ord(sc_symb),
          'sc_newpos   ', sc_newpos);
    t01p2int4 (ak_syn, 'sc_sylength ', sc_sylength,
          'dif         ', dif);
&   ENDIF
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a011uni_eqkey (VAR a : tak_keyword;
            VAR b     : tsp00_MoveObj;
            b_pos     : tsp00_Int4;
            length    : integer) : boolean;
 
VAR
      equal : boolean;
      i     : integer;
 
BEGIN
length := length DIV 2;
IF  length > sizeof (a)
THEN
    equal := false
ELSE
    BEGIN
    i     := 1;
    equal := true;
    WHILE (i <= length) AND equal DO
        BEGIN
        equal := (a [i] = b [b_pos-1+2*i]) AND
              (b[b_pos-2+2*i] = csp_unicode_mark);
        i     := i + 1
        END;
    (*ENDWHILE*) 
    IF  equal AND (i <= sizeof (a))
    THEN
        BEGIN
        IF  a [i] <> bsp_c1
        THEN
            equal := false
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
a011uni_eqkey := equal
END;
 
(*------------------------------*) 
 
PROCEDURE
      a011u_get_pwd (VAR acv : tak_all_command_glob;
            VAR put_node   : tsp00_Int2;
            VAR last_node  : tsp00_Int2);
 
VAR
      exit_loop    : boolean;
      (* PTS 1121518 E.Z. *)
      i            : tsp00_Int4;
      err_char_no  : tsp00_Int4;
      e            : tsp8_uni_error;
 
BEGIN
WITH acv, a_scv DO
    IF  a_returncode = 0
    THEN
        BEGIN
        sc_sylength := 0;
&       ifdef trace
        t01int4 (ak_sem, 'sc_newpos   ', sc_newpos);
&       endif
        exit_loop := false;
        WHILE NOT exit_loop DO
            IF  sc_newpos > a_cmd_part^.sp1p_buf_len
            THEN
                exit_loop := true
            ELSE
                (* PTS 1105437 GG *)
                IF  a01is_whitespace_char(a_cmd_part^.sp1p_buf, sc_newpos )
                THEN
                    sc_newpos := sc_newpos + 2
                ELSE
                    exit_loop := true;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDWHILE*) 
        IF  sc_newpos > a_cmd_part^.sp1p_buf_len
        THEN
            BEGIN
            (* PTS 1123663 E.Z. *)
            IF  a_is_ddl <> no_ddl
            THEN
                a07_error (acv, e_missing_identifier,
                      put_node, last_node)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF   (a_cmd_part^.sp1p_buf[sc_newpos] = csp_unicode_mark) AND
                (a_cmd_part^.sp1p_buf[sc_newpos+1] = '"')
            THEN
                BEGIN
                a011u_next_symbol (acv);
                IF  sc_symb <> s_identifier
                THEN
                    a07_error (acv, e_missing_identifier,
                          put_node, last_node)
                ELSE
                    BEGIN
                    IF  sc_sylength > mxsp_name
                    THEN
                        a07_error (acv, e_identifier_too_long, put_node, last_node);
                    (*ENDIF*) 
                    a01_put_node (acv, last_node);
                    put_node := last_node
                    END
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                sc_sypos := sc_newpos;
                (* PTS 1116725 E.Z. *)
                IF  (
                    (a_cmd_part^.sp1p_buf[sc_newpos  ] = csp_unicode_mark) AND
                    (a_cmd_part^.sp1p_buf[sc_newpos+1] in
                    a01letter_dig_under[a_sqlmode])
                    )
                    OR
                    (a_cmd_part^.sp1p_buf[sc_newpos+1] > chr(127))
                    OR
                    (a_cmd_part^.sp1p_buf[sc_newpos  ] <> csp_unicode_mark)
                THEN
                    BEGIN
                    exit_loop := false;
                    REPEAT
                        sc_newpos := sc_newpos + 2;
                        IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                        THEN
                            exit_loop := true
                        ELSE
                            exit_loop :=
                                  NOT (
                                  ((a_cmd_part^.sp1p_buf[sc_newpos  ] = csp_unicode_mark) AND
                                  ( a_cmd_part^.sp1p_buf[sc_newpos+1] in
                                  a01letter_dig_under[a_sqlmode])  )
                                  OR
                                  (a_cmd_part^.sp1p_buf[sc_newpos+1] > chr(127))
                                  OR
                                  (a_cmd_part^.sp1p_buf[sc_newpos  ] <> csp_unicode_mark)
                                  )
                        (*ENDIF*) 
                    UNTIL
                        exit_loop;
                    (*ENDREPEAT*) 
                    sc_symb     := s_identifier;
                    sc_sylength := sc_newpos - sc_sypos;
                    IF  sc_sylength > mxsp_name
                    THEN
                        a07_error (acv, e_identifier_too_long, put_node, last_node);
                    (* PTS 1121518 E.Z. *)
                    (*ENDIF*) 
                    i := sc_newpos - sc_sypos;
                    s80uni_trans (@a_cmd_part^.sp1p_buf[ sc_sypos ], sc_newpos - sc_sypos,
                          csp_unicode,
                          @a_cmd_part^.sp1p_buf[ sc_sypos ], i,
                          csp_unicode, [ uni_change_to_upper ], e, err_char_no);
                    IF  e <> uni_ok
                    THEN
                        a07_hex_uni_error (acv, e, err_char_no,
                              c_to_unicode, @a_cmd_part^.sp1p_buf[ sc_sypos - 1 + err_char_no ],
                              a_max_codewidth);
                    (*ENDIF*) 
                    a01_put_node (acv, last_node);
                    put_node := last_node
                    END
                ELSE
                    a07_error (acv,
                          e_missing_identifier, put_node, last_node);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
