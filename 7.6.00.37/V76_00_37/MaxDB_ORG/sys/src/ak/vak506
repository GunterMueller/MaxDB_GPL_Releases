.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK506$
.tt 2 $$$
.TT 3 $ElkeZ$Executing_values$$2000-09-13$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : Executing_values
=========
.sp
Purpose : Module in which the values for the commands to be
          executed are processed.
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a506fieldvalues (
                    VAR acv       : tak_all_command_glob;
                    VAR dmli      : tak_dml_info;
                    VAR frec      : tak_fill_rec;
                    viewkeybuf    : tak_sysbufferaddress;
                    VAR result    : tsp00_MoveObj;
                    resultBufSize : tsp00_Int4); (* PTS 1115085 *)
 
        PROCEDURE
              a506lock_fieldvalues (
                    VAR acv    : tak_all_command_glob;
                    VAR dmli   : tak_dml_info;
                    VAR frec   : tak_fill_rec;
                    viewkeybuf : tak_sysbufferaddress);
 
        PROCEDURE
              a506result_name (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info);
 
        PROCEDURE
              a506_init_numbercheckarray;
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01_il_b_identifier  : tsp00_KnlIdentifier;
              a01_zero_res_name    : tsp00_KnlIdentifier;
              a01defaultkey        : tgg00_SysInfoKey;
              a01identifier_size   : integer;
              a01char_size         : integer;
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05constraint_fulfilled (
                    VAR acv       : tak_all_command_glob;
                    VAR valbuf    : tgg00_Rec;
                    VAR tree      : tgg00_FileId;
                    constraint_id : integer);
 
        PROCEDURE
              a05_stamp_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tsp00_MoveObj;
                    destpos    : integer;
                    mv_dest    : integer);
 
        PROCEDURE
              a05_transaction_get (
                    VAR acv    : tak_all_command_glob;
                    VAR dest   : tsp00_MoveObj;
                    destpos    : integer;
                    mv_dest    : integer);
 
        PROCEDURE
              a05_nextval_get (
                    VAR acv      : tak_all_command_glob;
                    m2_type      : tgg00_MessType2;
                    VAR seq_id   : tgg00_Surrogate;
                    VAR seq_info : tgg00_SeqInfo;
                    VAR dest     : tsp00_MoveObj;
                    destpos      : integer;
                    VAR actlen   : integer);
 
        PROCEDURE
              a05qualification_test (
                    VAR acv        : tak_all_command_glob;
                    VAR m          : tgg00_MessBlock;
                    result_wanted  : boolean;
                    check_new_rec  : boolean;
                    error_pos      : integer;
                    VAR rec        : tgg00_Rec;
                    VAR result     : tsp00_MoveObj;
                    resultBufSize  : tsp00_Int4; (* PTS 1115085 *)
                    VAR result_len : integer);
 
        PROCEDURE
              a05serial (
                    VAR acv        : tak_all_command_glob;
                    VAR colinfo    : tak00_columninfo;
                    VAR treeid     : tgg00_FileId;
                    VAR moveobj    : tsp00_MoveObj;
                    moveobj_size   : tsp00_Int4;
                    number_pos     : tsp00_Int4;
                    VAR number_len : integer;
                    with_retpart   : boolean);
 
        PROCEDURE
              a05timestamp_get (
                    VAR acv      : tak_all_command_glob;
                    VAR src      : tsp00_MoveObj;
                    src_pos      : tsp00_Int4;
                    source_undef : boolean;
                    VAR dest     : tsp00_MoveObj;
                    dest_pos     : tsp00_Int4;
                    check_len    : tsp00_Int4;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a05_verify_not_null (
                    VAR acv        : tak_all_command_glob;
                    VAR valbuf     : tgg00_Rec;
                    VAR stackentry : tgg00_StackEntry);
 
        PROCEDURE
              a05int_range_check (VAR acv : tak_all_command_glob;
                    VAR dest  : tsp00_MoveObj;
                    destpos   : integer;
                    numlen    : integer;
                    cdatalen  : tsp00_Int2;
                    errorpos  : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_hex_uni_error (
                    VAR acv     : tak_all_command_glob;
                    uni_err     : tsp8_uni_error;
                    err_code    : tsp00_Int4;
                    to_unicode  : boolean;
                    bytestr     : tsp00_MoveObjPtr;
                    len         : tsp00_Int4 );
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_nb_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    VAR n    : tsp00_KnlIdentifier);
 
        PROCEDURE
              a07ak_system_error (
                    VAR acv  : tak_all_command_glob;
                    modul_no : integer;
                    id       : integer);
 
        PROCEDURE
              a07_uni_error (
                    VAR acv  : tak_all_command_glob;
                    uni_err  : tsp8_uni_error;
                    err_code : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10get_sysinfo (
                    VAR acv      : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_IsExtendedTempFile(
                    VAR acv    : tak_all_command_glob;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
      ------------------------------ 
 
        FROM
              SequenceWrapper : VAK104;
 
        FUNCTION
              ak104_CreateIncrementalMemorySequence (
                    allocator    : tgg00_VoidPtr;
                    refMode      : tak104_refcountMode;
                    VAR sequence : tsp00_MoveObjPtr;
                    msglist      : tak104_MsgList) : boolean;
 
        FUNCTION
              ak104_CreateVariableField_IMS (
                    sequence : tsp00_MoveObjPtr;
                    size     : tsp00_Int4;
                    VAR buf  : tsp00_MoveObjPtr;
                    msglist  : tak104_MsgList) : boolean;
 
        FUNCTION
              ak104_CloseCurrentField_IMS (
                    sequence : tsp00_MoveObjPtr;
                    size     : tsp00_Int4;
                    msglist  : tak104_MsgList) : boolean;
 
        FUNCTION
              ak104_GetFieldCount_IMS (
                    sequence : tsp00_MoveObjPtr) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Pseudo_fieldmap : VAK509;
 
        FUNCTION
              a509get_one_value (map_ptr : tsp00_MoveObjPtr;
                    value_no       : tsp00_Int2;
                    VAR value_ptr  : tsp00_MoveObjPtr;
                    VAR value_len  : tsp00_Int4;
                    VAR is_null    : boolean;
                    VAR is_default : boolean) : boolean;
 
        PROCEDURE
              a509set_long_value (map_ptr : tsp00_MoveObjPtr;
                    value_no : integer);
 
        FUNCTION
              a509get_datapos (map_ptr : tsp00_MoveObjPtr;
                    value_no : tsp00_Int2) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              DML_Parts : VAK55;
 
        PROCEDURE
              a55_const_from_resbuf (
                    VAR acv      : tak_all_command_glob;
                    VAR result   : tsp00_MoveObj;
                    VAR col_info : tak00_columninfo;
                    pars_kind    : tak_fp_kind_type;
                    VAR start    : integer;
                    VAR leng     : integer;
                    result_index : integer);
 
      ------------------------------ 
 
        FROM
              AK_Insert : VAK56;
 
        PROCEDURE
              a56one_default_value (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info;
                    VAR colinfo : tak00_columninfo;
                    with_length : tak_fp_kind_type);
 
        PROCEDURE
              a56temp_table_key (
                    VAR acv     : tak_all_command_glob;
                    VAR dmli    : tak_dml_info);
 
      ------------------------------ 
 
        FROM
              AK_Delete : VAK58;
 
        PROCEDURE
              a58_get_currentkey (
                    VAR acv         : tak_all_command_glob;
                    VAR currentnam  : tsp00_KnlIdentifier;
                    VAR sourcetabid : tgg00_Surrogate;
                    n_pos           : integer);
 
      ------------------------------ 
 
        FROM
              Execute_factor_col_function : VAK641;
 
        PROCEDURE
              a641_get_name (VAR acv : tak_all_command_glob;
                    part_ptr          : tsp1_part_ptr;
                    buf_pos           : tsp00_Int4;
                    buf_len           : tsp00_Int2;
                    get_schema        : boolean;
                    objecttype        : tsp00_Int2;
                    VAR returned_name : tsp00_KnlIdentifier);
 
      ------------------------------ 
 
        FROM
              KB_get : VKB71;
 
        PROCEDURE
              k71col_select (
                    VAR t           : tgg00_TransContext;
                    VAR sel         : tgg00_SelectFieldsParam;
                    VAR stack_desc  : tgg00_StackDesc;
                    VAR rec_buf     : tgg00_Rec;
                    VAR unqualified : boolean);
 
      ------------------------------ 
 
        FROM
              Single_Select : VKB720;
 
        PROCEDURE
              k720_test_subquery (
                    VAR trans   : tgg00_TransContext;
                    VAR datapart: tgg00_DataPart;
                    datapartsize: tsp00_Int4;
                    VAR mdesc   : tgg00_StackDesc;
                    VAR rec     : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              Single_Select_Part2 : VKB721;
 
        PROCEDURE
              k721longcol_insert_select (
                    VAR m              : tgg00_MessBlock;
                    VAR result         : tgg00_Rec;
                    VAR resf_id        : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01unicode        : boolean;
 
      ------------------------------ 
 
        FROM
              Check-Date-Time : VGG03;
 
        PROCEDURE
              g03fdcheck_date (
                    VAR sbuf  : tsp00_MoveObj;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    actlen    : integer;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              g03fdc_date (
                    sptr       : tsp00_MoveObjPtr;
                    dptr       : tsp00_MoveObjPtr;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03ftcheck_time (
                    VAR sbuf  : tsp00_MoveObj;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    actlen    : integer;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              g03ftc_time (
                    sptr       : tsp00_MoveObjPtr;
                    dptr       : tsp00_MoveObjPtr;
                    spos       : tsp00_Int4;
                    dpos       : tsp00_Int4;
                    actlen     : integer;
                    format     : tgg00_DateTimeFormat;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              g03dfchange_format_date (
                    VAR sbuf  : tsp00_Timestamp;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              g03tfchange_format_time (
                    VAR sbuf  : tsp00_C9;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              g03tsfchange_format_timestamp (
                    VAR sbuf  : tsp00_Timestamp;
                    VAR dbuf  : tsp00_MoveObj;
                    spos      : tsp00_Int4;
                    dpos      : tsp00_Int4;
                    format    : tgg00_DateTimeFormat;
                    language  : tsp00_C3;
                    VAR b_err : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04init_select_fields (
                    VAR sel       : tgg00_SelectFieldsParam;
                    data_addr     : tsp00_MoveObjPtr;
                    data_size     : tsp00_Int4;
                    work_st_addr  : tgg00_StackListPtr;
                    work_st_max   : tsp00_Int2;
                    work_buf_addr : tsp00_MoveObjPtr;
                    work_buf_size : tsp00_Int4;
                    curr_sqlmode  : tsp00_SqlMode;
                    fieldlistptr  : tgg00_FieldListsPtr);
 
        PROCEDURE
              g04value_locate (VAR stackentry : tgg00_StackEntry;
                    VAR mblock        : tgg00_MessBlock;
                    VAR operand_addr  : tsp00_MoveObjPtr;
                    VAR len           : integer);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20: VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (val     : tsp00_Int4;
                    source_swap : tsp00_SwapKind;
                    VAR destin  : tsp00_Int4;
                    destin_pos  : tsp00_Int4;
                    destin_swap : tsp00_SwapKind);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr (
                    VAR str : tsp00_MoveObj;
                    val   : char;
                    start : tsp00_Int4;
                    cnt   : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr1 (VAR str : tsp00_KnlIdentifier;
                    skip_val   : char;
                    start_pos  : tsp00_Int4;
                    length     : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30lnr_defbyte (
                    str       : tsp00_MoveObjPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GET-Conversions : VSP40;
 
        PROCEDURE
              s40glint (
                    VAR buf  : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    len      : integer;
                    VAR dest : tsp00_Int4;
                    VAR res  : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              PUT-Conversions : VSP41;
 
        PROCEDURE
              s41plrel (VAR buf : tsp00_MoveObj;
                    pos         : tsp00_Int4;
                    len         : integer;
                    frac        : integer;
                    source      : tsp00_Longreal;
                    VAR res     : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              Patterns : VSP49;
 
        PROCEDURE
              s49build_pattern (
                    VAR pat_buffer : tsp00_MoveObj;
                    start       : tsp00_Int4;
                    stop        : tsp00_Int4;
                    escape_char : char;
                    escape      : boolean;
                    string      : boolean;
                    sqlmode     : tsp00_SqlMode;
                    VAR ok      : boolean);
 
        PROCEDURE
              s49uni_build_pattern (
                    VAR pat_buffer : tsp00_MoveObj;
                    start       : tsp00_Int4;
                    stop        : tsp00_Int4;
                    escape_char : tsp00_C2;
                    escape      : boolean;
                    sqlmode     : tsp00_SqlMode;
                    VAR ok      : boolean);
 
      ------------------------------ 
 
        FROM
              Number-Arithmetic : VSP51;
 
        PROCEDURE
              s51kroun (
                    VAR source     : tsp00_MoveObj;
                    spos           : tsp00_Int4;
                    slen           : integer;
                    VAR result     : tsp00_MoveObj;
                    respos         : tsp00_Int4;
                    reslen         : integer;
                    resfrac        : integer;
                    VAR resbytelen : integer;
                    VAR ret        : tsp00_NumError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80 : VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vtimestamp (VAR ts : tsp00_Timestamp);
 
        PROCEDURE
              vUTCtimestamp (VAR timestamp : tsp00_Timestamp);
 
        FUNCTION
              vTimeZoneDelta : tsp00_Longreal; (* PTS 1109925 *)
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01buf (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_Buf;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01buf1 (
                    layer    : tgg00_Debug;
                    VAR buf  : tak_field_pars;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01char  (
                    level : tgg00_Debug;
                    nam : tsp00_Sname;
                    c   : char);
 
        PROCEDURE
              t01name (
                    level : tgg00_Debug;
                    nam : tsp00_Name);
 
        PROCEDURE
              t01longdescriptor (
                    debug     : tgg00_Debug;
                    long_desc : tsp00_LongDescriptor);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    bufaddr  : tsp00_MoveObjPtr);
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        FUNCTION
              ak104_CreateIncrementalMemorySequence;
 
              tak104_Allocator tgg00_VoidPtr
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_CreateVariableField_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_CloseCurrentField_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        FUNCTION
              ak104_GetFieldCount_IMS;
 
              tak104_IncrementalMemorySequence tsp00_MoveObjPtr
 
        PROCEDURE
              a55_const_from_resbuf;
 
              tsp00_Buf tsp00_MoveObj
 
        PROCEDURE
              a05qualification_test;
 
              tsp00_Buf tsp00_MoveObj
 
        PROCEDURE
              g03dfchange_format_date;
 
              tsp00_MoveObj tsp00_Timestamp
 
        PROCEDURE
              g03tfchange_format_time;
 
              tsp00_MoveObj tsp00_C9
 
        PROCEDURE
              g03tsfchange_format_timestamp;
 
              tsp00_MoveObj tsp00_Timestamp
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj  tsp00_Int4
 
        FUNCTION
              s30lnr1;
 
              tsp00_MoveObj tsp00_KnlIdentifier
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tak_field_pars
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1985-04-15
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-09-13
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
A506FIELDVALUES
.sp
This procedure is called by a505MOST_EXECUTE and
PARSINFO_WITH_VALUES and KEY_EXECUTE in such a way that all data
from the SQL_PACKET belonging to the (sub)command are entered
in the mess buffer.  The call from LOCK_FIELDVALUES leads only to
the reading of a datum since, in the case of LOCK commands, the layout
of the mess buffer is different from normal and severe length
restrictions must be complied with (erec.fno = erec.last_fno).
.br
For each datum to be input by the user, there is normally one
field-information record (except in the case of LIKE where there are
three, compare VAK65).  In addition, there are also
'field-information records' that force the internal jump forward to
specific positions or the usage of join-view keys.
.sp;.in +8;.un 8
gotopos After this 'field-information record', it is ensured that the
current mess buffer has part2 with an exactly specified length.  This is
necessary, for example, if the data must begin at particular positions
for search conditions since the pointers to them in the stack entries
are contained in part1 with fixed position information.  For this reason,
a 'field-information record' is generated with gotopos before a search
condition.  As a result, the part that has not yet been copied is copied
up to the specifed position from the parsed buffer to the current buffer.
.un 8
twuseold This 'field-information record' means that the first part (length
specified in fptopos) of part2 of the current mess buffer remains
as it is at this point in time.  This field-information record is then
used if the data in part2 are to be used for more than one KB request.
This is the case, for example, for complicated SELECTs, which are first
divided into several KB requests after the normal field-information
records have been generated.
.un 8
twviewkey This type of 'field-information record' designates the case when
a key must be transferred to the mess buffer from the buffer containing the
keys of the base records that participate in a change operation applied to a
join view.  Fpfrompos specifies the particular key (and the number of the
table from which it comes).
This key is always written to the beginning of part2 of the mess
buffer.
.un 8
copy_withlen This type is used for SELECT FIRST/LAST/NEXT/PREV
(see VAK62).
.un 8
varcolwithlen This is a real field-information record that specifies that
the value from the SQL_PACKET is fetched to the mess buffer;
only the fields designated with st_varcol are to receive a length byte.
This type is used for INSERT and for KEY... .
.un 8
allwithlen This is a real field-information record that causes all field
values to receive a length byte.  This type is used for UPDATE in the
SET clause.
.un 8
allwithoutlen This is a real field-information record that is responsible
for the fact that no values receive a length byte but, if necessary, only
the current length is identified in the associated stack entry.  This
type is used in the search condition.
.in -8;.sp
Fpmovebefore specifies the number of bytes that must be transferred from the
parsed mess buffer to the current buffer before the datum can be
fetched from the SQL_PACKET (mixture of data already known at the
time of parsing and unknown data).
.br
Ilen specifies the maximum number of bytes that belong to the value.
Start identifies the position in part2 of the mess buffer at which
the value is to begin.
.br
Selord_key only serves to simplify the next query.  In the case of
ordered SELECTs, the values must be filled to the required maximum
length.
.br
In the case of real field-information records, fptopos specifies the
number of the stack entry that contains the pointer to the value.  Since
it is not always ensured (e.g. join) that this stack entry is available
in the mess buffer that is currently being viewed, if necessary the
field value must be filled to its maximum length (to_fill).  This can
be omitted only if it is possible to write the actual
length of the value
to the stack entry (elen_var).
.br
Negative fpfrompos values designate very special data.
They are not fetched from the SQL_PACKET, but are available
internally: date(-1), time(-2), system number (STAMP, -3).  Of course,
these cannot already be determined at the time of parsing.  They are identified
via an RTE routine (vdattime) or via a query to KB (A05_STAMP_GET) and,
if necessary, entered in the mess buffer converted.
Since SURROGATE_MXGG00 = mv_date = mv_time, i.e. all three values have
the same length (8 bytes), one query
determines whether or not they must be
filled.
.br
For normal data (fpfrompos > 0, position in part2 of the SQL_PACKET)
a column description like the one that is also present in the
base records of the system-information records
must be generated in order to be able to call
VAL_FROM_DATAPART and undertake the type checking.
This description must include
the data type, length, number of decimal places, inoutlen, entry as to
whether or not it is a field of variable length
and the column numbers (for range
checks).  Since a maximum of 300 parameters can be contained in one
command and this information, together with the internal field-information
records, must fit in one system-information record (during parsing, sparr
has 2 buffers: 1 for the field-information records for the user, 1 for
internal use), one field-information record can be only 12-bytes long.
The entry for the decimal places is placed in fpdatatyp only under
unusual conditions.
.br
After VAL_FROM_DATAPART is called, leng contains the current length
that is entered in the associated stack entry, if necessary.
.br
The length byte, if one has been requested is then written to part2
and the entry concerning the key length for single-record commands
is raised.
.br
If a range check of the value is required (fprange), it is executed in
A05_VALUE_IN_RANGE.  If an error occurs, it is ensured via error-text
mechanisms in RANGE_ERROR that the user receives the name of the column
whose range is being violated.
.br
It is not permissible to simultaneously have a range definition for a
field and to specify NOT NULL for it.  Therefore, a check can be run in
the ELSE branch to determine whether a mandatory field has received the
NULL value.
.br
If the value belongs to a LIKE condition, an attempt is made to transform
this into an equal or BETWEEN condition.  A LIKE value usually appears in
the mess buffer 3 times (twice with st_dummy for use with strategies and
once for the actual LIKE condition).  It is also helpful for the strategies
if these values are transformed in such a way that they form a
BETWEEN condition (filled with binary zeros or ones beginning at the
first dummy).
.br
It is determined (for the 1st or 2nd value) whether filling is to take
place.  Then the value is gone through.  If it must be filled, it is
filled starting at the first placeholder ('*', '_', '%', '?').
For the first value, '00'h is entered.
ff'h is entered for the second one.  For the
third value, all placeholder
are replaced by the corresponding special
values (star1, any1).
.br
If all data must be entered without length information, this means that
pointers exist in the stack entries.  Therefore, the mess buffer must
be filled to the maximum length corresponding to the value to be read
at the moment (this amount of space would have to be left free during
parsing).
.sp 2
ONE_FIELD_COPY
.sp
A value that is already contained in part2 of the mess buffer is copied
to the end of part2 that is currently built.  In the case of a
'field-information record', this procedure is called with the type
copy_withlen.
.sp 2
RANGE_ERROR
.sp
In the event of an error, this procedure is called after A05_VALUE_IN_RANGE
from A506FIELDVALUES.  It assigns only the global information in VBD06 in
such a way that a subsequent A07_B_PUT_ERROR can use it to form an error text
containing the table name and column name of the column that has violated
the range condition (compare VAK07).
.sp 2
IN_MESS_BUF_MOVE
.sp
This procedure is called if data are to be copied from the parsed
mess buffer to the current mess buffer.  The length to be copied
is specified in total_leng and part1_pos designates the current position
in the parse-information record.  Each parse-information record that has a
successor is filled to the end (parsbuf_length).  The desired part is
copied; the only difficulty is that this part could be divided between
two parse-information records.
.sp 2
VAL_FROM_DATAPART
.sp
From the SQL_PACKET at the position valpos, this procedure fetches
a value that corresponds to the data type specified in colinfo.  The
data are partially checked for reliability and, if necessary,
converted.
.br
Destpos specifies the position at which the value is to begin in the
info part of part2 of the mess buffer.  Actlen contains the true
(written/to be written) length of the value.
.br
If the precompiler has not correctly filled the data part, an error
is supplied.
.br
If the null value is contained in the SQL_PACKET, the undef byte
is assigned NULL and the value is filled with '00'h.
.br
If the null value is not contained in the SQL_PACKET, the written
length of the value is identified in the case of variable-length fields
(actlen not including the undef byte).  In the case of values with a
fixed length, the inoutlen-1 is declared to be actlen.
.br
The undef byte is assigned according to the data type.  It is not
taken from the SQL_PACKET since it is not assumed that all
user components always assign it properly.
.br
A check is run because no ASCII field must have '00'h as
its last assigned byte since this would leads to problems in transitions
from page to page (BD side) if this value is inverted.
.br
For FIXED fields, a check is run to determine whether a number with the
specified exponents is displayable in this FIXED field.  For all
numerical values, a check is run in the case of an uneven number of
digits that are allowed in the field, to determine whether one half-byte
too many was written.  It is also checked whether all half-bytes
contain values from 0 to 9 only (no 'a' -  'f').  Otherwise, there
would be invalid numerical entries.
.br
Inputs to DATE and TIME fields must be checked for validity (no 70 min
or 19 months).  This is done via G03_DCHECK_DATE or G03_TCHECK_TIME.
The conversion is already done, if required, for the
check within s8 since all DATE/TIME values are checked as ASCII and
are stored later.  In addition, the TIME value (5-byte minimum length)
must be changed to 8 bytes and again stored in the SQL_PACKET in
this form.
.br
For all non-numerical values, the conversion is performed
when they are copied from the SQL_PACKET to the mess buffer.
.br
If the field value must be increased to its maximum length, it is filled
with the appropriate blank or '00'h.
.sp 2
LOCK_FIELDVALUES
.sp
There is a special variant of the mess buffer for lock commands.
40 lock entries are available with a length of 92 bytes each
(lockinfolength).
.sp
The number of lock entries is known (lock_count).  A loop is performed
via the lock entries.
.br
The lock entry that is next is copied from the parsed mess buffer
to the current one.  All field-information records that belong to this
lock entry are then processed in a loop.  Fpfrompos = 0 marks the last
field-information record of a lock entry.
.br
If WHERE CURRENT OF was specified for a lock entry, the 30 bytes to which
the key is to be written contain the name of the result set.  L_len is
located where len is normally located in part2 of the mess buffer.
Since it is operated on by the key procedures, l_len must be set to a
value so that the key is moved to the correct position.
.br
A58_GET_CURRENTKEY is called to take the current key from the result.
.br
Since these procedures cause an implicit change in
part2.keylen (the total length of the key is entered), this length must
be written to lockKeyLen_gg00 in the current lock entry and the value saved
beforehand must again be transferred by mlockc to the mess buffer.
.br
If the key does not SAPDB_PascalFill the 30 bytes provided, they are filled with
'00'h because these 30 bytes are always stored in the lock list and
compared, i.e. a defined value must also be in the bytes that are
actually  unimportant.  Since the result-set name was formerly located
in this part, nothing can be said about the layout of this
key part.  It must be assigned accordingly.
.br
If no CURRENT OF is to be used, A506FIELDVALUES is called once for each
parameter (last_fno = fno).  Part2.len must have been appropriately
assigned beforehand (see above) and fptopos must temporarily be set to 0
so that no stack entry for entering the data length is searched for in
A506FIELDVALUES.
.br
If the last key field was specified as a parameter, lockKeyLen_gg00 is set to
the maximum key length.  This means that the maximum length of this
field must be subtracted and its current length added.
This causes the length to be correctly assigned but only the first 30
bytes of the key are stored (the next lock entry overwrites the other
bytes).  The lock-list comparison ends in true only if both the true
length and the first 30 bytes of the key are alike.  Nevertheless, a
'key lock' can still, of course, lead to the locking of several records.
.br
The total length of part2 is the result of: number of lock entries *
lockinfolength + 4.
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_result_wanted  = true    (* a05qualification_test *);
      c_check_new_rec  = true    (* a05qualification_test *);
      c_string         = true    (* s49build_pattern *);
      c_trans_to_uni   = true;   (* a07_hex_uni_err *)
      c_undef          = true;
      c_move_before    = true;
 
VAR
      a506mantissacheckarr : PACKED ARRAY [0..255] OF boolean;
 
 
(*------------------------------*) 
 
PROCEDURE
      ak506normal_value (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR frec       : tak_fill_rec;
            VAR result     : tsp00_MoveObj;
            ind            : integer;
            VAR currentdif : integer;
            move_before    : boolean);
 
VAR
      b_err        : tgg00_BasisError;
      one_col      : tak00_columninfo;
      stop_search  : boolean;
      patt_ok      : boolean;
      to_fill      : boolean;
      len_add      : boolean;
      is_default   : boolean;
      in_datapart  : boolean;
      lendiff      : integer;
      iolen        : integer; (* length in order interface       *)
      (*                         may be different from cinoutlen *)
      (*                         ddate, dtimestamp               *)
      digits       : integer;
      seq_exp      : integer;
      errorpos     : integer;
      frompos      : integer;
      move_len     : integer;
      start        : integer;
      k            : integer;
      i            : integer;
      res          : tsp00_NumError;
      ic2          : tsp_int_map_c2;
      seq          : tak_sysbufferaddress;
      sysk         : tgg00_SysInfoKey;
      seq_name     : tsp00_KnlIdentifier;
      val_addr     : tsp00_MoveObjPtr;
      val_len      : integer;
      m_rowno      : tsp00_Int4;
      stackentry   : tgg00_StackEntry;
      msglist      : tak104_MsgList;
 
      sequenceinfo : RECORD
            seq_info : tgg00_SeqInfo;
            seq_id   : tgg00_Surrogate;
            seq_next : boolean;
            seq_fill : boolean;
      END;
 
 
BEGIN
WITH acv, a_mblock, mb_data^,
     dmli, d_sparr.px[ 1 ]^.sparsinfo, p_pars_infos[ ind ],
     frec DO
    BEGIN
&   ifdef TRACE
    t01int4 (ak_sem, '-fp_movebefo', fp_movebefore_v1);
    t01int4 (ak_sem, '-fp_frompos ', fp_frompos_v1);
    t01int4 (ak_sem, '-fp_extcolno', fp_rangeextcolno);
    t01int4 (ak_sem, '-fp_inoutlen', fp_inoutlen_v1);
    IF  fp_opt in fp_colset
    THEN
        t01name (ak_sem, 'OPTIONAL          ');
    (*ENDIF*) 
    IF  fp_like in fp_colset
    THEN
        t01name (ak_sem, 'LIKE CHECK        ');
    (*ENDIF*) 
    IF  fp_default in fp_colset
    THEN
        t01name (ak_sem, 'DEFAULT           ');
    (*ENDIF*) 
    IF  fp_escape in fp_colset
    THEN
        t01name (ak_sem, 'ESCAPE            ');
    (*ENDIF*) 
    IF  fp_serial in fp_colset
    THEN
        t01name (ak_sem, 'SERIAL            ');
&   endif
    (*ENDIF*) 
    IF  move_before AND (fp_movebefore_v1 > 0)
    THEN
        IF  (fp_kind = fp_val_all_without_l) OR
            (fp_kind = fp_rowno)             OR
            (fp_kind = fp_limit_offset)      OR
            (fp_kind = fp_upper_limit)
        THEN
            BEGIN
            fr_total_leng := fp_movebefore_v2 - mb_data_len;
            IF  fr_total_leng > 0
            THEN
                ak506in_mess_buf_move (acv, dmli, frec)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            fr_total_leng := fp_movebefore_v1;
            ak506in_mess_buf_move (acv, dmli, frec)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    len_add := true;
    lendiff := 0;
    in_datapart := true;
    iolen   := fp_inoutlen_v1;
    IF  (((fp_kind  = fp_val_varcol_with_len) AND
        (  fp_etype = st_varlongchar))
        OR
        (fp_kind = fp_val_all_with_len))
        AND
        (iolen > cak_maxvarcoliolen)
    THEN
        IF  ((fp_datatyp = dunicode) AND
            ((2 * fp_len_and_frac_v1.lf_datalen) + 1 <= cak_maxvarcoliolen))
            OR
            ((a_initial_packet_header.sp1h_mess_code in
            [ csp_unicode_swap, csp_unicode ]) AND
            (fp_datatyp in [ dcha,dvarchara ]) AND
            (fp_len_and_frac_v1.lf_datalen + 1 <= cak_maxvarcoliolen))
        THEN
            lendiff := 1
        ELSE
            lendiff := 2
        (*ENDIF*) 
    ELSE
        IF  (((fp_kind  = fp_val_varcol_with_len) AND
            (  fp_etype = st_varcol))
            OR
            (fp_kind = fp_val_all_with_len))
        THEN
            lendiff := 1;
        (*ENDIF*) 
    (*ENDIF*) 
    is_default := false;
    start := mb_data_len + lendiff + 1;
    mb_data_len := mb_data_len + lendiff;
    WITH one_col, ccolstack DO
        BEGIN
        IF  fp_datatyp in [ dsmallint, dinteger ]
        THEN
            cbinary := true
        ELSE
            cbinary := false;
        (*ENDIF*) 
        to_fill := false;
        IF  fp_kind = fp_val_all_without_l
        THEN
            BEGIN
            IF  ((fp_stackpos <= 0) OR
                ( fp_stackpos >= a_mblock.mb_qual^.mfirst_free))
            THEN
                to_fill := true
            ELSE
                IF  (NOT (mb_st^ [fp_stackpos].etype in [st_value, st_dummy])
                    OR
                    (mb_st^ [fp_stackpos].epos <> start))
                THEN
                    to_fill := true
                ELSE
                    IF  (mb_st^[ fp_stackpos ].etype = st_value) AND
                        ((mb_st^[ fp_stackpos ].ecol_tab[ 1 ] in
                        [ cgg04_param_in_between_expr, cgg04_param_in_in_expr]) OR
                        ((mb_st^[ fp_stackpos ].ecol_tab[ 1 ] = chr(0)) AND
                        (mb_st^[ fp_stackpos].ecol_tab[ 2 ] <> chr(0))))
                    THEN
                        to_fill := true
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            IF  (fp_datatyp = dunicode)             AND
                (fp_kind = fp_val_varcol_with_len ) AND
                (fp_etype in [ st_fixkey, st_fixcol ])
            THEN
                to_fill := true;
            (*ENDIF*) 
        (*ENDIF*) 
        cdatafrac := cak_frac_offset;
        IF  fp_kind in [ fp_val_varcol_with_len,
            fp_val_all_with_len,
            fp_val_from_res_buffer ]
        THEN
            BEGIN
            creccolno := fp_rangeextcolno;
            cextcolno := fp_rangeextcolno;
            END
        ELSE
            BEGIN
            creccolno := 0;
            cextcolno := 0
            END;
        (*ENDIF*) 
        errorpos := fp_frompos_v1;
        frompos  := fp_frompos_v1;
        cinoutlen     := iolen;
        ccolumnn_len  := chr(1);
        ccolumnn      := a01_il_b_identifier;
        ccolpropset   := [  ];
        etype         := fp_etype;
        eop           := op_none;
        epos          := 0;
        elen_var      := 0;
        ecol_tab[ 1 ] := chr(0);
        ecol_tab[ 2 ] := bsp_c1;
        IF  ((fp_frompos_v1 < 0 (* compare with fp_consts*)
            ) AND
            (fp_kind <> fp_val_from_res_buffer))
        THEN
            BEGIN
            IF  fp_frompos_v1 < cak_fp_nextval
            THEN
                BEGIN
                (* NEXTVAL, CURRVAL and SERIAL*)
                move_len := 0;
                IF  fp_serial in fp_colset
                THEN
                    BEGIN
                    cdatalen := fp_len_and_frac_v1.lf_fixed_datalen;
                    IF  cinoutlen > 0
                    THEN
                        BEGIN
                        (* constant was 0, get value from sequence cache *)
                        mbp_buf[start]   := csp_defined_byte;
                        mbp_buf[start+1] := csp_zero_exponent;
                        k                := 2;
                        a05serial (acv, one_col, mb_qual^.mtree,
                              mbp_buf, mb_data_size, start, k, (mb_type = m_insert));
                        END
                    ELSE
                        BEGIN
                        (* constant <> 0, send value to sequence cache *)
                        start   := start + cinoutlen;
                        mb_data_len := mb_data_len - lendiff;
                        k       := -cinoutlen;
                        to_fill := false;
                        len_add := false;
                        IF  (fp_kind in [ fp_val_varcol_with_len,
                            fp_selord_val_no_len ]) AND
                            (fp_etype in [st_fixkey, st_varkey])
                        THEN
                            BEGIN
                            mb_data_len := mb_data_len - mbp_keylen;
                            IF  (fp_etype = st_fixkey)
                            THEN
                                mbp_keylen := mbp_keylen - k
                            ELSE
                                IF  (fp_etype = st_varkey)
                                THEN
                                    mbp_keylen := start - 1 - cgg_rec_key_offset;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            mb_data_len := mb_data_len + mbp_keylen;
                            len_add     := true;
                            END;
                        (*ENDIF*) 
                        a05serial (acv, one_col, mb_qual^.mtree,
                              mbp_buf, mb_data_size, start-lendiff, k, (mb_type = m_insert));
                        lendiff := 0;
                        move_len := k;
                        END;
                    (*ENDIF*) 
                    fr_leng := k
                    END
                ELSE
                    BEGIN
                    IF  fp_kind = fp_val_all_without_l
                    THEN
                        BEGIN
                        fr_total_leng := fp_inoutlen_v2;
                        ak506in_mess_buf_move (acv, dmli, frec);
                        END;
                    (*ENDIF*) 
                    move_len :=
                          sizeof (sequenceinfo.seq_info) +
                          sizeof (sequenceinfo.seq_id  ) +
                          sizeof (sequenceinfo.seq_next);
                    sequenceinfo.seq_fill := false;
                    fr_total_leng := move_len;
                    ak506in_mess_buf_move (acv, dmli, frec);
                    mb_data_len := mb_data_len - move_len;
                    IF  ((fp_kind in [ fp_val_varcol_with_len,
                        fp_selord_val_no_len ]) AND
                        (fp_etype in [ st_varkey, st_fixkey ]))
                    THEN
                        mbp_keylen := mbp_keylen - move_len;
                    (*ENDIF*) 
                    SAPDB_PascalMove ('VAK506',   1,    
                          mb_data_size, sizeof(sequenceinfo.seq_info) +
                          sizeof (sequenceinfo.seq_id) +
                          sizeof (sequenceinfo.seq_next),
                          @mbp_buf, mb_data_len+1,
                          @sequenceinfo.seq_info, 1, move_len,
                          a_returncode);
                    (* cak_fp_nextval is negative ! *)
                    WITH sequenceinfo DO
                        IF  seq_next
                        THEN
                            a05_nextval_get (acv, mm_nil,
                                  seq_id, seq_info, mbp_buf, start, k)
                        ELSE
                            a05_nextval_get (acv, mm_same,
                                  seq_id, seq_info, mbp_buf, start, k);
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    frec.fr_leng := k;
                    IF  fp_datatyp = dfloat
                    THEN
                        digits := fp_len_and_frac_v1.lf_fixed_datalen
                    ELSE
                        digits := fp_len_and_frac_v1.lf_fixed_datalen -
                              fp_len_and_frac_v1.lf_frac + 1;
                    (*ENDIF*) 
                    seq_exp := ord (mbp_buf[start+1]);
                    IF  (digits < seq_exp - 192) OR
                        (digits < 64 - seq_exp )
                    THEN
                        BEGIN
                        sysk           := a01defaultkey;
                        sysk.stableid  := sequenceinfo.seq_id;
                        sysk.sentrytyp := cak_esequence;
                        a10get_sysinfo (acv, sysk, d_release, seq, b_err);
                        IF  b_err = e_ok
                        THEN
                            seq_name := seq^.ssequence.seq_name
                        ELSE
                            seq_name := a01_il_b_identifier;
                        (*ENDIF*) 
                        a07_nb_put_error (acv, e_num_overflow, 1, seq_name)
                        END;
                    (*ENDIF*) 
                    IF  fp_datatyp in [ dsmallint, dinteger ]
                    THEN
                        a05int_range_check (acv, mbp_buf, start, frec.fr_leng-1,
                              fp_len_and_frac_v1.lf_fixed_datalen, 1);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (cinoutlen > 0) AND (a_returncode = 0)
                THEN
                    IF  (to_fill OR
                        (fp_etype in [ st_fixkey, st_fixcol ]))
                    THEN
                        BEGIN
                        IF  iolen > frec.fr_leng
                        THEN
                            SAPDB_PascalFill ('VAK506',   2,    
                                  mb_data_size, @mbp_buf,
                                  start+frec.fr_leng,
                                  iolen-frec.fr_leng, csp_defined_byte,
                                  a_returncode);
                        (*ENDIF*) 
                        frec.fr_leng := iolen;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  fp_kind = fp_val_all_without_l
                THEN
                    mb_data_len := mb_data_len + move_len;
                (*ENDIF*) 
                currentdif := currentdif + move_len - frec.fr_leng;
                END
            ELSE
                BEGIN
                cinoutlen := iolen;
                CASE fp_datatyp OF
                    ddate :
                        cinoutlen := mxsp_date + 1;
                    dtime :
                        cinoutlen := mxsp_time + 1;
                    dtimestamp :
                        cinoutlen := mxsp_timestamp + 1;
                    dunicode :
                        cinoutlen :=
                              (2 * fp_len_and_frac_v1.lf_datalen ) + 1;
                    dcha, dvarchara :
                        cinoutlen :=
                              fp_len_and_frac_v1.lf_datalen + 1;
                    OTHERWISE
                        BEGIN
                        END
                    END;
                (*ENDCASE*) 
&               ifdef TRACE
                t01int4 (ak_sem, 'cinoutlen   ', cinoutlen);
                t01int4 (ak_sem, 'iolen       ', iolen    );
&               endif
                ak506datetime (acv, p_pars_infos[ fr_f_no ], frec,
                      cinoutlen, to_fill, start);
                END;
            (*ENDIF*) 
            frompos := -1
            END
        ELSE
            BEGIN
            cdatafrac := 0;
&           ifdef TRACE
            t01int4 (ak_sem, 'cinoutlen   ', cinoutlen);
            t01int4 (ak_sem, 'fp_datatyp  ', ord(fp_datatyp));
&           endif
            IF  fp_datatyp in [ dfixed, dsmallint, dinteger ]
            THEN
                BEGIN
                cdatatyp  := dfixed;
                cdatalen  := fp_len_and_frac_v1.lf_fixed_datalen;
                cdatafrac := fp_len_and_frac_v1.lf_frac;
                END
            ELSE
                IF  fp_datatyp = dfloat
                THEN
                    BEGIN
                    cdatatyp  := dfloat;
                    cdatalen  := fp_len_and_frac_v1.lf_fixed_datalen;
                    cdatafrac := fp_len_and_frac_v1.lf_frac;
                    END
                ELSE
                    BEGIN
                    cdatatyp := fp_datatyp;
                    cdatalen := fp_len_and_frac_v1.lf_datalen
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
&           ifdef TRACE
            t01int4 (ak_sem, 'startpos    ', start);
&           endif
            cinoutlen := iolen;
            CASE cdatatyp OF
                ddate :
                    cinoutlen := succ(mxsp_date);
                dtime :
                    cinoutlen := succ(mxsp_time);
                dtimestamp :
                    cinoutlen := succ(mxsp_timestamp);
                dunicode :
                    cinoutlen := succ(2 * cdatalen);
                dcha, dvarchara :
                    cinoutlen := succ(cdatalen);
                dstra, dstrb, dstruni,
                dlonga, dlonguni, dlongb :
                    cinoutlen := succ(SURROGATE_MXGG00);
                OTHERWISE
                    BEGIN
                    END
                END;
            (*ENDCASE*) 
&           ifdef TRACE
            t01int4 (ak_sem, 'cinoutlen   ', cinoutlen);
&           endif
            IF  fp_kind = fp_val_from_res_buffer
            THEN
                BEGIN
                a55_const_from_resbuf (acv, result, one_col,
                      fp_glob_fp_kind, start, i, fp_res_buf_index);
                fr_leng := i
                END
            ELSE
                IF  a_data_ptr = NIL
                THEN
                    a07_b_put_error (acv, e_too_short_datapart, 1)
                ELSE
                    BEGIN
                    IF  (NOT a_variable_input) AND
                        (a_data_ptr^[ fp_frompos_v1 ] = csp_default_byte)
                    THEN
                        is_default := true
                    ELSE
                        (* PTS 1106107 E.Z. *)
                        IF  a_variable_input
                        THEN
                            IF  (fp_kind = fp_val_all_without_l) OR
                                (fp_kind = fp_rowno)             OR
                                (fp_kind = fp_limit_offset)      OR
                                (fp_kind = fp_upper_limit)
                            THEN
                                BEGIN
                                in_datapart := false;
                                IF  acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist] = NIL
                                THEN
                                    BEGIN
                                    msglist := NIL;
                                    IF  NOT ak104_CreateIncrementalMemorySequence (acv.a_transinf.tri_trans.trAllocator_gg00,
                                        sessionCount_eak104, acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist], msglist)
                                    THEN
                                        a07_b_put_error (acv, e_no_more_memory, 3)
                                    ELSE
                                        ak506vardata_from_datapart (acv, fp_frompos_v1,
                                              one_col, frec, fp_colset);
                                    (*ENDIF*) 
&                                   ifdef TRACE
                                    t01addr (ak_sem, 'newfieldlist',
                                          acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist]);
&                                   endif
                                    END
                                ELSE
                                    ak506vardata_from_datapart (acv, fp_frompos_v1,
                                          one_col, frec, fp_colset)
                                (*ENDIF*) 
                                END
                            ELSE
                                ak506variable_data_from_datapart (acv, fp_frompos_v1, fp_kind,
                                      one_col, frec, to_fill, is_default)
                            (*ENDIF*) 
                        ELSE
                            ak506val_from_datapart (acv, fp_frompos_v1, fp_kind,
                                  one_col, iolen, frec, to_fill);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  is_default
                    THEN
                        IF  fp_default in fp_colset
                        THEN
                            BEGIN
                            mb_data_len := mb_data_len - lendiff;
                            lendiff     := 0;
                            ccolpropset := [  ];
                            a56one_default_value(acv, dmli, one_col,
                                  fp_kind);
                            IF  NOT a_variable_input
                            THEN
                                IF  a_input_data_pos < (fp_frompos_v1 + iolen)
                                THEN
                                    a_input_data_pos := fp_frompos_v1 + iolen;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            IF  a_returncode = 0
                            THEN
                                IF  ((fp_etype = st_varkey)
                                    OR
                                    (fp_etype = st_fixkey))
                                THEN
                                    fr_leng := mb_data_len -
                                          cgg_rec_key_offset - mbp_keylen
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END
                        ELSE
                            a07_b_put_error (acv,
                                  e_default_not_allowed, -errorpos)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  fp_serial in fp_colset
            THEN
                BEGIN
                i := fr_leng;
                a05serial (acv, one_col, mb_qual^.mtree,
                      mbp_buf, mb_data_size, start, i, (mb_type = m_insert));
                fr_leng := i
                END;
            (*ENDIF*) 
            IF  (NOT a_variable_input            AND
                (a_returncode = 0)               AND
                (fp_kind = fp_val_all_without_l) AND
                NOT to_fill)
            THEN
                mb_st^ [fp_stackpos].elen_var := fr_leng;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  lendiff = 1
            THEN
                mbp_buf[ start-1 ] := chr(fr_leng)
            ELSE
                IF  lendiff = 2
                THEN
                    BEGIN
                    ic2.map_int := fr_leng;
                    mbp_buf[ start-2 ] := ic2.map_c2[ 1 ];
                    mbp_buf[ start-1 ] := ic2.map_c2[ 2 ]
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  ((fp_kind in [ fp_val_varcol_with_len,
                fp_selord_val_no_len ]) AND
                (fp_etype in [ st_varkey, st_fixkey ]))
            THEN
                BEGIN
                mbp_keylen := mbp_keylen + fr_leng;
                IF  ((fp_kind = fp_selord_val_no_len) AND
                    (fp_stackpos <> 0))
                THEN (*  add up start-/stopkeylengths*)
                    WITH mb_st^ [fp_stackpos] DO
                        elen_var := elen_var + fr_leng;
                    (*ENDWITH*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  in_datapart AND (mbp_buf[ start ] = csp_undef_byte)
            THEN
                BEGIN
                IF  NOT (fp_opt in fp_colset)
                THEN
                    a07_b_put_error (acv,
                          e_mandatory_field_is_null, -errorpos)
                (*ENDIF*) 
                END
            ELSE
                CASE fp_kind OF
                    fp_rowno :
                        BEGIN
                        m_rowno := dmli.d_rowno;
                        IF  in_datapart
                        THEN
                            BEGIN
                            d_pos_in_parsbuf := d_pos_in_parsbuf + RESNUM_MXSP00;
                            s40glint (mbp_buf, start+1, 10, dmli.d_rowno, res)
                            END
                        ELSE
                            BEGIN
                            stackentry.etype    := st_value;
                            stackentry.eop      := op_none;
                            stackentry.ecol_pos := 0;
                            stackentry.epos     := cgg_param_valuefieldlist;
                            stackentry.elen_var :=
                                  ak104_GetFieldCount_IMS (mb_fieldlists[cgg_idx_param_valuefieldlist]) - 1;
                            g04value_locate (stackentry, acv.a_mblock, val_addr, val_len);
                            IF  val_len > 0
                            THEN
                                IF  val_addr^[1] <> csp_default_byte
                                THEN
                                    BEGIN
                                    s40glint(val_addr^, 2, (val_len - 2) * 2, dmli.d_rowno, res );
                                    IF  res = num_ok
                                    THEN
                                        IF  dmli.d_rowno <= 0
                                        THEN
                                            a07_b_put_error (acv, e_num_invalid, 1)
                                        ELSE
                                            BEGIN
                                            IF  fp_stackpos < 0
                                            THEN
                                                dmli.d_rowno := pred(dmli.d_rowno);
                                            (*ENDIF*) 
                                            END
                                        (*ENDIF*) 
                                    ELSE
                                        a07_b_put_error (acv, e_num_invalid, 1)
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  a_returncode = 0
                        THEN
                            BEGIN
                            IF  m_rowno <> cgg04_no_rowno_predicate
                            THEN
                                IF  dmli.d_rowno > 1
                                THEN
                                    dmli.d_rowno := m_rowno;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END;
                    fp_limit_offset :
                        IF  in_datapart
                        THEN
                            s40glint (mbp_buf, start+1, 10, dmli.d_limit_offset, res)
                        ELSE
                            BEGIN
                            stackentry.etype    := st_value;
                            stackentry.eop      := op_none;
                            stackentry.ecol_pos := 0;
                            stackentry.epos     := cgg_param_valuefieldlist;
                            stackentry.elen_var :=
                                  ak104_GetFieldCount_IMS (mb_fieldlists[cgg_idx_param_valuefieldlist]) - 1;
                            g04value_locate (stackentry, acv.a_mblock, val_addr, val_len);
                            IF  val_len > 0
                            THEN
                                IF  val_addr^[1] <> csp_default_byte
                                THEN
                                    BEGIN
                                    s40glint(val_addr^, 2, (val_len - 2) * 2, dmli.d_limit_offset, res );
                                    IF  res = num_ok
                                    THEN
                                        BEGIN
                                        IF  dmli.d_limit_offset <= 0
                                        THEN
                                            a07_b_put_error (acv, e_num_invalid, 1)
                                        (*ENDIF*) 
                                        END
                                    ELSE
                                        a07_b_put_error (acv, e_num_invalid, 1)
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    fp_upper_limit :
                        IF  in_datapart
                        THEN
                            s40glint (mbp_buf, start+1, 10, dmli.d_upper_limit, res)
                        ELSE
                            BEGIN
                            stackentry.etype    := st_value;
                            stackentry.eop      := op_none;
                            stackentry.ecol_pos := 0;
                            stackentry.epos     := cgg_param_valuefieldlist;
                            stackentry.elen_var :=
                                  ak104_GetFieldCount_IMS (mb_fieldlists[cgg_idx_param_valuefieldlist]) - 1;
                            g04value_locate (stackentry, acv.a_mblock, val_addr, val_len);
                            IF  val_len > 0
                            THEN
                                IF  val_addr^[1] <> csp_default_byte
                                THEN
                                    BEGIN
                                    s40glint(val_addr^, 2, (val_len - 2) * 2, dmli.d_upper_limit, res );
                                    IF  res = num_ok
                                    THEN
                                        BEGIN
                                        IF  dmli.d_upper_limit <= 0
                                        THEN
                                            a07_b_put_error (acv, e_num_invalid, 1)
                                        (*ENDIF*) 
                                        END
                                    ELSE
                                        a07_b_put_error (acv, e_num_invalid, 1)
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    OTHERWISE
                        BEGIN
                        END
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
            IF  fp_like in fp_colset
            THEN
                BEGIN
                (*  ================= *)
                (*  Replacement of    *)
                (*   '*','%','?','_'  *)
                (*  by 'xFF' and 'xFE'*)
                (*  in buffer         *)
                (*  ================= *)
                i := 2;
                stop_search := false;
                stackentry.etype    := st_value;
                stackentry.eop      := op_none;
                stackentry.ecol_pos := 0;
                IF  a_variable_input
                THEN
                    BEGIN
                    stackentry.epos     := cgg_param_valuefieldlist;
                    stackentry.elen_var :=
                          ak104_GetFieldCount_IMS (mb_fieldlists[cgg_idx_param_valuefieldlist]) - 1;
                    END
                ELSE
                    BEGIN
                    stackentry.epos     := start;
                    stackentry.elen_var := fr_leng;
                    END;
                (*ENDIF*) 
                g04value_locate (stackentry, acv.a_mblock, val_addr, val_len);
                IF  fp_datatyp = dunicode
                THEN
                    BEGIN
                    WHILE (i <= val_len) AND
                          NOT stop_search DO
                        IF  ((fp_escape in fp_colset) AND
                            (val_addr^[ i   ] = dmli.d_escape_char[ 1 ]) AND
                            (val_addr^[ i+1 ] = dmli.d_escape_char[ 2 ]))
                        THEN
                            i := i+4
                        ELSE
                            (* PTS 1123348 E.Z. *)
                            IF  (val_addr^ [ i   ] = csp_unicode_mark)
                                AND
                                (
                                (*
                                      ((a_sqlmode = sqlm_adabas) AND
                                      ((val_addr^[ i+1 ] = csp_ascii_star) OR
                                      ( val_addr^[ i+1 ] = csp_ascii_question_mark) OR
                                      ( val_addr^[ i+1 ] = csp_ascii_open_bracket))) OR
                                      *)
                                ( val_addr^[ i+1 ] = csp_ascii_underline) OR
                                ( val_addr^[ i+1 ] = csp_ascii_percent))
                            THEN
                                stop_search := true
                            ELSE
                                i := i + 2
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDWHILE*) 
                    END
                ELSE
                    BEGIN
                    WHILE (i <= val_len) AND
                          NOT stop_search DO
                        IF  ((fp_escape in fp_colset) AND
                            (val_addr^[ i ] = dmli.d_escape_char[ 2 ]))
                        THEN
                            i := i+2
                        ELSE
                            (* PTS 1123348 E.Z. *)
                            IF  (
                                (*
                                      ((a_sqlmode = sqlm_internal) AND
                                      ((val_addr^[ i ] = csp_ascii_star) OR
                                      ( val_addr^[ i ] = csp_ascii_question_mark) OR
                                      ( val_addr^[ i ] = csp_ascii_open_bracket))) OR
                                      *)
                                ( val_addr^[ i ] = csp_ascii_underline) OR
                                ( val_addr^[ i ] = csp_ascii_percent))
                            THEN
                                stop_search := true
                            ELSE
                                i := succ(i);
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDWHILE*) 
                    END;
                (*ENDIF*) 
&               ifdef TRACE
                t01int4 (ak_sem, 'fr_leng     ', fr_leng);
                t01int4 (ak_sem, 'i           ', i);
                t01int4 (ak_sem, 'cinoutlen   ', cinoutlen);
&               endif
                IF  fp_like1 in fp_colset
                THEN
                    BEGIN
                    IF  (i <= val_len)
                    THEN
                        IF  val_addr^[ 1 ] = csp_unicode_def_byte
                        THEN
                            SAPDB_PascalUnicodeFill ('VAK506',   3,    
                                  val_len, val_addr, i,
                                  frec.fr_leng + 1 - i, csp_unicode_blank,
                                  a_returncode)
                        ELSE
                            SAPDB_PascalFill ('VAK506',   4,    
                                  val_len, val_addr, i,
                                  frec.fr_leng + 1 - i, val_addr^[1],
                                  a_returncode)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  fp_like2 in fp_colset
                    THEN
                        BEGIN
                        IF  ((a_returncode = 0) AND
                            in_datapart         AND
                            (fp_kind = fp_val_all_without_l)
                            AND
                            NOT to_fill)
                        THEN
                            BEGIN
                            mb_st^ [fp_stackpos].elen_var := cinoutlen;
                            IF  i <= cinoutlen
                            THEN
                                SAPDB_PascalFill ('VAK506',   5,    
                                      cinoutlen, val_addr, i,
                                      cinoutlen - i, chr(255),
                                      a_returncode);
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  i <= val_len
                            THEN
                                SAPDB_PascalFill ('VAK506',   6,    
                                      val_len, val_addr, i,
                                      frec.fr_leng + 1 - i, chr(255),
                                      a_returncode);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  (acv.a_returncode = 0)
                THEN
                    BEGIN
                    patt_ok    := false;
                    IF  fp_datatyp = dunicode
                    THEN
                        s49uni_build_pattern (val_addr^, 2,
                              fr_leng, dmli.d_escape_char,
                              fp_escape in fp_colset,
                              sqlm_ansi, patt_ok)
                    ELSE
                        s49build_pattern (val_addr^, 2,
                              fr_leng, dmli.d_escape_char[ 2 ],
                              fp_escape in fp_colset, NOT c_string,
                              sqlm_ansi, patt_ok );
                    (*ENDIF*) 
                    IF  NOT patt_ok
                    THEN
                        IF  a_sqlmode = sqlm_ansi
                        THEN
                            a07_b_put_error ( acv,
                                  e_illegal_escape_sequence, 1)
                        ELSE
                            a07_b_put_error ( acv,
                                  e_invalid_pattern, 1);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
&               ifdef TRACE
                (*ENDIF*) 
                t01moveobj (ak_sem, val_addr^, 1, val_len);
&               endif
                END;
            (*ENDIF*) 
            IF  (frompos < 0)
                OR
                (fp_kind = fp_val_from_res_buffer)
                OR
                (NOT is_default AND in_datapart)
            THEN
                BEGIN
                END
            ELSE
                len_add := false;
            (*ENDIF*) 
            IF  len_add
            THEN
                BEGIN
                IF  fp_kind = fp_val_all_without_l
                THEN
                    BEGIN
                    mb_data_len := mb_data_len + cinoutlen;
                    d_pos_in_parsbuf := d_pos_in_parsbuf + cinoutlen;
                    END
                ELSE
                    mb_data_len := mb_data_len + fr_leng;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak506move_val_in_fieldlist (VAR acv : tak_all_command_glob;
            VAR fieldlist : tsp00_MoveObjPtr;
            value         : tsp00_MoveObjPtr;
            value_len     : tsp00_Int4;
            defined_byte  : tsp00_C1);
 
VAR
      ok           : boolean;
      msglist      : tak104_MsgList;
      valstart     : tsp00_MoveObjPtr;
 
BEGIN
msglist := NIL;
IF  fieldlist = NIL
THEN
    IF  NOT ak104_CreateIncrementalMemorySequence (acv.a_transinf.tri_trans.trAllocator_gg00,
        sessionCount_eak104, fieldlist, msglist)
    THEN
        a07_b_put_error (acv, e_no_more_memory, 3);
&   ifdef TRACE
    (*ENDIF*) 
(*ENDIF*) 
IF  fieldlist <> NIL
THEN
    t01addr (ak_sem, 'newfieldlist', fieldlist);
&endif
(*ENDIF*) 
IF  acv.a_returncode = 0
THEN
    BEGIN
    ok := ak104_CreateVariableField_IMS (fieldlist,
          succ(value_len), valstart, msglist);
    IF  ok
    THEN
        BEGIN
        IF  defined_byte[1] = csp_undef_byte
        THEN
            valstart^[1] := csp_undef_byte
        ELSE
            BEGIN
            valstart^[1] := defined_byte[1];
            SAPDB_PascalMove ('VAK506',   7,    
                  succ(value_len), succ(value_len), value, 1,
                  valstart, 2, value_len, acv.a_returncode)
            END;
        (*ENDIF*) 
        ok := ak104_CloseCurrentField_IMS (fieldlist,
              succ(value_len), msglist);
        IF  NOT ok
        THEN
            a07_b_put_error (acv, e_no_more_memory, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a506fieldvalues (
            VAR acv       : tak_all_command_glob;
            VAR dmli      : tak_dml_info;
            VAR frec      : tak_fill_rec;
            viewkeybuf    : tak_sysbufferaddress;
            VAR result    : tsp00_MoveObj;
            resultBufSize : tsp00_Int4); (* PTS 1115085 *)
 
CONST
      ak506swap_unicode_blank = '\20\00';
 
VAR
      currentdif   : integer;
      k            : integer;
      ind          : integer;
      escap_val    : tsp00_C3;
      escape_c2    : tsp00_C2;
      defined_byte : tsp00_C1;
      uniinlen     : integer;
      univallen    : integer;
      data_len     : tsp00_Int4;
      error        : tsp8_uni_error;
      err_char_no  : tsp00_Int4;
      value_ptr    : tsp00_MoveObjPtr;
      value_len    : tsp00_Int4;
      is_null      : boolean;
      is_default   : boolean;
      currentnam   : tsp00_KnlIdentifier;
      mblock       : tgg00_MessBlock;
 
BEGIN
currentdif := 0;
data_len   := 0;
dmli.d_first_longdesc_pos := 0;
dmli.d_cnt_longdesc       := 0;
dmli.d_longdesc_found     := false;
IF  (acv.a_initial_packet_header.sp1h_mess_code = csp_unicode) OR
    (acv.a_initial_packet_header.sp1h_mess_swap = sw_normal)
THEN
    frec.fr_uni_fill_c2 := csp_unicode_blank
ELSE
    frec.fr_uni_fill_c2 := ak506swap_unicode_blank;
(*ENDIF*) 
WHILE ((frec.fr_f_no <= frec.fr_last_fno) AND
      (acv.a_returncode = 0)) DO
    BEGIN
    (* *** Make shure, that index "fr_f_no" will not be changed     *)
    (*     in different WITH statements                         *** *)
    ind := frec.fr_f_no;
    WITH frec, acv.a_mblock, mb_data^,
         dmli.d_sparr.px[ 1 ]^.sparsinfo, p_pars_infos[ ind ] DO
        BEGIN
&       ifdef TRACE
        t01name (ak_sem, 'one parse-task :  ');
        t01int4 (ak_sem, '-reclen     ', mbp_reclen);
        t01int4 (ak_sem, '-datalen    ', mb_data_len);
        t01int4 (ak_sem, '-fp_kind    ', ord(fp_kind));
        t01int4 (ak_sem, '-fp_etype   ', ord(fp_etype));
        t01int4 (ak_sem, '-fp_datatyp ', ord(fp_datatyp     ));
        t01buf1 (ak_sem, p_pars_infos[ ind ], 5, 16);
        t01int4 (ak_sem, 'frec.fr_f_no', frec.fr_f_no);
        t01int4 (ak_sem, 'frec.fr_l_no', frec.fr_last_fno);
        t01int4 (ak_sem, '-fp_movebefo', fp_movebefore_v1);
        t01int4 (ak_sem, '-fp_frompos ', fp_frompos_v1);
        t01int4 (ak_sem, '-fp_extcolno', fp_rangeextcolno);
        t01int4 (ak_sem, '-fp_inoutlen', fp_inoutlen_v1);
&       endif
        CASE fp_kind OF
            fp_result_name :
                BEGIN
                (* skip pars info *)
                END;
            fp_catalog_column :
                ak506catalog_val_from_datapart (acv, fp_etype,
                      fp_frompos_v1, fp_inoutlen_v1);
            fp_current_of_key :
                BEGIN
                fr_total_leng := fp_curr_keylen+fp_movebefore_v5;
                ak506in_mess_buf_move (acv, dmli, frec);
                mb_data_len := mb_data_len-fp_curr_keylen;
                SAPDB_PascalMove ('VAK506',   8,    
                      mb_data_size, sizeof(currentnam), @mbp_buf,
                      mb_data_len + 1,
                      @currentnam, 1, sizeof(currentnam),
                      acv.a_returncode);
                a58_get_currentkey (acv, currentnam, p_tabid, 1);
                IF  ((mb_type  =  m_select_row) AND
                    ( mb_type2 <> mm_direct))
                THEN
                    mb_st^ [mb_qual^.mstrat_pos].elen_var := mbp_keylen;
                (*ENDIF*) 
                currentdif := fp_curr_keylen-mbp_keylen;
                END;
            fp_escape_val :
                dmli.d_escape_char := fp_escape_char;
            fp_fill_part2_to_len :
                BEGIN
                fr_total_leng := fp_len - mb_data_len - currentdif;
                ak506in_mess_buf_move (acv, dmli, frec);
                mb_data_len   := mb_data_len + currentdif;
                currentdif    := 0;
&               ifdef TRACE
                t01int4 (ak_sem, 'pos_in_parsb', dmli.d_pos_in_parsbuf);
                t01messblock (ak_sem, 'MBLOCK 506fi', acv.a_mblock);
&               endif
                dmli.d_pos_in_parsbuf := succ(fp_len);
&               ifdef TRACE
                t01messblock (ak_sem, 'MBLOCK 506fi', acv.a_mblock);
                t01int4 (ak_sem, 'total_leng  ', fr_total_leng);
                t01int4 (ak_sem, 'pos_in_parsb', dmli.d_pos_in_parsbuf);
&               endif
                END;
            fp_ordered_select_key :
                ak506one_field_copy (acv, dmli, frec);
            fp_pseudo_ins_select :
                BEGIN
                fr_total_leng := fp_movebeforev11;
                ak506in_mess_buf_move (acv, dmli, frec);
                ak506pseudo_insert_select (acv, dmli, fp_reccolno);
                WITH dmli.d_sparr.px[ dmli.d_sparr.pcount ]^.smessblock DO
                    dmli.d_pos_in_parsbuf := mbr_mess_block.mb_data_size + 1;
                (*ENDWITH*) 
                END;
            fp_reclen :
                BEGIN
                fr_total_leng := fp_movebefore_v4;
                ak506in_mess_buf_move (acv, dmli, frec);
                mb_data^.mbp_reclen := mb_data_len;
                IF  (mb_type = m_insert) AND
                    (mb_data^.mbp_reclen > MAX_RECLEN_GG00)
                THEN
                    a07_b_put_error (acv, e_too_long_record,
                          -MAX_RECLEN_GG00)
                (*ENDIF*) 
                END;
            fp_temp_table_key :
                BEGIN
                fr_total_leng := fp_movebeforev11;
                IF  ((fr_total_leng = 0) AND (dmli.d_pos_in_parsbuf = 1))
                THEN
                    BEGIN
                    fr_total_leng := cgg_rec_key_offset+2+SURROGATE_MXGG00;
                    ak506in_mess_buf_move (acv, dmli, frec);
                    END
                ELSE
                    BEGIN
                    ak506in_mess_buf_move (acv, dmli, frec);
                    IF  acv.a_mblock.mb_type <> m_insert_select
                    THEN
                        dmli.d_pos_in_parsbuf := dmli.d_pos_in_parsbuf + SURROGATE_MXGG00;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&               ifdef TRACE
                t01messblock (ak_sem, 'MBLOCK 506fi', acv.a_mblock);
&               endif
                a56temp_table_key (acv, dmli);
                IF  acv.a_mblock.mb_type = m_insert_select
                THEN
                    IF  mb_data_len < cgg_rec_key_offset+2+SURROGATE_MXGG00
                    THEN
                        mb_data_len := cgg_rec_key_offset+2+SURROGATE_MXGG00
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            fp_use_old_values_up_to_len :
                BEGIN
                IF  acv.a_mblock.mb_type = m_insert_select
                THEN
                    BEGIN
                    fr_total_leng := 2; (* byte 5,6 duplicate_spec*)
                    ak506in_mess_buf_move (acv, dmli, frec);
                    dmli.d_pos_in_parsbuf := succ(fp_len) - 2;
                    mb_data_len := fp_len
                    END
                ELSE
                    IF  dmli.d_corr = correlation
                    THEN
                        BEGIN
                        (* build new parsinfo incl. data *)
                        fr_total_leng := fp_len - mb_data_len - currentdif;
                        ak506in_mess_buf_move (acv,
                              dmli, frec);
                        END
                    ELSE
                        BEGIN
                        dmli.d_pos_in_parsbuf := succ(fp_len);
                        mb_data_len := fp_len;
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            fp_verify_constraint :
                BEGIN
                fr_total_leng := fp_movebeforev11;
                ak506in_mess_buf_move (acv, dmli, frec);
&               ifdef TRACE
                t01messblock (ak_sem, 'MBLOCK 506fi', acv.a_mblock);
&               endif
                a05constraint_fulfilled (acv,acv.a_mblock.mb_data^.mbp_rec,
                      acv.a_mblock.mb_qual^.mtree, fp_reccolno)
                END;
            fp_verify_not_null :
                BEGIN
                (* PTS 1001154 E.Z. *)
                a05_verify_not_null (acv, acv.a_mblock.mb_data^.mbp_rec,
                      fp_stackentry);
                END;
            fp_verify_view :
                BEGIN
                fr_total_leng := fp_movebeforev11;
                ak506in_mess_buf_move (acv, dmli, frec);
&               ifdef TRACE
                t01messblock (ak_sem, 'MBLOCK 506fi', acv.a_mblock);
&               endif
                mblock.mb_header       := acv.a_mblock.mb_header;
                mblock.mb_trailer      := acv.a_mblock.mb_trailer;
                mblock.mb_work_st      := acv.a_work_st_addr;
                mblock.mb_work_st_max  := acv.a_work_st_max;
                mblock.mb_workbuf      := acv.a_work_buf_addr;
                mblock.mb_workbuf_size := acv.a_work_buf_size;
                a05qualification_test (acv, mblock,
                      NOT c_result_wanted, c_check_new_rec, 1,
                      acv.a_mblock.mb_data^.mbp_rec, result, resultBufSize (* PTS 1115085 *), k);
                acv.a_mblock.mb_header := mblock.mb_header;
                IF  acv.a_returncode <> 0
                THEN
                    acv.a_transinf.tri_trans.trState_gg00 :=
                          mblock.mb_trns^.trState_gg00
                ELSE
                    acv.a_mblock.mb_qual^.mview_cnt := 0;
                (*ENDIF*) 
                END;
            fp_viewkey_to_mess_buf :
                WITH viewkeybuf^.sviewkey DO
                    BEGIN
                    dmli.d_pos_in_parsbuf := dmli.d_pos_in_parsbuf + cgg_rec_key_offset;
                    mbp_keylen  := vkjvkeylen;
                    mb_data_len := mbp_keylen+cgg_rec_key_offset;
                    currentdif := fp_curr_keylen-mbp_keylen;
                    SAPDB_PascalMove ('VAK506',   9,    
                          sizeof(vkjvkey), mb_data_size, @vkjvkey, 1,
                          @mbp_buf, cgg_rec_key_offset + 1,
                          mbp_keylen,
                          acv.a_returncode);
&                   ifdef TRACE
                    t01int4 (ak_sem, 'currentdif  ', currentdif);
&                   endif
                    END;
                (*ENDWITH*) 
            (* PTS 1111577 E.Z. *)
            fp_get_name_value :
                BEGIN
                fr_total_leng := fp_movebefore_v15 - mb_data_len;
                IF  fr_total_leng > 0
                THEN
                    ak506in_mess_buf_move (acv, dmli, frec);
                (*ENDIF*) 
                IF  acv.a_variable_input
                THEN
                    BEGIN
                    IF  NOT a509get_one_value (acv.a_input_data_map, fp_frompos_v15,
                        value_ptr, value_len, is_null, is_default)
                    THEN
                        a07ak_system_error (acv, 506, 2);
                    (*ENDIF*) 
                    IF  acv.a_returncode = 0
                    THEN
                        IF  is_null
                        THEN
                            a07_b_put_error (acv, e_mandatory_field_is_null,
                                  -fp_frompos_v15)
                        ELSE
                            BEGIN
                            currentnam := a01_il_b_identifier;
                            (* PTS 1112167 E.Z. *)
                            IF  g01unicode AND
                                (acv.a_initial_packet_header.sp1h_mess_swap <> sw_normal) AND
                                (acv.a_initial_packet_header.sp1h_mess_code <> csp_unicode)
                            THEN
                                BEGIN
                                (* PTS 1114579 E.Z. *)
                                univallen  := value_len;
                                s80uni_trans (value_ptr, value_len, csp_unicode_swap,
                                      value_ptr, univallen, csp_unicode,
                                      [ ], error, err_char_no);
                                IF  error <> uni_ok
                                THEN
                                    BEGIN
&                                   ifdef TRACE
                                    t01int4 (ak_sem, 'err_char_no ', err_char_no);
&                                   endif
                                    a07_hex_uni_error (acv, error,
                                          -fp_frompos_v15, c_trans_to_uni,
                                          @(value_ptr^[ err_char_no ]), acv.a_max_codewidth);
                                    END
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            a641_get_name (acv, acv.a_data_part,
                                  a509get_datapos (acv.a_input_data_map, fp_frompos_v15),
                                  value_len, (fp_sc_symbol = s_get_schema),
                                  ord(fp_objecttype[1]), currentnam);
                            (* PTS 1112167 E.Z. *)
                            (* leave data unchanged in the end in case we come along for the second time *)
                            IF  g01unicode AND
                                (acv.a_initial_packet_header.sp1h_mess_swap <> sw_normal) AND
                                (acv.a_initial_packet_header.sp1h_mess_code <> csp_unicode)
                            THEN
                                BEGIN
                                (* PTS 1114579 E.Z. *)
                                univallen  := value_len;
                                s80uni_trans (value_ptr, value_len, csp_unicode,
                                      value_ptr, univallen, csp_unicode_swap,
                                      [ ], error, err_char_no);
                                IF  error <> uni_ok
                                THEN
                                    BEGIN
&                                   ifdef TRACE
                                    t01int4 (ak_sem, 'err_char_no ', err_char_no);
&                                   endif
                                    a07_hex_uni_error (acv, error,
                                          -fp_frompos_v15, c_trans_to_uni,
                                          @(value_ptr^[ err_char_no ]), acv.a_max_codewidth);
                                    END
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  acv.a_returncode = 0
                            THEN
                                BEGIN
                                IF  g01unicode
                                THEN
                                    value_len := s30unilnr (@currentnam, csp_unicode_blank,
                                          1, sizeof(currentnam))
                                ELSE
                                    value_len := s30lnr1 (currentnam, csp_ascii_blank,
                                          1, sizeof(currentnam));
                                (*ENDIF*) 
                                IF  g01unicode
                                THEN
                                    defined_byte[1] := csp_unicode_def_byte
                                ELSE
                                    defined_byte[1] := csp_ascii_blank;
                                (*ENDIF*) 
                                ak506move_val_in_fieldlist (acv, acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist],
                                      @currentnam, value_len, defined_byte)
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  acv.a_data_ptr^[ fp_frompos_v15 ] = csp_undef_byte
                    THEN
                        a07_b_put_error (acv, e_mandatory_field_is_null,
                              -fp_frompos_v15)
                    ELSE
                        BEGIN
                        currentnam := a01_il_b_identifier;
                        (* PTS 1112167 E.Z. *)
                        IF  g01unicode AND
                            (acv.a_initial_packet_header.sp1h_mess_swap <> sw_normal) AND
                            (acv.a_initial_packet_header.sp1h_mess_code <> csp_unicode)
                        THEN
                            BEGIN
                            (* PTS 1114579 E.Z. *)
                            univallen  := fp_inoutlen_v1 - 1;
                            s80uni_trans (@acv.a_data_ptr^[ fp_frompos_v1+1], fp_inoutlen_v1 - 1,
                                  csp_unicode_swap,
                                  @acv.a_data_ptr^[ fp_frompos_v1+1], univallen, csp_unicode,
                                  [ ], error, err_char_no);
                            IF  error <> uni_ok
                            THEN
                                BEGIN
&                               ifdef TRACE
                                t01int4 (ak_sem, 'err_char_no ', err_char_no);
&                               endif
                                a07_hex_uni_error (acv, error,
                                      -(fp_frompos_v1+err_char_no), c_trans_to_uni,
                                      @(acv.a_data_ptr^[ fp_frompos_v1 + err_char_no ]),
                                      acv.a_max_codewidth);
                                END
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        a641_get_name (acv, acv.a_data_part,
                              succ(fp_frompos_v15), pred(fp_inoutlen_v15),
                              (fp_sc_symbol = s_get_schema), ord(fp_objecttype[1]),
                              currentnam);
                        (* PTS 1112167 E.Z. *)
                        (* leave data unchanged in the end in case we come along for the second time *)
                        IF  g01unicode AND
                            (acv.a_initial_packet_header.sp1h_mess_swap <> sw_normal) AND
                            (acv.a_initial_packet_header.sp1h_mess_code <> csp_unicode)
                        THEN
                            BEGIN
                            (* PTS 1114579 E.Z. *)
                            univallen  := fp_inoutlen_v1 - 1;
                            s80uni_trans (@acv.a_data_ptr^[ fp_frompos_v1+1], fp_inoutlen_v1 - 1,
                                  csp_unicode,
                                  @acv.a_data_ptr^[ fp_frompos_v1+1], univallen, csp_unicode_swap,
                                  [ ], error, err_char_no);
                            IF  error <> uni_ok
                            THEN
                                BEGIN
&                               ifdef TRACE
                                t01int4 (ak_sem, 'err_char_no ', err_char_no);
&                               endif
                                a07_hex_uni_error (acv, error,
                                      -(fp_frompos_v1+err_char_no), c_trans_to_uni,
                                      @(acv.a_data_ptr^[ fp_frompos_v1 + err_char_no ]),
                                      acv.a_max_codewidth);
                                END
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  currentnam = a01_il_b_identifier
                        THEN
                            BEGIN
                            mbp_buf[mb_data_len+1] := csp_undef_byte;
                            SAPDB_PascalFill ('VAK506',  10,    
                                  mb_data_size, @mbp_buf, mb_data_len+2,
                                  fp_inoutlen_v15 - 1, csp_defined_byte,
                                  acv.a_returncode)
                            END
                        ELSE
                            BEGIN
                            IF  fp_datatyp = dunicode
                            THEN
                                mbp_buf[mb_data_len+1] := csp_unicode_def_byte
                            ELSE
                                mbp_buf[mb_data_len+1] := csp_ascii_blank;
                            (*ENDIF*) 
                            SAPDB_PascalMove ('VAK506',  11,    
                                  sizeof(currentnam), mb_data_size, @currentnam, 1,
                                  @mbp_buf, mb_data_len+2, sizeof(currentnam),
                                  acv.a_returncode);
                            IF  mbp_buf[mb_data_len+1] = csp_unicode_def_byte
                            THEN
                                SAPDB_PascalUnicodeFill ('VAK506',  12,    
                                      mb_data_size, @mbp_buf, mb_data_len+2+sizeof(currentnam),
                                      fp_inoutlen_v15 - 1 - sizeof(currentnam), csp_unicode_blank,
                                      acv.a_returncode)
                            ELSE
                                SAPDB_PascalFill ('VAK506',  13,    
                                      mb_data_size, @mbp_buf, mb_data_len+2+sizeof(currentnam),
                                      fp_inoutlen_v15 - 1 - sizeof(currentnam), csp_ascii_blank,
                                      acv.a_returncode)
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        mb_data_len := mb_data_len + fp_inoutlen_v15;
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            OTHERWISE
                IF  fp_datatyp in [dstra, dstrb, dstruni,
                    dlonga, dlonguni, dlongb]
                THEN
                    BEGIN
                    ak506long_support (acv, dmli, frec, result, ind, currentdif);
                    IF  data_len > acv.a_mblock.mb_data_len
                    THEN (* this may happen in case of inout parameters of db-procedures *)
                        acv.a_mblock.mb_data_len := data_len;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  ((fp_kind = fp_val_all_without_l) AND
                        (fp_escape in fp_colset) AND
                        NOT (fp_like in fp_colset))
                    THEN
                        IF  acv.a_data_ptr = NIL
                        THEN
                            a07_b_put_error (acv, e_too_short_datapart, 1)
                        ELSE
                            BEGIN
                            (* escape_char as parameter *)
                            escap_val := '   ';
                            IF  acv.a_variable_input
                            THEN
                                BEGIN
                                IF  NOT a509get_one_value (acv.a_input_data_map, fp_frompos_v1,
                                    value_ptr, value_len, is_null, is_default)
                                THEN
                                    a07ak_system_error (acv, 506, 5)
                                ELSE
                                    BEGIN
                                    escap_val[2] := value_ptr^[ 1 ];
                                    IF  value_len = 2
                                    THEN
                                        escap_val[3] := value_ptr^[ 2 ];
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                escap_val[1] := acv.a_data_ptr^[ fp_frompos_v1   ];
                                escap_val[2] := acv.a_data_ptr^[ fp_frompos_v1+1 ];
                                escap_val[3] := acv.a_data_ptr^[ fp_frompos_v1+2 ];
                                END;
                            (*ENDIF*) 
                            IF  escap_val[1] = csp_undef_byte
                            THEN
                                a07_b_put_error (acv,
                                      e_mandatory_field_is_null,
                                      -fp_frompos_v1)
                            ELSE
                                BEGIN
                                IF  (
                                    (acv.a_initial_packet_header.sp1h_mess_code
                                    < csp_unicode_swap) AND
                                    ( fp_datatyp = dcha)
                                    ) OR
                                    (fp_datatyp = dchb)
                                THEN
                                    dmli.d_escape_char[ 2 ] := escap_val[2]
                                ELSE
                                    IF  fp_datatyp = dunicode
                                    THEN
                                        IF  acv.a_initial_packet_header.sp1h_mess_swap = sw_normal
                                        THEN
                                            BEGIN
                                            dmli.d_escape_char[ 1 ] := escap_val[2];
                                            dmli.d_escape_char[ 2 ] := escap_val[3];
                                            END
                                        ELSE
                                            BEGIN
                                            dmli.d_escape_char[ 1 ] := escap_val[3];
                                            dmli.d_escape_char[ 2 ] := escap_val[2];
                                            END
                                        (*ENDIF*) 
                                    ELSE
                                        BEGIN
                                        IF  (acv.a_initial_packet_header.sp1h_mess_code in
                                            [ csp_unicode, csp_unicode_swap ]) AND
                                            NOT acv.a_ascii_in_and_output (* new feature *)
                                        THEN
                                            BEGIN
                                            uniinlen := 2;
                                            univallen := 2;
                                            s80uni_trans (@escap_val[2], uniinlen,
                                                  acv.a_initial_packet_header.sp1h_mess_code,
                                                  @escape_c2, univallen, csp_unicode,
                                                  [ ], error, err_char_no);
                                            IF  error = uni_ok
                                            THEN
                                                BEGIN
                                                uniinlen := 1;
                                                s80uni_trans (@escape_c2, univallen, csp_unicode,
                                                      @dmli.d_escape_char[ 2 ], uniinlen, csp_ascii,
                                                      [ ], error, err_char_no);
                                                END;
                                            (*ENDIF*) 
                                            IF  error <> uni_ok
                                            THEN
                                                BEGIN
&                                               ifdef TRACE
                                                t01int4 (ak_sem, 'err_char_no ', err_char_no);
&                                               endif
                                                a07_hex_uni_error (acv, error,
                                                      -(fp_frompos_v1+err_char_no), c_trans_to_uni,
                                                      @(escap_val[ err_char_no ]),
                                                      acv.a_max_codewidth);
                                                END
                                            (*ENDIF*) 
                                            END
                                        ELSE
                                            dmli.d_escape_char[ 2 ] := escap_val[2];
                                        (*ENDIF*) 
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    ELSE
                        BEGIN
                        ak506normal_value (acv, dmli, frec,
                              result, ind, currentdif, c_move_before);
                        IF  data_len > acv.a_mblock.mb_data_len
                        THEN (* this may happen in case of inout parameters of db-procedures *)
                            acv.a_mblock.mb_data_len := data_len;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
            END;
        (*ENDCASE*) 
        END;
    (*ENDWITH*) 
    IF  acv.a_mblock.mb_data_len > data_len
    THEN
        data_len := acv.a_mblock.mb_data_len;
    (*ENDIF*) 
    frec.fr_f_no := succ(frec.fr_f_no)
    END;
(*ENDWHILE*) 
&ifdef trace
t01messblock (ak_sem, 'MBLOCK 506fi', acv.a_mblock);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a506lock_fieldvalues (
            VAR acv    : tak_all_command_glob;
            VAR dmli   : tak_dml_info;
            VAR frec   : tak_fill_rec;
            viewkeybuf : tak_sysbufferaddress);
 
VAR
      last_value     : boolean;
      i              : integer;
      currentnam     : tsp00_KnlIdentifier;
      nil_surrogate  : tgg00_Surrogate;
 
BEGIN
WITH dmli, frec, acv, a_mblock, mb_qual^ DO
    BEGIN
    nil_surrogate := cgg_zero_id;
    fr_f_no       := 1;
    i             := 1;
    a_mblock.mb_data_len := cgg_rec_key_offset;
    d_pos_in_parsbuf := d_pos_in_parsbuf + cgg_rec_key_offset;
&   ifdef trace
    t01int4 (ak_sem, 'lock_count  ', mlock_cnt);
    t01int4 (ak_sem, 'p_cnt_infos ',
          d_sparr.px[ 1 ]^.sparsinfo.p_cnt_infos);
&   endif
    WHILE ((i <= mlock_cnt) AND (a_returncode = 0)) DO
        BEGIN
&       ifdef TRACE
        t01messblock (ak_sem, 'MBLOCK 506lo', a_mblock);
&       endif
        IF  ((mlock[ i ].lockMode_gg00 <> lckTabShare_egg00) AND
            (mlock[ i ].lockMode_gg00 <> lckTabExcl_egg00))
        THEN
            BEGIN
            mlock[ i ].lockKeyPos_gg00 := a_mblock.mb_data_len-cgg_rec_key_offset+1;
            IF  fr_f_no <= d_sparr.px[ 1 ]^.sparsinfo.p_cnt_infos
            THEN
                BEGIN
                last_value := false;
                WHILE (NOT last_value AND (a_returncode = 0)) DO
                    BEGIN
                    WITH d_sparr.px[ 1 ]^.sparsinfo,
                         p_pars_infos[ fr_f_no ] DO
                        IF  fp_kind = fp_last_lock
                        THEN
                            BEGIN
                            IF  fp_movebefore_v4 > 0
                            THEN
                                BEGIN
                                fr_total_leng := fp_movebefore_v4;
                                ak506in_mess_buf_move (acv,
                                      dmli, frec)
                                END;
                            (*ENDIF*) 
                            last_value := true;
                            WITH mlock[ i ] DO
                                lockKeyLen_gg00 :=
                                      a_mblock.mb_data_len -
                                      cgg_rec_key_offset + 1 - lockKeyPos_gg00
                            (*ENDWITH*) 
                            END
                        ELSE
                            IF  fp_kind = fp_lock_val
                            THEN
                                BEGIN
                                fr_last_fno := fr_f_no;
                                a506fieldvalues (acv, dmli, frec, viewkeybuf,
                                      a_mblock.mb_data^.mbp_buf, a_mblock.mb_data_size);
                                END
                            ELSE
                                WITH mlock[ i ] DO
                                    BEGIN
                                    fr_f_no       := succ(fr_f_no);
                                    fr_total_leng := fp_curr_keylen+fp_movebefore_v5;
                                    ak506in_mess_buf_move (acv,
                                          dmli, frec);
&                                   ifdef TRACE
                                    t01int4 (ak_sem, 'total_leng  ',
                                          fr_total_leng);
                                    t01int4 (ak_sem, 'pos_in_parsb',
                                          d_pos_in_parsbuf);
                                    t01messblock (ak_sem, 'MBLOCK 506lo', a_mblock);
&                                   endif
                                    mb_data_len := mb_data_len-fp_curr_keylen;
                                    SAPDB_PascalMove ('VAK506',  14,    
                                          mb_data_size, sizeof (currentnam),
                                          @mb_data^.mbp_buf,
                                          mb_data_len+1, @currentnam, 1,
                                          sizeof(currentnam),
                                          a_returncode);
                                    a58_get_currentkey (acv, currentnam,
                                          nil_surrogate, 1);
                                    END;
                                (*ENDWITH*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDWITH*) 
                    END;
                (*ENDWHILE*) 
                fr_f_no := succ(fr_f_no);
&               ifdef TRACE
                t01messblock (ak_sem, 'MBLOCK 506lo', a_mblock);
&               endif
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        i := succ(i)
        END;
    (*ENDWHILE*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a506result_name (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info);
 
VAR
      movelen     : integer;
      err_char_no : tsp00_Int4;
      uni_err     : tsp8_uni_error;
      value_ptr   : tsp00_MoveObjPtr;
      value_len   : tsp00_Int4;
      is_null     : boolean;
      is_default  : boolean;
 
BEGIN
WITH acv, dmli.d_sparr.px[ 1 ]^.sparsinfo DO
    IF  p_cnt_infos > 0
    THEN
        WITH p_pars_infos[ 1 ] DO
            IF  fp_kind = fp_result_name
            THEN
                IF  a_variable_input
                THEN
                    BEGIN
                    dmli.d_resname := a01_il_b_identifier;
                    IF  NOT a509get_one_value (a_input_data_map, fp_fromposv14,
                        value_ptr, value_len, is_null, is_default)
                    THEN
                        a07ak_system_error (acv, 506, 3);
                    (*ENDIF*) 
                    IF  a_returncode = 0
                    THEN
                        BEGIN
                        IF  g01unicode
                        THEN
                            BEGIN
                            movelen := sizeof (dmli.d_resname);
                            IF  (acv.a_initial_packet_header.sp1h_mess_swap <> sw_normal) AND
                                (acv.a_initial_packet_header.sp1h_mess_code <> csp_unicode)
                            THEN
                                s80uni_trans (value_ptr, value_len, csp_unicode_swap,
                                      @dmli.d_resname, movelen, csp_unicode, [ ],
                                      uni_err, err_char_no)
                            ELSE
                                s80uni_trans (value_ptr, value_len, csp_unicode,
                                      @dmli.d_resname, movelen, csp_unicode, [ ],
                                      uni_err, err_char_no);
                            (*ENDIF*) 
                            IF  (uni_err <> uni_ok) AND
                                (uni_err <> uni_dest_too_short)
                            THEN
                                a07_b_put_error (acv, e_invalid_tablename, 1)
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            SAPDB_PascalMove ('VAK506',  15,    
                                  a_data_length, sizeof (dmli.d_resname),
                                  @value_ptr^, 1, @dmli.d_resname, 1, value_len,
                                  a_returncode);
                            END;
                        (*ENDIF*) 
                        IF  dmli.d_resname = a01_zero_res_name
                        THEN
                            a07_b_put_error (acv, e_invalid_parameter, -fp_fromposv14)
                        ELSE
                            dmli.d_resname_found := true;
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    IF  g01unicode
                    THEN
                        BEGIN
                        movelen := sizeof (dmli.d_resname);
                        IF  (acv.a_initial_packet_header.sp1h_mess_swap <> sw_normal) AND
                            (acv.a_initial_packet_header.sp1h_mess_code <> csp_unicode)
                        THEN
                            s80uni_trans (@a_data_ptr^[ fp_fromposv14 + 1 ],
                                  fp_dataiolenv14 - 1, csp_unicode_swap,
                                  @dmli.d_resname, movelen, csp_unicode, [ ],
                                  uni_err, err_char_no)
                        ELSE
                            s80uni_trans (@a_data_ptr^[ fp_fromposv14 + 1 ],
                                  fp_dataiolenv14 - 1, csp_unicode,
                                  @dmli.d_resname, movelen, csp_unicode, [ ],
                                  uni_err, err_char_no);
                        (*ENDIF*) 
                        IF  (uni_err <> uni_ok) AND
                            (uni_err <> uni_dest_too_short)
                        THEN
                            a07_b_put_error (acv, e_invalid_tablename, 1)
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        SAPDB_PascalMove ('VAK506',  16,    
                              a_data_length, sizeof (dmli.d_resname),
                              @a_data_ptr^, fp_fromposv14 + 1,
                              @dmli.d_resname, 1, fp_dataiolenv14 - 1,
                              a_returncode);
                        END;
                    (*ENDIF*) 
                    IF  dmli.d_resname = a01_zero_res_name
                    THEN
                        a07_b_put_error (acv, e_invalid_parameter, -fp_fromposv14)
                    ELSE
                        dmli.d_resname_found := true;
                    (*ENDIF*) 
                    IF  a_input_data_pos <  (fp_fromposv14 + fp_datalenv14)
                    THEN
                        a_input_data_pos :=  fp_fromposv14 + fp_datalenv14
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDWITH*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak506catalog_val_from_datapart (
            VAR acv      : tak_all_command_glob;
            etype        : tgg00_StackEntryType;
            valpos       : integer;
            inoutlen     : integer);
 
VAR
      b_err   : tgg00_BasisError;
      actlen  : integer;
      ix      : integer;
      i2c2    : tsp_int_map_c2;
      segm_id : tsp00_C2;
      sysbuf  : tak_sysbufferaddress;
      sysk    : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a_mblock, mb_data^ DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'data_length ', a_data_length);
    t01int4 (ak_sem, 'valpos      ', valpos);
    t01int4 (ak_sem, 'inoutlen    ', inoutlen);
&   endif
    IF  mb_data_len = 0
    THEN
        mb_data_len := cgg_rec_key_offset;
    (*ENDIF*) 
    IF  a_data_length + 1 < valpos + inoutlen
    THEN
        a07_b_put_error (acv, e_too_short_datapart, -valpos)
    ELSE
        IF  a_data_ptr^[ valpos ] = csp_undef_byte
        THEN
            a07_b_put_error (acv,
                  e_mandatory_field_is_null, -valpos)
        ELSE
            BEGIN
            IF  etype = st_varkey
            THEN
                actlen := s30lnr (a_data_ptr^, csp_defined_byte,
                      valpos + 1, inoutlen - 1)
            ELSE
                BEGIN
                i2c2.map_c2[ 1 ] := a_data_ptr^[ valpos+1 ];
                i2c2.map_c2[ 2 ] := a_data_ptr^[ valpos+2 ];
                actlen           := i2c2.map_int;
                valpos           := valpos + 2
                END;
            (*ENDIF*) 
&           ifdef trace
            t01int4 (ak_sem, 'actlen      ', actlen);
&           endif
            SAPDB_PascalMove ('VAK506',  17,    
                  sizeof(a_data_ptr^), mb_data_size,
                  @a_data_ptr^, valpos + 1,
                  @mbp_buf, mb_data_len + 1, actlen,
                  a_returncode);
            mb_data_len := mb_data_len + actlen;
            IF  etype = st_varkey
            THEN
                BEGIN
                mbp_keylen := mb_data_len - cgg_rec_key_offset;
                IF  ((mb_type  =  m_select_row) AND
                    ( mb_type2 <> mm_direct))
                THEN
                    mb_st^ [mb_qual^.mstrat_pos].elen_var := mbp_keylen
                ELSE
                    IF  mb_type = m_delete
                    THEN
                        BEGIN
                        sysk.skeylen := mbp_keylen;
                        FOR ix := 1 TO actlen DO
                            sysk.all[ix] := mbp_buf[cgg_rec_key_offset+ix];
                        (*ENDFOR*) 
                        a10get_sysinfo (acv, sysk, d_release, sysbuf, b_err);
                        IF  b_err = e_ok
                        THEN
                            WITH sysbuf^ DO
                                BEGIN
                                segm_id[1] := ssysbuf[cgg_rec_key_offset+b_kl+1];
                                segm_id[2] := ssysbuf[cgg_rec_key_offset+b_kl+2];
                                END;
                            (*ENDWITH*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak506datetime (
            VAR acv   : tak_all_command_glob;
            VAR fp    : tak_field_pars;
            VAR frec  : tak_fill_rec;
            mbufiolen : integer;
            to_fill   : boolean;
            start     : integer);
 
VAR
      i           : integer;
      b_err       : tgg00_BasisError;
      curr_time   : tsp00_C9;
      utcdiff     : tsp00_Longreal;
      timestamp   : tsp00_Timestamp;
      num_err     : tsp00_NumError;
      dest_len    : tsp00_Int4;
      err_char_no : tsp00_Int4;
      uni_err     : tsp8_uni_error;
 
BEGIN
WITH fp, acv.a_mblock, mb_data^ DO
    BEGIN
    IF  ((fp_datatyp = dcha)  OR
        ( fp_datatyp = ddate) OR
        ( fp_datatyp = dtime) OR
        ( fp_datatyp = dtimestamp))
    THEN
        mbp_buf[ start ] := csp_ascii_blank
    ELSE
        IF  fp_datatyp = dunicode
        THEN
            mbp_buf[ start ] := csp_unicode_def_byte
        ELSE
            mbp_buf[ start ] := csp_defined_byte;
        (*ENDIF*) 
    (*ENDIF*) 
    (* PTS 1116175 E.Z. *)
    CASE fp_frompos_v1 OF
        cak_fp_date,
        cak_fp_time,
        cak_fp_timestamp,
        cak_fp_utcdate :
            BEGIN
            IF  fp_frompos_v1 = cak_fp_utcdate
            THEN
                vUTCtimestamp (timestamp)
            ELSE
                BEGIN
                IF  acv.a_timestamp = bsp_c20
                THEN
                    vtimestamp (acv.a_timestamp);
                (*ENDIF*) 
                timestamp := acv.a_timestamp;
                END;
            (*ENDIF*) 
            IF  (fp_datatyp = ddate)      OR
                (fp_datatyp = dtime)      OR
                (fp_datatyp = dtimestamp) OR
                (acv.a_dt_format = dtf_normal)
            THEN
                BEGIN
                frec.fr_leng := mxsp_date + 1;
                IF  fp_frompos_v1 = cak_fp_date
                THEN
                    SAPDB_PascalMove ('VAK506',  18,    
                          sizeof(timestamp), mb_data_size,
                          @timestamp, 1, @mbp_buf, start + 1, mxsp_date,
                          acv.a_returncode)
                ELSE
                    IF  fp_frompos_v1 = cak_fp_time
                    THEN
                        BEGIN
                        mbp_buf[ start+1 ] := '0';
                        mbp_buf[ start+2 ] := '0';
                        SAPDB_PascalMove ('VAK506',  19,    
                              sizeof(timestamp), mb_data_size,
                              @timestamp, mxsp_date + 1,
                              @mbp_buf, start + 3, mxsp_time - 2,
                              acv.a_returncode);
                        END
                    ELSE
                        BEGIN
                        SAPDB_PascalMove ('VAK506',  20,    
                              sizeof(timestamp), mb_data_size,
                              @timestamp, 1, @mbp_buf, start + 1,
                              sizeof(timestamp),
                              acv.a_returncode);
                        frec.fr_leng := mxsp_timestamp + 1;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                CASE fp_frompos_v1 OF
                    cak_fp_date :
                        BEGIN
                        b_err := e_ok;
                        g03dfchange_format_date (timestamp, mbp_buf,
                              1, start+1, acv.a_dt_format, b_err);
                        IF  b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, b_err, 1)
                        ELSE
                            frec.fr_leng := mxsp_extdate + 1;
                        (*ENDIF*) 
                        END;
                    cak_fp_time :
                        BEGIN
                        b_err := e_ok;
                        curr_time[ 2 ] := '0';
                        curr_time[ 3 ] := '0';
                        SAPDB_PascalForcedMove (sizeof (timestamp), sizeof (curr_time),
                              @timestamp, mxsp_date+1, @curr_time, 4, mxsp_time-2);
                        g03tfchange_format_time (curr_time, mbp_buf,
                              2, start+1, acv.a_dt_format, b_err);
                        IF  b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, b_err, 1)
                        ELSE
                            frec.fr_leng := mxsp_exttime + 1;
                        (*ENDIF*) 
                        END;
                    cak_fp_timestamp, cak_fp_utcdate :
                        BEGIN
                        b_err := e_ok;
                        g03tsfchange_format_timestamp (timestamp, mbp_buf,
                              1, start+1, acv.a_dt_format,
                              acv.a_ak_language, b_err);
                        IF  b_err <> e_ok
                        THEN
                            a07_b_put_error (acv, b_err, 1)
                        ELSE
                            frec.fr_leng := mxsp_exttimestamp + 1;
                        (*ENDIF*) 
                        END
                    END;
                (*ENDCASE*) 
            (*ENDIF*) 
            IF  fp_datatyp = dunicode
            THEN
                BEGIN
                FOR i := frec.fr_leng-1 DOWNTO 1 DO
                    BEGIN
                    mbp_buf[ start+2*i   ] := mbp_buf[ start+i ];
                    mbp_buf[ start+2*i-1 ] := csp_unicode_mark;
                    END;
                (*ENDFOR*) 
                frec.fr_leng := (frec.fr_leng-1)*2 + 1
                END
            (*ENDIF*) 
            END;
        cak_fp_stamp :
            BEGIN
            a05_stamp_get (acv, mbp_buf, start+1, mb_data_size);
            frec.fr_leng := SURROGATE_MXGG00 + 1;
            END;
        cak_fp_transaction :
            BEGIN
            a05_transaction_get (acv, mbp_buf, start+1, mb_data_size);
            WITH acv.a_transinf.tri_trans DO
                frec.fr_leng := 1 + sizeof(trTransId_gg00);
            (*ENDWITH*) 
            END;
        cak_fp_utcdiff :
            BEGIN
            utcdiff := vTimeZoneDelta;
            s41plrel (mbp_buf, start + 1, cak_utcdiff_len, cak_utcdiff_frac,
                  utcdiff, num_err);
            IF  (num_err <> num_ok)
            THEN
                CASE num_err OF
                    num_invalid :
                        a07_b_put_error (acv,
                              e_num_invalid, 1);
                    num_trunc :
                        a07_b_put_error (acv,
                              e_num_truncated, 1);
                    num_overflow :
                        a07_b_put_error (acv,
                              e_num_overflow, 1);
                    END
                (*ENDCASE*) 
            ELSE
                frec.fr_leng := (cak_utcdiff_len + 1) DIV 2 + 2;
            (*ENDIF*) 
            END;
        cak_fp_timezone :
            BEGIN
            utcdiff := vTimeZoneDelta;
            (* from fixed (4,2) example 8,5 --> duration example 083000 *)
            utcdiff := trunc(utcdiff) * 10000 +
                  (utcdiff - trunc(utcdiff)) * 6000;
            s41plrel (mbp_buf, start + 1, cak_time_durationlen, 0,
                  utcdiff, num_err);
            IF  (num_err <> num_ok)
            THEN
                CASE num_err OF
                    num_invalid :
                        a07_b_put_error (acv,
                              e_num_invalid, 1);
                    num_trunc :
                        a07_b_put_error (acv,
                              e_num_truncated, 1);
                    num_overflow :
                        a07_b_put_error (acv,
                              e_num_overflow, 1);
                    END
                (*ENDCASE*) 
            ELSE
                frec.fr_leng := (cak_time_durationlen + 1) DIV 2 + 2;
            (*ENDIF*) 
            END;
        cak_fp_current_schema :
            BEGIN
            IF  (g01unicode AND
                (fp_datatyp = dcha))
            THEN
                BEGIN
                dest_len := a01identifier_size DIV a01char_size;
                s80uni_trans (@acv.a_curr_schema [ 1 ], sizeof(acv.a_curr_schema), csp_unicode,
                      @mbp_buf[ start+1 ], dest_len, csp_ascii,
                      [ ], uni_err, err_char_no);
                IF  uni_err = uni_ok
                THEN
                    frec.fr_leng := succ(dest_len)
                ELSE
                    a07_uni_error (acv, uni_err, err_char_no);
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                SAPDB_PascalMove ('VAK506',  21,    
                      sizeof (acv.a_curr_schema), mb_data_size, @acv.a_curr_schema, 1,
                      @mbp_buf, start+1, a01identifier_size, acv.a_returncode);
                frec.fr_leng := succ(a01identifier_size);
                END;
            (*ENDIF*) 
            END;
        OTHERWISE
            BEGIN
            END;
        END;
    (*ENDCASE*) 
    IF  (to_fill OR
        (fp_etype in [ st_fixkey, st_fixcol ]))
    THEN
        BEGIN
        IF  mbufiolen > frec.fr_leng
        THEN
            IF  fp_datatyp = dunicode
            THEN
                SAPDB_PascalUnicodeFill ('VAK506',  22,    
                      mb_data_size, @mbp_buf, start+frec.fr_leng,
                      mbufiolen-frec.fr_leng, csp_unicode_blank,
                      acv.a_returncode)
            ELSE
                SAPDB_PascalFill ('VAK506',  23,    
                      mb_data_size, @mbp_buf, start+frec.fr_leng,
                      mbufiolen-frec.fr_leng, mbp_buf[ start ],
                      acv.a_returncode);
            (*ENDIF*) 
        (*ENDIF*) 
        frec.fr_leng := mbufiolen;
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak506in_mess_buf_move (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR frec : tak_fill_rec);
 
VAR
      pmbp : tgg00_MessBlockPtr;
      pdbp : tgg00_DataPartPtr;
 
BEGIN
WITH acv, a_mblock, mb_data^, dmli, frec DO
    BEGIN
    pmbp    := @dmli.d_sparr.px[ d_sparr.pcount ]^.
          smessblock.mbr_mess_block;
    pdbp    := pmbp^.mb_data;
    IF  (fr_total_leng > 0) AND  (pdbp <> NIL)
    THEN
        BEGIN
&       ifdef trace
        t01int4( ak_sem, 'from size   ', pmbp^.mb_data_size );
        t01int4( ak_sem, 'to   size   ', mb_data_size );
        t01int4( ak_sem, 'from pos    ', d_pos_in_parsbuf );
        t01int4( ak_sem, 'to   pos    ', mb_data_len + 1 );
&       endif
        SAPDB_PascalMove ('VAK506',  24,    
              pmbp^.mb_data_size, mb_data_size,
              @pdbp^.mbp_buf, d_pos_in_parsbuf,
              @mb_data^.mbp_buf, mb_data_len + 1,
              fr_total_leng,
              a_returncode);
        END;
    (*ENDIF*) 
    fr_leng := 0;
&   ifdef TRACE
    t01int4 (ak_sem, 'total_leng  ', fr_total_leng);
    t01int4 (ak_sem, 'pos_in_parsb', d_pos_in_parsbuf);
    t01int4 (ak_sem, 'leng        ', fr_leng);
    t01int4 (ak_sem, 'mb_data_len ', mb_data_len);
    t01int4 (ak_sem, 'mbp_reclen  ', mbp_reclen);
    t01int4 (ak_sem, 'mbp_keylen  ', mbp_keylen);
&   endif
    mb_data_len      := mb_data_len      + fr_total_leng;
    d_pos_in_parsbuf := d_pos_in_parsbuf + fr_total_leng;
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak506long_support (
            VAR acv        : tak_all_command_glob;
            VAR dmli       : tak_dml_info;
            VAR frec       : tak_fill_rec;
            VAR result     : tsp00_MoveObj;
            ind            : integer;
            VAR currentdif : integer);
 
VAR
      isStream   : boolean;
      copyLong   : boolean;
      desc_len   : integer;
      all_litcol : integer;
      long_desc  : tak_long_descriptor;
      is_longlit : boolean;
      value_ptr  : tsp00_MoveObjPtr;
      value_len  : tsp00_Int4;
      is_null    : boolean;
      is_default : boolean;
      stackentry : tgg00_StackEntry;
      val_addr   : tsp00_MoveObjPtr;
      val_len    : integer;
 
BEGIN
WITH acv, dmli, d_sparr.px[1]^.sparsinfo, p_pars_infos[ind],
     a_mblock, mb_data^ DO
    BEGIN
    IF  fp_kind = fp_val_all_without_l
    THEN
        BEGIN
        frec.fr_total_leng := fp_movebefore_v2 - mb_data_len;
        IF  frec.fr_total_leng > 0
        THEN
            ak506in_mess_buf_move (acv, dmli, frec)
        (*ENDIF*) 
        END
    ELSE
        IF  fp_movebefore_v1 > 0
        THEN
            BEGIN
            frec.fr_total_leng := fp_movebefore_v1;
            ak506in_mess_buf_move (acv, dmli, frec)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    is_longlit := false;
    IF  dmli.d_literalrec <> NIL
    THEN
        WITH dmli.d_literalrec^.slongliteral DO
            BEGIN
            d_longlitcount := succ (d_longlitcount);
            is_longlit  := (litcoldesc [d_longlitcount].llcdatapos <> -1)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  is_longlit
    THEN
        BEGIN
        mbp_buf [ mb_data_len + 1] := csp_defined_byte;
        a05_stamp_get (acv, mbp_buf, mb_data_len + 2, mb_data_size);
        WITH dmli.d_literalrec^.slongliteral, litcoldesc [d_longlitcount] DO
            BEGIN
            SAPDB_PascalMove ('VAK506',  25,    
                  mb_data_size, sizeof(llclongid),
                  @mbp_buf, mb_data_len + 2,
                  @llclongid, 1, cgg04_str_col_entry_size,
                  a_returncode);
            IF  mb_type = m_insert_select
            THEN
                BEGIN
                IF  a_variable_input
                THEN
                    ak506move_val_in_fieldlist (acv, acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist],
                          @llclongid, sizeof (llclongid), csp_defined_byte);
                (*ENDIF*) 
                d_pos_in_parsbuf := d_pos_in_parsbuf + succ(cgg04_str_col_entry_size);
                END;
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        mb_data_len := mb_data_len + cgg04_str_col_entry_size + 1;
        END
    ELSE
        BEGIN
        copyLong         := false;
        d_longdesc_found := true;
        d_cnt_longdesc := succ(d_cnt_longdesc);
        IF  (d_first_longdesc_pos = 0) OR (d_first_longdesc_pos > fp_frompos_v1)
        THEN
            d_first_longdesc_pos := fp_frompos_v1;
        (* PTS 1116801 E.Z. *)
        (*ENDIF*) 
        desc_len := mxsp_long_desc;
        a_data_part^.sp1p_arg_count := d_cnt_longdesc;
        IF  NOT acv.a_variable_input
        THEN
            BEGIN
            IF  a_input_data_pos < (fp_frompos_v1 + desc_len + 1)
            THEN
                a_input_data_pos := fp_frompos_v1 + desc_len + 1;
            (*ENDIF*) 
            is_null    := (a_data_ptr^[fp_frompos_v1] = csp_undef_byte);
            is_default := (a_data_ptr^[fp_frompos_v1] = csp_default_byte);
            IF  is_null
            THEN
                BEGIN
                mbp_buf [ mb_data_len + 1] := csp_undef_byte;
                SAPDB_PascalFill ('VAK506',  26,    
                      mb_data_size, @mbp_buf, mb_data_len + 2,
                      cgg04_str_col_entry_size, csp_defined_byte,
                      a_returncode);
                mb_data_len := mb_data_len + cgg04_str_col_entry_size + 1;
                END
            ELSE
                IF  NOT is_default
                THEN
                    SAPDB_PascalMove ('VAK506',  27,    
                          a_data_length, sizeof(long_desc),
                          @a_data_ptr^, fp_frompos_v1 + 1,
                          @long_desc, 1, desc_len,
                          a_returncode);
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  NOT a509get_one_value (a_input_data_map, fp_frompos_v1,
                value_ptr, value_len, is_null, is_default)
            THEN
                a07ak_system_error (acv, 506, 4)
            ELSE
                BEGIN
                a509set_long_value (a_input_data_map, fp_frompos_v1);
                IF  is_null
                THEN
                    BEGIN
                    mbp_buf [ mb_data_len + 1] := csp_undef_byte;
                    SAPDB_PascalFill ('VAK506',  28,    
                          mb_data_size, @mbp_buf, mb_data_len + 2,
                          cgg04_str_col_entry_size, csp_defined_byte,
                          a_returncode);
                    mb_data_len := mb_data_len + cgg04_str_col_entry_size + 1;
                    long_desc.lds_descriptor := cgg_zero_id;
                    ak506move_val_in_fieldlist (acv, acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist],
                          @long_desc, sizeof (long_desc.lds_descriptor), csp_undef_byte)
                    END
                ELSE
                    IF  NOT is_default
                    THEN
                        BEGIN
                        SAPDB_PascalMove ('VAK506',  29,    
                              a_data_length, sizeof(long_desc),
                              @value_ptr^, 1, @long_desc, 1, value_len,
                              a_returncode);
                        ak506move_val_in_fieldlist (acv, acv.a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist],
                              @long_desc, sizeof (long_desc.lds_descriptor), csp_defined_byte)
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  (a_returncode = 0) AND (NOT is_default)
                THEN
                    BEGIN
                    stackentry.epos     := cgg_param_valuefieldlist;
                    stackentry.elen_var :=
                          ak104_GetFieldCount_IMS (mb_fieldlists[cgg_idx_param_valuefieldlist]) - 1;
                    g04value_locate (stackentry, acv.a_mblock, val_addr, val_len);
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
&       ifdef TRACE
        t01int4 (ak_sem, 'd_first_ldps', d_first_longdesc_pos);
        t01int4 (ak_sem, 'd_cntlongdes', d_cnt_longdesc);
        t01int4 (ak_sem, 'fp_fromposv1', fp_frompos_v1);
        t01int4 (ak_sem, 'input_data_p', a_input_data_pos);
        t01moveobj (ak_sem, a_data_ptr^, 1, 160);
&       endif
        IF  is_default AND (a_returncode = 0)
        THEN
            BEGIN
            IF  dmli.d_literalrec <> NIL
            THEN
                WITH dmli.d_literalrec^.slongliteral DO
                    BEGIN
                    all_litcol := litcolcount;
                    litcolcount := d_longlitcount;
                    ak506normal_value (acv, dmli, frec,
                          result, ind, currentdif, NOT c_move_before);
                    litcolcount := all_litcol;
                    END
                (*ENDWITH*) 
            ELSE
                a07_b_put_error (acv, e_not_implemented, 7)
            (*ENDIF*) 
            END
        ELSE
            IF  NOT is_null AND (a_returncode = 0)
            THEN
                BEGIN
&               ifdef trace
                t01int4 (ak_sem, 'long_desc  1', 1);
                t01longdescriptor (ak_sem, long_desc.desc);
&               endif
                WITH long_desc DO
                    BEGIN
                    copyLong := (ld_copy in lds_state) AND (acv.a_trigger_level + acv.a_dbproc_level > 0);
                    isStream := ld_stream in lds_state;
                    IF  p_treeid.fileName_gg00 = cgg_zero_fn
                    THEN
                        lds_tabid := a_mblock.mb_qual^.mtree.fileTabId_gg00
                    ELSE
                        lds_tabid := p_treeid.fileTabId_gg00;
                    (*ENDIF*) 
                    IF  NOT copyLong
                    THEN
                        BEGIN
                        lds_intern_pos  := 1;
                        IF  fp_datatyp in [dlonga, dlonguni, dlongb]
                        THEN
                            BEGIN
                            IF  ((a_mblock.mb_type = m_insert) OR
                                ( a_mblock.mb_type = m_insert_select))
                            THEN
                                lds_intern_pos  := -1;
                            (* PTS 1105838 E.Z. *)
                            (*ENDIF*) 
                            lds_state   := [ ];
                            lds_infoset := [ ld_without_shortcol ]
                            END
                        ELSE
                            BEGIN
                            lds_state   := [ ld_short_scol ];
                            lds_infoset := [ ];
                            END;
                        (*ENDIF*) 
                        (* PTS 1117525 *)
                        IF  isStream
                        THEN
                            lds_state := lds_state + [ld_stream];
                        (*ENDIF*) 
                        IF  (a_out_packet^.sp1_header.sp1h_mess_swap <>
                            g01code.kernel_swap)
                        THEN
                            BEGIN
                            s20int4_to_buf_swap (lds_intern_pos, g01code.kernel_swap,
                                  lds_intern_pos, 1,
                                  a_out_packet^.sp1_header.sp1h_mess_swap);
                            END;
                        (*ENDIF*) 
                        IF  fp_datatyp in [dstruni, dlonguni]
                        THEN
                            lds_infoset := lds_infoset + [ ld_unicode ];
                        (*ENDIF*) 
                        IF  ((fp_datatyp = dstruni) OR (fp_datatyp = dlonguni)) AND
                            (a_client_out_packet^.sp1_header.sp1h_mess_swap <> sw_normal)
                        THEN
                            lds_state := lds_state + [ld_use_ucs_2_swap];
                        (*ENDIF*) 
                        IF  (fp_datatyp in [dstra, dlonga]) AND
                            (a_client_out_packet^.sp1_header.sp1h_mess_code
                            in [csp_unicode, csp_unicode_swap])
                            AND
                            NOT acv.a_ascii_in_and_output (* new feature *)
                        THEN
                            BEGIN
                            IF  (a_dbproc_level + a_trigger_level = 0) OR
                                (acv.a_precomp_info_byte <> csp1_p_dialog_call)
                            THEN
                                lds_state := lds_state + [ld_use_toascii];
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        lds_colno := d_cnt_longdesc;
                        END;
                    (*ENDIF*) 
                    mbp_buf [ mb_data_len + 1] := csp_defined_byte;
                    IF  ((a_mblock.mb_type = m_insert) OR
                        ( a_mblock.mb_type = m_insert_select))
                    THEN
                        BEGIN
                        IF  a_variable_input AND
                            ( a_mblock.mb_type = m_insert_select)
                        THEN
                            BEGIN
                            a05_stamp_get (acv, val_addr^, 2, val_len);
                            SAPDB_PascalMove ('VAK506',  30,    
                                  val_len, sizeof(tsp00_LongDescriptor),
                                  val_addr, 2,
                                  @long_desc, 1, cgg04_str_col_entry_size,
                                  a_returncode);
                            END
                        ELSE
                            BEGIN
                            a05_stamp_get (acv,
                                  mbp_buf, mb_data_len + 2, mb_data_size);
                            SAPDB_PascalMove ('VAK506',  31,    
                                  mb_data_size, sizeof(tsp00_LongDescriptor),
                                  @mbp_buf, mb_data_len + 2,
                                  @long_desc, 1, cgg04_str_col_entry_size,
                                  a_returncode);
                            mb_data_len := mb_data_len + cgg04_str_col_entry_size + 1;
                            END;
                        (*ENDIF*) 
                        IF  a_mblock.mb_type = m_insert_select
                        THEN
                            d_pos_in_parsbuf := d_pos_in_parsbuf + succ(SURROGATE_MXGG00);
                        (*ENDIF*) 
                        IF  copyLong
                        THEN
                            lds_state := lds_state + [ ld_first_insert ];
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        SAPDB_PascalFill ('VAK506',  32,    
                              mb_data_size,  @mbp_buf, mb_data_len + 1,
                              cgg04_str_col_entry_size+1, csp_defined_byte,
                              a_returncode);
                        mb_data_len := mb_data_len + cgg04_str_col_entry_size + 1;
                        (* PTS 1124111 E.Z. *)
                        IF  a_mblock.mb_type = m_update
                        THEN
                            d_pos_in_parsbuf := d_pos_in_parsbuf + succ(SURROGATE_MXGG00);
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  a_variable_input
                    THEN
                        SAPDB_PascalMove ('VAK506',  33,    
                              sizeof(long_desc), a_data_length, @long_desc, 1,
                              @value_ptr^, 1, desc_len,
                              a_returncode)
                    ELSE
                        SAPDB_PascalMove ('VAK506',  34,    
                              sizeof(long_desc), a_data_length, @long_desc, 1,
                              @a_data_ptr^, fp_frompos_v1 + 1, desc_len,
                              a_returncode);
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
&               ifdef trace
                t01int4 (ak_sem, 'long_desc  2', 2);
                t01longdescriptor (ak_sem, long_desc.desc);
&               endif
                END
            ELSE
                BEGIN
                IF  is_null AND  (a_returncode = 0) AND
                    ((a_mblock.mb_type = m_insert_select) OR (a_mblock.mb_type = m_update))
                THEN
                    d_pos_in_parsbuf := d_pos_in_parsbuf + succ(SURROGATE_MXGG00);
                (*ENDIF*) 
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak506one_field_copy (
            VAR acv  : tak_all_command_glob;
            VAR dmli : tak_dml_info;
            VAR frec : tak_fill_rec);
 
VAR
      ind        : integer;
      curval_len : integer;
      currlen    : tsp_int_map_c2;
 
BEGIN
WITH acv, frec, dmli.d_sparr.px[ 1 ]^.sparsinfo,
     p_pars_infos[ fr_f_no ], a_mblock, mb_data^ DO
    BEGIN
    ind := fr_f_no;
    IF  fp_movebefore_v8 > 0
    THEN
        BEGIN
        fr_total_leng := fp_movebefore_v8;
        ak506in_mess_buf_move (acv, dmli, frec)
        END;
    (*ENDIF*) 
    WITH dmli.d_sparr.px[ 1 ]^.sparsinfo, p_pars_infos[ ind ] DO
        BEGIN
        fr_leng := mb_st^ [fp_keystack].elen_var;
        IF  (fp_key_low_handl <> cak_keycol_low_def)
        THEN
            BEGIN
            curval_len := 1 + s30lnr_defbyte (@mbp_buf,
                  mbp_buf [mb_st^ [fp_keystack].epos],
                  mb_st^ [fp_keystack].epos + 1, fr_leng - 1);
            IF  (fp_key_low_handl = cak_keycol_low_trunc)
            THEN
                fr_leng := curval_len;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (fp_to_stack = 0)
        THEN
            IF  fp_fill_81 > 255
            THEN
                BEGIN
                currlen.map_int := fr_leng;
                mbp_buf [mb_data_len + 1] := currlen.map_c2[1];
                mbp_buf [mb_data_len + 2] := currlen.map_c2[2];
                mb_data_len := mb_data_len + 2;
                END
            ELSE
                BEGIN
                mb_data_len := succ(mb_data_len);
                mbp_buf [mb_data_len] := chr(fr_leng);
                END
            (*ENDIF*) 
        ELSE
            WITH mb_st^ [fp_to_stack] DO
                elen_var := elen_var + fr_leng;
            (*ENDWITH*) 
        (*ENDIF*) 
        SAPDB_PascalOverlappingMove ('VAK506',  35,    
              mb_data_size, mb_data_size,
              @mbp_buf, mb_st^ [fp_keystack].epos,
              @mbp_buf, mb_data_len + 1, fr_leng,
              a_returncode);
        IF  (fp_key_low_handl = cak_keycol_low_zero)
        THEN
            SAPDB_PascalFill ('VAK506',  36,    
                  mb_data_size, @mbp_buf, mb_data_len + curval_len + 1,
                  fr_leng - curval_len, csp_defined_byte,
                  a_returncode);
        (*ENDIF*) 
        mb_data_len := mb_data_len + fr_leng;
&       ifdef TRACE
        t01name (ak_sem, 'after copy_withlen');
        t01messblock (ak_sem, 'MBLOCK 506on', a_mblock);
&       endif
        END;
    (*ENDWITH*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak506pseudo_insert_select (
            VAR acv     : tak_all_command_glob;
            VAR dmli    : tak_dml_info;
            dupl_clause : integer);
 
VAR
      dummy_bool : boolean;
      aux_len    : integer;
      rec_buf    : tgg00_Rec;
      res_buf    : tgg00_Rec;
      sel        : tgg00_SelectFieldsParam;
 
BEGIN
WITH acv, a_mblock, mb_data^ DO
    BEGIN
    mb_work_st      := a_work_st_addr;
    mb_work_st_max  := a_work_st_max;
    mb_workbuf      := a_work_buf_addr;
    mb_workbuf_size := a_work_buf_size;
    g04init_select_fields (sel, @mbp_buf, mb_data_size,
          mb_work_st, mb_work_st_max, mb_workbuf, mb_workbuf_size,
          a_sqlmode, @mb_fieldlists);
    sel.sfp_result_wanted := true;
    sel.sfp_result_length := cgg_rec_key_offset;
    sel.sfp_m_result_addr := @res_buf;
    sel.sfp_m_result_size := sizeof (res_buf);
    sel.sfp_acv_addr      := @acv;   (* PTS 1121403 E.Z. *)
    rec_buf.len           := cgg_rec_key_offset;
    rec_buf.keylen        := 0;
    IF  ( ssSubquery_egg00 in  a_mblock.mb_qual^.mstack_state )
    THEN
        k720_test_subquery( a_mblock.mb_trns^, a_mblock.mb_data^,
              a_mblock.mb_data_size, a_mblock.mb_qual^.mstack_desc, res_buf );
    (*ENDIF*) 
    res_buf.keylen        := 0;
    k71col_select (mb_trns^, sel, mb_qual^.mstack_desc,
          rec_buf, dummy_bool);
    IF  mb_trns^.trError_gg00 <> e_ok
    THEN
        a07_b_put_error (acv,
              a_mblock.mb_trns^.trError_gg00, 1)
    ELSE
        BEGIN
        res_buf.len := sel.sfp_result_length;
&       ifdef trace
        t01buf (ak_sem, res_buf.buf, 1, res_buf.len);
&       endif
        IF  mb_qual^.mstring_cnt > 0
        THEN
            k721longcol_insert_select (a_mblock, res_buf, mb_qual^.mtree);
        (*ENDIF*) 
        SAPDB_PascalMove ('VAK506',  37,    
              sizeof(res_buf.buf), mb_data_size,
              @res_buf.buf, 1, @mbp_buf, 1, sel.sfp_result_length,
              a_returncode);
        (* PTS 1123551 E.Z. *)
        mb_qual^.mqual_cnt  := 0;
        mb_qual^.mstrat_cnt := 0;
        mb_data_len         := res_buf.len;
        mb_type             := m_insert;
        IF  mb_data^.mbp_keylen = 0
        THEN
            BEGIN
            mbp_buf [cgg_rec_key_offset + 1] := csp_defined_byte;
            IF  a101_IsExtendedTempFile (acv, mb_qual^.mtree)
            THEN
                BEGIN
                aux_len := mb_data_len ;
                a56temp_table_key (acv, dmli);
                mb_data^.mbp_reclen := aux_len;
                mb_data_len         := aux_len
                END
            ELSE
                mb_type2 := mm_nokey;
            (*ENDIF*) 
            mb_data^.mbp_keylen := SURROGATE_MXGG00 + 1
            END
        ELSE
            BEGIN
            mb_type2 := mm_nil;
            IF  dupl_clause = cak_x_ignore_dupl
            THEN
                mb_type2 := mm_ignore_duplicates
            ELSE
                IF  dupl_clause = cak_x_update_dupl
                THEN
                    mb_type2 := mm_update_duplicates
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1106107 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      ak506val_from_datapart (
            VAR acv     : tak_all_command_glob;
            valpos      : integer;
            field_kind  : tak_fp_kind_type;
            VAR colinfo : tak00_columninfo;
            iolen       : integer;
            VAR frec    : tak_fill_rec;
            VAR to_fill : boolean);
 
VAR
      b_err      : tgg00_BasisError;
      truncated  : boolean;
      destpos    : integer;
      i          : integer;
      numlen     : integer;
      uniinlen   : integer;
      univallen  : integer;
      err        : tsp00_NumError;
      error      : tsp8_uni_error;
      err_char_no: tsp00_Int4;
      c64        : tsp00_C64;
      c64_ptr    : tsp00_MoveObjPtr;
 
BEGIN
WITH acv, a_mblock, mb_data^, colinfo DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem, 'data_length ', a_data_length);
    t01int4 (ak_sem, 'valpos      ', valpos);
&   endif
    b_err     := e_ok;
    truncated := false;
    destpos   := mb_data_len + 1;
    frec.fr_leng    := 0;
    IF  a_input_data_pos < (valpos + iolen)
    THEN
        a_input_data_pos := valpos + iolen;
    (*ENDIF*) 
    IF  a_data_length + 1 < valpos + iolen
    THEN
        a07_b_put_error (acv, e_too_short_datapart, -valpos);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  a_data_ptr^[ valpos ] = csp_undef_byte
        THEN
            BEGIN
            mbp_buf[ destpos ] := csp_undef_byte;
            IF  ((ccolstack.etype = st_varkey) OR
                ( ccolstack.etype = st_varcol) OR
                ( ccolstack.etype = st_varlongchar))
            THEN
                frec.fr_leng := 0
            ELSE
                BEGIN
                frec.fr_leng := cinoutlen - 1;
                SAPDB_PascalFill ('VAK506',  38,    
                      mb_data_size, @mbp_buf, destpos+1, frec.fr_leng,
                      csp_defined_byte, a_returncode)
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            IF  (((ccolstack.etype = st_varkey) OR
                (  ccolstack.etype = st_varcol) OR
                (  ccolstack.etype = st_varlongchar))
                AND
                (NOT to_fill))
            THEN
                IF  ((cdatatyp = dfixed)    OR
                    ( cdatatyp = dfloat)    OR
                    ( cdatatyp = dvfloat)   OR
                    ( cdatatyp = dinteger)  OR
                    ( cdatatyp = dsmallint) OR
                    ( cdatatyp = dchb))
                THEN
                    BEGIN
                    frec.fr_leng := s30lnr (a_data_ptr^, csp_defined_byte,
                          valpos + 1, iolen - 1);
                    truncated := true
                    END
                ELSE
                    BEGIN
                    IF  ((a_initial_packet_header.sp1h_mess_code in
                        [ csp_unicode, csp_unicode_swap ]) AND
                        (
                        (cdatatyp = dunicode) OR
                        ((cdatatyp in [ dcha, dvarchara, ddate, dtime, dtimestamp ]) AND
                        (NOT acv.a_ascii_in_and_output (* new feature *)
                        ))
                        ))
                        OR
                        (cdatatyp = dunicode)
                    THEN
                        frec.fr_leng := s30unilnr (a_data_ptr,
                              frec.fr_uni_fill_c2,
                              valpos + 1, iolen - 1)
                    ELSE
                        BEGIN
                        frec.fr_leng := s30lnr (a_data_ptr^, csp_ascii_blank,
                              valpos + 1, iolen - 1);
                        IF  a_space_option AND
                            (frec.fr_leng = 0) AND
                            (cdatatyp in [ dcha, dvarchara]) AND
                            (* not for insert *)
                            (field_kind <> fp_val_varcol_with_len)
                        THEN
                            frec.fr_leng := 1;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    truncated := true
                    END
                (*ENDIF*) 
            ELSE
                frec.fr_leng := iolen - 1;
            (*ENDIF*) 
&           ifdef TRACE
            t01int4 (ak_sem, 'to_fill     ', ord(to_fill));
            t01int4  (ak_sem, 'valpos      ', valpos);
            t01char (ak_sem, 'undef_byte  ', a_data_ptr^[ valpos ]);
            t01int4  (ak_sem, 'start       ', destpos);
            t01int4  (ak_sem, 'frec.fr_leng', frec.fr_leng);
&           endif
            CASE cdatatyp OF
                dunicode :
                    BEGIN
                    mbp_buf[ destpos ] := csp_unicode_def_byte;
                    IF  frec.fr_leng = iolen - 1
                    THEN
                        uniinlen := s30unilnr (a_data_ptr,
                              frec.fr_uni_fill_c2,
                              valpos + 1, iolen - 1)
                    ELSE
                        uniinlen := frec.fr_leng;
                    (*ENDIF*) 
                    IF  (a_initial_packet_header.sp1h_mess_swap <> sw_normal) AND
                        (a_initial_packet_header.sp1h_mess_code <> csp_unicode)
                    THEN
                        BEGIN
                        univallen := cinoutlen - 1;
                        s80uni_trans (@a_data_ptr^[ valpos + 1], uniinlen,
                              csp_unicode_swap,
                              @mbp_buf[ destpos + 1], univallen, csp_unicode,
                              [ ], error, err_char_no);
                        END
                    ELSE
                        BEGIN
                        univallen := uniinlen;
                        error := uni_ok;
                        SAPDB_PascalMove ('VAK506',  39,    
                              a_data_length, mb_data_size,
                              @a_data_ptr^, valpos + 1,
                              @mbp_buf, destpos + 1, uniinlen,
                              a_returncode)
                        END;
                    (*ENDIF*) 
                    IF  error = uni_ok
                    THEN
                        IF  (((ccolstack.etype = st_varkey) OR
                            (  ccolstack.etype = st_varcol) OR
                            (  ccolstack.etype = st_varlongchar))
                            AND
                            (NOT to_fill))
                        THEN
                            frec.fr_leng := univallen
                        ELSE
                            BEGIN
                            i := cinoutlen-univallen-1;
&                           ifdef TRACE
                            t01int4 (ak_sem, 'fill_length ', i);
&                           endif
                            IF  i > 0
                            THEN
                                SAPDB_PascalUnicodeFill ('VAK506',  40,    
                                      mb_data_size, @mbp_buf,
                                      destpos+1+univallen, i,
                                      csp_unicode_blank,
                                      a_returncode);
                            (*ENDIF*) 
                            frec.fr_leng := pred(cinoutlen)
                            END
                        (*ENDIF*) 
                    ELSE
                        BEGIN
&                       ifdef TRACE
                        t01int4 (ak_sem, 'err_char_no ', err_char_no);
&                       endif
                        a07_hex_uni_error (acv, error,
                              -(valpos+err_char_no), c_trans_to_uni,
                              @(a_data_ptr^[ valpos + err_char_no ]),
                              a_max_codewidth);
                        END
                    (*ENDIF*) 
                    END;
                dboolean :
                    BEGIN
                    mbp_buf[ destpos ] := csp_defined_byte;
                    IF  (a_data_ptr^[ valpos + 1 ] <> cgg04_truechar)
                        AND (a_data_ptr^[ valpos + 1 ] <> cgg04_falsechar)
                    THEN
                        a07_b_put_error (acv,
                              e_const_incompatible_with_typ, -valpos)
                    ELSE
                        mbp_buf [destpos + 1] := a_data_ptr^ [valpos + 1];
                    (*ENDIF*) 
                    END;
                dfixed, dfloat, dvfloat, dsmallint, dinteger :
                    IF  a_data_ptr^[ valpos ] <> chr(0)
                    THEN
                        a07_b_put_error (acv,
                              e_invalid_number_variable, -valpos)
                    ELSE
                        BEGIN
                        mbp_buf[ destpos ] := csp_defined_byte;
                        FOR i := valpos+2 TO valpos+frec.fr_leng DO
                            IF  NOT a506mantissacheckarr [ord(a_data_ptr^[ i ])]
                            THEN
                                a07_b_put_error (acv,
                                      e_invalid_number_variable, -valpos);
                            (*ENDIF*) 
                        (*ENDFOR*) 
                        s51kroun (a_data_ptr^, valpos+1, frec.fr_leng,
                              mbp_buf, destpos+1,
                              cdatalen, cdatafrac-cak_frac_offset,
                              numlen, err);
                        IF  (err <> num_ok)
                        THEN
                            CASE err OF
                                num_invalid :
                                    a07_b_put_error (acv,
                                          e_num_invalid, -valpos);
                                num_trunc :
                                    a07_b_put_error (acv,
                                          e_num_truncated, -valpos);
                                num_overflow :
                                    a07_b_put_error (acv,
                                          e_num_overflow, -valpos);
                                END
                            (*ENDCASE*) 
                        ELSE
                            IF  cbinary
                            THEN
                                a05int_range_check (acv, mbp_buf, destpos, numlen,
                                      cdatalen, -valpos);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                ddate :
                    BEGIN
                    mbp_buf [destpos] := csp_ascii_blank;
                    IF  (a_initial_packet_header.sp1h_mess_code in
                        [ csp_unicode, csp_unicode_swap ])
                        AND
                        NOT acv.a_ascii_in_and_output (* new feature *)
                    THEN
                        BEGIN
                        frec.fr_leng := s30unilnr (a_data_ptr,
                              frec.fr_uni_fill_c2,
                              valpos + 1, frec.fr_leng);
                        univallen := sizeof (c64);
                        c64_ptr   := @c64;
                        s80uni_trans (@a_data_ptr^[ valpos + 1], frec.fr_leng,
                              a_initial_packet_header.sp1h_mess_code,
                              c64_ptr, univallen, csp_ascii,
                              [ ], error, err_char_no);
                        IF  error = uni_ok
                        THEN
                            g03fdc_date(@c64, @mbp_buf, 1, destpos+1,
                                  univallen, a_dt_format, b_err)
                        ELSE
                            a07_hex_uni_error (acv, error,
                                  -(valpos+err_char_no), NOT c_trans_to_uni,
                                  @(a_data_ptr^[ valpos + err_char_no ]),
                                  a_max_codewidth);
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        frec.fr_leng := s30lnr(a_data_ptr^, csp_ascii_blank,
                              valpos + 1, mxsp_extdate);
&                       ifdef trace
                        t01int4 (ak_sem, 'g1code.ctype', g01code.ctype);
                        t01int4 (ak_sem, 'mess_code   ', a_mess_code);
&                       endif
                        g03fdcheck_date(a_data_ptr^, mbp_buf,
                              valpos+1, destpos+1, frec.fr_leng,
                              a_dt_format, b_err);
                        END;
                    (*ENDIF*) 
                    frec.fr_leng := mxsp_date
                    END;
                dtime :
                    BEGIN
                    mbp_buf [destpos] := csp_ascii_blank;
                    IF  (a_initial_packet_header.sp1h_mess_code in
                        [ csp_unicode, csp_unicode_swap ])
                        AND
                        NOT acv.a_ascii_in_and_output (* new feature *)
                    THEN
                        BEGIN
                        frec.fr_leng := s30unilnr (a_data_ptr,
                              frec.fr_uni_fill_c2,
                              valpos + 1, frec.fr_leng);
                        univallen := sizeof (c64);
                        c64_ptr   := @c64;
                        s80uni_trans (@a_data_ptr^[ valpos + 1], frec.fr_leng,
                              a_initial_packet_header.sp1h_mess_code,
                              c64_ptr, univallen, csp_ascii,
                              [ ], error, err_char_no);
                        IF  error = uni_ok
                        THEN
                            g03ftc_time(@c64, @mbp_buf, 1, destpos+1,
                                  univallen, a_dt_format, b_err)
                        ELSE
                            a07_hex_uni_error (acv, error,
                                  -(valpos+err_char_no), NOT c_trans_to_uni,
                                  @(a_data_ptr^[ valpos + err_char_no ]),
                                  a_max_codewidth);
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        frec.fr_leng := s30lnr(a_data_ptr^, csp_ascii_blank,
                              valpos + 1, mxsp_exttime);
                        g03ftcheck_time(a_data_ptr^, mbp_buf,
                              valpos+1, destpos+1, frec.fr_leng,
                              a_dt_format, b_err);
                        END;
                    (*ENDIF*) 
                    frec.fr_leng := mxsp_time
                    END;
                dtimestamp :
                    BEGIN
                    mbp_buf [destpos] := csp_ascii_blank;
                    IF  (a_initial_packet_header.sp1h_mess_code in
                        [ csp_unicode, csp_unicode_swap ])
                        AND
                        NOT acv.a_ascii_in_and_output (* new feature *)
                    THEN
                        BEGIN
                        frec.fr_leng := s30unilnr (a_data_ptr,
                              frec.fr_uni_fill_c2,
                              valpos + 1, frec.fr_leng);
                        c64[ 1 ]  := csp_ascii_blank;
                        c64_ptr   := @c64[ 2 ];
                        univallen := sizeof (c64) - 1;
                        s80uni_trans (@a_data_ptr^[ valpos + 1], frec.fr_leng,
                              a_initial_packet_header.sp1h_mess_code,
                              c64_ptr, univallen, csp_ascii,
                              [ ], error, err_char_no);
                        c64_ptr   := @c64;
                        IF  error = uni_ok
                        THEN
                            (* Funny but correct: the source buffer *)
                            (* starts at the defined byte, but      *)
                            (* univallen is the length without it.  *)
                            a05timestamp_get (acv, c64_ptr^, 2, NOT c_undef,
                                  mbp_buf, destpos+1, univallen, b_err)
                        ELSE
                            a07_hex_uni_error (acv, error,
                                  -(valpos+err_char_no), NOT c_trans_to_uni,
                                  @(a_data_ptr^[ valpos + err_char_no ]),
                                  a_max_codewidth);
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        frec.fr_leng := s30lnr (a_data_ptr^,
                              csp_ascii_blank, valpos + 1,
                              mxsp_exttimestamp);
                        a05timestamp_get (acv, a_data_ptr^, valpos+1, NOT c_undef,
                              mbp_buf, destpos+1, frec.fr_leng, b_err)
                        END;
                    (*ENDIF*) 
                    frec.fr_leng := mxsp_timestamp
                    END;
                OTHERWISE
                    BEGIN
                    CASE cdatatyp OF
                        dcha, dvarchara :
                            mbp_buf [destpos] := csp_ascii_blank;
                        OTHERWISE
                            mbp_buf [destpos] := csp_defined_byte
                        END;
                    (*ENDCASE*) 
                    IF  (a_initial_packet_header.sp1h_mess_code in
                        [ csp_unicode, csp_unicode_swap ]) AND
                        (cdatatyp in [ dcha, dvarchara ])
                        AND
                        NOT acv.a_ascii_in_and_output (* new feature *)
                    THEN
                        BEGIN
                        univallen := cdatalen;
                        s80uni_trans (@a_data_ptr^[ valpos + 1], frec.fr_leng,
                              a_initial_packet_header.sp1h_mess_code,
                              @mbp_buf[destpos+1], univallen, csp_ascii,
                              [ ], error, err_char_no);
                        IF  error = uni_ok
                        THEN
                            BEGIN
                            frec.fr_leng := univallen;
                            END
                        ELSE
                            a07_hex_uni_error (acv, error,
                                  -(valpos+err_char_no), NOT c_trans_to_uni,
                                  @(a_data_ptr^[ valpos + err_char_no ]),
                                  a_max_codewidth);
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        SAPDB_PascalMove ('VAK506',  41,    
                              a_data_length, mb_data_size,
                              @a_data_ptr^, valpos + 1,
                              @mbp_buf, destpos + 1, frec.fr_leng,
                              a_returncode)
                        END
                    (*ENDIF*) 
                    END
                END;
            (*ENDCASE*) 
            IF  b_err <> e_ok
            THEN
                a07_b_put_error (acv, b_err, -valpos);
            (*ENDIF*) 
            IF  (ccolstack.etype = st_varkey) AND (NOT truncated)
                AND (a_returncode = 0)
                AND (a_mblock.mb_type = m_key)
            THEN
                BEGIN
                (* in case of join view upd truncate key *)
                (* if not already done;                  *)
                (* e.g. cdatatype = dfloat               *)
                frec.fr_leng := s30lnr_defbyte (@mbp_buf, mbp_buf [destpos],
                      destpos + 1, frec.fr_leng)
                END;
            (*ENDIF*) 
            IF  (to_fill AND
                (a_returncode = 0))
            THEN
                BEGIN
                i := cinoutlen-frec.fr_leng-1;
&               ifdef TRACE
                t01int4 (ak_sem, 'fill_length ', i);
&               endif
                IF  i > 0
                THEN
                    CASE mbp_buf[ destpos ] OF
                        csp_ascii_blank :
                            SAPDB_PascalFill ('VAK506',  42,    
                                  mb_data_size, @mbp_buf,
                                  destpos+1+frec.fr_leng, i, csp_ascii_blank,
                                  a_returncode);
                        csp_unicode_def_byte :
                            SAPDB_PascalUnicodeFill ('VAK506',  43,    
                                  mb_data_size, @mbp_buf,
                                  destpos+1+frec.fr_leng, i, csp_unicode_blank,
                                  a_returncode);
                        OTHERWISE
                            SAPDB_PascalFill ('VAK506',  44,    
                                  mb_data_size, @mbp_buf,
                                  destpos+1+frec.fr_leng, i, csp_defined_byte,
                                  a_returncode)
                        END;
                    (*ENDCASE*) 
                (* PTS 1106107 E.Z. *)
                (*ENDIF*) 
                frec.fr_leng := pred(cinoutlen)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    frec.fr_leng := succ(frec.fr_leng)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak506vardata_from_datapart (
            VAR acv        : tak_all_command_glob;
            value_no       : integer;
            VAR colinfo    : tak00_columninfo;
            VAR frec       : tak_fill_rec;
            colset         : tak_fcolpropset);
 
VAR
      b_err      : tgg00_BasisError;
      ok         : boolean;
      i          : integer;
      numlen     : integer;
      univallen  : integer;
      mem_len    : integer;
      err        : tsp00_NumError;
      error      : tsp8_uni_error;
      err_char_no: tsp00_Int4;
      c64        : tsp00_C64;
      c64_ptr    : tsp00_MoveObjPtr;
      value_ptr  : tsp00_MoveObjPtr;
      valstart   : tsp00_MoveObjPtr;
      value_len  : tsp00_Int4;
      is_null    : boolean;
      is_default : boolean;
      msglist    : tak104_MsgList;
 
BEGIN
WITH acv, colinfo DO
    BEGIN
    b_err        := e_ok;
    frec.fr_leng := 0;
    msglist      := NIL;
    IF  NOT a509get_one_value (a_input_data_map, value_no,
        value_ptr, value_len, is_null, is_default)
    THEN
        a07ak_system_error (acv, 506, 6);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  is_default
        THEN
            IF  fp_default in colset
            THEN
                IF  true
                THEN
                    a07_b_put_error (acv, e_not_implemented, 1)
                ELSE
                    BEGIN
                    (*
                          mb_data_len := mb_data_len - lendiff;
                          lendiff     := 0;
                          ccolpropset := [  ];
                          a56one_default_value(acv, dmli, one_col,
                          fp_kind);
                          IF  a_returncode = 0
                          THEN
                          IF  ((fp_etype = st_varkey)
                          OR
                          (fp_etype = st_fixkey))
                          THEN
                          fr_leng := mb_data_len -
                          cgg_rec_key_offset - mbp_keylen
                          *)
                    END
                (*ENDIF*) 
            ELSE
                a07_b_put_error (acv, e_default_not_allowed, -value_no)
            (*ENDIF*) 
        ELSE
            BEGIN
            IF  is_null
            THEN
                mem_len := 1
            ELSE
                mem_len := cinoutlen;
            (*ENDIF*) 
            ok := ak104_CreateVariableField_IMS (a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist],
                  mem_len, valstart, msglist);
            IF  ok
            THEN
                IF  is_null
                THEN
                    BEGIN
                    frec.fr_leng := 0;
                    valstart^[ 1 ] := csp_undef_byte;
                    IF  NOT (fp_opt in colset)
                    THEN
                        a07_b_put_error (acv, e_mandatory_field_is_null, -value_no)
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    frec.fr_leng := value_len;
&                   ifdef TRACE
                    t01int4  (ak_sem, 'frec.fr_leng', frec.fr_leng);
&                   endif
                    CASE cdatatyp OF
                        dunicode :
                            BEGIN
                            valstart^[ 1 ] := csp_unicode_def_byte;
                            IF  (a_initial_packet_header.sp1h_mess_swap <> sw_normal) AND
                                (a_initial_packet_header.sp1h_mess_code <> csp_unicode)
                            THEN
                                BEGIN
                                univallen := cinoutlen - 1;
                                s80uni_trans (value_ptr, value_len,
                                      csp_unicode_swap,
                                      @valstart^[ 2 ], univallen, csp_unicode,
                                      [ ], error, err_char_no);
                                END
                            ELSE
                                BEGIN
                                univallen := value_len;
                                error := uni_ok;
                                SAPDB_PascalMove ('VAK506',  45,    
                                      value_len, mem_len, @value_ptr^, 1,
                                      valstart, 2, value_len, a_returncode)
                                END;
                            (*ENDIF*) 
                            IF  error = uni_ok
                            THEN
                                frec.fr_leng := univallen
                            ELSE
                                BEGIN
&                               ifdef TRACE
                                t01int4 (ak_sem, 'err_char_no ', err_char_no);
&                               endif
                                a07_hex_uni_error (acv, error,
                                      -value_no, c_trans_to_uni,
                                      @(value_ptr^[ err_char_no ]),
                                      a_max_codewidth);
                                END
                            (*ENDIF*) 
                            END;
                        dboolean :
                            BEGIN
                            valstart^[ 1 ] := csp_defined_byte;
                            IF  (value_ptr^[ 1 ] <> cgg04_truechar) AND
                                (value_ptr^[ 1 ] <> cgg04_falsechar)
                            THEN
                                a07_b_put_error (acv,
                                      e_const_incompatible_with_typ, -value_no)
                            ELSE
                                valstart^ [2] := value_ptr^[ 1 ];
                            (*ENDIF*) 
                            END;
                        dfixed, dfloat, dvfloat, dsmallint, dinteger :
                            BEGIN
                            valstart^[ 1 ] := csp_defined_byte;
                            FOR i := 2 TO value_len DO
                                BEGIN
                                IF  NOT a506mantissacheckarr [ord(value_ptr^[ i ])]
                                THEN
                                    a07_b_put_error (acv,
                                          e_invalid_number_variable, -value_no)
                                (*ENDIF*) 
                                END;
                            (*ENDFOR*) 
                            s51kroun (value_ptr^, 1, value_len,
                                  valstart^, 2,
                                  cdatalen, cdatafrac-cak_frac_offset,
                                  numlen, err);
                            IF  err = num_ok
                            THEN
                                numlen := s30lnr(valstart^, csp_defined_byte,
                                      2, numlen);
                            (*ENDIF*) 
                            frec.fr_leng := numlen;
                            IF  (err <> num_ok)
                            THEN
                                CASE err OF
                                    num_invalid :
                                        a07_b_put_error (acv,
                                              e_num_invalid, -value_no);
                                    num_trunc :
                                        a07_b_put_error (acv,
                                              e_num_truncated, -value_no);
                                    num_overflow :
                                        a07_b_put_error (acv,
                                              e_num_overflow, -value_no);
                                    END
                                (*ENDCASE*) 
                            ELSE
                                IF  cbinary
                                THEN
                                    a05int_range_check (acv, valstart^, 1, numlen,
                                          cdatalen, -value_no);
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        ddate :
                            BEGIN
                            valstart^ [1] := csp_ascii_blank;
                            IF  (a_initial_packet_header.sp1h_mess_code in
                                [ csp_unicode, csp_unicode_swap ])
                                AND
                                NOT acv.a_ascii_in_and_output (* new feature *)
                            THEN
                                BEGIN
                                univallen := sizeof (c64);
                                c64_ptr   := @c64;
                                s80uni_trans (value_ptr, value_len,
                                      a_initial_packet_header.sp1h_mess_code,
                                      c64_ptr, univallen, csp_ascii,
                                      [ ], error, err_char_no);
                                IF  error = uni_ok
                                THEN
                                    g03fdc_date(@c64, valstart, 1, 2,
                                          univallen, a_dt_format, b_err)
                                ELSE
                                    a07_hex_uni_error (acv, error,
                                          -value_no, NOT c_trans_to_uni,
                                          @(value_ptr^[ err_char_no ]),
                                          a_max_codewidth);
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
&                               ifdef trace
                                t01int4 (ak_sem, 'g1code.ctype', g01code.ctype);
                                t01int4 (ak_sem, 'mess_code   ', a_mess_code);
&                               endif
                                g03fdcheck_date(value_ptr^, valstart^,
                                      1, 2, value_len,
                                      a_dt_format, b_err);
                                END;
                            (*ENDIF*) 
                            frec.fr_leng := mxsp_date
                            END;
                        dtime :
                            BEGIN
                            valstart^ [1] := csp_ascii_blank;
                            IF  (a_initial_packet_header.sp1h_mess_code in
                                [ csp_unicode, csp_unicode_swap ])
                                AND
                                NOT acv.a_ascii_in_and_output (* new feature *)
                            THEN
                                BEGIN
                                univallen := sizeof (c64);
                                c64_ptr   := @c64;
                                s80uni_trans (value_ptr, value_len,
                                      a_initial_packet_header.sp1h_mess_code,
                                      c64_ptr, univallen, csp_ascii,
                                      [ ], error, err_char_no);
                                IF  error = uni_ok
                                THEN
                                    g03ftc_time(@c64, valstart, 1, 2,
                                          univallen, a_dt_format, b_err)
                                ELSE
                                    a07_hex_uni_error (acv, error,
                                          -value_no, NOT c_trans_to_uni,
                                          @(value_ptr^[ err_char_no ]),
                                          a_max_codewidth);
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                g03ftcheck_time(value_ptr^, valstart^,
                                      1, 2, value_len,
                                      a_dt_format, b_err);
                                END;
                            (*ENDIF*) 
                            frec.fr_leng := mxsp_time
                            END;
                        dtimestamp :
                            BEGIN
                            valstart^ [1] := csp_ascii_blank;
                            IF  (a_initial_packet_header.sp1h_mess_code in
                                [ csp_unicode, csp_unicode_swap ])
                                AND
                                NOT acv.a_ascii_in_and_output (* new feature *)
                            THEN
                                BEGIN
                                c64[ 1 ]  := csp_ascii_blank;
                                c64_ptr   := @c64[ 2 ];
                                univallen := sizeof (c64) - 1;
                                s80uni_trans (value_ptr, value_len,
                                      a_initial_packet_header.sp1h_mess_code,
                                      c64_ptr, univallen, csp_ascii,
                                      [ ], error, err_char_no);
                                c64_ptr   := @c64;
                                IF  error = uni_ok
                                THEN
                                    (* Funny but correct: the source buffer *)
                                    (* starts at the defined byte, but      *)
                                    (* univallen is the length without it.  *)
                                    a05timestamp_get (acv, c64_ptr^, 2, NOT c_undef,
                                          valstart^, 2, univallen, b_err)
                                ELSE
                                    a07_hex_uni_error (acv, error,
                                          -value_no, NOT c_trans_to_uni,
                                          @(value_ptr^[ err_char_no ]),
                                          a_max_codewidth);
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                a05timestamp_get (acv, value_ptr^, 1, is_null,
                                      valstart^, 2, value_len, b_err)
                                END;
                            (*ENDIF*) 
                            frec.fr_leng := mxsp_timestamp
                            END;
                        OTHERWISE
                            BEGIN
                            CASE cdatatyp OF
                                dcha, dvarchara :
                                    valstart^ [1] := csp_ascii_blank;
                                OTHERWISE
                                    valstart^ [1] := csp_defined_byte
                                END;
                            (*ENDCASE*) 
                            IF  (a_initial_packet_header.sp1h_mess_code in
                                [ csp_unicode, csp_unicode_swap ]) AND
                                (cdatatyp in [ dcha, dvarchara ])
                                AND
                                NOT acv.a_ascii_in_and_output (* new feature *)
                            THEN
                                BEGIN
                                univallen := cdatalen;
                                s80uni_trans (value_ptr, value_len,
                                      a_initial_packet_header.sp1h_mess_code,
                                      @valstart^[2], univallen, csp_ascii,
                                      [ ], error, err_char_no);
                                IF  error = uni_ok
                                THEN
                                    BEGIN
                                    frec.fr_leng := univallen;
                                    END
                                ELSE
                                    a07_hex_uni_error (acv, error,
                                          -value_no, NOT c_trans_to_uni,
                                          @(value_ptr^[ err_char_no ]),
                                          a_max_codewidth);
                                (*ENDIF*) 
                                END
                            ELSE
                                BEGIN
                                SAPDB_PascalMove ('VAK506',  46,    
                                      value_len, mem_len, @value_ptr^, 1,
                                      valstart, 2, value_len, a_returncode)
                                END
                            (*ENDIF*) 
                            END
                        END;
                    (*ENDCASE*) 
                    IF  b_err <> e_ok
                    THEN
                        a07_b_put_error (acv, b_err, -value_no)
                    ELSE
                        IF  (fp_like in colset) AND
                            ((fp_like1 in colset) OR (fp_like2 in colset))
                        THEN
                            BEGIN
                            i := cinoutlen-frec.fr_leng-1;
&                           ifdef TRACE
                            t01int4 (ak_sem, 'fill_length ', i);
&                           endif
                            IF  i > 0
                            THEN
                                CASE valstart^[ 1 ] OF
                                    csp_ascii_blank :
                                        SAPDB_PascalFill ('VAK506',  47,    
                                              mem_len, valstart,
                                              frec.fr_leng + 2, i, csp_ascii_blank,
                                              a_returncode);
                                    csp_unicode_def_byte :
                                        SAPDB_PascalUnicodeFill ('VAK506',  48,    
                                              mem_len, valstart,
                                              frec.fr_leng + 2, i, csp_unicode_blank,
                                              a_returncode);
                                    OTHERWISE
                                        SAPDB_PascalFill ('VAK506',  49,    
                                              mem_len, valstart,
                                              frec.fr_leng + 2, i, csp_defined_byte,
                                              a_returncode)
                                    END;
                                (*ENDCASE*) 
                            (* PTS 1106107 E.Z. *)
                            (*ENDIF*) 
                            frec.fr_leng := pred(cinoutlen)
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            frec.fr_leng := succ(frec.fr_leng);
            IF  a_returncode = 0
            THEN
                BEGIN
&               ifdef TRACE
                t01moveobj (ak_sem, valstart^, 1, frec.fr_leng);
&               endif
                ok := ak104_CloseCurrentField_IMS (a_mblock.mb_fieldlists[cgg_idx_param_valuefieldlist],
                      frec.fr_leng, msglist);
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak506variable_data_from_datapart (
            VAR acv        : tak_all_command_glob;
            value_no       : integer;
            field_kind     : tak_fp_kind_type;
            VAR colinfo    : tak00_columninfo;
            VAR frec       : tak_fill_rec;
            VAR to_fill    : boolean;
            VAR is_default : boolean);
 
VAR
      b_err      : tgg00_BasisError;
      destpos    : integer;
      i          : integer;
      numlen     : integer;
      univallen  : integer;
      err        : tsp00_NumError;
      error      : tsp8_uni_error;
      err_char_no: tsp00_Int4;
      c64        : tsp00_C64;
      c64_ptr    : tsp00_MoveObjPtr;
      value_ptr  : tsp00_MoveObjPtr;
      value_len  : tsp00_Int4;
      is_null    : boolean;
 
BEGIN
WITH acv, a_mblock, mb_data^, colinfo DO
    BEGIN
    b_err     := e_ok;
    destpos   := mb_data_len + 1;
    frec.fr_leng    := 0;
    IF  NOT a509get_one_value (a_input_data_map, value_no,
        value_ptr, value_len, is_null, is_default)
    THEN
        a07ak_system_error (acv, 506, 1);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  is_null
        THEN
            BEGIN
            mbp_buf[ destpos ] := csp_undef_byte;
            IF  ((ccolstack.etype = st_varkey) OR
                ( ccolstack.etype = st_varcol) OR
                ( ccolstack.etype = st_varlongchar))
            THEN
                frec.fr_leng := 0
            ELSE
                BEGIN
                frec.fr_leng := cinoutlen - 1;
                SAPDB_PascalFill ('VAK506',  50,    
                      mb_data_size, @mbp_buf, destpos+1, frec.fr_leng,
                      csp_defined_byte, a_returncode)
                END
            (*ENDIF*) 
            END
        ELSE
            IF  NOT is_default
            THEN
                BEGIN
                IF  (((ccolstack.etype = st_varkey) OR
                    (  ccolstack.etype = st_varcol) OR
                    (  ccolstack.etype = st_varlongchar))
                    AND
                    (NOT to_fill))
                THEN
                    BEGIN
                    frec.fr_leng := value_len;
                    IF  a_space_option AND
                        (frec.fr_leng = 0) AND
                        (cdatatyp in [ dcha, dvarchara]) AND
                        (* not for insert *)
                        (field_kind <> fp_val_varcol_with_len)
                    THEN
                        frec.fr_leng := 1;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    frec.fr_leng := value_len;
                    IF  field_kind in [ fp_val_varcol_with_len, fp_lock_val ]
                    THEN
                        to_fill := true;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
&               ifdef TRACE
                t01int4 (ak_sem, 'to_fill     ', ord(to_fill));
                t01int4  (ak_sem, 'start       ', destpos);
                t01int4  (ak_sem, 'frec.fr_leng', frec.fr_leng);
&               endif
                CASE cdatatyp OF
                    dunicode :
                        BEGIN
                        mbp_buf[ destpos ] := csp_unicode_def_byte;
                        IF  (a_initial_packet_header.sp1h_mess_swap <> sw_normal) AND
                            (a_initial_packet_header.sp1h_mess_code <> csp_unicode)
                        THEN
                            BEGIN
                            univallen := cinoutlen - 1;
                            s80uni_trans (value_ptr, value_len,
                                  csp_unicode_swap,
                                  @mbp_buf[ destpos + 1], univallen, csp_unicode,
                                  [ ], error, err_char_no);
                            END
                        ELSE
                            BEGIN
                            univallen := value_len;
                            error := uni_ok;
                            SAPDB_PascalMove ('VAK506',  51,    
                                  value_len, mb_data_size,
                                  @value_ptr^, 1,
                                  @mbp_buf, destpos + 1, value_len,
                                  a_returncode)
                            END;
                        (*ENDIF*) 
                        IF  error = uni_ok
                        THEN
                            IF  (((ccolstack.etype = st_varkey) OR
                                (  ccolstack.etype = st_varcol) OR
                                (  ccolstack.etype = st_varlongchar))
                                AND
                                (NOT to_fill))
                            THEN
                                frec.fr_leng := univallen
                            ELSE
                                BEGIN
                                i := cinoutlen-univallen-1;
&                               ifdef TRACE
                                t01int4 (ak_sem, 'fill_length ', i);
&                               endif
                                IF  i > 0
                                THEN
                                    SAPDB_PascalUnicodeFill ('VAK506',  52,    
                                          mb_data_size, @mbp_buf,
                                          destpos+1+univallen, i,
                                          csp_unicode_blank,
                                          a_returncode);
                                (*ENDIF*) 
                                frec.fr_leng := pred(cinoutlen)
                                END
                            (*ENDIF*) 
                        ELSE
                            BEGIN
&                           ifdef TRACE
                            t01int4 (ak_sem, 'err_char_no ', err_char_no);
&                           endif
                            a07_hex_uni_error (acv, error,
                                  -value_no, c_trans_to_uni,
                                  @(value_ptr^[ err_char_no ]),
                                  a_max_codewidth);
                            END
                        (*ENDIF*) 
                        END;
                    dboolean :
                        BEGIN
                        mbp_buf[ destpos ] := csp_defined_byte;
                        IF  (value_ptr^[ 1 ] <> cgg04_truechar) AND
                            (value_ptr^[ 1 ] <> cgg04_falsechar)
                        THEN
                            a07_b_put_error (acv,
                                  e_const_incompatible_with_typ, -value_no)
                        ELSE
                            mbp_buf [destpos + 1] := value_ptr^[ 1 ];
                        (*ENDIF*) 
                        END;
                    dfixed, dfloat, dvfloat, dsmallint, dinteger :
                        BEGIN
                        mbp_buf[ destpos ] := csp_defined_byte;
                        FOR i := 2 TO value_len DO
                            BEGIN
                            IF  NOT a506mantissacheckarr [ord(value_ptr^[ i ])]
                            THEN
                                a07_b_put_error (acv,
                                      e_invalid_number_variable, -value_no)
                            (*ENDIF*) 
                            END;
                        (*ENDFOR*) 
                        s51kroun (value_ptr^, 1, value_len,
                              mbp_buf, destpos+1,
                              cdatalen, cdatafrac-cak_frac_offset,
                              numlen, err);
                        IF  err = num_ok
                        THEN
                            numlen := s30lnr(mbp_buf, csp_defined_byte,
                                  destpos + 1, numlen);
                        (*ENDIF*) 
                        frec.fr_leng := numlen;
                        IF  (err <> num_ok)
                        THEN
                            CASE err OF
                                num_invalid :
                                    a07_b_put_error (acv,
                                          e_num_invalid, -value_no);
                                num_trunc :
                                    a07_b_put_error (acv,
                                          e_num_truncated, -value_no);
                                num_overflow :
                                    a07_b_put_error (acv,
                                          e_num_overflow, -value_no);
                                END
                            (*ENDCASE*) 
                        ELSE
                            IF  cbinary
                            THEN
                                a05int_range_check (acv, mbp_buf, destpos, numlen,
                                      cdatalen, -value_no);
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    ddate :
                        BEGIN
                        mbp_buf [destpos] := csp_ascii_blank;
                        IF  (a_initial_packet_header.sp1h_mess_code in
                            [ csp_unicode, csp_unicode_swap ])
                            AND
                            NOT acv.a_ascii_in_and_output (* new feature *)
                        THEN
                            BEGIN
                            univallen := sizeof (c64);
                            c64_ptr   := @c64;
                            s80uni_trans (value_ptr, value_len,
                                  a_initial_packet_header.sp1h_mess_code,
                                  c64_ptr, univallen, csp_ascii,
                                  [ ], error, err_char_no);
                            IF  error = uni_ok
                            THEN
                                g03fdc_date(@c64, @mbp_buf, 1, destpos+1,
                                      univallen, a_dt_format, b_err)
                            ELSE
                                a07_hex_uni_error (acv, error,
                                      -value_no, NOT c_trans_to_uni,
                                      @(value_ptr^[ err_char_no ]),
                                      a_max_codewidth);
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
&                           ifdef trace
                            t01int4 (ak_sem, 'g1code.ctype', g01code.ctype);
                            t01int4 (ak_sem, 'mess_code   ', a_mess_code);
&                           endif
                            g03fdcheck_date(value_ptr^, mbp_buf,
                                  1, destpos+1, value_len,
                                  a_dt_format, b_err);
                            END;
                        (*ENDIF*) 
                        frec.fr_leng := mxsp_date
                        END;
                    dtime :
                        BEGIN
                        mbp_buf [destpos] := csp_ascii_blank;
                        IF  (a_initial_packet_header.sp1h_mess_code in
                            [ csp_unicode, csp_unicode_swap ])
                            AND
                            NOT acv.a_ascii_in_and_output (* new feature *)
                        THEN
                            BEGIN
                            univallen := sizeof (c64);
                            c64_ptr   := @c64;
                            s80uni_trans (value_ptr, value_len,
                                  a_initial_packet_header.sp1h_mess_code,
                                  c64_ptr, univallen, csp_ascii,
                                  [ ], error, err_char_no);
                            IF  error = uni_ok
                            THEN
                                g03ftc_time(@c64, @mbp_buf, 1, destpos+1,
                                      univallen, a_dt_format, b_err)
                            ELSE
                                a07_hex_uni_error (acv, error,
                                      -value_no, NOT c_trans_to_uni,
                                      @(value_ptr^[ err_char_no ]),
                                      a_max_codewidth);
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            g03ftcheck_time(value_ptr^, mbp_buf,
                                  1, destpos+1, value_len,
                                  a_dt_format, b_err);
                            END;
                        (*ENDIF*) 
                        frec.fr_leng := mxsp_time
                        END;
                    dtimestamp :
                        BEGIN
                        mbp_buf [destpos] := csp_ascii_blank;
                        IF  (a_initial_packet_header.sp1h_mess_code in
                            [ csp_unicode, csp_unicode_swap ])
                            AND
                            NOT acv.a_ascii_in_and_output (* new feature *)
                        THEN
                            BEGIN
                            c64[ 1 ]  := csp_ascii_blank;
                            c64_ptr   := @c64[ 2 ];
                            univallen := sizeof (c64) - 1;
                            s80uni_trans (value_ptr, value_len,
                                  a_initial_packet_header.sp1h_mess_code,
                                  c64_ptr, univallen, csp_ascii,
                                  [ ], error, err_char_no);
                            c64_ptr   := @c64;
                            IF  error = uni_ok
                            THEN
                                (* Funny but correct: the source buffer *)
                                (* starts at the defined byte, but      *)
                                (* univallen is the length without it.  *)
                                a05timestamp_get (acv, c64_ptr^, 2, NOT c_undef,
                                      mbp_buf, destpos+1, univallen, b_err)
                            ELSE
                                a07_hex_uni_error (acv, error,
                                      -value_no, NOT c_trans_to_uni,
                                      @(value_ptr^[ err_char_no ]),
                                      a_max_codewidth);
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            a05timestamp_get (acv, value_ptr^, 1, is_null,
                                  mbp_buf, destpos+1, value_len, b_err)
                            END;
                        (*ENDIF*) 
                        frec.fr_leng := mxsp_timestamp
                        END;
                    OTHERWISE
                        BEGIN
                        CASE cdatatyp OF
                            dcha, dvarchara :
                                mbp_buf [destpos] := csp_ascii_blank;
                            OTHERWISE
                                mbp_buf [destpos] := csp_defined_byte
                            END;
                        (*ENDCASE*) 
                        IF  (a_initial_packet_header.sp1h_mess_code in
                            [ csp_unicode, csp_unicode_swap ]) AND
                            (cdatatyp in [ dcha, dvarchara ])
                            AND
                            NOT acv.a_ascii_in_and_output (* new feature *)
                        THEN
                            BEGIN
                            univallen := cdatalen;
                            s80uni_trans (value_ptr, value_len,
                                  a_initial_packet_header.sp1h_mess_code,
                                  @mbp_buf[destpos+1], univallen, csp_ascii,
                                  [ ], error, err_char_no);
                            IF  error = uni_ok
                            THEN
                                BEGIN
                                frec.fr_leng := univallen;
                                END
                            ELSE
                                a07_hex_uni_error (acv, error,
                                      -value_no, NOT c_trans_to_uni,
                                      @(value_ptr^[ err_char_no ]),
                                      a_max_codewidth);
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            SAPDB_PascalMove ('VAK506',  53,    
                                  value_len, mb_data_size,
                                  @value_ptr^, 1,
                                  @mbp_buf, destpos + 1, value_len,
                                  a_returncode)
                            END
                        (*ENDIF*) 
                        END
                    END;
                (*ENDCASE*) 
                IF  b_err <> e_ok
                THEN
                    a07_b_put_error (acv, b_err, -value_no);
                (*ENDIF*) 
                IF  (ccolstack.etype = st_varkey) AND (a_returncode = 0)
                THEN
                    frec.fr_leng := s30lnr_defbyte (@mbp_buf, mbp_buf [destpos], destpos + 1, frec.fr_leng);
                (*ENDIF*) 
                IF  (to_fill AND
                    (a_returncode = 0))
                THEN
                    BEGIN
                    i := cinoutlen-frec.fr_leng-1;
&                   ifdef TRACE
                    t01int4 (ak_sem, 'fill_length ', i);
&                   endif
                    IF  i > 0
                    THEN
                        CASE mbp_buf[ destpos ] OF
                            csp_ascii_blank :
                                SAPDB_PascalFill ('VAK506',  54,    
                                      mb_data_size, @mbp_buf,
                                      destpos+1+frec.fr_leng, i, csp_ascii_blank,
                                      a_returncode);
                            csp_unicode_def_byte :
                                SAPDB_PascalUnicodeFill ('VAK506',  55,    
                                      mb_data_size, @mbp_buf,
                                      destpos+1+frec.fr_leng, i, csp_unicode_blank,
                                      a_returncode);
                            OTHERWISE
                                SAPDB_PascalFill ('VAK506',  56,    
                                      mb_data_size, @mbp_buf,
                                      destpos+1+frec.fr_leng, i, csp_defined_byte,
                                      a_returncode)
                            END;
                        (*ENDCASE*) 
                    (* PTS 1106107 E.Z. *)
                    (*ENDIF*) 
                    frec.fr_leng := pred(cinoutlen)
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    frec.fr_leng := succ(frec.fr_leng)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a506_init_numbercheckarray;
 
VAR
      i : integer;
      j : integer;
 
BEGIN
FOR i := 0 TO 9 DO
    BEGIN
    FOR j := 0 TO 9 DO
        a506mantissacheckarr[ i * 16 + j ] := true;
    (*ENDFOR*) 
    FOR j := 10 TO 15 DO
        a506mantissacheckarr[ i * 16 + j ] := false;
    (*ENDFOR*) 
    END;
(*ENDFOR*) 
FOR i := 160 TO 255 DO
    a506mantissacheckarr [ i ] := false;
(*ENDFOR*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
