.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 1999-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
*****************************************************
Copyright (c) 1999-2005 SAP AG
SAP Database Technology
 
Release :      Date : 2000-10-05
*****************************************************
modname : VAK01
changed : 2000-10-05
module  : Scanner
 
Author  :
Created : 1985-02-06
*****************************************************
 
Purpose : Bearbeitungsroutinen fuer den variablen part (Eingabestring)
          Symbolerkennung.
 
Define  :
 
        VAR
              a01char_size           : integer;
              a01identifier_size     : integer;
              a01defaultkey          : tgg00_SysInfoKey;
              a01emptypriv           : tak_privilege;
              a01fullset             : tak_columnset;
              a01kw                  : tak_keywordtab;
              a01letter_dig_under    : tak_sqlm_charset;
              a01diag_monitor_on     : boolean;
              a01diag_moni_parseid   : boolean;
              a01diag_analyze_on     : boolean;
              a01diag_ana_coll_data  : boolean;
              a01nil_part_desc       : tsp1_part_header;
              a01QueryRewriteMode    : tak_queryrewrite_mode; (* PTS 1128197 D.T. *)
              a01sm_collect_data     : boolean;
              a01sysnullkey          : tgg00_SysInfoKey;
              a01digits              : tak_charset;
              a01_letters            : tak_sqlm_charset;
              a01_first_id_char      : tak_sqlm_charset;
              a01controluser         : tsp00_KnlIdentifier;
              a01_i_authorization    : tsp00_KnlIdentifier;
              a01_i_dbarole          : tsp00_KnlIdentifier;
              a01_i_catalog          : tsp00_KnlIdentifier;
              a01_i_count            : tsp00_KnlIdentifier;
              a01_i_current          : tsp00_KnlIdentifier;
              a01_i_current_schema   : tsp00_KnlIdentifier;
              a01_i_cursor           : tsp00_KnlIdentifier;
              a01_i_errmsg           : tsp00_KnlIdentifier;
              a01_i_temp             : tsp00_KnlIdentifier;
              a01_i_domain           : tsp00_KnlIdentifier;
              a01_i_sys_appl         : tsp00_KnlIdentifier;
              a01_i_dual             : tsp00_KnlIdentifier;
              a01_i_java             : tsp00_KnlIdentifier;
              a01_i_main             : tsp00_KnlIdentifier;
              a01_i_new              : tsp00_KnlIdentifier;
              a01_i_old              : tsp00_KnlIdentifier;
              a01_i_oms_container    : tsp00_KnlIdentifier;
              a01_i_oms_schema       : tsp00_KnlIdentifier;
              a01_i_oms_identifier   : tsp00_KnlIdentifier;
              a01_i_postupgradecheck : tsp00_KnlIdentifier; (* PTS 1134997 M.Ki *)
              a01_i_postupgradechecku: tsp00_KnlIdentifier; (* PTS 1134997 M.Ki *)
              a01_i_rc               : tsp00_KnlIdentifier;
              a01_i_sysddltrigger    : tsp00_KnlIdentifier;
              a01_i_syscat1          : tsp00_KnlIdentifier;
              a01_i_syscat2          : tsp00_KnlIdentifier;
              a01_i_syschecktablelog : tsp00_KnlIdentifier;
              a01_i_sysmessages      : tsp00_KnlIdentifier;
              a01_i_sysdialoglibrary : tsp00_KnlIdentifier;
              a01_i_sysmonitor       : tsp00_KnlIdentifier;
              a01_i_sysmondata       : tsp00_KnlIdentifier;
              a01_i_sysparseid       : tsp00_KnlIdentifier;
              a01_i_syscmd_analyze   : tsp00_KnlIdentifier;
              a01_i_sysdata_analyze  : tsp00_KnlIdentifier;
              a01_i_sysproc          : tsp00_KnlIdentifier;
              a01_i_syscursorname    : tsp00_KnlIdentifier;
              a01_i_syserrormap      : tsp00_KnlIdentifier;
              a01_i_sysstatistics    : tsp00_KnlIdentifier;
              a01_i_sysupdstatlog    : tsp00_KnlIdentifier;
              a01_i_sysupdstatwanted : tsp00_KnlIdentifier;
              a01_i_public           : tsp00_KnlIdentifier;
              a01_i_queryrewriterules: tsp00_KnlIdentifier;
              a01_i_user             : tsp00_KnlIdentifier;
              a01_i_usergroup        : tsp00_KnlIdentifier;
              a01_i_sapr3            : tsp00_KnlIdentifier;
              a01_i_sysdd            : tsp00_KnlIdentifier;
              a01_i_sys              : tsp00_KnlIdentifier;
              a01_i_sysinfo          : tsp00_KnlIdentifier;
              a01_i_system           : tsp00_KnlIdentifier;
              a01_i_sysdba           : tsp00_KnlIdentifier; (* PTS 1111797 E.Z. *)
              a01_i_table            : tsp00_KnlIdentifier;
              a01_i_tablekey         : tsp00_KnlIdentifier;
              a01_i_show             : tsp00_KnlIdentifier;
              a01_i_ak_cache         : tsp00_KnlIdentifier;
              a01_i_oldpacket        : tsp00_KnlIdentifier;
              a01_i_expression       : tsp00_KnlIdentifier;
              a01_l_expression       : tsp00_Int2;
              a01_i_rowno            : tsp00_KnlIdentifier;
              a01_i_rest             : tsp00_KnlIdentifier;
              a01_i_asterisk         : tsp00_KnlIdentifier;
              a01_i_internal         : tsp00_KnlIdentifier;
              a01_i_tmpresult        : tsp00_KnlIdentifier;
              a01_i_b_identifier     : tsp00_Identifier;
              a01_il_b_identifier    : tsp00_KnlIdentifier;
              a01_into_res_name      : tsp00_KnlIdentifier;
              a01_zero_res_name      : tsp00_KnlIdentifier;
              a01_union_fill_resname : tsp00_KnlIdentifier;
              a01ht                  : char; (* horizontal tab  *)
              a01lf                  : char; (* line feed       *)
              a01cr                  : char; (* carriage return *)
              a01join_clust_read     : boolean;
 
        FUNCTION
              a01equal_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4;
                    cmp_char : char) : boolean;
 
        FUNCTION
              a01is_whitespace_char (
                    VAR m    : tsp00_MoveObj;
                    pos      : tsp00_Int4) : boolean;
 
        PROCEDURE
              a01_parser_init;
 
        PROCEDURE
              a01info_call_put (
                    VAR acv    : tak_all_command_glob;
                    proc       : tak_procs;
                    subproc    : tsp00_Int2;
                    VAR curr_n : tsp00_Int2;
                    VAR info_n : tsp00_Int2);
 
        FUNCTION
              a01is_ascii_unicode (
                    VAR m : tsp00_MoveObj;
                    pos   : integer) : boolean;
 
        FUNCTION
              a01is_identifier (
                    VAR identifier  : tsp00_MoveObj;
                    len             : integer;
                    sqlmode         : tsp00_SqlMode) : boolean;
 
        PROCEDURE
              a01_init_command (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_force_symbol (
                    VAR acv         : tak_all_command_glob;
                    expected_symbol : tak_sc_symbol;
                    VAR node1       : tsp00_Int2;
                    VAR node2       : tsp00_Int2);
 
        PROCEDURE
              a01_compact_cmd (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_next_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_is_end_symbol (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a01_put_node (
                    VAR acv    : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_put_same_node (
                    VAR acv    : tak_all_command_glob;
                    input_node : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_function_put (
                    VAR acv    : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_dt_put_datatype_node (
                    VAR acv    : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2;
                    data_type  : tsp00_DataType;
                    datalen    : tsp00_Int2;
                    datafrac   : tsp00_Int2;
                    inoutlen   : integer);
 
        PROCEDURE
              a01_call_put (
                    VAR acv  : tak_all_command_glob;
                    proc     : tak_procs;
                    subproc  : tsp00_Int2;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_call_put_queryrewrite (
                    VAR acv  : tak_all_command_glob;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01_get_keyword (
                    VAR acv      : tak_all_command_glob;
                    VAR index    : integer;
                    VAR reserved : boolean);
 
        PROCEDURE
              a01_write_keywords;
 
        PROCEDURE
              a01_is_odbc_syntax (
                    VAR acv      : tak_all_command_glob;
                    VAR partype  : tak_odbc_partype;
                    VAR functype : tak_odbc_functiontype);
 
        FUNCTION
              a01node_get_ptr (
                    VAR acv    : tak_all_command_glob;
                    tree_index : integer) : tsp00_MoveObjPtr;
 
        FUNCTION
              a01_odbc_end_ok (
                    VAR acv : tak_all_command_glob;
                    partype : tak_odbc_partype) : boolean;
 
        FUNCTION
              a01aligned_cmd_len (len : tsp00_Int4) : tsp00_Int4;
 
        PROCEDURE
              a01ptr_put_node (
                    VAR acv    : tak_all_command_glob;
                    ptr        : tsp00_MoveObjPtr;
                    VAR curr_n : tsp00_Int2);
 
        PROCEDURE
              a01setl_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tsp00_KnlIdentifier);
 
        PROCEDURE
              a01sets_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tak_oldidentifier);
 
        PROCEDURE
              a01set32_identifier (
                    VAR id         : tsp00_KnlIdentifier;
                    set_identifier : tsp00_Lname);
 
        FUNCTION
              a01swap_int2 (old : tsp00_Int2) : tsp00_Int2;
 
        PROCEDURE
              a01swap_cmd_part (
                    client_swap  : tsp00_SwapKind;
                    VAR cmd_part : tsp1_part_header);
 
        FUNCTION
              a01eqkw (
                    VAR a     : tak_keyword;
                    VAR b     : tsp00_MoveObj;
                    b_pos     : tsp00_Int4;
                    length    : integer) : boolean;
 
        FUNCTION
              a01mandatory_keyword (
                    VAR acv          : tak_all_command_glob;
                    required_keyword : integer) : boolean;
 
        FUNCTION
              a01_eqkey (
                    VAR a      : tak_keyword;
                    sqlmode    : tsp00_SqlMode;
                    VAR b      : tsp00_MoveObj;
                    VAR scv    : tak_scanner_glob) : boolean;
 
        PROCEDURE
              a01_get_password (
                    VAR acv        : tak_all_command_glob;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
        PROCEDURE
              a01_character_set (
                    VAR acv        : tak_all_command_glob;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
        PROCEDURE
              a01blank_skip_node (
                    VAR acv : tak_all_command_glob;
                    pos     : tsp00_Int4;
                    len     : tsp00_Int4);
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              Unicode-Scanner: VAK011;
 
        PROCEDURE
              a011u_get_pwd (
                    VAR acv        : tak_all_command_glob;
                    VAR put_node   : tsp00_Int2;
                    VAR last_node  : tsp00_Int2);
 
        PROCEDURE
              a011u_next_symbol (VAR acv : tak_all_command_glob);
 
        FUNCTION
              a011uni_eqkey (
                    VAR a     : tak_keyword;
                    VAR b     : tsp00_MoveObj;
                    b_pos     : tsp00_Int4;
                    length    : integer) : boolean;
 
      ------------------------------ 
 
        FROM
              AK_syntax_tools : VAK02;
 
        PROCEDURE
              a02_put_identifier (
                    VAR acv       : tak_all_command_glob;
                    VAR put_node  : tsp00_Int2;
                    VAR last_node : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_error (
                    VAR acv : tak_all_command_glob;
                    err  : tgg00_BasisError;
                    VAR nod1 : tsp00_Int2;
                    VAR nod2 : tsp00_Int2);
 
        PROCEDURE
              a07_b_put_error (
                    VAR acv : tak_all_command_glob;
                    b_err   : tgg00_BasisError;
                    err_code : tsp00_Int4);
 
        PROCEDURE
              a07_kw_put_error (
                    VAR acv  : tak_all_command_glob;
                    b_err    : tgg00_BasisError;
                    err_code : tsp00_Int4;
                    kw       : integer);
 
        PROCEDURE
              a07const_param (
                    VAR acv    : tak_all_command_glob;
                    param_no   : integer;
                    param_addr : tsp00_MoveObjPtr;
                    param_len  : integer);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10increment_ap_tree (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a10shrink_syntax_tree (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              SQLManager : VAK101;
 
        FUNCTION
              a101_SchemaMappingActive (
                    VAR acv : tak_all_command_glob) : boolean;
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK542;
 
        PROCEDURE
              a542internal_packet (
                    VAR acv                 : tak_all_command_glob;
                    release_internal_packet : boolean;
                    required_len            : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01glob           : tgg00_KernelGlobals;
              g01unicode        : boolean;
              g01controluser    : tgg04_ControlUser;
 
        FUNCTION
              g01packet_size : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Codetransformation_and_Coding : VGG02;
 
        VAR
              g02codetables : tgg04_CodeTables;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    src_upb  : tsp00_Int4;
                    dest_upb : tsp00_Int4;
                    src      : tsp00_MoveObjPtr;
                    src_pos  : tsp00_Int4;
                    dest     : tsp00_MoveObjPtr;
                    dest_pos : tsp00_Int4;
                    length   : tsp00_Int4;
                    VAR err  : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        FUNCTION
              s20buf_to_int4_swap (
                    VAR source     : tsp00_Int4;
                    si             : tsp00_Int4;
                    sourceswap     : tsp00_SwapKind;
                    destswap       : tsp00_SwapKind) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30map (
                    VAR code_t : tsp00_Ctable;
                    VAR source : tsp00_MoveObj;
                    spos       : tsp00_Int4;
                    VAR dest   : tsp00_MoveObj;
                    dpos       : tsp00_Int4;
                    length     : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-80: VSP80;
 
        PROCEDURE
              s80uni_trans
                    (src_ptr        : tsp00_MoveObjPtr;
                    src_len         : tsp00_Int4;
                    src_codeset     : tsp00_Int2;
                    dest_ptr        : tsp00_MoveObjPtr;
                    VAR dest_len    : tsp00_Int4;
                    dest_codeset    : tsp00_Int2;
                    trans_options   : tsp8_uni_opt_set;
                    VAR rc          : tsp8_uni_error;
                    VAR err_char_no : tsp00_Int4);
&       IFDEF TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures  : VTA01;
 
        PROCEDURE
              t01trace_kw(
                    debug   : tgg00_Debug;
                    name    : tsp00_Sname;
                    kw      : tak_keyword);
 
        PROCEDURE
              t01trace_symbol(
                    debug   : tgg00_Debug;
                    name    : tsp00_Sname;
                    symb    : tak_sc_symbol);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01moveobj (
                    debug       : tgg00_Debug;
                    VAR moveobj : tsp00_MoveObj;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01bufline (
                    debug  : tgg00_Debug;
                    VAR ln : tsp00_Line;
                    len    : integer);
 
      ------------------------------ 
 
        FROM
              Syntax-Tree-Printer : VAK99;
 
        PROCEDURE
              a99init;
&       ENDIF
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        FUNCTION
              s20buf_to_int4_swap;
 
              tsp00_MoveObj tsp00_Int4
 
.CM *-END-* synonym -------------------------------------
***********************************************************
 
Specification:
 
PROCEDURE  a01_parser_init:
.sp
Initialisiert globale Gr?o?zen f?ur den Scanner..
Der Aufruf  mu?z einmal am Anfang der Arbeiten mit der
Datenbank aufgerufen werden.
.sp 4
PROCEDURE  a01_init_command :
.sp
Belegt die Anfangswerte f?ur die Auswertung des variab_part
(sc_syspos = 1, sc_newpos = 1 und liest erstes Symbol)
.sp 4
PROCEDURE  a01_next_symbol :
.sp
Sucht das n?achste Symbol, das zuinterpretieren ist und
belegt die entsprechende Variablen sc_symb, sc_sypos,
sc_sylength und sc_newpos.
Bei Fehlererkennung wird sc_symb gleich s_unknown gesetzt.
Dies kann der Fall sein bei
.br
a ]  Symbol f?angt mit Sonderzeichen an,
Variablenname darf mit ':' anfangen,
.br
b ]  Real Exponent ist falsch,
.br
c ]  Bei Commandstring Ende wird sc_symb := s_eof.
.sp 4
PROCEDURE  a01_is_end_symbol :
.sp
Fragt, ob der Wert im Puffer an der Position sc_newpos gr?o?zer
als a_cmd_part^.sp1p_buf_len ist. Bei nein ist der Functionwert
false und die Fehlermeldung 'invalid_command_end' wird gesetzt.
.CM *-END-* specification -------------------------------
***********************************************************
 
Description:
 
PROCEDURE  a01_init_command:
.sp
Globale Gr?o?zen aus scanner_glob:
init :  sc_newpos    actuelle position des zuletzt gelesenen
                     Zeichens im  variab_part
init :  sc_sypos     actuelle position des zuletzt gelesenen
                     Symbols
used :  vp           variab_part
.sp 4
PROCEDURE  a01_next_symbol:
.sp
Globale Gr?o?zen aus scv:
init :  sc_sylength  actuelle L?ange des gelesenen Symbols aus
                     dem variab_part
        sc_sypos     Positionsanfang des gelesenen Symbols
        sc_symb      Symbolkennzeichnung (Enumerationwert von symbole)
repl :  sc_newpos    actuelle position des zuletzt gelesenen
                     Zeichens aus dem variab_part
used :  vp           variab_part
.sp 4
PROCEDURE  is_end_symbol;
.sp
Globale Gr?o?zen aus glob8:
used :  sc_symb      Symbolkennzeichnung (Enumerationwert von symbole)
init :  returncode   invalid_command_end, wenn kein s_eof vorhanden.
.CM *-END-* description ---------------------------------
***********************************************************
 
.CM -lll-
Code    :
 
 
CONST
      c_release_internal_packet = true;
      c_mx_extra_len            = 24;
      c_nls_numeric_characters  = 'NLS_NUMERIC_CHARACTERS  ';
 
TYPE
 
      control_entry = RECORD
            first_pos : integer;
            last_pos  : integer;
      END;
 
      tak01_set_sqlmode = SET OF tsp00_SqlMode;
 
      tak01myline = RECORD
            CASE boolean OF
                true:
                    (line : tsp00_Line);
                false:
                    (filler5 : tsp00_C5;
                    key1     : tak_keyword;
                    fillerk1 : tsp00_C1;
                    key2     : tak_keyword;
                    fillerk2 : tsp00_C1;
                    key3     : tak_keyword;
                    fillerk3 : tsp00_C1);
                END;
            (*ENDCASE*) 
 
 
VAR
      a01_kw_control        : ARRAY [ 'A'..'Z' ] OF control_entry;
      a01kw_sqlmode         : ARRAY [ 0..cak_maxkeyword ] OF
            tak01_set_sqlmode;
      ak01identifier_chars  : tak_sqlm_charset;
      ak01res_kw            : ARRAY [ 0..cak_maxkeyword, tsp00_SqlMode ] OF
            boolean;
      ak01myline            : tak01myline;
      (* PTS 1121518 E.Z. *)
      ak01upp_first_id_char : tak_sqlm_charset;
      ak01upp_id_char       : tak_sqlm_charset;
 
 
(*------------------------------*) 
 
PROCEDURE
      a01blank_skip_node (
            VAR acv : tak_all_command_glob;
            pos : tsp00_Int4;
            len : tsp00_Int4);
 
VAR
      found : boolean;
      ix    : integer;
 
BEGIN
ix := 0;
IF  acv.a_scv_index = 0
THEN
    BEGIN
    found               := true;
    acv.a_errpos_offset := len
    END
ELSE
    BEGIN
    found := false;
    ix    := 0;
    WHILE NOT found AND (acv.a_ap_tree^[ix].n_sa_level <> 0) DO
        BEGIN
        ix := acv.a_ap_tree^[ix].n_sa_level;
        IF  acv.a_ap_tree^[ix].n_pos = pos + 1
        THEN
            found := true
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  NOT found
THEN
    BEGIN
    a01_put_node (acv, acv.a_ap_tree^[ix].n_sa_level);
    IF  acv.a_returncode = 0
    THEN
        WITH acv.a_ap_tree^[acv.a_ap_tree^[ix].n_sa_level] DO
            BEGIN
            n_proc     := a90;
            n_special  := [ni_blank_skip];
            n_pos      := pos;
            n_subproc  := len DIV csp_maxint2;
            n_length   := len MOD csp_maxint2;
            n_datatype := dunknown;
            n_subproc  := 0;
            n_sa_level := 0;
            n_lo_level := 0;
            (* D.T. QueryRewrite *)
            n_refback   := cak_qrewrite_ref_init;
            n_querycheck:= [];
            n_dt_format := acv.a_dt_format;
            (* *)
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak01special_identifier (
            VAR acv : tak_all_command_glob;
            VAR dif : integer);
 
VAR
      is_blank_identifier : boolean;
      stringend           : boolean;
      c                   : char;
      j                   : tsp00_Int4;
      aux_int             : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    sc_sypos := succ(sc_newpos);
    sc_symb             := s_identifier;
    sc_double_quote     := 1;
    is_blank_identifier := true;
    sc_newpos := succ(sc_newpos);
    WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
          AND
          (a_cmd_part^.sp1p_buf [ sc_newpos ]  <> '"') DO
        BEGIN
        IF  (a_cmd_part^.sp1p_buf[ sc_newpos ] <> bsp_c1) AND
            (a_cmd_part^.sp1p_buf[ sc_newpos ] <> '"')
        THEN
            is_blank_identifier := false;
        (*ENDIF*) 
        sc_newpos := succ(sc_newpos);
        END;
    (*ENDWHILE*) 
    IF  sc_newpos > a_cmd_part^.sp1p_buf_len
    THEN
        BEGIN
        a07_error (acv, e_invalid_end_of_command,
              aux_int, aux_int);
        sc_symb := s_eof
        END
    ELSE
        BEGIN
        sc_newpos := succ(sc_newpos);
        IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
        THEN
            BEGIN
            IF  a_cmd_part^.sp1p_buf[ sc_newpos ] = '"'
            THEN
                (* PTS 1117265 E.Z. *)
                BEGIN
                sc_states := sc_states + [ scs_pack ];
                is_blank_identifier := false;
                (* at least '"' is the identifier *)
                stringend := false;
                j         := sc_newpos;
                c         := ' ';
                REPEAT
                    REPEAT
                        sc_newpos := succ(sc_newpos);
                        IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                        THEN
                            BEGIN
                            c := a_cmd_part^.sp1p_buf[ sc_newpos ];
                            j := succ(j)
                            END;
                        (*ENDIF*) 
                    UNTIL
                        (c = '"') OR (sc_newpos > a_cmd_part^.sp1p_buf_len);
                    (*ENDREPEAT*) 
                    IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                    THEN (* Error: eof in the middle of a special id! *)
                        BEGIN
                        stringend := true;
                        sc_symb   := s_eof
                        END
                    ELSE (* c = '"' *)
                        BEGIN
                        sc_newpos := succ(sc_newpos);
                        IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                        THEN (* Correct terminated special id direct at eof *)
                            stringend := true
                        ELSE (* is there another double quote? *)
                            stringend := (a_cmd_part^.sp1p_buf[ sc_newpos ] <>'"')
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                UNTIL
                    stringend;
                (*ENDREPEAT*) 
                dif := sc_newpos - j + 1;
                END
            ELSE
                dif := 1
            (*ENDIF*) 
            END
        ELSE
            dif := 1
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    (* PTS 1103134 E.Z. *)
    IF  is_blank_identifier AND (a_is_ddl <> no_ddl)
    THEN
        sc_symb := s_unknown;
&   IFDEF TRACE
    (*ENDIF*) 
    t01p2int4 (ak_syn, 'sc_symb     ', ord(sc_symb),
          'sc_newpos   ', sc_newpos);
    t01p2int4 (ak_syn, 'sc_sylength ', sc_sylength,
          'dif         ', dif);
&   ENDIF
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak01string_literal (
            VAR acv : tak_all_command_glob;
            VAR dif : integer);
 
VAR
      stringend      : boolean;
      j              : tsp00_Int4;
      aux_int        : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  sc_symb = s_unknown
    THEN
        sc_symb := s_string_literal;
    (*ENDIF*) 
    sc_sypos := succ(sc_newpos);
    sc_newpos := succ(sc_newpos);
    WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
          AND
          (a_cmd_part^.sp1p_buf[ sc_newpos ] <> '''') DO
        sc_newpos := succ(sc_newpos);
    (*ENDWHILE*) 
    IF  sc_newpos > a_cmd_part^.sp1p_buf_len
    THEN
        BEGIN
        a07_error (acv, e_invalid_end_of_command,
              aux_int, aux_int);
        sc_symb := s_eof
        END
    ELSE
        BEGIN
        sc_newpos := succ(sc_newpos);
        IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
        THEN
            BEGIN
            IF  a_cmd_part^.sp1p_buf[ sc_newpos ] = ''''
            THEN
                BEGIN
                sc_states  := sc_states + [ scs_pack ];
                stringend := false;
                j         := sc_newpos;
                REPEAT
                    sc_newpos := succ(sc_newpos);
                    j         := j + 1;
                    WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                          AND
                          (a_cmd_part^.sp1p_buf[sc_newpos] <> '''') DO
                        BEGIN
                        sc_newpos := succ(sc_newpos);
                        j         := j + 1;
                        END;
                    (*ENDWHILE*) 
                    IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                    THEN (* Error: eof in the middle of a string! *)
                        BEGIN
                        a07_error (acv, e_invalid_end_of_command,
                              aux_int, aux_int);
                        stringend := true;
                        sc_symb   := s_eof
                        END
                    ELSE (* c = '''' *)
                        BEGIN
                        sc_newpos := succ(sc_newpos);
                        IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                        THEN (* Correct terminated string direct at eof *)
                            stringend := true
                        ELSE (* is there another quote? *)
                            stringend := (a_cmd_part^.sp1p_buf[sc_newpos] <>'''')
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                UNTIL
                    stringend;
                (*ENDREPEAT*) 
                dif := sc_newpos - j + 1
                END
            ELSE
                dif := 1
            (*ENDIF*) 
            END
        ELSE
            dif := 1
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (sc_newpos - sc_sypos - dif = 0) AND
        (a_sqlmode = sqlm_oracle)
    THEN
        sc_symb := s_identifier;
&   IFDEF TRACE
    (*ENDIF*) 
    t01p2int4 (ak_syn, 'sc_symb     ', ord(sc_symb),
          'sc_newpos   ', sc_newpos);
    t01p2int4 (ak_syn, 'sc_sylength ', sc_sylength,
          'dif         ', dif);
&   ENDIF
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak01tree_enlargement (VAR acv : tak_all_command_glob);
 
BEGIN
a10increment_ap_tree (acv)
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak01trigger_parameter (VAR acv : tak_all_command_glob);
 
VAR
      sy_pos  : tsp00_Int4;
      aux_scv : tak_scanner_glob;
 
BEGIN
sy_pos := acv.a_scv.sc_sypos;
a01_next_symbol(acv);
IF  acv.a_scv.sc_symb = s_identifier
THEN
    BEGIN
    aux_scv := acv.a_scv;
    a01_next_symbol (acv);
    IF  acv.a_scv.sc_symb = s_point
    THEN
        BEGIN
        a01_next_symbol (acv);
        END
    ELSE
        acv.a_scv := aux_scv
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  acv.a_scv.sc_symb <> s_identifier
THEN
    a07_b_put_error (acv, e_invalid_parameter, acv.a_scv.sc_sypos)
ELSE
    acv.a_scv.sc_symb := s_parameter_name;
(*ENDIF*) 
acv.a_scv.sc_sypos := sy_pos
END;
 
(*------------------------------*) 
 
FUNCTION
      a01equal_char (
            VAR m    : tsp00_MoveObj;
            pos      : tsp00_Int4;
            cmp_char : char) : boolean;
 
BEGIN
IF  g01unicode
THEN
    a01equal_char := (m[pos] = csp_unicode_mark) AND
          (m[pos+1] = cmp_char)
ELSE
    a01equal_char := m[pos] = cmp_char
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a01is_whitespace_char (
            VAR m    : tsp00_MoveObj;
            pos      : tsp00_Int4) : boolean;
 
BEGIN
(* PTS 1105418 G.G.*)
IF  g01unicode
THEN
    a01is_whitespace_char := (m[pos] = csp_unicode_mark) AND
          ((m[pos+1] = bsp_c1) OR
          (m[pos+1] = a01ht)  OR
          (m[pos+1] = a01lf)  OR
          (m[pos+1] = a01cr))
ELSE
    a01is_whitespace_char := ( m[pos] = bsp_c1 ) OR ( m[pos] = a01ht ) OR
          ( m[pos] = a01lf ) OR ( m[pos] = a01cr )
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a01is_ascii_unicode (
            VAR m : tsp00_MoveObj;
            pos : integer) : boolean;
 
BEGIN
IF  g01unicode
THEN
    a01is_ascii_unicode := (m[pos] = csp_unicode_mark)
ELSE
    a01is_ascii_unicode := true
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01info_call_put (
            VAR acv    : tak_all_command_glob;
            proc       : tak_procs;
            subproc    : tsp00_Int2;
            VAR curr_n : tsp00_Int2;
            VAR info_n : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    IF  ((a_is_ddl <> no_ddl) AND (a_ex_kind <> only_syntax))
        OR
        NOT a_optimize_info.o_do_optimize
    THEN
        BEGIN
        a01_call_put (acv, proc, subproc, curr_n);
        info_n := 0
        END
    ELSE
        BEGIN
        IF  a_scv_index < a_maxnode
        THEN
            IF  ni_skip_node in a_ap_tree^[a_scv_index+1].n_special
            THEN
                a_scv_index := a_ap_tree^[a_scv_index+1].n_pos - 1
            ELSE
                IF  a_scv_index + 2 < a_maxnode
                THEN
                    IF  ni_skip_node in
                        a_ap_tree^[a_scv_index+2].n_special
                    THEN
                        a_scv_index := a_ap_tree^[a_scv_index+2].n_pos - 1;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        WHILE  (a_scv_index + 2 > a_ap_max_node) AND
              (a_returncode = 0) DO
            BEGIN
            IF  a_scv_index + 1 = a_ap_max_node
            THEN
                (* one not used node to go one node further with a_scv_index *)
                a01_call_put (acv, proc, subproc, curr_n);
            (*
                  a_ap_tree^[ a_scv_index ].n_special :=
                  a_ap_tree^[ a_scv_index ].n_special +
                  [ ni_skip_node ];
                  a_ap_max_node := a_scv_index;
                  *)
            (*ENDIF*) 
            ak01tree_enlargement (acv);
            IF  a_scv_index + 2 > a_ap_max_node
            THEN
                a_scv_index := a_scv_index + 1
            (*ENDIF*) 
            END;
        (*ENDWHILE*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            a01_call_put (acv, proc, subproc, curr_n);
            a_ap_tree^[curr_n].n_special :=
                  a_ap_tree^[curr_n].n_special + [ni_info_node];
            a_scv_index := a_scv_index + 1;
            IF  a_scv_index > a_maxnode
            THEN
                a_maxnode := a_scv_index;
            (*ENDIF*) 
            info_n      := a_scv_index;
            WITH a_ap_tree^[info_n] DO
                BEGIN
                n_proc     := no_proc;
                n_special  := [];
                n_symb     := s_unknown;
                n_datatype := dunknown;
                n_subproc  := 0;
                n_length   := 0;
                n_pos      := sc_sypos;
                IF  g01unicode AND (n_pos > 1)
                THEN
                    BEGIN
                    IF  (a_cmd_part^.sp1p_buf[n_pos - 1] = '"') AND
                        (a_cmd_part^.sp1p_buf[n_pos - 2] = csp_unicode_mark)
                    THEN
                        n_pos := n_pos - 2;
                    (*ENDIF*) 
                    END
                ELSE
                    IF  (NOT g01unicode) AND
                        (n_pos > 0)
                    THEN
                        IF  a_cmd_part^.sp1p_buf[n_pos - 1] = '"'
                        THEN
                            n_pos := n_pos - 1;
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
                n_lo_level := 0;
                n_sa_level := 0;
                (* D.T. QueryRewrite *)
                n_refback   := cak_qrewrite_ref_init;
                n_querycheck:= [];
                n_dt_format := a_dt_format;
                (* *)
                END
            (*ENDWITH*) 
            END
        ELSE
            BEGIN
            curr_n := 0;
            info_n := 0
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01ptr_put_node (
            VAR acv    : tak_all_command_glob;
            ptr        : tsp00_MoveObjPtr;
            VAR curr_n : tsp00_Int2);
 
BEGIN
a01_call_put (acv, a999ptr_node, 0, curr_n);
WITH acv.a_ap_tree^[curr_n] DO
    BEGIN
    SAPDB_PascalForcedMove (sizeof(ptr),  sizeof(n_subproc) + sizeof(n_length) + sizeof(n_pos),
          @ptr, 1, @n_subproc, 1, sizeof(ptr));
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a01node_get_ptr (
            VAR acv    : tak_all_command_glob;
            tree_index : integer) : tsp00_MoveObjPtr;
 
VAR
      ptr : tsp00_MoveObjPtr;
 
BEGIN
WITH acv.a_ap_tree^[tree_index] DO
    IF  n_proc = a999ptr_node
    THEN
        BEGIN
        SAPDB_PascalForcedMove (sizeof(n_subproc) + sizeof(n_length) + sizeof(n_pos), sizeof(ptr),
              @n_subproc, 1, @ptr, 1, sizeof(ptr));
        a01node_get_ptr := ptr
        END
    ELSE
        a01node_get_ptr := NIL
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a01is_identifier (
            VAR identifier : tsp00_MoveObj;
            len     : integer;
            sqlmode : tsp00_SqlMode) : boolean;
 
VAR
      is_ascii      : boolean;
      is_identifier : boolean;
      i             : integer;
      i_len         : integer;
      left          : integer;
      right         : integer;
      middle        : integer;
      i_identifier  : tsp00_KnlIdentifier;
      err_char_no   : tsp00_Int4;
      uni_err       : tsp8_uni_error;
 
      hkw        : RECORD
            CASE boolean OF
                true :
                    (kw  : tak_keyword);
                false :
                    (c24 : tsp00_C24);
                END;
            (*ENDCASE*) 
 
 
BEGIN
is_identifier := false;
uni_err       := uni_ok;
is_ascii      := true;
is_identifier := false;
i_len         := a01identifier_size;
&ifdef trace
t01moveobj (ak_sem, identifier, 1, len);
&endif
IF  g01unicode
THEN
    BEGIN
    i_len := sizeof(tsp00_KnlIdentifier);
    s80uni_trans (@identifier, len, csp_unicode,
          @i_identifier, i_len, csp_ascii, [ ], uni_err,
          err_char_no);
    IF  uni_err <> uni_ok
    THEN
        BEGIN
        (* PTS 1121518 E.Z. *)
        IF  ((identifier[ 2 ] in ak01upp_first_id_char[sqlmode])
            AND (identifier[ 1 ] = csp_unicode_mark))
            OR
            (ord(identifier[ 2 ]) > 127)
            OR
            (identifier[ 1 ] <> csp_unicode_mark)
        THEN
            BEGIN
            is_identifier := true;
            i := 4;
            WHILE i <= len DO
                BEGIN
                IF  (identifier [ i-1 ] = csp_unicode_mark) AND
                    (identifier [ i   ] <= chr(127))        AND
                    (* PTS 1121518 E.Z. *)
                    NOT (i_identifier[ i   ] in ak01upp_id_char[sqlmode])
                THEN
                    is_identifier := false;
                (*ENDIF*) 
                i := i + 2
                END
            (*ENDWHILE*) 
            END;
        (*ENDIF*) 
        is_ascii := false
        END
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  len <= sizeof(i_identifier)
    THEN
        BEGIN
        SAPDB_PascalForcedMove (len, sizeof(i_identifier),
              @identifier, 1, @i_identifier, 1, len);
        i_len := len
        END
    ELSE
        BEGIN
        is_ascii := false;
        is_identifier := false
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  is_ascii AND
    (* PTS 1121518 E.Z. *)
    (i_identifier[ 1 ] in ak01upp_first_id_char[sqlmode])
THEN
    BEGIN
    is_identifier := true;
    FOR i := 2 TO i_len DO
        (* PTS 1121518 E.Z. *)
        IF  NOT (i_identifier[ i ] in ak01upp_id_char[sqlmode])
        THEN
            is_identifier := false;
        (*ENDIF*) 
    (*ENDFOR*) 
    END;
(*ENDIF*) 
IF  is_identifier               AND
    (i_len <= sizeof (hkw.c24)) AND
    is_ascii                    AND
    (i_identifier[ 1 ] in [ 'A'..'I', 'J'..'R', 'S'..'Z' ])
THEN
    BEGIN
    hkw.c24 := bsp_c24;
    SAPDB_PascalForcedMove (sizeof (i_identifier), sizeof (hkw.c24),
          @i_identifier, 1, @hkw.c24, 1, i_len);
    IF  hkw.c24 = c_nls_numeric_characters
    THEN
        is_identifier := NOT (ak01res_kw[cak_i_nls_numeric_chars, sqlmode]);
    (*ENDIF*) 
    IF  is_identifier AND (i_len <= sizeof (a01kw[1])) AND
        (i_identifier[ 1 ] in [ 'A'..'I', 'J'..'R', 'S'..'Z' ])
    THEN
        BEGIN
        (* check, if identifier is a reserved keyword *)
        WITH a01_kw_control[i_identifier[1]] DO
            BEGIN
            left  := first_pos;
            right := last_pos;
            END;
        (*ENDWITH*) 
        REPEAT
            middle := (left + right) DIV 2;
            IF  (a01kw[middle] > hkw.kw)
            THEN
                right := middle - 1
            ELSE
                left  := middle + 1;
            (*ENDIF*) 
        UNTIL
            (left > right);
        (*ENDREPEAT*) 
        IF  NOT (sqlmode IN a01kw_sqlmode[right])
        THEN
            right := 0;
        (*ENDIF*) 
        IF  right > 0
        THEN
            IF  a01kw[right] = hkw.kw
            THEN
                is_identifier := NOT ak01res_kw[right, sqlmode]
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
&ifdef trace
(*ENDIF*) 
t01int4 (ak_sem, 'is_identifie', ord (is_identifier));
&endif
a01is_identifier := is_identifier
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_parser_init;
 
CONST
      c_ak_cache           = 'AK_CACHE          ';
      c_authorization      = 'AUTHORIZATION     ';
      c_catalog            = 'SYSCATALOG        ';
      c_count              = '$COUNT            ';
      c_current            = 'CURRENT           ';
      c_current_schema     = 'CURRENT_SCHEMA    ';
      c_cursor             = '$CURSOR           ';
      c_dbarole            = 'DBAROLE           ';
      c_errmsg             = '$ERRMSG           ';
      c_expression         = 'EXPRESSION        ';
      c_internal           = 'INTERNAL          ';
      c_java               = 'JAVA              ';
      c_main               = 'MAIN              ';
      c_temp_res           = 'TEMPORARY RESULT  ';
      c_oldpacket          = 'OLDPACKET         ';
      c_oms_schema         = 'OMS               ';
      c_oms_container      = 'OMS_CONTAINER     ';
      c_postupgradecheck   = 'POSTUPGRADECHECKLIST            ';
      c_postupgradechecku  = 'POSTUPGRADECHECKLISTUNICODE     ';
      c_queryrewriterules  = 'QUERYREWRITERULES ';
      c_rc                 = '$RC               ';
      c_rest               = 'REST              ';
      c_rowno              = 'ROWNO             ';
      c_sapr3              = 'SAPR3             ';
      c_sysddltrigger      = 'SYSDDLTRIGGERPL   ';
      c_syschecktablelog   = 'SYSCHECKTABLELOG  ';
      c_sysinfo            = 'SYSINFO           ';
      c_sysmonitor         = 'SYSMONITOR        ';
      c_sysmondata         = 'SYSMONDATA        ';
      c_syscmd_analyze     = 'SYSCMD_ANALYZE    ';
      c_sysdata_analyze    = 'SYSDATA_ANALYZE   ';
      c_sysproc            = 'SYSPROC           ';
      c_syscursorname      = 'SYSCURSORNAME     ';
      c_sysstatistics      = 'SYSSTATISTICS     ';
      c_sysupdstatlog      = 'SYSUPDSTATLOG     ';
      c_sysupdstatwanted   = 'SYSUPDSTATWANTED  ';
      c_usergroup          = 'USERGROUP         ';
      c_asterisk           = '*                 ';
      ln_sysdialoglibrary  = 'SYSDIALOGLIBRARY  ';
 
VAR
      i         : integer;
      sqlm      : tsp00_SqlMode;
      underline : SET OF char;
 
BEGIN
&IFDEF TRACE
a99init;
&ENDIF
IF  g01unicode
THEN
    BEGIN
    a01identifier_size := sizeof(tsp00_KnlIdentifier);
    a01char_size := 2;
    END
ELSE
    BEGIN
    a01identifier_size := sizeof (tsp00_KnlIdentifier) DIV 2;
    a01char_size := 1;
    END;
(*ENDIF*) 
a01sets_identifier (a01_il_b_identifier, bsp_name);
SAPDB_PascalForcedMove (sizeof (a01_il_b_identifier), sizeof (a01_i_b_identifier),
      @a01_il_b_identifier, 1, @a01_i_b_identifier, 1,
      sizeof (a01_i_b_identifier));
a01sets_identifier (a01_i_ak_cache,     c_ak_cache);
a01sets_identifier (a01_i_asterisk,     c_asterisk);
a01sets_identifier (a01_i_domain,       cak_domain_user);
a01sets_identifier (a01_i_dual,         cak_ln_dual);
a01sets_identifier (a01_i_expression,   c_expression);
a01_l_expression := 10;
a01sets_identifier (a01_i_authorization,      c_authorization);
a01sets_identifier (a01_i_catalog,            c_catalog);
a01sets_identifier (a01_i_current,            c_current);
a01sets_identifier (a01_i_current_schema,     c_current_schema);
a01sets_identifier (a01_i_cursor,             c_cursor); (* $cursor variable in triggers *)
a01sets_identifier (a01_i_count,              c_count);  (* $count variable in triggers *)
a01sets_identifier (a01_i_dbarole,            c_dbarole);
a01sets_identifier (a01_i_errmsg,             c_errmsg);
a01sets_identifier (a01_i_internal,           c_internal);
a01sets_identifier (a01_i_java,               c_java);
(* PTS 1111797 E.Z. *)
a01sets_identifier (a01_i_main,               c_main);
a01sets_identifier (a01_i_new,                cak_ln_new);
a01sets_identifier (a01_i_old,                cak_ln_old);
a01sets_identifier (a01_i_oms_schema,         c_oms_schema);
a01sets_identifier (a01_i_oms_identifier,     c_oms_schema);
a01sets_identifier (a01_i_oms_container,      c_oms_container);
a01sets_identifier (a01_i_rc,                 c_rc); (* return code variable in triggers *)
a01sets_identifier (a01_i_oldpacket,          c_oldpacket);
a01set32_identifier (a01_i_postupgradecheck,  c_postupgradecheck);
a01set32_identifier (a01_i_postupgradechecku, c_postupgradechecku);
a01sets_identifier (a01_i_public,             cak_u_public);
a01sets_identifier (a01_i_queryrewriterules,  c_queryrewriterules);
a01sets_identifier (a01_i_rest,               c_rest);
a01sets_identifier (a01_i_rowno,              c_rowno);
a01sets_identifier (a01_i_sapr3,              c_sapr3);
a01sets_identifier (a01_i_show,               cak_ln_show);
a01sets_identifier (a01_i_sysddltrigger,      c_sysddltrigger);
a01sets_identifier (a01_i_sys,                cak_u_oracle_sys);
a01sets_identifier (a01_i_sysinfo,            c_sysinfo);
a01sets_identifier (a01_i_system,             cak_ln_system);
a01sets_identifier (a01_i_sys_appl,           cak_sys_application);
(* PTS 1115978 E.Z. *)
(* PTS 1104393 E.Z. *)
a01sets_identifier (a01_i_sysdialoglibrary,   ln_sysdialoglibrary);
a01sets_identifier (a01_i_syscat1,            cak_ln_syscat1);
a01sets_identifier (a01_i_syscat2,            cak_ln_syscat2);
a01sets_identifier (a01_i_syschecktablelog,   c_syschecktablelog);
a01sets_identifier (a01_i_sysdba,             cak_ln_sysdba);
a01sets_identifier (a01_i_sysdd,              cak_u_sys);
a01sets_identifier (a01_i_syserrormap,        cak_ln_syserrormap);
a01sets_identifier (a01_i_sysmessages,        cak_ln_sysmessages);
a01sets_identifier (a01_i_sysmonitor,         c_sysmonitor);
a01sets_identifier (a01_i_sysmondata,         c_sysmondata);
a01sets_identifier (a01_i_sysparseid,         cak_ln_sysparseid);
a01sets_identifier (a01_i_syscmd_analyze,     c_syscmd_analyze);
a01sets_identifier (a01_i_sysdata_analyze,    c_sysdata_analyze);
a01sets_identifier (a01_i_sysproc,            c_sysproc);
a01sets_identifier (a01_i_syscursorname,      c_syscursorname);
a01sets_identifier (a01_i_sysstatistics,      c_sysstatistics);
a01sets_identifier (a01_i_sysupdstatlog,      c_sysupdstatlog);
a01sets_identifier (a01_i_sysupdstatwanted,   c_sysupdstatwanted);
a01sets_identifier (a01_i_table,              cak_ln_table);
a01sets_identifier (a01_i_tablekey,           cak_n_tablekey);
a01sets_identifier (a01_i_temp,               cak_temp_user_name);
a01sets_identifier (a01_i_tmpresult,          c_temp_res);
a01sets_identifier (a01_i_user,               cak_ln_user);
a01sets_identifier (a01_i_usergroup,          c_usergroup);
FOR i := 1 TO sizeof (a01_zero_res_name) DO
    a01_zero_res_name[i] := chr(0);
(*ENDFOR*) 
a01_into_res_name := a01_zero_res_name;
a01_into_res_name[sizeof (a01_into_res_name)] := chr(1);
FOR i := 1 TO sizeof (a01_zero_res_name) DO
    a01_union_fill_resname[i] := chr(1);
(*ENDFOR*) 
IF  g01code.ctype = csp_ascii
THEN
    BEGIN
    FOR sqlm := sqlm_ansi TO sqlm_internal DO
        (* PTS 1121518 E.Z. *)
        BEGIN
        ak01upp_first_id_char[sqlm] := [ 'A'..'Z',
              chr(192).. chr(214), (* A grave .. O umlaut *)
              (* PTS 1107832 E.Z. *)
              chr(216).. chr(223), (* O slash ..  *)
              '@', '#', '$' ];
        a01_first_id_char[sqlm] := [ 'a'..'z',
              chr(224).. chr(246), (* a grave .. o umlaut *)
              chr(248).. chr(255)  (* o slash .. ij ligature *) ] +
              ak01upp_first_id_char[sqlm] ;
        END;
    (*ENDFOR*) 
    a01_first_id_char    [sqlm_oracle] :=
          a01_first_id_char    [sqlm_oracle] - ['@'];
    ak01upp_first_id_char[sqlm_oracle] :=
          ak01upp_first_id_char[sqlm_oracle] - ['@'];
    FOR sqlm := sqlm_ansi TO sqlm_internal DO
        (* PTS 1121518 E.Z. *)
        a01_letters[sqlm] := a01_first_id_char[sqlm];
    (*ENDFOR*) 
    (* PTS 1107832 E.Z. *)
    a01ht             := chr(9);  (* HT *)
    a01lf             := chr(10); (* LF *)
    a01cr             := chr(13); (* CR *)
    END
ELSE
    BEGIN
    FOR sqlm := sqlm_ansi TO sqlm_internal DO
        BEGIN      (* PTS 1121518 E.Z. *)
        ak01upp_first_id_char[sqlm] := [ 'A'..'I', 'J'..'R', 'S'..'Z',
              (* PTS 1107832 E.Z. *)
              chr( 89),
              chr( 98) .. chr(105),
              chr(128),
              chr(158),
              chr(172) .. chr(174),
              chr(235) .. chr(239),
              chr(251) .. chr(254),
              '@', '#', '$' ];
        a01_first_id_char[sqlm] := [ 'a'..'i', 'j'..'r', 's'..'z' ] +
              ak01upp_first_id_char[sqlm];
        END;
    (*ENDFOR*) 
    a01_first_id_char    [sqlm_oracle] :=
          a01_first_id_char    [sqlm_oracle] - ['@'];
    ak01upp_first_id_char[sqlm_oracle] :=
          ak01upp_first_id_char[sqlm_oracle] - ['@'];
    FOR sqlm := sqlm_ansi TO sqlm_internal DO
        (* PTS 1121518 E.Z. *)
        a01_letters[sqlm] := [
              chr( 66) .. chr(73),
              (* PTS 1107832 E.Z. *)
              chr( 81) .. chr(88),
              chr(112),
              chr(140) .. chr(142),
              chr(156),
              chr(203) .. chr(207),
              chr(219) .. chr(223)  ] +
              a01_first_id_char[sqlm];
    (*ENDFOR*) 
    a01ht             := chr(5);  (* HT *)
    a01lf             := chr(25); (* LF *)
    a01cr             := chr(15); (* Zeilenvorschub mit Wagenruecklauf *)
    END;
(*ENDIF*) 
a01digits           :=  [ '1','2','3','4','5','6','7','8','9','0' ];
underline           :=  [ '_' ];
FOR sqlm := sqlm_ansi TO sqlm_internal DO
    BEGIN
    a01letter_dig_under[sqlm] :=
          a01_letters[sqlm] + a01digits + underline;
    ak01identifier_chars[sqlm] :=
          a01_first_id_char[sqlm] + a01digits + underline;
    (* PTS 1121518 E.Z. *)
    ak01upp_id_char[sqlm] := ak01upp_first_id_char[sqlm] + a01digits + underline;
    END;
(*ENDFOR*) 
a01diag_monitor_on    := false;
a01diag_moni_parseid  := false;
a01diag_analyze_on    := false;
a01diag_ana_coll_data := false;
a01join_clust_read    := true;
(* a01QueryRewriteMode   := Statement_Rewrite; *)
a01sm_collect_data    := false;
ak01init_keyword_tab;
WITH a01sysnullkey DO
    BEGIN
    FOR i := 1 TO SURROGATE_MXGG00 DO
        sauthid[ i ] := bsp_c1;
    (*ENDFOR*) 
    sidentifier := a01_il_b_identifier;
    sentrytyp   := cak_etable;
    slinkage    := cak_zero_linkage;
    skeylen     := mxak_standard_sysk;
    END;
(*ENDWITH*) 
a01defaultkey := a01sysnullkey;
WITH a01defaultkey DO
    BEGIN
    sauthid  := cgg_zero_id;
    slinkage := cak_init_linkage;
    END;
(*ENDWITH*) 
WITH a01emptypriv DO
    BEGIN
    priv_all_set       := [  ];
    priv_all_grant_set := [  ];
    priv_col_exist     := [  ];
    priv_filler        := false;
    priv_sel_set       := [  ];
    priv_upd_set       := [  ];
    priv_ref_set       := [  ];
    priv_grant_sel_set := [  ];
    priv_grant_upd_set := [  ];
    priv_grant_ref_set := [  ]
    END;
(*ENDWITH*) 
a01fullset := [  ];
FOR i := 1 TO MAX_COL_PER_TAB_GG00 DO
    a01fullset := a01fullset + [ i ];
(*ENDFOR*) 
WITH a01nil_part_desc DO
    BEGIN
    sp1p_part_kind   := sp1pk_data;
    sp1p_attributes  := [ ];
    sp1p_arg_count   := 1;
    sp1p_segm_offset := 0;
    sp1p_buf_len     := 0;
    sp1p_buf_size    := 0
    END;
(*ENDWITH*) 
a01setl_identifier (a01controluser, g01controluser.gg04cu_user)
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_init_command (VAR acv : tak_all_command_glob);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    a_scv_index   := 0;
    a_maxnode     := 0;
    WITH a_ap_tree^[ a_scv_index ] DO
        BEGIN
        n_proc     := a90;
        n_special  := [];
        n_symb     := s_link;
        n_datatype := dunknown;
        n_pos      := csp_minint2;
        n_length   := csp_minint2;
        n_subproc  := csp_minint2;
        n_lo_level := csp_minint2;
        n_sa_level := 0;
        (* D.T. QueryRewrite *)
        n_refback   := cak_qrewrite_ref_init;
        n_querycheck:= [];
        n_dt_format := a_dt_format;
        (* *)
        END;
    (*ENDWITH*) 
    sc_symb             := s_unknown;
    sc_eof_symb         := s_unknown;
    sc_eof_kw           := cak_i_no_keyword;
    sc_newpos           := 1;
    sc_sypos            := 1;
    sc_states           := [];
    sc_filler           := true;
    sc_double_quote     := 0;
    a_first_hint_node   := csp_minint2;
    a_count_variab      := 0;
    a_count_literals    := 0;
    a_count_output_params:=0;
    a_first_output_param:= MAX_INT2_SP00;
    a_leftpar_cnt       := 0;
    a_rightpar_cnt      := 0;
    a_insert_select     := false;
    a_compact_varpart   := false;
    (* a DDL command was recognized beforehand, this command should be save *)
    IF  ((a_init_ddl = no_ddl) AND
        (a_is_ddl in [ddl_create_view, ddl_create_domain]))
    THEN
        a01_compact_cmd (acv);
    (*ENDIF*) 
    a_union_cnt         := 0;
    a_sql_cmd_state     := [];
    a_rowno_allowed     := false;
    a_rowno_found       := false;
    a_limit_allowed     := false;
    a_limit_found       := false;
    a_limit_node        := 0;
    a_in_select_list    := false;
    (* PTS 1116169 E.Z. *)
    a_oneval_subq_allowed := false;
    IF  (acv.a_qualified_jv_upd = no_jv_upd) OR
        (a_ex_kind <> only_parsing)
    THEN
        a_input_data_pos := 1;
    (*ENDIF*) 
    a_output_data_pos := 1;
    IF  a_max_intern_select = 0
    THEN
        BEGIN
        IF  ((a_comp_type <> at_odbc) AND
            (a_comp_type <> at_jdbc) AND
            ((a_ex_kind = only_parsing) OR
            (a_ex_kind = only_syntax)  OR
            (a_ex_kind = only_executing)))
            OR (a_curr_user_name = a01_il_b_identifier)
        THEN
            a_costcheck := false
        ELSE
            IF  ((a_costwarn_value <> csp_maxint4) OR
                (a_costlimit_value <> csp_maxint4))
            THEN
                a_costcheck := true
            ELSE
                a_costcheck := false;
            (*ENDIF*) 
        (*ENDIF*) 
        a_costsum := 0;
        END;
    (*ENDIF*) 
    IF  acv.a_proc_compile = pct_none
    THEN
        a_queryrewrite_mode := a01QueryRewriteMode
    ELSE
        a_queryrewrite_mode := No_Rewrite;
    (*ENDIF*) 
    a_queryrewrite_done     := No_Rewrite;
    a_queryrewrite_exec     := [];
    a_queryrewrite_modified := false;
    a_explain_kind  := ex_default;
    a_resultnum     := csp_rescnt_unknown;
    a_first_serial  := csp_null_number;
    a_last_serial   := csp_null_number;
    a_outer_n       := 0;
    a_outer_join    := false;
    a_from_select   := false;
    a_fromsel_n     := 0;
    a_err_parm_cnt  := 0;
    a_cpart_type    := cpt_unknown;
    a_no_of_likes   := 0;
    a_next_upos     := 0;
    IF  a_ap_max_node <> cak_init_node
    THEN
        a10shrink_syntax_tree (acv);
    (*ENDIF*) 
    IF  a_ex_kind <> only_executing
    THEN
        a01_next_symbol (acv)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_force_symbol (
            VAR acv         : tak_all_command_glob;
            expected_symbol : tak_sc_symbol;
            VAR node1       : tsp00_Int2;
            VAR node2       : tsp00_Int2);
 
VAR
      c : tsp00_C2;
 
BEGIN
&ifdef trace
t01trace_symbol(ak_syn, '            ', expected_symbol );
&endif
WITH acv DO
    IF  a_returncode = 0
    THEN
        IF  a_scv.sc_symb = expected_symbol
        THEN
            a01_next_symbol (acv)
        ELSE
            BEGIN
            c := '  ';
            CASE expected_symbol OF
                s_comma :
                    c[2] := ',';
                s_equal :
                    c[2] := '=';
                s_leftpar :
                    c[2] := '(';
                s_rightpar :
                    c[2] := ')';
                s_minus :
                    c[2] := '-';
                s_plus :
                    c [2]:= '+';
                s_point :
                    c[2] := '.';
                s_semicolon :
                    c[2] := ';';
                s_asterisk  :
                    c[2] := '*';
                s_colon     :
                    c[2] := ':';
                OTHERWISE ;
                END;
            (*ENDCASE*) 
            IF  c[2] <> bsp_c1
            THEN
                a07_error (acv, e_missing_delimiter, node1, node2)
            ELSE
                a07_error (acv, e_missing_keyword, node1, node2);
            (*ENDIF*) 
            a07const_param (acv, 1, @c, sizeof (c))
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_next_symbol (VAR acv : tak_all_command_glob);
 
CONST
      dopp = ':';
 
VAR
      c                   : char;
      l_bracket           : char;
      r_bracket           : char;
      prev_symb           : tak_sc_symbol;
      i                   : tsp00_Int4;
      dif                 : integer;
      pos                 : tsp00_Int4;
      hint                : tsp00_Int2;
      odbc_partype        : tak_odbc_partype;
      odbc_functype       : tak_odbc_functiontype;
      scvh                : tak_scanner_glob;
      recursive_call      : boolean; (* PTS 1118015 U.J. *)
 
BEGIN
(* PTS 1116837 E.Z. every loop was changed *)
IF  g01unicode
THEN
    a011u_next_symbol (acv)
ELSE
    WITH acv, a_scv DO
        BEGIN
        recursive_call := false; (* PTS 1118015 U.J. *)
        hint        := sc_newpos - sc_sypos;
        sc_sylength := 0;
        prev_symb   := sc_symb;
        sc_symb     := s_unknown;
        sc_states   := sc_states - [ scs_pack ];
        dif         := 0;
        sc_lastpos  := sc_newpos - 1;
        pos         := sc_newpos;
        WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
              AND
              ((a_cmd_part^.sp1p_buf [ sc_newpos ] = bsp_c1) OR
              ( a_cmd_part^.sp1p_buf [ sc_newpos ] = a01ht ) OR
              ( a_cmd_part^.sp1p_buf [ sc_newpos ] = a01lf ) OR
              ( a_cmd_part^.sp1p_buf [ sc_newpos ] = a01cr )) DO
            sc_newpos := succ(sc_newpos);
        (*ENDWHILE*) 
        IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
        THEN
            BEGIN
            IF  a_compact_varpart
            THEN
                IF  (sc_newpos > pos + 1) OR
                    ((sc_newpos = pos + 1) AND
                    ((a_cmd_part^.sp1p_buf[sc_newpos] in [',',')']) OR
                    ( prev_symb = s_leftpar)))
                THEN
                    BEGIN
                    IF  (a_cmd_part^.sp1p_buf[sc_newpos] in [',',')']) OR
                        (prev_symb = s_leftpar)
                    THEN
                        pos := pos - 1;
                    (*ENDIF*) 
                    SAPDB_PascalOverlappingMove ('VAK01 ',   1,    
                          a_cmd_part^.sp1p_buf_len, a_cmd_part^.sp1p_buf_len,
                          @a_cmd_part^.sp1p_buf, sc_newpos,
                          @a_cmd_part^.sp1p_buf, pos + 1,
                          a_cmd_part^.sp1p_buf_len - sc_newpos + 1,
                          a_returncode);
                    a_cmd_part^.sp1p_buf_len := a_cmd_part^.sp1p_buf_len
                          - (sc_newpos - pos - 1);
                    a01blank_skip_node (acv,
                          pos + 1, sc_newpos - pos - 1);
                    sc_newpos := pos + 1;
&                   IFDEF TRACE
                    t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, 1, a_cmd_part^.sp1p_buf_len);
                    t01int4    (ak_sem, 'sc_newpos   ', sc_newpos);
&                   ENDIF
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            c := a_cmd_part^.sp1p_buf [ sc_newpos ];
            (* PTS 1121518 E.Z. *)
            IF  (((c = 'X') OR (c = 'x')) AND
                (a_sqlmode <> sqlm_ansi))
            THEN
                BEGIN
                i := succ(sc_newpos);
                WHILE (i < a_cmd_part^.sp1p_buf_len)
                      AND
                      ((a_cmd_part^.sp1p_buf [ i ] = bsp_c1) OR
                      ( a_cmd_part^.sp1p_buf [ i ] = a01ht ) OR
                      ( a_cmd_part^.sp1p_buf [ i ] = a01lf ) OR
                      ( a_cmd_part^.sp1p_buf [ i ] = a01cr )) DO
                    i := succ(i);
                (*ENDWHILE*) 
                IF  i < a_cmd_part^.sp1p_buf_len
                THEN
                    IF  a_cmd_part^.sp1p_buf[ i ] = ''''
                    THEN
                        BEGIN
                        sc_newpos := i;
                        c := a_cmd_part^.sp1p_buf[ sc_newpos ];
                        sc_symb := s_byte_string;
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            sc_sypos := sc_newpos;
            IF  c in a01_first_id_char[a_sqlmode]
            THEN
                BEGIN
                sc_symb := s_identifier;
                sc_double_quote := 0;
                WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                      AND
                      (a_cmd_part^.sp1p_buf[ sc_newpos ] in
                      a01letter_dig_under[a_sqlmode]) DO
                    sc_newpos := succ(sc_newpos);
                (*ENDWHILE*) 
                (* PTS 1121518 E.Z. *)
                s30map (g02codetables.tables[ cgg04_up_ascii ],
                      a_cmd_part^.sp1p_buf, sc_sypos,
                      a_cmd_part^.sp1p_buf, sc_sypos, sc_newpos - sc_sypos);
                IF  acv.a_scv.sc_eof_kw <> cak_i_no_keyword
                THEN
                    BEGIN
                    sc_sylength := sc_newpos - sc_sypos;
                    IF  (a01_eqkey (a01kw[acv.a_scv.sc_eof_kw], a_sqlmode,
                        acv.a_cmd_part^.sp1p_buf, a_scv))
                    THEN
                        BEGIN
                        sc_symb   := s_eof;
                        sc_newpos := sc_sypos
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                IF  c = '"'
                THEN
                    ak01special_identifier (acv, dif)
                ELSE
                    IF  ((c >= '0') AND (c <= '9')) OR
                        (c = '.')
                    THEN
                        BEGIN
                        sc_symb := s_unknown;
                        IF  c = '.'
                        THEN
                            BEGIN
                            sc_symb   := s_point;
                            sc_newpos := succ(sc_newpos);
                            WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                  AND
                                  (a_cmd_part^.sp1p_buf [ sc_newpos ] >= '0')
                                  AND
                                  (a_cmd_part^.sp1p_buf [ sc_newpos ] <= '9') DO
                                BEGIN
                                sc_symb := s_fixed_point_literal;
                                sc_newpos := succ(sc_newpos);
                                END;
                            (*ENDWHILE*) 
                            END
                        ELSE
                            BEGIN
                            sc_symb := s_unsigned_integer;
                            sc_newpos := succ(sc_newpos);
                            WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                  AND
                                  (a_cmd_part^.sp1p_buf[ sc_newpos ] >= '0')
                                  AND
                                  (a_cmd_part^.sp1p_buf[ sc_newpos ] <= '9') DO
                                sc_newpos := succ(sc_newpos);
                            (*ENDWHILE*) 
                            IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                            THEN
                                IF  a_cmd_part^.sp1p_buf [ sc_newpos ] = '.'
                                THEN
                                    BEGIN
                                    sc_symb := s_fixed_point_literal;
                                    sc_newpos := succ(sc_newpos);
                                    WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                          AND
                                          (a_cmd_part^.sp1p_buf[ sc_newpos ] >= '0')
                                          AND
                                          (a_cmd_part^.sp1p_buf[ sc_newpos ] <= '9') DO
                                        sc_newpos := succ(sc_newpos);
                                    (*ENDWHILE*) 
                                    END;
                                (*ENDIF*) 
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                        THEN
                            (* PTS 1121518 E.Z. *)
                            IF  (
                                (a_cmd_part^.sp1p_buf [ sc_newpos ] = 'E') OR
                                (a_cmd_part^.sp1p_buf [ sc_newpos ] = 'e'))
                                AND (sc_symb <> s_point)
                            THEN
                                BEGIN
                                (* PTS 1121518 E.Z. *)
                                a_cmd_part^.sp1p_buf [ sc_newpos ] := 'E';
                                sc_newpos := succ(sc_newpos);
                                IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                    AND
                                    ((a_cmd_part^.sp1p_buf [ sc_newpos ] = '+') OR
                                    ( a_cmd_part^.sp1p_buf [ sc_newpos ] = '-'))
                                THEN
                                    sc_newpos := succ(sc_newpos);
                                (*ENDIF*) 
                                IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                    AND
                                    (a_cmd_part^.sp1p_buf [ sc_newpos ] >= '0')
                                    AND
                                    (a_cmd_part^.sp1p_buf[ sc_newpos ] <= '9')
                                THEN
                                    BEGIN
                                    sc_symb := s_floating_point_literal;
                                    i := 0;
                                    WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                          AND
                                          (a_cmd_part^.sp1p_buf[ sc_newpos ] >= '0')
                                          AND
                                          (a_cmd_part^.sp1p_buf[ sc_newpos ] <= '9') DO
                                        BEGIN
                                        i := succ(i);
                                        sc_newpos := succ(sc_newpos);
                                        END;
                                    (*ENDWHILE*) 
                                    IF  i > 3
                                    THEN
                                        sc_symb := s_unknown;
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    sc_symb := s_unknown;
                                (*ENDIF*) 
                                END
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    ELSE
                        IF  c = ''''
                        THEN
                            ak01string_literal (acv, dif)
                        ELSE
                            IF  ((c = csp_ascii_tilde) AND
                                (g01code.ctype = csp_ascii))
                            THEN
                                BEGIN
                                sc_symb   := s_unknown;
                                sc_newpos := succ(sc_newpos);
                                IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                THEN
                                    IF  a_cmd_part^.sp1p_buf[ sc_newpos ] = '='
                                    THEN
                                        BEGIN
                                        sc_symb   := s_unequal;
                                        sc_newpos := succ(sc_newpos);
                                        END
                                    ELSE
                                        IF  a_cmd_part^.sp1p_buf[ sc_newpos ] = '<'
                                        THEN
                                            BEGIN
                                            sc_symb   := s_greater_or_eq;
                                            sc_newpos := succ(sc_newpos);
                                            END
                                        ELSE
                                            IF  a_cmd_part^.sp1p_buf[ sc_newpos ] = '>'
                                            THEN
                                                BEGIN
                                                sc_symb   := s_less_or_eq;
                                                sc_newpos := succ(sc_newpos);
                                                END;
                                            (*ENDIF*) 
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END
                            ELSE
                                IF  ((c = csp_ascii_not) AND
                                    (g01code.ctype = csp_ascii))
                                THEN
                                    BEGIN
                                    sc_symb   := s_unknown;
                                    sc_newpos := succ(sc_newpos);
                                    IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                    THEN
                                        IF  a_cmd_part^.sp1p_buf[ sc_newpos ] = '='
                                        THEN
                                            BEGIN
                                            sc_symb   := s_unequal;
                                            sc_newpos := succ(sc_newpos);
                                            END
                                        (*ENDIF*) 
                                    (*ENDIF*) 
                                    END
                                ELSE
                                    CASE c OF
                                        '!' :
                                            BEGIN
                                            sc_symb   := s_unknown;
                                            sc_newpos := succ(sc_newpos);
                                            IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                            THEN
                                                IF  a_cmd_part^.sp1p_buf[ sc_newpos ] = '='
                                                THEN
                                                    BEGIN
                                                    sc_symb   := s_unequal;
                                                    sc_newpos := succ(sc_newpos);
                                                    END
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END;
                                        '>' :
                                            BEGIN
                                            sc_symb := s_greater;
                                            sc_newpos := succ(sc_newpos);
                                            IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                            THEN
                                                IF  a_cmd_part^.sp1p_buf [ sc_newpos ] = '='
                                                THEN
                                                    BEGIN
                                                    sc_symb := s_greater_or_eq;
                                                    sc_newpos := succ(sc_newpos);
                                                    END;
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END;
                                        (*less,lessequal*)
                                        '<' :
                                            BEGIN
                                            sc_newpos := succ(sc_newpos);
                                            sc_symb := s_less;
                                            IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                            THEN
                                                IF  a_cmd_part^.sp1p_buf [ sc_newpos ] = '='
                                                THEN
                                                    BEGIN
                                                    sc_symb := s_less_or_eq;
                                                    sc_newpos := succ(sc_newpos);
                                                    END
                                                ELSE
                                                    IF  a_cmd_part^.sp1p_buf [ sc_newpos ] = '>'
                                                    THEN
                                                     BEGIN
                                                     sc_symb := s_unequal;
                                                     sc_newpos := succ(sc_newpos);
                                                     END;
                                                    (*ENDIF*) 
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END;
                                        (* colon *)
                                        dopp :
                                            BEGIN
                                            l_bracket :=
                                                  cak_l_ascii_sq_bracket;
                                            r_bracket :=
                                                  cak_r_ascii_sq_bracket;
                                            sc_symb := s_colon;
                                            sc_newpos := succ(sc_newpos);
                                            IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                            THEN
                                                IF  (a_cmd_part^.sp1p_buf [ sc_newpos ] in
                                                    a01letter_dig_under[a_sqlmode])
                                                    OR
                                                    ((acv.a_is_ddl = ddl_create_trigger) AND
                                                    ( a_cmd_part^.sp1p_buf [ sc_newpos ] = '"'))
                                                THEN
                                                    BEGIN
                                                    IF  acv.a_is_ddl = ddl_create_trigger
                                                    THEN
                                                     ak01trigger_parameter (acv)
                                                    ELSE
                                                     BEGIN
                                                     sc_symb := s_parameter_name;
                                                     WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                                        AND
                                                        (a_cmd_part^.sp1p_buf [ sc_newpos ] in
                                                        a01letter_dig_under[a_sqlmode] +
                                                        [ '.' ])                            DO
                                                      sc_newpos := succ(sc_newpos);
                                                     (*ENDWHILE*) 
                                                     IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                                                     THEN
                                                      IF  (a_cmd_part^.sp1p_buf[ sc_newpos ] = '(') OR
                                                       (a_cmd_part^.sp1p_buf[ sc_newpos ] = l_bracket)
                                                      THEN
                                                       BEGIN
                                                       sc_newpos := succ(sc_newpos);
                                                       WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                                          AND
                                                          (a_cmd_part^.sp1p_buf [ sc_newpos ] in
                                                          a01letter_dig_under[a_sqlmode] +
                                                          [ '.' ])                            DO
                                                        sc_newpos := succ(sc_newpos);
                                                       (*ENDWHILE*) 
                                                       IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                                        AND
                                                        ((a_cmd_part^.sp1p_buf[ sc_newpos ] = ')') OR
                                                        (a_cmd_part^.sp1p_buf[ sc_newpos ] = r_bracket))
                                                       THEN
                                                        sc_newpos :=
                                                           succ(sc_newpos)
                                                       ELSE
                                                        a07_error (acv, e_missing_keyword, hint, hint);
                                                       (*ENDIF*) 
                                                       END
                                                      (*ENDIF*) 
                                                     (*ENDIF*) 
                                                     END
                                                    (*ENDIF*) 
                                                    END
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END;
                                        (* question-mark = parameter *)
                                        '?' :
                                            BEGIN
                                            sc_symb := s_parameter_name;
                                            sc_newpos := succ(sc_newpos);
                                            END;
                                        (*equal*)
                                        '=' :
                                            BEGIN
                                            sc_symb := s_equal;
                                            sc_newpos := succ(sc_newpos);
                                            END;
                                        (*plus*)
                                        '+' :
                                            BEGIN
                                            sc_symb := s_plus;
                                            sc_newpos := succ(sc_newpos);
                                            END;
                                        (*minus*)
                                        '-' :
                                            BEGIN
                                            sc_symb := s_minus;
                                            sc_newpos := succ(sc_newpos);
                                            IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                                            THEN
                                                IF  a_cmd_part^.sp1p_buf [ sc_newpos ] = '>'
                                                THEN
                                                    BEGIN
                                                    sc_symb   := s_method_call;
                                                    sc_newpos := succ(sc_newpos)
                                                    END
                                                (* PTS 1113708 E.Z. *)
                                                ELSE
                                                    IF  a_cmd_part^.sp1p_buf [ sc_newpos ] = '-'
                                                    THEN
                                                     BEGIN
                                                     (* may be comment or odbc-syntax *)
                                                     odbc_partype := no_odbc;
                                                     scvh := a_scv;
                                                     IF  (a_comp_type = at_odbc) OR (a_comp_type = at_jdbc)
                                                     THEN
                                                      a01_is_odbc_syntax (acv, odbc_partype, odbc_functype);
                                                     (*ENDIF*) 
                                                     IF  odbc_partype = no_odbc
                                                     THEN
                                                      BEGIN
                                                      WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                                         AND
                                                         ((a_cmd_part^.sp1p_buf [ sc_newpos ] <> a01lf ) AND
                                                         ( a_cmd_part^.sp1p_buf [ sc_newpos ] <> a01cr )) DO
                                                       sc_newpos := succ(sc_newpos);
                                                      (*ENDWHILE*) 
                                                      IF  sc_newpos <= a_cmd_part^.sp1p_buf_len
                                                      THEN
                                                       BEGIN
                                                       sc_newpos := succ(sc_newpos);
                                                       a01_next_symbol(acv);
                                                       recursive_call := true; (* PTS 1118015 U.J. *)
                                                       END
                                                      ELSE
                                                       BEGIN
                                                       sc_sypos := a_cmd_part^.sp1p_buf_len;
                                                       sc_symb  := s_eof
                                                       END;
                                                      (*ENDIF*) 
                                                      END
                                                     ELSE
                                                      a_scv := scvh;
                                                     (*ENDIF*) 
                                                     END;
                                                    (* END PTS 1113708 E.Z. *)
                                                    (*ENDIF*) 
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END;
                                        (*divide*)
                                        '/' :
                                            BEGIN
                                            sc_symb := s_divide;
                                            sc_newpos := succ(sc_newpos);
                                            IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                            THEN
                                                IF  ( a_cmd_part^.sp1p_buf [ sc_newpos ] = '*' )
                                                THEN
                                                    IF  ( a_cmd_part^.sp1p_buf [ succ(sc_newpos) ] = '+' )
                                                     AND
                                                     ( scs_hint_allowed in a_scv.sc_states )
                                                    THEN
                                                     BEGIN
&                                                    ifdef TRACE
                                                     t01int4(ak_syn, 'start hint  ', pred(sc_newpos));
&                                                    endif
                                                     sc_symb   := s_hint;
                                                     sc_newpos := sc_newpos + 2;
                                                     END
                                                    ELSE
                                                     BEGIN
&                                                    ifdef TRACE
                                                     t01int4(ak_syn, 'start commnt', pred(sc_newpos));
&                                                    endif
                                                     WHILE (sc_newpos < a_cmd_part^.sp1p_buf_len)
                                                        AND
                                                        NOT (( a_cmd_part^.sp1p_buf[ sc_newpos ] = '*' ) AND
                                                        ( a_cmd_part^.sp1p_buf[ succ(sc_newpos) ] = '/' )) DO
                                                      sc_newpos := succ(sc_newpos);
                                                     (*ENDWHILE*) 
                                                     IF  (sc_newpos < a_cmd_part^.sp1p_buf_len)
                                                     THEN
                                                      BEGIN
                                                      sc_newpos := succ(sc_newpos);
&                                                     ifdef TRACE
                                                      t01int4(ak_syn, 'stop comment', sc_newpos);
&                                                     endif
                                                      sc_newpos := succ(sc_newpos);
                                                      a01_next_symbol(acv);
                                                      recursive_call := true; (* PTS 1118015 U.J. *)
                                                      END
                                                     ELSE
                                                      (* PTS 1119779 E.Z. *)
                                                      sc_newpos := succ(sc_sypos);
                                                     (*ENDIF*) 
                                                     END;
                                                    (*ENDIF*) 
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END;
                                        (* comma *)
                                        ',' :
                                            BEGIN
                                            sc_symb := s_comma;
                                            sc_newpos := succ(sc_newpos);
                                            END;
                                        (* opening bracket *)
                                        '(' :
                                            BEGIN
                                            (* outer join predicate '(+)' *)
                                            i := succ (sc_newpos);
&                                           IFDEF TRACE
                                            t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, sc_sypos, sc_sypos + 5);
                                            t01p2int4 (ak_sem, 'sc_sypos    ', sc_sypos,
                                                  'sc_newpos   ', sc_newpos);
&                                           ENDIF
                                            WHILE (i < a_cmd_part^.sp1p_buf_len)
                                                  AND
                                                  ((a_cmd_part^.sp1p_buf [ i ] = bsp_c1) OR
                                                  ( a_cmd_part^.sp1p_buf [ i ] = a01ht ) OR
                                                  ( a_cmd_part^.sp1p_buf [ i ] = a01lf ) OR
                                                  ( a_cmd_part^.sp1p_buf [ i ] = a01cr )) DO
                                                i := succ (i);
                                            (*ENDWHILE*) 
                                            IF  (a_cmd_part^.sp1p_buf [ i ] <> '+')
                                            THEN
                                                BEGIN
                                                sc_symb   := s_leftpar;
                                                sc_newpos := succ(sc_newpos);
                                                END
                                            ELSE
                                                BEGIN
                                                (* skip over '+' *)
                                                i := succ (i);
                                                WHILE (i < a_cmd_part^.sp1p_buf_len)
                                                      AND
                                                      ((a_cmd_part^.sp1p_buf [ i ] = bsp_c1) OR
                                                      ( a_cmd_part^.sp1p_buf [ i ] = a01ht ) OR
                                                      ( a_cmd_part^.sp1p_buf [ i ] = a01lf ) OR
                                                      ( a_cmd_part^.sp1p_buf [ i ] = a01cr )) DO
                                                    i := succ (i);
                                                (*ENDWHILE*) 
                                                IF  (a_cmd_part^.sp1p_buf [ i ] <> ')')
                                                THEN
                                                    BEGIN
                                                    sc_symb   := s_leftpar;
                                                    sc_newpos := succ(sc_newpos);
                                                    END
                                                ELSE
                                                    BEGIN
                                                    sc_symb   := s_outer_join;
                                                    sc_newpos := succ (i);
&                                                   IFDEF TRACE
                                                    t01int4 (ak_sem, 's_outer_join', ord(s_outer_join));
&                                                   ENDIF
                                                    END;
                                                (*ENDIF*) 
                                                END;
                                            (*ENDIF*) 
&                                           IFDEF TRACE
                                            t01moveobj (ak_sem, a_cmd_part^.sp1p_buf, sc_sypos, sc_sypos + 5);
                                            t01p2int4 (ak_sem, 'sc_sypos    ', sc_sypos,
                                                  'sc_newpos   ', sc_newpos);
                                            t01int4 (ak_sem, 'i           ', i);
&                                           ENDIF
                                            END;
                                        (* closing bracket *)
                                        ')' :
                                            BEGIN
                                            sc_symb := s_rightpar;
                                            sc_newpos := succ(sc_newpos);
                                            END;
                                        (* semicolon *)
                                        ';' :
                                            IF  acv.a_scv.sc_eof_symb = s_semicolon
                                            THEN
                                                sc_symb := s_eof
                                            ELSE
                                                BEGIN
                                                sc_symb := s_semicolon;
                                                sc_newpos := succ(sc_newpos);
                                                END;
                                            (*ENDIF*) 
                                        '*' :
                                            BEGIN
                                            sc_symb := s_asterisk;
                                            sc_newpos := succ(sc_newpos);
                                            END;
                                        '&' :
                                            IF  acv.a_sqlmode = sqlm_internal
                                            THEN
                                                BEGIN
                                                sc_symb   := s_concat;
                                                sc_newpos := succ(sc_newpos);
                                                END
                                            ELSE
                                                BEGIN
                                                sc_symb := s_unknown;
                                                sc_newpos := succ(sc_newpos);
                                                END;
                                            (*ENDIF*) 
                                        '|' :
                                            BEGIN
                                            sc_symb   := s_unknown;
                                            sc_newpos := succ(sc_newpos);
                                            IF  (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                            THEN
                                                IF  (a_cmd_part^.sp1p_buf[ sc_newpos ]='|')
                                                    AND
                                                    (acv.a_sqlmode <> sqlm_ansi)
                                                THEN
                                                    BEGIN
                                                    sc_symb   := s_concat;
                                                    sc_newpos := succ(sc_newpos);
                                                    END
                                                ELSE
                                                    BEGIN
                                                    sc_symb := s_unknown;
                                                    sc_newpos := succ(sc_newpos);
                                                    END;
                                                (*ENDIF*) 
                                            (*ENDIF*) 
                                            END;
                                        '%' :
                                            BEGIN
                                            sc_newpos := succ(sc_newpos);
                                            WHILE (sc_newpos <= a_cmd_part^.sp1p_buf_len)
                                                  AND
                                                  (a_cmd_part^.sp1p_buf[ sc_newpos ] in a01digits) DO
                                                sc_newpos := succ(sc_newpos);
                                            (*ENDWHILE*) 
                                            IF  a_ex_kind <> only_syntax
                                            THEN
                                                sc_symb := s_unknown
                                            ELSE
                                                BEGIN
                                                sc_symb := s_identifier;
                                                sc_double_quote := 0;
                                                END
                                            (*ENDIF*) 
                                            END;
                                        (* undefsymbols *)
                                        OTHERWISE
                                            BEGIN
                                            sc_symb := s_unknown;
                                            sc_newpos := succ(sc_newpos);
                                            END
                                        END;
                                    (*ENDCASE*) 
                                (*ENDIF*) 
                            (*ENDIF*) 
                        (*ENDIF*) 
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDIF*) 
            (* PTS 1118015 U.J. *)
            IF  NOT recursive_call
            THEN
                sc_sylength := sc_newpos - sc_sypos - dif;
            (*ENDIF*) 
            END (*sc_newpos <= a_cmd_part^.sp1p_buf_len*)
        ELSE
            BEGIN
            sc_sypos := sc_sypos + hint;
            sc_symb  := s_eof
            END;
        (*ENDIF*) 
&       ifdef TRACE
        t01p2int4 (ak_syn,'sc_sypos    ', sc_sypos,
              'sc_sylength ', sc_sylength);
        t01moveobj (ak_syn, a_cmd_part^.sp1p_buf, sc_sypos, sc_sypos + sc_sylength - 1);
&       endif
        END;
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_compact_cmd (VAR acv : tak_all_command_glob);
 
VAR
      do_prepare      : boolean;
      pos             : tsp00_Int4;
      org_cmd_part    : tsp1_part_ptr;
      org_len         : tsp00_Int4;
      requiredLength  : tsp00_Int4;
 
BEGIN
(* Ideally this procedure would compact the cmd immediately. *)
(* Instead we copy the original and compact it later.        *)
WITH acv DO
    IF  a_ex_kind <> only_syntax
    THEN
        BEGIN
        org_cmd_part    := a_cmd_part;
        do_prepare      := a_cmd_segment_header.sp1c_prepare;
        pos             := 1;
        (* PTS 1105437 GG *)
        WHILE a01is_whitespace_char (org_cmd_part^.sp1p_buf, pos) DO
            pos := pos + a01char_size;
        (*ENDWHILE*) 
        org_len := a_cmd_part^.sp1p_buf_len - pos + 1;
        IF  (a_cmd_segment_header.sp1c_producer <> sp1pr_kernel)
            AND
            (a_cmd_segment_header.sp1c_producer <> sp1pr_view_optimizer)
            AND
            (a_cmd_segment_header.sp1c_producer <> sp1pr_complex_view_handling)
        THEN
            BEGIN
            IF  a101_SchemaMappingActive(acv)
            THEN
                requiredLength := g01packet_size
            ELSE
                requiredLength := org_len;
            (*ENDIF*) 
            a542internal_packet (acv,
                  NOT c_release_internal_packet, requiredLength);
            END;
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  (org_cmd_part <> a_cmd_part) OR (pos > 1)
            THEN
                SAPDB_PascalOverlappingMove ('VAK01 ',   2,    
                      org_cmd_part^.sp1p_buf_size,
                      a_cmd_part^.sp1p_buf_size,
                      @org_cmd_part^.sp1p_buf, pos,
                      @a_cmd_part^.sp1p_buf, 1, org_len,
                      a_returncode);
            (*ENDIF*) 
            a_cmd_segment_header.sp1c_prepare := do_prepare;
            a_cmd_segm^.sp1c_prepare          := do_prepare;
            a_cmd_part^.sp1p_buf_len          := org_len;
            a_compact_varpart                 := true;
            a_errpos_offset                   := pos - 1
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_is_end_symbol (VAR acv : tak_all_command_glob);
 
VAR
      hint : tsp00_Int2;
 
BEGIN
WITH acv DO
    IF  ((a_returncode = 0) AND
        NOT (a_scv.sc_symb = s_eof))
    THEN
        a07_error (acv, e_invalid_end_of_command,
              hint, hint);
    (*ENDIF*) 
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak01init_keyword_tab;
 
VAR
      kw_first_char : char;
      kw_index      : integer;
 
BEGIN
FOR kw_index := 1 TO cak_maxkeyword DO
    a01kw [ kw_index ] := '@                 ';
(*ENDFOR*) 
(* sort for binary search *)
a01kw [ cak_i_abs          ] := 'ABS               ';
a01kw [ cak_i_absolute     ] := 'ABSOLUTE          ';
(* PTS 1115978 E.Z. *)
a01kw [ cak_i_acos         ] := 'ACOS              ';
a01kw [ cak_i_add          ] := 'ADD               ';
a01kw [ cak_i_add_months   ] := 'ADD_MONTHS        ';
a01kw [ cak_i_adddate      ] := 'ADDDATE           ';
(* PTS 1119691 E.Z. *)
a01kw [ cak_i_address      ] := 'ADDRESS           ';
a01kw [ cak_i_addtime      ] := 'ADDTIME           ';
a01kw [ cak_i_after        ] := 'AFTER             ';
a01kw [ cak_i_all          ] := 'ALL               ';
a01kw [ cak_i_alpha        ] := 'ALPHA             ';
a01kw [ cak_i_alter        ] := 'ALTER             ';
a01kw [ cak_i_alterin      ] := 'ALTERIN           ';
a01kw [ cak_i_analyze      ] := 'ANALYZE           ';
a01kw [ cak_i_and          ] := 'AND               ';
a01kw [ cak_i_ansi         ] := 'ANSI              ';
a01kw [ cak_i_any          ] := 'ANY               ';
a01kw [ cak_i_append       ] := 'APPEND            ';
a01kw [ cak_i_archive      ] := 'ARCHIVE           '; (* PTS 1117381 E.Z. *)
a01kw [ cak_i_as           ] := 'AS                ';
a01kw [ cak_i_asc          ] := 'ASC               ';
a01kw [ cak_i_ascii        ] := 'ASCII             ';
a01kw [ cak_i_asin         ] := 'ASIN              ';
a01kw [ cak_i_at           ] := 'AT                ';
a01kw [ cak_i_atan         ] := 'ATAN              ';
a01kw [ cak_i_atan2        ] := 'ATAN2             ';
a01kw [ cak_i_authentication] := 'AUTHENTICATION    ';
a01kw [ cak_i_authorization] := 'AUTHORIZATION     '; (* PTS 1127736 *)
(* PTS 1120104 E.Z. *)
a01kw [ cak_i_auto         ] := 'AUTO              ';
(* PTS 1111576 E.Z. *)
a01kw [ cak_i_autosave     ] := 'AUTOSAVE          ';
a01kw [ cak_i_avg          ] := 'AVG               ';
(* PTS 1117472 E.Z. *)
a01kw [ cak_i_bad          ] := 'BAD               ';
a01kw [ cak_i_before       ] := 'BEFORE            ';
a01kw [ cak_i_begin        ] := 'BEGIN             ';
a01kw [ cak_i_beginload    ] := 'BEGINLOAD         ';
a01kw [ cak_i_beginproc    ] := 'BEGINPROC         ';
a01kw [ cak_i_between      ] := 'BETWEEN           ';
a01kw [ cak_i_binary       ] := 'BINARY            ';
a01kw [ cak_i_bit          ] := 'BIT               ';
(* PTS 1119691 E.Z. *)
a01kw [ cak_i_block        ] := 'BLOCK             ';
a01kw [ cak_i_blocksize    ] := 'BLOCKSIZE         ';
a01kw [ cak_i_boolean      ] := 'BOOLEAN           ';
a01kw [ cak_i_both         ] := 'BOTH              ';
a01kw [ cak_i_break        ] := 'BREAK             ';
a01kw [ cak_i_buffer       ] := 'BUFFER            ';
a01kw [ cak_i_bufferpool   ] := 'BUFFERPOOL        ';
a01kw [ cak_i_bwhierarchy  ] := 'BWHIERARCHY       ';
a01kw [ cak_i_by           ] := 'BY                ';
a01kw [ cak_i_byte         ] := 'BYTE              ';
a01kw [ cak_i_cache        ] := 'CACHE             ';
a01kw [ cak_i_cachelimit   ] := 'CACHELIMIT        ';
a01kw [ cak_i_caches       ] := 'CACHES            ';
a01kw [ cak_i_call         ] := 'CALL              ';
a01kw [ cak_i_cancel       ] := 'CANCEL            ';
a01kw [ cak_i_cascade      ] := 'CASCADE           ';
a01kw [ cak_i_case         ] := 'CASE              ';
a01kw [ cak_i_catalog      ] := 'CATALOG           ';
a01kw [ cak_i_catch        ] := 'CATCH             ';
a01kw [ cak_i_ceil         ] := 'CEIL              ';
a01kw [ cak_i_ceiling      ] := 'CEILING           ';
a01kw [ cak_i_char         ] := 'CHAR              ';
a01kw [ cak_i_character    ] := 'CHARACTER         ';
a01kw [ cak_i_check        ] := 'CHECK             ';
a01kw [ cak_i_checkpoint   ] := 'CHECKPOINT        ';
a01kw [ cak_i_chr          ] := 'CHR               ';
a01kw [ cak_i_clear        ] := 'CLEAR             ';
a01kw [ cak_i_close        ] := 'CLOSE             ';
a01kw [ cak_i_cluster      ] := 'CLUSTER           ';
a01kw [ cak_i_column       ] := 'COLUMN            ';
a01kw [ cak_i_comment      ] := 'COMMENT           ';
a01kw [ cak_i_commit       ] := 'COMMIT            ';
a01kw [ cak_i_compute      ] := 'COMPUTE           ';
a01kw [ cak_i_concat       ] := 'CONCAT            ';
a01kw [ cak_i_config       ] := 'CONFIG            ';
a01kw [ cak_i_connect      ] := 'CONNECT           ';
a01kw [ cak_i_constraint   ] := 'CONSTRAINT        ';
a01kw [ cak_i_constraints  ] := 'CONSTRAINTS       ';
a01kw [ cak_i_container    ] := 'CONTAINER         ';
a01kw [ cak_i_continue     ] := 'CONTINUE          ';
a01kw [ cak_i_cos          ] := 'COS               ';
a01kw [ cak_i_cosh         ] := 'COSH              ';
a01kw [ cak_i_costlimit    ] := 'COSTLIMIT         ';
a01kw [ cak_i_costwarning  ] := 'COSTWARNING       ';
a01kw [ cak_i_cot          ] := 'COT               ';
a01kw [ cak_i_count        ] := 'COUNT             ';
a01kw [ cak_i_create       ] := 'CREATE            ';
a01kw [ cak_i_createin     ] := 'CREATEIN          ';
a01kw [ cak_i_cross        ] := 'CROSS             ';
a01kw [ cak_i_curdate      ] := 'CURDATE           ';
a01kw [ cak_i_current      ] := 'CURRENT           ';
a01kw [ cak_i_current_schema]:= 'CURRENT_SCHEMA    ';
a01kw [ cak_i_current_date ] := 'CURRENT_DATE      ';
a01kw [ cak_i_current_time ] := 'CURRENT_TIME      ';
a01kw [ cak_i_current_timestamp ] := 'CURRENT_TIMESTAMP ';
a01kw [ cak_i_currval      ] := 'CURRVAL           ';
a01kw [ cak_i_cursor       ] := 'CURSOR            ';
a01kw [ cak_i_curtime      ] := 'CURTIME           ';
a01kw [ cak_i_cycle        ] := 'CYCLE             ';
a01kw [ cak_i_dafs         ] := 'DAFS              ';
a01kw [ cak_i_data         ] := 'DATA              ';
a01kw [ cak_i_database     ] := 'DATABASE          ';
a01kw [ cak_i_date         ] := 'DATE              ';
a01kw [ cak_i_datediff     ] := 'DATEDIFF          ';
a01kw [ cak_i_day          ] := 'DAY               ';
a01kw [ cak_i_dayname      ] := 'DAYNAME           ';
a01kw [ cak_i_dayofmonth   ] := 'DAYOFMONTH        ';
a01kw [ cak_i_dayofweek    ] := 'DAYOFWEEK         ';
a01kw [ cak_i_dayofyear    ] := 'DAYOFYEAR         ';
a01kw [ cak_i_days         ] := 'DAYS              ';
a01kw [ cak_i_db2          ] := 'DB2               ';
a01kw [ cak_i_dba          ] := 'DBA               ';
a01kw [ cak_i_dbproc       ] := 'DBPROC            ';
a01kw [ cak_i_dbprocedure  ] := 'DBPROCEDURE       ';
a01kw [ cak_i_debug        ] := 'DEBUG             ';
a01kw [ cak_i_dec          ] := 'DEC               ';
a01kw [ cak_i_decimal      ] := 'DECIMAL           ';
a01kw [ cak_i_declare      ] := 'DECLARE           ';
a01kw [ cak_i_decode       ] := 'DECODE            ';
a01kw [ cak_i_default      ] := 'DEFAULT           ';
(* PTS 1117216 E.Z. *)
a01kw [ cak_i_defaultcode  ] := 'DEFAULTCODE       ';
a01kw [ cak_i_degree       ] := 'DEGREE            ';
a01kw [ cak_i_degrees      ] := 'DEGREES           ';
a01kw [ cak_i_delete       ] := 'DELETE            ';
a01kw [ cak_i_desc         ] := 'DESC              ';
a01kw [ cak_i_describe     ] := 'DESCRIBE          ';
a01kw [ cak_i_deterministic] := 'DETERMINISTIC     ';
a01kw [ cak_i_device       ] := 'DEVICE            ';
a01kw [ cak_i_diagnose     ] := 'DIAGNOSE          ';
a01kw [ cak_i_digits       ] := 'DIGITS            ';
a01kw [ cak_i_dimension    ] := 'DIMENSION         ';
a01kw [ cak_i_disable      ] := 'DISABLE           ';
a01kw [ cak_i_distinct     ] := 'DISTINCT          ';
a01kw [ cak_i_div          ] := 'DIV               ';
a01kw [ cak_i_do           ] := 'DO                ';
a01kw [ cak_i_domain       ] := 'DOMAIN            ';
a01kw [ cak_i_double       ] := 'DOUBLE            ';
a01kw [ cak_i_drop         ] := 'DROP              ';
a01kw [ cak_i_dropin       ] := 'DROPIN            ';
a01kw [ cak_i_dsetpass     ] := 'DSETPASS          ';
a01kw [ cak_i_duplicates   ] := 'DUPLICATES        ';
a01kw [ cak_i_dynamic      ] := 'DYNAMIC           ';
(* PTS 1122828 E.Z. *)
a01kw [ cak_i_editproc     ] := 'EDITPROC          ';
a01kw [ cak_i_else         ] := 'ELSE              ';
a01kw [ cak_i_enable       ] := 'ENABLE            ';
a01kw [ cak_i_end          ] := 'END               ';
a01kw [ cak_i_endload      ] := 'ENDLOAD           ';
a01kw [ cak_i_endproc      ] := 'ENDPROC           ';
a01kw [ cak_i_error        ] := 'ERROR             ';
a01kw [ cak_i_escape       ] := 'ESCAPE            ';
a01kw [ cak_i_estimate     ] := 'ESTIMATE          ';
a01kw [ cak_i_eur          ] := 'EUR               ';
a01kw [ cak_i_except       ] := 'EXCEPT            ';
a01kw [ cak_i_exclusive    ] := 'EXCLUSIVE         ';
a01kw [ cak_i_execute      ] := 'EXECUTE           ';
a01kw [ cak_i_exists       ] := 'EXISTS            ';
a01kw [ cak_i_exp          ] := 'EXP               ';
a01kw [ cak_i_expand       ] := 'EXPAND            ';
a01kw [ cak_i_explain      ] := 'EXPLAIN           ';
a01kw [ cak_i_explicit     ] := 'EXPLICIT          ';
a01kw [ cak_i_extended     ] := 'EXTENDED          ';
a01kw [ cak_i_fact         ] := 'FACT              ';
a01kw [ cak_i_false        ] := 'FALSE             ';
a01kw [ cak_i_fetch        ] := 'FETCH             ';
a01kw [ cak_i_file         ] := 'FILE              ';
a01kw [ cak_i_first        ] := 'FIRST             ';
a01kw [ cak_i_fixed        ] := 'FIXED             ';
a01kw [ cak_i_float        ] := 'FLOAT             ';
a01kw [ cak_i_floor        ] := 'FLOOR             ';
a01kw [ cak_i_flush        ] := 'FLUSH             ';
a01kw [ cak_i_for          ] := 'FOR               ';
a01kw [ cak_i_force        ] := 'FORCE             ';
a01kw [ cak_i_foreign      ] := 'FOREIGN           ';
a01kw [ cak_i_format       ] := 'FORMAT            ';
a01kw [ cak_i_freepage     ] := 'FREEPAGE          ';
a01kw [ cak_i_from         ] := 'FROM              ';
a01kw [ cak_i_full         ] := 'FULL              ';
a01kw [ cak_i_function     ] := 'FUNCTION          ';
a01kw [ cak_i_fversion     ] := 'FVERSION          ';
a01kw [ cak_i_get          ] := 'GET               ';
(* PTS 1111577 E.Z. *)
a01kw [ cak_i_get_objectname] := 'GET_OBJECTNAME    ';
a01kw [ cak_i_get_schema   ] := 'GET_SCHEMA        ';
a01kw [ cak_i_grant        ] := 'GRANT             ';
a01kw [ cak_i_graphic      ] := 'GRAPHIC           ';
a01kw [ cak_i_greatest     ] := 'GREATEST          ';
a01kw [ cak_i_group        ] := 'GROUP             ';
a01kw [ cak_i_having       ] := 'HAVING            ';
a01kw [ cak_i_hex          ] := 'HEX               ';
a01kw [ cak_i_hextoraw     ] := 'HEXTORAW          ';
a01kw [ cak_i_high         ] := 'HIGH              ';
a01kw [ cak_i_history      ] := 'HISTORY           ';
a01kw [ cak_i_hold         ] := 'HOLD              ';
a01kw [ cak_i_hour         ] := 'HOUR              ';
a01kw [ cak_i_hours        ] := 'HOURS             ';
a01kw [ cak_i_identified   ] := 'IDENTIFIED        ';
a01kw [ cak_i_if           ] := 'IF                ';
a01kw [ cak_i_ifnull       ] := 'IFNULL            ';
a01kw [ cak_i_ignore       ] := 'IGNORE            ';
a01kw [ cak_i_implicit     ] := 'IMPLICIT          ';
a01kw [ cak_i_in           ] := 'IN                ';
a01kw [ cak_i_increment    ] := 'INCREMENT         ';
a01kw [ cak_i_index        ] := 'INDEX             ';
a01kw [ cak_i_indexname    ] := 'INDEXNAME         ';
a01kw [ cak_i_indicator    ] := 'INDICATOR         ';
(* PTS 1111229 E.Z. *)
a01kw [ cak_i_info         ] := 'INFO              ';
a01kw [ cak_i_init         ] := 'INIT              ';
a01kw [ cak_i_initcap      ] := 'INITCAP           ';
a01kw [ cak_i_initrans     ] := 'INITRANS          ';
a01kw [ cak_i_inner        ] := 'INNER             ';
a01kw [ cak_i_inout        ] := 'INOUT             ';
a01kw [ cak_i_inproc       ] := 'INPROC            ';
a01kw [ cak_i_insert       ] := 'INSERT            ';
a01kw [ cak_i_instance     ] := 'INSTANCE          ';
a01kw [ cak_i_instr        ] := 'INSTR             ';
a01kw [ cak_i_int          ] := 'INT               ';
a01kw [ cak_i_integer      ] := 'INTEGER           ';
a01kw [ cak_i_internal     ] := 'INTERNAL          ';
a01kw [ cak_i_intersect    ] := 'INTERSECT         ';
a01kw [ cak_i_into         ] := 'INTO              ';
a01kw [ cak_i_is           ] := 'IS                ';
a01kw [ cak_i_iso          ] := 'ISO               ';
a01kw [ cak_i_isolation    ] := 'ISOLATION         ';
a01kw [ cak_i_isupdatedcolumn] := 'ISUPDATEDCOLUMN   ';  (* PTS 1127075 *)
a01kw [ cak_i_java         ] := 'JAVA              ';
a01kw [ cak_i_jis          ] := 'JIS               ';
a01kw [ cak_i_join         ] := 'JOIN              ';
a01kw [ cak_i_key          ] := 'KEY               ';
a01kw [ cak_i_label        ] := 'LABEL             ';
a01kw [ cak_i_language     ] := 'LANGUAGE          ';
a01kw [ cak_i_last         ] := 'LAST              ';
a01kw [ cak_i_last_day     ] := 'LAST_DAY          ';
a01kw [ cak_i_lcase        ] := 'LCASE             ';
a01kw [ cak_i_least        ] := 'LEAST             ';
a01kw [ cak_i_left         ] := 'LEFT              ';
a01kw [ cak_i_length       ] := 'LENGTH            ';
a01kw [ cak_i_level        ] := 'LEVEL             ';
a01kw [ cak_i_lfill        ] := 'LFILL             ';
a01kw [ cak_i_like         ] := 'LIKE              ';
a01kw [ cak_i_limit        ] := 'LIMIT             ';
a01kw [ cak_i_list         ] := 'LIST              ';
a01kw [ cak_i_ln           ] := 'LN                ';
a01kw [ cak_i_load         ] := 'LOAD              ';
a01kw [ cak_i_local        ] := 'LOCAL             ';
(* PTS 1111797 E.Z. *)
a01kw [ cak_i_locate       ] := 'LOCATE            ';
a01kw [ cak_i_lock         ] := 'LOCK              ';
a01kw [ cak_i_log          ] := 'LOG               ';
a01kw [ cak_i_logwriter    ] := 'LOGWRITER         ';
a01kw [ cak_i_logfull      ] := 'LOGFULL           ';
a01kw [ cak_i_log10        ] := 'LOG10             ';
a01kw [ cak_i_long         ] := 'LONG              ';
a01kw [ cak_i_longfile     ] := 'LONGFILE          ';
a01kw [ cak_i_low          ] := 'LOW               ';
a01kw [ cak_i_lower        ] := 'LOWER             ';
a01kw [ cak_i_lpad         ] := 'LPAD              ';
a01kw [ cak_i_ltrim        ] := 'LTRIM             ';
a01kw [ cak_i_makedate     ] := 'MAKEDATE          ';
a01kw [ cak_i_maketime     ] := 'MAKETIME          ';
a01kw [ cak_i_mapchar      ] := 'MAPCHAR           ';
a01kw [ cak_i_max          ] := 'MAX               ';
a01kw [ cak_i_maxtrans     ] := 'MAXTRANS          ';
a01kw [ cak_i_maxvalue     ] := 'MAXVALUE          ';
a01kw [ cak_i_mbcs         ] := 'MBCS              ';
a01kw [ cak_i_medianame    ] := 'MEDIANAME         ';
a01kw [ cak_i_medium       ] := 'MEDIUM            ';
a01kw [ cak_i_microsec     ] := 'MICROSECOND       ';
a01kw [ cak_i_microsecs    ] := 'MICROSECONDS      ';
(* PTS 1117050 E.Z. *)
a01kw [ cak_i_migrate      ] := 'MIGRATE           ';
a01kw [ cak_i_min          ] := 'MIN               ';
a01kw [ cak_i_minus        ] := 'MINUS             ';
a01kw [ cak_i_minute       ] := 'MINUTE            ';
a01kw [ cak_i_minutes      ] := 'MINUTES           ';
a01kw [ cak_i_minvalue     ] := 'MINVALUE          ';
a01kw [ cak_i_mod          ] := 'MOD               ';
a01kw [ cak_i_mode         ] := 'MODE              ';
a01kw [ cak_i_modify       ] := 'MODIFY            ';
a01kw [ cak_i_monitor      ] := 'MONITOR           ';
a01kw [ cak_i_month        ] := 'MONTH             ';
a01kw [ cak_i_monthname    ] := 'MONTHNAME         ';
a01kw [ cak_i_months       ] := 'MONTHS            ';
a01kw [ cak_i_months_between ] := 'MONTHS_BETWEEN    ';
a01kw [ cak_i_name         ] := 'NAME              ';
a01kw [ cak_i_natural      ] := 'NATURAL           ';
a01kw [ cak_i_nchar        ] := 'NCHAR             ';
(* PTS 1111229 E.Z. *)
a01kw [ cak_i_new          ] := 'NEW               ';
a01kw [ cak_i_new_time     ] := 'NEW_TIME          ';
a01kw [ cak_i_next         ] := 'NEXT              ';
a01kw [ cak_i_next_day     ] := 'NEXT_DAY          ';
a01kw [ cak_i_nextval      ] := 'NEXTVAL           ';
a01kw [ cak_i_nlssort      ] := 'NLSSORT           ';
a01kw [ cak_i_nls_date_format   ] := 'NLS_DATE_FORMAT   ';
a01kw [ cak_i_nls_date_language ] := 'NLS_DATE_LANGUAGE ';
a01kw [ cak_i_nls_language      ] := 'NLS_LANGUAGE      ';
a01kw [ cak_i_nls_numeric_chars ] := 'NLS_NUMERIC_CHARAC';
a01kw [ cak_i_nls_currency      ] := 'NLS_CURRENCY      ';
a01kw [ cak_i_nls_sort          ] := 'NLS_SORT          ';
a01kw [ cak_i_no           ] := 'NO                ';
a01kw [ cak_i_nocache      ] := 'NOCACHE           ';
a01kw [ cak_i_nocycle      ] := 'NOCYCLE           ';
a01kw [ cak_i_nolog        ] := 'NOLOG             ';
a01kw [ cak_i_nomaxvalue   ] := 'NOMAXVALUE        ';
a01kw [ cak_i_nominvalue   ] := 'NOMINVALUE        ';
a01kw [ cak_i_none         ] := 'NONE              ';
a01kw [ cak_i_noorder      ] := 'NOORDER           ';
a01kw [ cak_i_norewind     ] := 'NOREWIND          ';
a01kw [ cak_i_normal       ] := 'NORMAL            ';
a01kw [ cak_i_noround      ] := 'NOROUND           ';
a01kw [ cak_i_nosort       ] := 'NOSORT            ';
a01kw [ cak_i_not          ] := 'NOT               ';
a01kw [ cak_i_now          ] := 'NOW               ';
a01kw [ cak_i_nowait       ] := 'NOWAIT            ';
a01kw [ cak_i_null         ] := 'NULL              ';
a01kw [ cak_i_num          ] := 'NUM               ';
a01kw [ cak_i_number       ] := 'NUMBER            ';
a01kw [ cak_i_numeric      ] := 'NUMERIC           ';
a01kw [ cak_i_nvl          ] := 'NVL               ';
a01kw [ cak_i_obid         ] := 'OBID              ';
a01kw [ cak_i_object       ] := 'OBJECT            ';
a01kw [ cak_i_of           ] := 'OF                ';
a01kw [ cak_i_off          ] := 'OFF               ';
a01kw [ cak_i_on           ] := 'ON                ';
a01kw [ cak_i_only         ] := 'ONLY              ';
a01kw [ cak_i_open         ] := 'OPEN              ';
a01kw [ cak_i_optimistic   ] := 'OPTIMISTIC        ';
a01kw [ cak_i_optimize     ] := 'OPTIMIZE          ';
a01kw [ cak_i_option       ] := 'OPTION            ';
a01kw [ cak_i_or           ] := 'OR                ';
a01kw [ cak_i_oracle       ] := 'ORACLE            ';
a01kw [ cak_i_order        ] := 'ORDER             ';
a01kw [ cak_i_out          ] := 'OUT               ';
a01kw [ cak_i_outer        ] := 'OUTER             ';
a01kw [ cak_i_overwrite    ] := 'OVERWRITE         ';
a01kw [ cak_i_package      ] := 'PACKAGE           ';
a01kw [ cak_i_packed       ] := 'PACKED            ';
(* PTS 1119691 E.Z. *)
a01kw [ cak_i_page         ] := 'PAGE              ';
a01kw [ cak_i_pages        ] := 'PAGES             ';
a01kw [ cak_i_param        ] := 'PARAM             ';
a01kw [ cak_i_parameter    ] := 'PARAMETER         ';
a01kw [ cak_i_parse        ] := 'PARSE             ';
a01kw [ cak_i_parseid      ] := 'PARSEID           ';
a01kw [ cak_i_password     ] := 'PASSWORD          ';
a01kw [ cak_i_pctfree      ] := 'PCTFREE           ';
a01kw [ cak_i_pctused      ] := 'PCTUSED           ';
a01kw [ cak_i_per          ] := 'PER               ';
a01kw [ cak_i_percent      ] := 'PERCENT           ';
a01kw [ cak_i_permanent    ] := 'PERMANENT         ';
a01kw [ cak_i_pipe         ] := 'PIPE              ';
a01kw [ cak_i_pi           ] := 'PI                ';
(* PTS 1106205 E.Z. *)
a01kw [ cak_i_ping         ] := 'PING              ';
a01kw [ cak_i_pos          ] := 'POS               ';
a01kw [ cak_i_power        ] := 'POWER             ';
a01kw [ cak_i_precision    ] := 'PRECISION         ';
(* PTS 1111229 E.Z. *)
a01kw [ cak_i_prepare      ] := 'PREPARE           ';
a01kw [ cak_i_prev         ] := 'PREV              ';
a01kw [ cak_i_primary      ] := 'PRIMARY           ';
a01kw [ cak_i_priv         ] := 'PRIV              ';
a01kw [ cak_i_privileges   ] := 'PRIVILEGES        ';
a01kw [ cak_i_proc         ] := 'PROC              ';
a01kw [ cak_i_procedure    ] := 'PROCEDURE         ';
a01kw [ cak_i_psm          ] := 'PSM               ';
a01kw [ cak_i_public       ] := 'PUBLIC            ';
a01kw [ cak_i_quick        ] := 'QUICK             ';
a01kw [ cak_i_radians      ] := 'RADIANS           ';
a01kw [ cak_i_range        ] := 'RANGE             ';
a01kw [ cak_i_raw          ] := 'RAW               ';
a01kw [ cak_i_rawtohex     ] := 'RAWTOHEX          ';
a01kw [ cak_i_read         ] := 'READ              ';
a01kw [ cak_i_real         ] := 'REAL              ';
a01kw [ cak_i_recursive    ] := 'RECURSIVE         ';
a01kw [ cak_i_references   ] := 'REFERENCES        ';
(* PTS 1111229 E.Z. *)
a01kw [ cak_i_register     ] := 'REGISTER          ';
(* PTS 1111576 E.Z. *)
a01kw [ cak_i_reject       ] := 'REJECT            ';
a01kw [ cak_i_relative     ] := 'RELATIVE          ';
a01kw [ cak_i_release      ] := 'RELEASE           ';
a01kw [ cak_i_remote       ] := 'REMOTE            ';
(* PTS 1111229 E.Z. *)
a01kw [ cak_i_remove       ] := 'REMOVE            ';
a01kw [ cak_i_rename       ] := 'RENAME            ';
a01kw [ cak_i_replace      ] := 'REPLACE           ';
a01kw [ cak_i_replication  ] := 'REPLICATION       ';
a01kw [ cak_i_reset        ] := 'RESET             ';
a01kw [ cak_i_resource     ] := 'RESOURCE          ';
a01kw [ cak_i_restart      ] := 'RESTART           ';
a01kw [ cak_i_restore      ] := 'RESTORE           ';
a01kw [ cak_i_resume       ] := 'RESUME            ';
a01kw [ cak_i_restrict     ] := 'RESTRICT          ';
a01kw [ cak_i_return       ] := 'RETURN            ';
a01kw [ cak_i_returns      ] := 'RETURNS           ';
a01kw [ cak_i_reuse        ] := 'REUSE             ';
a01kw [ cak_i_revoke       ] := 'REVOKE            ';
(* PTS 1111576 E.Z. *)
a01kw [ cak_i_rfill        ] := 'RFILL             ';
a01kw [ cak_i_right        ] := 'RIGHT             ';
a01kw [ cak_i_role         ] := 'ROLE              ';
a01kw [ cak_i_rollback     ] := 'ROLLBACK          ';
a01kw [ cak_i_round        ] := 'ROUND             ';
a01kw [ cak_i_row          ] := 'ROW               ';
a01kw [ cak_i_rowid        ] := 'ROWID             ';
a01kw [ cak_i_rowno        ] := 'ROWNO             ';
a01kw [ cak_i_rownum       ] := 'ROWNUM            ';
a01kw [ cak_i_rows         ] := 'ROWS              ';
a01kw [ cak_i_rpad         ] := 'RPAD              ';
a01kw [ cak_i_rtrim        ] := 'RTRIM             ';
a01kw [ cak_i_same         ] := 'SAME              ';
a01kw [ cak_i_sample       ] := 'SAMPLE            ';
a01kw [ cak_i_sapr3        ] := 'SAPR3             ';
a01kw [ cak_i_save         ] := 'SAVE              ';
a01kw [ cak_i_savepoint    ] := 'SAVEPOINT         ';
a01kw [ cak_i_schema       ] := 'SCHEMA            ';
a01kw [ cak_i_second       ] := 'SECOND            ';
a01kw [ cak_i_seconds      ] := 'SECONDS           ';
a01kw [ cak_i_select       ] := 'SELECT            ';
a01kw [ cak_i_selectivity  ] := 'SELECTIVITY       ';
a01kw [ cak_i_selupd       ] := 'SELUPD            ';
a01kw [ cak_i_sequence     ] := 'SEQUENCE          ';
a01kw [ cak_i_serial       ] := 'SERIAL            ';
a01kw [ cak_i_serverdb     ] := 'SERVERDB          ';
a01kw [ cak_i_session      ] := 'SESSION           ';
a01kw [ cak_i_set          ] := 'SET               ';
a01kw [ cak_i_share        ] := 'SHARE             ';
a01kw [ cak_i_show         ] := 'SHOW              ';
a01kw [ cak_i_shutdown     ] := 'SHUTDOWN          ';
a01kw [ cak_i_sign         ] := 'SIGN              ';
a01kw [ cak_i_sin          ] := 'SIN               ';
a01kw [ cak_i_sinh         ] := 'SINH              ';
a01kw [ cak_i_smallint     ] := 'SMALLINT          ';
a01kw [ cak_i_snapshot     ] := 'SNAPSHOT          ';
(* PTS 1111576 E.Z. *)
a01kw [ cak_i_some         ] := 'SOME              ';
a01kw [ cak_i_soundex      ] := 'SOUNDEX           ';
a01kw [ cak_i_sounds       ] := 'SOUNDS            ';
a01kw [ cak_i_space        ] := 'SPACE             ';
a01kw [ cak_i_sqlid        ] := 'SQLID             ';
a01kw [ cak_i_sqlmode      ] := 'SQLMODE           ';
a01kw [ cak_i_sqrt         ] := 'SQRT              ';
a01kw [ cak_i_stamp        ] := 'STAMP             ';
a01kw [ cak_i_standard     ] := 'STANDARD          ';
(* PTS 1111229 E.Z. *)
a01kw [ cak_i_standby      ] := 'STANDBY           ';
a01kw [ cak_i_start        ] := 'START             ';
a01kw [ cak_i_startpos     ] := 'STARTPOS          ';
a01kw [ cak_i_stat         ] := 'STAT              ';
a01kw [ cak_i_state        ] := 'STATE             ';
(* PTS 1119691 E.Z. *)
a01kw [ cak_i_static       ] := 'STATIC            ';
a01kw [ cak_i_statistics   ] := 'STATISTICS        ';
a01kw [ cak_i_stddev       ] := 'STDDEV            ';
a01kw [ cak_i_stop         ] := 'STOP              ';
a01kw [ cak_i_storage      ] := 'STORAGE           ';
a01kw [ cak_i_subdate      ] := 'SUBDATE           ';
a01kw [ cak_i_subpages     ] := 'SUBPAGES          ';
a01kw [ cak_i_substr       ] := 'SUBSTR            ';
a01kw [ cak_i_substring    ] := 'SUBSTRING         ';
a01kw [ cak_i_subtime      ] := 'SUBTIME           ';
a01kw [ cak_i_subtrans     ] := 'SUBTRANS          ';
a01kw [ cak_i_sum          ] := 'SUM               ';
a01kw [ cak_i_suspend      ] := 'SUSPEND           ';
a01kw [ cak_i_switch       ] := 'SWITCH            ';
(* PTS 1111229 E.Z. *)
a01kw [ cak_i_synchronize  ] := 'SYNCHRONIZE       ';
a01kw [ cak_i_synonym      ] := 'SYNONYM           ';
a01kw [ cak_i_sysdate      ] := 'SYSDATE           ';
a01kw [ cak_i_sysdba       ] := 'SYSDBA            ';
a01kw [ cak_i_system       ] := 'SYSTEM            ';
a01kw [ cak_i_table        ] := 'TABLE             ';
a01kw [ cak_i_tablespace   ] := 'TABLESPACE        ';
(* PTS 1111229 E.Z. *)
a01kw [ cak_i_takeover     ] := 'TAKEOVER          ';
a01kw [ cak_i_tan          ] := 'TAN               ';
a01kw [ cak_i_tanh         ] := 'TANH              ';
a01kw [ cak_i_tape         ] := 'TAPE              ';
a01kw [ cak_i_temp         ] := 'TEMP              ';
a01kw [ cak_i_then         ] := 'THEN              ';
a01kw [ cak_i_time         ] := 'TIME              ';
a01kw [ cak_i_timediff     ] := 'TIMEDIFF          ';
a01kw [ cak_i_timeout      ] := 'TIMEOUT           ';
a01kw [ cak_i_timestamp    ] := 'TIMESTAMP         ';
a01kw [ cak_i_timezone     ] := 'TIMEZONE          ';
a01kw [ cak_i_to           ] := 'TO                ';
a01kw [ cak_i_toidentifier ] := 'TOIDENTIFIER      ';
(* PTS 1110976 E.Z. *)
a01kw [ cak_i_to_char      ] := 'TO_CHAR           ';
a01kw [ cak_i_to_date      ] := 'TO_DATE           ';
a01kw [ cak_i_to_number    ] := 'TO_NUMBER         ';
a01kw [ cak_i_top          ] := 'TOP               ';
a01kw [ cak_i_trace        ] := 'TRACE             ';
a01kw [ cak_i_transaction  ] := 'TRANSACTION       ';
a01kw [ cak_i_translate    ] := 'TRANSLATE         ';
a01kw [ cak_i_trigger      ] := 'TRIGGER           ';
a01kw [ cak_i_trim         ] := 'TRIM              ';
a01kw [ cak_i_true         ] := 'TRUE              ';
a01kw [ cak_i_trunc        ] := 'TRUNC             ';
a01kw [ cak_i_truncate     ] := 'TRUNCATE          ';
a01kw [ cak_i_try          ] := 'TRY               ';
a01kw [ cak_i_type         ] := 'TYPE              ';
a01kw [ cak_i_ucase        ] := 'UCASE             ';
a01kw [ cak_i_uid          ] := 'UID               ';
a01kw [ cak_i_unicode      ] := 'UNICODE           ';
a01kw [ cak_i_union        ] := 'UNION             ';
a01kw [ cak_i_unique       ] := 'UNIQUE            ';
a01kw [ cak_i_unknown      ] := 'UNKNOWN           ';
a01kw [ cak_i_unload       ] := 'UNLOAD            ';
a01kw [ cak_i_unlock       ] := 'UNLOCK            ';
a01kw [ cak_i_until        ] := 'UNTIL             ';
a01kw [ cak_i_unused       ] := 'UNUSED            ';  (* PTS: 1117847 *)
a01kw [ cak_i_update       ] := 'UPDATE            ';
a01kw [ cak_i_upper        ] := 'UPPER             ';
a01kw [ cak_i_usa          ] := 'USA               ';
a01kw [ cak_i_usage        ] := 'USAGE             ';
a01kw [ cak_i_user         ] := 'USER              ';
a01kw [ cak_i_usergroup    ] := 'USERGROUP         ';
a01kw [ cak_i_userid       ] := 'USERID            ';
a01kw [ cak_i_using        ] := 'USING             ';
(* PTS 1116174 E.Z. *)
a01kw [ cak_i_utcdate      ] := 'UTCDATE           ';
(* PTS 1109925 E.Z. *)
a01kw [ cak_i_utcdiff      ] := 'UTCDIFF           ';
a01kw [ cak_i_validproc    ] := 'VALIDPROC         ';
a01kw [ cak_i_value        ] := 'VALUE             ';
a01kw [ cak_i_values       ] := 'VALUES            ';
a01kw [ cak_i_varchar      ] := 'VARCHAR           ';
a01kw [ cak_i_varchar2     ] := 'VARCHAR2          ';
a01kw [ cak_i_vargraphic   ] := 'VARGRAPHIC        ';
a01kw [ cak_i_variance     ] := 'VARIANCE          ';
a01kw [ cak_i_verify       ] := 'VERIFY            ';
a01kw [ cak_i_version      ] := 'VERSION           ';
a01kw [ cak_i_view         ] := 'VIEW              ';
(* PTS 1117472 E.Z. *)
a01kw [ cak_i_volume       ] := 'VOLUME            ';
a01kw [ cak_i_vsize        ] := 'VSIZE             ';
a01kw [ cak_i_vtrace       ] := 'VTRACE            ';
a01kw [ cak_i_wait         ] := 'WAIT              ';
a01kw [ cak_i_week         ] := 'WEEK              ';
a01kw [ cak_i_weekofyear   ] := 'WEEKOFYEAR        ';
a01kw [ cak_i_when         ] := 'WHEN              ';
a01kw [ cak_i_whenever     ] := 'WHENEVER          ';
a01kw [ cak_i_where        ] := 'WHERE             ';
a01kw [ cak_i_while        ] := 'WHILE             ';
a01kw [ cak_i_with         ] := 'WITH              ';
a01kw [ cak_i_work         ] := 'WORK              ';
a01kw [ cak_i_write        ] := 'WRITE             ';
(* PTS 1120104 E.Z. *)
a01kw [ cak_i_writer       ] := 'WRITER            ';
a01kw [ cak_i_year         ] := 'YEAR              ';
a01kw [ cak_i_years        ] := 'YEARS             ';
a01kw [ cak_i_zoned        ] := 'ZONED             ';
ak01reserved_keywords;
ak01sqlmode_keywords;
(* intervals for binary search *)
FOR kw_first_char := 'A' TO 'Z' DO
    BEGIN
    a01_kw_control[ kw_first_char ].first_pos := 1;
    a01_kw_control[ kw_first_char ].last_pos  := 1;
    END;
(*ENDFOR*) 
a01_kw_control [ 'A' ].first_pos := 1;
kw_first_char := 'A';
FOR kw_index := 1 TO cak_maxkeyword DO
    BEGIN
    IF  a01kw[ kw_index, 1 ] <> kw_first_char
    THEN
        BEGIN
        a01_kw_control[ kw_first_char ].last_pos := kw_index - 1;
        kw_first_char := a01kw [ kw_index, 1 ];
        a01_kw_control[ kw_first_char ].first_pos := kw_index;
        END;
    (*ENDIF*) 
    END;
(*ENDFOR*) 
a01_kw_control[ 'Z' ].last_pos := cak_maxkeyword;
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak01reserved_keywords;
 
VAR
      i    : integer;
      mode : tsp00_SqlMode;
 
BEGIN
FOR i := 1 TO cak_maxkeyword DO
    FOR mode := sqlm_ansi TO sqlm_internal DO
        ak01res_kw [ i, mode ] := false;
    (*ENDFOR*) 
(*ENDFOR*) 
(* switch for keywords >> true =  reserved keyword *)
(*=================== SQL-DB reserved keywords ================*)
ak01res_kw [ cak_i_abs         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_absolute    , sqlm_internal ] := true;
ak01res_kw [ cak_i_acos        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_asin        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_atan        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_atan2       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_adddate     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_addtime     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_all         , sqlm_internal ] := true;
ak01res_kw [ cak_i_alpha       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_alter       , sqlm_internal ] := true;
ak01res_kw [ cak_i_any         , sqlm_internal ] := true;
(* predicate (SELECT) *)
ak01res_kw [ cak_i_ascii       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_avg         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_binary      , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_bit         , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_boolean     , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_byte        , sqlm_internal ] := true; (* data type *)
(* PTS 1117523 E.Z. *)
ak01res_kw [ cak_i_case        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_ceil        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_ceiling     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_char        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_character   , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_chr         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_check       , sqlm_internal ] := true;
ak01res_kw [ cak_i_column      , sqlm_internal ] := true;
ak01res_kw [ cak_i_concat      , sqlm_internal ] := true; (* function *)
(* UPDATE STATISTICS *)
ak01res_kw [ cak_i_constraint  , sqlm_internal ] := true;
ak01res_kw [ cak_i_count       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_cos         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_cosh        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_cot         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_cross       , sqlm_internal ] := true; (* join *)
ak01res_kw [ cak_i_curdate     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_current     , sqlm_internal ] := true;
(* .. CURRENT OF ??    *)
ak01res_kw [ cak_i_current_schema, sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_curtime     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_database    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_date        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_datediff    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_day         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_dayname     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_dayofmonth  , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_dayofweek   , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_dayofyear   , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_dec         , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_decimal     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_decode      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_default     , sqlm_internal ] := true;
(* expr = DEFAULT *)
ak01res_kw [ cak_i_degrees     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_delete      , sqlm_internal ] := true;
(* table priv list *)
ak01res_kw [ cak_i_digits      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_distinct    , sqlm_internal ] := true;
(* SELECT DISTINCT ... *)
ak01res_kw [ cak_i_double      , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_except      , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_exists      , sqlm_internal ] := true;
(* predicate exists *)
ak01res_kw [ cak_i_exp         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_expand      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_first       , sqlm_internal ] := true;
(* SELECT FIRST ... *)
ak01res_kw [ cak_i_fixed       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_float       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_floor       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_for         , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_from        , sqlm_internal ] := true;
ak01res_kw [ cak_i_full        , sqlm_internal ] := true;
(* DELETE /FROM/ ... *)
(* PTS 1111577 E.Z. *)
ak01res_kw [ cak_i_get_objectname, sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_get_schema  , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_graphic     , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_greatest    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_group       , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_having      , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_hex         , sqlm_internal ] := true; (* function *)
(* PTS 1115974 E.Z. *)
ak01res_kw [ cak_i_hextoraw    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_hour        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_ifnull      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_ignore      , sqlm_internal ] := true;
(* insert select from *)
ak01res_kw [ cak_i_index       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_initcap     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_inner       , sqlm_internal ] := true;
ak01res_kw [ cak_i_insert      , sqlm_internal ] := true;
(* table priv list *)
ak01res_kw [ cak_i_int         , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_internal    , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_integer     , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_intersect   , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_into        , sqlm_internal ] := true;
ak01res_kw [ cak_i_isupdatedcolumn, sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_join        , sqlm_internal ] := true;
ak01res_kw [ cak_i_key         , sqlm_internal ] := true;
(* DELETE ... KEY *)
ak01res_kw [ cak_i_last        , sqlm_internal ] := true;
(* SELECT LAST ... *)
ak01res_kw [ cak_i_lcase       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_least       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_left        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_length      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_lfill       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_limit       , sqlm_internal ] := true; (* table-alias*)
ak01res_kw [ cak_i_list        , sqlm_internal ] := true;
(* table priv list *)
(* PTS 1111797 E.Z. *)
ak01res_kw [ cak_i_locate      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_ln          , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_log         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_log10       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_long        , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_longfile    , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_lower       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_lpad        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_ltrim       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_makedate    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_maketime    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_mapchar     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_max         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_mbcs        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_microsec    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_min         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_minute      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_mod         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_month       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_monthname   , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_natural     , sqlm_internal ] := true;
ak01res_kw [ cak_i_nchar       , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_next        , sqlm_internal ] := true;
ak01res_kw [ cak_i_no          , sqlm_internal ] := true; (* PTS 1109081 *)
(* SELECT NEXT ... *)
ak01res_kw [ cak_i_noround     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_not         , sqlm_internal ] := true;
(* expr = NOT ... *)
ak01res_kw [ cak_i_now         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_nowait      , sqlm_internal ] := true;
(* nowait beacuse: DELETE <tab> NOWAIT (may be seen as refname) *)
ak01res_kw [ cak_i_null        , sqlm_internal ] := true;
(* expr = NULL *)
ak01res_kw [ cak_i_num         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_numeric     , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_obid        , sqlm_internal ] := false;
ak01res_kw [ cak_i_object      , sqlm_internal ] := true; (* vtrace *)
ak01res_kw [ cak_i_of          , sqlm_internal ] := true;
(* UPDATE /OF/ ... *)
ak01res_kw [ cak_i_on          , sqlm_internal ] := true;
ak01res_kw [ cak_i_order       , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_packed      , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_pi          , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_power       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_prev        , sqlm_internal ] := true;
(* SELECT PREV ... *)
ak01res_kw [ cak_i_primary     , sqlm_internal ] := true;
ak01res_kw [ cak_i_radians     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_real        , sqlm_internal ] := true; (* data type *)
(* ..REFERENCED BY.. *)
ak01res_kw [ cak_i_relative    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_replace     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_reject      , sqlm_internal ] := true;
(* insert select from *)
ak01res_kw [ cak_i_rfill       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_right       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_round       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_rowid       , sqlm_internal ] := true;
ak01res_kw [ cak_i_rowno       , sqlm_internal ] := true;
(* ..WHERE ROWNO =.. *)
ak01res_kw [ cak_i_rpad        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_rtrim       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_second      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_select      , sqlm_internal ] := true;
(* table priv list *)
ak01res_kw [ cak_i_selupd      , sqlm_internal ] := true;
(* table priv list *)
ak01res_kw [ cak_i_set         , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_serial      , sqlm_internal ] := true;
ak01res_kw [ cak_i_show        , sqlm_internal ] := true;
(* SELECT SHOW ... *)
ak01res_kw [ cak_i_sign        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_sin         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_sinh        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_smallint    , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_some        , sqlm_internal ] := true;
(* predicate (SELECT) *)
ak01res_kw [ cak_i_soundex     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_space       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_sqrt        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_stamp       , sqlm_internal ] := true;
(* expr = STAMP *)
ak01res_kw [ cak_i_statistics  , sqlm_internal ] := true;
(* UPDATE STATISTICS *)
ak01res_kw [ cak_i_stddev      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_subdate     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_substr      , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_substring   , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_subtime     , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_sum         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_sysdba      , sqlm_internal ] := true;
(* expr = SYSDBA *)
ak01res_kw [ cak_i_table       , sqlm_internal ] := true;
(* GRANT..ON /TABLE/ *)
ak01res_kw [ cak_i_tan         , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_tanh        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_time        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_timediff    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_timestamp   , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_timezone    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_to          , sqlm_internal ] := true; (*          *)
ak01res_kw [ cak_i_top         , sqlm_internal ] := true; (* select top *)
ak01res_kw [ cak_i_toidentifier, sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_transaction , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_translate   , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_trim        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_trunc       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_truncate    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_ucase       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_uid         , sqlm_internal ] := true;
ak01res_kw [ cak_i_unicode     , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_union       , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_update      , sqlm_internal ] := true;
(* table priv list *)
ak01res_kw [ cak_i_upper       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_user        , sqlm_internal ] := true;
(* expr = USER *)
ak01res_kw [ cak_i_usergroup   , sqlm_internal ] := true;
(* expr = USERGROUP *)
ak01res_kw [ cak_i_using       , sqlm_internal ] := true;
(* PTS 1116174 E.Z. *)
ak01res_kw [ cak_i_utcdate     , sqlm_internal ] := true;
(* PTS 1109925 E.Z. *)
ak01res_kw [ cak_i_utcdiff     , sqlm_internal ] := true;
ak01res_kw [ cak_i_value       , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_values      , sqlm_internal ] := true; (* insert *)
ak01res_kw [ cak_i_varchar     , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_vargraphic  , sqlm_internal ] := true; (* data type *)
ak01res_kw [ cak_i_variance    , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_week        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_weekofyear  , sqlm_internal ] := true; (* function *)
(* PTS 1117523 E.Z. *)
ak01res_kw [ cak_i_when        , sqlm_internal ] := true; (* case when*)
ak01res_kw [ cak_i_where       , sqlm_internal ] := true; (* table-alias*)
ak01res_kw [ cak_i_with        , sqlm_internal ] := true; (* table_alias*)
ak01res_kw [ cak_i_year        , sqlm_internal ] := true; (* function *)
ak01res_kw [ cak_i_zoned       , sqlm_internal ] := true; (* data type *)
(*=================== DB2 reserved keywords ================*)
ak01res_kw [ cak_i_add         , sqlm_db2 ] := true;
ak01res_kw [ cak_i_all         , sqlm_db2 ] := true;
ak01res_kw [ cak_i_alter       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_and         , sqlm_db2 ] := true;
ak01res_kw [ cak_i_any         , sqlm_db2 ] := true;
ak01res_kw [ cak_i_as          , sqlm_db2 ] := true;
(* PTS 1111576 E.Z. *)
ak01res_kw [ cak_i_between     , sqlm_db2 ] := true;
ak01res_kw [ cak_i_bufferpool  , sqlm_db2 ] := true;
ak01res_kw [ cak_i_by          , sqlm_db2 ] := true;
ak01res_kw [ cak_i_cluster     , sqlm_db2 ] := true;
ak01res_kw [ cak_i_column      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_concat      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_count       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_current     , sqlm_db2 ] := true;
ak01res_kw [ cak_i_cursor      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_database    , sqlm_db2 ] := true;
ak01res_kw [ cak_i_delete      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_distinct    , sqlm_db2 ] := true;
ak01res_kw [ cak_i_drop        , sqlm_db2 ] := true;
ak01res_kw [ cak_i_editproc    , sqlm_db2 ] := true;
ak01res_kw [ cak_i_escape      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_except      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_execute     , sqlm_db2 ] := true;
ak01res_kw [ cak_i_exists      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_for         , sqlm_db2 ] := true;
ak01res_kw [ cak_i_from        , sqlm_db2 ] := true;
ak01res_kw [ cak_i_grant       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_group       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_having      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_in          , sqlm_db2 ] := true;
ak01res_kw [ cak_i_index       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_insert      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_into        , sqlm_db2 ] := true;
ak01res_kw [ cak_i_is          , sqlm_db2 ] := true;
ak01res_kw [ cak_i_key         , sqlm_db2 ] := true;
ak01res_kw [ cak_i_like        , sqlm_db2 ] := true;
ak01res_kw [ cak_i_not         , sqlm_db2 ] := true;
ak01res_kw [ cak_i_null        , sqlm_db2 ] := true;
ak01res_kw [ cak_i_obid        , sqlm_db2 ] := true;
ak01res_kw [ cak_i_of          , sqlm_db2 ] := true;
ak01res_kw [ cak_i_on          , sqlm_db2 ] := true;
ak01res_kw [ cak_i_optimize    , sqlm_db2 ] := true;
ak01res_kw [ cak_i_or          , sqlm_db2 ] := true;
ak01res_kw [ cak_i_order       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_privileges  , sqlm_db2 ] := true;
ak01res_kw [ cak_i_release     , sqlm_db2 ] := true; (* version 3 *)
ak01res_kw [ cak_i_select      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_set         , sqlm_db2 ] := true;
ak01res_kw [ cak_i_some        , sqlm_db2 ] := true;
ak01res_kw [ cak_i_synonym     , sqlm_db2 ] := true;
ak01res_kw [ cak_i_table       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_tablespace  , sqlm_db2 ] := true;
ak01res_kw [ cak_i_to          , sqlm_db2 ] := true;
ak01res_kw [ cak_i_union       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_update      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_user        , sqlm_db2 ] := true;
ak01res_kw [ cak_i_using       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_validproc   , sqlm_db2 ] := true;
ak01res_kw [ cak_i_values      , sqlm_db2 ] := true;
ak01res_kw [ cak_i_view        , sqlm_db2 ] := true;
ak01res_kw [ cak_i_where       , sqlm_db2 ] := true;
ak01res_kw [ cak_i_with        , sqlm_db2 ] := true;
(*=================== ORACLE reserved keywords ================*)
ak01res_kw [ cak_i_add         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_all         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_alter       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_and         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_any         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_as          , sqlm_oracle ] := true;
ak01res_kw [ cak_i_asc         , sqlm_oracle ] := true;
(* PTS 1111576 E.Z. *)
ak01res_kw [ cak_i_between     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_by          , sqlm_oracle ] := true;
ak01res_kw [ cak_i_char        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_check       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_cluster     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_column      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_comment     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_connect     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_create      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_current     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_date        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_decimal     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_default     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_delete      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_desc        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_distinct    , sqlm_oracle ] := true;
ak01res_kw [ cak_i_drop        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_exclusive   , sqlm_oracle ] := true;
ak01res_kw [ cak_i_exists      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_float       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_for         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_from        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_grant       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_group       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_having      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_identified  , sqlm_oracle ] := true;
ak01res_kw [ cak_i_in          , sqlm_oracle ] := true;
ak01res_kw [ cak_i_inout       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_index       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_insert      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_integer     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_intersect   , sqlm_oracle ] := true;
ak01res_kw [ cak_i_into        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_is          , sqlm_oracle ] := true;
ak01res_kw [ cak_i_isupdatedcolumn, sqlm_oracle ] := true;
ak01res_kw [ cak_i_level       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_like        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_lock        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_long        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_minus       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_mode        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_modify      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_no          , sqlm_oracle ] := true; (* PTS 1109081 *)
ak01res_kw [ cak_i_not         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_nowait      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_null        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_number      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_of          , sqlm_oracle ] := true;
ak01res_kw [ cak_i_on          , sqlm_oracle ] := true;
ak01res_kw [ cak_i_option      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_or          , sqlm_oracle ] := true;
ak01res_kw [ cak_i_order       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_pctfree     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_privileges  , sqlm_oracle ] := true;
ak01res_kw [ cak_i_public      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_raw         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_rename      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_resource    , sqlm_oracle ] := true;
ak01res_kw [ cak_i_revoke      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_row         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_rowid       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_rownum      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_rows        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_select      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_session     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_set         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_share       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_smallint    , sqlm_oracle ] := true;
ak01res_kw [ cak_i_synonym     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_sysdate     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_table       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_to          , sqlm_oracle ] := true;
ak01res_kw [ cak_i_trigger     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_uid         , sqlm_oracle ] := true;
ak01res_kw [ cak_i_union       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_unique      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_update      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_user        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_values      , sqlm_oracle ] := true;
ak01res_kw [ cak_i_varchar     , sqlm_oracle ] := true;
ak01res_kw [ cak_i_varchar2    , sqlm_oracle ] := true;
ak01res_kw [ cak_i_view        , sqlm_oracle ] := true;
ak01res_kw [ cak_i_whenever    , sqlm_oracle ] := true;
ak01res_kw [ cak_i_where       , sqlm_oracle ] := true;
ak01res_kw [ cak_i_with        , sqlm_oracle ] := true;
(*=================== ANSI reserved keywords =======================*)
ak01res_kw [ cak_i_absolute    , sqlm_ansi ] := true;
ak01res_kw [ cak_i_add         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_all         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_alter       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_and         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_any         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_as          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_asc         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_at          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_avg         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_begin       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_between     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_bit         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_both        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_by          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_cascade     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_catalog     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_char        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_character   , sqlm_ansi ] := true;
ak01res_kw [ cak_i_check       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_close       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_column      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_commit      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_connect     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_constraint  , sqlm_ansi ] := true;
ak01res_kw [ cak_i_count       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_create      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_current     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_current_date, sqlm_ansi ] := true;
ak01res_kw [ cak_i_current_time, sqlm_ansi ] := true;
ak01res_kw [ cak_i_current_timestamp, sqlm_ansi ] := true;
ak01res_kw [ cak_i_cursor      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_date        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_day         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_dec         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_decimal     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_declare     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_default     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_delete      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_desc        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_describe    , sqlm_ansi ] := true;
ak01res_kw [ cak_i_distinct    , sqlm_ansi ] := true;
ak01res_kw [ cak_i_domain      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_double      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_drop        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_end         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_escape      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_except      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_execute     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_exists      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_false       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_fetch       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_first       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_float       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_for         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_foreign     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_from        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_full        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_get         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_grant       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_group       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_having      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_hour        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_in          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_indicator   , sqlm_ansi ] := true;
ak01res_kw [ cak_i_inner       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_insert      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_int         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_integer     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_intersect   , sqlm_ansi ] := true;
ak01res_kw [ cak_i_into        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_is          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_isolation   , sqlm_ansi ] := true;
ak01res_kw [ cak_i_join        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_key         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_language    , sqlm_ansi ] := true;
ak01res_kw [ cak_i_last        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_left        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_level       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_like        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_local       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_lower       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_max         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_min         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_minute      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_month       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_natural     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_next        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_no          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_not         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_null        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_numeric     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_of          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_on          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_only        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_open        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_option      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_or          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_order       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_outer       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_precision   , sqlm_ansi ] := true;
ak01res_kw [ cak_i_primary     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_privileges  , sqlm_ansi ] := true;
ak01res_kw [ cak_i_procedure   , sqlm_ansi ] := true;
ak01res_kw [ cak_i_public      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_read        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_real        , sqlm_ansi ] := true;
(*ak01res_kw [ cak_i_recursive   , sqlm_ansi ] := true; SQL3 *)
ak01res_kw [ cak_i_references  , sqlm_ansi ] := true;
ak01res_kw [ cak_i_relative    , sqlm_ansi ] := true;
ak01res_kw [ cak_i_restrict    , sqlm_ansi ] := true;
ak01res_kw [ cak_i_revoke      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_right       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_rollback    , sqlm_ansi ] := true;
ak01res_kw [ cak_i_rows        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_schema      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_second      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_select      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_set         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_smallint    , sqlm_ansi ] := true;
ak01res_kw [ cak_i_some        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_sum         , sqlm_ansi ] := true;
ak01res_kw [ cak_i_table       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_time        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_timestamp   , sqlm_ansi ] := true;
ak01res_kw [ cak_i_to          , sqlm_ansi ] := true;
ak01res_kw [ cak_i_transaction , sqlm_ansi ] := true;
ak01res_kw [ cak_i_translate   , sqlm_ansi ] := true;
ak01res_kw [ cak_i_trim        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_true        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_union       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_unique      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_unknown     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_update      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_upper       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_usage       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_user        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_using       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_value       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_values      , sqlm_ansi ] := true;
ak01res_kw [ cak_i_varchar     , sqlm_ansi ] := true;
ak01res_kw [ cak_i_view        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_whenever    , sqlm_ansi ] := true;
ak01res_kw [ cak_i_where       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_with        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_work        , sqlm_ansi ] := true;
ak01res_kw [ cak_i_write       , sqlm_ansi ] := true;
ak01res_kw [ cak_i_year        , sqlm_ansi ] := true;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01sets_identifier (
            VAR id         : tsp00_KnlIdentifier;
            set_identifier : tak_oldidentifier);
 
VAR
      ix            : integer;
      i_len         : integer;
      err_char_no   : tsp00_Int4;
      uni_err       : tsp8_uni_error;
 
BEGIN
IF  g01unicode
THEN
    BEGIN
    i_len := sizeof (id);
    s80uni_trans (@set_identifier, sizeof (set_identifier), csp_ascii,
          @id, i_len, csp_unicode, [uni_fillup_field], uni_err,
          err_char_no)
    END
ELSE
    BEGIN
    FOR ix := 1 TO sizeof (set_identifier) DO
        id[ix] := set_identifier[ix];
    (*ENDFOR*) 
    FOR ix := sizeof (set_identifier) + 1 TO sizeof (id) DO
        id[ix] := bsp_c1;
    (*ENDFOR*) 
    END;
(*ENDIF*) 
END;
 
(* PTS 1115043 *)
(*------------------------------*) 
 
PROCEDURE
      a01set32_identifier (
            VAR id         : tsp00_KnlIdentifier;
            set_identifier : tsp00_Lname);
 
VAR
      ix            : integer;
      i_len         : integer;
      err_char_no   : tsp00_Int4;
      uni_err       : tsp8_uni_error;
 
BEGIN
IF  g01unicode
THEN
    BEGIN
    i_len := sizeof (id);
    s80uni_trans (@set_identifier, sizeof (set_identifier), csp_ascii,
          @id, i_len, csp_unicode, [uni_fillup_field], uni_err,
          err_char_no)
    END
ELSE
    BEGIN
    FOR ix := 1 TO sizeof (set_identifier) DO
        id[ix] := set_identifier[ix];
    (*ENDFOR*) 
    FOR ix := sizeof (set_identifier) + 1 TO sizeof (id) DO
        id[ix] := bsp_c1;
    (*ENDFOR*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01setl_identifier (
            VAR id         : tsp00_KnlIdentifier;
            set_identifier : tsp00_KnlIdentifier);
 
VAR
      ix : integer;
 
BEGIN
IF  NOT g01unicode
THEN
    id := set_identifier
ELSE
    FOR ix := sizeof (set_identifier) DIV 2 DOWNTO 1 DO
        BEGIN
        id [ix * 2    ] := set_identifier[ix];
        id [ix * 2 - 1] := csp_unicode_mark
        END;
    (*ENDFOR*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak01sqlmode_keywords;
 
VAR
      i       : integer;
      fullset : tak01_set_sqlmode;
 
BEGIN
fullset := [ sqlm_ansi, sqlm_db2, sqlm_oracle, sqlm_internal ];
FOR i := 1 TO cak_maxkeyword DO
    a01kw_sqlmode [ i ] := [  ];
(*ENDFOR*) 
(* PTS 1000313 E.Z. *)
(* PTS 1005820 E.Z. *)
(* switch for keywords >> true =  reserved keyword *)
a01kw_sqlmode [ cak_i_abs          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_absolute     ] := [ sqlm_ansi,   sqlm_internal ];
(* PTS 1115978 E.Z. *)
a01kw_sqlmode [ cak_i_acos         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_add          ] := fullset;
a01kw_sqlmode [ cak_i_add_months   ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_adddate      ] := [ sqlm_internal ];
(* PTS 1119691 E.Z. *)
a01kw_sqlmode [ cak_i_address      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_addtime      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_after        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_all          ] := fullset;
a01kw_sqlmode [ cak_i_alpha        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_alter        ]     := fullset;
a01kw_sqlmode [ cak_i_alterin      ]     := fullset;
a01kw_sqlmode [ cak_i_analyze      ]     := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_and          ]     := fullset;
a01kw_sqlmode [ cak_i_ansi         ]     := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_any          ]     := fullset;
a01kw_sqlmode [ cak_i_append       ]     := [ sqlm_internal, sqlm_oracle ];
(* PTS 1117381 E.Z. *)
a01kw_sqlmode [ cak_i_archive      ]     := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_as           ]     := fullset;
a01kw_sqlmode [ cak_i_asc          ]     :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_ascii        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_asin         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_at           ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_atan         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_atan2        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_authorization] := fullset; (* PTS 1127736 *)
(* PTS 1120104 E.Z. *)
a01kw_sqlmode [ cak_i_auto         ] := [ sqlm_internal ];
(* PTS 1111576 E.Z. *)
a01kw_sqlmode [ cak_i_autosave     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_avg          ] := fullset;
(* PTS 1117472 E.Z. *)
a01kw_sqlmode [ cak_i_bad          ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_before       ] := [ sqlm_internal ];
(* PTS 1104983 E.Z. *)
a01kw_sqlmode [ cak_i_begin        ] :=
      [ sqlm_ansi, sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_beginload    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_beginproc    ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_between      ] := fullset;
a01kw_sqlmode [ cak_i_binary       ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_bit          ] :=
      [ sqlm_ansi, sqlm_db2, sqlm_internal ];
(* PTS 1119691 E.Z. *)
a01kw_sqlmode [ cak_i_block        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_blocksize    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_boolean      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_both         ] := [ sqlm_ansi   ];
a01kw_sqlmode [ cak_i_break        ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_buffer       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_bufferpool   ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_bwhierarchy  ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_by           ] := fullset;
a01kw_sqlmode [ cak_i_byte         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_cache        ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_call         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_cancel       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_cachelimit   ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_caches       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_cascade      ] := fullset;
a01kw_sqlmode [ cak_i_case         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_catalog      ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_catch        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_ceil         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_ceiling      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_char         ] := fullset;
(*       [ sqlm_ansi, sqlm_db2, sqlm_internal ]; *)
a01kw_sqlmode [ cak_i_character    ] := fullset;
a01kw_sqlmode [ cak_i_check        ] := fullset;
(* PTS 1102256 E.Z. *)
a01kw_sqlmode [ cak_i_checkpoint   ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_chr          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_clear        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_close        ] := fullset;
a01kw_sqlmode [ cak_i_cluster      ] :=
      [ sqlm_db2, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_column       ] := fullset;
a01kw_sqlmode [ cak_i_comment      ] :=
      [ sqlm_db2, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_commit       ] := fullset;
a01kw_sqlmode [ cak_i_compute      ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_concat       ] :=
      [ sqlm_oracle, sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_config       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_connect      ] := fullset;
a01kw_sqlmode [ cak_i_constraint   ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_constraints  ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_container    ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_continue     ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_cos          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_cosh         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_costlimit    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_costwarning  ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_cot          ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_count        ] := fullset;
a01kw_sqlmode [ cak_i_create       ] := fullset;
a01kw_sqlmode [ cak_i_createin     ] := fullset;
a01kw_sqlmode [ cak_i_cross        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_curdate      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_current      ] := fullset;
a01kw_sqlmode [ cak_i_current_date ] := [ sqlm_ansi   ];
a01kw_sqlmode [ cak_i_current_schema]:= [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_current_time ] := [ sqlm_ansi   ];
a01kw_sqlmode [ cak_i_current_timestamp ] := [ sqlm_ansi   ];
a01kw_sqlmode [ cak_i_currval      ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_cursor       ] := fullset;
a01kw_sqlmode [ cak_i_curtime      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_cycle        ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_dafs         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_data         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_database     ] :=
      [ sqlm_db2, sqlm_internal , sqlm_oracle];
a01kw_sqlmode [ cak_i_date         ] := fullset;
a01kw_sqlmode [ cak_i_datediff     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_day          ] :=
      [ sqlm_ansi, sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_dayname      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_dayofmonth   ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_dayofweek    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_dayofyear    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_days         ] := [ sqlm_db2    ];
a01kw_sqlmode [ cak_i_db2          ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_dba          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_dbproc       ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_dbprocedure  ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_debug        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_dec          ] := fullset;
a01kw_sqlmode [ cak_i_decimal      ] := fullset;
a01kw_sqlmode [ cak_i_declare      ] := fullset;
a01kw_sqlmode [ cak_i_decode       ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_default      ] := fullset;
(* PTS 1117216 E.Z. *)
a01kw_sqlmode [ cak_i_defaultcode  ] := fullset;
a01kw_sqlmode [ cak_i_degree       ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_degrees      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_delete       ] := fullset;
a01kw_sqlmode [ cak_i_desc         ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_describe     ] := fullset;
a01kw_sqlmode [cak_i_deterministic ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_device       ] := [ sqlm_internal ];
(* GET DEVICE CONFIG *)
a01kw_sqlmode [ cak_i_diagnose     ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_digits       ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_dimension    ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_disable      ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_distinct     ] := fullset;
a01kw_sqlmode [ cak_i_div          ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_do           ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_domain       ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_double       ] := fullset;
a01kw_sqlmode [ cak_i_drop         ] := fullset;
a01kw_sqlmode [ cak_i_dropin       ] := fullset;
a01kw_sqlmode [ cak_i_dsetpass     ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_duplicates   ] := [ sqlm_internal ];
(* PTS 1107080 E.Z. *)
a01kw_sqlmode [ cak_i_dynamic      ] := [ sqlm_internal, sqlm_oracle  ];
a01kw_sqlmode [ cak_i_editproc     ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_enable       ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_else         ] := [ sqlm_internal, sqlm_oracle ];
(* PTS 1104983 E.Z. *)
a01kw_sqlmode [ cak_i_end          ] :=
      [ sqlm_ansi, sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_endload      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_endproc      ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_error        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_escape       ] := fullset;
a01kw_sqlmode [ cak_i_estimate     ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_eur          ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_except       ] :=
      [ sqlm_ansi, sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_exclusive    ] := [ sqlm_oracle, sqlm_internal ];
(* PTS 1104983 E.Z. *)
a01kw_sqlmode [ cak_i_execute      ] := fullset;
a01kw_sqlmode [ cak_i_exists       ] := fullset;
a01kw_sqlmode [ cak_i_exp          ] := [ sqlm_oracle, sqlm_internal ];
(* PTS 1105367 E.Z. *)
a01kw_sqlmode [ cak_i_expand       ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_explain      ] :=
      [ sqlm_db2, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_explicit     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_extended     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_fact         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_false        ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_fetch        ] := fullset;
a01kw_sqlmode [ cak_i_file         ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_first        ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_fixed        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_float        ] := fullset;
a01kw_sqlmode [ cak_i_floor        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_flush        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_for          ] := fullset;
(* PTS 1102256 E.Z. *)
a01kw_sqlmode [ cak_i_force        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_foreign      ] := fullset;
a01kw_sqlmode [ cak_i_format       ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_freepage     ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_from         ] := fullset;
a01kw_sqlmode [ cak_i_full         ] :=
      [ sqlm_internal, sqlm_ansi, sqlm_oracle];
a01kw_sqlmode [ cak_i_function     ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_fversion     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_get          ] := [ sqlm_ansi, sqlm_internal ];
(* PTS 1111577 E.Z. *)
a01kw_sqlmode [ cak_i_get_objectname] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_get_schema   ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_grant        ] := fullset;
a01kw_sqlmode [ cak_i_graphic      ] :=
      [ sqlm_db2, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_greatest     ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_group        ] := fullset;
a01kw_sqlmode [ cak_i_having       ] := fullset;
(* a01kw_sqlmode [ cak_i_hex       ] := [ sqlm_db2, sqlm_internal ]; *)
a01kw_sqlmode [ cak_i_hex          ] := [ sqlm_internal ];
(* PTS 1115974 E.Z. *)
a01kw_sqlmode [ cak_i_hextoraw     ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_high         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_history      ] := [ sqlm_internal ]; (* PTS 1129960 mb 2004-06-10 *)
a01kw_sqlmode [ cak_i_hold         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_hour         ] :=
      [ sqlm_ansi, sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_hours        ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_identified   ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_if           ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_ifnull       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_ignore       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_implicit     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_in           ] := fullset;
a01kw_sqlmode [ cak_i_inout        ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_increment    ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_index        ] := fullset;
a01kw_sqlmode [ cak_i_indexname    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_indicator    ] := [ sqlm_ansi, sqlm_db2  ];
(* PTS 1111229 E.Z. *)
a01kw_sqlmode [ cak_i_info         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_init         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_initcap      ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_initrans     ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_inner        ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_inproc       ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_insert       ] := fullset;
a01kw_sqlmode [ cak_i_instance     ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_instr        ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_int          ] := fullset;
a01kw_sqlmode [ cak_i_integer      ] := fullset;
a01kw_sqlmode [ cak_i_internal     ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_intersect    ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_into         ] := fullset;
a01kw_sqlmode [ cak_i_is           ] := fullset;
a01kw_sqlmode [ cak_i_iso          ] := [ sqlm_db2, sqlm_internal ];
(* PTS 1112876 E.Z. *)
a01kw_sqlmode [ cak_i_isolation    ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_isupdatedcolumn] := [ sqlm_oracle, sqlm_internal ];   (* PTS: 1127075 *)
a01kw_sqlmode [ cak_i_java         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_jis          ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_join         ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_key          ] := fullset;
a01kw_sqlmode [ cak_i_label        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_language     ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_last         ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_last_day     ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_lcase        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_least        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_length       ] := [ sqlm_db2, sqlm_oracle,
      sqlm_internal ];
a01kw_sqlmode [ cak_i_level        ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_lfill        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_like         ] := fullset;
a01kw_sqlmode [ cak_i_limit        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_list         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_left         ] :=
      [ sqlm_ansi, sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_ln           ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_load         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_local        ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_locate       ] := [ sqlm_internal ];
(* PTS 1111797 E.Z. *)
a01kw_sqlmode [ cak_i_lock         ] := fullset;
a01kw_sqlmode [ cak_i_log          ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_logfull      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_logwriter    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_log10        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_long         ] :=
      [ sqlm_db2, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_longfile     ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_low          ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_lower        ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_lpad         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_ltrim        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_makedate     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_maketime     ] := [ sqlm_internal ];
(* PTS 1120720 E.Z. *)
a01kw_sqlmode [ cak_i_mapchar      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_max          ] := fullset;
a01kw_sqlmode [ cak_i_maxtrans     ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_maxvalue     ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_minvalue     ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_mbcs         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_medianame    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_medium       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_microsec     ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_microsecs    ] := [ sqlm_db2 ];
(* PTS 1117050 E.Z. *)
a01kw_sqlmode [ cak_i_migrate      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_min          ] := fullset;
a01kw_sqlmode [ cak_i_minus        ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_minute       ] :=
      [ sqlm_ansi, sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_minutes      ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_mod          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_mode         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_modify       ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_monitor      ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_month        ] :=
      [ sqlm_ansi, sqlm_db2 , sqlm_internal ];
a01kw_sqlmode [ cak_i_monthname    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_months       ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_months_between ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_name         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_natural      ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_nchar        ] := [ sqlm_internal ];
(* PTS 1111229 E.Z. *)
a01kw_sqlmode [ cak_i_new          ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_new_time     ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_next         ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_next_day     ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_nextval      ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_nlssort      ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_nls_date_format   ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_nls_date_language ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_nls_language      ] := [ sqlm_oracle ];
(*a01kw_sqlmode [ cak_i_nls_numeric_chars ] := [ sqlm_oracle ];*)
(*a01kw_sqlmode [ cak_i_nls_currency      ] := [ sqlm_oracle ];*)
a01kw_sqlmode [ cak_i_nls_sort     ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_no           ] := [ sqlm_internal, sqlm_oracle, sqlm_ansi ];
a01kw_sqlmode [ cak_i_nocache      ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_nocycle      ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_nomaxvalue   ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_nominvalue   ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_noorder      ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_none         ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_norewind     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_nolog        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_normal       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_noround      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_nosort       ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_not          ] := fullset;
a01kw_sqlmode [ cak_i_now          ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_nowait       ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_null         ] := fullset;
a01kw_sqlmode [ cak_i_num          ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_number       ] := [ sqlm_oracle, sqlm_internal ]; (* PTS 1120019 *)
a01kw_sqlmode [ cak_i_numeric      ] := fullset;
a01kw_sqlmode [ cak_i_nvl          ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_obid         ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_object       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_of           ] := fullset;
a01kw_sqlmode [ cak_i_off          ] := fullset;
a01kw_sqlmode [ cak_i_on           ] := fullset;
a01kw_sqlmode [ cak_i_only         ] := [ sqlm_ansi, sqlm_db2 ];
a01kw_sqlmode [ cak_i_open         ] := fullset;
a01kw_sqlmode [ cak_i_optimistic   ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_optimize     ] := [ sqlm_db2 , sqlm_internal ];
a01kw_sqlmode [ cak_i_option       ] := fullset;
a01kw_sqlmode [ cak_i_or           ] := fullset;
a01kw_sqlmode [ cak_i_oracle       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_order        ] := fullset;
(* PTS 1104983 E.Z. *)
a01kw_sqlmode [ cak_i_out          ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_outer        ] := [ sqlm_ansi   ];
a01kw_sqlmode [ cak_i_overwrite    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_package      ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_packed       ] := [ sqlm_internal ];
(* PTS 1119691 E.Z. *)
a01kw_sqlmode [ cak_i_page         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_pages        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_param        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_parameter    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_parse        ] := fullset;
a01kw_sqlmode [ cak_i_parseid      ] := fullset;
a01kw_sqlmode [ cak_i_password     ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_pctfree      ] := [ sqlm_db2, sqlm_oracle ];
a01kw_sqlmode [ cak_i_pctused      ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_per          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_percent      ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_permanent    ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_pipe         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_pi           ] := [ sqlm_internal ];
(* PTS 1116223 E.Z. *)
a01kw_sqlmode [ cak_i_ping         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_pos          ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_power        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_precision    ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
(* PTS 1111229 E.Z. *)
a01kw_sqlmode [ cak_i_prepare      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_prev         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_primary      ] := fullset;
a01kw_sqlmode [ cak_i_priv         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_privileges   ] := fullset;
a01kw_sqlmode [ cak_i_proc         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_procedure    ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_psm          ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_public       ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_quick        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_radians      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_range        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_raw          ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_rawtohex     ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_read         ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_real         ] := fullset;
a01kw_sqlmode [ cak_i_recursive    ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_references   ] := fullset;
(* PTS 1111229 E.Z. *)
a01kw_sqlmode [ cak_i_register     ] := [ sqlm_internal ];
(* PTS 1111576 E.Z. *)
a01kw_sqlmode [ cak_i_reject       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_relative     ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_remote       ] := [ sqlm_oracle, sqlm_internal ];
(* PTS 1111229 E.Z. *)
a01kw_sqlmode [ cak_i_remove       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_release      ] :=
      [ sqlm_db2, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_rename       ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_replace      ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_replication  ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_reset        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_resource     ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_restart      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_restore      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_resume       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_restrict     ] := fullset;
a01kw_sqlmode [ cak_i_return       ] := fullset;
a01kw_sqlmode [ cak_i_returns      ] := fullset;
a01kw_sqlmode [ cak_i_reuse        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_revoke       ] := fullset;
(* PTS 1111576 E.Z. *)
a01kw_sqlmode [ cak_i_rfill        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_right        ] :=
      [ sqlm_ansi, sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_role         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_rollback     ] := fullset;
a01kw_sqlmode [ cak_i_round        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_row          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_rowid        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_rowno        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_rownum       ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_rows         ] := fullset;
a01kw_sqlmode [ cak_i_rpad         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_rtrim        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_same         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_sample       ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_sapr3        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_save         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_savepoint    ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_schema       ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_second       ] :=
      [ sqlm_ansi, sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_seconds      ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_select       ] := fullset;
a01kw_sqlmode [ cak_i_selectivity  ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_selupd       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_sequence     ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_serial       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_serverdb     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_session      ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_set          ] := fullset;
a01kw_sqlmode [ cak_i_share        ] :=
      [ sqlm_db2, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_show         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_shutdown     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_sign         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_sin          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_sinh         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_smallint     ] := fullset;
a01kw_sqlmode [ cak_i_snapshot     ] := [ sqlm_internal ];
(* PTS 1111576 E.Z. *)
a01kw_sqlmode [ cak_i_some         ] := fullset;
a01kw_sqlmode [ cak_i_soundex      ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_sounds       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_space        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_sqlid        ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_sqlmode      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_sqrt         ] := [ sqlm_oracle, sqlm_internal ];
(* PTS 1105319 E.Z. *)
(* PTS 1119691 E.Z. *)
a01kw_sqlmode [ cak_i_static       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_stamp        ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_standard     ] := [ sqlm_internal ];
(* PTS 1111229 E.Z. *)
a01kw_sqlmode [ cak_i_standby      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_start        ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_startpos     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_stat         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_state        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_statistics   ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_stddev       ] := [ sqlm_oracle, sqlm_internal ];
(* PTS 1104983 E.Z. *)
a01kw_sqlmode [ cak_i_stop         ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_storage      ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_subdate      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_subpages     ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_substr       ] := fullset - [ sqlm_ansi ];
a01kw_sqlmode [ cak_i_substring    ] := fullset - [ sqlm_ansi ];
a01kw_sqlmode [ cak_i_subtime      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_subtrans     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_sum          ] := fullset;
a01kw_sqlmode [ cak_i_suspend      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_switch       ] := [ sqlm_internal ];
(* PTS 1111229 E.Z. *)
a01kw_sqlmode [ cak_i_synchronize  ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_synonym      ] := fullset;
a01kw_sqlmode [ cak_i_sysdate      ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_system       ] := [ sqlm_internal, sqlm_oracle ];
(* PTS 1104590 E.Z. *)
a01kw_sqlmode [ cak_i_sysdba       ] := fullset;
a01kw_sqlmode [ cak_i_table        ] := fullset;
a01kw_sqlmode [ cak_i_tablespace   ] := [ sqlm_db2, sqlm_oracle ];
(* PTS 1111229 E.Z. *)
a01kw_sqlmode [ cak_i_takeover     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_tan          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_tanh         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_tape         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_temp         ] := [ sqlm_internal ];
(* PTS 1116602 E.Z. *)
a01kw_sqlmode [ cak_i_then         ] :=
      [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_time         ] :=
      [ sqlm_ansi, sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_timediff     ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_timeout      ] := [ sqlm_internal ];
(* PTS 1105367 E.Z. *)
a01kw_sqlmode [ cak_i_timestamp    ] := fullset;
a01kw_sqlmode [ cak_i_timezone     ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_to           ] := fullset;
a01kw_sqlmode [ cak_i_toidentifier ] := [ sqlm_internal ];
(* PTS 1110976 E.Z. *)
a01kw_sqlmode [ cak_i_to_char      ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_to_date      ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_to_number    ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_top          ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_trace        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_transaction  ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_translate    ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_trigger      ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_trim         ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_true         ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_trunc        ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_try          ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_truncate     ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_type         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_ucase        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_uid          ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_unicode      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_union        ] := fullset;
a01kw_sqlmode [ cak_i_unique       ] := fullset;
a01kw_sqlmode [ cak_i_unknown      ] := [ sqlm_ansi, sqlm_internal ];
a01kw_sqlmode [ cak_i_unload       ] := [ sqlm_internal ];
(* PTS 1107262 E.Z. *)
a01kw_sqlmode [ cak_i_unlock       ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_until        ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_unused       ] := [ sqlm_oracle ];                  (* PTS: 1117847 *)
a01kw_sqlmode [ cak_i_update       ] := fullset;
a01kw_sqlmode [ cak_i_upper        ] :=
      [ sqlm_ansi, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_usa          ] := [ sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_usage        ] := fullset;
a01kw_sqlmode [ cak_i_user         ] := fullset;
(* PTS 1105367 E.Z. *)
a01kw_sqlmode [ cak_i_usergroup    ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_userid       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_using        ] := fullset;
(* PTS 1116174 E.Z. *)
a01kw_sqlmode [ cak_i_utcdate      ] := fullset;
(* PTS 1109925 E.Z. *)
a01kw_sqlmode [ cak_i_utcdiff      ] := fullset;
a01kw_sqlmode [ cak_i_validproc    ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_value        ] :=
      [ sqlm_ansi, sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_values       ] := fullset;
a01kw_sqlmode [ cak_i_varchar      ] := fullset;
a01kw_sqlmode [ cak_i_varchar2     ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_vargraphic   ] :=
      [ sqlm_db2, sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_variance     ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_verify       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_version      ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_view         ] := fullset;
(* PTS 1117472 E.Z. *)
a01kw_sqlmode [ cak_i_volume       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_vsize        ] := [ sqlm_oracle ];
a01kw_sqlmode [ cak_i_vtrace       ] := [ sqlm_internal ];
(* PTS 1102256 E.Z. *)
a01kw_sqlmode [ cak_i_wait         ] := [ sqlm_oracle, sqlm_internal ];
a01kw_sqlmode [ cak_i_week         ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_weekofyear   ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_when         ] := fullset;
a01kw_sqlmode [ cak_i_whenever     ] := fullset;
a01kw_sqlmode [ cak_i_where        ] := fullset;
a01kw_sqlmode [ cak_i_while        ] := [ sqlm_internal, sqlm_oracle ];
a01kw_sqlmode [ cak_i_with         ] := fullset;
a01kw_sqlmode [ cak_i_work         ] := fullset;
a01kw_sqlmode [ cak_i_write        ] := [ sqlm_ansi, sqlm_internal ];
(* PTS 1120104 E.Z. *)
a01kw_sqlmode [ cak_i_writer       ] := [ sqlm_internal ];
a01kw_sqlmode [ cak_i_year         ] :=
      [ sqlm_ansi, sqlm_db2, sqlm_internal ];
a01kw_sqlmode [ cak_i_years        ] := [ sqlm_db2 ];
a01kw_sqlmode [ cak_i_zoned        ] := [ sqlm_internal ];
END;
 
&ifdef TRACE
(* only for use for Elke if she wants to update the keywordlists *)
(* in the reference manual                                       *)
(*------------------------------*) 
 
PROCEDURE
      ak01write_keyword (
            kw_index      : integer;
            VAR no        : integer;
            VAR firstchar : char);
 
BEGIN
WITH ak01myline DO
    BEGIN
    IF  NOT ((kw_index = cak_i_nls_currency)      OR
        (     kw_index = cak_i_nls_numeric_chars))
    THEN
        BEGIN
        IF  a01kw[ kw_index ][ 1 ] <> firstchar
        THEN
            BEGIN
            t01bufline (td_always, line, 5+no * (sizeof(key1)+1));
            t01bufline (td_always, line, 5);
            firstchar := a01kw[ kw_index ][ 1 ];
            no := 0;
            END;
        (*ENDIF*) 
        IF  no >= 3
        THEN
            BEGIN
            t01bufline (td_always, line, 5+no * (sizeof(key1)+1));
            no := 0
            END;
        (*ENDIF*) 
        CASE kw_index OF
            cak_i_nls_numeric_chars :
                BEGIN
                (* write (' NLS_NUMERIC_CHARACTERS       ');*)
                no := succ(no)
                END;
            OTHERWISE
                BEGIN
                CASE no OF
                    0 :
                        key1 := a01kw [ kw_index ];
                    1 :
                        key2 := a01kw [ kw_index ];
                    2 :
                        key3 := a01kw [ kw_index ];
                    END;
                (*ENDCASE*) 
                END
            END;
        (*ENDCASE*) 
        no := succ(no);
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
&endif
(*------------------------------*) 
 
PROCEDURE
      a01_write_keywords;
 
VAR
      kw_index  : integer;
      no        : integer;
      firstchar : char;
 
BEGIN
(* only for use for Elke if she wants to update the keywordlists *)
(* in the reference manual                                       *)
&ifdef TRACE
;
WITH ak01myline DO
    BEGIN
    filler5  := bsp_c5;
    fillerk1 := bsp_c1;
    fillerk2 := bsp_c1;
    fillerk3 := bsp_c1;
    t01bufline (td_always, line, 5);
    t01bufline (td_always, line, 5);
    key1 := 'NOT RESERVED      ';
    t01bufline (td_always, line, 5+sizeof(key1));
    no := 0;
    firstchar := '1';
    FOR kw_index := 1 TO cak_maxkeyword DO
        IF  (NOT ak01res_kw[ kw_index, sqlm_internal ])
            AND (a01kw_sqlmode[ kw_index ] <> [])
            (*
                  >        AND (NOT ak01res_kw[ kw_index, sqlm_ansi   ])
                  >        AND (NOT ak01res_kw[ kw_index, sqlm_db2    ])
                  >        AND (NOT ak01res_kw[ kw_index, sqlm_oracle ])
                  *)
        THEN
            ak01write_keyword (kw_index, no, firstchar);
        (*ENDIF*) 
    (*ENDFOR*) 
    t01bufline (td_always, line, 5+no * (sizeof(key1)+1));
    t01bufline (td_always, line, 5);
    t01bufline (td_always, line, 5);
    key1 := 'INTERNAL RESERVED ';
    t01bufline (td_always, line, 5+sizeof(key1));
    no := 0;
    firstchar := '1';
    FOR kw_index := 1 TO cak_maxkeyword DO
        IF  ak01res_kw[ kw_index, sqlm_internal ]
            AND (sqlm_internal in a01kw_sqlmode[ kw_index ])
        THEN
            ak01write_keyword (kw_index, no, firstchar);
        (* ==============================
              >writeln (bsp_name);
              >writeln (bsp_name);
              >writeln ('ANSI   RESTRICTED !!   ');
              >no := 0;
              >firstchar := '1';
              >FOR kw_index := 1 TO cak_maxkeyword DO
              >    IF  ((NOT ak01res_kw[ kw_index, sqlm_ansi   ])
              >        AND
              >        ((ak01res_kw[ kw_index, sqlm_internal ]) OR
              >        ( ak01res_kw[ kw_index, sqlm_db2    ]) OR
              >        ( ak01res_kw[ kw_index, sqlm_oracle ])))
              >    THEN
              >        ak01write_keyword (kw_index, no, firstchar);
              >writeln (bsp_name);
              >writeln (bsp_name);
              >writeln ('ANSI   RESERVED ');
              >no := 0;
              >firstchar := '1';
              >FOR kw_index := 1 TO cak_maxkeyword DO
              >    IF  ak01res_kw[ kw_index, sqlm_ansi   ]
              >    THEN
              >        ak01write_keyword (kw_index, no, firstchar);
              >writeln (bsp_name);
              >writeln (bsp_name);
              >writeln ('DB2    RESTRICTED !!   ');
              >no := 0;
              >firstchar := '1';
              >FOR kw_index := 1 TO cak_maxkeyword DO
              >    IF  ((NOT ak01res_kw[ kw_index, sqlm_db2    ])
              >        AND
              >        ((ak01res_kw[ kw_index, sqlm_ansi   ]) OR
              >        ( ak01res_kw[ kw_index, sqlm_internal ]) OR
              >        ( ak01res_kw[ kw_index, sqlm_oracle ])))
              >    THEN
              >        ak01write_keyword (kw_index, no, firstchar);
              >writeln (bsp_name);
              >writeln (bsp_name);
              >writeln ('DB2    RESERVED ');
              >no := 0;
              >firstchar := '1';
              >FOR kw_index := 1 TO cak_maxkeyword DO
              >    IF  ak01res_kw[ kw_index, sqlm_db2    ]
              >    THEN
              >        ak01write_keyword (kw_index, no, firstchar);
              >writeln (bsp_name);
              >writeln (bsp_name);
              >writeln ('ORACLE RESTRICTED !!   ');
              >no := 0;
              >firstchar := '1';
              >FOR kw_index := 1 TO cak_maxkeyword DO
              >    IF  ((NOT ak01res_kw[ kw_index, sqlm_oracle ])
              >        AND
              >        ((ak01res_kw[ kw_index, sqlm_ansi   ]) OR
              >        ( ak01res_kw[ kw_index, sqlm_db2    ]) OR
              >        ( ak01res_kw[ kw_index, sqlm_internal ])))
              >    THEN
              >        ak01write_keyword (kw_index, no, firstchar);
              >writeln (bsp_name);
              >writeln (bsp_name);
              >writeln ('ORACLE RESERVED ');
              >no := 0;
              >firstchar := '1';
              >FOR kw_index := 1 TO cak_maxkeyword DO
              >    IF  ak01res_kw[ kw_index, sqlm_oracle ]
              >    THEN
              >        ak01write_keyword (kw_index, no, firstchar);
              ============================== *)
        (*ENDIF*) 
    (*ENDFOR*) 
    t01bufline (td_always, line, 5+no * (sizeof(key1)+1));
    t01bufline (td_always, line, 5);
    t01bufline (td_always, line, 5);
    key1 := 'ANSI not Key !!   ';
    t01bufline (td_always, line, 5+sizeof(key1));
    no := 0;
    firstchar := '1';
    FOR kw_index := 1 TO cak_maxkeyword DO
        IF  ((ak01res_kw[ kw_index, sqlm_ansi ])
            AND
            (NOT (sqlm_ansi in a01kw_sqlmode[ kw_index ])))
        THEN
            ak01write_keyword (kw_index, no, firstchar);
        (*ENDIF*) 
    (*ENDFOR*) 
    t01bufline (td_always, line, 5+no * (sizeof(key1)+1));
    t01bufline (td_always, line, 5);
    t01bufline (td_always, line, 5);
    key1 := 'INTERNAL not Key!!';
    t01bufline (td_always, line, 5+sizeof(key1));
    no := 0;
    firstchar := '1';
    FOR kw_index := 1 TO cak_maxkeyword DO
        IF  ((ak01res_kw[ kw_index, sqlm_internal ])
            AND
            (NOT (sqlm_internal in a01kw_sqlmode[ kw_index ])))
        THEN
            ak01write_keyword (kw_index, no, firstchar);
        (*ENDIF*) 
    (*ENDFOR*) 
    t01bufline (td_always, line, 5+no * (sizeof(key1)+1));
    t01bufline (td_always, line, 5);
    t01bufline (td_always, line, 5);
    key1 := 'DB2    not Key !! ';
    t01bufline (td_always, line, 5+sizeof(key1));
    no := 0;
    firstchar := '1';
    FOR kw_index := 1 TO cak_maxkeyword DO
        IF  ((ak01res_kw[ kw_index, sqlm_db2 ])
            AND
            (NOT (sqlm_db2 in a01kw_sqlmode[ kw_index ])))
        THEN
            ak01write_keyword (kw_index, no, firstchar);
        (*ENDIF*) 
    (*ENDFOR*) 
    t01bufline (td_always, line, 5+no * (sizeof(key1)+1));
    t01bufline (td_always, line, 5);
    t01bufline (td_always, line, 5);
    key1 := 'ORACLE not Key !! ';
    t01bufline (td_always, line, 5+sizeof(key1));
    no := 0;
    firstchar := '1';
    FOR kw_index := 1 TO cak_maxkeyword DO
        IF  ((ak01res_kw[ kw_index, sqlm_oracle ])
            AND
            (NOT (sqlm_oracle in a01kw_sqlmode[ kw_index ])))
        THEN
            ak01write_keyword (kw_index, no, firstchar);
        (*ENDIF*) 
    (*ENDFOR*) 
    t01bufline (td_always, line, 5+no * (sizeof(key1)+1));
    t01bufline (td_always, line, 5);
    t01bufline (td_always, line, 5);
    key1 := 'not known      !! ';
    t01bufline (td_always, line, 5+sizeof(key1));
    no := 0;
    firstchar := '1';
    FOR kw_index := 1 TO cak_maxkeyword DO
        IF  a01kw_sqlmode[ kw_index ] = []
        THEN
            ak01write_keyword (kw_index, no, firstchar);
        (*ENDIF*) 
    (*ENDFOR*) 
    t01bufline (td_always, line, 5+no * (sizeof(key1)+1));
    END;
(*ENDWITH*) 
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_put_node (
            VAR acv    : tak_all_command_glob;
            VAR curr_n : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  a_scv_index = a_ap_max_node
    THEN
        ak01tree_enlargement (acv);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a_scv_index := succ (a_scv_index);
        IF  (a_scv_index < a_maxnode) AND
            (ni_skip_node in a_ap_tree^[a_scv_index].n_special)
        THEN (* a_scv_index points into a gap *)
            a_scv_index := a_ap_tree^[a_scv_index].n_pos;
        (*ENDIF*) 
        IF  a_scv_index > a_maxnode
        THEN
            a_maxnode := a_scv_index;
        (*ENDIF*) 
        WITH a_ap_tree^[ a_scv_index ] DO
            BEGIN
            n_proc     := no_proc;
            IF  scs_pack in sc_states
            THEN
                n_special := [ni_complex_string_id]
            ELSE
                n_special := [];
            (*ENDIF*) 
            n_symb     := sc_symb;
            n_pos      := sc_sypos;
            IF  n_symb = s_parameter_name
            THEN
                BEGIN
                a_count_variab := succ (a_count_variab);
                n_subproc      := sc_sylength;
                n_length       := a_count_variab + a_parameter_offset
                END
            ELSE
                BEGIN
                IF  n_symb in [
                    s_string_literal, s_byte_string,
                    s_unsigned_integer, s_fixed_point_literal, s_floating_point_literal,
                    s_plus, s_minus,
                    s_null,
                    s_true, s_false,
                    s_pi,
                    s_uid, s_user, s_usergroup, s_current_schema,
                    s_database, s_transaction,
                    s_sysdba,
                    s_date, s_time, s_utcdate, s_timestamp, s_now, s_timezone, s_utcdiff, s_midnight,
                    s_stamp, s_nextval, s_currval,
                    s_degree
                    ]
                THEN
                    a_count_literals := succ(a_count_literals);
                (*ENDIF*) 
                n_subproc := 0;
                n_length  := sc_sylength;
                END;
            (*ENDIF*) 
            n_datatype := dunknown;
            n_lo_level := 0;
            n_sa_level := 0;
            (* D.T. QueryRewrite *)
            n_refback   := cak_qrewrite_ref_init;
            n_querycheck:= [];
            n_dt_format := a_dt_format;
            (* *)
            curr_n     := a_scv_index;
            END;
        (*ENDWITH*) 
        END
    ELSE
        curr_n := 0
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* PTS 1116838 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      a01_put_same_node (
            VAR acv    : tak_all_command_glob;
            input_node : tsp00_Int2;
            VAR curr_n : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  a_scv_index = a_ap_max_node
    THEN
        ak01tree_enlargement (acv);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a_scv_index := succ (a_scv_index);
        IF  (a_scv_index < a_maxnode) AND
            (ni_skip_node in a_ap_tree^[a_scv_index].n_special)
        THEN (* a_scv_index points into a gap *)
            a_scv_index := a_ap_tree^[a_scv_index].n_pos;
        (*ENDIF*) 
        IF  a_scv_index > a_maxnode
        THEN
            a_maxnode := a_scv_index;
        (*ENDIF*) 
        a_ap_tree^[ a_scv_index ]            := a_ap_tree^[ input_node ];
        a_ap_tree^[ a_scv_index ].n_lo_level := 0;
        a_ap_tree^[ a_scv_index ].n_sa_level := 0;
        curr_n     := a_scv_index;
        END
    ELSE
        curr_n := 0
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_function_put (
            VAR acv    : tak_all_command_glob;
            VAR curr_n : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  a_scv_index = a_ap_max_node
    THEN
        ak01tree_enlargement (acv);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a_scv_index := succ (a_scv_index);
        IF  (a_scv_index < a_maxnode) AND
            (ni_skip_node in a_ap_tree^[a_scv_index].n_special)
        THEN (* a_scv_index points into a gap *)
            a_scv_index := a_ap_tree^[a_scv_index].n_pos;
        (*ENDIF*) 
        IF  a_scv_index > a_maxnode
        THEN
            a_maxnode := a_scv_index;
        (*ENDIF*) 
        WITH a_ap_tree^[ a_scv_index ] DO
            BEGIN
            n_proc     := a641;
            n_special  := [];
            n_symb     := sc_symb;
            n_pos      := sc_sypos;
            n_length   := sc_sylength;
            n_datatype := dunknown;
            n_subproc  := 0;
            n_lo_level := 0;
            n_sa_level := 0;
            (* D.T. QueryRewrite *)
            n_refback   := cak_qrewrite_ref_init;
            n_querycheck:= [];
            n_dt_format := a_dt_format;
            (* *)
            curr_n     := a_scv_index;
            END;
        (*ENDWITH*) 
        END
    ELSE
        curr_n := 0
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_dt_put_datatype_node (
            VAR acv    : tak_all_command_glob;
            VAR curr_n : tsp00_Int2;
            data_type  : tsp00_DataType;
            datalen    : tsp00_Int2;
            datafrac   : tsp00_Int2;
            inoutlen   : integer);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  a_scv_index = a_ap_max_node
    THEN
        ak01tree_enlargement (acv);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a_scv_index := succ (a_scv_index);
        IF  (a_scv_index < a_maxnode) AND
            (ni_skip_node in a_ap_tree^[a_scv_index].n_special)
        THEN (* a_scv_index points into a gap *)
            a_scv_index := a_ap_tree^[a_scv_index].n_pos;
        (*ENDIF*) 
        IF  a_scv_index > a_maxnode
        THEN
            a_maxnode := a_scv_index;
        (*ENDIF*) 
        WITH a_ap_tree^[ a_scv_index ] DO
            BEGIN
            n_proc     := no_proc;
            n_special  := [];
            n_symb     := s_unknown;
            (* PTS 1116169 E.Z. *)
            IF  data_type = dfixed
            THEN
                n_pos := (datalen * 100) + datafrac
            ELSE
                n_pos := datalen;
            (*ENDIF*) 
            n_datatype := data_type;
            n_length   := inoutlen;
            n_subproc  := 0;
            n_lo_level := 0;
            n_sa_level := 0;
            (* D.T. QueryRewrite *)
            n_refback   := cak_qrewrite_ref_init;
            n_querycheck:= [];
            n_dt_format := a_dt_format;
            (* *)
            curr_n     := a_scv_index;
            END;
        (*ENDWITH*) 
        END
    ELSE
        curr_n := 0
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_call_put (
            VAR acv    : tak_all_command_glob;
            proc       : tak_procs;
            subproc    : tsp00_Int2;
            VAR curr_n : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  a_scv_index = a_ap_max_node
    THEN
        ak01tree_enlargement (acv);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a_scv_index := succ (a_scv_index);
        IF  (a_scv_index < a_maxnode) AND
            (ni_skip_node in a_ap_tree^[a_scv_index].n_special)
        THEN (* a_scv_index points into a gap *)
            a_scv_index := a_ap_tree^[a_scv_index].n_pos;
        (*ENDIF*) 
        IF  a_scv_index > a_maxnode
        THEN
            a_maxnode := a_scv_index;
        (*ENDIF*) 
        WITH a_ap_tree^[ a_scv_index ] DO
            BEGIN
            n_proc     := proc;
            n_special  := [];
            n_symb     := s_unknown;
            n_pos      := sc_sypos;
            n_length   := 0;
            n_datatype := dunknown;
            n_subproc  := subproc;
            n_lo_level := 0;
            n_sa_level := 0;
            (* D.T. QueryRewrite *)
            n_refback   := cak_qrewrite_ref_init;
            n_querycheck:= [];
            n_dt_format := a_dt_format;
            (* *)
            curr_n     := a_scv_index;
            END;
        (*ENDWITH*) 
        END
    ELSE
        curr_n := 0
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* D.T. QueryRewrite *)
(*------------------------------*) 
 
PROCEDURE
      a01_call_put_queryrewrite (
            VAR acv    : tak_all_command_glob;
            VAR curr_n : tsp00_Int2);
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  a_scv_index = a_ap_max_node
    THEN
        ak01tree_enlargement (acv);
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        BEGIN
        a_scv_index := succ (a_scv_index);
        IF  (a_scv_index < a_maxnode) AND
            (ni_skip_node in a_ap_tree^[a_scv_index].n_special)
        THEN (* a_scv_index points into a gap *)
            a_scv_index := a_ap_tree^[a_scv_index].n_pos;
        (*ENDIF*) 
        IF  a_scv_index > a_maxnode
        THEN
            a_maxnode := a_scv_index;
        (*ENDIF*) 
        WITH a_ap_tree^[ a_scv_index ] DO
            BEGIN
            n_proc      := no_proc;
            n_special   := [];
            n_symb      := s_unknown;
            n_pos       := 0;
            n_length    := 0;
            n_datatype  := dunknown;
            n_subproc   := 0;
            n_lo_level  := 0;
            n_sa_level  := 0;
            n_refback   := 0;
            n_querycheck:= [];
            n_dt_format := a_dt_format;
            curr_n      := a_scv_index;
            END;
        (*ENDWITH*) 
        END
    ELSE
        curr_n := 0
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(* *)
(*------------------------------*) 
 
PROCEDURE
      a01_get_keyword (
            VAR acv   : tak_all_command_glob;
            VAR index : integer; VAR reserved : boolean);
 
VAR
      i             : integer;
      j             : integer;
      k             : integer;
      hkw           : tak_keyword;
      word24        : tsp00_C24;
      extra         : boolean;
      symb_len      : integer;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    index  := 0;
    reserved  := FALSE;
    IF  a_returncode = 0
    THEN
        BEGIN
        extra := false;
        IF  g01unicode
        THEN
            symb_len := sc_sylength DIV 2
        ELSE
            symb_len := sc_sylength;
        (*ENDIF*) 
        IF  ((sc_symb = s_identifier) AND
            (symb_len = 0) AND
            (a_sqlmode = sqlm_oracle))
        THEN
            BEGIN
            index := cak_i_null;
            reserved := ak01res_kw[ cak_i_null, acv.a_sqlmode ];
            END
        ELSE
            IF  (sc_symb = s_identifier)
                AND (symb_len >  sizeof (hkw))
                AND (symb_len <= c_mx_extra_len)
                AND (sc_double_quote = 0)
            THEN
                BEGIN
                word24 := bsp_c24;
                IF  g01unicode
                THEN
                    FOR i := 1 TO symb_len DO
                        word24 [i] := a_cmd_part^.sp1p_buf [sc_sypos + (i*2) - 1]
                    (*ENDFOR*) 
                ELSE
                    SAPDB_PascalMove ('VAK01 ',   3,    
                          a_cmd_part^.sp1p_buf_len, sizeof (word24),
                          @a_cmd_part^.sp1p_buf, sc_sypos,
                          @word24, 1, symb_len,
                          a_returncode);
                (*ENDIF*) 
                extra := word24 = c_nls_numeric_characters;
                IF  extra
                THEN
                    symb_len := sizeof (hkw)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (sc_symb = s_identifier)
            AND (sc_sylength > 1)
            AND (sc_double_quote = 0)
            AND (symb_len <= sizeof (hkw))
        THEN
            BEGIN
            hkw := bsp_name;
            IF  g01unicode
            THEN
                FOR i := 1 TO symb_len DO
                    hkw [i] := a_cmd_part^.sp1p_buf [sc_sypos + (i*2) - 1]
                (*ENDFOR*) 
            ELSE
                SAPDB_PascalMove ('VAK01 ',   4,    
                      a_cmd_part^.sp1p_buf_len, sizeof (hkw),
                      @a_cmd_part^.sp1p_buf, sc_sypos,
                      @hkw, 1, symb_len,
                      a_returncode);
            (*ENDIF*) 
            IF  hkw[ 1 ] in [ 'A'..'I', 'J'..'R', 'S'..'Z' ]
            THEN
                BEGIN
                WITH a01_kw_control[ hkw[ 1 ] ] DO
                    BEGIN
                    i      := first_pos;
                    j      := last_pos;
                    END;
                (*ENDWITH*) 
                REPEAT
                    k := (i+j) DIV 2;
                    IF  (a01kw[ k ] >  hkw)
                    THEN
                        j := k - 1
                    ELSE
                        i := succ(k);
                    (*ENDIF*) 
                UNTIL
                    (i > j);
                (*ENDREPEAT*) 
                IF  (NOT (acv.a_sqlmode IN a01kw_sqlmode[ j ]))
                    AND
                    NOT(
                    (j = cak_i_unicode)             AND
                    (g01glob.db_is_for_sapr3 OR
                    (a_initial_segment_header.sp1c_producer = sp1pr_installation))
                    )
                    AND
                    NOT(
                    (j = cak_i_internal)            AND
                    (acv.a_sqlmode = sqlm_oracle)   AND
                    (a_initial_segment_header.sp1c_producer in
                    [sp1pr_internal_cmd, sp1pr_installation])
                    )
                THEN
                    IF  ((acv.a_comp_type <> at_odbc) AND (acv.a_comp_type <> at_jdbc))  OR
                        (acv.a_sqlmode <> sqlm_oracle) OR
                        NOT (j in [cak_i_acos, cak_i_asin, cak_i_atan,
                        cak_i_atan2, cak_i_ceiling, cak_i_cot, cak_i_degrees,
                        cak_i_log10, cak_i_pi, cak_i_radians, cak_i_lcase,
                        cak_i_left, cak_i_locate, cak_i_right, cak_i_space,
                        cak_i_substring, cak_i_ucase, cak_i_curdate,
                        cak_i_curtime, cak_i_dayname, cak_i_dayofmonth,
                        cak_i_dayofweek, cak_i_dayofyear,
                        cak_i_hour, cak_i_minute, cak_i_month,
                        cak_i_monthname, cak_i_now,
                        cak_i_second, cak_i_week ])
                    THEN
                        j := 0;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  j > 0
                THEN
                    IF  a01kw[ j ] = hkw
                    THEN
                        BEGIN
                        index := j;
                        reserved := ak01res_kw[ j, acv.a_sqlmode ];
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (index = cak_i_nls_numeric_chars) AND NOT extra
        THEN (* To prevent the abbreviation NLS_NUMERIC_CHARAC. *)
            BEGIN
            index    := 0;
            reserved := false
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&IFDEF TRACE
t01int4 (ak_syn, 'a01_kw.index', index);
&ENDIF
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_is_odbc_syntax (
            VAR acv      : tak_all_command_glob;
            VAR partype  : tak_odbc_partype;
            VAR functype : tak_odbc_functiontype);
 
CONST
      c_odbc_ext_initiator  = '{                 ';
      c_odbc_initiator      = '--(*              ';
      c_odbc_vendor         = 'VENDOR            ';
      c_odbc_product        = 'PRODUCT           ';
      c_odbc_escape         = 'ESCAPE            ';
      c_odbc_call           = 'CALL              ';
      c_odbc_fn             = 'FN                ';
      c_odbc_oj             = 'OJ                ';
      c_odbc_d              = 'D                 ';
      c_odbc_t              = 'T                 ';
      c_odbc_ts             = 'TS                ';
 
VAR
      symb_to_compare     : tak_keyword;
      save_scv            : tak_scanner_glob;
      help_scv            : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    save_scv := a_scv;
    partype  := no_odbc;
    functype := odbc_nothing;
    symb_to_compare := c_odbc_ext_initiator;
    IF  a_scv.sc_symb = s_unknown
    THEN
        a_scv.sc_symb := s_identifier;
    (*ENDIF*) 
    IF  a01_eqkey (symb_to_compare, a_sqlmode,
        a_cmd_part^.sp1p_buf, a_scv)
    THEN
        BEGIN
        partype := extended_odbc;
        a_scv.sc_symb := s_unknown
        END
    ELSE
        BEGIN
        help_scv := a_scv;
        a01_next_symbol (acv);
        a01_next_symbol (acv);
        a01_next_symbol (acv);
        help_scv.sc_sylength := sc_sypos - help_scv.sc_sypos +
              sc_sylength;
        help_scv.sc_symb := s_identifier;
        symb_to_compare := c_odbc_initiator;
        IF  a01_eqkey (symb_to_compare, a_sqlmode,
            a_cmd_part^.sp1p_buf, help_scv)
        THEN
            BEGIN
            a01_next_symbol (acv);
            symb_to_compare := c_odbc_vendor;
            IF  a01_eqkey (symb_to_compare, a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                BEGIN
                a01_next_symbol (acv);
                IF  sc_symb = s_leftpar
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    a01_next_symbol (acv);
                    IF  sc_symb = s_rightpar
                    THEN
                        BEGIN
                        a01_next_symbol (acv);
                        IF  sc_symb = s_comma
                        THEN
                            BEGIN
                            a01_next_symbol (acv);
                            symb_to_compare := c_odbc_product;
                            IF  a01_eqkey (symb_to_compare, a_sqlmode,
                                a_cmd_part^.sp1p_buf, a_scv)
                            THEN
                                BEGIN
                                a01_next_symbol (acv);
                                IF  sc_symb = s_leftpar
                                THEN
                                    BEGIN
                                    a01_next_symbol (acv);
                                    a01_next_symbol (acv);
                                    IF  sc_symb = s_rightpar
                                    THEN
                                        partype := normal_odbc;
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  partype = no_odbc
THEN
    acv.a_scv := save_scv
ELSE
    WITH acv, a_scv DO
        BEGIN
        save_scv := a_scv;
        a01_next_symbol (acv);
        IF  sc_symb = s_parameter_name
        THEN
            functype := odbc_dbfunc
        ELSE
            BEGIN
            symb_to_compare := c_odbc_call;
            IF  a01_eqkey (symb_to_compare, a_sqlmode,
                a_cmd_part^.sp1p_buf, a_scv)
            THEN
                functype := odbc_call
            ELSE
                BEGIN
                symb_to_compare := c_odbc_fn;
                IF  a01_eqkey (symb_to_compare, a_sqlmode,
                    a_cmd_part^.sp1p_buf, a_scv)
                THEN
                    functype := odbc_fn
                ELSE
                    BEGIN
                    symb_to_compare := c_odbc_d;
                    IF  a01_eqkey (symb_to_compare, a_sqlmode,
                        a_cmd_part^.sp1p_buf, a_scv)
                    THEN
                        functype := odbc_d
                    ELSE
                        BEGIN
                        symb_to_compare := c_odbc_t;
                        IF  a01_eqkey (symb_to_compare, a_sqlmode,
                            a_cmd_part^.sp1p_buf, a_scv)
                        THEN
                            functype := odbc_t
                        ELSE
                            BEGIN
                            symb_to_compare := c_odbc_ts;
                            IF  a01_eqkey (symb_to_compare, a_sqlmode,
                                a_cmd_part^.sp1p_buf, a_scv)
                            THEN
                                functype := odbc_ts
                            ELSE
                                BEGIN
                                symb_to_compare := c_odbc_oj;
                                IF  a01_eqkey (symb_to_compare, a_sqlmode,
                                    a_cmd_part^.sp1p_buf, a_scv)
                                THEN
                                    functype := odbc_oj
                                ELSE
                                    BEGIN
                                    symb_to_compare := c_odbc_escape;
                                    IF  a01_eqkey (symb_to_compare, a_sqlmode,
                                        a_cmd_part^.sp1p_buf, a_scv)
                                    THEN
                                        functype := odbc_esc;
                                    (*ENDIF*) 
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  functype = odbc_nothing
THEN
    acv.a_scv := save_scv;
&IFDEF TRACE
(*ENDIF*) 
t01int4 (ak_syn, 'PAR  TYPE   ', ord(partype));
t01int4 (ak_syn, 'FUNC TYPE   ', ord(functype));
&ENDIF
END;
 
(*------------------------------*) 
 
FUNCTION
      a01_odbc_end_ok (
            VAR acv : tak_all_command_glob;
            partype : tak_odbc_partype) : boolean;
 
CONST
      c_odbc_ext_terminator = '}                 ';
      c_odbc_terminator     = '*)--              ';
 
VAR
      ok                  : boolean;
      symb_to_compare     : tak_keyword;
      help_scv            : tak_scanner_glob;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    ok := false;
    IF  partype = extended_odbc
    THEN
        BEGIN
        symb_to_compare := c_odbc_ext_terminator;
        a_scv.sc_symb := s_identifier;
        IF  a01_eqkey (symb_to_compare, a_sqlmode,
            a_cmd_part^.sp1p_buf, a_scv)
        THEN
            ok := true;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        help_scv := a_scv;
        a01_next_symbol (acv);
        (* PTS 1113708 E.Z. *)
        sc_sypos  := sc_sypos  + a01char_size;
        sc_newpos := sc_newpos + a01char_size;
        (*a01_next_symbol (acv);*)
        a01_next_symbol (acv);
        IF  sc_symb <> s_eof
        THEN
            BEGIN
            help_scv.sc_sylength := sc_sypos - help_scv.sc_sypos +
                  sc_sylength;
            symb_to_compare := c_odbc_terminator;
            help_scv.sc_symb := s_identifier;
            IF  a01_eqkey (symb_to_compare , a_sqlmode,
                a_cmd_part^.sp1p_buf, help_scv)
            THEN
                ok := true;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
&   IFDEF TRACE
    t01int4 (ak_syn, 'odbc end ok ', ord(ok));
&   ENDIF
    a01_odbc_end_ok := ok;
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a01aligned_cmd_len (len : tsp00_Int4) : tsp00_Int4;
 
BEGIN
a01aligned_cmd_len := ((len + csp1_part_align_length - 1) DIV
      csp1_part_align_length) * csp1_part_align_length;
END;
 
(*------------------------------*) 
 
FUNCTION
      a01swap_int2 (old : tsp00_Int2) : tsp00_Int2;
 
VAR
      inew : tsp_int_map_c2;
      iold : tsp_int_map_c2;
 
BEGIN
iold.map_int    := old;
inew.map_c2 [1] := iold.map_c2 [2];
inew.map_c2 [2] := iold.map_c2 [1];
a01swap_int2    := inew.map_int
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01swap_cmd_part (
            client_swap  : tsp00_SwapKind;
            VAR cmd_part : tsp1_part_header);
 
BEGIN
WITH cmd_part DO
    BEGIN
    sp1p_arg_count   := a01swap_int2 (sp1p_arg_count);
    sp1p_segm_offset := s20buf_to_int4_swap (sp1p_segm_offset, 1
          ,                           g01code.kernel_swap, client_swap);
    sp1p_buf_len     := s20buf_to_int4_swap (sp1p_buf_len, 1
          ,                           g01code.kernel_swap, client_swap);
    sp1p_buf_size    := s20buf_to_int4_swap (sp1p_buf_size, 1
          ,                           g01code.kernel_swap, client_swap)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a01eqkw (
            VAR a     : tak_keyword;
            VAR b     : tsp00_MoveObj;
            b_pos     : tsp00_Int4;
            length    : integer) : boolean;
 
VAR
      equal : boolean;
      i     : integer;
 
BEGIN
IF  length > sizeof (a)
THEN
    equal := false
ELSE
    BEGIN
    i     := 1;
    equal := true;
    WHILE (i <= length) AND equal DO
        BEGIN
        equal := (a [i] = b [b_pos-1+i]);
        i     := i + 1
        END;
    (*ENDWHILE*) 
    IF  equal AND (i <= sizeof (a))
    THEN
        BEGIN
        IF  a [i] <> bsp_c1
        THEN
            equal := false
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
a01eqkw := equal;
END;
 
(*------------------------------*) 
 
FUNCTION
      a01mandatory_keyword (
            VAR acv          : tak_all_command_glob;
            required_keyword : integer) : boolean;
 
BEGIN
&ifdef trace
t01trace_kw(ak_syn, '            ', a01kw[required_keyword]);
&endif
IF  a01_eqkey (a01kw[required_keyword], acv.a_sqlmode,
    acv.a_cmd_part^.sp1p_buf, acv.a_scv)
THEN
    BEGIN
    a01mandatory_keyword := true;
    a01_next_symbol (acv)
    END
ELSE
    BEGIN
    a01mandatory_keyword := false;
    a07_kw_put_error (acv, e_wanted_keyword,
          acv.a_scv.sc_sypos, required_keyword)
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      a01_eqkey (
            VAR a      : tak_keyword;
            sqlmode    : tsp00_SqlMode;
            VAR b      : tsp00_MoveObj;
            VAR scv    : tak_scanner_glob) : boolean;
 
BEGIN
IF  scv.sc_symb <> s_identifier
THEN
    a01_eqkey := false
ELSE
    IF  (scv.sc_sylength = 0)     AND
        (sqlmode = sqlm_oracle)   AND
        (a = a01kw[ cak_i_null ])
    THEN
        a01_eqkey := true
    ELSE
        IF  g01unicode
        THEN
            a01_eqkey := a011uni_eqkey (a, b, scv.sc_sypos, scv.sc_sylength)
        ELSE
            a01_eqkey := a01eqkw (a, b, scv.sc_sypos, scv.sc_sylength);
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_get_password (
            VAR acv        : tak_all_command_glob;
            VAR put_node   : tsp00_Int2;
            VAR last_node  : tsp00_Int2);
 
VAR
      exit_loop : boolean;
 
BEGIN
IF  g01unicode
THEN
    a011u_get_pwd (acv, put_node, last_node)
ELSE
    WITH acv, a_scv DO
        IF  a_returncode = 0
        THEN
            BEGIN
            sc_sylength := 0;
&           ifdef trace
            t01int4 (ak_sem, 'sc_newpos   ', sc_newpos);
&           endif
            exit_loop := false;
            WHILE NOT exit_loop DO
                IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                THEN
                    exit_loop := true
                ELSE
                    (* PTS 1105437 GG *)
                    IF  a01is_whitespace_char( a_cmd_part^.sp1p_buf, sc_newpos )
                    THEN
                        sc_newpos := sc_newpos + 1
                    ELSE
                        exit_loop := true;
                    (*ENDIF*) 
                (*ENDIF*) 
            (*ENDWHILE*) 
            IF  sc_newpos > a_cmd_part^.sp1p_buf_len
            THEN
                BEGIN
                (* h.b. PTS 1000930 *)
                IF  a_is_ddl <> no_ddl
                THEN
                    a07_error (acv, e_missing_identifier,
                          put_node, last_node)
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  (a_cmd_part^.sp1p_buf[ sc_newpos ] = '"')
                THEN
                    BEGIN
                    a01_next_symbol (acv);
                    IF  sc_symb <> s_identifier
                    THEN
                        a07_error (acv, e_missing_identifier,
                              put_node, last_node)
                    ELSE
                        BEGIN
                        IF  sc_sylength > mxsp_name
                        THEN
                            a07_error (acv, e_identifier_too_long, put_node, last_node);
                        (*ENDIF*) 
                        a01_put_node (acv, last_node);
                        put_node := last_node
                        END
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    sc_sypos := sc_newpos;
                    IF  a_cmd_part^.sp1p_buf[ sc_newpos ] in
                        a01letter_dig_under[a_sqlmode]
                    THEN
                        BEGIN
                        exit_loop := false;
                        REPEAT
                            sc_newpos := sc_newpos + 1;
                            IF  sc_newpos > a_cmd_part^.sp1p_buf_len
                            THEN
                                exit_loop := true
                            ELSE
                                exit_loop :=
                                      NOT (a_cmd_part^.sp1p_buf[ sc_newpos ] in
                                      a01letter_dig_under[a_sqlmode]);
                            (*ENDIF*) 
                        UNTIL
                            exit_loop;
                        (*ENDREPEAT*) 
                        sc_symb     := s_identifier;
                        sc_sylength := sc_newpos - sc_sypos;
                        IF  sc_sylength > mxsp_name
                        THEN
                            a07_error (acv, e_identifier_too_long, put_node, last_node);
                        (* PTS 1121518 E.Z. *)
                        (*ENDIF*) 
                        s30map (g02codetables.tables[ cgg04_up_ascii ],
                              a_cmd_part^.sp1p_buf, sc_sypos,
                              a_cmd_part^.sp1p_buf, sc_sypos, sc_sylength);
                        a01_put_node (acv, last_node);
                        put_node := last_node
                        END
                    ELSE
                        a07_error (acv,
                              e_missing_identifier, put_node, last_node);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a01_character_set (
            VAR acv        : tak_all_command_glob;
            VAR put_node   : tsp00_Int2;
            VAR last_node  : tsp00_Int2);
 
VAR
      curr_n : tsp00_Int2;
 
BEGIN
WITH acv, a_scv DO
    BEGIN
    IF  sc_symb <> s_identifier
    THEN
        a07_b_put_error (acv, e_invalid_command, sc_sypos)
    ELSE
        BEGIN
        a02_put_identifier (acv, put_node, curr_n);
        IF  a_scv.sc_symb = s_point
        THEN
            BEGIN
            a01_next_symbol (acv);
            a02_put_identifier (acv,
                  a_ap_tree^[ put_node ].n_sa_level, curr_n);
            IF  a_returncode = 0
            THEN
                BEGIN
                a_ap_tree^[ put_node ].n_length :=
                      a_ap_tree^[ curr_n ].n_pos +
                      a_ap_tree^[ curr_n ].n_length -
                      a_ap_tree^[ put_node ].n_pos;
                a_ap_tree^[ put_node ].n_sa_level := 0;
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        last_node := put_node
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
