.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VAK09$
.tt 2 $$$
.TT 3 $ThomasA$AK_BD_procedure_interface$1999-03-17$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : AK_BD_procedure_interface
=========
.sp
Purpose :
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        PROCEDURE
              a09load_constraint_info (VAR acv : tak_all_command_glob;
                    last_constraint : boolean;
                    VAR and_cnt     : integer);
 
        PROCEDURE
              a09activate_lock (VAR t : tgg00_TransContext;
                    stack_addr : tgg00_StackListPtr;
                    stack_max  : tsp00_Int2;
                    VAR b_err  : tgg00_BasisError);
 
        PROCEDURE
              a09exec_load (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a09rollback (VAR acv : tak_all_command_glob;
                    VAR b_err : tgg00_BasisError);
 
        PROCEDURE
              a09unload (VAR acv : tak_all_command_glob);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              KB_restart_record : VKB57;
 
        PROCEDURE
              k57stamp_logged (
                    VAR trans_state : tgg00_TransState;
                    task_id         : tsp00_TaskId;
                    stamp_type      : tgg00_MessType2;
                    buffer          : tsp00_MoveObjPtr;
                    buf_len         : tsp00_Int4;
                    VAR b_err       : tgg00_BasisError);
&       ifdef trace
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01int4 (debug : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01messblock (debug : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01moveobj (layer : tgg00_Debug;
                    VAR moveobj : tbd_node;
                    startpos    : tsp00_Int4;
                    endpos      : tsp00_Int4);
 
        PROCEDURE
              t01basis_error (layer : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01treeid (debug : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
&       endif
 
      ------------------------------ 
 
        FROM
              Execute_Where_Part : VAK65;
 
        PROCEDURE
              a65_set_operator (VAR acv : tak_all_command_glob;
                    operator            : tgg00_StackOpType);
 
      ------------------------------ 
 
        FROM
              AK_Lock_Commit_Rollback : VAK52;
 
        PROCEDURE
              a52init_subtrans_of_new_trans (VAR acv : tak_all_command_glob);
 
      ------------------------------ 
 
        FROM
              DML_Help_Procedures : VAK54;
 
        PROCEDURE
              a54_internal_function (VAR acv : tak_all_command_glob;
                    VAR m : tgg00_MessBlock;
                    st_no : integer);
 
      ------------------------------ 
 
        FROM
              Systeminfo_cache : VAK10;
 
        PROCEDURE
              a10_cache_delete  (VAR acv : tak_all_command_glob;
                    is_rollback : boolean);
 
        PROCEDURE
              a10get_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10add_sysinfo (VAR acv : tak_all_command_glob;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
        PROCEDURE
              a10mblock_into_cache (VAR acv : tak_all_command_glob;
                    VAR syskey   : tgg00_SysInfoKey;
                    VAR mblock   : tgg00_MessBlock;
                    dstate       : tak_directory_state;
                    VAR syspoint : tak_sysbufferaddress;
                    VAR b_err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              AK_semantic_scanner_tools : VAK05;
 
        PROCEDURE
              a05qualification_test (VAR acv : tak_all_command_glob;
                    VAR m          : tgg00_MessBlock;
                    result_wanted  : boolean;
                    check_new_rec  : boolean;
                    error_pos      : integer;
                    VAR rec        : tgg00_Rec;
                    VAR result_buf : tsp00_Buf;
                    resultBufSize  : tsp00_Int4;
                    VAR result_len : integer);
 
      ------------------------------ 
 
        FROM
              AK_universal_semantic_tools : VAK06;
 
        PROCEDURE
              a06init_curr_retpart (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06finish_curr_retpart (VAR acv : tak_all_command_glob;
                    part_kind : tsp1_part_kind;
                    arg_count : tsp00_Int2);
 
        PROCEDURE
              a06rsend_mess_buf (VAR acv : tak_all_command_glob;
                    VAR mblock  : tgg00_MessBlock;
                    return_req  : boolean;
                    VAR b_err   : tgg00_BasisError);
 
        PROCEDURE
              a06inc_linkage (VAR linkage : tsp00_C2);
 
        PROCEDURE
              a06a_mblock_init (VAR acv : tak_all_command_glob;
                    mtype           : tgg00_MessType;
                    m2type          : tgg00_MessType2;
                    VAR tree        : tgg00_FileId);
 
        PROCEDURE
              a06remove_locked_state (VAR acv : tak_all_command_glob);
 
        PROCEDURE
              a06retpart_move (VAR acv : tak_all_command_glob;
                    moveobj_ptr : tsp00_MoveObjPtr;
                    move_len    : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK07;
 
        PROCEDURE
              a07_b_put_error (VAR acv : tak_all_command_glob;
                    b_err        : tgg00_BasisError;
                    err_code     : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              AK_error_handling : VAK071;
 
        FUNCTION
              a071_return_code (
                    b_err   : tgg00_BasisError;
                    sqlmode : tsp00_SqlMode) : tsp00_Int2;
 
      ------------------------------ 
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01defaultkey   : tgg00_SysInfoKey;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02add_record (VAR t : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR b          : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_7 : VBD07;
 
        PROCEDURE
              b07cadd_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR b       : tgg00_Rec);
 
        PROCEDURE
              b07cget_record (VAR t : tgg00_TransContext;
                    VAR file_id : tgg00_FileId;
                    VAR rk      : tgg00_Rec;
                    VAR b       : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_9 : VBD09;
 
        PROCEDURE
              bd09LoadTable (VAR t      : tgg00_TransContext;
                    VAR tree_id         : tgg00_FileId;
                    VAR rightmost_leaf  : tsp00_PageNo;
                    VAR check_leaf      : tsp00_PageNo;
                    VAR lobParentFileNo : tgg00_Surrogate;
                    load_buf_len        : tsp00_Int4;
                    VAR load_buf        : tsp00_MoveObj);
 
        PROCEDURE
              bd09UnloadTable (
                    VAR t           : tgg00_TransContext;
                    VAR tree_id     : tgg00_FileId;
                    VAR pno         : tsp00_PageNo;
                    VAR pno_x       : tsp00_PageNo;
                    ret_buf_size    : tsp00_Int4;
                    VAR ret_buf     : tsp00_MoveObj;
                    VAR ret_buf_len : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              BD_modify_table : VBD37;
 
        PROCEDURE
              b37_unload_rewrite_table (
                    VAR t           : tgg00_TransContext;
                    VAR treeid      : tgg00_FileId;
                    unload_info     : tgg03_unloadInfoPtr;
                    ret_buf_size    : tsp00_Int4;
                    VAR ret_buf     : tsp00_MoveObj;
                    VAR ret_buf_len : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01unicode       : boolean;
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04locate_col (VAR st : tgg00_StackEntry;
                    rec_buf        : tgg00_RecPtr;
                    VAR varcol_pos : tgg00_VarColPosList;
                    VAR col_pos    : integer;
                    VAR col_len    : integer);
 
        PROCEDURE
              g04short_col_tree_build (
                    VAR table_surrogate : tgg00_Surrogate (*ptocConst*);
                    VAR short_col_tree  : tgg00_FileId;
                    VAR b_err           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53rollback (VAR t : tgg00_TransContext;
                    MessType2    : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : char;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalUnicodeFill (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    obj_upb     : tsp00_Int4;
                    obj         : tsp00_MoveObjPtr;
                    obj_pos     : tsp00_Int4;
                    length      : tsp00_Int4;
                    fillchar    : tsp00_C2;
                    VAR e       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30lnr_defbyte (str : tgg00_RecPtr;
                    defbyte   : char;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GG_allocator_interface : VGG941;
 
        PROCEDURE
              gg941Deallocate(VAR TransContext : tgg00_TransContext;
                    VAR p : tgg03_unloadInfoPtr);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              b07cget_record;
 
              tgg00_Lkey tgg00_Rec
 
        FUNCTION
              s30lnr_defbyte;
 
              tsp00_MoveObjPtr tgg00_RecPtr
 
        PROCEDURE
              gg941Deallocate;
 
              tsp00_Addr tgg03_unloadInfoPtr
&             ifdef trace
 
        PROCEDURE
              t01moveobj;
 
              tsp00_MoveObj tbd_node
&             endif
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ThomasA
.sp
.cp 3
Created : 1979-06-07
.sp
.cp 3
.sp
.cp 3
Release :      Date : 1999-03-17
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
 
 
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_result_wanted    = true (* a05qualification_test *);
      c_check_new_rec    = true (* a05qualification_test *);
      c_no_error_pos     = 0    (* a05qualification_test *);
      c_is_rollback      = true;
 
TYPE
 
      t_bd_info = RECORD (* see tsp7_bdinfo *)
            CASE boolean OF
                true:
                    (bdi_FileId         : tgg00_FileId;
                    bdi_Pno             : tsp00_PageNo;
                    bdi_Pno_x           : tsp00_PageNo;
                    bdi_LobParentFileNo : tgg00_Surrogate);
                false: (* for a09unload *)
                    (tree1 : tgg00_FileId;
                    uinf   : tgg03_unloadInfoPtr);
                END;
            (*ENDCASE*) 
 
 
 
(*------------------------------*) 
 
PROCEDURE
      a09load_constraint_info (VAR acv : tak_all_command_glob;
            last_constraint : boolean;
            VAR and_cnt     : integer);
 
VAR
      b_err         : tgg00_BasisError;
      mess_buf_init : boolean;
      stack_cnt     : integer;
      loop_cnt      : integer;
      first_pos     : integer;
      i             : integer;
      move_len      : integer;
      mess_block_ptr: tak_sysbufferaddress;
      sysk          : tgg00_SysInfoKey;
 
BEGIN
WITH acv, a_mblock, a_ptr1^.sconstraint DO
    BEGIN
    mess_buf_init := and_cnt = csp_maxint2;
    loop_cnt      := 1;
    IF  coldrange
    THEN
        stack_cnt := cstack_cnt + 1
    ELSE
        stack_cnt := cstack_cnt;
    (*ENDIF*) 
    REPEAT
        IF  mb_qual^.mfirst_free + stack_cnt + and_cnt + 1 > mb_st_max
        THEN
            a07_b_put_error (acv, e_too_many_mb_stackentries, 1)
        ELSE
            IF  mb_data_len + a_ptr1^.b_sl - cvalue_pos + 1 > mb_data_size
            THEN
                a07_b_put_error (acv, e_too_many_mb_data, 1);
            (*ENDIF*) 
        (*ENDIF*) 
        IF  a_returncode = 0
        THEN
            BEGIN
            IF  loop_cnt > 1
            THEN
                BEGIN
                a_special_expr := true;
                FOR i := 1 TO and_cnt DO
                    a65_set_operator (acv, op_and);
                (*ENDFOR*) 
                FOR i := 1 TO mb_qual^.mqual_cnt DO
                    IF  (mb_st^ [i].etype = st_jump_false) AND
                        (mb_st^ [i].epos  = 0)
                    THEN
                        mb_st^ [i].epos := mb_qual^.mfirst_free - i;
                    (*ENDIF*) 
                (*ENDFOR*) 
                a_constraint_cnt := 1;
&               ifdef trace
                t01messblock (ak_sem, 'a_mblock    ', a_mblock);
&               endif
                END;
            (*ENDIF*) 
            IF  (a_returncode = 0) AND (loop_cnt = 1)
            THEN
                BEGIN
                WITH mb_qual^ DO
                    BEGIN
                    IF  mqual_pos = 0
                    THEN
                        mqual_pos := mfirst_free
                    ELSE
                        BEGIN
                        WITH mb_st^ [mfirst_free] DO
                            BEGIN
                            etype    := st_jump_false;
                            eop      := op_none;
                            epos     := 0;
                            elen_var := 0;
                            ecol_pos := 0;
                            END;
                        (*ENDWITH*) 
                        mfirst_free := mfirst_free + 1;
                        and_cnt     := and_cnt + 1
                        END;
                    (*ENDIF*) 
                    SAPDB_PascalMove ('VAK09 ',   1,    
                          sizeof (cstack), mb_st_size,
                          @cstack, (cstackstart - 1) * sizeof (tgg00_StackEntry) + 1, @mb_st^,
                          (mfirst_free - 1) * STACK_ENTRY_MXGG00 + 1,
                          cstack_cnt * sizeof (tgg00_StackEntry),
                          acv.a_returncode);
                    move_len    := a_ptr1^.b_sl  - cvalue_pos + 1;
                    SAPDB_PascalMove ('VAK09 ',   2,    
                          sizeof (a_ptr1^), mb_data_size, @a_ptr1^,
                          cvalue_pos, @mb_data^.mbp_buf, mb_data_len + 1,
                          move_len, acv.a_returncode);
                    first_pos := 0;
                    FOR i := mfirst_free TO mfirst_free + cstack_cnt - 1 DO
                        WITH mb_st^ [i] DO
                            IF  etype in [ st_value,
                                st_language, st_format,
                                st_date, st_time, st_timestamp,
                                (* PTS 1116176 E.Z. *)
                                st_utcdate,
                                (* PTS 1109925 E.Z. *)
                                st_utcdiff,
                                st_user, st_usergroup, st_current_schema, st_uid,
                                st_sysdba, st_localsysdba ]
                            THEN
                                BEGIN
                                IF  first_pos = 0
                                THEN
                                    first_pos := epos;
                                (*ENDIF*) 
                                epos := epos - first_pos +
                                      mb_data_len + 1;
                                IF  etype <> st_value
                                THEN
                                    a54_internal_function (acv,
                                          a_mblock, i);
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                        (*ENDWITH*) 
                    (*ENDFOR*) 
                    mfirst_free := mfirst_free + cstack_cnt;
                    IF  coldrange
                    THEN
                        BEGIN
                        WITH mb_st^ [mfirst_free] DO
                            BEGIN
                            etype    := st_truth;
                            epos     := cgg04_is_not_false;
                            elen_var := 0;
                            ecol_tab := cgg_zero_c2
                            END;
                        (*ENDWITH*) 
                        mfirst_free := mfirst_free + 1
                        END;
                    (*ENDIF*) 
                    mqual_cnt      := mfirst_free - 1;
                    mb_data_len    := mb_data_len + move_len
                    END
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        loop_cnt := loop_cnt + 1;
    UNTIL
        NOT (last_constraint) OR (loop_cnt > 2);
    (*ENDREPEAT*) 
    IF  last_constraint AND
        (a_returncode = 0)
    THEN
        BEGIN
        IF  a_mblock.mb_data_len = 0
        THEN (* just to make a05qualification_test happy *)
            a_mblock.mb_data_len := 1;
        (*ENDIF*) 
        sysk               := a_p_arr1.pbasep^.syskey;
        sysk.sentrytyp     := cak_emessblock;
        sysk.slinkage[ 2 ] := chr(1);
        a10mblock_into_cache (acv, sysk, a_mblock, d_release,
              mess_block_ptr, b_err);
        IF  b_err = e_ok
        THEN
            a10add_sysinfo (acv, mess_block_ptr, b_err);
        (*ENDIF*) 
        IF  b_err <> e_ok
        THEN
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak09restore_short_string (VAR acv : tak_all_command_glob;
            VAR tree  : tgg00_FileId;
            VAR error : boolean);
 
VAR
      i           : integer;
      string_pos  : integer;
      data_pos    : integer;
      rec_len     : integer;
      key_len     : integer;
      node_ptr    : tbd_nodeptr;
      string_id   : tgg00_FileId;
      rec_buf     : tgg00_Rec;
      key_buf     : tgg00_Rec;
      currIndex   : integer;
      maxRecIndex : integer;
      pRec        : tgg00_RecPtr;
 
BEGIN
WITH acv DO
    BEGIN
    string_id := tree;
    g04short_col_tree_build (tree.fileTabId_gg00, string_id,
          a_transinf.tri_trans.trError_gg00);
    IF  a_transinf.tri_trans.trError_gg00 = e_file_not_found
    THEN (* only LONGFILE columns exists *)
        a_transinf.tri_trans.trError_gg00 := e_ok
    ELSE
        BEGIN
        IF  a_transinf.tri_trans.trError_gg00 <> e_ok
        THEN
            a07_b_put_error (acv,
                  a_transinf.tri_trans.trError_gg00, 1);
        (*ENDIF*) 
        string_id.fileBdUse_gg00   := [ ];
        data_pos                   := 1;
        WHILE (data_pos <= a_data_length) AND
              (a_returncode = 0) DO
            BEGIN
            node_ptr := @a_data_ptr^[data_pos];
&           ifdef trace
            t01moveobj (ak_sem, node_ptr^, 1, sizeof(node_ptr^));
&           endif
            currIndex   := FIRST_REC_INDEX_BD00;
            maxRecIndex := node_ptr^.nd_record_cnt - 1;
            WHILE (currIndex <= maxRecIndex) AND
                  (a_returncode = 0) DO
                BEGIN
                pRec    := @node_ptr^.nd_body[
                      node_ptr^.nd_pointer_list[MAX_POINTERINDEX_BD00 - currIndex]];
                rec_len := pRec^.recLen_gg00;
                key_len := pRec^.recKeyLen_gg00;
                string_pos := 1 + cgg_rec_key_offset + key_len;
&               ifdef trace
                t01int4(ak_sem, 'rec_len     ', rec_len);
                t01int4(ak_sem, 'key_len     ', key_len);
                t01int4(ak_sem, 'string_pos  ', string_pos);
&               endif
                i := 1;
                WHILE (i <= a_restore_with_string) AND
                      (a_returncode = 0) DO
                    BEGIN
                    IF  pRec^.recBuf_gg00[string_pos] <> csp_undef_byte
                    THEN
                        BEGIN
                        key_buf.len    := cgg04_str_col_entry_size;
                        key_buf.keylen := cgg04_str_col_entry_size;
                        SAPDB_PascalMove ('VAK09 ',   3,    
                              sizeof (pRec^.recBuf_gg00), sizeof (key_buf),
                              @pRec^.recBuf_gg00, string_pos + 1, @key_buf,
                              cgg_rec_key_offset+1, cgg04_str_col_entry_size,
                              acv.a_returncode);
                        b07cget_record (a_transinf.tri_trans,
                              a_into_tree, key_buf, rec_buf);
                        IF  a_transinf.tri_trans.trError_gg00 = e_ok
                        THEN
                            BEGIN
                            a_mblock.mb_type  := m_stamp;
                            a_mblock.mb_type2 := mm_key;
                            k57stamp_logged (
                                  a_mblock.mb_trns^.trState_gg00,
                                  a_mblock.mb_trns^.trTaskId_gg00,
                                  mm_key,
                                  @rec_buf.recKey_gg00.keyVal_gg00,
                                  sizeof(rec_buf) - cgg_rec_key_offset - 1,
                                  a_transinf.tri_trans.trError_gg00);
                            SAPDB_PascalMove ('VAK09 ',   4,    
                                  sizeof(rec_buf),
                                  sizeof (rec_buf),
                                  @rec_buf, cgg_rec_key_offset + 1,
                                  @pRec^.recBuf_gg00, string_pos + 1,
                                  SURROGATE_MXGG00, acv.a_returncode);
                            b02add_record (a_transinf.tri_trans,
                                  string_id, rec_buf);
                            IF  a_transinf.tri_trans.trError_gg00 <> e_ok
                            THEN
                                a07_b_put_error (acv,
                                      a_transinf.tri_trans.trError_gg00, 1)
                            (*ENDIF*) 
                            END
                        ELSE
                            IF  a_transinf.tri_trans.trError_gg00 =
                                e_key_not_found
                            THEN
                                BEGIN
                                a_transinf.tri_trans.trError_gg00 := e_ok;
                                (* the old column ids are no longer valid;      *)
                                (* in the case of an aborted RESTORE sequence   *)
                                (* we must prevent them from being dropped      *)
                                pRec^.recBuf_gg00[string_pos] := csp_undef_byte
                                END
                            ELSE
                                a07_b_put_error (acv,
                                      a_transinf.tri_trans.trError_gg00, 1)
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    string_pos := string_pos + cgg04_str_col_entry_size + 1;
                    i          := i + 1
                    END;
                (*ENDWHILE*) 
                currIndex := currIndex + 1;
                END;
            (*ENDWHILE*) 
            data_pos := data_pos + sizeof (tbd_node)
            END;
        (*ENDWHILE*) 
        END;
    (*ENDIF*) 
    error := a_returncode <> 0
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak09verify_constraint (VAR acv : tak_all_command_glob;
            VAR tree  : tgg00_FileId;
            VAR error : boolean);
 
VAR
      b_err      : tgg00_BasisError;
      pos        : integer;
      res_len    : integer;
      data_pos   : integer;
      mblock_ptr : tak_sysbufferaddress;
      node_ptr   : tbd_nodeptr;
      ic2        : tsp_int_map_c2;
      sysk       : tgg00_SysInfoKey;
      rec_buf    : tgg00_Rec;
      res_buf    : tsp00_Buf;
      currIndex   : integer;
      maxRecIndex : integer;
      pRec        : tgg00_RecPtr;
 
BEGIN
WITH acv DO
    BEGIN
    sysk               := a01defaultkey;
    sysk.stableid      := tree.fileTabId_gg00;
    sysk.sentrytyp     := cak_emessblock;
    sysk.slinkage[2]   := chr(1);
    a10get_sysinfo (acv, sysk, d_release, mblock_ptr, b_err);
    IF  b_err <> e_ok
    THEN
        a07_b_put_error (acv, b_err, 1)
    ELSE
        WITH mblock_ptr^.smessblock DO
            BEGIN
            data_pos := 1;
            WHILE data_pos < a_data_length DO
                BEGIN
                node_ptr := @a_data_ptr^[data_pos];
                currIndex   := FIRST_REC_INDEX_BD00;
                maxRecIndex := node_ptr^.nd_record_cnt - 1;
                WHILE  currIndex <= maxRecIndex DO
                    BEGIN
                    pRec := @node_ptr^.nd_body[
                          node_ptr^.nd_pointer_list[MAX_POINTERINDEX_BD00 - currIndex]];
                    IF  pRec^.recLen_gg00 < 0
                    THEN
                        BEGIN
                        (* record is marked as valid *)
                        pRec^.recLen_gg00 := -pRec^.recLen_gg00;
                        END
                    ELSE
                        BEGIN
                        mbr_mess_block.mb_work_st      := a_work_st_addr;
                        mbr_mess_block.mb_work_st_max  := a_work_st_max;
                        mbr_mess_block.mb_workbuf      := a_work_buf_addr;
                        mbr_mess_block.mb_workbuf_size := a_work_buf_size;
                        a05qualification_test (acv, mbr_mess_block,
                              NOT c_result_wanted, NOT c_check_new_rec,
                              c_no_error_pos, pRec^, res_buf, sizeof(res_buf) (* PTS 1114565 *), res_len);
&                       ifdef trace
                        t01basis_error (ak_sem, 'basis_error ',
                              mbr_mess_block.mb_trns^.trError_gg00);
&                       endif
                        IF  mbr_mess_block.mb_trns^.trError_gg00 <> e_ok
                        THEN
                            BEGIN
                            a_transinf.tri_trans.trState_gg00 :=
                                  mbr_mess_block.mb_trns^.trState_gg00;
                            pRec^.recKeyLen_gg00 := -pRec^.recKeyLen_gg00;
                            error := true
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    currIndex := currIndex + 1
                    END;
                (*ENDWHILE*) 
                data_pos := data_pos + sizeof (tbd_node)
                END;
            (*ENDWHILE*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    error := error OR (a_returncode <> 0);
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      ak09verify_link (VAR acv : tak_all_command_glob;
            VAR tree  : tgg00_FileId;
            VAR error : boolean);
 
VAR
      key_check  : boolean;
      b_err      : tgg00_BasisError;
      col_pos    : integer;
      col_len    : integer;
      i          : integer;
      j          : integer;
      len        : integer;
      linkcnt    : integer;
      req_len    : integer;
      data_pos   : tsp00_Int4;
      rec_len     : integer;
      key_len     : integer;
      node_ptr   : tbd_nodeptr;
      sysk       : tgg00_SysInfoKey;
      varcol_pos : tgg00_VarColPosList;
      rec_buf    : tgg00_Rec;
      currIndex   : integer;
      maxRecIndex : integer;
      pRec        : tgg00_RecPtr;
&     ifdef trace
      pMoveObj    : tbd_nodeptr;
&     endif
 
LABEL
      999;
 
BEGIN
WITH acv DO
    BEGIN
    sysk           := a01defaultkey;
    sysk.stableid  := tree.fileTabId_gg00;
    sysk.sentrytyp := cak_elinkparsinfo;
    linkcnt := 0;
    REPEAT
        a10get_sysinfo (acv, sysk, d_release, a_ptr2, b_err);
        IF  b_err = e_ok
        THEN
            BEGIN
            IF  sysk.slinkage = cak_init_linkage
            THEN
                linkcnt := a_ptr2^.slinkparsinfo.lpcount;
            (*ENDIF*) 
            i   := 1;
            WHILE (i <= cak_maxlinkdef) AND (linkcnt > 0) DO
                BEGIN
                data_pos := 1;
                WHILE data_pos <= a_data_length DO
                    BEGIN
                    node_ptr := @a_data_ptr^[data_pos];
                    currIndex   := FIRST_REC_INDEX_BD00;
                    maxRecIndex := node_ptr^.nd_record_cnt - 1;
                    WHILE  currIndex <= maxRecIndex DO
                        BEGIN
                        b_err             := e_ok;
                        pRec  := @node_ptr^.nd_body[
                              node_ptr^.nd_pointer_list[MAX_POINTERINDEX_BD00 - currIndex]];
&                       ifdef trace
                        pMoveObj := @pRec^;
                        t01moveobj (ak_sem, pMoveObj^, 1, pRec^.recLen_gg00);
&                       endif
                        rec_len := pRec^.recLen_gg00;
                        key_len := pRec^.recKeyLen_gg00;
                        IF  rec_len < 0
                        THEN
                            BEGIN
                            (* record has already been check in   *)
                            (* the first round, no check required *)
                            pRec^.recLen_gg00 := -pRec^.recLen_gg00;
                            j                     := csp_maxint2;
                            key_check             := false
                            END
                        ELSE
                            IF  key_len > 0
                            THEN
                                BEGIN
                                j         := 1;
                                key_check := true
                                END
                            ELSE
                                BEGIN
                                (* curr record has already caused *)
                                (* an error ==> no check needed   *)
                                j         := csp_maxint2;
                                key_check := false
                                END;
                            (*ENDIF*) 
                        (*ENDIF*) 
                        (* construct foreign key from curr record *)
                        (* in a_mblock.mb_data                  *)
                        WITH a_ptr2^.slinkparsinfo.lpinfo[ i ],
                             a_mblock DO
                            BEGIN
                            len := cgg_rec_key_offset;
                            varcol_pos.vpl_last := -1;
                            WHILE j <= lpcolcount DO
                                BEGIN
                                g04locate_col (lpstack[j], pRec,
                                      varcol_pos, col_pos, col_len);
&                               ifdef trace
                                t01int4 (ak_sem, 'col_pos     ', col_pos);
                                t01int4 (ak_sem, 'col_len     ', col_len);
&                               endif
                                req_len := 0;
                                IF  pRec^.recBuf_gg00[col_pos] = csp_undef_byte
                                THEN
                                    BEGIN
                                    (* NULL value in key ==> no *)
                                    (* check in primary table   *)
                                    j         := lpcolcount;
                                    key_check := false
                                    END
                                ELSE
                                    BEGIN
                                    IF  j = lpcolcount
                                    THEN
                                        col_len := 1 +
                                              s30lnr_defbyte (pRec,
                                              pRec^.recBuf_gg00[col_pos],
                                              col_pos+1, col_len-1)
                                    ELSE
                                        req_len := lpstack[ j ].ecol_pos;
                                    (*ENDIF*) 
&                                   ifdef trace
                                    IF  j = lpcolcount
                                    THEN
                                        t01int4 (ak_sem, 'col_len     ', col_len)
                                    ELSE
                                        t01int4 (ak_sem, 'req_len     ', req_len);
                                    (*ENDIF*) 
&                                   endif
                                    SAPDB_PascalMove ('VAK09 ',   5,    
                                          sizeof (pRec^.recBuf_gg00),
                                          mb_data_size,
                                          @pRec^.recBuf_gg00, col_pos,
                                          @mb_data^.mbp_buf, len + 1,
                                          col_len, acv.a_returncode);
                                    IF  (j < lpcolcount) AND
                                        (col_len < req_len)
                                    THEN
                                        BEGIN
                                        IF  g01unicode AND
                                            (pRec^.recBuf_gg00[col_pos] =
                                            csp_unicode_def_byte)
                                        THEN
                                            SAPDB_PascalUnicodeFill ('VAK09 ',   6,    
                                                  mb_data_size,
                                                  @(mb_data^.mbp_buf),
                                                  len + col_len + 1,
                                                  req_len - col_len,
                                                  csp_unicode_blank,
                                                  acv.a_returncode)
                                        ELSE
                                            SAPDB_PascalFill ('VAK09 ',   7,    
                                                  mb_data_size,
                                                  @mb_data^.mbp_buf,
                                                  len + col_len + 1,
                                                  req_len - col_len,
                                                  pRec^.recBuf_gg00[col_pos],
                                                  acv.a_returncode);
                                        (*ENDIF*) 
                                        col_len := req_len
                                        END;
                                    (*ENDIF*) 
                                    len := len + col_len
                                    END;
                                (*ENDIF*) 
                                j := j + 1
                                END;
                            (*ENDWHILE*) 
                            IF  key_check AND NOT lp_one_to_one
                            THEN
                                BEGIN
                                mb_data^.mbp_keylen :=
                                      len - cgg_rec_key_offset;
                                b07cget_record (a_transinf.tri_trans,
                                      lpauxfile, mb_data^.mbp_rec, rec_buf);
                                IF  a_transinf.tri_trans.trError_gg00 = e_ok
                                THEN
                                    BEGIN
                                    key_check := false;
                                    IF  rec_buf.info[rec_buf.keylen+1] =
                                        chr ( ord(false))
                                    THEN
                                        b_err := e_key_not_found
                                    (*ENDIF*) 
                                    END
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  key_check
                            THEN
                                BEGIN
                                a06a_mblock_init (acv,
                                      m_get, mm_direct, lptreeid);
                                a_mblock.mb_data_len         := len;
                                a_mblock.mb_data^.mbp_keylen := len -
                                      cgg_rec_key_offset;
                                IF  NOT lp_one_to_one
                                THEN
                                    SAPDB_PascalForcedMove (a_mblock.mb_data_size,
                                          sizeof (rec_buf),
                                          @a_mblock.mb_data^.mbp_buf, 1,
                                          @rec_buf, 1, len);
                                (*ENDIF*) 
                                a06rsend_mess_buf (acv, a_mblock,
                                      cak_return_req, b_err);
                                IF  (b_err <> e_ok)                 AND
                                    (b_err <> e_key_not_found)      AND
                                    (b_err <> e_inv_list_not_found)
                                THEN
                                    BEGIN
                                    a07_b_put_error (acv, b_err, 1);
                                    (* abort all loops *)
                                    goto 999
                                    END
                                ELSE
                                    IF  NOT lp_one_to_one
                                    THEN
                                        BEGIN
                                        rec_buf.info[rec_buf.keylen + 1 ] :=
                                              chr(ord (b_err = e_ok));
                                        rec_buf.len :=
                                              cgg_rec_key_offset +
                                              rec_buf.keylen + 1;
                                        rec_buf.recVarcolOffset_gg00 := 1;
                                        rec_buf.recVarcolCnt_gg00    := 0;
                                        b07cadd_record (
                                              a_transinf.tri_trans,
                                              lpauxfile, rec_buf)
                                        END;
                                    (*ENDIF*) 
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  (b_err = e_key_not_found) OR
                                (b_err = e_inv_list_not_found)
                            THEN
                                BEGIN
                                pRec^.recLen_gg00 := -pRec^.recLen_gg00;
                                error := true;
                                IF  a_fk_check_cnt < 0
                                THEN
                                    BEGIN
                                    (* error occured in the course *)
                                    (* of restore table            *)
                                    a07_b_put_error (acv,
                                          e_link_rule_violation, 1);
                                    (* abort all loops *)
                                    goto 999
                                    END;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            currIndex := currIndex + 1
                            END;
                        (*ENDWITH*) 
                        END;
                    (*ENDWHILE*) 
                    data_pos  := data_pos + sizeof (tbd_node);
                    END;
                (*ENDWHILE*) 
                i       := i + 1;
                linkcnt := linkcnt - 1
                END;
            (*ENDWHILE*) 
            a06inc_linkage (sysk.slinkage)
            END
        ELSE
            a07_b_put_error (acv, b_err, 1)
        (*ENDIF*) 
    UNTIL
        (linkcnt <= 0) OR (a_returncode <> 0);
    (*ENDREPEAT*) 
    END;
(*ENDWITH*) 
999 : ;
END;
 
(*------------------------------*) 
 
PROCEDURE
      a09unload (VAR acv : tak_all_command_glob);
 
VAR
      bd_info_ptr : ^t_bd_info;
      bd_info     : t_bd_info;
 
BEGIN
WITH acv DO
    BEGIN
    bd_info_ptr := @a_cmd_part^.sp1p_buf[1];
    bd_info     := bd_info_ptr^;
    a06retpart_move (acv, @bd_info, sizeof (bd_info));
    bd_info_ptr := @acv.a_return_segm^.sp1p_buf;
    a06finish_curr_retpart (acv, sp1pk_bdinfo, 1);
    a06init_curr_retpart (acv);
    IF  a_returncode = 0
    THEN
        WITH a_curr_retpart^, bd_info_ptr^ DO
            BEGIN
            IF  bdi_FileId.fileTfn_gg00 = tfnTable_egg00
            THEN
                BEGIN
                (* bd_info_ptr contains pointer to tgg03_unloadInfo structure *)
                IF  uinf <> NIL
                THEN
                    BEGIN
                    IF  uinf^.ui_do_mapping
                    THEN
                        b37_unload_rewrite_table (a_transinf.tri_trans,
                              bdi_FileId, uinf,
                              sp1p_buf_size, sp1p_buf, sp1p_buf_len)
                    ELSE
                        bd09UnloadTable (a_transinf.tri_trans, bdi_FileId,
                              uinf^.ui_src_pageno,
                              uinf^.ui_src_pageno, sp1p_buf_size,
                              sp1p_buf, sp1p_buf_len);
                    (*ENDIF*) 
                    IF  a_transinf.tri_trans.trError_gg00 = e_no_next_record
                    THEN
                        BEGIN
                        gg941Deallocate(a_transinf.tri_trans,
                              uinf);
                        uinf := NIL;
                        END;
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE (* short column or column file *)
                bd09UnloadTable (a_transinf.tri_trans, bdi_FileId,
                      bdi_Pno, bdi_Pno_x, sp1p_buf_size,
                      sp1p_buf, sp1p_buf_len);
            (*ENDIF*) 
            IF  a_transinf.tri_trans.trError_gg00 <> e_ok
            THEN
                IF  a_transinf.tri_trans.trError_gg00 <> e_no_next_record
                THEN
                    a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        a06finish_curr_retpart (acv, sp1pk_page,
              a_curr_retpart^.sp1p_buf_len DIV mxsp_buf)
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a09exec_load (VAR acv : tak_all_command_glob);
 
VAR
      error           : boolean;
      bdInfoLength    : tsp00_Int4;
      lobParentFileNo : tgg00_Surrogate;
      bd_info_ptr     : ^t_bd_info;
      bd_info         : t_bd_info;
 
BEGIN
bd_info_ptr  := @acv.a_cmd_part^.sp1p_buf;
bd_info      := bd_info_ptr^;
bdInfoLength := acv.a_cmd_part^.sp1p_part_header.sp1p_buf_len;
WITH acv, bd_info DO
    BEGIN
&   ifdef trace
    t01int4 (ak_sem,   'data_length ', acv.a_data_length);
    t01int4 (ak_sem,   'pno         ', bd_info.bdi_Pno);
    t01int4 (ak_sem,   'pno_x       ', bd_info.bdi_Pno_x);
    t01treeid (ak_sem, 'fileId      ', bd_info.bdi_FileId);
    IF  bdInfoLength = sizeof(t_bd_info)
    THEN
        t01surrogate (ak_sem, 'LOB ParentID', bd_info.bdi_LobParentFileNo);
&   endif
    (*ENDIF*) 
    error := false;
    IF  bdi_FileId.fileTfn_gg00 = tfnTable_egg00
    THEN
        BEGIN
        IF  (a_constraint_cnt > 0) AND
            (a_returncode = 0)
        THEN
            ak09verify_constraint (acv, bdi_FileId, error);
        (*ENDIF*) 
        IF  (a_fk_check_cnt <> 0) AND
            (a_returncode = 0)
        THEN
            ak09verify_link (acv, bdi_FileId, error);
        (*ENDIF*) 
        IF  (a_restore_with_string > 0) AND
            (a_returncode = 0)
        THEN
            ak09restore_short_string (acv, bdi_FileId, error)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  a_returncode = 0
    THEN
        IF  NOT error
        THEN
            BEGIN
            IF  a_transinf.tri_trans.trError_gg00 = e_ok
            THEN
                BEGIN
                error                         := false;
                bdi_FileId.fileRootCheck_gg00 := ROOT_CHECK_GG00;
                IF  bdInfoLength = sizeof(t_bd_info)
                THEN
                    lobParentFileNo := bdi_LobParentFileNo
                ELSE
                    lobParentFileNo := cgg_zero_id;
                (*ENDIF*) 
                bd09LoadTable (a_transinf.tri_trans, bdi_FileId, bdi_Pno, bdi_Pno_x,
                      lobParentFileNo, a_data_length, a_data_ptr^);
                END;
            (*ENDIF*) 
            IF  a_transinf.tri_trans.trError_gg00 <> e_ok
            THEN
                a07_b_put_error (acv, a_transinf.tri_trans.trError_gg00, 1)
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            a06retpart_move        (acv, @a_data_ptr^, a_data_length);
            a06finish_curr_retpart (acv, sp1pk_page,
                  a_data_length DIV sizeof (tsp00_Buf));
            a_returncode :=
                  a071_return_code (e_range_violation, a_sqlmode)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  a_returncode <> 0
    THEN
        IF  a_returncode <>
            a071_return_code (e_range_violation, a_sqlmode)
        THEN
            a_rollback_info := [ trans_rollback, new_trans ];
        (*ENDIF*) 
    (*ENDIF*) 
    a_errorpos := 0
    END;
(*ENDWITH*) 
a06retpart_move (acv, @bd_info, sizeof (bd_info));
a06finish_curr_retpart (acv, sp1pk_bdinfo, 1);
END;
 
(*------------------------------*) 
 
PROCEDURE
      a09activate_lock (VAR t : tgg00_TransContext;
            stack_addr : tgg00_StackListPtr;
            stack_max  : tsp00_Int2;
            VAR b_err  : tgg00_BasisError);
 
BEGIN
t.trError_gg00 := e_ok;
b_err          := e_ok;
IF  t.trError_gg00 = e_rollback_wanted
THEN
    k53rollback (t, mm_nil);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      a09rollback (VAR acv : tak_all_command_glob;
            VAR b_err : tgg00_BasisError);
 
BEGIN
WITH acv, a_transinf, tri_trans DO
    BEGIN
    IF  trans_rollback in a_rollback_info
    THEN
        BEGIN
        k53rollback (tri_trans, mm_nil);
        b_err := tri_trans.trError_gg00;
        a10_cache_delete (acv, NOT c_is_rollback)
        END;
    (*ENDIF*) 
    a52init_subtrans_of_new_trans (acv);
    a06remove_locked_state (acv)
    END;
(*ENDWITH*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
