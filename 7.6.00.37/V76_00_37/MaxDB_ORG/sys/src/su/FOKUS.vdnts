file xinitdbk !
file connect ( kern test sqlmode oracle !
create table mitarbeiter (
   ma_id        number (3) not null primary key,
   name         char (30)  not null,
   soll_stunden number (3) not null)!
insert into mitarbeiter values (1, 'Ladewig', 40)!
insert into mitarbeiter values (2, 'Schweiberger', 40)!
insert into mitarbeiter values (3, 'Crossley', 20)!
insert into mitarbeiter values (4, 'Ellis', 20)!
create table projekt (
   projektid   number(3) not null primary key,
   its_name  char(30) not null)!
insert into projekt values (1, 'Beratung IT Verlag')!
insert into projekt values (2, 'Loesung SQL Reatsel')!
insert into projekt values (3, 'Uebersetzung/Dokumentation')!
insert into projekt values (4, 'Vernetzung IT Verlag')!
create table projekt_zuordnung (
   ma_id                number (3) not null references mitarbeiter,
   projektid           number (3) not null references projekt,
   zeit_anteil_prozent  number (3),
        primary key (ma_id, projektid))!
insert into projekt_zuordnung values (1, 1, 50)!
insert into projekt_zuordnung values (1, 2, 50)!
insert into projekt_zuordnung values (2, 1, 30)!
insert into projekt_zuordnung values (2, 2, 60)!
insert into projekt_zuordnung values (2, 3, 10)!
insert into projekt_zuordnung values (3, 2, 10)!
insert into projekt_zuordnung values (3, 3, 90)!
create table projzeit (
   ma_id       number (3) not null,
   projektid  number(3) not null,
   datum       date not null,
   woche       number (4) not null,
   stunden     number (2) not null,
        primary key (ma_id, projektid, datum),
        foreign key (ma_id, projektid) references projekt_zuordnung)!
insert into projzeit values (1, 1, '21-JUN-93', 9325, 8)!
insert into projzeit values (1, 1, '22-JUN-93', 9325, 8)!
insert into projzeit values (1, 2, '23-JUN-93', 9325, 8)!
insert into projzeit values (1, 2, '24-JUN-93', 9325, 8)!
insert into projzeit values (1, 2, '25-JUN-93', 9325, 8)!
insert into projzeit values (2, 1, '21-JUN-93', 9325, 8)!
insert into projzeit values (2, 1, '22-JUN-93', 9325, 8)!
insert into projzeit values (2, 2, '23-JUN-93', 9325, 8)!
insert into projzeit values (2, 2, '24-JUN-93', 9325, 8)!
insert into projzeit values (2, 2, '25-JUN-93', 9325, 8)!
insert into projzeit values (3, 2, '21-JUN-93', 9325, 4)!
insert into projzeit values (3, 3, '21-JUN-93', 9325, 4)!
insert into projzeit values (3, 3, '22-JUN-93', 9325, 8)!
insert into projzeit values (3, 3, '23-JUN-93', 9325, 8)!
insert into projzeit values (3, 3, '24-JUN-93', 9325, 8)!
insert into projzeit values (3, 3, '25-JUN-93', 9325, 8)!
commit work !
select mitarbeiter.name,
       projekt.its_name
  from mitarbeiter, projekt_zuordnung, projekt
 where mitarbeiter.ma_id = projekt_zuordnung.ma_id
   and projekt_zuordnung.projektid = projekt.projektid
 and (mitarbeiter.soll_stunden * projekt_zuordnung.zeit_anteil_prozent)
        / 100
     > (select nvl(sum(projzeit.stunden), 0)
          from projzeit
         where projzeit.ma_id = mitarbeiter.ma_id
           and projzeit.projektid = projekt.projektid
           and woche = 9325)!
fetch into :ma, :pr !
commit release !
file connect ( kern test  !
declare r_pro cursor for
SELECT a.ma_id, a.projektid, FIXED ( ((a.absh/soll_stunden)*100), 3, 1) relh 
       FROM mitarbeiter m,
            ( SELECT ma_id, projektid, SUM(stunden) absh
                     FROM projzeit GROUP BY ma_id, projektid ) a
       WHERE a.ma_id = m.ma_id
 UNION
SELECT ma_id, projektid, 0
       FROM projekt_zuordnung zu
       WHERE NOT EXISTS ( SELECT * FROM projzeit ze WHERE
                                 (zu.ma_id      = ze.ma_id) AND
                                 (zu.projektid = ze.projektid)) !
FETCH r_pro !
select soll.ma_id, soll.name, its_name, soll, geleistet
    FROM
    (select fixed (sum (stunden), 5,2) geleistet, ma_id, projektid
       from projzeit
       group by ma_id, projektid
     union
     select 0, ma_id, projektid from projekt_zuordnung where
        chr (ma_id) || chr (projektid) NOT IN
          (select chr(ma_id) || chr (projektid) from projzeit)
    ) geleistet,
    (SELECT A.MA_ID, A.NAME, B.projektid, its_name,
       FIXED (SOLL_STUNDEN / 100 * ZEIT_ANTEIL_PROZENT, 5, 2) soll
                    FROM MITARBEITER A,
                    PROJEKT_ZUORDNUNG B,
                    PROJEKT WHERE A.MA_ID = B.MA_ID AND
                    B.projektid = PROJEKT.projektid) soll
where 
soll.ma_id      = geleistet.ma_id      and
soll.projektid = geleistet.projektid and
soll > geleistet !
fetch !

select soll.ma_id, soll.name, its_name, soll, geleistet
    FROM
    (SELECT A.MA_ID, A.NAME, B.projektid, its_name,
       FIXED (SOLL_STUNDEN / 100 * ZEIT_ANTEIL_PROZENT, 5, 2) soll
                    FROM MITARBEITER A,
                    PROJEKT_ZUORDNUNG B,
                    PROJEKT WHERE A.MA_ID = B.MA_ID AND
                    B.projektid = PROJEKT.projektid) soll,
    (select fixed (sum (stunden), 5,2) geleistet, ma_id, projektid
       from projzeit
       group by ma_id, projektid
     union
     select 0, ma_id, projektid from projekt_zuordnung where
        chr (ma_id) || chr (projektid) NOT IN
          (select chr(ma_id) || chr (projektid) from projzeit)
    ) geleistet
where 
soll.ma_id      = geleistet.ma_id      and
soll.projektid = geleistet.projektid and
soll > geleistet !
fetch!

select soll.ma_id, soll.name, its_name, soll, geleistet
    FROM
    (SELECT A.MA_ID, A.NAME, B.projektid, its_name,
       FIXED (SOLL_STUNDEN / 100 * ZEIT_ANTEIL_PROZENT, 5, 2) soll 
                    FROM MITARBEITER A,
                    PROJEKT_ZUORDNUNG B,
                    PROJEKT WHERE A.MA_ID = B.MA_ID AND
                    B.projektid = PROJEKT.projektid) soll,
    (select fixed (sum (stunden), 5,2) geleistet , ma_id, projektid
       from projzeit
       group by ma_id, projektid
     union
     select 0, ma_id, projektid from projekt_zuordnung where
        chr (ma_id) || chr (projektid) NOT IN
          (select chr(ma_id) || chr (projektid) from projzeit)
    ) geleistet
where 
soll.ma_id      = geleistet.ma_id      and
soll.projektid = geleistet.projektid and
soll > geleistet !
fetch !

drop table mitarbeiter !
drop table projekt !
drop table projekt_zuordnung!
drop table projzeit!
COMMIT RELEASE !
file connect ( kern test !
create table tahef 
           (ejj char(2), 
            aus fixed(5), 
            obj fixed(5),
            emm char(2), 
            jjj fixed(5), 
            hhh fixed(5)) !
create table taagn 
           (agn fixed(10), 
            vbe fixed(5), 
            tx1 char(30))!
create table tawer 
           (kdn fixed(10), 
            prn fixed(10), 
            ant fixed(11), 
            vol fixed(5), 
            aus fixed(5), 
            obj fixed(5), 
            agn fixed(10), 
            jjj fixed(5),  
            hhh fixed(5))!
create table takp1 
           (brh fixed(5), 
            bru fixed(5), 
            prn fixed(10),
            kdn fixed(10))!

commit work!
SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn , a.vbe , k.vbe , p.brh ,
       p.bru , s.ant , s.vol  
 FROM tahef  h , tawer  s , taagn  k , taagn  a , takp1  p  
UNION ALL SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn ,     99 , 
  k.vbe , p.brh , p.bru , s.ant , s.vol  
 FROM tahef  h , tawer  s , taagn  k , takp1  p  
 WHERE  NOT  EXISTS  
   (SELECT  *  FROM taagn  a  WHERE a.agn  = s.agn )  
UNION ALL SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn , a.vbe , 
 k.vbe ,   9999 ,     99 , s.ant , s.vol  FROM tahef  h , tawer  s , 
 taagn  k , taagn  a  
 WHERE  NOT  EXISTS  
  (SELECT  *  FROM takp1  p  
  WHERE p.kdn  = s.kdn  AND p.prn  = s.prn )
   UNION ALL SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn ,     99 , 
   k.vbe ,   9999 ,     99 , s.ant , s.vol  
   FROM tahef  h , tawer  s , taagn  k  WHERE NOT  EXISTS  
  (SELECT  *  FROM taagn  a  WHERE a.agn  = s.agn )  AND  NOT  EXISTS 
  (SELECT  *  FROM takp1  p  WHERE p.kdn  = s.kdn  AND p.prn  = s.prn )
  ORDER BY      4 ,      5 !

SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn , a.vbe , k.vbe , p.brh ,
       p.bru , s.ant , s.vol  
 FROM tahef  h , tawer  s , taagn  k , taagn  a , takp1  p  
 WHERE  (h.obj  =      4 )  AND  (h.ejj  = '92' )  AND  (h.emm  = '01' )
  AND  (k.vbe  =      2 )  AND  (k.agn  = s.kdn )  AND  (s.obj  = h.obj )
  AND  (s.aus  = h.aus )  AND  (s.jjj  = h.jjj )  AND  (s.hhh  = h.hhh ) 
  AND  (k.agn  = s.kdn )  AND  (a.agn  = s.agn )  AND  (p.prn  = s.prn ) 
  AND  (p.kdn  = s.kdn )  
UNION ALL SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn ,     99 , 
  k.vbe , p.brh , p.bru , s.ant , s.vol  
 FROM tahef  h , tawer  s , taagn  k , takp1  p  
 WHERE  (h.obj  =    4 )
  AND  (h.ejj  = '92' )  AND  (h.emm  = '01' )  AND  (k.vbe  =      2 )  
  AND  (k.agn  = s.kdn )  AND  (s.obj  = h.obj )  AND  (s.aus  = h.aus ) 
  AND  (s.jjj  = h.jjj )  AND  (s.hhh  = h.hhh )  AND  (p.prn  = s.prn ) 
  AND  (p.kdn  = s.kdn )  AND  NOT  EXISTS  
   (SELECT  *  FROM taagn  a  WHERE a.agn  = s.agn )  
UNION ALL SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn , a.vbe , 
 k.vbe ,   9999 ,     99 , s.ant , s.vol  FROM tahef  h , tawer  s , 
 taagn  k , taagn  a  
 WHERE  (h.obj  =      4 )  AND  (h.ejj  = '92' )
  AND  (h.emm  = '01' )  AND  (k.vbe  =      2 )  AND  (k.agn  = s.kdn ) 
  AND  (s.obj  = h.obj )  AND  (s.aus  = h.aus )  AND  (s.jjj  = h.jjj ) 
  AND  (s.hhh  = h.hhh )  AND  (a.agn  = s.agn )  AND  NOT  EXISTS  
  (SELECT  *  FROM takp1  p  
  WHERE p.kdn  = s.kdn  AND p.prn  = s.prn )
   UNION ALL SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn ,     99 , 
   k.vbe ,   9999 ,     99 , s.ant , s.vol  
   FROM tahef  h , tawer  s , taagn  k  WHERE  (h.obj  =      4 )  
  AND  (h.ejj  = '92' )  AND  (h.emm  = '01' )  AND  (k.vbe  =      2 )
  AND  (k.agn  = s.kdn )  AND  (s.obj  = h.obj )  AND  (s.aus  = h.aus )
  AND  (s.jjj  = h.jjj )  AND  (s.hhh  = h.hhh )  AND  NOT  EXISTS  
  (SELECT  *  FROM taagn  a  WHERE a.agn  = s.agn )  AND  NOT  EXISTS 
  (SELECT  *  FROM takp1  p  WHERE p.kdn  = s.kdn  AND p.prn  = s.prn )
  ORDER BY      4 ,      5 !



SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn , a.vbe , k.vbe , p.brh ,
       p.bru , s.ant , s.vol  
 FROM tahef  h , tawer  s , taagn  k , taagn  a , takp1  p  
 WHERE  (h.obj  =      4 )  AND  (h.ejj  = '92' )  AND  (h.emm  = '01' )
  AND  (k.vbe  =      2 )  AND  (k.agn  = s.kdn )  AND  (s.obj  = h.obj )
  AND  (s.aus  = h.aus )  AND  (s.jjj  = h.jjj )  AND  (s.hhh  = h.hhh ) 
  AND  (k.agn  = s.kdn )  AND  (a.agn  = s.agn )  AND  (p.prn  = s.prn ) 
  AND  (p.kdn  = s.kdn )  
UNION ALL SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn ,     99 , 
  k.vbe , p.brh , p.bru , s.ant , s.vol  
 FROM tahef  h , tawer  s , taagn  k , takp1  p  
 WHERE  (h.obj  =    4 )
  AND  (h.ejj  = '92' )  AND  (h.emm  = '01' )  AND  (k.vbe  =      2 )  
  AND  (k.agn  = s.kdn )  AND  (s.obj  = h.obj )  AND  (s.aus  = h.aus ) 
  AND  (s.jjj  = h.jjj )  AND  (s.hhh  = h.hhh )  AND  (p.prn  = s.prn ) 
  AND  (p.kdn  = s.kdn )  AND  NOT  EXISTS  
   (SELECT  *  FROM taagn  a  WHERE a.agn  = s.agn )  
UNION ALL SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn , a.vbe , 
 k.vbe ,   9999 ,     99 , s.ant , s.vol  FROM tahef  h , tawer  s , 
 taagn  k , taagn  a  
 WHERE  (h.obj  =      4 )  AND  (h.ejj  = '92' )
  AND  (h.emm  = '01' )  AND  (k.vbe  =      2 )  AND  (k.agn  = s.kdn ) 
  AND  (s.obj  = h.obj )  AND  (s.aus  = h.aus )  AND  (s.jjj  = h.jjj ) 
  AND  (s.hhh  = h.hhh )  AND  (a.agn  = s.agn )  AND  NOT  EXISTS  
  (SELECT  *  FROM takp1  p  
  WHERE p.kdn  = s.kdn  AND p.prn  = s.prn )
   UNION ALL SELECT h.ejj , h.aus , h.obj , s.kdn , s.prn ,     99 , 
   k.vbe ,   9999 ,     99 , s.ant , s.vol  
   FROM tahef  h , tawer  s , taagn  k  WHERE  (h.obj  =      4 )  
  AND  (h.ejj  = '92' )  AND  (h.emm  = '01' )  AND  (k.vbe  =      2 )
  AND  (k.agn  = s.kdn )  AND  (s.obj  = h.obj )  AND  (s.aus  = h.aus )
  AND  (s.jjj  = h.jjj )  AND  (s.hhh  = h.hhh )  AND  NOT  EXISTS  
  (SELECT  *  FROM taagn  a  WHERE a.agn  = s.agn )  AND  NOT  EXISTS 
  (SELECT  *  FROM takp1  p  WHERE p.kdn  = s.kdn  AND p.prn  = s.prn )
  ORDER BY      4 ,      5 !
drop table tahef  !
drop table taagn  !
drop table tawer  !
drop table takp1  !
COMMIT RELEASE !
* Heft 1/2 1994 !
file connect ( kern test !
create table fluege
 (flug_nr       fixed(3) key,
  ges_plaetze   fixed(3) not null,
  verf_plaetze  fixed(3) not null)!
insert into fluege values (1, 200, 5)!  
insert into fluege values (2, 300, 3)!  
insert into fluege values (3, 450, 4)!  
create table buchungen
 (id      fixed (5) key,
  flug_nr fixed(3) not null references fluege,
  name    char (20) not null)!
insert into buchungen values ( 3, 3, 'Albrecht')!
insert into buchungen values (10, 1, 'Baader')!
insert into buchungen values (11, 1, 'Chall')!
insert into buchungen values ( 4, 1, 'Hansen')!
insert into buchungen values ( 1, 1, 'Jonas')!
insert into buchungen values ( 6, 3, 'Kauffmann')!
insert into buchungen values ( 7, 2, 'Lindemann')!
insert into buchungen values ( 8, 1, 'Linke')!
insert into buchungen values ( 2, 2, 'Medinger')!
insert into buchungen values ( 5, 2, 'Weiss')!
insert into buchungen values ( 9, 2, 'Weyhausen')!
select a.flug_nr, a.name
  from buchungen a, fluege
 where a.flug_nr = fluege.flug_nr 
   and verf_plaetze >=
           (select count(*) 
              from buchungen
             where buchungen.id <= a.id
               and buchungen.flug_nr = a.flug_nr) 
 order by a.flug_nr, id !
fetch !
drop table fluege !
drop table buchungen !
commit work release !
* Heft 11/12 1993 !
file connect ( kern test !
create table rechnungen (renr fixed (4) key,
                         kdnr fixed (4) not null,
                       betrag fixed(9,2) not null)!
insert into rechnungen values (1, 1, 1000)!
insert into rechnungen values (2, 2, 1000)!
insert into rechnungen values (3, 3, 1000)!
insert into rechnungen values (4, 4, 1000)!
insert into rechnungen values (5, 2, 2000)!
insert into rechnungen values (6, 1, 3000)!
insert into rechnungen values (7, 2, 1000)!
select a.kdnr, a.renr, a.betrag betrag,
       a.betrag / sum (b.betrag) * 100 prozent
from rechnungen a, rechnungen b
group by a.kdnr, a.renr, a.betrag !
fetch !
select a.kdnr,
       float(sum (a.betrag) / count (distinct b.renr),18) betrag,
       float(sum (a.betrag) / count (distinct b.renr) /
      (sum (b.betrag) / count (distinct a.renr)) * 100,18) prozent
from rechnungen a, rechnungen b
group by a.kdnr !
fetch!
select a.kdnr,
       float(sum (a.betrag), 18),
       float(sum (a.betrag) / b.sumbetrag * 100, 18) prozent
from rechnungen a,
     (select sum (betrag) sumbetrag
      from rechnungen) b
group by a.kdnr !
fetch!
select a.kdnr,
       float(sum (a.betrag), 18),
       float(sum (a.betrag) / sum(b.sumbetrag) * 100, 18) prozent
from rechnungen a,
     (select sum (betrag) sumbetrag
      from rechnungen) b
group by a.kdnr !
fetch!
select a.kdnr,
       float(sum (a.betrag), 18),
       float(sum (a.betrag) / b.sumbetrag * 100, 18) prozent
from rechnungen a,
     (select sum (betrag) sumbetrag
      from rechnungen) b
group by a.kdnr, b.sumbetrag !
fetch!
select a.kdnr,
       fixed(sum (a.betrag), 10) betrag, 
       fixed(sum (a.betrag) / b.sumbetrag * 100, 3) prozent
from rechnungen a,
     (select sum (betrag) sumbetrag
      from rechnungen) b
group by a.kdnr, b.sumbetrag !
fetch!
drop table rechnungen!
commit work release !
* Heft 4/5 1995 !
file connect ( kern test sqlmode oracle !
create table lager_frei (
regal     number (3) not null,
frei_von  number (4) not null,
frei_bis  number (4) not null,
check (frei_von < frei_bis),
primary key (regal, frei_von)) !
insert into lager_frei values (1,  25,3767)!
insert into lager_frei values (1,4234,4965)!
insert into lager_frei values (1,5001,5010)!
insert into lager_frei values (2, 702, 711)!
insert into lager_frei values (1,8001,8029)!
insert into lager_frei values (2,   1,  23)!
insert into lager_frei values (3,  25, 234)!
insert into lager_frei values (2,  55, 600)!
insert into lager_frei values (2, 800,7000)!
insert into lager_frei values (3, 255, 900)!
insert into lager_frei values (1,   1,  23)!
insert into lager_frei values (3,1002,7000)!
insert into lager_frei values (3, 921, 943)!
commit work !
pars_then_ex !
data !
select * from lager_frei
where (frei_bis - frei_von) =
      (select min (frei_bis - frei_von)
       from lager_frei
       where :benoetigte_anzahl <=
             frei_bis - frei_von +1)
and    frei_von =
      (select min (frei_von)
       from   lager_frei
       where (frei_bis - frei_von) = 
             (select min (frei_bis - frei_von)
              from lager_frei
              where :benoetigte_anzahl <=
                    frei_bis - frei_von + 1))
and    regal =
      (select min (regal)
       from   lager_frei
       where (frei_bis - frei_von) = 
             (select min (frei_bis - frei_von)
              from lager_frei
              where :benoetigte_anzahl <=
                    frei_bis - frei_von + 1)
       and    frei_von =
             (select min (frei_von)
              from   lager_frei
              where  (frei_bis - frei_von) =
                     (select min (frei_bis - frei_von)
                      from lager_frei
                      where :benoetigte_anzahl <= 
                            frei_bis - frei_von + 1))) !
n 4 10
n 4 10
n 4 10
n 4 10

nodata !
fetch into :a, :b, :c !
data !
select * from lager_frei
where (frei_bis - frei_von) =
      (select min (frei_bis - frei_von)
       from lager_frei
       where :benoetigte_anzahl <=
             frei_bis - frei_von +1)
and    frei_von =
      (select min (frei_von)
       from   lager_frei
       where (frei_bis - frei_von) = 
             (select min (frei_bis - frei_von)
              from lager_frei
              where :benoetigte_anzahl <=
                    frei_bis - frei_von + 1))
and    regal =
      (select min (regal)
       from   lager_frei
       where (frei_bis - frei_von) = 
             (select min (frei_bis - frei_von)
              from lager_frei
              where :benoetigte_anzahl <=
                    frei_bis - frei_von + 1)
       and    frei_von =
             (select min (frei_von)
              from   lager_frei
              where  (frei_bis - frei_von) =
                     (select min (frei_bis - frei_von)
                      from lager_frei
                      where :benoetigte_anzahl <= 
                            frei_bis - frei_von + 1))) !
n 4 20
n 4 20
n 4 20
n 4 20

nodata !
fetch into :a, :b, :c !
pars_then_ex !
data !
select *
from lager_frei
where (regal, frei_von, frei_bis - frei_von) =
      (select min (regal), frei_von, frei_bis - frei_von
       from lager_frei
       where (frei_von, frei_bis - frei_von) =
             (select min (frei_von), frei_bis - frei_von
              from lager_frei
              where (frei_bis - frei_von) =
                    (select min (frei_bis - frei_von)
                     from lager_frei
                     where :benoetigte_anzahl <=
                           frei_bis - frei_von + 1)
              group by frei_bis - frei_von)
       group by frei_bis - frei_von, frei_von) !
n 20 10
n 20 10
n 20 10
n 20 10

nodata !
fetch into :a, :b, :c !
data !
select *
from lager_frei
where (regal, frei_von, frei_bis - frei_von) =
      (select min (regal), frei_von, frei_bis - frei_von
       from lager_frei
       where (frei_von, frei_bis - frei_von) =
             (select min (frei_von), frei_bis - frei_von
              from lager_frei
              where (frei_bis - frei_von) =
                    (select min (frei_bis - frei_von)
                     from lager_frei
                     where :benoetigte_anzahl <=
                           frei_bis - frei_von + 1)
              group by frei_bis - frei_von)
       group by frei_von, frei_bis - frei_von) !
n 20 10
n 20 10
n 20 10
n 20 10

nodata !
fetch into :a, :b, :c !
data !
select *
from lager_frei
where (regal, frei_von, frei_bis - frei_von) =
      (select min (regal), frei_von, frei_bis - frei_von
       from lager_frei
       where (frei_von, frei_bis - frei_von) =
             (select min (frei_von), frei_bis - frei_von
              from lager_frei
              where (frei_bis - frei_von) =
                    (select min (frei_bis - frei_von)
                     from lager_frei
                     where :benoetigte_anzahl <=
                           frei_bis - frei_von + 1)
              group by frei_bis - frei_von)
       group by frei_von, frei_bis - frei_von) !
n 20 20
n 20 20
n 20 20
n 20 20

nodata !
fetch into :a, :b, :c !
pars_execute!
drop table lager_frei !
commit work release !
* Heft 4 1995 !
file connect ( kern test sqlmode oracle !
create table tables
  (name         varchar (30) primary key,
   storage_size number) !
insert into tables values ('KONTO'  , 1000)!
insert into tables values ('ARTIKEL', 1000)!
commit !
create table indexes
  (name        varchar2 (30) primary key,
   table_name  varchar2 (30) not null references tables,
   unique_flag varchar2 ( 4) not null
                      check (unique_flag in ('YES', 'NO'))) !
insert into indexes values ('KT01', 'KONTO'  , 'YES')! 
insert into indexes values ('KT02', 'KONTO'  , 'YES')! 
insert into indexes values ('KT03', 'KONTO'  , 'YES')! 
insert into indexes values ('KT04', 'KONTO'  , 'YES')! 
insert into indexes values ('ART1', 'ARTIKEL', 'YES')! 
insert into indexes values ('ART2', 'ARTIKEL', 'YES')! 
insert into indexes values ('ART3', 'ARTIKEL', 'YES')! 
insert into indexes values ('ART4', 'ARTIKEL', 'YES')! 
commit !
create table index_columns
  (index_name      varchar2 (30) references indexes,
   column_name     varchar2 (30) not null,
   column_position number not null
                          check (column_position > 0),
   primary key (index_name, column_name),
   constraint c1_index_name unique (index_name, column_position)) !
insert into index_columns values ('KT01', 'COL1', 1)!
insert into index_columns values ('KT02', 'COL1', 1)!
insert into index_columns values ('KT02', 'COL2', 2)!
insert into index_columns values ('KT03', 'COL1', 1)!
insert into index_columns values ('KT03', 'COL2', 2)!
insert into index_columns values ('KT03', 'COL3', 3)!
insert into index_columns values ('KT04', 'COL3', 1)!
insert into index_columns values ('KT04', 'COL4', 2)!
insert into index_columns values ('ART1', 'COLA', 1)!
insert into index_columns values ('ART1', 'COLB', 2)!
insert into index_columns values ('ART2', 'COLB', 1)!
insert into index_columns values ('ART2', 'COLC', 2)!
insert into index_columns values ('ART3', 'COLC', 1)!
insert into index_columns values ('ART3', 'COLD', 2)!
insert into index_columns values ('ART4', 'COLC', 1)!
insert into index_columns values ('ART4', 'COLD', 2)!
insert into index_columns values ('ART4', 'COLE', 3)!
insert into index_columns values ('ART4', 'COLF', 4)!
commit !
select substr(i1.table_name, 1, 10), 
       substr(i1.name, 1, 10), 
       substr(i2.name, 1, 10)
  from indexes i1, indexes i2
 where i1.table_name = i2.table_name
   and i1.name <> i2.name
   and not exists
           (select column_name, column_position
              from index_columns c1
             where i2.name = c1.index_name
           minus
           select column_name, column_position
             from index_columns c2
            where i1.name = c2.index_name) !
fetch into :a, :b, :c!
select substr(i1.table_name, 1, 10), 
       substr(i1.name, 1, 10), 
       substr(i2.name, 1, 10)
  from indexes i1, indexes i2
 where i1.table_name = i2.table_name
   and i1.name <> i2.name
   and not exists
           (select *
              from index_columns ic1
             where ic1.index_name = i2.name
               and not exists
                       (select *
                          from index_columns ic2
                         where ic2.index_name = i1.name
                           and ic1.column_name = ic2.column_name)) !
fetch into :a, :b, :c!
select substr(i1.table_name, 1, 10), 
       substr(i2.name, 1, 10), 
       substr(i1.name, 1, 10)
  from indexes i1,
       indexes i2,
       index_columns ic1
 where i1.table_name = i2.table_name
   and i1.name = ic1.index_name
   and i1.name <> i2.name
   and ic1.column_position =
                (select count(*)
                   from index_columns
                  where index_name = i1.name)
   and ic1.column_position =
                (select count(*)
                   from index_columns ic2,
                        index_columns ic3
                  where ic2.index_name = i1.name
                    and ic3.index_name = i2.name
                    and ic2.column_name = ic3.column_name
                    and ic2.column_position = ic3.column_position) !
fetch into :a, :b, :c!
drop table tables !
drop table indexes !
drop table index_columns !
commit release !
* Heft 5 1995 !
file connect ( kern test sqlmode oracle !
create table buecher
   (buch_nr number primary key,
    titel   varchar (30) not null,
    autor   varchar (30) not null)!
insert into buecher values (1, 'ORACLE7'         , 'G. Stuerner')!
insert into buecher values (2, 'INFORMIX 6.0/7.1', 'D. Petkovic')!
insert into buecher values (3, 'SYBASE'          , 'D. McGoveran')!
commit !
create table leser
   (leser_nr number primary key,
    name     varchar (30) not null) !
insert into leser values (1, 'H. Kohl')!
insert into leser values (2, 'B. Clinton')!
insert into leser values (3, 'B. Jelzin')!
commit !
create table ausleihe
   (buch_nr  number references buecher,
    leser_nr number references leser,
    ein_aus  char (3) not null 
                 check (ein_aus in ('EIN', 'AUS')),
    datum    date not null,
    primary key (buch_nr, datum))!
commit release !
file connect ( kern test !
insert into ausleihe values (3, 3, 'AUS', '19950609000000')!
insert into ausleihe values (2, 2, 'AUS', '19950611000000')!
insert into ausleihe values (1, 1, 'AUS', '19950612000000')!
insert into ausleihe values (3, 3, 'EIN', '19950613000000')!
insert into ausleihe values (1, 1, 'EIN', '19950615000000')!
insert into ausleihe values (1, 2, 'AUS', '19950617000000')!
insert into ausleihe values (2, 2, 'EIN', '19950618000000')!
insert into ausleihe values (2, 3, 'AUS', '19950619000000')!
insert into ausleihe values (3, 1, 'AUS', '19950619000000')!
insert into ausleihe values (1, 2, 'EIN', '19950622000000')!
insert into ausleihe values (2, 3, 'EIN', '19950627000000')!
insert into ausleihe values (3, 1, 'EIN', '19950630000000')!
commit !
select titel, name, aus.ein_aus, ein.ein_aus, 
      datediff(ein.datum, aus.datum) dauer
  from buecher, leser, ausleihe aus, ausleihe ein
 where buecher.buch_nr = aus.buch_nr
   and leser.leser_nr  = aus.leser_nr
   and aus.buch_nr     = ein.buch_nr
   and aus.leser_nr    = ein.leser_nr
   and aus.ein_aus     = 'AUS'
   and ein.ein_aus     = 'EIN'
   and ein.datum = (select min (datum) 
                      from ausleihe
                     where ausleihe.ein_aus  = 'EIN'
                       and ausleihe.buch_nr  = aus.buch_nr
                       and ausleihe.leser_nr = aus.leser_nr
                       and ausleihe.datum    > aus.datum) !
fetch!
drop table buecher !
drop table leser !
drop table ausleihe !
commit release!
* Heft 6 1995 !
file connect ( kern test sqlmode oracle !
create table flurkarte (
id varchar (4) primary key,
xa number not null,
xe number not null,
ya number not null,
ye number not null,
check ((xa<xe) and (ya<ye)))!
insert into flurkarte values ('1 ', 0, 3, 3, 5)!
insert into flurkarte values ('2 ', 0, 2, 1, 3)!
insert into flurkarte values ('3 ', 2, 5, 1, 3)!
insert into flurkarte values ('4a', 3, 5, 3, 5)!
insert into flurkarte values ('4b', 5, 7, 3, 4)!
insert into flurkarte values ('5 ', 5, 9, 4, 5)!
insert into flurkarte values ('6 ', 5, 7, 1, 3)!
insert into flurkarte values ('7 ', 7, 9, 1, 4)!
insert into flurkarte values ('8 ', 0, 9, 0, 1)!
insert into flurkarte values ('9 ', 0, 9, 5, 6)!
select id from flurkarte
where not 
      ((xe <= 3) or (xa >= 7) or (ye <= 1) or (ya >= 4)) !
fetch into :a!
drop table flurkarte !
commit work release !
* Heft 7 1995 !
file connect ( kern test sqlmode internal !
create table artikel (
nummer      integer primary key,
bezeichnung varchar(30))!
insert into artikel values (1, 'Bier')!
insert into artikel values (2, 'Wein')!
create table preis (
nummer      integer,
start_datum date,
preis       fixed(10,2) not null,
primary key (nummer, start_datum),
foreign key (nummer) references artikel)!
insert into preis values (1, '19950101', 1.20)!
insert into preis values (1, '19950201', 1.30)!
insert into preis values (1, '19950301', 1.50)!
insert into preis values (1, '19950601', 1.90)!
insert into preis values (2, '19950101', 1.90)!
insert into preis values (2, '19950401', 1.50)!
insert into preis values (2, '19951101', 2.10)!
create table verkauf (
nummer      integer,
datum       date,
anzahl      integer not null,
primary key (nummer, datum),
foreign key (nummer) references artikel)!
insert into verkauf values (1, '19950120',  20)!
insert into verkauf values (1, '19950311',  20)!
insert into verkauf values (2, '19950514', 345)!
insert into verkauf values (1, '19950811',  55)!
insert into verkauf values (2, '19950214',  55)!
insert into verkauf values (2, '19951014', 345)!
select a.bezeichnung,
       fixed(sum(p.preis * v.anzahl), 8,2) summe
  from artikel a, verkauf v, preis p
 where a.nummer = v.nummer
   and v.nummer = p.nummer
   and p.start_datum =
                     (select max (pr.start_datum)
                        from preis pr
                       where pr.nummer = v.nummer
                         and pr.start_datum <= v.datum)
group by a.bezeichnung !
fetch into :a, :b !
select a.bezeichnung,
       fixed(sum(p.preis * v.anzahl), 8,2) summe
  from artikel a, verkauf v, preis p
 where a.nummer = v.nummer
   and v.nummer = p.nummer
   and p.start_datum <= v.datum
   and not exists (select 1
                     from preis pr
                    where pr.nummer = v.nummer
                      and pr.start_datum > p.start_datum
                      and pr.start_datum <= v.datum)
group by a.bezeichnung !
fetch into :a, :b !
drop table artikel !
drop table preis !
drop table verkauf !
commit work release !
* Heft 1 1996 !
file connect ( kern test sqlmode internal !
create table personal (
id   integer primary key,
name varchar (10))!
insert into personal values (1, 'Ofer')!
insert into personal values (2, 'Hansen')!
insert into personal values (3, 'Meyer')!
insert into personal values (4, 'Albrecht')!
insert into personal values (5, 'Linke')!
create table rente (
id     integer references personal,
jahr   integer,
monate integer not null check (monate between 1 and 12),
lohn   integer not null,
primary key (id, jahr))!
insert into rente values (1, 1989,  2, 1500)!
insert into rente values (2, 1989, 12, 2200)!
insert into rente values (4, 1989,  3, 1200)!
insert into rente values (3, 1989,  2, 1700)!
insert into rente values (2, 1990, 12, 2300)!
insert into rente values (3, 1990,  2, 1900)!
insert into rente values (4, 1990,  3, 1400)!
insert into rente values (2, 1991, 12, 2400)!
insert into rente values (1, 1992,  2, 2100)!
insert into rente values (4, 1992,  3, 1900)!
insert into rente values (3, 1992,  2, 2100)!
insert into rente values (2, 1992, 12, 2500)!
insert into rente values (1, 1993,  2, 2200)!
insert into rente values (4, 1993,  3, 2100)!
insert into rente values (5, 1993,  6, 3000)!
insert into rente values (2, 1993, 12, 2600)!
insert into rente values (1, 1994,  2, 2300)!
insert into rente values (2, 1994, 12, 2700)!
insert into rente values (3, 1994,  2, 2300)!
select p.name, fixed(min(r1.jahr),4,0) beg,
       fixed(max(r1.jahr),4,0) ende,
       fixed(sum(r1.monate),4,0) sum_monate,
       fixed(sum(r1.lohn * r1.monate) / sum(r1.monate), 6,0) avg_lohn
  from rente r1, personal p
 where r1.id = p.id
   and r1.jahr >= (select min (r2.jahr)
                     from rente r2
                    where r1.id = r2.id
                      and exists
                               (select count(*)
                                  from rente r3
                                 where r1.id = r3.id
                                   and r2.jahr <= r3.jahr
                                group by r3.id
                                having count(r3.jahr) = 
                                     max(r3.jahr) - r2.jahr + 1
                                   and sum(r3.monate) >= 6)
                 ) 
group by p.name !
fetch into :a, :b, :c, :d, :e !
* hier unten ist das Ergebnis mit den 12 Monaten ok !
* Aufgabe war nicht eindeutig gestellt !
select p.name, fixed(min(r1.jahr),4,0) beg,
       fixed(max(r1.jahr),4,0) ende,
       fixed(sum(r1.monate),4,0) sum_monate,
       fixed(sum(r1.lohn * r1.monate) / sum(r1.monate), 6,0) avg_lohn
  from rente r1, personal p
 where r1.id = p.id
   and (  r1.jahr in (select r2.jahr + 1
                        from rente r2
                       where r1.id = r2.id)
        or 
          r1.jahr in (select r3.jahr - 1
                        from rente r3
                       where r1.id = r3.id)
        or
          r1.monate >= 6)
group by p.name, r1.id
having sum(monate) >= 6 !
fetch into :a, :b, :c, :d, :e !
drop table rente !
drop table personal !
commit work release !
* Heft 2 1996 !
file connect ( kern test sqlmode internal !
create table artikel (
artikel_nr  integer primary key,
bezeichnung varchar(12) not null)!
insert into artikel values (1, 'Brot')!
insert into artikel values (2, 'Fisch')!
insert into artikel values (3, 'Nudeln')!
insert into artikel values (4, 'Milch')!
insert into artikel values (5, 'Tomatensosse')!
create table scanner_header (
bon_id  integer primary key,
datum   date not null) !
insert into scanner_header values (1, '19951220')!
insert into scanner_header values (2, '19951220')!
insert into scanner_header values (3, '19951220')!
insert into scanner_header values (4, '19951220')!
insert into scanner_header values (5, '19951220')!
insert into scanner_header values (6, '19951220')!
insert into scanner_header values (7, '19951220')!
insert into scanner_header values (8, '19951220')!
create table scanner_line (
bon_id     integer
           constraint scanner_header_line_ref references scanner_header,
zeile      integer,
artikel_nr integer not null
           constraint scanner_artikel_ref references artikel,
menge      integer not null
           constraint mengen_check check (menge > 0),
constraint scanner_key primary key (bon_id, zeile))!
insert into scanner_line values (1,1,1,1)!
insert into scanner_line values (1,2,2,1)!
insert into scanner_line values (1,3,3,1)!
insert into scanner_line values (1,4,4,1)!
insert into scanner_line values (1,5,5,1)!
insert into scanner_line values (2,1,2,1)!
insert into scanner_line values (2,2,4,2)!
insert into scanner_line values (3,1,1,4)!
insert into scanner_line values (3,2,3,3)!
insert into scanner_line values (3,3,5,1)!
insert into scanner_line values (4,1,1,1)!
insert into scanner_line values (4,2,3,2)!
insert into scanner_line values (4,3,4,2)!
insert into scanner_line values (5,1,2,1)!
insert into scanner_line values (5,2,4,2)!
insert into scanner_line values (5,3,5,2)!
insert into scanner_line values (6,1,3,2)!
insert into scanner_line values (6,2,5,1)!
insert into scanner_line values (7,1,1,1)!
insert into scanner_line values (8,1,3,2)!
insert into scanner_line values (8,2,5,3)!
* der erste Test lief bis 26.3.96 mit -4004 falsch.
* Beim Auseinandernehmen in three_phase wurde ein Eintabellenselect
* draus, maxcounttabs blieb > 1 ==> es wurde versucht, den
* Eintabellenselect mit a680_join zu bearbeiten. Konnte nicht gehen. !
SELECT EINS.BEZEICHNUNG, ZWEI.BEZEICHNUNG 
  FROM ARTIKEL EINS, ARTIKEL ZWEI, 
       SCANNER_LINE SC1,  SCANNER_LINE SC2 
 WHERE SC1.BON_ID = SC2.BON_ID 
   AND SC1.ARTIKEL_NR  = EINS.ARTIKEL_NR 
   AND SC2.ARTIKEL_NR  = ZWEI.ARTIKEL_NR 
GROUP BY EINS.BEZEICHNUNG, EINS.ARTIKEL_NR, 
         ZWEI.BEZEICHNUNG, ZWEI.ARTIKEL_NR 
HAVING COUNT(EINS.ARTIKEL_NR) >= 
           (SELECT 0.5 * COUNT(*) 
              FROM SCANNER_LINE SC 
             WHERE SC.ARTIKEL_NR = EINS.ARTIKEL_NR) 
    OR COUNT(ZWEI.ARTIKEL_NR) >= 
           (SELECT 0.5 * COUNT(*) 
              FROM SCANNER_LINE SC 
             WHERE SC.ARTIKEL_NR = ZWEI.ARTIKEL_NR)
!
fetch into :a, :b !
SELECT EINS.BEZEICHNUNG, ZWEI.BEZEICHNUNG 
  FROM ARTIKEL EINS, ARTIKEL ZWEI, 
       SCANNER_LINE SC1,  SCANNER_LINE SC2 
 WHERE SC1.BON_ID = SC2.BON_ID 
   AND SC1.ARTIKEL_NR  = EINS.ARTIKEL_NR 
   AND SC2.ARTIKEL_NR  = ZWEI.ARTIKEL_NR 
   AND EINS.ARTIKEL_NR < ZWEI.ARTIKEL_NR 
GROUP BY EINS.BEZEICHNUNG, EINS.ARTIKEL_NR, 
         ZWEI.BEZEICHNUNG, ZWEI.ARTIKEL_NR 
HAVING COUNT(*) > 
           (SELECT 0.5 * COUNT(distinct sc.bon_id) 
              FROM SCANNER_LINE SC 
             WHERE SC.ARTIKEL_NR in (EINS.ARTIKEL_NR, ZWEI.ARTIKEL_NR))
!
fetch into :a, :b !
SELECT EINS.BEZEICHNUNG, ZWEI.BEZEICHNUNG 
  FROM ARTIKEL EINS, ARTIKEL ZWEI, 
       SCANNER_LINE SC1,  SCANNER_LINE SC2 
 WHERE SC1.BON_ID = SC2.BON_ID 
   AND SC1.ARTIKEL_NR  = EINS.ARTIKEL_NR 
   AND SC2.ARTIKEL_NR  = ZWEI.ARTIKEL_NR 
   AND EINS.ARTIKEL_NR < ZWEI.ARTIKEL_NR 
GROUP BY EINS.BEZEICHNUNG, EINS.ARTIKEL_NR, 
         ZWEI.BEZEICHNUNG, ZWEI.ARTIKEL_NR 
HAVING COUNT(*) * 3 > 
           (SELECT COUNT(sc.bon_id) 
              FROM SCANNER_LINE SC 
             WHERE SC.ARTIKEL_NR in (EINS.ARTIKEL_NR, ZWEI.ARTIKEL_NR))
!
fetch into :a, :b !
drop table artikel !
drop table scanner_header !
drop table scanner_line !
commit work release !
* Heft 3 1996 !
file connect ( kern test sqlmode internal !
create table zaehlungen (
zaehlungs_id   integer,
tier           varchar (30),
anzahl         integer not null,
primary key (zaehlungs_id, tier))!
insert into zaehlungen values (1, 'Frosch    ', 12)!
insert into zaehlungen values (1, 'Kaulquappe', 16)!
insert into zaehlungen values (1, 'Lurch     ', 10)!
insert into zaehlungen values (2, 'Frosch    ',  2)!
insert into zaehlungen values (2, 'Lurch     ',  1)!
insert into zaehlungen values (2, 'Kroete    ',  3)!
insert into zaehlungen values (3, 'Frosch    ',  3)!
create table zaehlungsgruppen (
gruppen_id    integer,
zaehlungs_id  integer,
primary key (gruppen_id, zaehlungs_id))!
insert into zaehlungsgruppen values (1,1)!
insert into zaehlungsgruppen values (1,2)!
insert into zaehlungsgruppen values (2,1)!
insert into zaehlungsgruppen values (2,3)!
insert into zaehlungsgruppen values (3,3)!
select tier, fixed(sum(anzahl) / x.nr, 4,1)
  from (select count(gruppen_id) nr 
          from zaehlungsgruppen
         where gruppen_id = 1) x,
       zaehlungen z,
       zaehlungsgruppen zg
 where zg.gruppen_id = 1
   and zg.zaehlungs_id = z.zaehlungs_id
group by tier, x.nr !
fetch into :a, :b!
drop table zaehlungen !
drop table zaehlungsgruppen !
commit work release !
* Heft 4 1996 !
file connect ( kern test sqlmode internal !
create table patienten (
id      integer primary key,
name    varchar (30))!
insert into patienten values (1, 'Albrecht')!
insert into patienten values (2, 'Ladewig')!
insert into patienten values (3, 'Weiss')!
insert into patienten values (4, 'Suhr')!
insert into patienten values (5, 'Medinger')!
insert into patienten values (6, 'Linke')!
create table messungen (
id    integer references patienten,
datum date,
wert  fixed(3,1) not null,
primary key (id, datum))!
insert into messungen values (1, '19960208', 38.4)!
insert into messungen values (2, '19960208', 36.7)!
insert into messungen values (3, '19960208', 37.5)!
insert into messungen values (6, '19960208', 40.7)!
insert into messungen values (5, '19960208', 39.5)!
insert into messungen values (4, '19960208', 40.8)!
insert into messungen values (1, '19960209', 40.6)!
insert into messungen values (6, '19960209', 37.3)!
insert into messungen values (5, '19960209', 41.8)!
insert into messungen values (4, '19960209', 38.7)!
insert into messungen values (3, '19960209', 42.2)!
insert into messungen values (2, '19960209', 38.1)!
insert into messungen values (1, '19960210', 40.5)!
insert into messungen values (6, '19960210', 38.1)!
insert into messungen values (5, '19960210', 37.5)!
insert into messungen values (4, '19960210', 41.7)!
insert into messungen values (3, '19960210', 36.5)!
insert into messungen values (2, '19960210', 36.1)!
insert into messungen values (1, '19960211', 38.1)!
insert into messungen values (4, '19960211', 42.3)!
insert into messungen values (3, '19960211', 41.7)!
insert into messungen values (6, '19960211', 36.0)!
insert into messungen values (5, '19960211', 40.8)!
insert into messungen values (2, '19960211', 37.8)!
select name, fixed(avg(m.wert), 5, 3) avg_wert, mw.wert
  from (select wert, id, datum from messungen me1
         where datum = (select max(datum) 
                          from messungen me2
                         where me2.id = me1.id)
       ) mw,
                     patienten p, messungen m
 where p.id  = m.id
   and mw.id = m.id
group by name, mw.wert
having mw.wert > avg(m.wert) !
fetch into :a, :b, :c !
select p.name, avg (m1.wert) avg_wert, m2.wert
  from patienten p, messungen m1, messungen m2
 where p.id = m1.id
   and p.id = m2.id
   and m2.datum = (select max(mi.datum)
                     from messungen mi
                    where mi.id = m2.id)
group by p.name, m2.wert
having m2.wert > avg (m1.wert)!
fetch into :a, :b, :c !
select p.name, mess.avg_wert, m.wert
  from patienten p, messungen m,
       (select mav.id, avg(mav.wert) avg_wert,
                       max(mav.datum) max_datum
          from messungen mav
        group by mav.id) mess
 where p.id = m.id
   and p.id = mess.id
   and m.datum = mess.max_datum
   and m.wert > mess.avg_wert !
fetch into :a, :b, :c !
drop table patienten !
drop table messungen!
commit work release !
* Heft 6 1996 !
file connect ( kern test sqlmode oracle !
create table flugplan
 (flug_nr varchar(10) constraint flugplan_pk primary key,
  ab_ort  varchar(30) not null,
  an_ort  varchar(30) not null)!
insert into flugplan values ('IT001', 'Hamburg  ', 'Berlin   ')!
insert into flugplan values ('IT002', 'Berlin   ', 'Hamburg  ')!
insert into flugplan values ('IT003', 'Hamburg  ', 'Berlin   ')!
insert into flugplan values ('IT004', 'Berlin   ', 'Hamburg  ')!
insert into flugplan values ('IT005', 'Hamburg  ', 'Bremen   ')!
insert into flugplan values ('IT006', 'Bremen   ', 'Hamburg  ')!
insert into flugplan values ('IT007', 'Bremen   ', 'Berlin   ')!
insert into flugplan values ('IT008', 'Berlin   ', 'Bremen   ')!
insert into flugplan values ('IT009', 'Bremen   ', 'Frankfurt')!
insert into flugplan values ('IT010', 'Frankfurt', 'Bremen   ')!
create table flug
 (flug_nr  varchar(10) constraint flugplan_fk references flugplan,
  datum    date,
  personen number not null,
      constraint flug_pk primary key (flug_nr, datum)) !
insert into flug values ('IT001', '20-APR-96',  60)!
insert into flug values ('IT002', '20-APR-96',  72)!
insert into flug values ('IT003', '20-APR-96',  37)!
insert into flug values ('IT004', '20-APR-96',  61)!
insert into flug values ('IT005', '20-APR-96',  38)!
insert into flug values ('IT006', '20-APR-96',  21)!
insert into flug values ('IT007', '20-APR-96',  63)!
insert into flug values ('IT008', '20-APR-96',  58)!
insert into flug values ('IT009', '20-APR-96',  59)!
insert into flug values ('IT010', '20-APR-96',  66)!
insert into flug values ('IT001', '21-APR-96',  55)!
insert into flug values ('IT002', '21-APR-96',  26)!
insert into flug values ('IT003', '21-APR-96',  68)!
insert into flug values ('IT004', '21-APR-96',  67)!
insert into flug values ('IT005', '21-APR-96',  23)!
insert into flug values ('IT006', '21-APR-96',  50)!
insert into flug values ('IT007', '21-APR-96',  34)!
insert into flug values ('IT008', '21-APR-96',  32)!
insert into flug values ('IT009', '21-APR-96',  44)!
insert into flug values ('IT010', '21-APR-96',  70)!
insert into flug values ('IT001', '22-APR-96',  47)!
insert into flug values ('IT002', '22-APR-96',  91)!
insert into flug values ('IT003', '22-APR-96',  34)!
insert into flug values ('IT004', '22-APR-96', 122)!
insert into flug values ('IT005', '22-APR-96', 109)!
insert into flug values ('IT006', '22-APR-96', 118)!
insert into flug values ('IT007', '22-APR-96',  26)!
insert into flug values ('IT008', '22-APR-96',  79)!
insert into flug values ('IT009', '22-APR-96',  31)!
insert into flug values ('IT010', '22-APR-96', 128)!
insert into flug values ('IT001', '23-APR-96',  82)!
insert into flug values ('IT002', '23-APR-96',  63)!
insert into flug values ('IT003', '23-APR-96',  70)!
insert into flug values ('IT004', '23-APR-96',  32)!
insert into flug values ('IT005', '23-APR-96',  91)!
insert into flug values ('IT006', '23-APR-96',  34)!
insert into flug values ('IT007', '23-APR-96',  74)!
insert into flug values ('IT008', '23-APR-96',  69)!
insert into flug values ('IT009', '23-APR-96',  90)!
insert into flug values ('IT010', '23-APR-96',  66)!
* geht nicht, ist auch nicht SQL92 Entry Level wegen der
* geschachtelten Set-Funktionen !
select substr(ab_ort, 1, 10), datum, sum(personen) summe_s
  from flugplan fp, flug f
 where fp.flug_nr = f.flug_nr
group by ab_ort, datum
having sum(personen) = 
   (select min(sum( fi.personen )) 
             from flugplan fpi, flug fi
            where fpi.flug_nr = fi.flug_nr
              and fp.ab_ort   = fpi.ab_ort
           group by datum) 
   !
fetch into :a, :b, :c !
select substr(ab_ort, 1, 10), datum, sum(personen) summe_s
  from flugplan fp, flug f
 where fp.flug_nr = f.flug_nr
group by ab_ort, datum
having (ab_ort, sum(personen)) = any
   (select ab_ort, min(sum_p) 
      from 
          (select ab_ort, sum(personen) sum_p
             from flugplan fp1, flug f1
            where fp1.flug_nr = f1.flug_nr
           group by ab_ort, datum) s
      group by ab_ort
   )!
fetch into :a, :b, :c !
select substr(ab_ort, 1, 10), datum, sum(personen) summe_s
  from flugplan fp, flug f
 where fp.flug_nr = f.flug_nr
group by ab_ort, datum
having (ab_ort, sum(personen)) in
   (select ab_ort, min(sum_p) 
      from 
          (select ab_ort, sum(personen) sum_p
             from flugplan fp1, flug f1
            where fp1.flug_nr = f1.flug_nr
           group by ab_ort, datum) s
      group by ab_ort
   )!
fetch into :a, :b, :c !
commit work release !
* PTS-Error 1382/1384 !
file connect ( kern test !
select * 
      from dual
     where exists (select datum from flug) !
set format eur !
select * 
      from dual
     where exists (select datum from flug) !
set format internal !
commit work release !
file connect ( kern test sqlmode ansi !
declare c cursor for
select ab_ort, datum, sum(personen) summe_s
  from flugplan fp, flug f
 where fp.flug_nr = f.flug_nr
group by ab_ort, datum
having sum(personen) <= all
   (select sum(fi.personen) 
      from flugplan fpi, flug fi
     where fpi.flug_nr = fi.flug_nr
       and fpi.ab_ort = min(fp.ab_ort)
    group by datum )
   !
fetch c into :a, :b, :c !
commit work release !
file connect ( kern test sqlmode oracle !
* PTS 1390 !
declare c cursor for
select ab_ort, datum, sum(personen) summe_s
  from flugplan fp, flug f
 where fp.flug_nr = f.flug_nr
group by ab_ort, datum
having sum(personen) <= all
   (select sum(fi.personen) 
      from flugplan fpi, flug fi
     where fpi.flug_nr = fi.flug_nr
       and fpi.ab_ort = fp.ab_ort
    group by datum )
   !
fetch c into :a, :b, :c !
* PTS 1470 !
declare c cursor for
select substr(ab_ort, 1, 10), datum, sum(personen) summe_s
  from flugplan fp, flug f
 where fp.flug_nr = f.flug_nr
group by ab_ort, datum
having sum(personen) <= all
   (select sum(fi.personen) 
      from flugplan fpi, flug fi
     where fpi.flug_nr = fi.flug_nr
       and fpi.ab_ort = fp.ab_ort
    group by datum )
   !
fetch c into :a, :b, :c !
drop table flugplan!
drop table flug !
commit work release !
* Heft 7 1996 !
file connect ( kern test !
create table personal (
id        fixed (4) primary key,
name      varchar (30) not null,
geb_date1 date,
geb_date2 timestamp)!
insert personal values (1,'Wilckes, Eva     ','19660523',
'19660523000000000000')!
insert personal values (2,'Ofer, Ute        ','19650101',
'19650101000000000000')!
insert personal values (3,'Bartels, Maja    ','19651031',
'19651031000000000000')!
insert personal values (4,'Weidert, Albrecht','19620810',
'19620810000000000000')!
insert personal values (5,'Klokkers, Jan    ','19610911',
'19610911000000000000')!
insert personal values (6,'Klemm, Lisel     ','19681002',
'19681002000000000000')!
insert personal values (7,'Krauss, Sepp     ','19550920',
'19550920000000000000')!
insert personal values (8,'Lynn, Barbara    ','19611001',
'19611001000000000000')!
insert personal values (9,'Zabel, Manfred   ','19590820',
'19590820000000000000')!
insert personal values (10,'Dietz, Juergen   ','19550710',
'19550710000000000000')!
insert personal values (11,'Passauf, Clever  ','19600229',
'19600229000000000000')!
commit !
commit work release !
file connect ( kern test sqlmode db2 !
set format eur !
 * fuehrt zum Fehler wegen 29.2.1997, illegal Datum !
declare c cursor for 
select name, geb_date1
from personal
where 
      date(substr (char (geb_date1)    , 1, 8) ||
           substr (char (date('01.07.1996') + 1 year), 9, 2)) >= 
                                 date('01.07.1996') + 1 year
  and date(substr (char (geb_date1)    , 1, 8) ||
           substr (char (date('01.07.1996') + 1 year), 9, 2)) <= 
                                 date('01.07.1996') + 1 year + 45 days !
fetch c into :a, :b !
close c !
declare c cursor for 
select name, geb_date1
from personal
where date(substr (char (geb_date1)    , 1, 8) ||
           substr ('01.07.1996'         , 9, 2)) >= date('01.07.1996')
  and date(substr (char (geb_date1)    , 1, 8) ||
           substr ('01.07.1996'         , 9, 2)) <= 
                                 date('01.07.1996') + 45 days
or    date(substr (char (geb_date1)    , 1, 8) ||
           substr (char (date('01.07.1996') + 1 year), 9, 2)) >= 
                                 date('01.07.1996') + 1 year
  and date(substr (char (geb_date1)    , 1, 8) ||
           substr (char (date('01.07.1996') + 1 year), 9, 2)) <= 
                                 date('01.07.1996') + 1 year + 45 days!
fetch c into :a, :b !
close c !
set format eur !
declare c cursor for 
select name, geb_date1
from personal
where 
      days (geb_date1 + 1 years) -
      days (geb_date1 - (month (geb_date1) - 1) months
                      - (day   (geb_date1) - 1) days ) -
      (days (date ('01.07.1996') + 1 years) -
       days (date ('01.07.1996') -
            (month (date ('01.07.1996')) - 1) months -
            (day   (date ('01.07.1996')) - 1) days))
     between 0 and 45!
fetch c into :a, :b !
close c !
declare c cursor for 
select name, geb_date1
from personal
where days (geb_date1) -
      days (geb_date1 - (month (geb_date1) - 1) months
                      - (day   (geb_date1) - 1) days ) -
      (days (date ('01.07.1996')) -
       days (date ('01.07.1996') -
            (month (date ('01.07.1996')) - 1) months -
            (day   (date ('01.07.1996')) - 1) days))
     between 0 and 45
or
      days (geb_date1 + 1 years) -
      days (geb_date1 - (month (geb_date1) - 1) months
                      - (day   (geb_date1) - 1) days ) -
      (days (date ('01.07.1997')) -
       days (date ('01.07.1996') -
            (month (date ('01.07.1996')) - 1) months -
            (day   (date ('01.07.1996')) - 1) days))
     between 0 and 45!
fetch c into :a, :b !
close c !
commit work release !
file connect ( kern test sqlmode oracle !
select name, geb_date2
from personal 
where 
      add_months
     (geb_date2,
       (to_number (to_char (to_date ('01-JUL-96'), 'yyyy')) -    
        to_number (to_char (geb_date2            , 'yyyy'))) * 12 + 12)
    between to_date ('01-JUL-97') and
            to_date ('01-JUL-97') + 45 !
fetch into :a, :b !
select name, geb_date2
from personal 
where add_months
     (geb_date2,
       (to_number (to_char (to_date ('01-JUL-96'), 'yyyy')) -    
        to_number (to_char (geb_date2            , 'yyyy'))) * 12)
    between to_date ('01-JUL-96') and
            to_date ('01-JUL-96') + 45
or
      add_months
     (geb_date2,
       (to_number (to_char (to_date ('01-JUL-96'), 'yyyy')) -    
        to_number (to_char (geb_date2            , 'yyyy'))) * 12 + 12)
    between to_date ('01-JUL-96') and
            to_date ('01-JUL-96') + 45 !
fetch into :a, :b !
drop table personal !
commit work release!
* Heft 8 1996 !
file connect ( kern test sqlmode oracle !
create table abteilungen (
abt_nr      number  ( 3) constraint abteilungen_pk primary key,
bezeichnung varchar (20) not null) !
insert into abteilungen values (10, 'EDV      ')!
insert into abteilungen values (20, 'Vertrieb ')!
insert into abteilungen values (30, 'Marketing')!
insert into abteilungen values (40, 'Personal ')!
create table angestellte (
ma_nr       number   (3) constraint angestellte_pk primary key,
name        varchar (30) not null,
position    varchar (30),
abt_nr      number  ( 3) constraint angestellte_fk_abt
                               references abteilungen) !
insert into angestellte values ( 1, 'Moeller', 'Systemanalytiker', 10)!
insert into angestellte values ( 2, 'Meyer  ', 'EDV-Spezialist  ', 10)!
insert into angestellte values ( 5, 'Chall  ', 'Verkaeufer      ', 20)!
insert into angestellte values ( 6, 'Kunze  ', null              , 20)!
insert into angestellte values ( 7, 'Peter  ', 'Verkaeuferin    ', 20)!
insert into angestellte values ( 8, 'Hagner ', 'EDV-Spezialist  ',null)!
insert into angestellte values ( 9, 'Hansen ', 'Berater         ', 30)!
insert into angestellte values (10, 'Klasen ', 'EDV-Spezialist  ', 30)!
insert into angestellte values (12, 'Bauer  ', 'Sachbearbeiter  ', 40)!
create table kurse (
kurs_nr     number  ( 3) constraint kurs_pk primary key,
bezeichnung varchar (20) not null) !
insert into kurse values (10, 'Rhetorik')!
insert into kurse values (20, 'SQL     ')!
create table kursteilnehmer (
kurs_nr     number  ( 3) constraint ktn_fk_kurs
                                 references kurse,
ma_nr       number  ( 3) constraint ktn_fk_ma
                                 references angestellte,
datum       date,
constraint kursteilnehmer_pk primary key (kurs_nr, ma_nr, datum)) !
insert into kursteilnehmer values (10,  1, '20-NOV-95')!
insert into kursteilnehmer values (10,  5, '20-OCT-95')!
insert into kursteilnehmer values (10,  6, '20-DEC-95')!
insert into kursteilnehmer values (10, 10, '20-SEP-95')!
insert into kursteilnehmer values (10,  9, '20-NOV-95')!
insert into kursteilnehmer values (20,  2, '10-MAY-95')!
insert into kursteilnehmer values (20,  8, '11-JUL-95')!
insert into kursteilnehmer values (20,  6, '02-FEB-96')!
insert into kursteilnehmer values (20,  7, '20-APR-96')!
select bezeichnung
  from abteilungen 
 where abt_nr not in
          (select abt_nr
             from kursteilnehmer kt,
                  kurse k,
                  angestellte a
            where k.bezeichnung = 'SQL'
              and k.kurs_nr     = kt.kurs_nr
              and kt.ma_nr      = a.ma_nr
              and a.abt_nr is not null
          ) !
fetch into :a !
select bezeichnung
  from abteilungen 
 where not exists 
          (select 'a'
             from kursteilnehmer kt,
                  kurse k,
                  angestellte a
            where k.bezeichnung = 'SQL'
              and k.kurs_nr     = kt.kurs_nr
              and kt.ma_nr      = a.ma_nr 
              and a.abt_nr      = abteilungen.abt_nr )!
fetch into :a !
* PTS 2612 !
select a.bezeichnung
  from abteilungen a
 where not exists
      (select *
         from angestellte ag
        where a.abt_nr = ag.abt_nr
          and exists
             (select * 
                from kursteilnehmer kt
               where ag.ma_nr = kt.ma_nr
                 and kt.kurs_nr =
                         (select k.kurs_nr
                            from kurse k
                           where k.bezeichnung = 'SQL'
                         )               
             )
     )!
fetch into :a!
drop table abteilungen !
drop table angestellte !
drop table kurse !
drop table kursteilnehmer !
commit work release !
* Heft 9 1996 !
file connect ( kern test !
create table personal (
pers_no fixed (3) primary key,
name varchar (10) not null)!
insert into personal values (1, 'Gehner')!
insert into personal values (2, 'Jonas')!
insert into personal values (3, 'Hansen')!
insert into personal values (4, 'Clausen')!
create table praemie (
pr_id        fixed (3) primary key,
beschreibung varchar (10) not null,
wert         fixed (10) not null)!
insert into praemie values (2, 'Restaurant',   200)!
insert into praemie values (3, '1100 DM   ',  1100)!
insert into praemie values (4, '3100 DM   ',  3100)!
insert into praemie values (5, '1000 DM   ',  1000)!
insert into praemie values (6, '3000 DM   ',  3000)!
insert into praemie values (1, 'Reise     ', 10000)!
create table ziel (
ziel_id      fixed (3) primary key,
beschreibung varchar(10) not null)!
insert into ziel values (1, '80% Umsatz')!
insert into ziel values (2, '90% Umsatz')!
insert into ziel values (3, '100% Ums. ')!
insert into ziel values (4, '120% Ums. ')!
insert into ziel values (5, '5 neue Kd.')!
insert into ziel values (6, '10 neu Kd.')!
insert into ziel values (7, 'Kurs 1    ')!
insert into ziel values (8, 'Kurs 2    ')!
insert into ziel values (9, 'Gr. Auftr.')!
commit !
create table erreichtes_ziel (
pers_no    fixed (3) references personal,
ziel_id    fixed (3) references ziel,
primary key (pers_no, ziel_id))!
insert into erreichtes_ziel values (4, 1)!
insert into erreichtes_ziel values (3, 1)!
insert into erreichtes_ziel values (2, 1)!
insert into erreichtes_ziel values (1, 1)!
insert into erreichtes_ziel values (4, 2)!
insert into erreichtes_ziel values (3, 2)!
insert into erreichtes_ziel values (2, 2)!
insert into erreichtes_ziel values (1, 2)!
insert into erreichtes_ziel values (4, 3)!
insert into erreichtes_ziel values (3, 3)!
insert into erreichtes_ziel values (1, 3)!
insert into erreichtes_ziel values (1, 4)!
insert into erreichtes_ziel values (4, 5)!
insert into erreichtes_ziel values (3, 5)!
insert into erreichtes_ziel values (2, 5)!
insert into erreichtes_ziel values (1, 5)!
insert into erreichtes_ziel values (2, 6)!
insert into erreichtes_ziel values (1, 6)!
insert into erreichtes_ziel values (4, 7)!
insert into erreichtes_ziel values (2, 7)!
insert into erreichtes_ziel values (1, 7)!
insert into erreichtes_ziel values (3, 8)!
insert into erreichtes_ziel values (1, 8)!
insert into erreichtes_ziel values (4, 9)!
insert into erreichtes_ziel values (1, 9)!
create table notwendiges_ziel (
pr_id     fixed (3) references praemie,
ziel_id   fixed (3) references ziel,
primary key (pr_id, ziel_id))!
insert notwendiges_ziel values (2, 1)!
insert notwendiges_ziel values (2, 5)!
insert notwendiges_ziel values (2, 7)!
insert notwendiges_ziel values (3, 2)!
insert notwendiges_ziel values (3, 5)!
insert notwendiges_ziel values (3, 7)!
insert notwendiges_ziel values (5, 1)!
insert notwendiges_ziel values (5, 6)!
insert notwendiges_ziel values (5, 8)!
insert notwendiges_ziel values (4, 3)!
insert notwendiges_ziel values (4, 5)!
insert notwendiges_ziel values (4, 7)!
insert notwendiges_ziel values (6, 2)!
insert notwendiges_ziel values (6, 6)!
insert notwendiges_ziel values (6, 8)!
insert notwendiges_ziel values (6, 9)!
insert notwendiges_ziel values (1, 4)!
insert notwendiges_ziel values (1, 6)!
insert notwendiges_ziel values (1, 8)!
insert notwendiges_ziel values (1, 9)!
commit !
select name, beschreibung, wert 
from personal, praemie
where wert = 
       (select max(wert)
         from praemie
        where pr_id in 
                  (select pr_id 
                     from notwendiges_ziel
                    group by pr_id
                   having (pr_id, count(*)) in
                               (select pr_id, count(*)
                                  from notwendiges_ziel nz,
                                       erreichtes_ziel ez
                                 where nz.ziel_id = ez.ziel_id
                                   and ez.pers_no = personal.pers_no
                                 group by pr_id
                               )
                  )
       ) 
order by wert !
fetch into :a, :b, :c !
select name, beschreibung, wert 
from personal, praemie
where wert = 
       (select max(wert)
         from praemie
        where pr_id in 
                  (select pr_id 
                     from notwendiges_ziel
                    group by pr_id
                   having (pr_id, count(*)) in
                               (select pr_id, count(*)
                                  from notwendiges_ziel nz,
                                       erreichtes_ziel ez
                                 where nz.ziel_id = ez.ziel_id
                                   and ez.pers_no = personal.pers_no
                                 group by pr_id
                               )
                  )
       ) 
order by 3 !
fetch into :a, :b, :c !
* Das hier geht nicht, weil er ein FROM-Select in einer Correlation
* nicht vertraegt !
select name, beschreibung, wert 
from personal, praemie
where wert = 
       (select max(wert)
         from praemie,
               (select count(*) cnt, pr_id
                 from notwendiges_ziel
                group by pr_id) nzcnt
        where praemie.pr_id = nzcnt.pr_id
          and (praemie.pr_id, nzcnt.cnt) in 
             (select pr_id, count(*)
                from notwendiges_ziel nz
               where nz.ziel_id in (select ziel_id
                                      from erreichtes_ziel ez
                                     where ez.pers_no = personal.pers_no
                                   )
               group by pr_id
             )
       ) 
order by 3 !
fetch into :a, :b, :c !
* Die beiden gehen nicht, weil er (a661_corr_sub) corr_subs in
* where und in having nicht vertraegt, auch wenn es keine 
* echten Corr-Subs sind !
select name, beschreibung, wert 
from personal, praemie
where wert = 
       (select max(wert)
         from praemie
        where pr_id in 
             (select pr_id
                from notwendiges_ziel nz
               where nz.ziel_id in (select ziel_id
                                      from erreichtes_ziel ez
                                     where ez.pers_no = personal.pers_no
                                   )
               group by pr_id
               having count (*) = (select count(*)
                                     from notwendiges_ziel
                                    where pr_id = nz.pr_id
                                  )
             )
       ) 
order by 3 !
fetch into :a, :b, :c !
select name, beschreibung, wert 
from personal, praemie
where wert = 
       (select max(wert)
         from praemie
        where pr_id in 
             (select pr_id
                from notwendiges_ziel nz
               where nz.ziel_id in (select ziel_id
                                      from erreichtes_ziel ez
                                     where ez.pers_no = personal.pers_no
                                   )
               group by pr_id
               having (count (*), pr_id) = (select count(*), pr_id
                                     from notwendiges_ziel
                                     group by pr_id)
             )
       ) 
order by 3 !
* Das hier geht nicht, weil es zu viele Correlation-Stufen hat (>4) !
* Wenn man das gehend machen will (ausprobiert mit 6.2.7.4+) :
* mxak_full_dml_init
* mxak_part_dml_init
* mxak_one_corcolumn
* cak_maxcorlevel
* mxak_correc
* tak_one_corcolumn (Kommentar)
* anpassen !
select name, beschreibung, wert 
from personal, praemie
where wert = 
       (select max(wert)
         from praemie
        where pr_id in 
                 (select pr_id 
                    from notwendiges_ziel
                   group by pr_id
                  having (pr_id, count(*)) in
                          (select pr_id, count(*)
                             from notwendiges_ziel nz
                            where nz.ziel_id in 
                                    (select ziel_id
                                      from erreichtes_ziel ez
                                     where ez.pers_no = personal.pers_no
                                    )
                            group by pr_id
                          )
                 )
       ) 
order by 3 !
fetch into :a, :b, :c !
select pe1.name,
       pr1.beschreibung,
       pr1.wert
  from personal pe1,
       praemie pr1
 where pr1.wert in
             (select max (pr2.wert)
                from praemie pr2
               where pr2.pr_id not in
                      (select nz1.pr_id
                         from notwendiges_ziel nz1
                        where nz1.ziel_id not in
                              (select ez1.ziel_id
                                 from erreichtes_ziel ez1
                                where ez1.pers_no = pe1.pers_no
                              )
                       )
             )!
fetch into :a, :b, :c !
select pe1.name,
       pr1.beschreibung,
       pr1.wert
  from personal pe1,
       praemie pr1
 where (pe1.name, pr1.wert) in
          (select pe2.name, max(pr2.wert)
             from personal pe2, praemie pr2
            where not exists
                   (select nz1.ziel_id
                      from notwendiges_ziel nz1
                     where nz1.pr_id = pr2.pr_id
                  except
                    select ez1.ziel_id
                      from erreichtes_ziel ez1
                     where ez1.pers_no = pe2.pers_no
                   )
           group by pe2.name
          ) !
fetch into :a, :b, :c !
drop table personal !
drop table praemie !
drop table ziel !
drop table erreichtes_ziel !
drop table notwendiges_ziel !
commit release !
* Heft 10 1996 !
file connect ( kern test sqlmode oracle!
create table kunden (
kdnr number (6,0) constraint kunden_pk primary key,
name varchar (30))!
insert into kunden values (1, 'Meyer    ')!
insert into kunden values (2, 'Schmidt  ')!
insert into kunden values (3, 'Clausen  ')!
insert into kunden values (4, 'Fischer  ')!
insert into kunden values (5, 'Feddersen')!
create table ausgaben (
titel varchar (30) constraint ausgaben_pk primary key,
datum date not null)!
insert into ausgaben values ('7/96', '05-JUL-96')!
insert into ausgaben values ('8/96', '05-AUG-96')!
insert into ausgaben values ('9/96', '05-SEP-96')!
create table anzeigen (
kdnr    number (6,0) constraint anz_kd_fk references kunden,
titel   varchar (30) constraint anz_ausg_fk references ausgaben,
seite   number (3,0),
groesse number (3,2) constraint groesse_check
        check (groesse > 0 and groesse <= 1),
color   char (1) constraint color_check check (color in ('J','N')),
constraint anzeigen_pk primary key (kdnr, titel, seite))!
insert into anzeigen values (1, '7/96', 15, 0.50, 'J')!
insert into anzeigen values (2, '7/96', 22, 0.50, 'J')!
insert into anzeigen values (5, '7/96', 33, 1.00, 'N')!
insert into anzeigen values (3, '7/96', 41, 1.00, 'N')!
insert into anzeigen values (4, '7/96', 45, 1.00, 'N')!
insert into anzeigen values (4, '7/96', 46, 1.00, 'N')!
insert into anzeigen values (1, '8/96', 15, 0.50, 'J')!
insert into anzeigen values (2, '8/96', 22, 0.50, 'J')!
insert into anzeigen values (5, '8/96', 33, 1.00, 'N')!
insert into anzeigen values (1, '9/96', 15, 0.50, 'J')!
insert into anzeigen values (2, '9/96', 22, 1.00, 'N')!
insert into anzeigen values (5, '9/96', 33, 1.00, 'N')!
insert into anzeigen values (3, '9/96', 41, 1.00, 'J')!
select name
  from kunden
 where 3 <= (select sum (decode (color,
                                   'J', groesse*2,
                                        groesse))
               from anzeigen
              where kunden.kdnr = anzeigen.kdnr)
order by kdnr !
fetch into :a !
select kd.name
  from kunden kd, anzeigen az
 where az.kdnr = kd.kdnr
group by kd.name
having sum (az.groesse * decode (az.color, 'J', 2, 1)) >= 3 !
fetch into :a !
select kd.name
  from kunden kd
 where exists
      (select sum (az_all.groesse),
              sum (az_col.groesse)
         from anzeigen az_all, anzeigen az_col
        where kd.kdnr        = az_all.kdnr
          and az_all.kdnr    = az_col.kdnr(+)
          and az_all.titel   = az_col.titel(+)
          and az_all.seite   = az_col.seite(+)
          and az_col.color   = 'J'
        having sum (az_all.groesse) + 
               sum (az_col.groesse) >= 3.0
            or sum (az_all.groesse) >= 3.0) !
fetch into :a !
drop table kunden !
drop table ausgaben !
drop table anzeigen!
commit work release !
* Heft 11 1996 !
file connect ( kern test !
create table bahnhof (
name              varchar (10) primary key,
min_umsteige_zeit fixed (5) not null)!
insert into bahnhof values ('Muenchen' , 10)!
insert into bahnhof values ('Hamburg ' , 10)!
insert into bahnhof values ('Frankfurt', 15)!
create table zug (
nummer       varchar (6) primary key,
von_bahnhof  varchar (10) references bahnhof,
bis_bahnhof  varchar (10) references bahnhof,
start_zeit   time not null,
ankunft_zeit time not null,
preis        fixed (6,2) not null)!
insert zug values('ICE111','Muenchen ','Frankfurt','00090000','00130000',120)!
insert zug values('IC121 ','Muenchen ','Frankfurt','00091000','00134000', 90)!
insert zug values('ICE112','Muenchen ','Frankfurt','00102000','00141500',120)!
insert zug values('IC122 ','Muenchen ','Frankfurt','00111100','00154000', 90)!
insert zug values('ICE211','Frankfurt','Hamburg  ','00131000','00160000',100)!
insert zug values('ICE113','Muenchen ','Frankfurt','00131200','00172000',120)!
insert zug values('IC123 ','Muenchen ','Frankfurt','00132300','00180000', 90)!
insert zug values('ICE124','Muenchen ','Frankfurt','00135000','00175000',120)!
insert zug values('IC221 ','Frankfurt','Hamburg  ','00135000','00172000', 80)!
insert zug values('ICE212','Frankfurt','Hamburg  ','00141000','00170000',100)!
insert zug values('IC222 ','Frankfurt','Hamburg  ','00145000','00183000', 80)!
insert zug values('IC223 ','Frankfurt','Hamburg  ','00171000','00204000', 80)!
insert zug values('ICE213','Frankfurt','Hamburg  ','00173000','00204000',100)!
insert zug values('IC224 ','Frankfurt','Hamburg  ','00182300','00220000', 80)!
insert zug values('ICE214','Frankfurt','Hamburg  ','00190000','00220000',100)!
select * from
(select zug1.nummer num1,
       zug1.start_zeit start_m,
       zug1.ankunft_zeit end_f,
       zug2.nummer num2,
       zug2.start_zeit start_f,
       zug2.ankunft_zeit end_h,
       fixed(hour  (zug2.ankunft_zeit) * 60 + 
       minute(zug2.ankunft_zeit)          -
       (hour (zug1.start_zeit) * 60 +
       minute(zug1.start_zeit)), 3) dauer,
       fixed(zug1.preis + zug2.preis, 3) preis
  from zug zug1, zug zug2, bahnhof
 where zug1.von_bahnhof = 'Muenchen'
   and (hour (zug1.ankunft_zeit) * 60 +
       minute(zug1.ankunft_zeit)) + bahnhof.min_umsteige_zeit 
         <= (hour(zug2.start_zeit) * 60 + minute(zug2.start_zeit))
   and zug2.von_bahnhof = 'Frankfurt'
   and zug1.bis_bahnhof = bahnhof.name) xx
order by (dauer+preis)
!
fetch into :a, :b, :c, :d, :e, :f, :g, :h!
commit work release!
* Heft 12 1996 !
file connect ( kern test sqlmode oracle !
create table tabellen (
tabelle      varchar (30),
beschreibung varchar(100),
constraint tabellen_pk primary key ( tabelle))!
insert into tabellen values ('Tabellen', 'Beschreibung aller Tabellen')!
insert into tabellen values ('Spalten', 
            'Beschreibung aller Tabellenspalten')!
insert into tabellen values ('Indices', 'Beschreibung aller Indices')!
insert into tabellen values ('Index_Spalten', 
            'Beschreibung der Index Spalten')!
create table spalten (
tabelle    varchar (30) constraint sptabfk
                              references tabellen,
spalte     varchar (30),
is_key     varchar(1) not null constraint is_key_check
                              check (is_key in ('Y', 'N')),
fremdschl  varchar (30) constraint sptabfk2
                              references tabellen,
constraint spalten_pk primary key (tabelle, spalte)) !
insert into spalten values ('Tabellen     ', 'Beschreibung', 'N', NULL)!
insert into spalten values ('Spalten      ', 'Fremdschl   ', 'N', 'Tabellen')!
insert into spalten values ('Indices      ', 'Index_Name  ', 'Y', NULL)!
insert into spalten values ('Index_Spalten', 'Index_Name  ', 'Y', 'Indices')!
insert into spalten values ('Spalten      ', 'Is_Key      ', 'N', NULL)!
insert into spalten values ('Index_Spalten', 'Sortierung  ', 'N', NULL)!
insert into spalten values ('Spalten      ', 'Spalte      ', 'Y', NULL)!
insert into spalten values ('Index_Spalten', 'Spalte      ', 'Y', NULL)!
insert into spalten values ('Index_Spalten', 'Tabelle     ', 'Y', 'Indices')!
insert into spalten values ('Tabellen     ', 'Tabelle     ', 'Y', NULL)!
insert into spalten values ('Spalten      ', 'Tabelle     ', 'Y', 'Tabellen')!
insert into spalten values ('Indices      ', 'Tabelle     ', 'Y', 'Tabellen')!
insert into spalten values ('Indices      ', 'Unique      ', 'N', NULL)!
* bei Tabellen, Spalten ==> keine Daten gefunden
* bei Tabellen, Indices ==> Indices.Tabelle = Tabellen.Tabelle
* bei Index_Spalten, Indices ==> Indices.Tabelle = Index_Spalten.Tabelle
*                      and Indices.Index_Name = Index_Spalten.Index_Name
pars_then_ex !
data !
select s1.tabelle || '.' || s1.spalte || ' = ' ||
       s2.tabelle || '.' || s1.spalte bedingung
from spalten s1, spalten s2
where s1.tabelle = :a
  and s2.tabelle = :b
  and s1.fremdschl = s2.tabelle
  and s1.spalte = s2.spalte
  and not exists
    (select * 
       from spalten s3
      where s1.tabelle = s3.tabelle
        and s1.fremdschl = s3.fremdschl
        and s3.spalte not in
                (select s4.spalte
                   from spalten s4
                  where s2.tabelle = s4.tabelle
                )
    )
union
select s1.tabelle || '.' || s1.spalte || ' = ' ||
       s2.tabelle || '.' || s1.spalte bedingung
from spalten s1, spalten s2
where s2.tabelle = :a
  and s1.tabelle = :b
  and s1.fremdschl = s2.tabelle
  and s1.spalte = s2.spalte
  and not exists
    (select * 
       from spalten s3
      where s1.tabelle = s3.tabelle
        and s1.fremdschl = s3.fremdschl
        and s3.spalte not in
                (select s4.spalte
                   from spalten s4
                  where s2.tabelle = s4.tabelle
                )
    )!
c 30 'Tabellen' c 30 'Spalten'
c 30 'Tabellen' c 30 'Spalten'

nodata !
fetch into :a !
data !
select s1.tabelle || '.' || s1.spalte || ' = ' ||
       s2.tabelle || '.' || s1.spalte bedingung
from spalten s1, spalten s2
where s1.tabelle = :a
  and s2.tabelle = :b
  and s1.fremdschl = s2.tabelle
  and s1.spalte = s2.spalte
  and not exists
    (select * 
       from spalten s3
      where s1.tabelle = s3.tabelle
        and s1.fremdschl = s3.fremdschl
        and s3.spalte not in
                (select s4.spalte
                   from spalten s4
                  where s2.tabelle = s4.tabelle
                )
    )
union
select s1.tabelle || '.' || s1.spalte || ' = ' ||
       s2.tabelle || '.' || s1.spalte bedingung
from spalten s1, spalten s2
where s2.tabelle = :a
  and s1.tabelle = :b
  and s1.fremdschl = s2.tabelle
  and s1.spalte = s2.spalte
  and not exists
    (select * 
       from spalten s3
      where s1.tabelle = s3.tabelle
        and s1.fremdschl = s3.fremdschl
        and s3.spalte not in
                (select s4.spalte
                   from spalten s4
                  where s2.tabelle = s4.tabelle
                )
    )!
c 30 'Tabellen' c 30 'Indices'
c 30 'Tabellen' c 30 'Indices'

nodata !
fetch into :a !
data !
select s1.tabelle || '.' || s1.spalte || ' = ' ||
       s2.tabelle || '.' || s1.spalte bedingung
from spalten s1, spalten s2
where s1.tabelle = :a
  and s2.tabelle = :b
  and s1.fremdschl = s2.tabelle
  and s1.spalte = s2.spalte
  and not exists
    (select * 
       from spalten s3
      where s1.tabelle = s3.tabelle
        and s1.fremdschl = s3.fremdschl
        and s3.spalte not in
                (select s4.spalte
                   from spalten s4
                  where s2.tabelle = s4.tabelle
                )
    )
union
select s1.tabelle || '.' || s1.spalte || ' = ' ||
       s2.tabelle || '.' || s1.spalte bedingung
from spalten s1, spalten s2
where s2.tabelle = :a
  and s1.tabelle = :b
  and s1.fremdschl = s2.tabelle
  and s1.spalte = s2.spalte
  and not exists
    (select * 
       from spalten s3
      where s1.tabelle = s3.tabelle
        and s1.fremdschl = s3.fremdschl
        and s3.spalte not in
                (select s4.spalte
                   from spalten s4
                  where s2.tabelle = s4.tabelle
                )
    )!
c 30 'Index_Spalten' c 30 'Indices'
c 30 'Index_Spalten' c 30 'Indices'

nodata !
fetch into :a !
data !
select s1.tabelle || '.' || s1.spalte || ' = ' ||
       s2.tabelle || '.' || s1.spalte bedingung
from spalten s1, spalten s2
where s1.tabelle = :a
  and s2.tabelle = :b
  and s1.spalte = s2.spalte
  and (s1.fremdschl = s2.tabelle
  and not exists
    (select * 
       from spalten s3
      where s1.tabelle = s3.tabelle
        and s1.fremdschl = s3.fremdschl
        and s3.spalte not in
                (select s4.spalte
                   from spalten s4
                  where s2.tabelle = s4.tabelle
                )
    )
or 
    s2.fremdschl = s1.tabelle
and not exists
   (select * 
      from spalten s3
     where s2.tabelle = s3.tabelle
       and s2.fremdschl = s3.fremdschl
       and s3.spalte not in
           (select s4.spalte
              from spalten s4
             where s1.tabelle = s4.tabelle
           )
   )
)!
c 30 'Tabellen' c 30 'Spalten'

nodata !
fetch into :a !
data !
select s1.tabelle || '.' || s1.spalte || ' = ' ||
       s2.tabelle || '.' || s1.spalte bedingung
from spalten s1, spalten s2
where s1.tabelle = :a
  and s2.tabelle = :b
  and s1.spalte = s2.spalte
  and (s1.fremdschl = s2.tabelle
  and not exists
    (select * 
       from spalten s3
      where s1.tabelle = s3.tabelle
        and s1.fremdschl = s3.fremdschl
        and s3.spalte not in
                (select s4.spalte
                   from spalten s4
                  where s2.tabelle = s4.tabelle
                )
    )
or 
    s2.fremdschl = s1.tabelle
and not exists
   (select * 
      from spalten s3
     where s2.tabelle = s3.tabelle
       and s2.fremdschl = s3.fremdschl
       and s3.spalte not in
           (select s4.spalte
              from spalten s4
             where s1.tabelle = s4.tabelle
           )
   )
)!
c 30 'Tabellen' c 30 'Indices'

nodata !
fetch into :a !
data !
select s1.tabelle || '.' || s1.spalte || ' = ' ||
       s2.tabelle || '.' || s1.spalte bedingung
from spalten s1, spalten s2
where s1.tabelle = :a
  and s2.tabelle = :b
  and s1.spalte = s2.spalte
  and (s1.fremdschl = s2.tabelle
  and not exists
    (select * 
       from spalten s3
      where s1.tabelle = s3.tabelle
        and s1.fremdschl = s3.fremdschl
        and s3.spalte not in
                (select s4.spalte
                   from spalten s4
                  where s2.tabelle = s4.tabelle
                )
    )
or 
    s2.fremdschl = s1.tabelle
and not exists
   (select * 
      from spalten s3
     where s2.tabelle = s3.tabelle
       and s2.fremdschl = s3.fremdschl
       and s3.spalte not in
           (select s4.spalte
              from spalten s4
             where s1.tabelle = s4.tabelle
           )
   )
)!
c 30 'Index_Spalten' c 30 'Indices'

nodata !
fetch into :a !
pars_execute!
drop table tabellen !
drop table spalten !
commit work release !
file shutdwnk!
vdnexit!
