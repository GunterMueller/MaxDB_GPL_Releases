LONG.vdnts
 
Enter command:
FILE XINITDBK!
 
Enter command:
FILE XRESTORE !
 
Enter command:
DBMCLI SUPERDBA,COLDUSER!
UTIL_CONNECT SUPERDBA,COLDUSER!
OK
 
BACKUP_RESTORE XINITDB DATA!
OK
Returncode           0
Date                 DATEXXXX
Time                 TIMEYYYY
Server               <servernode>
Database             <serverdb>
Kernel Version       KERNEL    vv.vv.vv Build bbb-bbb-bbb-bbb
Pages Transferred    000
Pages Left           0
Volumes              1
Medianame            xinitdb
Location             xinitdb.sav
Errortext
Label                <label>
Is Consistent        true
First LOG Page       000
Last LOG Page
DB Stamp 1 Date      DATEXXXX
DB Stamp 1 Time      TIMEYYYY
DB Stamp 2 Date
DB Stamp 2 Time
Page Count           000
Devices Used         1
Database ID          <servernode>:<serverdb>_DATEXXXX_<timestamp>
Max Used Data Page  000
Converter Page Count 8
 
UTIL_EXECUTE CLEAR LOG!
OK
 
DB_ONLINE!
OK
 
UTIL_RELEASE!
OK
 
UTIL_CONNECT SUT,SUT!
OK
 
UTIL_RELEASE!
OK
 
BYE!
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT!
 
Enter command:
CREATE USER KERN PASSWORD TEST DBA NOT EXCLUSIVE !
 
Enter command:
COMMIT WORK RELEASE !
 
Enter command:
FILE LONG ( LONG !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE L ( K CHAR (8) KEY,
A CHAR (9),
S LONG,
B CHAR (10))!
 
Enter command:
FILE SEL_COLS_TAB ( L !
 
Enter command:
DECLARE SEL_COL CURSOR FOR
 SELECT COLUMNNAME,
        MODE AS "MOD",
        DATATYPE,
        CODETYPE AS "CODE",
        LEN,"DEC",COLUMNPRIVILEGES,"DEFAULT"
   FROM DOMAIN.COLUMNS
  WHERE OWNER <> 'SUT'
    AND TABLENAME = 'L'
  ORDER BY POS !
 
resultcount :                     4
 
Enter command:
FETCH SEL_COL INTO :A,:B,:C,:D,:E,:F,:G,:H !
 
COLUMNNAME        :  K
MOD               :  KEY
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      8
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  A
MOD               :  OPT
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      9
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  S
MOD               :  OPT
DATATYPE          :  LONG
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  B
MOD               :  OPT
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :     10
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
 
resultcount :                     4
 
Enter command:
CLOSE SEL_COL !
 
Enter command:
PARSING !
 
Enter command:
COMMENT ON TABLE L IS :AAA !
parsing idnr :       1
 
Enter command:
EXECUTING!
 
Enter command:
DATA!
 
Enter command:
INSERT !
Parsing idnr :      1
 
l 36 'hier steht der String drin '
 
Enter command:
 *INSERT MIT KURZER 'Long'-COLUMN!
 
Enter command:
PARSING !
 
Enter command:
INSERT L VALUES (:K, :A, :S, :B)!
parsing idnr :       1
 
Enter command:
EXECUTING!
 
Enter command:
DATA!
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'keyvalue'
c 9 'a9a9a9a9a'
l 100 'hier steht der String drin '
c 10 'b10b10b10b'
 
Enter command:
 *INSERT MIT LANGER 'Long'-COLUMN !
 
Enter command:
PARSING !
 
Enter command:
NODATA !
 
Enter command:
INSERT L SET K = :K, S = :S, A = :A, B = :B !
parsing idnr :       1
 
Enter command:
DATA!
 
Enter command:
EXECUTING!
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'second_k'
l 8200 'hier steht der String drin '
c 9 'a9a9a9a9a'
c 10 'b10b10b10b'
 
Enter command:
 *INSERT MIT LONG-COLUMN, DIE DURCH PUTVALS AUFGEFUELLT WIRD !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'third_k'
l 54,0 'hier steht der String drin '
c 9 'a9a9a9a9a'
c 10 'b10b10b10b'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120,0 'Nachschlag 1'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 100,2 'Rest'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 'R'
 
Enter command:
EXECUTING!
 
Enter command:
 * INSERT MIT NULL-WERT ALS DATENEINGABE !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'fourth_k'
c 32
c 9 'aaaaaaaaa'
c 10 'b10b10b10b'
 
Enter command:
 * ABGEBROCHENES PUTVAL PTS 1113250 !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'fifth_k'
l 54,0 'hier steht der String drin '
c 9 'a9a9a9a9a'
c 10 'b10b10b10b'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120,0 'Nachschlag 1'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 100,8 'Rest'
 
Enter command:
 *KONTROLLESEN DER SAETZE !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
maxlen:        100
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *APPEND VON KURZEM WERT IN KURZEN, L‰NGEREN WERT !
 
Enter command:
PARSING !
 
Enter command:
APPEND L SET S = :S KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 50 'appended  '
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
from    101 to    150:appended
maxlen:        150
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *APPEND VON KURZEM WERT IN AUCH NOCH KURZEN WERT
 *MIT LONG-COLUMN, DIE DURCH PUTVALS AUFGEFUELLT WIRD !
 
Enter command:
PARSING !
 
Enter command:
APPEND L SET S = :S KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 34,0 'das ist der 1. Teil '
 
resultcount :                     1
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 80,2 'Rest vom putval '
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 'R'
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
from    101 to    150:appended
from    151 to    184:das ist der 1. Teil
from    185 to    264:Rest vom putval
maxlen:        264
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *APPEND VON KURZEM WERT IN LANGEN WERT !
 
Enter command:
PARSING !
 
Enter command:
APPEND L SET S = :S KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 9000 'looong appended '
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
from    101 to    150:appended
from    151 to    184:das ist der 1. Teil
from    185 to    264:Rest vom putval
from    265 to   9264:looong appended
maxlen:       9264
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *APPEND VON LANGEM WERT IN NOCH L‰NGEREN WERT !
 
Enter command:
PARSING !
 
Enter command:
APPEND L SET S = :S KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 900 'das ist der Rest '
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
from    101 to    150:appended
from    151 to    184:das ist der 1. Teil
from    185 to    264:Rest vom putval
from    265 to   9264:looong appended
from   9265 to  10164:das ist der Rest
maxlen:      10164
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *UPDATE VON BESTEHENDEM WERT IN EXPLIZIT ANGEGEBENES NULL !
 
Enter command:
PARSING !
 
Enter command:
UPDATE L SET S = NULL KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
resultcount :                     1
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *UPDATE VON BESTEHENDEM WERT IN NULL-WERT DURCH DATENEINGABE !
 
Enter command:
PARSING !
 
Enter command:
UPDATE L SET S = :S KEY K = 'second_k' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
c 32
 
resultcount :                     1
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *VORABLESEN DES BESTEHENDEN WERTES !
 
Enter command:
SELECT * FROM L WHERE K = 'third_k' !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     1
 
Enter command:
 *UPDATE EINES BESTEHENDEN WERTES DURCH EINEN NEUEN WERT !
 
Enter command:
 *ANGABE NICHT DURCH KEY ..., SONDERN DURCH WHERE !
 
Enter command:
NODATA!
 
Enter command:
PARSING!
 
Enter command:
UPDATE L SET S = :S WHERE K = 'third_k' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 300 'neuer Text !!!'
 
resultcount :                     1
 
Enter command:
 *KONTROLLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *UPDATE EINES NULL-WERTES DURCH NEUEN WERT, DER DURCH PUTVALS
 *AUFGEF?ULLT WIRD !
 
Enter command:
PARSING !
 
Enter command:
UPDATE L SET S = :S WHERE A = 'aaaaaaaaa' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 1,3 'v'
 
resultcount :                     1
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 30,0 'neuer Text !!!'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120,0 'Nachschlag 1'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 100,2 'Rest'
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
COMMIT !
 
Enter command:
 *MEHRERE SAETZE DUERFEN DOCH GLEICHZEITIG GEAENDERT WERDEN !
 
Enter command:
PARSING!
 
Enter command:
UPDATE L SET S = :S WHERE K <= 'st' AND A = 'a9a9a9a9a'!
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 300 'neuer Text fuer mehrere Saetze !'
 
resultcount :                     2
 
Enter command:
NODATA!
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
ROLLBACK !
 
Enter command:
PARSING!
 
Enter command:
UPDATE L (S) VALUES (:S) !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 300 'noch neuerer Text fuer mehrere Saetze !'
 
resultcount :                     4
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to    300:noch neuerer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    300:noch neuerer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:noch neuerer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:noch neuerer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
ROLLBACK !
 
Enter command:
 * TEST WITH CORRELATION AND MORE THAN ONE RECORD !
 
Enter command:
 CREATE TABLE L1 AS SELECT K, A, B FROM L!
 
Enter command:
PARSING !
 
Enter command:
UPDATE L SET S = :S WHERE A = 'a9a9a9a9a'
AND K IN (SELECT K FROM L1 WHERE L1.K = L.K) !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:S   0014
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
ROLLBACK !
 
Enter command:
 * TEST WITH ARRAY COMMAND AND MORE THAN ONE RECORD !
 
Enter command:
PARSING !
 
Enter command:
MUPDATE L SET S = :S WHERE K BETWEEN :K1 AND :K2 !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
MUPDATE    T!
32767
-2
Parsing idnr :      1
 
l 240 'die ersten zwei keys kriegen den long-value'
c 8 'fourth_k' c 8 'keyvalue'
l 300 'die letzten zwei keys kriegen einen anderen long-value'
c 8 'second_k' c 8 'third_k'
 
resultcount :                     4
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to    240:die ersten zwei keys kriegen den long-value
maxlen:        240
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    240:die ersten zwei keys kriegen den long-value
maxlen:        240
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:die letzten zwei keys kriegen einen anderen long-value
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:die letzten zwei keys kriegen einen anderen long-value
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
ROLLBACK !
 
Enter command:
SELECT K, A, B FROM L WHERE S IS NULL !
 
resultcount :               unknown
 
Enter command:
SELECT K, A, B FROM L WHERE S IS NOT NULL !
 
resultcount :               unknown
 
Enter command:
SELECT K, A, B FROM L WHERE S = 'neuer Text'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0029
 
Enter command:
PARS_THEN_EX !
 
Enter command:
SELECT K, A, B FROM L WHERE S IS NULL !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K        | A         | B
---------+-----------+-----------
keyvalue | a9a9a9a9a | b10b10b10b
second_k | a9a9a9a9a | b10b10b10b
 
resultcount :                     2
 
Enter command:
SELECT K, A, B FROM L WHERE S IS NOT NULL !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K        | A         | B
---------+-----------+-----------
fourth_k | aaaaaaaaa | b10b10b10b
third_k  | a9a9a9a9a | b10b10b10b
 
resultcount :                     2
 
Enter command:
SELECT K, A, B FROM L WHERE S = 'neuer Text'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0029
 
Enter command:
SELECT K, A, B FROM L WHERE S LIKE 'neuer Text%'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0029
 
Enter command:
SELECT K, A, B FROM L WHERE DEFAULT < S !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0029
 
Enter command:
SELECT K, A, B FROM L WHERE S = DEFAULT !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0033
 
Enter command:
COMMIT !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
DELETE L KEY K = 'second_k' !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     3
 
Enter command:
ROLLBACK !
 
Enter command:
CREATE TABLE T ( A CHAR ( 8) KEY, B LONG, B1 LONG, C CHAR(32)) !
 
Enter command:
PARSING !
 
Enter command:
MINSERT T VALUES (:A, :B, :B1, :C) !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
MINSERT    T!
32767
2
Parsing idnr :      1
 
c 8 'aaa' l 1000 'a' l 10 'b1eins    ' c 32 'eins'
c 8 'bbb' l 500  'a' l 10,0 'b1zweib1  ' c 32 'zwei'
 
resultcount :                     2
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1000,1 'erster Teil f¸r zwei '
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 'R'
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A                 :  aaa
B                 :
from      1 to   1000:a
maxlen:       1000
B1                :  b1eins
C                 :  eins
-----------------------------------------------------------------------
A                 :  bbb
B                 :
from      1 to    500:a
maxlen:        500
B1                :
from      1 to      8:b1zwei
from      9 to     10:
from     11 to     16:erst
from     17 to   1010: Teil f¸r zwei erster
maxlen:       1010
C                 :  zwei
 
resultcount :                     2
 
Enter command:
CHECK TABLE T WITH LONG CHECK !
 
Enter command:
ROLLBACK !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
 *GEHT DAS AUCH MIT MEHREREN LONG-COLUMNS IN EINER TABELLE ? !
 
Enter command:
CREATE TABLE T2 (
   K  CHAR (8) KEY,
   S1 LONG ,
   A  CHAR (2),
   S2 LONG BYTE)!
 
Enter command:
FILE SEL_COLS_TAB ( T2 !
 
Enter command:
DECLARE SEL_COL CURSOR FOR
 SELECT COLUMNNAME,
        MODE AS "MOD",
        DATATYPE,
        CODETYPE AS "CODE",
        LEN,"DEC",COLUMNPRIVILEGES,"DEFAULT"
   FROM DOMAIN.COLUMNS
  WHERE OWNER <> 'SUT'
    AND TABLENAME = 'T2'
  ORDER BY POS !
 
resultcount :                     4
 
Enter command:
FETCH SEL_COL INTO :A,:B,:C,:D,:E,:F,:G,:H !
 
COLUMNNAME        :  K
MOD               :  KEY
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      8
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  S1
MOD               :  OPT
DATATYPE          :  LONG
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  A
MOD               :  OPT
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      2
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  S2
MOD               :  OPT
DATATYPE          :  LONG
CODE              :  BYTE
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
 
resultcount :                     4
 
Enter command:
CLOSE SEL_COL !
 
Enter command:
 * IN CASE PUTVAL IS DONE SEPARATELY FOR BOTH COLUMNS, THE SECOND ONE
 * USES THE DESCRIPTION OF THE FIRST ONE --> IN CASE OF UNICODE-DEFCODE
 * S2-INPUT WILL NOT BE HANDLED AS BYTE, BUT AS UNICODE -->
 * 'l' X'00' '2' X'00' !
 
Enter command:
PARSING !
 
Enter command:
INSERT T2 VALUES (:K, :S1, :A, :S2)!
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'keyvalue'
l 100 'tri tra tralala...'
c 2 'a9'
l 100 "hier steht der String drin "
 
Enter command:
EXECUTING!
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'second_k'
l 2500 'tritratralala...'
c 2 'a9'
c 32
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'third_k'
l 1,3 't'
c 2 'a9'
l 1,3 "m"
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120 'l1 l1 l1 '
l 1,3 "m"
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 420 "l2 l2 l2 "
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 "c"
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'fourth_k'
l 100,0 't'
c 2 'a9'
l 1,3 "m"
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120,2 'l1 l1 l1 '
l 1,3 "m"
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 420 "l2 l2 l2 "
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 "c"
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T2 !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
S1                :
from      1 to    100:t
from    101 to    220:l1
maxlen:        220
A                 :  a9
S2                :
from      1 to    420:l2
maxlen:        420
-----------------------------------------------------------------------
K                 :  keyvalue
S1                :
from      1 to      6:tri
from      7 to    100:a tralala...tri tr
maxlen:        100
A                 :  a9
S2                :
from      1 to    100:hier steht der String drin
maxlen:        100
-----------------------------------------------------------------------
K                 :  second_k
S1                :
from      1 to      5:tri
from      6 to   2500:atralala...tritr
maxlen:       2500
A                 :  a9
S2                :  ?????
-----------------------------------------------------------------------
K                 :  third_k
S1                :
from      1 to    120:l1
maxlen:        120
A                 :  a9
S2                :
from      1 to    420:l2
maxlen:        420
 
resultcount :                     4
 
Enter command:
DELETE T2 !
 
resultcount :                     4
 
Enter command:
DIAGNOSE SHARE PARSE DROP !
 
Enter command:
SELECT * FROM T2 !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
PARSING !
 
Enter command:
CREATE VIEW VLONG AS SELECT * FROM L !
parsing idnr :       1
 
Enter command:
PARSING !
 
Enter command:
SELECT RL.K, RL.A, RL.S, RL.B
        INTO :K1, :A1, :S1, :B1,
             :K0, :A0, :S0, :B0
        FROM L, L RL
        WHERE L.K = 'second_k' AND RL.K = 'second_k'!
parsing idnr :       1
 
Enter command:
 
SELECT *
        INTO :K1, :A1, :S1, :B1,
             :K0, :A0, :S0, :B0
        FROM L, L RL
        WHERE L.K = 'second_k' AND RL.K = 'second_k'!
parsing idnr :       2
 
Enter command:
SELECT DISTINCT *
        INTO :K1, :A1, :S1, :B1
        FROM L
        WHERE K = 'second_k'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:S   0017
 
Enter command:
SELECT K, A, S, B
        FROM L
        WHERE K = 'second_k'
UNION
SELECT K, A, S, B
        FROM L
        WHERE K = 'keyvalue'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:S   0001
 
Enter command:
SELECT * FROM (SELECT K, A, S, B
        FROM L
        WHERE K = 'keyvalue') !
parsing idnr :       3
 
Enter command:
PARS_THEN_EX !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH INTO :A, :B, :C, :D!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
DECLARE ERG CURSOR FOR
SELECT * FROM L FOR REUSE !
 
resultcount :                     4
 
Enter command:
DROP TABLE L !
 
Enter command:
DIAGNOSE SHARE PARSE DROP !
 
Enter command:
FETCH ERG INTO :A, :B, :C, :D !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
DROP TABLE T2 !
 
Enter command:
COMMIT WORK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE X (K CHAR (8) KEY)!
 
Enter command:
CREATE TABLE T ( A CHAR (8),
    FOREIGN KEY (A) REFERENCES X (K))!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T SET A = :A!
 
c 8 'fff'
 
***ERROR    350 Referential integrity violated:X_T,KERN,T                  0001
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
CREATE TABLE T1 (A CHAR (8),
                 L LONG,
    FOREIGN KEY (A) REFERENCES X (K))!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T1 SET A = :A, L = :L!
 
c 8 'fff'
l 7800,0 'Text '
 
***ERROR    350 Referential integrity violated:X_T1,KERN,T1                0001
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), S LONG, B CHAR (8))!
 
Enter command:
INSERT T SET A = 'firstval', B = 'bbbb'!
 
Enter command:
PARSING !
 
Enter command:
INSERT T VALUES (:A, :S, :B)!
parsing idnr :       1
 
Enter command:
EXECUTING!
 
Enter command:
DATA!
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'keyvalue'
l 100 'hier steht der String drin '
c 8 'b10b10b1'
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
MFETCH FIRST !
7
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
Enter command:
SELECT A, S, B FROM T FOR REUSE!
 
resultcount :                     2
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
MFETCH FIRST !
7
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
Enter command:
PARS_THEN_EX !
 
Enter command:
PARS_EXECUTE !
 
Enter command:
CREATE VIEW V1 AS SELECT * FROM T !
 
Enter command:
CREATE TABLE T1 AS SELECT * FROM T !
 
Enter command:
CREATE TABLE T2 AS SELECT * FROM V1 !
 
Enter command:
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
SELECT * FROM T1!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
SELECT * FROM V1!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
SELECT * FROM T2!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
    CREATE TABLE SYSDDMODULE
      (
       OWNER       CHAR(64) ASCII DEFAULT USERGROUP,
       MODULNAM1   CHAR(64) ASCII DEFAULT ' ',
       MODULNAM2   CHAR(64) ASCII DEFAULT ' ',
       PROGLANG    CHAR(64) ASCII DEFAULT ' ',
       OBJTYPE     CHAR(18) ASCII DEFAULT 'MODULE',
       SUBTYPE     CHAR(12) ASCII DEFAULT ' ',
       VERSION     CHAR(4)  ASCII DEFAULT ' ',
       LONGNAME    CHAR(40) ASCII DEFAULT ' ',
       TYPE        CHAR(18) ASCII DEFAULT ' ',
       CREATEDATE  DATE DEFAULT DATE,
       CREATETIME  TIME DEFAULT TIME,
       UPDDATE     DATE DEFAULT DATE,
       UPDTIME     TIME DEFAULT TIME,
       COMMENT     LONG     ASCII
      ) !
 
Enter command:
    CREATE TABLE SYSDDUSR_USES_PRO
      (
       USER_ID     FIXED(10)       KEY,
       ROW_ID      CHAR(8)   BYTE  KEY,
       DEFOWNER    CHAR(64)  ASCII,
       DEFOBJN1    CHAR(64)  ASCII DEFAULT ' ',
       DEFOBJN2    CHAR(64)  ASCII DEFAULT ' ',
       DEFOBJN3    CHAR(64)  ASCII DEFAULT ' ',
       DEFOBJTYPE  CHAR(18)  ASCII DEFAULT 'USER',
       DEFSUBTYPE  CHAR(12)  ASCII DEFAULT ' ',
       DEFVERSION  CHAR(4)   ASCII DEFAULT ' ',
       RELTYPE     CHAR(18)  ASCII DEFAULT 'USES',
       REFOWNER    CHAR(64)  ASCII,
       REFOBJN1    CHAR(64)  ASCII DEFAULT ' ',
       REFOBJN2    CHAR(64)  ASCII DEFAULT ' ',
       REFOBJN3    CHAR(64)  ASCII DEFAULT ' ',
       REFOBJTYPE  CHAR(18)  ASCII DEFAULT 'PROGRAM',
       REFSUBTYPE  CHAR(12)  ASCII DEFAULT ' ',
       REFVERSION  CHAR(4)   ASCII DEFAULT ' ',
       PRIVILEGES  CHAR(40)  ASCII DEFAULT 'EXECUTE',
       CREATEDATE  DATE DEFAULT DATE,
       CREATETIME  TIME DEFAULT TIME
      ) !
 
Enter command:
    GRANT SELECT ON SYSDDUSR_USES_PRO TO PUBLIC !
 
Enter command:
CREATE VIEW SYSDD_USR_USES_PRO
  (DEFOBJTYPE,DEFOWNER,DEFUSERNAME,DEFGROUPNAME,RELTYPE,
   REFOBJTYPE,REFOWNER,REFPROGRAMNAME,REFPROGLANG,CREATEDATE,CREATETIME)
AS SELECT
     DEFOBJTYPE,DEFOWNER,DEFOBJN1,DEFOBJN2,RELTYPE,
     REFOBJTYPE,REFOWNER,REFOBJN1,REFOBJN3,CREATEDATE,CREATETIME
   FROM SYSDDUSR_USES_PRO
   WHERE DEFOBJN1 IN(USERGROUP,'*PUBLIC*') OR DEFOBJN2 = USERGROUP
WITH CHECK OPTION !
 
Enter command:
INSERT SYSDDMODULE SET
       OWNER       = USER,
       MODULNAM1 = 'module',
       MODULNAM2 = 'noch ein module',
       PROGLANG    = 'programm',
       OBJTYPE     = 'objekt',
       SUBTYPE     = 'subtype',
       VERSION     = '1.',
       LONGNAME    = 'recht lang',
       TYPE        = 'typ',
       CREATEDATE  = DATE,
       CREATETIME  = TIME,
       UPDDATE     = DATE,
       UPDTIME     = TIME!
 
Enter command:
PARSING !
 
Enter command:
UPDATE SYSDDMODULE SET COMMENT = :A WHERE OWNER = USER !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 500 'der Kommentar: '
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
INSERT SYSDDUSR_USES_PRO VALUES
(1, X'0000000000000001', USERGROUP, USERGROUP, USERGROUP, USERGROUP,
'objekt', 'subtype', '1.', 'needs',
USERGROUP, USERGROUP, USERGROUP, USERGROUP,
'objekt 2', 'subtype 2', '2.', 'keine', DATE, TIME) !
 
Enter command:
GRANT ALL ON SYSDD_USR_USES_PRO TO PUBLIC !
 
Enter command:
SELECT
  T1.OWNER,T1.MODULNAM1,T1.MODULNAM2,T1.PROGLANG,
  T1.CREATEDATE,T1.CREATETIME,T1.COMMENT
FROM SYSDDMODULE T1, SYSDD_USR_USES_PRO T2
WHERE T1.OWNER = T2.REFOWNER OR T1.OWNER = USERGROUP !
 
resultcount :                     1
 
Enter command:
FETCH !
 
OWNER             :  KERN
MODULNAM1         :  module
MODULNAM2         :  noch ein module
PROGLANG          :  programm
CREATEDATE        :  DATEXXXX
CREATETIME        :  TIMEYYYY
COMMENT           :
from      1 to    500:der Kommentar:
maxlen:        500
 
resultcount :                     1
 
Enter command:
ROLLBACK !
 
Enter command:
CREATE TABLE T ( A CHAR (8) KEY, B LONG, C FIXED (8))!
 
Enter command:
PARSING !
 
Enter command:
INSERT T VALUES ('aaa', :B, 4 * 3)!
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
INSERT T VALUES ('aaa', :B, 4 * 3)!
Parsing idnr :      1
 
l 400 'xyz '
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA!
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | B                                                  | C
---------+----------------------------------------------------+----------
aaa      | xyz xyz xyz xyz xyz xyz xyz xyz xyz xyz xyz xyz xy |        12
 
resultcount :                     1
 
Enter command:
CREATE TABLE T1 ( A CHAR (8), C FIXED (8))!
 
Enter command:
INSERT T1 VALUES ('aaa', 25)!
 
Enter command:
DECLARE INVISIBLE CURSOR FOR
SELECT DESCRIPTION,
       VALUE (CHR(NUMERIC_VALUE), CHAR_VALUE) "VALUE"
  FROM SYSDBA.TABLESTATISTICS
 WHERE OWNER = 'KERN'
   AND TABLENAME = 'T' !
 
resultcount :                    35
 
Enter command:
DECLARE ERG CURSOR FOR
SELECT COUNT(*) CNT FROM T WHERE B IS NOT NULL!
 
resultcount :                     1
 
Enter command:
SELECT CNT, VALUE FROM INVISIBLE, ERG
WHERE DESCRIPTION = 'DEFINED LONG COLUMNS'
  AND NUM(VALUE) <> CNT !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
FETCH !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
CLOSE INVISIBLE !
 
Enter command:
INSERT T(A,C) SELECT A, C FROM T1 !
 
***ERROR    200 Duplicate key                                              0001
 
Enter command:
INSERT T(A,C) SELECT A, C FROM T1 UPDATE DUPLICATES !
 
Enter command:
DECLARE INVISIBLE CURSOR FOR
SELECT DESCRIPTION,
       VALUE (CHR(NUMERIC_VALUE), CHAR_VALUE) "VALUE"
  FROM SYSDBA.TABLESTATISTICS
 WHERE OWNER = 'KERN'
   AND TABLENAME = 'T' !
 
resultcount :                    35
 
Enter command:
DECLARE ERG CURSOR FOR
SELECT COUNT(*) CNT FROM T WHERE B IS NOT NULL!
 
resultcount :                     1
 
Enter command:
SELECT CNT, VALUE FROM INVISIBLE, ERG
WHERE DESCRIPTION = 'DEFINED LONG COLUMNS'
  AND NUM(VALUE) <> CNT !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
FETCH !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
CLOSE INVISIBLE !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT (KERN TEST!
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TA (A CHAR)!
 
Enter command:
ALTER  TABLE TA ADD  L LONG!
 
Enter command:
ALTER  TABLE TA DROP L!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
CREATE TABLE TA (A CHAR, L LONG)!
 
Enter command:
ALTER  TABLE TA ADD  L2 LONG!
 
Enter command:
ALTER  TABLE TA DROP L2!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
CREATE TABLE TA (A CHAR, L LONG, L2 LONG)!
 
Enter command:
ALTER  TABLE TA ADD  L2 LONG!
 
***ERROR  -6001 Duplicate column name:L2                                   0022
 
Enter command:
ALTER  TABLE TA DROP L2!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
ROLLBACK WORK RELEASE!
 
Enter command:
FILE CONNECT (KERN TEST SQLMODE ORACLE!
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST SQLMODE ORACLE ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TA (A CHAR)!
 
Enter command:
ALTER  TABLE TA ADD  L LONG!
 
Enter command:
ALTER  TABLE TA DROP (L)!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
CREATE TABLE TA (A CHAR, L LONG)!
 
Enter command:
ALTER  TABLE TA ADD  L2 LONG!
 
Enter command:
ALTER  TABLE TA DROP (L2)!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
CREATE TABLE TA (A CHAR, L LONG, L2 LONG)!
 
Enter command:
DROP   TABLE TA !
 
Enter command:
COMMIT WORK RELEASE!
 
Enter command:
FILE CONNECT (KERN TEST!
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 
CREATE TABLE LT1 (
K1 CHAR KEY ,
K2 CHAR KEY ,
L11 LONG BYTE DEFAULT X'31323334',
L12 LONG ) !
 
Enter command:
 
CREATE TABLE LT2 (
L21 LONG BYTE DEFAULT X'35363738',
L22 LONG ASCII ) !
 
Enter command:
 
CREATE VIEW LV1 AS SELECT * FROM LT1 !
 
Enter command:
CREATE VIEW LV2 AS SELECT * FROM LT2 !
 
Enter command:
 
CREATE VIEW LV12 AS SELECT * FROM LT1, LT2 !
 
Enter command:
 
FILE SEL_COLS_TAB ( LV12 !
 
Enter command:
DECLARE SEL_COL CURSOR FOR
 SELECT COLUMNNAME,
        MODE AS "MOD",
        DATATYPE,
        CODETYPE AS "CODE",
        LEN,"DEC",COLUMNPRIVILEGES,"DEFAULT"
   FROM DOMAIN.COLUMNS
  WHERE OWNER <> 'SUT'
    AND TABLENAME = 'LV12'
  ORDER BY POS !
 
resultcount :                     6
 
Enter command:
FETCH SEL_COL INTO :A,:B,:C,:D,:E,:F,:G,:H !
 
COLUMNNAME        :  K1
MOD               :  MAN
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      1
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  K2
MOD               :  MAN
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      1
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  L11
MOD               :  OPT
DATATYPE          :  LONG
CODE              :  BYTE
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  323334
--------------------------------------------------------------------------------
COLUMNNAME        :  L12
MOD               :  OPT
DATATYPE          :  LONG
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  L21
MOD               :  OPT
DATATYPE          :  LONG
CODE              :  BYTE
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  363738
--------------------------------------------------------------------------------
COLUMNNAME        :  L22
MOD               :  OPT
DATATYPE          :  LONG
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  ?????
 
resultcount :                     6
 
Enter command:
CLOSE SEL_COL !
 
Enter command:
 
INSERT LT1 SET K1 = 'a', K2 = 'z', L11 = DEFAULT, L12 = '012' !
 
Enter command:
INSERT LT1 SET K1 = 'z', K2 = 'a', L12 = '012' !
 
Enter command:
 
INSERT LT2 SET L21 = DEFAULT, L22 = X'333435' !
 
Enter command:
INSERT LT2 SET L22 = X'333435' !
 
Enter command:
 
SELECT * FROM LV12 !
 
resultcount :                     4
 
Enter command:
FETCH !
 
K1                :  a
K2                :  z
L11               :  1234
L12               :  012
L21               :  5678
L22               :  345
-----------------------------------------------------------------------
K1                :  a
K2                :  z
L11               :  1234
L12               :  012
L21               :  5678
L22               :  345
-----------------------------------------------------------------------
K1                :  z
K2                :  a
L11               :  1234
L12               :  012
L21               :  5678
L22               :  345
-----------------------------------------------------------------------
K1                :  z
K2                :  a
L11               :  1234
L12               :  012
L21               :  5678
L22               :  345
 
resultcount :                     4
 
Enter command:
 
INSERT LT1 SET K1 = 'b', K2 = 'y',
L11 =
'Dies sind 1400 Zeichen insgesamt (viele As und ein X): aaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaax'
, L12 = 'hallo' !
 
Enter command:
 
 *KONTROLLESEN DER SAETZE !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM LT1 !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K1                :  a
K2                :  z
L11               :  1234
L12               :  012
-----------------------------------------------------------------------
K1                :  b
K2                :  y
L11               :
from      1 to    110:Dies sind 1400 Zeichen insgesamt (viele As und ein X): aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
from    111 to   1399:a
from   1400 to   1400:x
maxlen:       1400
L12               :  hallo
-----------------------------------------------------------------------
K1                :  z
K2                :  a
L11               :  1234
L12               :  012
 
resultcount :                     3
 
Enter command:
ROLLBACK WORK RELEASE!
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A LONG DEFAULT 'das ist der Long-Default-Wert',
B CHAR (8) PRIMARY KEY )!
 
Enter command:
INSERT T SET B = 'erstens' !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A                                                  | B
---------------------------------------------------+---------
das ist der Long-Default-Wert                      | erstens
 
resultcount :                     1
 
Enter command:
INSERT T VALUES (DEFAULT, 'zweitens') !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A                                                  | B
---------------------------------------------------+---------
das ist der Long-Default-Wert                      | erstens
das ist der Long-Default-Wert                      | zweitens
 
resultcount :                     2
 
Enter command:
SELECT * FROM T WHERE A = DEFAULT !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0027
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
FILE SEL_COLS_TAB ( T !
 
Enter command:
DECLARE SEL_COL CURSOR FOR
 SELECT COLUMNNAME,
        MODE AS "MOD",
        DATATYPE,
        CODETYPE AS "CODE",
        LEN,"DEC",COLUMNPRIVILEGES,"DEFAULT"
   FROM DOMAIN.COLUMNS
  WHERE OWNER <> 'SUT'
    AND TABLENAME = 'T'
  ORDER BY POS !
 
resultcount :                     2
 
Enter command:
FETCH SEL_COL INTO :A,:B,:C,:D,:E,:F,:G,:H !
 
COLUMNNAME        :  A
MOD               :  OPT
DATATYPE          :  LONG
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  das ist der Long-Default-Wert
--------------------------------------------------------------------------------
COLUMNNAME        :  B
MOD               :  KEY
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      8
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
 
resultcount :                     2
 
Enter command:
CLOSE SEL_COL !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T (
A CHAR (8) KEY,
B CHAR (5) KEY,
C CHAR (3) KEY,
D CHAR (12) KEY,
E FIXED (2) KEY,
F CHAR (20),
G CHAR (30),
H LONG )!
 
Enter command:
CREATE VIEW V (A,B,C,D,E) AS SELECT A,B,C,D,E FROM T !
 
Enter command:
DELETE V WHERE A = 'a' AND B = 'b' AND C = 'c' !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), B LONG, C LONG)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T SET A = 'abc',
B = 'das soll der long sein', C = 'das ist der neuere Long'!
 
Enter command:
 
INSERT T SET A = '2a2b2c', B = :B,
 C = 'das ist der neuere Long'!
 
 l 5000 'das soll der long sein '
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :  abc
B                 :  das soll der long sein
C                 :  das ist der neuere Long
-----------------------------------------------------------------------
A                 :  2a2b2c
B                 :
from      1 to   5000:das soll der long sein
maxlen:       5000
C                 :  das ist der neuere Long
 
resultcount :                     2
 
Enter command:
DECLARE ERG CURSOR FOR
SELECT * FROM T FOR REUSE !
 
resultcount :                     2
 
Enter command:
DROP TABLE T !
 
Enter command:
DIAGNOSE SHARE PARSE DROP !
 
Enter command:
FETCH ERG !
 
A                 :  abc
B                 :
C                 :
-----------------------------------------------------------------------
A                 :  2a2b2c
B                 :
C                 :
 
resultcount :                     2
 
Enter command:
COMMIT !
 
Enter command:
 * JUST TO SPENT SOME TIME TO LET GARBAGE COLLECTOR CLEAN LONG-FILE !
 
Enter command:
 * > 3 MIN AS GARBAGE-COLLECTOR WILL WORK AT LEAST AFTER 3 MIN !
 
Enter command:
SLEEP 10 !
COMMIT RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TTT ( L LONG )!
 
Enter command:
INSERT INTO TTT SET L = 1!
 
***ERROR  -8004 Constant must be compatible with column type and length    0025
 
Enter command:
ROLLBACK RELEASE!
 
Enter command:
FILE CONNECT (KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE HUGO ( I INT, L LONG DEFAULT 'kkk')!
 
Enter command:
INSERT INTO HUGO VALUES( 1, '111' )!
 
Enter command:
SELECT * INTO :A, :B FROM HUGO !
 
I                 :            1
L                 :  111
 
Enter command:
UPDATE HUGO SET I=2,L='2222'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0024
 
Enter command:
SELECT * INTO :A, :B FROM HUGO !
 
I                 :            1
L                 :  111
 
Enter command:
UPDATE HUGO SET L = NULL!
 
resultcount :                     1
 
Enter command:
SELECT * INTO :A, :B FROM HUGO !
 
I                 :            1
L                 :  ?????
 
Enter command:
UPDATE HUGO SET L = DEFAULT!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0021
 
Enter command:
SELECT * INTO :A, :B FROM HUGO !
 
I                 :            1
L                 :  ?????
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT (KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TAB170
 ( COL1  LONG,
   COL2  LONG CONSTRAINT FK_COL1_SELFREF REFERENCES  TAB170(COL1),
     CONSTRAINT PK_COL1 PRIMARY  KEY (COL1)) !
 
***ERROR  -7002 KEY not allowed                                            0132
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), B FIXED (7))!
 
Enter command:
INSERT T VALUES ('aaa', 1)!
 
Enter command:
CREATE TABLE T2 ( A VARCHAR (8)NOT NULL DEFAULT '',
A1 LONG NOT NULL DEFAULT '', B FIXED(7))!
 
Enter command:
INSERT INTO T2 (B) VALUES (17)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
INSERT INTO T2 (B) VALUES (44)!
 
Enter command:
PARS_EXECUTE !
 
Enter command:
INSERT INTO T2 (B) SELECT B FROM T !
 
Enter command:
SELECT * FROM T2 !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A        | A1                                                 | B
---------+----------------------------------------------------+---------
         |                                                    |       17
         |                                                    |       44
         |                                                    |        1
 
resultcount :                     3
 
Enter command:
CREATE TABLE T3 ( A VARCHAR (8)NOT NULL DEFAULT 'r',
A1 LONG NOT NULL DEFAULT 'r', B FIXED(7))!
 
Enter command:
INSERT INTO T3 (B) VALUES (17)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
INSERT INTO T3 (B) VALUES (44)!
 
Enter command:
PARS_EXECUTE !
 
Enter command:
INSERT INTO T3 (B) SELECT B FROM T !
 
Enter command:
SELECT * FROM T3 !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A        | A1                                                 | B
---------+----------------------------------------------------+---------
r        | r                                                  |       17
r        | r                                                  |       44
r        | r                                                  |        1
 
resultcount :                     3
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T1 (S1 INT, S2 CHAR (10), S3 LONG) !
 
Enter command:
    INSERT T1 VALUES (1, 'Hallo', 'long value') !
 
Enter command:
    INSERT T1 VALUES (1, 'BYE BYE', NULL) !
 
Enter command:
CREATE TABLE T2
    AS SELECT (S1 - 1) S1, S2 FROM T1 !
 
Enter command:
CREATE VIEW V1
    AS SELECT * FROM T1 !
 
Enter command:
SELECT * FROM V1 !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
S1          | S2         | S3
------------+------------+---------------------------------------------------
          1 | Hallo      | long value
          1 | BYE BYE    | ??????????????????????????????????????????????????
 
resultcount :                     2
 
Enter command:
CREATE VIEW V2
    AS SELECT * FROM T1 WHERE T1.S1 NOT IN (SELECT S1 FROM T2) !
 
Enter command:
SELECT * FROM V2!
 
resultcount :                     2
 
Enter command:
FETCH !
 
S1          | S2         | S3
------------+------------+---------------------------------------------------
          1 | Hallo      | long value
          1 | BYE BYE    | ??????????????????????????????????????????????????
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TAB6 (
 A1 LONG ,
 A2 CHAR(515)
   )!
 
Enter command:
INSERT INTO TAB6 VALUES( '§bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶',
         '§bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶' )!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT INTO TAB6 VALUES( :P,
         '§bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶' )!
 
l 30 '§bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶'
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM TAB6!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A1                :  §bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶
A2                :  §bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶
--------------------------------------------------------------------------------
A1                :  §bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶§
A2                :  §bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A INT, B INT, C INT,
                 PRIMARY KEY (A,B,C),
                 D INT,
                 E LONG)!
 
Enter command:
INSERT INTO T VALUES (1,1,1,1,'alter Wert')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
UPDATE T SET C =C+1, E = :LONG
   WHERE A = 1 AND B = 1 AND D = 1!
 
l 300 'neuer Wert '
 
resultcount :                     1
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :            1
B                 :            1
C                 :            2
D                 :            1
E                 :
from      1 to    300:neuer Wert
maxlen:        300
 
resultcount :                     1
 
Enter command:
UPDATE T SET C =C+1
   WHERE A = 1 AND B = 1 AND D = 1!
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE !
 
Enter command:
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :            1
B                 :            1
C                 :            3
D                 :            1
E                 :
from      1 to    300:neuer Wert
maxlen:        300
 
resultcount :                     1
 
Enter command:
UPDATE T SET C =C+1, E = NULL
   WHERE A = 1 AND B = 1 AND D = 1!
 
resultcount :                     1
 
Enter command:
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :            1
B                 :            1
C                 :            4
D                 :            1
E                 :  ?????
 
resultcount :                     1
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( K CHAR (8) PRIMARY KEY,A CHAR (8),
   B FIXED (7), C LONG BYTE)!
 
Enter command:
INSERT INTO T VALUES ('key', 'aaa', 1, NULL)!
 
Enter command:
CREATE TABLE DUMMY_LONG (DUMMYLONG LONG BYTE)!
 
Enter command:
INSERT DUMMY_LONG VALUES (NULL)!
 
Enter command:
SELECT K,A,B,C FROM T
UNION ALL
SELECT 'k2', NULL, NULL, NULL FROM DUAL, DUMMY_LONG
ORDER BY 1!
 
resultcount :                     2
 
Enter command:
MFETCH!
2
 
K                 :  k2
A                 :  ?????
B                 :  ????????
C                 :  ?????
-----------------------------------------------------------------------
K                 :  key
A                 :  aaa
B                 :         1
C                 :  ?????
 
Enter command:
 
SELECT K,A,B,C FROM T
UNION ALL
SELECT 'k2', NULL, NULL, DUMMYLONG FROM DUAL, DUMMY_LONG
ORDER BY 1!
 
resultcount :                     2
 
Enter command:
MFETCH!
2
 
K                 :  k2
A                 :  ?????
B                 :  ????????
C                 :  ?????
-----------------------------------------------------------------------
K                 :  key
A                 :  aaa
B                 :         1
C                 :  ?????
 
Enter command:
 
ROLLBACK RELEASE !
 
Enter command:
SENDERID ODB!
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 CREATE TABLE TEST2 (
    FRAGMENTAPPLET  LONG VARCHAR DEFAULT ' ',
    FRAGMENTCREATED DATE         DEFAULT DATE,
    FRAGMENTID      INTEGER      NOT NULL PRIMARY KEY
 )!
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTCREATED,FRAGMENTID
    ) VALUES (
    '1999-01-01',-1 )
!
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTCREATED,FRAGMENTID
    )
    SELECT DATE, 4711 FROM DUAL !
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTCREATED,FRAGMENTID
    ) VALUES (
    DATE('1999-01-01'),0 )
!
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTAPPLET,FRAGMENTCREATED,FRAGMENTID
    ) VALUES (
    'test applet',DATE('1999-01-23'),3 )
!
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTAPPLET,FRAGMENTCREATED,FRAGMENTID
    ) VALUES (
    'test applet','1999-01-23',4 )!
 
Enter command:
INSERT TEST2 SELECT FRAGMENTAPPLET,FRAGMENTCREATED,FRAGMENTID+100
FROM TEST2!
 
Enter command:
DECLARE C CURSOR FOR SELECT * FROM TEST2 FOR REUSE!
 
resultcount :                    10
 
Enter command:
FETCH C!
 
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  1999-01-01
FRAGMENTID        :           -1
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  1999-01-01
FRAGMENTID        :            0
-----------------------------------------------------------------------
FRAGMENTAPPLET    :  test applet
FRAGMENTCREATED   :  1999-01-23
FRAGMENTID        :            3
-----------------------------------------------------------------------
FRAGMENTAPPLET    :  test applet
FRAGMENTCREATED   :  1999-01-23
FRAGMENTID        :            4
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  1999-01-01
FRAGMENTID        :           99
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  1999-01-01
FRAGMENTID        :          100
-----------------------------------------------------------------------
FRAGMENTAPPLET    :  test applet
FRAGMENTCREATED   :  1999-01-23
FRAGMENTID        :          103
-----------------------------------------------------------------------
FRAGMENTAPPLET    :  test applet
FRAGMENTCREATED   :  1999-01-23
FRAGMENTID        :          104
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  YYYY-MM-DD
FRAGMENTID        :         4711
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  YYYY-MM-DD
FRAGMENTID        :         4811
 
resultcount :                    10
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
SENDERID XCI!
 * PTS 1123714-7 !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TEST (ID INTEGER, LONG_COL LONG BYTE)!
 
Enter command:
INSERT INTO TEST VALUES (1, 'aa')!
 
Enter command:
INSERT INTO TEST VALUES (1, 'bb')!
 
Enter command:
INSERT INTO TEST VALUES (2, 'cc')!
 
Enter command:
 
SELECT DISTINCT ID FROM TEST WHERE ID IS NOT NULL!
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE LONG_COL IS NOT NULL!
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM
   (SELECT ID FROM TEST WHERE LONG_COL IS NOT NULL) !
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE ID IN
   (SELECT ID FROM TEST WHERE LONG_COL IS NOT NULL) !
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE ID IN
   (SELECT ID FROM TEST WHERE LONG_COL IS NOT NULL AND ROWNO <= 1000000) !
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID, LONG_COL FROM TEST WHERE LONG_COL IS NOT NULL!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:LON 0021
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
SELECT DISTINCT ID FROM
   (SELECT ID, LONG_COL FROM TEST WHERE LONG_COL IS NOT NULL) !
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE (ID, LONG_COL) IN
   (SELECT ID, LONG_COL FROM TEST WHERE LONG_COL IS NOT NULL) !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:LON 0066
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE (ID , LONG_COL) IN
   (SELECT ID, LONG_COL FROM TEST
     WHERE LONG_COL IS NOT NULL AND ROWNO <= 1000000) !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:LON 0067
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
 * PTS 1123726-9 !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE PRIMA (
   OID INTEGER,
   CONSTRAINT PRIMA_PK PRIMARY KEY(OID),
   VAL LONG DEFAULT '')
!
 
Enter command:
 CREATE TABLE SEC1 (
   OID INTEGER DEFAULT SERIAL,
   CONSTRAINT SEC1_PK PRIMARY KEY(OID),
   CONSTRAINT SEC1_FK FOREIGN KEY(OID) REFERENCES PRIMA(OID) ON DELETE
CASCADE,
   VAL LONG DEFAULT '')
!
 
Enter command:
 CREATE VIEW V2 (OID, VAL, VAL1) AS
   SELECT P.OID, P.VAL, S1.VAL
   FROM PRIMA P, SEC1 S1
   WHERE P.OID = S1.OID
   WITH CHECK OPTION
!
 
Enter command:
 INSERT INTO V2 (OID, VAL, VAL1) VALUES (1, 'prima a', 'sec1 a')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
INSERT INTO V2 (OID, VAL, VAL1) VALUES (2, 'prima b', 'sec1 b') !
 
Enter command:
DATA !
 
Enter command:
INSERT INTO V2 (OID, VAL, VAL1) VALUES (3, :A, :B ) !
 
l 7 'prima c'
l 6 'sec1 c'
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
 SELECT * FROM V2!
 
resultcount :                     3
 
Enter command:
 FETCH!
 
OID               :            1
VAL               :  prima a
VAL1              :  sec1 a
-----------------------------------------------------------------------
OID               :            2
VAL               :  prima b
VAL1              :  sec1 b
-----------------------------------------------------------------------
OID               :            3
VAL               :  prima c
VAL1              :  sec1 c
 
resultcount :                     3
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE DBM350_SM (MSN SERIAL(8) PRIMARY KEY,
STATUSCODE INTEGER, DIST_FILE LONG BYTE, DIST_NUM INTEGER)!
 
Enter command:
INSERT DBM350_SM (STATUSCODE, DIST_FILE, DIST_NUM) VALUES
(3, NULL, 11)!
 
Enter command:
INSERT DBM350_SM (STATUSCODE, DIST_FILE, DIST_NUM) VALUES
(3, NULL, 11)!
 
Enter command:
SELECT * FROM DBM350_SM!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
MSN               :            8
STATUSCODE        :            3
DIST_FILE         :  ?????
DIST_NUM          :           11
-----------------------------------------------------------------------
MSN               :            9
STATUSCODE        :            3
DIST_FILE         :  ?????
DIST_NUM          :           11
 
resultcount :                     2
 
Enter command:
PARS_THEN_EX!
 
Enter command:
DATA!
 
Enter command:
UPDATE DBM350_SM SET STATUSCODE=-2, DIST_FILE=?,
DIST_NUM=DIST_NUM+1 WHERE MSN=9!
 
l 917 'abcdefg'
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM DBM350_SM!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
MSN               :            8
STATUSCODE        :            3
DIST_FILE         :  ?????
DIST_NUM          :           11
-----------------------------------------------------------------------
MSN               :            9
STATUSCODE        :           -2
DIST_FILE         :
from      1 to    917:abcdefg
maxlen:        917
DIST_NUM          :           12
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), B LONG BYTE DEFAULT 'abc')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
INSERT T (A) VALUES ('xyz')!
 
Enter command:
PARS_EXECUTE !
 
Enter command:
SELECT * INTO :A, :B FROM T !
 
A                 :  xyz
B                 :  abc
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( K INT, A CHAR (30), B LONG)!
 
Enter command:
INSERT INTO T VALUES (1, 'abcdef', 'abcdef')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT INTO T VALUES (2, 'kurzer Long', :A)!
 
l 1234 'das ist der 1234 Bytes lange String'
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT INTO T VALUES (2, 'langer long', :A)!
 
l 12345 'das ist der 12345 Bytes lange LOOOONG String'
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
SELECT *, SUBSTR(B, 5) FROM T!
 
***ERROR  -5010 Missing value specification                                0018
 
Enter command:
SELECT *, SUBSTR(B, 5, 100) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :  ef
--------------------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :  ist der 1234 Bytes lange Stringdas ist der 1234 Bytes lange Stringdas ist der 1234 Bytes lange Strin
--------------------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :  ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 1234
 
resultcount :                     3
 
Enter command:
SELECT *, SUBSTR(B, 1, 20) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :  abcdef
-----------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :  das ist der 1234 Byt
-----------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :  das ist der 12345 By
 
resultcount :                     3
 
Enter command:
SELECT *, SUBSTR(B, 10, 20) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :  ?????
-----------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :  er 1234 Bytes lange
-----------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :  er 12345 Bytes lange
 
resultcount :                     3
 
Enter command:
SELECT *, SUBSTR(B, 1, 20000) FROM T!
 
***ERROR  -3046 Invalid char position in string function                   0011
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
SELECT *, SUBSTR(B, 10000, 3000) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :  ?????
--------------------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :  ?????
--------------------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :
 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringda
s ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG
 Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lang
e LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 B
ytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist de
r 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringd
as ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOON
G Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lan
ge LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345
Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist d
er 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG String
das ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOO
NG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes la
nge LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345
 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist
der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Strin
gdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOO
ONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes l
ange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 1234
5 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist
 der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stri
ngdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOO
OONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes
lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 123
45 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas is
t der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Str
ingdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LO
OOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes
 lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12
345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes l
 
resultcount :                     3
 
Enter command:
 
SELECT *, LENGTH(A), LENGTH (B) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :      6
EXPRESSION2       :            6
-----------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :     11
EXPRESSION2       :         1234
-----------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :     11
EXPRESSION2       :        12345
 
resultcount :                     3
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST SQLMODE ORACLE !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST SQLMODE ORACLE ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE DOCUMENT_FORMAT (
E_DOC_VER_K_DOCUMENT  NUMBER (9) NOT NULL,
B_TEXT                LONG BYTE)!
 
Enter command:
PARSING !
 
Enter command:
INSERT INTO DOCUMENT_FORMAT (E_DOC_VER_K_DOCUMENT,B_TEXT )
         SELECT TO_NUMBER(?), ? FROM DUAL!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0081
 
Enter command:
INSERT INTO DOCUMENT_FORMAT (E_DOC_VER_K_DOCUMENT,B_TEXT )
         VALUES ( TO_NUMBER(?),?  ) !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 254 '1'
l 80 'abcd '
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE !
 
Enter command:
SELECT * FROM DOCUMENT_FORMAT!
 
resultcount :                     0
 
Enter command:
FETCH INTO :A, :B !
 
E_DOC_VER_K_DOCUMENT | B_TEXT
---------------------+---------------------------------------------------
         1           | abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd
 
resultcount :                     1
 
Enter command:
DROP TABLE DOCUMENT_FORMAT!
 
Enter command:
COMMIT RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), LB LONG BYTE, L LONG, LA LONG ASCII, B CHAR (8))!
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', '414243616263',
'515253616263', 'bcdefghi')!
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', '414243616263',
'515253616263', 'bcd' || 'efg 2')!
 
Enter command:
 
PARS_THEN_EX !
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', '414243616263',
'515253616263', 'bcdefg 3')!
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', '414243616263',
'515253616263', 'bcd' || 'efg 4')!
 
Enter command:
 
DATA !
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', :P,
'515253616263', 'bcdefg 5')!
 
l 12 '414243616263'
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', :P,
'515253616263', 'bcd' || 'efg 6')!
 
l 12 '414243616263'
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefghi
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 2
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 3
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 4
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 5
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 6
 
resultcount :                     6
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T1 (S1 INT, S2 CHAR (10), S3 LONG) !
 
Enter command:
INSERT T1 VALUES (1, 'Hallo', 'long value') !
 
Enter command:
INSERT T1 VALUES (1, 'BYE BYE', NULL) !
 
Enter command:
CREATE TABLE T2 AS SELECT (S1 - 1) S1, S2 FROM T1 !
 
Enter command:
CREATE VIEW V2 AS SELECT * FROM T1 WHERE T1.S1 NOT IN (SELECT S1 FROM T2) !
 
Enter command:
SELECT * FROM V2!
 
resultcount :                     2
 
Enter command:
FETCH!
 
S1          | S2         | S3
------------+------------+---------------------------------------------------
          1 | Hallo      | long value
          1 | BYE BYE    | ??????????????????????????????????????????????????
 
resultcount :                     2
 
Enter command:
SELECT * FROM (SELECT * FROM T1)!
 
resultcount :                     2
 
Enter command:
FETCH!
 
S1          | S2         | S3
------------+------------+---------------------------------------------------
          1 | Hallo      | long value
          1 | BYE BYE    | ??????????????????????????????????????????????????
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A INT, B LONG)!
 
Enter command:
INSERT T VALUES (1, 'das ist der long')!
 
Enter command:
COMMENT ON TABLE KERN.T IS 'das ist der Kommentar'!
 
Enter command:
SELECT A, SUBSTR(B,1,8) FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A           | EXPRESSION1
------------+------------
          1 | das ist
 
resultcount :                     1
 
Enter command:
SELECT *, SUBSTR(COMMENT,1,8) FROM SYSDD.TABLES
WHERE TABLENAME = 'T' AND SCHEMANAME = 'KERN'!
 
***ERROR  -9000 System error: Not yet implemented:virtual long column      0011
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( L LONG, A CHAR (300))!
 
Enter command:
INSERT T VALUES ('das ist der long-wert', 'abc')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T VALUES (:L, 'abc')!
 
l 12000 'das ist der 2. long-wert'
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
UPDATE T SET A = SUBSTR (L, 1,20)!
 
resultcount :                     2
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
L                 :  das ist der long-wert
A                 :  das ist der long-wer
--------------------------------------------------------------------------------
L                 :
from      1 to  12000:das ist der 2. long-wert
maxlen:      12000
A                 :  das ist der 2. long-
 
resultcount :                     2
 
Enter command:
UPDATE T SET A = SUBSTR (L, 1,400)!
 
***ERROR  -2010 Assignment impossible, char value too long                 0034
 
Enter command:
UPDATE T SET A = SUBSTR (L, 13,100)!
 
resultcount :                     2
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
L                 :  das ist der long-wert
A                 :  long-wert
--------------------------------------------------------------------------------
L                 :
from      1 to  12000:das ist der 2. long-wert
maxlen:      12000
A                 :  2. long-wertdas ist der 2. long-wertdas ist der 2. long-wertdas ist der 2. long-wertdas ist der 2. l
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TAB1 (A INT PRIMARY KEY, B CHAR(10), C LONG, D FIXED)!
 
Enter command:
CREATE TABLE TAB2 (A INT, B CHAR(10), C LONG, D INT)!
 
Enter command:
INSERT INTO TAB1 VALUES (1, 'bla', NULL, 5.2)!
 
Enter command:
INSERT INTO TAB2 VALUES (1, 'bla', NULL, 5)!
 
Enter command:
CREATE VIEW SELTAB1 AS SELECT * FROM TAB1!
 
Enter command:
CREATE VIEW SELTAB2 AS SELECT * FROM TAB2!
 
Enter command:
CREATE VIEW SELTAB1_V1 AS
SELECT * FROM SELTAB1 S WHERE S.A IN (SELECT A FROM SELTAB2)!
 
Enter command:
CREATE VIEW CC1 AS SELECT * FROM SELTAB1_V1 !
 
Enter command:
CREATE VIEW SELTAB1_V2 AS
SELECT * FROM SELTAB1 S !
 
Enter command:
SELECT * FROM SELTAB1 S WHERE S.A IN (SELECT A FROM SELTAB2)!
 
resultcount :                     1
 
Enter command:
FETCH!
 
A                 :            1
B                 :  bla
C                 :  ?????
D                 :       5
 
resultcount :                     1
 
Enter command:
SELECT * FROM SELTAB1_V2!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :            1
B                 :  bla
C                 :  ?????
D                 :       5
 
resultcount :                     1
 
Enter command:
SELECT * FROM SELTAB1_V1!
 
resultcount :                     1
 
Enter command:
FETCH !
 
A                 :            1
B                 :  bla
C                 :  ?????
D                 :       5
 
resultcount :                     1
 
Enter command:
SELECT * FROM CC1!
 
resultcount :                     1
 
Enter command:
FETCH!
 
A                 :            1
B                 :  bla
C                 :  ?????
D                 :       5
 
resultcount :                     1
 
Enter command:
ROLLBACK WORK RELEASE !
 
Enter command:
 * PTS 1130589, 1136988 !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TAB
(
    ID CHAR(24) BYTE,
    PROP CHAR(24) BYTE,
    SHORT_COL CHAR(24) ASCII,
    LONG_COL LONG BYTE
)!
 
Enter command:
INSERT TAB VALUES (X'414243', X'515253', 'xyz', X'31323334')!
 
Enter command:
SELECT * INTO :A, :B, :C, :D FROM TAB !
 
ID                :  414243
PROP              :  515253
SHORT_COL         :  xyz
LONG_COL          :  1234
 
Enter command:
PARS_THEN_EX!
 
Enter command:
DATA !
 
Enter command:
UPDATE TAB SET SHORT_COL=?, LONG_COL=? WHERE ID=? AND PROP=?!
 
c 24 'NEWVALUE'
l 120 'newvalue NEWVALUE '
b 24 414243
b 24 515253
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE
NODATA !
 
Enter command:
SELECT * INTO :A, :B, :C, :D FROM TAB !
 
ID                :  414243
PROP              :  515253
SHORT_COL         :  NEWVALUE
LONG_COL          :
from      1 to    120:newvalue NEWVALUE
maxlen:        120
 
Enter command:
PARS_THEN_EX!
 
Enter command:
DATA !
 
Enter command:
UPDATE TAB SET (SHORT_COL, LONG_COL) = (?,?) WHERE ID=? AND PROP=?!
 
c 24 'NEWER VALUE'
l 120 'newervalue NEWERVALUE '
b 24 414243
b 24 515253
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE
NODATA !
 
Enter command:
SELECT * INTO :A, :B, :C, :D FROM TAB !
 
ID                :  414243
PROP              :  515253
SHORT_COL         :  NEWER VALUE
LONG_COL          :
from      1 to    120:newervalue NEWERVALUE
maxlen:        120
 
Enter command:
PARS_EXECUTE !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A INT , B LONG, C LONG, D INT,
E LONG, F INT, G LONG, H INT)!
 
Enter command:
INSERT T VALUES (1,'default','default',1,'default',1,'default',1)!
 
Enter command:
INSERT T VALUES (2,'default','default',2,'default',2,'default',2)!
 
Enter command:
INSERT T VALUES (3,'default','default',3,'default',3,'default',3)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T VALUES (:A,:B,:C,:D,:E,:F,:G,:H)!
 
n 10 4
l 40
l 1000 'alter Wert '
n 10 4
l 40
n 10 4
l 40
n 10 4
 
Enter command:
UPDATE T SET
A =:A, B = :B, C = :C, D = :D, E = :E, F = :F, G = :G, H = :H
WHERE A <  3 !
 
n 10 4711
l 40
l 1000 'neuer Wert '
n 10 4711
l 40
n 10 4711
l 40
n 10 4711
 
resultcount :                     2
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :         4711
B                 :  ?????
C                 :
from      1 to   1000:neuer Wert
maxlen:       1000
D                 :         4711
E                 :  ?????
F                 :         4711
G                 :  ?????
H                 :         4711
-----------------------------------------------------------------------
A                 :         4711
B                 :  ?????
C                 :
from      1 to   1000:neuer Wert
maxlen:       1000
D                 :         4711
E                 :  ?????
F                 :         4711
G                 :  ?????
H                 :         4711
-----------------------------------------------------------------------
A                 :            3
B                 :  default
C                 :  default
D                 :            3
E                 :  default
F                 :            3
G                 :  default
H                 :            3
-----------------------------------------------------------------------
A                 :            4
B                 :  ?????
C                 :
from      1 to   1000:alter Wert
maxlen:       1000
D                 :            4
E                 :  ?????
F                 :            4
G                 :  ?????
H                 :            4
 
resultcount :                     4
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TEST ( I INT , C CHAR(10) , L LONG ) !
 
Enter command:
INSERT TEST VALUES (1,'hallo', 'xxx')!
 
Enter command:
PARSING !
 
Enter command:
UPDATE TEST SET C = ? , L = ? WHERE I = ? !
parsing idnr :       1
 
Enter command:
INSERT TEST VALUES (2, 'hallu', ?) !
parsing idnr :       2
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
 
UPDATE !
Parsing idnr :      1
 
c 10 'halli'
c 32
n 10 1
 
resultcount :                     1
 
Enter command:
INSERT !
Parsing idnr :      2
 
l 10 'test'
 
Enter command:
PARS_EXECUTE !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T1 (S1 INT KEY, S2 LONG) !
 
Enter command:
COMMIT !
 
Enter command:
PARSING !
 
Enter command:
INSERT T1 VALUES (1, 'Dies ist ein doofer test') !
parsing idnr :       1
 
Enter command:
PARS_EXECUTE !
 
Enter command:
ROLLBACK !
 
Enter command:
EXECUTING !
 
Enter command:
INSERT !
Parsing idnr :      1
 
Enter command:
 
 
PARS_EXECUTE !
 
Enter command:
DROP TABLE T1 !
 
Enter command:
 
CREATE TABLE S ( CID CHAR(24)) !
 
Enter command:
INSERT S VALUES ('3031')!
 
Enter command:
 
CREATE TABLE T (
 CID CHAR (24) ,
 NAME_ID CHAR (24) ,
 SHORT_VALUE CHAR (499) NOT NULL ,
 LONG_VALUE  LONG BYTE,
 VIEWOWNER CHAR(32) DEFAULT USERGROUP,
 PRIMARY KEY (NAME_ID,CID)) !
 
Enter command:
 
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
 
INSERT T COLUMNS (CID, NAME_ID, SHORT_VALUE, LONG_VALUE)
VALUES ((SELECT CID FROM S WHERE CID = ?), ?, ?, ?)!
 
c 24 '3031'
c 24 '3031'
c 499 'hallo'
c 32
 
Enter command:
NODATA!
 
Enter command:
PARS_EXECUTE!
 
Enter command:
 
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH !
 
CID               :  3031
NAME_ID           :  3031
SHORT_VALUE       :  hallo
LONG_VALUE        :  ?????
VIEWOWNER         :  KERN
 
resultcount :                     1
 
Enter command:
 
DROP TABLE T!
 
Enter command:
DROP TABLE S!
 
Enter command:
 
COMMIT RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), B LONG DEFAULT 'abcdef',
 C LONG DEFAULT 'mopqr', D LONG, E FIXED (8))!
 
Enter command:
INSERT T VALUES ('aaaa', DEFAULT, DEFAULT, 'abc', 1)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T VALUES (:A, :B, DEFAULT, :D, 2)!
 
c 8 'bbb'
d
l 120 'long'
 
Enter command:
INSERT T VALUES ('a2', DEFAULT, :C, :D, :E)!
 
d
l 300 'dddd'
n 8 4
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :  aaaa
B                 :  abcdef
C                 :  mopqr
D                 :  abc
E                 :          1
-----------------------------------------------------------------------
A                 :  bbb
B                 :  abcdef
C                 :  mopqr
D                 :
from      1 to    120:long
maxlen:        120
E                 :          2
-----------------------------------------------------------------------
A                 :  a2
B                 :  abcdef
C                 :  mopqr
D                 :
from      1 to    300:d
maxlen:        300
E                 :          4
 
resultcount :                     3
 
Enter command:
 
UPDATE T SET B = 'das ist neues b' WHERE E = 1!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0019
 
Enter command:
 
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
UPDATE T SET B = :B WHERE E = 2!
 
d
 
***ERROR  -9000 System error: Not yet implemented                          0004
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :  aaaa
B                 :  abcdef
C                 :  mopqr
D                 :  abc
E                 :          1
-----------------------------------------------------------------------
A                 :  bbb
B                 :  abcdef
C                 :  mopqr
D                 :
from      1 to    120:long
maxlen:        120
E                 :          2
-----------------------------------------------------------------------
A                 :  a2
B                 :  abcdef
C                 :  mopqr
D                 :
from      1 to    300:d
maxlen:        300
E                 :          4
 
resultcount :                     3
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE DUMMY1 (
"Column1" CHAR (8), "Memo" LONG) !
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT DUMMY1 VALUES ('abc', :L)!
 
l 120 'das ist der lob '
 
Enter command:
INSERT DUMMY1 VALUES ('def', :L)!
 
l 10200 'das ist der loooooong lob of 10200 bytes '
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA!
 
Enter command:
CREATE TABLE DUMMY2 ("Column1" CHAR (8)) !
 
Enter command:
INSERT DUMMY2 VALUES ('abc')!
 
Enter command:
INSERT DUMMY2 VALUES ('def')!
 
Enter command:
CREATE VIEW V1 AS
SELECT T0."Column1", SUBSTR(T0."Memo", 1, 50)
    FROM DUMMY1 T0
         INNER JOIN
         DUMMY2 T1
         ON T0."Column1" = T1."Column1" !
 
Enter command:
CREATE TABLE TEMP.TEST3 ("Column1", "ColumnMemo") AS
  SELECT T0."Column1", SUBSTR(T0."Memo", 1, 50)
    FROM DUMMY1 T0
         INNER JOIN
         DUMMY2 T1
         ON T0."Column1" = T1."Column1" !
 
Enter command:
CREATE TABLE TEMP.TEST3A ("Column1", "ColumnMemo") AS
  SELECT T0."Column1", SUBSTR_LOB
    FROM (SELECT "Column1", SUBSTR("Memo", 1, 50) SUBSTR_LOB FROM DUMMY1) T0
         INNER JOIN
         DUMMY2 T1
         ON T0."Column1" = T1."Column1" !
 
Enter command:
CREATE TABLE TEMP.TEST5("Column1", "ColumnMemo") AS
  SELECT * FROM V1 !
 
Enter command:
SELECT * FROM TEMP.TEST3!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
Column1  | ColumnMemo
---------+---------------------------------------------------
abc      | das ist der lob das ist der lob das ist der lob da
def      | das ist der loooooong lob of 10200 bytes das ist d
 
resultcount :                     2
 
Enter command:
SELECT * FROM TEMP.TEST3A!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
Column1  | ColumnMemo
---------+---------------------------------------------------
abc      | das ist der lob das ist der lob das ist der lob da
def      | das ist der loooooong lob of 10200 bytes das ist d
 
resultcount :                     2
 
Enter command:
SELECT * FROM TEMP.TEST5!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
Column1  | ColumnMemo
---------+---------------------------------------------------
abc      | das ist der lob das ist der lob das ist der lob da
def      | das ist der loooooong lob of 10200 bytes das ist d
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE LONG ( LONGFILE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE L ( K CHAR (8) KEY,
A CHAR (9),
S LONGFILE,
B CHAR (10))!
 
Enter command:
FILE SEL_COLS_TAB ( L !
 
Enter command:
DECLARE SEL_COL CURSOR FOR
 SELECT COLUMNNAME,
        MODE AS "MOD",
        DATATYPE,
        CODETYPE AS "CODE",
        LEN,"DEC",COLUMNPRIVILEGES,"DEFAULT"
   FROM DOMAIN.COLUMNS
  WHERE OWNER <> 'SUT'
    AND TABLENAME = 'L'
  ORDER BY POS !
 
resultcount :                     4
 
Enter command:
FETCH SEL_COL INTO :A,:B,:C,:D,:E,:F,:G,:H !
 
COLUMNNAME        :  K
MOD               :  KEY
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      8
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  A
MOD               :  OPT
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      9
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  S
MOD               :  OPT
DATATYPE          :  LONGFILE
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  B
MOD               :  OPT
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :     10
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
 
resultcount :                     4
 
Enter command:
CLOSE SEL_COL !
 
Enter command:
PARSING !
 
Enter command:
COMMENT ON TABLE L IS :AAA !
parsing idnr :       1
 
Enter command:
EXECUTING!
 
Enter command:
DATA!
 
Enter command:
INSERT !
Parsing idnr :      1
 
l 36 'hier steht der String drin '
 
Enter command:
 *INSERT MIT KURZER 'Long'-COLUMN!
 
Enter command:
PARSING !
 
Enter command:
INSERT L VALUES (:K, :A, :S, :B)!
parsing idnr :       1
 
Enter command:
EXECUTING!
 
Enter command:
DATA!
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'keyvalue'
c 9 'a9a9a9a9a'
l 100 'hier steht der String drin '
c 10 'b10b10b10b'
 
Enter command:
 *INSERT MIT LANGER 'Long'-COLUMN !
 
Enter command:
PARSING !
 
Enter command:
NODATA !
 
Enter command:
INSERT L SET K = :K, S = :S, A = :A, B = :B !
parsing idnr :       1
 
Enter command:
DATA!
 
Enter command:
EXECUTING!
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'second_k'
l 8200 'hier steht der String drin '
c 9 'a9a9a9a9a'
c 10 'b10b10b10b'
 
Enter command:
 *INSERT MIT LONG-COLUMN, DIE DURCH PUTVALS AUFGEFUELLT WIRD !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'third_k'
l 54,0 'hier steht der String drin '
c 9 'a9a9a9a9a'
c 10 'b10b10b10b'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120,0 'Nachschlag 1'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 100,2 'Rest'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 'R'
 
Enter command:
EXECUTING!
 
Enter command:
 * INSERT MIT NULL-WERT ALS DATENEINGABE !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'fourth_k'
c 32
c 9 'aaaaaaaaa'
c 10 'b10b10b10b'
 
Enter command:
 * ABGEBROCHENES PUTVAL PTS 1113250 !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'fifth_k'
l 54,0 'hier steht der String drin '
c 9 'a9a9a9a9a'
c 10 'b10b10b10b'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120,0 'Nachschlag 1'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 100,8 'Rest'
 
Enter command:
 *KONTROLLESEN DER SAETZE !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
maxlen:        100
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *APPEND VON KURZEM WERT IN KURZEN, L‰NGEREN WERT !
 
Enter command:
PARSING !
 
Enter command:
APPEND L SET S = :S KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 50 'appended  '
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
from    101 to    150:appended
maxlen:        150
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *APPEND VON KURZEM WERT IN AUCH NOCH KURZEN WERT
 *MIT LONG-COLUMN, DIE DURCH PUTVALS AUFGEFUELLT WIRD !
 
Enter command:
PARSING !
 
Enter command:
APPEND L SET S = :S KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 34,0 'das ist der 1. Teil '
 
resultcount :                     1
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 80,2 'Rest vom putval '
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 'R'
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
from    101 to    150:appended
from    151 to    184:das ist der 1. Teil
from    185 to    264:Rest vom putval
maxlen:        264
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *APPEND VON KURZEM WERT IN LANGEN WERT !
 
Enter command:
PARSING !
 
Enter command:
APPEND L SET S = :S KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 9000 'looong appended '
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
from    101 to    150:appended
from    151 to    184:das ist der 1. Teil
from    185 to    264:Rest vom putval
from    265 to   9264:looong appended
maxlen:       9264
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *APPEND VON LANGEM WERT IN NOCH L‰NGEREN WERT !
 
Enter command:
PARSING !
 
Enter command:
APPEND L SET S = :S KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 900 'das ist der Rest '
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    100:hier steht der String drin
from    101 to    150:appended
from    151 to    184:das ist der 1. Teil
from    185 to    264:Rest vom putval
from    265 to   9264:looong appended
from   9265 to  10164:das ist der Rest
maxlen:      10164
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *UPDATE VON BESTEHENDEM WERT IN EXPLIZIT ANGEGEBENES NULL !
 
Enter command:
PARSING !
 
Enter command:
UPDATE L SET S = NULL KEY K = 'keyvalue' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
resultcount :                     1
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to   8200:hier steht der String drin
maxlen:       8200
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *UPDATE VON BESTEHENDEM WERT IN NULL-WERT DURCH DATENEINGABE !
 
Enter command:
PARSING !
 
Enter command:
UPDATE L SET S = :S KEY K = 'second_k' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
c 32
 
resultcount :                     1
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *VORABLESEN DES BESTEHENDEN WERTES !
 
Enter command:
SELECT * FROM L WHERE K = 'third_k' !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to     54:hier steht der String drin
from     55 to    174:Nachschlag 1
from    175 to    274:Rest
maxlen:        274
B                 :  b10b10b10b
 
resultcount :                     1
 
Enter command:
 *UPDATE EINES BESTEHENDEN WERTES DURCH EINEN NEUEN WERT !
 
Enter command:
 *ANGABE NICHT DURCH KEY ..., SONDERN DURCH WHERE !
 
Enter command:
NODATA!
 
Enter command:
PARSING!
 
Enter command:
UPDATE L SET S = :S WHERE K = 'third_k' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 300 'neuer Text !!!'
 
resultcount :                     1
 
Enter command:
 *KONTROLLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
 *UPDATE EINES NULL-WERTES DURCH NEUEN WERT, DER DURCH PUTVALS
 *AUFGEF?ULLT WIRD !
 
Enter command:
PARSING !
 
Enter command:
UPDATE L SET S = :S WHERE A = 'aaaaaaaaa' !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 1,3 'v'
 
resultcount :                     1
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 30,0 'neuer Text !!!'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120,0 'Nachschlag 1'
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 100,2 'Rest'
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
COMMIT !
 
Enter command:
 *MEHRERE SAETZE DUERFEN DOCH GLEICHZEITIG GEAENDERT WERDEN !
 
Enter command:
PARSING!
 
Enter command:
UPDATE L SET S = :S WHERE K <= 'st' AND A = 'a9a9a9a9a'!
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 300 'neuer Text fuer mehrere Saetze !'
 
resultcount :                     2
 
Enter command:
NODATA!
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
ROLLBACK !
 
Enter command:
PARSING!
 
Enter command:
UPDATE L (S) VALUES (:S) !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 300 'noch neuerer Text fuer mehrere Saetze !'
 
resultcount :                     4
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to    300:noch neuerer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    300:noch neuerer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:noch neuerer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:noch neuerer Text fuer mehrere Saetze !
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
ROLLBACK !
 
Enter command:
 * TEST WITH CORRELATION AND MORE THAN ONE RECORD !
 
Enter command:
 CREATE TABLE L1 AS SELECT K, A, B FROM L!
 
Enter command:
PARSING !
 
Enter command:
UPDATE L SET S = :S WHERE A = 'a9a9a9a9a'
AND K IN (SELECT K FROM L1 WHERE L1.K = L.K) !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:S   0014
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
ROLLBACK !
 
Enter command:
 * TEST WITH ARRAY COMMAND AND MORE THAN ONE RECORD !
 
Enter command:
PARSING !
 
Enter command:
MUPDATE L SET S = :S WHERE K BETWEEN :K1 AND :K2 !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
MUPDATE    T!
32767
-2
Parsing idnr :      1
 
l 240 'die ersten zwei keys kriegen den long-value'
c 8 'fourth_k' c 8 'keyvalue'
l 300 'die letzten zwei keys kriegen einen anderen long-value'
c 8 'second_k' c 8 'third_k'
 
resultcount :                     4
 
Enter command:
 *TESTLESEN !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to    240:die ersten zwei keys kriegen den long-value
maxlen:        240
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :
from      1 to    240:die ersten zwei keys kriegen den long-value
maxlen:        240
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:die letzten zwei keys kriegen einen anderen long-value
maxlen:        300
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:die letzten zwei keys kriegen einen anderen long-value
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
ROLLBACK !
 
Enter command:
SELECT K, A, B FROM L WHERE S IS NULL !
 
resultcount :               unknown
 
Enter command:
SELECT K, A, B FROM L WHERE S IS NOT NULL !
 
resultcount :               unknown
 
Enter command:
SELECT K, A, B FROM L WHERE S = 'neuer Text'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0029
 
Enter command:
PARS_THEN_EX !
 
Enter command:
SELECT K, A, B FROM L WHERE S IS NULL !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K        | A         | B
---------+-----------+-----------
keyvalue | a9a9a9a9a | b10b10b10b
second_k | a9a9a9a9a | b10b10b10b
 
resultcount :                     2
 
Enter command:
SELECT K, A, B FROM L WHERE S IS NOT NULL !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K        | A         | B
---------+-----------+-----------
fourth_k | aaaaaaaaa | b10b10b10b
third_k  | a9a9a9a9a | b10b10b10b
 
resultcount :                     2
 
Enter command:
SELECT K, A, B FROM L WHERE S = 'neuer Text'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0029
 
Enter command:
SELECT K, A, B FROM L WHERE S LIKE 'neuer Text%'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0029
 
Enter command:
SELECT K, A, B FROM L WHERE DEFAULT < S !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0029
 
Enter command:
SELECT K, A, B FROM L WHERE S = DEFAULT !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0033
 
Enter command:
COMMIT !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
DELETE L KEY K = 'second_k' !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     3
 
Enter command:
ROLLBACK !
 
Enter command:
CREATE TABLE T ( A CHAR ( 8) KEY, B LONGFILE, B1 LONGFILE, C CHAR(32)) !
 
Enter command:
PARSING !
 
Enter command:
MINSERT T VALUES (:A, :B, :B1, :C) !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
MINSERT    T!
32767
2
Parsing idnr :      1
 
c 8 'aaa' l 1000 'a' l 10 'b1eins    ' c 32 'eins'
c 8 'bbb' l 500  'a' l 10,0 'b1zweib1  ' c 32 'zwei'
 
resultcount :                     2
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1000,1 'erster Teil f¸r zwei '
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 'R'
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A                 :  aaa
B                 :
from      1 to   1000:a
maxlen:       1000
B1                :  b1eins
C                 :  eins
-----------------------------------------------------------------------
A                 :  bbb
B                 :
from      1 to    500:a
maxlen:        500
B1                :
from      1 to      8:b1zwei
from      9 to     10:
from     11 to     16:erst
from     17 to   1010: Teil f¸r zwei erster
maxlen:       1010
C                 :  zwei
 
resultcount :                     2
 
Enter command:
CHECK TABLE T WITH LONG CHECK !
 
Enter command:
ROLLBACK !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
 *GEHT DAS AUCH MIT MEHREREN LONG-COLUMNS IN EINER TABELLE ? !
 
Enter command:
CREATE TABLE T2 (
   K  CHAR (8) KEY,
   S1 LONGFILE ,
   A  CHAR (2),
   S2 LONGFILE BYTE)!
 
Enter command:
FILE SEL_COLS_TAB ( T2 !
 
Enter command:
DECLARE SEL_COL CURSOR FOR
 SELECT COLUMNNAME,
        MODE AS "MOD",
        DATATYPE,
        CODETYPE AS "CODE",
        LEN,"DEC",COLUMNPRIVILEGES,"DEFAULT"
   FROM DOMAIN.COLUMNS
  WHERE OWNER <> 'SUT'
    AND TABLENAME = 'T2'
  ORDER BY POS !
 
resultcount :                     4
 
Enter command:
FETCH SEL_COL INTO :A,:B,:C,:D,:E,:F,:G,:H !
 
COLUMNNAME        :  K
MOD               :  KEY
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      8
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  S1
MOD               :  OPT
DATATYPE          :  LONGFILE
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  A
MOD               :  OPT
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      2
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  S2
MOD               :  OPT
DATATYPE          :  LONGFILE
CODE              :  BYTE
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
 
resultcount :                     4
 
Enter command:
CLOSE SEL_COL !
 
Enter command:
 * IN CASE PUTVAL IS DONE SEPARATELY FOR BOTH COLUMNS, THE SECOND ONE
 * USES THE DESCRIPTION OF THE FIRST ONE --> IN CASE OF UNICODE-DEFCODE
 * S2-INPUT WILL NOT BE HANDLED AS BYTE, BUT AS UNICODE -->
 * 'l' X'00' '2' X'00' !
 
Enter command:
PARSING !
 
Enter command:
INSERT T2 VALUES (:K, :S1, :A, :S2)!
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'keyvalue'
l 100 'tri tra tralala...'
c 2 'a9'
l 100 "hier steht der String drin "
 
Enter command:
EXECUTING!
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'second_k'
l 2500 'tritratralala...'
c 2 'a9'
c 32
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'third_k'
l 1,3 't'
c 2 'a9'
l 1,3 "m"
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120 'l1 l1 l1 '
l 1,3 "m"
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 420 "l2 l2 l2 "
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 "c"
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'fourth_k'
l 100,0 't'
c 2 'a9'
l 1,3 "m"
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 120,2 'l1 l1 l1 '
l 1,3 "m"
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 420 "l2 l2 l2 "
 
Enter command:
PUTVAL !
Parsing idnr :      1
 
l 1,5 "c"
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T2 !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :  fourth_k
S1                :
from      1 to    100:t
from    101 to    220:l1
maxlen:        220
A                 :  a9
S2                :
from      1 to    420:l2
maxlen:        420
-----------------------------------------------------------------------
K                 :  keyvalue
S1                :
from      1 to      6:tri
from      7 to    100:a tralala...tri tr
maxlen:        100
A                 :  a9
S2                :
from      1 to    100:hier steht der String drin
maxlen:        100
-----------------------------------------------------------------------
K                 :  second_k
S1                :
from      1 to      5:tri
from      6 to   2500:atralala...tritr
maxlen:       2500
A                 :  a9
S2                :  ?????
-----------------------------------------------------------------------
K                 :  third_k
S1                :
from      1 to    120:l1
maxlen:        120
A                 :  a9
S2                :
from      1 to    420:l2
maxlen:        420
 
resultcount :                     4
 
Enter command:
DELETE T2 !
 
resultcount :                     4
 
Enter command:
DIAGNOSE SHARE PARSE DROP !
 
Enter command:
SELECT * FROM T2 !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
PARSING !
 
Enter command:
CREATE VIEW VLONG AS SELECT * FROM L !
parsing idnr :       1
 
Enter command:
PARSING !
 
Enter command:
SELECT RL.K, RL.A, RL.S, RL.B
        INTO :K1, :A1, :S1, :B1,
             :K0, :A0, :S0, :B0
        FROM L, L RL
        WHERE L.K = 'second_k' AND RL.K = 'second_k'!
parsing idnr :       1
 
Enter command:
 
SELECT *
        INTO :K1, :A1, :S1, :B1,
             :K0, :A0, :S0, :B0
        FROM L, L RL
        WHERE L.K = 'second_k' AND RL.K = 'second_k'!
parsing idnr :       2
 
Enter command:
SELECT DISTINCT *
        INTO :K1, :A1, :S1, :B1
        FROM L
        WHERE K = 'second_k'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:S   0017
 
Enter command:
SELECT K, A, S, B
        FROM L
        WHERE K = 'second_k'
UNION
SELECT K, A, S, B
        FROM L
        WHERE K = 'keyvalue'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:S   0001
 
Enter command:
SELECT * FROM (SELECT K, A, S, B
        FROM L
        WHERE K = 'keyvalue') !
parsing idnr :       3
 
Enter command:
PARS_THEN_EX !
 
Enter command:
SELECT * FROM L !
 
resultcount :               unknown
 
Enter command:
FETCH INTO :A, :B, :C, :D!
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
DECLARE ERG CURSOR FOR
SELECT * FROM L FOR REUSE !
 
resultcount :                     4
 
Enter command:
DROP TABLE L !
 
Enter command:
DIAGNOSE SHARE PARSE DROP !
 
Enter command:
FETCH ERG INTO :A, :B, :C, :D !
 
K                 :  fourth_k
A                 :  aaaaaaaaa
S                 :
from      1 to     30:neuer Text !!!
from     31 to    150:Nachschlag 1
from    151 to    250:Rest
maxlen:        250
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  keyvalue
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  second_k
A                 :  a9a9a9a9a
S                 :  ?????
B                 :  b10b10b10b
-----------------------------------------------------------------------
K                 :  third_k
A                 :  a9a9a9a9a
S                 :
from      1 to    300:neuer Text !!!
maxlen:        300
B                 :  b10b10b10b
 
resultcount :                     4
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
DROP TABLE T2 !
 
Enter command:
COMMIT WORK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE X (K CHAR (8) KEY)!
 
Enter command:
CREATE TABLE T ( A CHAR (8),
    FOREIGN KEY (A) REFERENCES X (K))!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T SET A = :A!
 
c 8 'fff'
 
***ERROR    350 Referential integrity violated:X_T,KERN,T                  0001
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
CREATE TABLE T1 (A CHAR (8),
                 L LONGFILE,
    FOREIGN KEY (A) REFERENCES X (K))!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T1 SET A = :A, L = :L!
 
c 8 'fff'
l 7800,0 'Text '
 
***ERROR    350 Referential integrity violated:X_T1,KERN,T1                0001
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), S LONGFILE, B CHAR (8))!
 
Enter command:
INSERT T SET A = 'firstval', B = 'bbbb'!
 
Enter command:
PARSING !
 
Enter command:
INSERT T VALUES (:A, :S, :B)!
parsing idnr :       1
 
Enter command:
EXECUTING!
 
Enter command:
DATA!
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 8 'keyvalue'
l 100 'hier steht der String drin '
c 8 'b10b10b1'
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
MFETCH FIRST !
7
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
Enter command:
SELECT A, S, B FROM T FOR REUSE!
 
resultcount :                     2
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
MFETCH FIRST !
7
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
Enter command:
PARS_THEN_EX !
 
Enter command:
PARS_EXECUTE !
 
Enter command:
CREATE VIEW V1 AS SELECT * FROM T !
 
Enter command:
CREATE TABLE T1 AS SELECT * FROM T !
 
Enter command:
CREATE TABLE T2 AS SELECT * FROM V1 !
 
Enter command:
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
SELECT * FROM T1!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
SELECT * FROM V1!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
SELECT * FROM T2!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | S                                                  | B
---------+----------------------------------------------------+---------
firstval | ?????????????????????????????????????????????????? | bbbb
keyvalue | hier steht der String drin hier steht der String d | b10b10b1
 
resultcount :                     2
 
Enter command:
    CREATE TABLE SYSDDMODULE
      (
       OWNER       CHAR(64) ASCII DEFAULT USERGROUP,
       MODULNAM1   CHAR(64) ASCII DEFAULT ' ',
       MODULNAM2   CHAR(64) ASCII DEFAULT ' ',
       PROGLANG    CHAR(64) ASCII DEFAULT ' ',
       OBJTYPE     CHAR(18) ASCII DEFAULT 'MODULE',
       SUBTYPE     CHAR(12) ASCII DEFAULT ' ',
       VERSION     CHAR(4)  ASCII DEFAULT ' ',
       LONGNAME    CHAR(40) ASCII DEFAULT ' ',
       TYPE        CHAR(18) ASCII DEFAULT ' ',
       CREATEDATE  DATE DEFAULT DATE,
       CREATETIME  TIME DEFAULT TIME,
       UPDDATE     DATE DEFAULT DATE,
       UPDTIME     TIME DEFAULT TIME,
       COMMENT     LONGFILE     ASCII
      ) !
 
Enter command:
    CREATE TABLE SYSDDUSR_USES_PRO
      (
       USER_ID     FIXED(10)       KEY,
       ROW_ID      CHAR(8)   BYTE  KEY,
       DEFOWNER    CHAR(64)  ASCII,
       DEFOBJN1    CHAR(64)  ASCII DEFAULT ' ',
       DEFOBJN2    CHAR(64)  ASCII DEFAULT ' ',
       DEFOBJN3    CHAR(64)  ASCII DEFAULT ' ',
       DEFOBJTYPE  CHAR(18)  ASCII DEFAULT 'USER',
       DEFSUBTYPE  CHAR(12)  ASCII DEFAULT ' ',
       DEFVERSION  CHAR(4)   ASCII DEFAULT ' ',
       RELTYPE     CHAR(18)  ASCII DEFAULT 'USES',
       REFOWNER    CHAR(64)  ASCII,
       REFOBJN1    CHAR(64)  ASCII DEFAULT ' ',
       REFOBJN2    CHAR(64)  ASCII DEFAULT ' ',
       REFOBJN3    CHAR(64)  ASCII DEFAULT ' ',
       REFOBJTYPE  CHAR(18)  ASCII DEFAULT 'PROGRAM',
       REFSUBTYPE  CHAR(12)  ASCII DEFAULT ' ',
       REFVERSION  CHAR(4)   ASCII DEFAULT ' ',
       PRIVILEGES  CHAR(40)  ASCII DEFAULT 'EXECUTE',
       CREATEDATE  DATE DEFAULT DATE,
       CREATETIME  TIME DEFAULT TIME
      ) !
 
Enter command:
    GRANT SELECT ON SYSDDUSR_USES_PRO TO PUBLIC !
 
Enter command:
CREATE VIEW SYSDD_USR_USES_PRO
  (DEFOBJTYPE,DEFOWNER,DEFUSERNAME,DEFGROUPNAME,RELTYPE,
   REFOBJTYPE,REFOWNER,REFPROGRAMNAME,REFPROGLANG,CREATEDATE,CREATETIME)
AS SELECT
     DEFOBJTYPE,DEFOWNER,DEFOBJN1,DEFOBJN2,RELTYPE,
     REFOBJTYPE,REFOWNER,REFOBJN1,REFOBJN3,CREATEDATE,CREATETIME
   FROM SYSDDUSR_USES_PRO
   WHERE DEFOBJN1 IN(USERGROUP,'*PUBLIC*') OR DEFOBJN2 = USERGROUP
WITH CHECK OPTION !
 
Enter command:
INSERT SYSDDMODULE SET
       OWNER       = USER,
       MODULNAM1 = 'module',
       MODULNAM2 = 'noch ein module',
       PROGLANG    = 'programm',
       OBJTYPE     = 'objekt',
       SUBTYPE     = 'subtype',
       VERSION     = '1.',
       LONGNAME    = 'recht lang',
       TYPE        = 'typ',
       CREATEDATE  = DATE,
       CREATETIME  = TIME,
       UPDDATE     = DATE,
       UPDTIME     = TIME!
 
Enter command:
PARSING !
 
Enter command:
UPDATE SYSDDMODULE SET COMMENT = :A WHERE OWNER = USER !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
UPDATE !
Parsing idnr :      1
 
l 500 'der Kommentar: '
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
INSERT SYSDDUSR_USES_PRO VALUES
(1, X'0000000000000001', USERGROUP, USERGROUP, USERGROUP, USERGROUP,
'objekt', 'subtype', '1.', 'needs',
USERGROUP, USERGROUP, USERGROUP, USERGROUP,
'objekt 2', 'subtype 2', '2.', 'keine', DATE, TIME) !
 
Enter command:
GRANT ALL ON SYSDD_USR_USES_PRO TO PUBLIC !
 
Enter command:
SELECT
  T1.OWNER,T1.MODULNAM1,T1.MODULNAM2,T1.PROGLANG,
  T1.CREATEDATE,T1.CREATETIME,T1.COMMENT
FROM SYSDDMODULE T1, SYSDD_USR_USES_PRO T2
WHERE T1.OWNER = T2.REFOWNER OR T1.OWNER = USERGROUP !
 
resultcount :                     1
 
Enter command:
FETCH !
 
OWNER             :  KERN
MODULNAM1         :  module
MODULNAM2         :  noch ein module
PROGLANG          :  programm
CREATEDATE        :  DATEXXXX
CREATETIME        :  TIMEYYYY
COMMENT           :
from      1 to    500:der Kommentar:
maxlen:        500
 
resultcount :                     1
 
Enter command:
ROLLBACK !
 
Enter command:
CREATE TABLE T ( A CHAR (8) KEY, B LONGFILE, C FIXED (8))!
 
Enter command:
PARSING !
 
Enter command:
INSERT T VALUES ('aaa', :B, 4 * 3)!
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
INSERT T VALUES ('aaa', :B, 4 * 3)!
Parsing idnr :      1
 
l 400 'xyz '
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA!
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A        | B                                                  | C
---------+----------------------------------------------------+----------
aaa      | xyz xyz xyz xyz xyz xyz xyz xyz xyz xyz xyz xyz xy |        12
 
resultcount :                     1
 
Enter command:
CREATE TABLE T1 ( A CHAR (8), C FIXED (8))!
 
Enter command:
INSERT T1 VALUES ('aaa', 25)!
 
Enter command:
DECLARE INVISIBLE CURSOR FOR
SELECT DESCRIPTION,
       VALUE (CHR(NUMERIC_VALUE), CHAR_VALUE) "VALUE"
  FROM SYSDBA.TABLESTATISTICS
 WHERE OWNER = 'KERN'
   AND TABLENAME = 'T' !
 
resultcount :                    35
 
Enter command:
DECLARE ERG CURSOR FOR
SELECT COUNT(*) CNT FROM T WHERE B IS NOT NULL!
 
resultcount :                     1
 
Enter command:
SELECT CNT, VALUE FROM INVISIBLE, ERG
WHERE DESCRIPTION = 'DEFINED LONG COLUMNS'
  AND NUM(VALUE) <> CNT !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
FETCH !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
CLOSE INVISIBLE !
 
Enter command:
INSERT T(A,C) SELECT A, C FROM T1 !
 
***ERROR    200 Duplicate key                                              0001
 
Enter command:
INSERT T(A,C) SELECT A, C FROM T1 UPDATE DUPLICATES !
 
Enter command:
DECLARE INVISIBLE CURSOR FOR
SELECT DESCRIPTION,
       VALUE (CHR(NUMERIC_VALUE), CHAR_VALUE) "VALUE"
  FROM SYSDBA.TABLESTATISTICS
 WHERE OWNER = 'KERN'
   AND TABLENAME = 'T' !
 
resultcount :                    35
 
Enter command:
DECLARE ERG CURSOR FOR
SELECT COUNT(*) CNT FROM T WHERE B IS NOT NULL!
 
resultcount :                     1
 
Enter command:
SELECT CNT, VALUE FROM INVISIBLE, ERG
WHERE DESCRIPTION = 'DEFINED LONG COLUMNS'
  AND NUM(VALUE) <> CNT !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
FETCH !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
CLOSE INVISIBLE !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT (KERN TEST!
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TA (A CHAR)!
 
Enter command:
ALTER  TABLE TA ADD  L LONGFILE!
 
Enter command:
ALTER  TABLE TA DROP L!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
CREATE TABLE TA (A CHAR, L LONGFILE)!
 
Enter command:
ALTER  TABLE TA ADD  L2 LONGFILE!
 
Enter command:
ALTER  TABLE TA DROP L2!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
CREATE TABLE TA (A CHAR, L LONGFILE, L2 LONGFILE)!
 
Enter command:
ALTER  TABLE TA ADD  L2 LONGFILE!
 
***ERROR  -6001 Duplicate column name:L2                                   0022
 
Enter command:
ALTER  TABLE TA DROP L2!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
ROLLBACK WORK RELEASE!
 
Enter command:
FILE CONNECT (KERN TEST SQLMODE ORACLE!
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST SQLMODE ORACLE ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TA (A CHAR)!
 
Enter command:
ALTER  TABLE TA ADD  L LONGFILE!
 
Enter command:
ALTER  TABLE TA DROP (L)!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
CREATE TABLE TA (A CHAR, L LONGFILE)!
 
Enter command:
ALTER  TABLE TA ADD  L2 LONGFILE!
 
Enter command:
ALTER  TABLE TA DROP (L2)!
 
Enter command:
DROP   TABLE TA!
 
Enter command:
CREATE TABLE TA (A CHAR, L LONGFILE, L2 LONGFILE)!
 
Enter command:
DROP   TABLE TA !
 
Enter command:
COMMIT WORK RELEASE!
 
Enter command:
FILE CONNECT (KERN TEST!
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 
CREATE TABLE LT1 (
K1 CHAR KEY ,
K2 CHAR KEY ,
L11 LONGFILE BYTE DEFAULT X'31323334',
L12 LONGFILE ) !
 
Enter command:
 
CREATE TABLE LT2 (
L21 LONGFILE BYTE DEFAULT X'35363738',
L22 LONGFILE ASCII ) !
 
Enter command:
 
CREATE VIEW LV1 AS SELECT * FROM LT1 !
 
Enter command:
CREATE VIEW LV2 AS SELECT * FROM LT2 !
 
Enter command:
 
CREATE VIEW LV12 AS SELECT * FROM LT1, LT2 !
 
Enter command:
 
FILE SEL_COLS_TAB ( LV12 !
 
Enter command:
DECLARE SEL_COL CURSOR FOR
 SELECT COLUMNNAME,
        MODE AS "MOD",
        DATATYPE,
        CODETYPE AS "CODE",
        LEN,"DEC",COLUMNPRIVILEGES,"DEFAULT"
   FROM DOMAIN.COLUMNS
  WHERE OWNER <> 'SUT'
    AND TABLENAME = 'LV12'
  ORDER BY POS !
 
resultcount :                     6
 
Enter command:
FETCH SEL_COL INTO :A,:B,:C,:D,:E,:F,:G,:H !
 
COLUMNNAME        :  K1
MOD               :  MAN
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      1
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  K2
MOD               :  MAN
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      1
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  L11
MOD               :  OPT
DATATYPE          :  LONGFILE
CODE              :  BYTE
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  323334
--------------------------------------------------------------------------------
COLUMNNAME        :  L12
MOD               :  OPT
DATATYPE          :  LONGFILE
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  ?????
--------------------------------------------------------------------------------
COLUMNNAME        :  L21
MOD               :  OPT
DATATYPE          :  LONGFILE
CODE              :  BYTE
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  363738
--------------------------------------------------------------------------------
COLUMNNAME        :  L22
MOD               :  OPT
DATATYPE          :  LONGFILE
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+
DEFAULT           :  ?????
 
resultcount :                     6
 
Enter command:
CLOSE SEL_COL !
 
Enter command:
 
INSERT LT1 SET K1 = 'a', K2 = 'z', L11 = DEFAULT, L12 = '012' !
 
Enter command:
INSERT LT1 SET K1 = 'z', K2 = 'a', L12 = '012' !
 
Enter command:
 
INSERT LT2 SET L21 = DEFAULT, L22 = X'333435' !
 
Enter command:
INSERT LT2 SET L22 = X'333435' !
 
Enter command:
 
SELECT * FROM LV12 !
 
resultcount :                     4
 
Enter command:
FETCH !
 
K1                :  a
K2                :  z
L11               :  1234
L12               :  012
L21               :  5678
L22               :  345
-----------------------------------------------------------------------
K1                :  a
K2                :  z
L11               :  1234
L12               :  012
L21               :  5678
L22               :  345
-----------------------------------------------------------------------
K1                :  z
K2                :  a
L11               :  1234
L12               :  012
L21               :  5678
L22               :  345
-----------------------------------------------------------------------
K1                :  z
K2                :  a
L11               :  1234
L12               :  012
L21               :  5678
L22               :  345
 
resultcount :                     4
 
Enter command:
 
INSERT LT1 SET K1 = 'b', K2 = 'y',
L11 =
'Dies sind 1400 Zeichen insgesamt (viele As und ein X): aaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaax'
, L12 = 'hallo' !
 
Enter command:
 
 *KONTROLLESEN DER SAETZE !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM LT1 !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
K1                :  a
K2                :  z
L11               :  1234
L12               :  012
-----------------------------------------------------------------------
K1                :  b
K2                :  y
L11               :
from      1 to    110:Dies sind 1400 Zeichen insgesamt (viele As und ein X): aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
from    111 to   1399:a
from   1400 to   1400:x
maxlen:       1400
L12               :  hallo
-----------------------------------------------------------------------
K1                :  z
K2                :  a
L11               :  1234
L12               :  012
 
resultcount :                     3
 
Enter command:
ROLLBACK WORK RELEASE!
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A LONGFILE DEFAULT 'das ist der Long-Default-Wert',
B CHAR (8) PRIMARY KEY )!
 
Enter command:
INSERT T SET B = 'erstens' !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A                                                  | B
---------------------------------------------------+---------
das ist der Long-Default-Wert                      | erstens
 
resultcount :                     1
 
Enter command:
INSERT T VALUES (DEFAULT, 'zweitens') !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A                                                  | B
---------------------------------------------------+---------
das ist der Long-Default-Wert                      | erstens
das ist der Long-Default-Wert                      | zweitens
 
resultcount :                     2
 
Enter command:
SELECT * FROM T WHERE A = DEFAULT !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0027
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
FILE SEL_COLS_TAB ( T !
 
Enter command:
DECLARE SEL_COL CURSOR FOR
 SELECT COLUMNNAME,
        MODE AS "MOD",
        DATATYPE,
        CODETYPE AS "CODE",
        LEN,"DEC",COLUMNPRIVILEGES,"DEFAULT"
   FROM DOMAIN.COLUMNS
  WHERE OWNER <> 'SUT'
    AND TABLENAME = 'T'
  ORDER BY POS !
 
resultcount :                     2
 
Enter command:
FETCH SEL_COL INTO :A,:B,:C,:D,:E,:F,:G,:H !
 
COLUMNNAME        :  A
MOD               :  OPT
DATATYPE          :  LONGFILE
CODE              :  ASCII
LEN               :  ?????
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  das ist der Long-Default-Wert
--------------------------------------------------------------------------------
COLUMNNAME        :  B
MOD               :  KEY
DATATYPE          :  CHAR
CODE              :  ASCII
LEN               :      8
DEC               :  ????
COLUMNPRIVILEGES  :  SEL+UPD+
DEFAULT           :  ?????
 
resultcount :                     2
 
Enter command:
CLOSE SEL_COL !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T (
A CHAR (8) KEY,
B CHAR (5) KEY,
C CHAR (3) KEY,
D CHAR (12) KEY,
E FIXED (2) KEY,
F CHAR (20),
G CHAR (30),
H LONGFILE )!
 
Enter command:
CREATE VIEW V (A,B,C,D,E) AS SELECT A,B,C,D,E FROM T !
 
Enter command:
DELETE V WHERE A = 'a' AND B = 'b' AND C = 'c' !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), B LONGFILE, C LONGFILE)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T SET A = 'abc',
B = 'das soll der long sein', C = 'das ist der neuere Long'!
 
Enter command:
 
INSERT T SET A = '2a2b2c', B = :B,
 C = 'das ist der neuere Long'!
 
 l 5000 'das soll der long sein '
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :  abc
B                 :  das soll der long sein
C                 :  das ist der neuere Long
-----------------------------------------------------------------------
A                 :  2a2b2c
B                 :
from      1 to   5000:das soll der long sein
maxlen:       5000
C                 :  das ist der neuere Long
 
resultcount :                     2
 
Enter command:
DECLARE ERG CURSOR FOR
SELECT * FROM T FOR REUSE !
 
resultcount :                     2
 
Enter command:
DROP TABLE T !
 
Enter command:
DIAGNOSE SHARE PARSE DROP !
 
Enter command:
FETCH ERG !
 
A                 :  abc
B                 :  das soll der long sein
C                 :  das ist der neuere Long
-----------------------------------------------------------------------
A                 :  2a2b2c
B                 :
from      1 to   5000:das soll der long sein
maxlen:       5000
C                 :  das ist der neuere Long
 
resultcount :                     2
 
Enter command:
COMMIT !
 
Enter command:
 * JUST TO SPENT SOME TIME TO LET GARBAGE COLLECTOR CLEAN LONG-FILE !
 
Enter command:
 * > 3 MIN AS GARBAGE-COLLECTOR WILL WORK AT LEAST AFTER 3 MIN !
 
Enter command:
SLEEP 10 !
COMMIT RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TTT ( L LONGFILE )!
 
Enter command:
INSERT INTO TTT SET L = 1!
 
***ERROR  -8004 Constant must be compatible with column type and length    0025
 
Enter command:
ROLLBACK RELEASE!
 
Enter command:
FILE CONNECT (KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE HUGO ( I INT, L LONGFILE DEFAULT 'kkk')!
 
Enter command:
INSERT INTO HUGO VALUES( 1, '111' )!
 
Enter command:
SELECT * INTO :A, :B FROM HUGO !
 
I                 :            1
L                 :  111
 
Enter command:
UPDATE HUGO SET I=2,L='2222'!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0024
 
Enter command:
SELECT * INTO :A, :B FROM HUGO !
 
I                 :            1
L                 :  111
 
Enter command:
UPDATE HUGO SET L = NULL!
 
resultcount :                     1
 
Enter command:
SELECT * INTO :A, :B FROM HUGO !
 
I                 :            1
L                 :  ?????
 
Enter command:
UPDATE HUGO SET L = DEFAULT!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0021
 
Enter command:
SELECT * INTO :A, :B FROM HUGO !
 
I                 :            1
L                 :  ?????
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT (KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TAB170
 ( COL1  LONGFILE,
   COL2  LONGFILE CONSTRAINT FK_COL1_SELFREF REFERENCES  TAB170(COL1),
     CONSTRAINT PK_COL1 PRIMARY  KEY (COL1)) !
 
***ERROR  -7002 KEY not allowed                                            0140
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), B FIXED (7))!
 
Enter command:
INSERT T VALUES ('aaa', 1)!
 
Enter command:
CREATE TABLE T2 ( A VARCHAR (8)NOT NULL DEFAULT '',
A1 LONGFILE NOT NULL DEFAULT '', B FIXED(7))!
 
Enter command:
INSERT INTO T2 (B) VALUES (17)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
INSERT INTO T2 (B) VALUES (44)!
 
Enter command:
PARS_EXECUTE !
 
Enter command:
INSERT INTO T2 (B) SELECT B FROM T !
 
Enter command:
SELECT * FROM T2 !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A        | A1                                                 | B
---------+----------------------------------------------------+---------
         |                                                    |       17
         |                                                    |       44
         |                                                    |        1
 
resultcount :                     3
 
Enter command:
CREATE TABLE T3 ( A VARCHAR (8)NOT NULL DEFAULT 'r',
A1 LONGFILE NOT NULL DEFAULT 'r', B FIXED(7))!
 
Enter command:
INSERT INTO T3 (B) VALUES (17)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
INSERT INTO T3 (B) VALUES (44)!
 
Enter command:
PARS_EXECUTE !
 
Enter command:
INSERT INTO T3 (B) SELECT B FROM T !
 
Enter command:
SELECT * FROM T3 !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
A        | A1                                                 | B
---------+----------------------------------------------------+---------
r        | r                                                  |       17
r        | r                                                  |       44
r        | r                                                  |        1
 
resultcount :                     3
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T1 (S1 INT, S2 CHAR (10), S3 LONGFILE) !
 
Enter command:
    INSERT T1 VALUES (1, 'Hallo', 'long value') !
 
Enter command:
    INSERT T1 VALUES (1, 'BYE BYE', NULL) !
 
Enter command:
CREATE TABLE T2
    AS SELECT (S1 - 1) S1, S2 FROM T1 !
 
Enter command:
CREATE VIEW V1
    AS SELECT * FROM T1 !
 
Enter command:
SELECT * FROM V1 !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
S1          | S2         | S3
------------+------------+---------------------------------------------------
          1 | Hallo      | long value
          1 | BYE BYE    | ??????????????????????????????????????????????????
 
resultcount :                     2
 
Enter command:
CREATE VIEW V2
    AS SELECT * FROM T1 WHERE T1.S1 NOT IN (SELECT S1 FROM T2) !
 
Enter command:
SELECT * FROM V2!
 
resultcount :                     2
 
Enter command:
FETCH !
 
S1          | S2         | S3
------------+------------+---------------------------------------------------
          1 | Hallo      | long value
          1 | BYE BYE    | ??????????????????????????????????????????????????
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TAB6 (
 A1 LONGFILE ,
 A2 CHAR(515)
   )!
 
Enter command:
INSERT INTO TAB6 VALUES( '§bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶',
         '§bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶' )!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT INTO TAB6 VALUES( :P,
         '§bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶' )!
 
l 30 '§bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶'
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM TAB6!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A1                :  §bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶
A2                :  §bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶
--------------------------------------------------------------------------------
A1                :  §bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶§
A2                :  §bY@O£{of[]}≤≥ËÓ˘÷‹¢•P˙ÒøΩºª¶
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A INT, B INT, C INT,
                 PRIMARY KEY (A,B,C),
                 D INT,
                 E LONGFILE)!
 
Enter command:
INSERT INTO T VALUES (1,1,1,1,'alter Wert')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
UPDATE T SET C =C+1, E = :LONG
   WHERE A = 1 AND B = 1 AND D = 1!
 
l 300 'neuer Wert '
 
resultcount :                     1
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :            1
B                 :            1
C                 :            2
D                 :            1
E                 :
from      1 to    300:neuer Wert
maxlen:        300
 
resultcount :                     1
 
Enter command:
UPDATE T SET C =C+1
   WHERE A = 1 AND B = 1 AND D = 1!
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE !
 
Enter command:
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :            1
B                 :            1
C                 :            3
D                 :            1
E                 :
from      1 to    300:neuer Wert
maxlen:        300
 
resultcount :                     1
 
Enter command:
UPDATE T SET C =C+1, E = NULL
   WHERE A = 1 AND B = 1 AND D = 1!
 
resultcount :                     1
 
Enter command:
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :            1
B                 :            1
C                 :            4
D                 :            1
E                 :  ?????
 
resultcount :                     1
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( K CHAR (8) PRIMARY KEY,A CHAR (8),
   B FIXED (7), C LONGFILE BYTE)!
 
Enter command:
INSERT INTO T VALUES ('key', 'aaa', 1, NULL)!
 
Enter command:
CREATE TABLE DUMMY_LONG (DUMMYLONG LONGFILE BYTE)!
 
Enter command:
INSERT DUMMY_LONG VALUES (NULL)!
 
Enter command:
SELECT K,A,B,C FROM T
UNION ALL
SELECT 'k2', NULL, NULL, NULL FROM DUAL, DUMMY_LONG
ORDER BY 1!
 
resultcount :                     2
 
Enter command:
MFETCH!
2
 
K                 :  k2
A                 :  ?????
B                 :  ????????
C                 :  ?????
-----------------------------------------------------------------------
K                 :  key
A                 :  aaa
B                 :         1
C                 :  ?????
 
Enter command:
 
SELECT K,A,B,C FROM T
UNION ALL
SELECT 'k2', NULL, NULL, DUMMYLONG FROM DUAL, DUMMY_LONG
ORDER BY 1!
 
resultcount :                     2
 
Enter command:
MFETCH!
2
 
K                 :  k2
A                 :  ?????
B                 :  ????????
C                 :  ?????
-----------------------------------------------------------------------
K                 :  key
A                 :  aaa
B                 :         1
C                 :  ?????
 
Enter command:
 
ROLLBACK RELEASE !
 
Enter command:
SENDERID ODB!
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 CREATE TABLE TEST2 (
    FRAGMENTAPPLET  LONGFILE VARCHAR DEFAULT ' ',
    FRAGMENTCREATED DATE         DEFAULT DATE,
    FRAGMENTID      INTEGER      NOT NULL PRIMARY KEY
 )!
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTCREATED,FRAGMENTID
    ) VALUES (
    '1999-01-01',-1 )
!
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTCREATED,FRAGMENTID
    )
    SELECT DATE, 4711 FROM DUAL !
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTCREATED,FRAGMENTID
    ) VALUES (
    DATE('1999-01-01'),0 )
!
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTAPPLET,FRAGMENTCREATED,FRAGMENTID
    ) VALUES (
    'test applet',DATE('1999-01-23'),3 )
!
 
Enter command:
 INSERT INTO TEST2 (
    FRAGMENTAPPLET,FRAGMENTCREATED,FRAGMENTID
    ) VALUES (
    'test applet','1999-01-23',4 )!
 
Enter command:
INSERT TEST2 SELECT FRAGMENTAPPLET,FRAGMENTCREATED,FRAGMENTID+100
FROM TEST2!
 
Enter command:
DECLARE C CURSOR FOR SELECT * FROM TEST2 FOR REUSE!
 
resultcount :                    10
 
Enter command:
FETCH C!
 
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  1999-01-01
FRAGMENTID        :           -1
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  1999-01-01
FRAGMENTID        :            0
-----------------------------------------------------------------------
FRAGMENTAPPLET    :  test applet
FRAGMENTCREATED   :  1999-01-23
FRAGMENTID        :            3
-----------------------------------------------------------------------
FRAGMENTAPPLET    :  test applet
FRAGMENTCREATED   :  1999-01-23
FRAGMENTID        :            4
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  1999-01-01
FRAGMENTID        :           99
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  1999-01-01
FRAGMENTID        :          100
-----------------------------------------------------------------------
FRAGMENTAPPLET    :  test applet
FRAGMENTCREATED   :  1999-01-23
FRAGMENTID        :          103
-----------------------------------------------------------------------
FRAGMENTAPPLET    :  test applet
FRAGMENTCREATED   :  1999-01-23
FRAGMENTID        :          104
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  YYYY-MM-DD
FRAGMENTID        :         4711
-----------------------------------------------------------------------
FRAGMENTAPPLET    :
FRAGMENTCREATED   :  YYYY-MM-DD
FRAGMENTID        :         4811
 
resultcount :                    10
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
SENDERID XCI!
 * PTS 1123714-7 !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TEST (ID INTEGER, LONG_COL LONGFILE BYTE)!
 
Enter command:
INSERT INTO TEST VALUES (1, 'aa')!
 
Enter command:
INSERT INTO TEST VALUES (1, 'bb')!
 
Enter command:
INSERT INTO TEST VALUES (2, 'cc')!
 
Enter command:
 
SELECT DISTINCT ID FROM TEST WHERE ID IS NOT NULL!
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE LONG_COL IS NOT NULL!
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM
   (SELECT ID FROM TEST WHERE LONG_COL IS NOT NULL) !
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE ID IN
   (SELECT ID FROM TEST WHERE LONG_COL IS NOT NULL) !
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE ID IN
   (SELECT ID FROM TEST WHERE LONG_COL IS NOT NULL AND ROWNO <= 1000000) !
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID, LONG_COL FROM TEST WHERE LONG_COL IS NOT NULL!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:LON 0021
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
SELECT DISTINCT ID FROM
   (SELECT ID, LONG_COL FROM TEST WHERE LONG_COL IS NOT NULL) !
 
resultcount :                     2
 
Enter command:
FETCH!
 
ID
-----------
          1
          2
 
resultcount :                     2
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE (ID, LONG_COL) IN
   (SELECT ID, LONG_COL FROM TEST WHERE LONG_COL IS NOT NULL) !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:LON 0066
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
SELECT DISTINCT ID FROM TEST WHERE (ID , LONG_COL) IN
   (SELECT ID, LONG_COL FROM TEST
     WHERE LONG_COL IS NOT NULL AND ROWNO <= 1000000) !
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG:LON 0067
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
 * PTS 1123726-9 !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE PRIMA (
   OID INTEGER,
   CONSTRAINT PRIMA_PK PRIMARY KEY(OID),
   VAL LONGFILE DEFAULT '')
!
 
Enter command:
 CREATE TABLE SEC1 (
   OID INTEGER DEFAULT SERIAL,
   CONSTRAINT SEC1_PK PRIMARY KEY(OID),
   CONSTRAINT SEC1_FK FOREIGN KEY(OID) REFERENCES PRIMA(OID) ON DELETE
CASCADE,
   VAL LONGFILE DEFAULT '')
!
 
Enter command:
 CREATE VIEW V2 (OID, VAL, VAL1) AS
   SELECT P.OID, P.VAL, S1.VAL
   FROM PRIMA P, SEC1 S1
   WHERE P.OID = S1.OID
   WITH CHECK OPTION
!
 
Enter command:
 INSERT INTO V2 (OID, VAL, VAL1) VALUES (1, 'prima a', 'sec1 a')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
INSERT INTO V2 (OID, VAL, VAL1) VALUES (2, 'prima b', 'sec1 b') !
 
Enter command:
DATA !
 
Enter command:
INSERT INTO V2 (OID, VAL, VAL1) VALUES (3, :A, :B ) !
 
l 7 'prima c'
l 6 'sec1 c'
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
 SELECT * FROM V2!
 
resultcount :                     3
 
Enter command:
 FETCH!
 
OID               :            1
VAL               :  prima a
VAL1              :  sec1 a
-----------------------------------------------------------------------
OID               :            2
VAL               :  prima b
VAL1              :  sec1 b
-----------------------------------------------------------------------
OID               :            3
VAL               :  prima c
VAL1              :  sec1 c
 
resultcount :                     3
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE DBM350_SM (MSN SERIAL(8) PRIMARY KEY,
STATUSCODE INTEGER, DIST_FILE LONGFILE BYTE, DIST_NUM INTEGER)!
 
Enter command:
INSERT DBM350_SM (STATUSCODE, DIST_FILE, DIST_NUM) VALUES
(3, NULL, 11)!
 
Enter command:
INSERT DBM350_SM (STATUSCODE, DIST_FILE, DIST_NUM) VALUES
(3, NULL, 11)!
 
Enter command:
SELECT * FROM DBM350_SM!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
MSN               :            8
STATUSCODE        :            3
DIST_FILE         :  ?????
DIST_NUM          :           11
-----------------------------------------------------------------------
MSN               :            9
STATUSCODE        :            3
DIST_FILE         :  ?????
DIST_NUM          :           11
 
resultcount :                     2
 
Enter command:
PARS_THEN_EX!
 
Enter command:
DATA!
 
Enter command:
UPDATE DBM350_SM SET STATUSCODE=-2, DIST_FILE=?,
DIST_NUM=DIST_NUM+1 WHERE MSN=9!
 
l 917 'abcdefg'
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM DBM350_SM!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
MSN               :            8
STATUSCODE        :            3
DIST_FILE         :  ?????
DIST_NUM          :           11
-----------------------------------------------------------------------
MSN               :            9
STATUSCODE        :           -2
DIST_FILE         :
from      1 to    917:abcdefg
maxlen:        917
DIST_NUM          :           12
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), B LONG BYTE DEFAULT 'abc')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
INSERT T (A) VALUES ('xyz')!
 
Enter command:
PARS_EXECUTE !
 
Enter command:
SELECT * INTO :A, :B FROM T !
 
A                 :  xyz
B                 :  abc
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( K INT, A CHAR (30), B LONGFILE)!
 
Enter command:
INSERT INTO T VALUES (1, 'abcdef', 'abcdef')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT INTO T VALUES (2, 'kurzer Long', :A)!
 
l 1234 'das ist der 1234 Bytes lange String'
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT INTO T VALUES (2, 'langer long', :A)!
 
l 12345 'das ist der 12345 Bytes lange LOOOONG String'
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE!
 
Enter command:
SELECT *, SUBSTR(B, 5) FROM T!
 
***ERROR  -5010 Missing value specification                                0018
 
Enter command:
SELECT *, SUBSTR(B, 5, 100) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :  ef
--------------------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :  ist der 1234 Bytes lange Stringdas ist der 1234 Bytes lange Stringdas ist der 1234 Bytes lange Strin
--------------------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :  ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 1234
 
resultcount :                     3
 
Enter command:
SELECT *, SUBSTR(B, 1, 20) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :  abcdef
-----------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :  das ist der 1234 Byt
-----------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :  das ist der 12345 By
 
resultcount :                     3
 
Enter command:
SELECT *, SUBSTR(B, 10, 20) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :  ?????
-----------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :  er 1234 Bytes lange
-----------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :  er 12345 Bytes lange
 
resultcount :                     3
 
Enter command:
SELECT *, SUBSTR(B, 1, 20000) FROM T!
 
***ERROR  -3046 Invalid char position in string function                   0011
 
Enter command:
FETCH!
 
***ERROR    100 Row not found                                              0001
 
Enter command:
SELECT *, SUBSTR(B, 10000, 3000) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :  ?????
--------------------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :  ?????
--------------------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :
 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringda
s ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG
 Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lang
e LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 B
ytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist de
r 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringd
as ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOON
G Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lan
ge LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345
Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist d
er 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG String
das ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOO
NG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes la
nge LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345
 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist
der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Strin
gdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOO
ONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes l
ange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 1234
5 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist
 der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stri
ngdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOO
OONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes
lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 123
45 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas is
t der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Str
ingdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes lange LO
OOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes
 lange LOOOONG Stringdas ist der 12345 Bytes lange LOOOONG Stringdas ist der 12
345 Bytes lange LOOOONG Stringdas ist der 12345 Bytes l
 
resultcount :                     3
 
Enter command:
 
SELECT *, LENGTH(A), LENGTH (B) FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
K                 :            1
A                 :  abcdef
B                 :  abcdef
EXPRESSION1       :      6
EXPRESSION2       :            6
-----------------------------------------------------------------------
K                 :            2
A                 :  kurzer Long
B                 :
from      1 to   1234:das ist der 1234 Bytes lange String
maxlen:       1234
EXPRESSION1       :     11
EXPRESSION2       :         1234
-----------------------------------------------------------------------
K                 :            2
A                 :  langer long
B                 :
from      1 to  12345:das ist der 12345 Bytes lange LOOOONG String
maxlen:      12345
EXPRESSION1       :     11
EXPRESSION2       :        12345
 
resultcount :                     3
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST SQLMODE ORACLE !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST SQLMODE ORACLE ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE DOCUMENT_FORMAT (
E_DOC_VER_K_DOCUMENT  NUMBER (9) NOT NULL,
B_TEXT                LONG BYTE)!
 
Enter command:
PARSING !
 
Enter command:
INSERT INTO DOCUMENT_FORMAT (E_DOC_VER_K_DOCUMENT,B_TEXT )
         SELECT TO_NUMBER(?), ? FROM DUAL!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0081
 
Enter command:
INSERT INTO DOCUMENT_FORMAT (E_DOC_VER_K_DOCUMENT,B_TEXT )
         VALUES ( TO_NUMBER(?),?  ) !
parsing idnr :       1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
INSERT !
Parsing idnr :      1
 
c 254 '1'
l 80 'abcd '
 
Enter command:
NODATA !
 
Enter command:
PARS_EXECUTE !
 
Enter command:
SELECT * FROM DOCUMENT_FORMAT!
 
resultcount :                     0
 
Enter command:
FETCH INTO :A, :B !
 
E_DOC_VER_K_DOCUMENT | B_TEXT
---------------------+---------------------------------------------------
         1           | abcd abcd abcd abcd abcd abcd abcd abcd abcd abcd
 
resultcount :                     1
 
Enter command:
DROP TABLE DOCUMENT_FORMAT!
 
Enter command:
COMMIT RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), LB LONG BYTE, L LONG, LA LONG ASCII, B CHAR (8))!
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', '414243616263',
'515253616263', 'bcdefghi')!
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', '414243616263',
'515253616263', 'bcd' || 'efg 2')!
 
Enter command:
 
PARS_THEN_EX !
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', '414243616263',
'515253616263', 'bcdefg 3')!
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', '414243616263',
'515253616263', 'bcd' || 'efg 4')!
 
Enter command:
 
DATA !
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', :P,
'515253616263', 'bcdefg 5')!
 
l 12 '414243616263'
 
Enter command:
INSERT INTO T VALUES ('abcdefgh', X'313233616263', :P,
'515253616263', 'bcd' || 'efg 6')!
 
l 12 '414243616263'
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefghi
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 2
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 3
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 4
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 5
-----------------------------------------------------------------------
A                 :  abcdefgh
LB                :  123abc
L                 :  414243616263
LA                :  515253616263
B                 :  bcdefg 6
 
resultcount :                     6
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T1 (S1 INT, S2 CHAR (10), S3 LONG) !
 
Enter command:
INSERT T1 VALUES (1, 'Hallo', 'long value') !
 
Enter command:
INSERT T1 VALUES (1, 'BYE BYE', NULL) !
 
Enter command:
CREATE TABLE T2 AS SELECT (S1 - 1) S1, S2 FROM T1 !
 
Enter command:
CREATE VIEW V2 AS SELECT * FROM T1 WHERE T1.S1 NOT IN (SELECT S1 FROM T2) !
 
Enter command:
SELECT * FROM V2!
 
resultcount :                     2
 
Enter command:
FETCH!
 
S1          | S2         | S3
------------+------------+---------------------------------------------------
          1 | Hallo      | long value
          1 | BYE BYE    | ??????????????????????????????????????????????????
 
resultcount :                     2
 
Enter command:
SELECT * FROM (SELECT * FROM T1)!
 
resultcount :                     2
 
Enter command:
FETCH!
 
S1          | S2         | S3
------------+------------+---------------------------------------------------
          1 | Hallo      | long value
          1 | BYE BYE    | ??????????????????????????????????????????????????
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A INT, B LONGFILE)!
 
Enter command:
INSERT T VALUES (1, 'das ist der long')!
 
Enter command:
COMMENT ON TABLE KERN.T IS 'das ist der Kommentar'!
 
Enter command:
SELECT A, SUBSTR(B,1,8) FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A           | EXPRESSION1
------------+------------
          1 | das ist
 
resultcount :                     1
 
Enter command:
SELECT *, SUBSTR(COMMENT,1,8) FROM SYSDD.TABLES
WHERE TABLENAME = 'T' AND SCHEMANAME = 'KERN'!
 
***ERROR  -9000 System error: Not yet implemented:virtual long column      0011
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( L LONGFILE, A CHAR (300))!
 
Enter command:
INSERT T VALUES ('das ist der long-wert', 'abc')!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T VALUES (:L, 'abc')!
 
l 12000 'das ist der 2. long-wert'
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
UPDATE T SET A = SUBSTR (L, 1,20)!
 
resultcount :                     2
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
L                 :  das ist der long-wert
A                 :  das ist der long-wer
--------------------------------------------------------------------------------
L                 :
from      1 to  12000:das ist der 2. long-wert
maxlen:      12000
A                 :  das ist der 2. long-
 
resultcount :                     2
 
Enter command:
UPDATE T SET A = SUBSTR (L, 1,400)!
 
***ERROR  -2010 Assignment impossible, char value too long                 0034
 
Enter command:
UPDATE T SET A = SUBSTR (L, 13,100)!
 
resultcount :                     2
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
L                 :  das ist der long-wert
A                 :  long-wert
--------------------------------------------------------------------------------
L                 :
from      1 to  12000:das ist der 2. long-wert
maxlen:      12000
A                 :  2. long-wertdas ist der 2. long-wertdas ist der 2. long-wertdas ist der 2. long-wertdas ist der 2. l
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TAB1 (A INT PRIMARY KEY, B CHAR(10), C LONGFILE, D FIXED)!
 
Enter command:
CREATE TABLE TAB2 (A INT, B CHAR(10), C LONGFILE, D INT)!
 
Enter command:
INSERT INTO TAB1 VALUES (1, 'bla', NULL, 5.2)!
 
Enter command:
INSERT INTO TAB2 VALUES (1, 'bla', NULL, 5)!
 
Enter command:
CREATE VIEW SELTAB1 AS SELECT * FROM TAB1!
 
Enter command:
CREATE VIEW SELTAB2 AS SELECT * FROM TAB2!
 
Enter command:
CREATE VIEW SELTAB1_V1 AS
SELECT * FROM SELTAB1 S WHERE S.A IN (SELECT A FROM SELTAB2)!
 
Enter command:
CREATE VIEW CC1 AS SELECT * FROM SELTAB1_V1 !
 
Enter command:
CREATE VIEW SELTAB1_V2 AS
SELECT * FROM SELTAB1 S !
 
Enter command:
SELECT * FROM SELTAB1 S WHERE S.A IN (SELECT A FROM SELTAB2)!
 
resultcount :                     1
 
Enter command:
FETCH!
 
A                 :            1
B                 :  bla
C                 :  ?????
D                 :       5
 
resultcount :                     1
 
Enter command:
SELECT * FROM SELTAB1_V2!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :            1
B                 :  bla
C                 :  ?????
D                 :       5
 
resultcount :                     1
 
Enter command:
SELECT * FROM SELTAB1_V1!
 
resultcount :                     1
 
Enter command:
FETCH !
 
A                 :            1
B                 :  bla
C                 :  ?????
D                 :       5
 
resultcount :                     1
 
Enter command:
SELECT * FROM CC1!
 
resultcount :                     1
 
Enter command:
FETCH!
 
A                 :            1
B                 :  bla
C                 :  ?????
D                 :       5
 
resultcount :                     1
 
Enter command:
ROLLBACK WORK RELEASE !
 
Enter command:
 * PTS 1130589, 1136988 !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TAB
(
    ID CHAR(24) BYTE,
    PROP CHAR(24) BYTE,
    SHORT_COL CHAR(24) ASCII,
    LONG_COL LONG BYTE
)!
 
Enter command:
INSERT TAB VALUES (X'414243', X'515253', 'xyz', X'31323334')!
 
Enter command:
SELECT * INTO :A, :B, :C, :D FROM TAB !
 
ID                :  414243
PROP              :  515253
SHORT_COL         :  xyz
LONG_COL          :  1234
 
Enter command:
PARS_THEN_EX!
 
Enter command:
DATA !
 
Enter command:
UPDATE TAB SET SHORT_COL=?, LONG_COL=? WHERE ID=? AND PROP=?!
 
c 24 'NEWVALUE'
l 120 'newvalue NEWVALUE '
b 24 414243
b 24 515253
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE
NODATA !
 
Enter command:
SELECT * INTO :A, :B, :C, :D FROM TAB !
 
ID                :  414243
PROP              :  515253
SHORT_COL         :  NEWVALUE
LONG_COL          :
from      1 to    120:newvalue NEWVALUE
maxlen:        120
 
Enter command:
PARS_THEN_EX!
 
Enter command:
DATA !
 
Enter command:
UPDATE TAB SET (SHORT_COL, LONG_COL) = (?,?) WHERE ID=? AND PROP=?!
 
c 24 'NEWER VALUE'
l 120 'newervalue NEWERVALUE '
b 24 414243
b 24 515253
 
resultcount :                     1
 
Enter command:
PARS_EXECUTE
NODATA !
 
Enter command:
SELECT * INTO :A, :B, :C, :D FROM TAB !
 
ID                :  414243
PROP              :  515253
SHORT_COL         :  NEWER VALUE
LONG_COL          :
from      1 to    120:newervalue NEWERVALUE
maxlen:        120
 
Enter command:
PARS_EXECUTE !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A INT , B LONGFILE, C LONGFILE, D INT,
E LONGFILE, F INT, G LONGFILE, H INT)!
 
Enter command:
INSERT T VALUES (1,'default','default',1,'default',1,'default',1)!
 
Enter command:
INSERT T VALUES (2,'default','default',2,'default',2,'default',2)!
 
Enter command:
INSERT T VALUES (3,'default','default',3,'default',3,'default',3)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T VALUES (:A,:B,:C,:D,:E,:F,:G,:H)!
 
n 10 4
l 40
l 1000 'alter Wert '
n 10 4
l 40
n 10 4
l 40
n 10 4
 
Enter command:
UPDATE T SET
A =:A, B = :B, C = :C, D = :D, E = :E, F = :F, G = :G, H = :H
WHERE A <  3 !
 
n 10 4711
l 40
l 1000 'neuer Wert '
n 10 4711
l 40
n 10 4711
l 40
n 10 4711
 
resultcount :                     2
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :         4711
B                 :  ?????
C                 :
from      1 to   1000:neuer Wert
maxlen:       1000
D                 :         4711
E                 :  ?????
F                 :         4711
G                 :  ?????
H                 :         4711
-----------------------------------------------------------------------
A                 :         4711
B                 :  ?????
C                 :
from      1 to   1000:neuer Wert
maxlen:       1000
D                 :         4711
E                 :  ?????
F                 :         4711
G                 :  ?????
H                 :         4711
-----------------------------------------------------------------------
A                 :            3
B                 :  default
C                 :  default
D                 :            3
E                 :  default
F                 :            3
G                 :  default
H                 :            3
-----------------------------------------------------------------------
A                 :            4
B                 :  ?????
C                 :
from      1 to   1000:alter Wert
maxlen:       1000
D                 :            4
E                 :  ?????
F                 :            4
G                 :  ?????
H                 :            4
 
resultcount :                     4
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE TEST ( I INT , C CHAR(10) , L LONG ) !
 
Enter command:
INSERT TEST VALUES (1,'hallo', 'xxx')!
 
Enter command:
PARSING !
 
Enter command:
UPDATE TEST SET C = ? , L = ? WHERE I = ? !
parsing idnr :       1
 
Enter command:
INSERT TEST VALUES (2, 'hallu', ?) !
parsing idnr :       2
 
Enter command:
EXECUTING !
 
Enter command:
DATA!
 
Enter command:
 
UPDATE !
Parsing idnr :      1
 
c 10 'halli'
c 32
n 10 1
 
resultcount :                     1
 
Enter command:
INSERT !
Parsing idnr :      2
 
l 10 'test'
 
Enter command:
PARS_EXECUTE !
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T1 (S1 INT KEY, S2 LONG) !
 
Enter command:
COMMIT !
 
Enter command:
PARSING !
 
Enter command:
INSERT T1 VALUES (1, 'Dies ist ein doofer test') !
parsing idnr :       1
 
Enter command:
PARS_EXECUTE !
 
Enter command:
ROLLBACK !
 
Enter command:
EXECUTING !
 
Enter command:
INSERT !
Parsing idnr :      1
 
Enter command:
 
 
PARS_EXECUTE !
 
Enter command:
DROP TABLE T1 !
 
Enter command:
 
CREATE TABLE S ( CID CHAR(24)) !
 
Enter command:
INSERT S VALUES ('3031')!
 
Enter command:
 
CREATE TABLE T (
 CID CHAR (24) ,
 NAME_ID CHAR (24) ,
 SHORT_VALUE CHAR (499) NOT NULL ,
 LONG_VALUE  LONG BYTE,
 VIEWOWNER CHAR(32) DEFAULT USERGROUP,
 PRIMARY KEY (NAME_ID,CID)) !
 
Enter command:
 
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
 
INSERT T COLUMNS (CID, NAME_ID, SHORT_VALUE, LONG_VALUE)
VALUES ((SELECT CID FROM S WHERE CID = ?), ?, ?, ?)!
 
c 24 '3031'
c 24 '3031'
c 499 'hallo'
c 32
 
Enter command:
NODATA!
 
Enter command:
PARS_EXECUTE!
 
Enter command:
 
SELECT * FROM T!
 
resultcount :               unknown
 
Enter command:
FETCH !
 
CID               :  3031
NAME_ID           :  3031
SHORT_VALUE       :  hallo
LONG_VALUE        :  ?????
VIEWOWNER         :  KERN
 
resultcount :                     1
 
Enter command:
 
DROP TABLE T!
 
Enter command:
DROP TABLE S!
 
Enter command:
 
COMMIT RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( A CHAR (8), B LONGFILE DEFAULT 'abcdef',
 C LONGFILE DEFAULT 'mopqr', D LONGFILE, E FIXED (8))!
 
Enter command:
INSERT T VALUES ('aaaa', DEFAULT, DEFAULT, 'abc', 1)!
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT T VALUES (:A, :B, DEFAULT, :D, 2)!
 
c 8 'bbb'
d
l 120 'long'
 
Enter command:
INSERT T VALUES ('a2', DEFAULT, :C, :D, :E)!
 
d
l 300 'dddd'
n 8 4
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :  aaaa
B                 :  abcdef
C                 :  mopqr
D                 :  abc
E                 :          1
-----------------------------------------------------------------------
A                 :  bbb
B                 :  abcdef
C                 :  mopqr
D                 :
from      1 to    120:long
maxlen:        120
E                 :          2
-----------------------------------------------------------------------
A                 :  a2
B                 :  abcdef
C                 :  mopqr
D                 :
from      1 to    300:d
maxlen:        300
E                 :          4
 
resultcount :                     3
 
Enter command:
 
UPDATE T SET B = 'das ist neues b' WHERE E = 1!
 
***ERROR  -7032 SQL statement not allowed for column of data type LONG     0019
 
Enter command:
 
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
UPDATE T SET B = :B WHERE E = 2!
 
d
 
***ERROR  -9000 System error: Not yet implemented                          0004
 
Enter command:
PARS_EXECUTE!
 
Enter command:
NODATA !
 
Enter command:
SELECT * FROM T !
 
resultcount :               unknown
 
Enter command:
FETCH!
 
A                 :  aaaa
B                 :  abcdef
C                 :  mopqr
D                 :  abc
E                 :          1
-----------------------------------------------------------------------
A                 :  bbb
B                 :  abcdef
C                 :  mopqr
D                 :
from      1 to    120:long
maxlen:        120
E                 :          2
-----------------------------------------------------------------------
A                 :  a2
B                 :  abcdef
C                 :  mopqr
D                 :
from      1 to    300:d
maxlen:        300
E                 :          4
 
resultcount :                     3
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE DUMMY1 (
"Column1" CHAR (8), "Memo" LONG) !
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
INSERT DUMMY1 VALUES ('abc', :L)!
 
l 120 'das ist der lob '
 
Enter command:
INSERT DUMMY1 VALUES ('def', :L)!
 
l 10200 'das ist der loooooong lob of 10200 bytes '
 
Enter command:
PARS_EXECUTE !
 
Enter command:
NODATA!
 
Enter command:
CREATE TABLE DUMMY2 ("Column1" CHAR (8)) !
 
Enter command:
INSERT DUMMY2 VALUES ('abc')!
 
Enter command:
INSERT DUMMY2 VALUES ('def')!
 
Enter command:
CREATE VIEW V1 AS
SELECT T0."Column1", SUBSTR(T0."Memo", 1, 50)
    FROM DUMMY1 T0
         INNER JOIN
         DUMMY2 T1
         ON T0."Column1" = T1."Column1" !
 
Enter command:
CREATE TABLE TEMP.TEST3 ("Column1", "ColumnMemo") AS
  SELECT T0."Column1", SUBSTR(T0."Memo", 1, 50)
    FROM DUMMY1 T0
         INNER JOIN
         DUMMY2 T1
         ON T0."Column1" = T1."Column1" !
 
Enter command:
CREATE TABLE TEMP.TEST3A ("Column1", "ColumnMemo") AS
  SELECT T0."Column1", SUBSTR_LOB
    FROM (SELECT "Column1", SUBSTR("Memo", 1, 50) SUBSTR_LOB FROM DUMMY1) T0
         INNER JOIN
         DUMMY2 T1
         ON T0."Column1" = T1."Column1" !
 
Enter command:
CREATE TABLE TEMP.TEST5("Column1", "ColumnMemo") AS
  SELECT * FROM V1 !
 
Enter command:
SELECT * FROM TEMP.TEST3!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
Column1  | ColumnMemo
---------+---------------------------------------------------
abc      | das ist der lob das ist der lob das ist der lob da
def      | das ist der loooooong lob of 10200 bytes das ist d
 
resultcount :                     2
 
Enter command:
SELECT * FROM TEMP.TEST3A!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
Column1  | ColumnMemo
---------+---------------------------------------------------
abc      | das ist der lob das ist der lob das ist der lob da
def      | das ist der loooooong lob of 10200 bytes das ist d
 
resultcount :                     2
 
Enter command:
SELECT * FROM TEMP.TEST5!
 
resultcount :               unknown
 
Enter command:
FETCH!
 
Column1  | ColumnMemo
---------+---------------------------------------------------
abc      | das ist der lob das ist der lob das ist der lob da
def      | das ist der loooooong lob of 10200 bytes das ist d
 
resultcount :                     2
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
FILE SHUTDWNK!
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT !
 
Enter command:
DROP USER KERN !
 
Enter command:
COMMIT WORK RELEASE !
 
Enter command:
FILE SHUTDOWN !
 
Enter command:
DBMCLI SUPERDBA,COLDUSER!
UTIL_CONNECT SUT,SUT!
OK
 
DB_OFFLINE!
OK
 
BYE!
 
Enter command:
VDNEXIT!
SESSION END
 
