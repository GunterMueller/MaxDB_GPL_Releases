file xinitdbk!
* Heft 1 1997 !
file connect ( kern test sqlmode oracle !
create table autoren (
aut_id number constraint autoren_pk primary key,
name   varchar(20))!
insert into autoren values (1, 'Bartels   ')!
insert into autoren values (2, 'Lenz      ')!
insert into autoren values (3, 'Unbescheid')!
insert into autoren values (4, 'Hermann   ')!
insert into autoren values (5, 'Stuerner  ')!
insert into autoren values (6, 'Wiesmeier ')!
create table buecher (
buch_id number constraint buecher_pk primary key,
titel   varchar(20))!
insert into buecher values (1, 'Oracle7    ')!
insert into buecher values (2, 'SQL*Net    ')!
insert into buecher values (3, 'Datenbanken')!
insert into buecher values (4, 'Objekte    ')!
create table autoren_referenz (
buch_id number constraint ref_buch_fk references buecher,
aut_id  number constraint ref_autor_fk references autoren,
lfd_nr  number,
constraint autoren_referenz_pk primary key (buch_id, aut_id, lfd_nr))!
insert into autoren_referenz values (1, 1, 1)!
insert into autoren_referenz values (2, 3, 2)!
insert into autoren_referenz values (4, 3, 1)!
insert into autoren_referenz values (3, 3, 3)!
insert into autoren_referenz values (3, 4, 2)!
insert into autoren_referenz values (3, 5, 1)!
insert into autoren_referenz values (2, 6, 1)!
commit work release !
file connect ( kern test !
select decode (anz_autoren, 1, aut1.name,
                            2, aut1.name || ', ' || aut2.name,
                               aut1.name || ' et al') name,
       titel
from (select buch_id, count(*) anz_autoren
        from autoren_referenz
       group by buch_id) cnttab,
      autoren_referenz ar,
      (select buch_id, name
         from autoren_referenz, autoren
        where autoren_referenz.aut_id = autoren.aut_id
          and lfd_nr = 1) aut1,
      (select buch_id, name
         from autoren_referenz, autoren
        where autoren_referenz.aut_id = autoren.aut_id
          and (buch_id, lfd_nr) = any (select buch_id, max(lfd_nr)
                                         from autoren_referenz
                                        group by buch_id)) aut2,
      buecher
where ar.buch_id = cnttab.buch_id
  and ar.buch_id = aut1.buch_id
  and ar.buch_id = aut2.buch_id
  and ar.buch_id = buecher.buch_id 
  and ar.lfd_nr  = 1 
order by ar.buch_id !
fetch!
* 1. Musterloesung !
select a.name, b.titel
  from buecher b,
       autoren a,
       autoren_referenz r
 where a.aut_id = r.aut_id
  and b.buch_id = r.buch_id
  and r.lfd_nr = 1
  and 1 = (select count (*)
             from autoren_referenz ri
            where b.buch_id = ri.buch_id)
union
select a1.name || ', ' || a2.name name, b.titel
  from buecher b,
       autoren a1,
       autoren a2,
       autoren_referenz r1,
       autoren_referenz r2
 where a1.aut_id = r1.aut_id
   and a2.aut_id = r2.aut_id
   and b.buch_id = r1.buch_id
   and b.buch_id = r2.buch_id
   and r1.lfd_nr = 1
   and r2.lfd_nr = 2
   and r1.buch_id in
          (select ri.buch_id
             from autoren_referenz ri
            group by ri.buch_id
            having count(*) = 2 )
union
select a.name || ' et. al.' name, b.titel
  from buecher b,
       autoren a,
       autoren_referenz r
 where a.aut_id = r.aut_id
   and b.buch_id = r.buch_id
   and r.lfd_nr = 1
   and exists (select * 
                 from autoren_referenz ri
                where b.buch_id = ri.buch_id
                  and ri.lfd_nr = 3)
order by 1 !
fetch into :a, :b !
* 2. Musterloesung !
select decode (aut_anz.anzahl,
               1, a1.name,
               2, a1.name || ', ' || a2.name,
               a1.name || ' et. al.') name,
       b.titel
  from buecher b,
       autoren a1,
       autoren a2,
       autoren_referenz r1,
       autoren_referenz r2,
       (select ri.buch_id, count(*) anzahl
          from autoren_referenz ri
         where ri.lfd_nr <= 3
         group by ri.buch_id) aut_anz
 where a1.aut_id      = r1.aut_id
   and a2.aut_id (+)  = r2.aut_id
   and b.buch_id      = r1.buch_id
   and b.buch_id      = r2.buch_id (+)
   and r1.lfd_nr      = 1
   and r2.lfd_nr (+)  = 2
   and r1.buch_id     = aut_anz.buch_id
order by 1 !
fetch into :a, :b !
drop table autoren !
drop table buecher !
drop table autoren_referenz !
commit release !
* Heft 2 1997 !
file connect ( kern test sqlmode oracle !
create table firmen (
f_id   number constraint firmen_pk primary key,
f_name varchar (20))!
insert into firmen values (1, 'Autohaus Meyer  ')!
insert into firmen values (8, 'Friseur Schulz  ')!
insert into firmen values (5, 'Klempner Schmidt')!
insert into firmen values (9, 'Werkstatt Grefe ')!
commit !
create table personen (
p_id    number constraint personen_pk primary key,
p_f_id  number constraint personen_firmen_fk references firmen,
p_name  varchar (20))!
insert into personen values (11, 5, 'Albrecht   ')!
insert into personen values (22, 5, 'Clausen    ')!
insert into personen values (55, 1, 'Fritz      ')!
insert into personen values ( 9, 5, 'Graber     ')!
insert into personen values (36, 9, 'Hansen     ')!
insert into personen values (44, 9, 'Herrmann   ')!
insert into personen values (77, 5, 'Jensen     ')!
insert into personen values ( 2, 5, 'Kunz       ')!
insert into personen values (56, 5, 'Linke      ')!
insert into personen values (23, 8, 'Linkwitz   ')!
insert into personen values (14, 1, 'Paulsen    ')!
insert into personen values (12, 5, 'Petersen   ')!
insert into personen values (25, 9, 'Rackwitz   ')!
insert into personen values ( 5, 1, 'Schweizer  ')!
insert into personen values (13, 5, 'Weidert    ')!
insert into personen values (33, 9, 'Zimmer     ')!
commit !
select f_name, p_name, x.nummer
  from firmen, personen,
       (select count(*) nummer, p1.p_id
          from personen p1, personen p2
         where p1.p_id  >= p2.p_id
           and p1.p_f_id = p2.p_f_id
         group by p1.p_id
       ) x
 where firmen.f_id = personen.p_f_id
   and x.p_id = personen.p_id
   and mod (x.nummer, 3) = 1 
order by 1,3 !
fetch into :a, :b, :c !
select f.f_name, p.p_name, count(*) nummer
  from firmen f,
       personen p,
       personen pz
 where f.f_id   = p.p_f_id
   and p.p_f_id = pz.p_f_id
   and p.p_id  >= pz.p_id
group by f.f_name, f.f_id, p.p_name, p.p_id
having mod(count(*), 3) = 1
order by f_name, nummer !
fetch into :a, :b, :c !
drop table firmen !
drop table personen !
commit work release !
* Heft 3 1997 !
file connect ( kern test sqlmode oracle !
create table auftragsposition (
auftragsnr  number (6) 
            constraint auftragsnr_check check (auftragsnr > 0),
position    number (3)
            constraint position_check check (position > 0),
unterpos    number (3)
            constraint unterpos_check check (unterpos > 0),
artikel     number (4) not null,
menge       number (6) not null,
constraint auftragsposition_pk
primary key (auftragsnr, position, unterpos)) !
insert into auftragsposition values (1,1,1,11,12)!
insert into auftragsposition values (2,2,1,42,11)!
insert into auftragsposition values (2,2,2,14,21)!
insert into auftragsposition values (1,1,2,22,32)!
insert into auftragsposition values (1,2,1,11,23)!
insert into auftragsposition values (2,1,1,23,22)!
insert into auftragsposition values (2,1,2,12,13)!
insert into auftragsposition values (3,1,1,21,22)!
insert into auftragsposition values (3,2,1,24,21)!
commit !
select * 
  from auftragsposition
 where (auftragsnr > 2)
       or
       (auftragsnr = 2 and position >= 2)
order by auftragsnr, position, unterpos !
fetch into :a, :b, :c, :d, :e !
select *
  from auftragsposition
 where auftragsnr * 10000000 + position * 1000 + unterpos >=
              2   * 10000000 +    2     * 1000 +    1
order by auftragsnr, position, unterpos !
fetch into :a, :b, :c, :d, :e !
select * 
  from auftragsposition
 where (auftragsnr > 2)
       or
       (auftragsnr = 2 and 
             (position > 2 or (position = 2 and unterpos >= 1))) 
order by auftragsnr, position, unterpos !
fetch into :a, :b, :c, :d, :e !
select * 
  from auftragsposition
 where auftragsnr = 2 and position = 2 and unterpos >= 1
       or
       auftragsnr = 2 and position > 2
       or
       auftragsnr > 2
order by auftragsnr, position, unterpos !
fetch into :a, :b, :c, :d, :e !
drop table auftragsposition !
commit work release !
* Heft 4 1997 !
file connect ( kern test sqlmode oracle !
create table ind (
index_name varchar (15) not null,
table_name varchar (15) not null,
column_name varchar (15) not null,
column_position number (2) not null
   constraint ind_pos_check
   check (column_position between 1 and 16),
constraint ind_pk primary key (index_name, column_name),
constraint ind_u1 unique (index_name, column_position)) !
insert into ind values ('IND1', 'TAB1', 'COL1', 1)!
insert into ind values ('IND3', 'TAB1', 'COL2', 2)!
insert into ind values ('IND1', 'TAB1', 'COL3', 2)!
insert into ind values ('IND2', 'TAB1', 'COL5', 1)!
insert into ind values ('IND2', 'TAB1', 'COL6', 2)!
insert into ind values ('IND4', 'TAB1', 'COL6', 2)!
insert into ind values ('IND3', 'TAB1', 'COL7', 1)!
insert into ind values ('IND4', 'TAB1', 'COL9', 1)!
create table ind_save (
index_name varchar (15) not null,
table_name varchar (15) not null,
column_name varchar (15) not null,
column_position number (2) not null
   constraint ind_save_pos_check
   check (column_position between 1 and 16),
constraint ind_save_pk primary key (index_name, column_name),
constraint ind_save_u1 unique (index_name, column_position)) !
insert into ind_save values ('IND1', 'TAB1', 'COL1', 1)!
insert into ind_save values ('IND3', 'TAB1', 'COL1', 3)!
insert into ind_save values ('IND3', 'TAB1', 'COL2', 2)!
insert into ind_save values ('IND1', 'TAB1', 'COL3', 2)!
insert into ind_save values ('IND2', 'TAB1', 'COL5', 1)!
insert into ind_save values ('IND4', 'TAB2', 'COL6', 2)!
insert into ind_save values ('IND3', 'TAB1', 'COL7', 1)!
insert into ind_save values ('IND4', 'TAB2', 'COL9', 1)!
(select 'ZUS.' "STATUS", 
        index_name "INDEX", 
        table_name "TABLE", 
        column_name "COLUMN", 
        column_position "POSITION"
   from ind
 minus
 select 'ZUS.', index_name, table_name, column_name, column_position
   from ind_save
) 
UNION ALL
(select 'FEHLT', index_name, table_name, column_name, column_position
   from ind_save
 minus
 select 'FEHLT', index_name, table_name, column_name, column_position
   from ind
) 
order by 1 desc, 2, 3, 4 !
fetch  into :a, :b, :c, :d, :e !
select 'ZUS.' "STATUS", 
       i.index_name "INDEX", 
       i.table_name "TABLE", 
       i.column_name "COLUMN", 
       i.column_position "POSITION"
  from ind i
 where not exists
          (select * 
             from ind_save isv
            where isv.index_name = i.index_name
              and isv.table_name = i.table_name
              and isv.column_name = i.column_name)
UNION ALL
select 'FEHLT.' "STATUS", 
       isv.index_name "INDEX", 
       isv.table_name "TABLE", 
       isv.column_name "COLUMN", 
       isv.column_position "POSITION"
  from ind_save isv
 where not exists
          (select * 
             from ind i
            where isv.index_name = i.index_name
              and isv.table_name = i.table_name
              and isv.column_name = i.column_name)
order by 1 desc, 2, 3, 4 !
fetch  into :a, :b, :c, :d, :e !
select 'ZUS.' "STATUS", 
       i.index_name "INDEX", 
       i.table_name "TABLE", 
       i.column_name "COLUMN", 
       i.column_position "POSITION"
  from ind i
 where (index_name, table_name, column_name) not in
        (select index_name, table_name, column_name
           from ind_save)
union all
select 'FEHLT.' "STATUS", 
       isv.index_name "INDEX", 
       isv.table_name "TABLE", 
       isv.column_name "COLUMN", 
       isv.column_position "POSITION"
  from ind_save isv
 where (index_name, table_name, column_name) not in
        (select index_name, table_name, column_name
           from ind)
order by 1 desc, 2, 3, 4 !
fetch  into :a, :b, :c, :d, :e !
drop table ind !
drop table ind_save !
commit release !
* Heft 5 1997 !
file connect ( kern test sqlmode oracle !
create table mitarbeiter (
m_id   number constraint ma_pk primary key,
name   varchar (10) not null)!
insert into mitarbeiter values (2, 'Fitz')!
insert into mitarbeiter values (3, 'Lenz')!
insert into mitarbeiter values (1, 'Ofer')!
commit work !
create table kenntnisse (
m_id           number constraint k_ma_fk references mitarbeiter,
bezeichnung    varchar (10),
constraint k_pk primary key (m_id, bezeichnung)) !
insert into kenntnisse values (1, '4GL       ')!
insert into kenntnisse values (3, 'C         ')!
insert into kenntnisse values (3, 'C++       ')!
insert into kenntnisse values (2, 'CICS      ')!
insert into kenntnisse values (2, 'COBOL     ')!
insert into kenntnisse values (3, 'DB-LIB    ')!
insert into kenntnisse values (2, 'DB2 DBA   ')!
insert into kenntnisse values (2, 'JCL       ')!
insert into kenntnisse values (1, 'ORACLE DBA')!
insert into kenntnisse values (3, 'SQL       ')!
insert into kenntnisse values (1, 'SQL*NET   ')!
insert into kenntnisse values (3, 'SYBASE DBA')!
commit work !
create table offene_positionen (
pos_id       number,
bezeichnung  varchar (10),
constraint op_pk primary key (pos_id))!
insert into offene_positionen values (1, 'Entwickler')!
insert into offene_positionen values (2, 'WEB Spezi ')!
insert into offene_positionen values (3, 'Entwickler')!
insert into offene_positionen values (4, 'Entwickler')!
commit !
create table notwendige_kenntnisse (
pos_id        number,
bezeichnung   varchar (10),
constraint nk_pk primary key (pos_id, bezeichnung),
constraint nk_op_fk foreign key (pos_id) references offene_positionen)!
insert into notwendige_kenntnisse values (1, '4GL       ')!
insert into notwendige_kenntnisse values (2, 'C++       ')!
insert into notwendige_kenntnisse values (3, 'CICS      ')!
insert into notwendige_kenntnisse values (3, 'COBOL     ')!
insert into notwendige_kenntnisse values (2, 'DB2 DBA   ')!
insert into notwendige_kenntnisse values (2, 'JAVA      ')!
insert into notwendige_kenntnisse values (1, 'ORACLE DBA')!
insert into notwendige_kenntnisse values (2, 'SQL       ')!
insert into notwendige_kenntnisse values (4, 'ORACLE DBA')!
insert into notwendige_kenntnisse values (4, 'COBOL     ')!
insert into notwendige_kenntnisse values (4, 'SQL       ')!
commit work !
select op.pos_id, op.bezeichnung
  from offene_positionen op, notwendige_kenntnisse not_k
 where op.pos_id = not_k.pos_id
group by op.pos_id, op.bezeichnung
having count(*) > all (select count(k.bezeichnung)
                         from kenntnisse k, notwendige_kenntnisse nk
                        where k.bezeichnung = nk.bezeichnung
                          and nk.pos_id = op.pos_id
                        group by k.m_id)!
fetch into :a, :b !
select *
  from offene_positionen op
 where not exists
       (select *
          from mitarbeiter ma
         where not exists
               (select *
                  from notwendige_kenntnisse nk
                 where nk.pos_id = op.pos_id
                   and not exists
                       (select *
                          from kenntnisse k
                         where k.bezeichnung = nk.bezeichnung
                           and k.m_id = ma.m_id
                       )
               )
       )!
fetch into :a, :b !
select *
  from offene_positionen op
 where not exists
       (select *
          from mitarbeiter m
         where not exists
               (select nk.bezeichnung
                  from notwendige_kenntnisse nk
                 where nk.pos_id = op.pos_id
                minus
                select k.bezeichnung
                  from kenntnisse k
                 where k.m_id = m.m_id
               )
       )!
fetch into :a, :b!
select pos_id, bezeichnung
  from offene_positionen o
 where not exists
       (select k.m_id, count(nk.bezeichnung)
          from notwendige_kenntnisse nk,
               kenntnisse k
         where nk.bezeichnung = k.bezeichnung
           and nk.pos_id = o.pos_id
          group by nk.pos_id, k.m_id
          having count (nk.bezeichnung) = 
                              (select count (nk2.bezeichnung)
                                 from notwendige_kenntnisse nk2
                                where nk.pos_id = nk2.pos_id
                              )
       ) !
fetch into :a, :b !
drop table mitarbeiter !
drop table kenntnisse !
drop table offene_positionen !
drop table notwendige_kenntnisse !
commit work release !
* Heft 6 1997 !
file connect ( kern test sqlmode oracle !
create table auftrag (
auf_id  integer constraint auftrag_pk primary key,
kd_name varchar (10) not null)!
insert into auftrag values (1, 'Parthier')!
insert into auftrag values (2, 'Jansen')!
insert into auftrag values (3, 'Hagner')!
create table position (
auf_id       integer constraint pos_auf_fk references auftrag,
position     integer,
menge        integer not null,
bezeichnung  varchar(10) not null,
constraint position_pk primary key (auf_id, position))!
insert into position values (1,1,5,'Blech')!
insert into position values (1,2,3,'Stuetze')!
insert into position values (1,3,2,'Halter')!
insert into position values (2,1,1,'Gehaeuse')!
insert into position values (2,2,4,'Lager')!
insert into position values (2,3,5,'Korpus')!
insert into position values (3,1,3,'Blech')!
insert into position values (3,2,1,'Lager')!
create table maschine (
m_id        integer constraint maschine_pk primary key,
bezeichnung varchar (10) not null,
dm_stunde   decimal (8,2) not null)!
insert into maschine values (1, 'M1', 998.98)!
insert into maschine values (2, 'M2', 899.98)!
insert into maschine values (3, 'M3', 699.98)!
create table werkzeug (
w_id        integer constraint werkzeug_pk primary key,
bezeichnung varchar (10) not null,
dm_stunde   decimal (8,2) not null)!
insert into werkzeug values (1, 'Bohrer  ', 20.22)!
insert into werkzeug values (2, 'Saege   ', 30.33)!
insert into werkzeug values (3, 'Fraese  ', 40.44)!
insert into werkzeug values (4, 'Schleifer',50.55)!
insert into werkzeug values (5, 'Dreher  ', 60.66)!
create table maschine_werkzeug (
m_id        integer constraint masch_wk_masch_fk references maschine,
w_id        integer constraint masch_wk_wk_fk references werkzeug,
max_mass    decimal (8,2) not null,
constraint maschine_werkzeug_pk primary key (m_id, w_id))!
insert into maschine_werkzeug values (1,1,20.5)!
insert into maschine_werkzeug values (1,2,30.5)!
insert into maschine_werkzeug values (1,3,40.5)!
insert into maschine_werkzeug values (1,4,10.5)!
insert into maschine_werkzeug values (1,5,20.5)!
insert into maschine_werkzeug values (2,1,30.5)!
insert into maschine_werkzeug values (2,2,20.5)!
insert into maschine_werkzeug values (2,3,20.5)!
insert into maschine_werkzeug values (2,4,22.5)!
insert into maschine_werkzeug values (2,5,20.5)!
insert into maschine_werkzeug values (3,1,20.5)!
insert into maschine_werkzeug values (3,3,20.5)!
insert into maschine_werkzeug values (3,5,20.5)!
create table bearbeitung (
auf_id     integer,
position   integer,
schritt    integer,
w_id       integer not null constraint bearb_wk_fk references werkzeug,
mass       decimal (8,2) not null,
dauer      decimal (4,2) not null,
constraint bearbeitung_pk primary key (auf_id, position, schritt),
constraint bearb_pos_fk foreign key (auf_id, position) 
                       references position)!
insert into bearbeitung values (1,1,1,1,20.2,0.3)!
insert into bearbeitung values (1,1,2,3,20.2,0.1)!
insert into bearbeitung values (1,2,1,5,20.3,0.4)!
insert into bearbeitung values (1,2,2,3,20.1,0.3)!
insert into bearbeitung values (1,3,1,1,20.2,0.5)!
insert into bearbeitung values (1,3,2,5,20.1,0.6)!
insert into bearbeitung values (2,1,1,1,20.2,0.3)!
insert into bearbeitung values (2,1,2,3,20.2,0.1)!
insert into bearbeitung values (2,2,1,5,20.3,0.4)!
insert into bearbeitung values (2,2,2,3,40.1,0.7)!
insert into bearbeitung values (2,3,1,1,20.2,0.5)!
insert into bearbeitung values (2,3,2,5,20.1,0.6)!
insert into bearbeitung values (3,1,1,1,20.2,0.3)!
insert into bearbeitung values (3,1,2,3,20.2,0.1)!
insert into bearbeitung values (3,2,1,4,20.3,0.4)!
insert into bearbeitung values (3,2,2,3,40.1,0.7)!
commit work release!
file connect ( kern test !
select a.auf_id, m.m_id, m.bezeichnung, 
 fixed (sum(p.menge*b.dauer*(m.dm_stunde+w.dm_stunde)),10,3)
from  auftrag a,
      position p,
      bearbeitung b,
      werkzeug w,
      maschine_werkzeug m_w,
      maschine m
where a.auf_id = p.auf_id
  and p.auf_id = b.auf_id
  and p.position = b.position
  and b.w_id = w.w_id
  and w.w_id = m_w.w_id
  and b.mass <= m_w.max_mass
  and m_w.m_id = m.m_id
group by a.auf_id, m.m_id, m.bezeichnung
having (count(*) , a.auf_id) = 
     any ( select count(*), auf_id from bearbeitung group by auf_id)!
fetch into :a, :b, :c, :d !
* PTS 1000960 !
SELECT B.AUF_ID, M.M_ID, M.BEZEICHNUNG "Maschine",
       FIXED(SUM(P.MENGE*B.DAUER*(M.DM_STUNDE+W.DM_STUNDE)),7,2) "Preis"
FROM BEARBEITUNG B, WERKZEUG W, MASCHINE M, MASCHINE_WERKZEUG MW,
     POSITION P
WHERE
    B.W_ID = W.W_ID AND
    MW.W_ID = W.W_ID AND
    MW.M_ID = M.M_ID AND
    B.MASS <= MW.MAX_MASS AND
    P.AUF_ID = B.AUF_ID AND
    P.POSITION = B.POSITION
GROUP BY B.AUF_ID, M.M_ID, M.BEZEICHNUNG
HAVING COUNT(B.SCHRITT) = (
  SELECT COUNT(B1.SCHRITT)
  FROM BEARBEITUNG B1
  WHERE B1.AUF_ID = B.AUF_ID
)
ORDER BY B.AUF_ID, M.M_ID!
fetch into :a, :b, :c, :d !
drop table auftrag !
drop table position !
drop table bearbeitung !
drop table werkzeug !
drop table maschine_werkzeug !
drop table maschine!
commit work release !
* Heft 7 1997 !
file connect ( kern test sqlmode oracle !
create table mitarbeiter (
m_id   number constraint ma_pk primary key,
name   varchar (10) not null)!
insert into mitarbeiter values (2, 'Fitz')!
insert into mitarbeiter values (3, 'Lenz')!
insert into mitarbeiter values (1, 'Ofer')!
commit work !
create table kenntnisse (
k_id           number constraint k_pk primary key,
bezeichnung    varchar (10))!
insert into kenntnisse values (1, '4GL       ')!
insert into kenntnisse values (2, 'C         ')!
insert into kenntnisse values (3, 'C++       ')!
insert into kenntnisse values (4, 'CICS      ')!
insert into kenntnisse values (5, 'COBOL     ')!
insert into kenntnisse values (6, 'DB-LIB    ')!
insert into kenntnisse values (7, 'DB2 DBA   ')!
insert into kenntnisse values (8, 'JAVA      ')!
insert into kenntnisse values (9, 'JCL       ')!
insert into kenntnisse values (10, 'ORACLE DBA')!
insert into kenntnisse values (11, 'SQL       ')!
insert into kenntnisse values (12, 'SQL*NET   ')!
insert into kenntnisse values (13, 'SYBASE DBA')!
commit work !
create table vorhandene_kenntnisse (
m_id         number constraint vk_m_fk references mitarbeiter,
k_id         number constraint vk_k_fk references kenntnisse,
constraint nk_pk primary key (m_id, k_id)) !
insert into vorhandene_kenntnisse values (1, 1)!
insert into vorhandene_kenntnisse values (3, 2)!
insert into vorhandene_kenntnisse values (3, 3)!
insert into vorhandene_kenntnisse values (2, 4)!
insert into vorhandene_kenntnisse values (2, 5)!
insert into vorhandene_kenntnisse values (3, 6)!
insert into vorhandene_kenntnisse values (2, 7)!
insert into vorhandene_kenntnisse values (2, 9)!
insert into vorhandene_kenntnisse values (1,10)!
insert into vorhandene_kenntnisse values (3,11)!
insert into vorhandene_kenntnisse values (1,12)!
insert into vorhandene_kenntnisse values (3,13)!
commit work !
create table offene_positionen (
pos_id       number,
bezeichnung  varchar (10),
constraint op_pk primary key (pos_id))!
insert into offene_positionen values (1, 'Entwickler')!
insert into offene_positionen values (2, 'WEB Spezi ')!
insert into offene_positionen values (3, 'Entwickler')!
insert into offene_positionen values (4, 'Entwickler')!
commit !
create table notwendige_kenntnisse (
pos_id        number constraint nk_op_fk references offene_positionen,
k_id          number constraint nk_k__fk references kenntnisse,
constraint nk_pk primary key (pos_id, k_id))!
insert into notwendige_kenntnisse values (1, 1)!
insert into notwendige_kenntnisse values (2, 3)!
insert into notwendige_kenntnisse values (3, 4)!
insert into notwendige_kenntnisse values (3, 5)!
insert into notwendige_kenntnisse values (4, 5)!
insert into notwendige_kenntnisse values (2, 7)!
insert into notwendige_kenntnisse values (2, 8)!
insert into notwendige_kenntnisse values (1,10)!
insert into notwendige_kenntnisse values (4,10)!
insert into notwendige_kenntnisse values (2,11)!
insert into notwendige_kenntnisse values (4,11)!
commit work !
select op.pos_id, op.bezeichnung, name
  from offene_positionen op, 
       mitarbeiter m, 
       vorhandene_kenntnisse vk,
       notwendige_kenntnisse nk
 where op.pos_id = nk.pos_id
   and nk.k_id   = vk.k_id
   and m.m_id    = vk.m_id 
group by op.pos_id, op.bezeichnung, name
having count(*) >= all ( select count(*)
                  from vorhandene_kenntnisse vk,
                       notwendige_kenntnisse nk
                 where nk.pos_id  = op.pos_id
                   and nk.k_id   = vk.k_id
                group by vk.m_id 
                  ) !
fetch into :a, :b, :c !
select op.pos_id, op.bezeichnung, name
  from offene_positionen op, 
       mitarbeiter m, 
       vorhandene_kenntnisse vk,
       notwendige_kenntnisse nk
 where op.pos_id = nk.pos_id
   and nk.k_id   = vk.k_id
   and m.m_id    = vk.m_id 
group by op.pos_id, op.bezeichnung, name
having not exists (select vk1.m_id
                  from vorhandene_kenntnisse vk1,
                       notwendige_kenntnisse nk1
                 where nk1.pos_id = op.pos_id
                   and nk1.k_id   = vk1.k_id
                group by vk1.m_id 
				having count (vk1.k_id) > count (vk.k_id)
                  ) !
pars_execute!
fetch into :a, :b, :c !
drop table mitarbeiter !
drop table kenntnisse !
drop table vorhandene_kenntnisse !
drop table offene_positionen !
drop table notwendige_kenntnisse !
commit work release !
* Heft 8 1997 !
* stand mir leider nicht zur Verfügung !
* Heft 9 1997 !
file connect ( kern test !
create table kfz (
kennzeichen   varchar (20) primary key,
avg_verbrauch decimal)!
insert into kfz values ('HH-XY 1224', 10)!
insert into kfz values ('M-OC 5447', 12)!
insert into kfz values ('XQ-BZ 9090', 11)!
insert into kfz values ('QU-AA 0815', 13)!
create table tanken (
kennzeichen varchar (20) constraint t_k_fk references kfz,
dat         date not null,
km          integer constraint t_km_check check (km > 0),
menge       decimal not null constraint t_m_check check (menge > 0),
primary key (kennzeichen, km))!
commit release !
file connect ( kern test !
set format eur !
insert into tanken values ('HH-XY 1224', '10.03.1997', 13100, 40)!
insert into tanken values ('HH-XY 1224', '11.04.1997', 13800, 40)!
insert into tanken values ('XQ-BZ 9090', '13.03.1997', 46720, 55)!
insert into tanken values ('XQ-BZ 9090', '17.03.1997', 47320, 65)!
insert into tanken values ('M-OC 5447' , '20.02.1997', 12345, 55)!
insert into tanken values ('HH-XY 1224', '20.03.1997', 13420, 40)!
insert into tanken values ('M-OC 5447' , '20.04.1997', 13870, 62)!
insert into tanken values ('HH-XY 1224', '22.02.1997', 12345, 55)!
insert into tanken values ('QU-AA 0815', '22.02.1997', 44556, 50)!
insert into tanken values ('XQ-BZ 9090', '22.02.1997', 45678, 70)!
insert into tanken values ('M-OC 5447' , '22.02.1997',128451, 62)!
insert into tanken values ('M-OC 5447' , '22.04.1997', 14350, 58)!
insert into tanken values ('QU-AA 0815', '22.04.1997', 45500, 60)!
insert into tanken values ('QU-AA 0815', '23.04.1997', 46000, 65)!
insert into tanken values ('QU-AA 0815', '24.02.1997',  5000, 65)!
insert into tanken values ('HH-XY 1224', '25.02.1997', 12750, 40)!
insert into tanken values ('XQ-BZ 9090', '25.02.1997', 45865, 60)!
insert into tanken values ('QU-AA 0815', '27.03.1997', 45400, 50)!
insert into tanken values ('QU-AA 0815', '27.04.1997', 46400, 60)!
insert into tanken values ('XQ-BZ 9090', '28.02.1997', 46223, 50)!
insert into tanken values ('M-OC 5447' , '30.03.1997', 13320, 63)!
set format internal!
alter table tanken add datum timestamp!
update tanken set datum = timestamp (dat, time)!
commit release !
file connect ( kern test !
* PTS 1000966 !
* Versuch, sich an die Lösung des Problems heranzurobben,
* von Till Luhmann !
select k.kennzeichen, k.avg_verbrauch,  
t2.dat as Letzt_Datum, t1.dat as Akt_Datum, 
datediff(t1.dat, t2.dat) as Tage,
t2.km as Letzt_km, t1.km as Akt_km
from kfz k, tanken t1, tanken t2
where 
(t1.kennzeichen = k.kennzeichen) and
(t2.kennzeichen = k.kennzeichen) and
(t2.dat < t1.dat) and
(t2.dat = (select max(dat) from tanken 
 except (select max(dat) from tanken)))!
fetch !
commit release !
file connect ( kern test sqlmode oracle !
select k.kennzeichen, k.avg_verbrauch avg,
       t.datum datum_von, tb.datum datum_bis,
	   t.datum - tb.datum tage,
	   tb.km km_von, t.km km_bis,
	   t.km - tb.km distanz, t.menge,
	   round (t.menge / (t.km - tb.km) * 100, 2) verbrauch,
       round ((t.menge / (t.km - tb.km) * 100 - k.avg_verbrauch )
	   / k.avg_verbrauch * 100, 2) "%Abw."
from kfz k, tanken t, 
       (select min (tank1.datum - tank2.datum) min_tage,
	   tank2.kennzeichen, tank2.datum, tank2.km
	   from tanken tank1, tanken tank2
	   where tank1.kennzeichen = tank2.kennzeichen
	     and tank1.datum > tank2.datum
		 group by tank2.kennzeichen, tank2.datum, tank2.km) tb
where k.kennzeichen = t.kennzeichen
and	  k.kennzeichen = tb.kennzeichen
and   t.datum > tb.datum
and   t.datum - tb.datum = tb.min_tage
and   abs(round((t.menge / (t.km - tb.km) * 100 
       / k.avg_verbrauch - 1) * 100, 2)) > 50 !
fetch into :a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k !
drop table tanken !
drop table kfz !
commit work release !
* Heft 10 1997 !
file connect ( kern test sqlmode oracle !
create table artikel (
art_nr      integer constraint artikel_pk primary key,
bezeichnung varchar (20) not null)!
insert into artikel values (1, 'Apfelsaft')!
insert into artikel values (2, 'Orangensaft')!
commit work !
create table flaschen (
fl_nr        integer constraint flaschen_pk primary key,
bezeichnung  varchar (20) not null,
inhalt       decimal (5,2) not null
             constraint inhalt_check check (inhalt > 0))!
insert into flaschen values (1, 'Pfandflasche', 1.0)!
insert into flaschen values (2, 'Fläschchen'  , 0.2)!
insert into flaschen values (3, 'Halber'      , 0.5)!
commit work !
create table kunden (
kn_nr integer constraint kunden_pk primary key,
name  varchar (20) not null)!
insert into kunden values (1, 'Durstig')!
insert into kunden values (2, 'Saufaus')!
commit work !
create table bestellung (
bestell_nr   integer constraint bestellung_pk primary key,
kd_nr        integer 
              constraint best_kd_fk references kunden not null,
liefer_datum date not null)!
insert into bestellung values (1, 1, '01-JAN-97')!
insert into bestellung values (2, 1, '01-MAY-97')!
insert into bestellung values (3, 1, '11-DEC-97')!
insert into bestellung values (4, 2, '22-JUN-97')!
insert into bestellung values (5, 2, '21-AUG-97')!
insert into bestellung values (6, 1, '20-DEC-97')!
insert into bestellung values (7, 2, '24-DEC-97')!
commit work !
create table bestell_pos (
bestell_nr integer,
pos        integer,
art_nr     integer not null constraint bp_art_fk references artikel,
fl_nr      integer not null constraint bp_fla_fk references flaschen,
menge      integer not null constraint menge_check check (menge > 0),
constraint bestell_pos_pk primary key (bestell_nr, pos),
constraint bes_pos_u1 unique (bestell_nr, art_nr, fl_nr))!
insert into bestell_pos values (1,1,1,1, 100)!
insert into bestell_pos values (1,2,2,3,  20)!
insert into bestell_pos values (1,3,1,2, 200)!
insert into bestell_pos values (2,1,2,2, 200)!
insert into bestell_pos values (2,2,1,3,  15)!
insert into bestell_pos values (2,3,2,1,  22)!
insert into bestell_pos values (3,1,1,1,  11)!
insert into bestell_pos values (3,2,2,1,  33)!
insert into bestell_pos values (3,3,1,2,  44)!
insert into bestell_pos values (3,4,1,3,  25)!
insert into bestell_pos values (3,5,2,2,  37)!
insert into bestell_pos values (3,6,2,3, 234)!
insert into bestell_pos values (4,1,1,1,1111)!
insert into bestell_pos values (4,2,2,2, 222)!
insert into bestell_pos values (5,1,1,3, 234)!
insert into bestell_pos values (6,1,2,3,1000)!
insert into bestell_pos values (6,2,2,2, 100)!
insert into bestell_pos values (7,1,1,1, 300)!
insert into bestell_pos values (7,2,1,2, 300)!
insert into bestell_pos values (7,3,1,3, 200)!
commit work !
create table produktion (
art_nr      integer,
prod_datum  date,
menge       decimal (10,2) not null 
             constraint prod_menge_check check (menge > 0),
constraint produktion_pk primary key (art_nr, prod_datum))!
insert into produktion values (1,'01-OCT-97',1000)!
insert into produktion values (2,'01-OCT-97', 677)!
commit work !
select bp.art_nr, bp.fl_nr,
       to_char(round(sum (bp.menge * f.inhalt) /
             sum.summe * 100, 2), '99.99') prozent,
       to_char(round(sum (bp.menge * f.inhalt) /
             sum.summe * p.menge), '9999') menge,
       to_char(round(sum (bp.menge * f.inhalt) /
             sum.summe * p.menge / f.inhalt), '9999') flaschen             
  from bestell_pos bp,
       flaschen f,
       produktion p,
       (select bp.art_nr,
               sum (bp.menge * f.inhalt) summe
          from bestell_pos bp, flaschen f
         where bp.fl_nr = f.fl_nr
         group by bp.art_nr)                      sum
 where bp.art_nr = sum.art_nr
   and bp.fl_nr  = f.fl_nr
   and bp.art_nr = p.art_nr
   and p.prod_datum = '01-OCT-97'
 group by bp.art_nr, bp.fl_nr, sum.summe,
               f.inhalt, p.menge !
fetch into :a, :b, :c, :d, :e !
drop table artikel !
drop table flaschen !
drop table kunden !
drop table bestellung !
drop table bestell_pos !
drop table produktion !
commit work release !
* Heft 11 1997 !
file connect ( kern test sqlmode oracle !
create table messungen (
messung integer constraint messung_pk primary key,
wert    decimal (4,1) not null)!
insert into messungen values ( 4, 11.3)!
insert into messungen values ( 6, 11.7)!
insert into messungen values ( 2, 12.2)!
insert into messungen values ( 9, 12.8)!
insert into messungen values (11, 12.9)!
insert into messungen values (13, 13.3)!
insert into messungen values ( 5, 13.4)!
insert into messungen values (18, 13.4)!
insert into messungen values ( 8, 13.9)!
insert into messungen values (15, 13.9)!
insert into messungen values (20, 13.9)!
insert into messungen values (17, 14.0)!
insert into messungen values (10, 14.3)!
insert into messungen values (22, 14.5)!
insert into messungen values (25, 15.0)!
commit release !
file connect ( kern test !
select m1.messung, m1.wert, fixed(round (avg(m2.wert),2),4,2), 
       fixed(round((avg(m2.wert) - m1.wert) * 100 / avg(m2.wert), 2),4,2)
from 
           (select rowno nr1, messung, wert
              from messungen
			  group by messung, wert) m1,
           (select rowno nr2, messung, wert
              from messungen
			  group by messung, wert) m2
where m2.nr2 between m1.nr1-3 and m1.nr1+3 
group by m1.messung, m1.wert
having abs(round((avg(m2.wert) - m1.wert) * 100 / avg(m2.wert), 2)) > 5!
fetch into :a, :b, :c, :d !
* Lösung 1 !
select m1.messung, m1.wert,
       fixed(round(avg (m2.wert), 2),4,2) avgr,
       fixed(round((avg(m2.wert) - m1.wert) / 
                    avg (m2.wert) * 100, 2),4,2) abw
  from messungen m1, messungen m2
 where m1.messung <= m2.messung
   and 4 >= (select count (*)
               from messungen mi
              where mi.messung between m1.messung and m2.messung
            )
    or 
       m1.messung >= m2.messung
   and 4 >= (select count (*)
               from messungen mi
              where mi.messung between m2.messung and m1.messung
            )
 group by m1.messung, m1.wert
having round ((avg(m2.wert) - m1.wert) /
               avg(m2.wert) * 100, 2)
       not between -5 and 5 !
fetch into :a, :b, :c, :d !
*Lösung 2 geht nicht, da ACCESS Spezialität !
select c.messung1 as messung,
       round(c.wert1,1) as wert,
       fixed(round(avg(c.wert2),2),4,2) as avgr,
       fixed(round(100-(c.wert1*100 / avg(c.wert2)),2),4,2) as abw
  from (select b.messung as messung1, b.wert as wert1,
               a.messung as messung2, a.wert as wert2
          from messungen a, messungen b
         where a.messung = b.messung
        union
        select b.messung as messung1, b.wert as wert1,
               a.messung as messung2, a.wert as wert2
          from messungen a, messungen b
         where a.messung = 
               (select min(messung) 
                  from messungen
                 where messung > b.messung)
        union          
        select b.messung as messung1, b.wert as wert1,
               a.messung as messung2, a.wert as wert2
          from messungen a, messungen b
         where a.messung = 
               (select min(messung) 
                  from messungen
                 where messung > 
                       (select min(messung) 
                          from messungen
                         where messung > b.messung))
        union          
        select b.messung as messung1, b.wert as wert1,
               a.messung as messung2, a.wert as wert2
          from messungen a, messungen b
         where a.messung = 
               (select min(messung) 
                  from messungen
                 where messung > 
                       (select min(messung) 
                          from messungen
                         where messung > 
                               (select min(messung) 
                                  from messungen
                                 where messung > b.messung)))
        union
        select b.messung as messung1, b.wert as wert1,
               a.messung as messung2, a.wert as wert2
          from messungen a, messungen b
         where a.messung = 
               (select max(messung) 
                  from messungen
                 where messung < b.messung)
        union          
        select b.messung as messung1, b.wert as wert1,
               a.messung as messung2, a.wert as wert2
          from messungen a, messungen b
         where a.messung = 
               (select max(messung) 
                  from messungen
                 where messung < 
                       (select max(messung) 
                          from messungen
                         where messung < b.messung))
        union          
        select b.messung as messung1, b.wert as wert1,
               a.messung as messung2, a.wert as wert2
          from messungen a, messungen b
         where a.messung = 
               (select max(messung) 
                  from messungen
                 where messung < 
                       (select max(messung) 
                          from messungen
                         where messung < 
                               (select max(messung) 
                                  from messungen
                                 where messung < b.messung)))
         ) c
group by messung1,wert1
having abs(100-(c.wert1*100/avg(c.wert2))) > 5!
fetch into :a, :b, :c, :d !
drop table messungen !
commit release !
* Heft 12 1997 !
file connect ( kern test !
create table personen (
p_id integer primary key,
name char (10) not null)!
insert into personen values (1, 'Golf')!
insert into personen values (2, 'John')!
insert into personen values (3, 'Peter')!
commit !
create table accounting (
login_id integer primary key,
p_id     integer not null references personen,
login    timestamp not null,
logout   timestamp not null,
constraint date_check check (login < logout))!
insert into accounting values 
 ( 1,1,'19971210100000000000','19971210120000000000')!
insert into accounting values 
 ( 2,1,'19971210110000000000','19971210140000000000')!
insert into accounting values 
 ( 3,1,'19971210150000000000','19971210190000000000')!
insert into accounting values
 ( 4,1,'19971210150000000000','19971210160000000000')!
insert into accounting values
 ( 5,1,'19971210170000000000','19971210180000000000')!
insert into accounting values
 ( 6,2,'19971210090000000000','19971210130000000000')!
insert into accounting values
 ( 7,2,'19971210150000000000','19971210160000000000')!
insert into accounting values
 ( 8,2,'19971210150000000000','19971210160000000000')!
insert into accounting values
 ( 9,3,'19971210100000000000','19971210140000000000')!
insert into accounting values
 (10,3,'19971210130000000000','19971210150000000000')!
insert into accounting values
 (11,3,'19971210130000000000','19971210150000000000')!
insert into accounting values
 (12,3,'19971210150000000000','19971210170000000000')!
commit work !
create table preise (
anzahl integer primary key,
betrag decimal (10,2) not null)!
insert into preise values (1, 1.00)!
insert into preise values (2, 0.70)!
insert into preise values (3, 0.55)!
insert into preise values (4, 0.45)!
insert into preise values (5, 0.40)!
commit work !
select p.name, a.login_id, max(pr.betrag)
  from personen p,
       accounting a,
       preise pr
 where p.p_id = a.p_id 
   and pr.anzahl >= ALL 
                (select count (*)
                   from accounting a1,
                        accounting a2
                  where a1.login >= a.login
                    and a1.login <  a.logout
                    and a1.login >= a2.login
                    and a1.login <  a2.logout
                    and a1.p_id  =  p.p_id
                    and a1.p_id  =  a2.p_id
                 group by a1.login_id) 
group by p.name, a.login_id !
fetch into :a, :b, :c !
drop table personen !
drop table accounting !
drop table preise !
commit work release !
file shutdwnk!
vdnexit!
