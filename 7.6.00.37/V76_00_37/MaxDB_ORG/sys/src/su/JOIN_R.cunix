JOIN_R.vdnts
 
Enter command:
FILE XRESTORE !
 
Enter command:
DBMCLI SUPERDBA,COLDUSER!
UTIL_CONNECT SUPERDBA,COLDUSER!
OK
 
BACKUP_RESTORE XINITDB DATA!
OK
Returncode           0
Date                 DATEXXXX
Time                 TIMEYYYY
Server               <servernode>
Database             <serverdb>
Kernel Version       KERNEL    vv.vv.vv Build bbb-bbb-bbb-bbb
Pages Transferred    000
Pages Left           0
Volumes              1
Medianame            xinitdb
Location             xinitdb.sav
Errortext
Label                <label>
Is Consistent        true
First LOG Page       000
Last LOG Page
DB Stamp 1 Date      DATEXXXX
DB Stamp 1 Time      TIMEYYYY
DB Stamp 2 Date
DB Stamp 2 Time
Page Count           000
Devices Used         1
Database ID          <servernode>:<serverdb>_DATEXXXX_<timestamp>
Max Used Data Page  000
Converter Page Count 8
 
UTIL_EXECUTE CLEAR LOG!
OK
 
DB_ONLINE!
OK
 
UTIL_RELEASE!
OK
 
UTIL_CONNECT SUT,SUT!
OK
 
UTIL_RELEASE!
OK
 
BYE!
 
Enter command:
 
FILE JOIN_R ( 'NO' !
 
Enter command:
SENDERID DBM !
FILE CONNECT ( SUT SUT !
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT   ISOLATION LEVEL 1 !
 
Enter command:
SET PARAMETER OPTIMIZE_OPERATOR_JOIN = 'NO' !
 
Enter command:
COMMIT RELEASE !
 
Enter command:
SENDERID XCI !
 
FILE CONNECT ( SUT SUT !
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT   ISOLATION LEVEL 1 !
 
Enter command:
CREATE USER KERN PASSWORD TEST DBA NOT EXCLUSIVE !
 
Enter command:
COMMIT WORK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( W CHAR (3),
X CHAR (8) ,
Y FIXED (12))!
 
Enter command:
INSERT T VALUES ('aaa', 'bbb', 12)!
 
Enter command:
INSERT T VALUES ('aaa', 'ccc', 13)!
 
Enter command:
INSERT T VALUES ('b  ', 'ccc', 83)!
 
Enter command:
INSERT T VALUES ('bbb', 'ddd', 124)!
 
Enter command:
INSERT T VALUES ('bbb', 'eee', 125)!
 
Enter command:
INSERT T VALUES ('ccc', 'eee', 135)!
 
Enter command:
INSERT T VALUES ('eee', 'fff', 12561356)!
 
Enter command:
CREATE TABLE TT ( A CHAR (1))!
 
Enter command:
INSERT TT SET A = 'b'!
 
Enter command:
 
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MINOR) AS
  (SELECT X FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT X FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MINOR
FROM PX !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MINOR
--------
fff
fff
ddd
eee
eee
bbb
ccc
 
resultcount :                     7
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MINOR) AS
  (SELECT X FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT X FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MINOR
FROM PX !
 
resultcount :                     7
 
Enter command:
FETCH C INTO :A!
 
MINOR
--------
fff
fff
ddd
eee
eee
bbb
ccc
 
resultcount :                     7
 
Enter command:
PARSING !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MINOR) AS
  (SELECT X FROM T WHERE W = :A
   UNION ALL
   SELECT X FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MINOR
FROM PX !
parsing idnr :       1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
PDESCRIBE!
Parsing idnr :      1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
DECLARE C CURSOR FOR !
Parsing idnr :      1
 
c 3 'aaa'
 
resultcount :                     7
 
Enter command:
NODATA !
 
Enter command:
PARS_THEN_EX !
 
Enter command:
FETCH C INTO :A!
 
MINOR
--------
fff
fff
ddd
eee
eee
bbb
ccc
 
resultcount :                     7
 
Enter command:
PARS_EXECUTE !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, ZAHL, MAINMAJOR, MYLEVEL) AS
  (SELECT W,X,Y,W , 1 FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, Y, MAINMAJOR, MYLEVEL + 1 FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,ZAHL, FIXED (MYLEVEL,5)
FROM PX
ORDER BY ZAHL !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAINMAJOR | MINOR    | ZAHL          | EXPRESSION1
----------+----------+---------------+------------
aaa       | bbb      |            12 |      1
aaa       | ccc      |            13 |      1
aaa       | ddd      |           124 |      2
aaa       | eee      |           125 |      2
aaa       | eee      |           135 |      2
aaa       | fff      |      12561356 |      3
aaa       | fff      |      12561356 |      3
 
resultcount :                     7
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR,MINOR,ZAHL, MAINMAJOR,MAINMINOR,MAINZAHL) AS
  (SELECT W,X,Y, T.* FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, Y, MAINMAJOR,MAINMINOR,MAINZAHL FROM T, PX
       WHERE MINOR = T.W
  )
SELECT *
FROM PX, TT
WITH LOCK ISOLATION LEVEL 2 !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAJOR | MINOR    | ZAHL          | MAINMAJOR | MAINMINOR | MAINZAHL      | A
------+----------+---------------+-----------+-----------+---------------+--
eee   | fff      |      12561356 | aaa       | bbb       |            12 | b
eee   | fff      |      12561356 | aaa       | ccc       |            13 | b
bbb   | ddd      |           124 | aaa       | bbb       |            12 | b
bbb   | eee      |           125 | aaa       | bbb       |            12 | b
ccc   | eee      |           135 | aaa       | ccc       |            13 | b
aaa   | bbb      |            12 | aaa       | bbb       |            12 | b
aaa   | ccc      |            13 | aaa       | ccc       |            13 | b
 
resultcount :                     7
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, ZAHL, MAINMAJOR) AS
  (SELECT W,X,Y,W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, Y, MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,ZAHL
FROM PX
ORDER BY ZAHL !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAINMAJOR | MINOR    | ZAHL
----------+----------+--------------
aaa       | bbb      |            12
aaa       | ccc      |            13
aaa       | ddd      |           124
aaa       | eee      |           125
aaa       | eee      |           135
aaa       | fff      |      12561356
aaa       | fff      |      12561356
 
resultcount :                     7
 
Enter command:
CLOSE C !
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, ZAHL, MAINMAJOR) AS
  (SELECT W,X,Y,W FROM T WHERE W = :A
   UNION ALL
   SELECT W, X, Y, MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,ZAHL
FROM PX
ORDER BY ZAHL !
 
c 3 'aaa'
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAINMAJOR | MINOR    | ZAHL
----------+----------+--------------
aaa       | bbb      |            12
aaa       | ccc      |            13
aaa       | ddd      |           124
aaa       | eee      |           125
aaa       | eee      |           135
aaa       | fff      |      12561356
aaa       | fff      |      12561356
 
resultcount :                     7
 
Enter command:
CLOSE C !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -5015 Missing keyword:UNION                                      0138
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   EXCEPT
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -9000 System error: Not yet implemented                          0143
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -9000 System error: Not yet implemented                          0199
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
UNION
SELECT * FROM T
ORDER BY FOLGE !
 
***ERROR  -3008 Invalid keyword or missing delimiter                       0270
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -9000 System error: Not yet implemented                          0142
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -2012 View column list too long                                  0073
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -8006 Data types must be compatible                              0159
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(CHR(Y), LENGTH(CHR(Y)),1),
                              MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAINMAJOR         :  aaa
MINOR             :  bbb
FOLGE             :  12
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  ddd
FOLGE             :  124
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  eee
FOLGE             :  125
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  fff
FOLGE             :  1256
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  ccc
FOLGE             :  13
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  eee
FOLGE             :  135
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  fff
FOLGE             :  1356
 
resultcount :                     7
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, ZAHL) AS
  (SELECT W,X,Y FROM T WHERE W IN (SELECT * FROM TT)
   UNION ALL
   SELECT W,X,Y FROM T, PX
       WHERE MINOR = T.W AND X < (SELECT 'f' FROM TT)
  )
SELECT *
FROM PX
WHERE ZAHL IN (SELECT Y FROM T) !
 
resultcount :                     2
 
Enter command:
FETCH C !
 
MAJOR | MINOR    | ZAHL
------+----------+--------------
ccc   | eee      |           135
b     | ccc      |            83
 
resultcount :                     2
 
Enter command:
PARS_EXECUTE !
 
Enter command:
COMMIT RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE KMS_MESSAGE_REFERENCE
( MESSAGE_ID  SMALLINT,
  PARENT_TYPE SMALLINT,
  PARENT      SMALLINT)!
 
Enter command:
CREATE INDEX I_P_T ON KMS_MESSAGE_REFERENCE (PARENT_TYPE)!
 
Enter command:
INSERT INTO KMS_MESSAGE_REFERENCE VALUES (1,1,1)!
 
Enter command:
INSERT INTO KMS_MESSAGE_REFERENCE VALUES (1,1,2)!
 
Enter command:
 
CREATE TABLE KMS_MESSAGE
(ID     SMALLINT,
 PARENT SMALLINT)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (11, 1)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (12, 1)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (111, 11)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (1111, 111)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (21, 2)!
 
Enter command:
SELECT * FROM KMS_MESSAGE !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
ID     | PARENT
-------+-------
    11 |      1
    12 |      1
   111 |     11
  1111 |    111
    21 |      2
 
resultcount :                     5
 
Enter command:
 
CREATE TABLE KMS_USER_MESSAGE
(MESSAGE_ID SMALLINT,
 USER_ID    SMALLINT,
 READ_TIME  TIME)!
 
Enter command:
CREATE INDEX I ON KMS_USER_MESSAGE (USER_ID)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (11, 4711, TIME)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (12, 9, TIME)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (111, 4711, TIME)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (1111, 9, TIME)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (21, 4711, TIME)!
 
Enter command:
SELECT * FROM KMS_USER_MESSAGE !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
MESSAGE_ID | USER_ID | READ_TIME
-----------+---------+----------
    11     |   4711  | TIMEYYYY
    12     |      9  | TIMEYYYY
   111     |   4711  | TIMEYYYY
  1111     |      9  | TIMEYYYY
    21     |   4711  | TIMEYYYY
 
resultcount :                     5
 
Enter command:
 
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
)
SELECT KMS_MESSAGE.*, READ_TIME
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= 4711
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
 
resultcount :                     4
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D !
 
ID     | PARENT | READ_TIME
-------+--------+----------
    11 |      1 | TIMEYYYY
   111 |     11 | TIMEYYYY
    12 |      1 | ?????????
  1111 |    111 | ?????????
 
resultcount :                     4
 
Enter command:
 
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
     AND KMS_MESSAGE.ID   BETWEEN :ID AND 1000
)
SELECT KMS_MESSAGE.*, READ_TIME
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= 4711
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
n 5 7
 
resultcount :                     3
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D !
 
ID     | PARENT | READ_TIME
-------+--------+----------
    11 |      1 | TIMEYYYY
   111 |     11 | TIMEYYYY
    12 |      1 | ?????????
 
resultcount :                     3
 
Enter command:
 
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
)
SELECT KMS_MESSAGE.*, READ_TIME
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= :UID
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
n 5 4711
 
resultcount :                     4
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D !
 
ID     | PARENT | READ_TIME
-------+--------+----------
    11 |      1 | TIMEYYYY
   111 |     11 | TIMEYYYY
    12 |      1 | ?????????
  1111 |    111 | ?????????
 
resultcount :                     4
 
Enter command:
 
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
)
SELECT KMS_MESSAGE.*,
       KMS_USER_MESSAGE.MESSAGE_ID MID, KMS_USER_MESSAGE.USER_ID USID,
       RESULT.ID RESID, RESULT.PARENT RESPARENT
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= 4711
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
 
resultcount :                     4
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D, :E, :F!
 
ID     | PARENT | MID    | USID   | RESID  | RESPARENT
-------+--------+--------+--------+--------+----------
    11 |      1 |     11 |   4711 |     11 |      1
   111 |     11 |    111 |   4711 |    111 |     11
    12 |      1 | ?????? | ?????? |     12 |      1
  1111 |    111 | ?????? | ?????? |   1111 |    111
 
resultcount :                     4
 
Enter command:
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
)
SELECT KMS_MESSAGE.*,
       KMS_USER_MESSAGE.MESSAGE_ID MID, KMS_USER_MESSAGE.USER_ID USID,
       RESULT.ID RESID, RESULT.PARENT RESPARENT
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= :UID
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
n 5 4711
 
resultcount :                     4
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D, :E, :F, :G !
 
ID     | PARENT | MID    | USID   | RESID  | RESPARENT
-------+--------+--------+--------+--------+----------
    11 |      1 |     11 |   4711 |     11 |      1
   111 |     11 |    111 |   4711 |    111 |     11
    12 |      1 | ?????? | ?????? |     12 |      1
  1111 |    111 | ?????? | ?????? |   1111 |    111
 
resultcount :                     4
 
Enter command:
PARS_EXECUTE!
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
 
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 
CREATE TABLE "PVC_VSETELEMENT"
(
"VERSIONSETID"           CHAR (16) BYTE    NOT NULL,
"OBJECTID"               CHAR (16) BYTE    NOT NULL,
"VERSIONID"              CHAR (16) BYTE    NOT NULL,
"ACTIVATIONSEQNO"        INTEGER    NOT NULL  DEFAULT 0,
"MODOPERATION"           INTEGER,
"ISIMPORTED"             SMALLINT,
"DEACTIVATED"               SMALLINT,
"CREATIONTIME"               TIMESTAMP    NOT NULL,
"LASTMODIFIED"               TIMESTAMP    NOT NULL,
"AUTOVERSION"               SMALLINT    NOT NULL,
"IDXDECLID"               INTEGER,
"LOCKINGVSID"               CHAR (16) BYTE,
PRIMARY KEY ("VERSIONSETID", "OBJECTID")
)!
 
Enter command:
CREATE INDEX "PVC_VSE_VID_ISN" ON "PVC_VSETELEMENT"(
 "VERSIONSETID" ASC,
 "ACTIVATIONSEQNO" ASC)!
 
Enter command:
CREATE INDEX "PVC_VSE_VS_O_V" ON "PVC_VSETELEMENT"(
 "VERSIONSETID" ASC,
 "OBJECTID" ASC,
 "VERSIONID" ASC)!
 
Enter command:
 
CREATE TABLE "PVC_VERSION"
(
"VERSIONID"               CHAR (16) BYTE    NOT NULL,
"OBJECTID"               CHAR (16) BYTE    NOT NULL,
"BRANCHID"               CHAR (16) BYTE    NOT NULL,
"BRANCHSEQNO"               INTEGER    NOT NULL,
"OBJSTATE"               INTEGER    NOT NULL,
"ISDELETED"               SMALLINT    NOT NULL,
"CREATORNAME"               VARCHAR (255)   NOT NULL,
"CREATIONTIME"               TIMESTAMP    NOT NULL,
"LASTMODIFIED"               TIMESTAMP    NOT NULL,
"ISARCHIVED"               SMALLINT    NOT NULL    DEFAULT      0,
"VERSIONTYPE"               INTEGER    NOT NULL,
"DELETELOCK"               SMALLINT    NOT NULL,
PRIMARY KEY ("VERSIONID")
)!
 
Enter command:
CREATE INDEX "PVC_V_VID_STATE" ON "PVC_VERSION"(
 "VERSIONID" ASC, "OBJSTATE" ASC)!
 
Enter command:
 
EXPLAIN
SELECT /*+ORDERED, JOIN(ACCESS=INDEXACCESS,L2_STRAT_NO_OPTIM,
L2_MORE_STRATEGIES) */ DISTINCT *
FROM "PVC_VSETELEMENT" "VSE" INNER JOIN "PVC_VERSION" "V"
 ON "V"."VERSIONID" = "VSE"."VERSIONID"
WHERE ("VSE"."VERSIONSETID" = X'C45CD580373A11DACEE7003005711AC9'
 OR "VSE"."VERSIONSETID" = X'C45CD56E373A11DABF68003005711AC9') AND
 "VSE"."DEACTIVATED" =  0 AND  "V"."ISDELETED" = 0 !
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
                   | VSE                |                    | DIFFERENT STRATEGIES FOR OR-TERMS        |          1
                   |                    | PVC_VSE_VID_ISN    | RANGE CONDITION FOR INDEX                |
                   |                    |                    | ADDNL. QUALIFICATION ON INDEX            |
                   |                    | VERSIONSETID       |      (USED INDEX COLUMN)                 |
                   |                    | VERSIONSETID       |      (USED KEY COLUMN)                   |
                   |                    | PVC_VSE_VID_ISN    | RANGE CONDITION FOR INDEX                |
                   |                    |                    | ADDNL. QUALIFICATION ON INDEX            |
                   |                    | VERSIONSETID       |      (USED INDEX COLUMN)                 |
                   |                    | VERSIONSETID       |      (USED KEY COLUMN)                   |
                   | V                  | PVC_V_VID_STATE    | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | VERSIONID          |      (USED INDEX COLUMN)                 |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |         10
 
Enter command:
 
SELECT /*+ORDERED, JOIN(ACCESS=INDEXACCESS,L2_STRAT_NO_OPTIM,
L2_MORE_STRATEGIES) */ DISTINCT *
FROM "PVC_VSETELEMENT" "VSE" INNER JOIN "PVC_VERSION" "V"
 ON "V"."VERSIONID" = "VSE"."VERSIONID"
WHERE ("VSE"."VERSIONSETID" = X'C45CD580373A11DACEE7003005711AC9'
 OR "VSE"."VERSIONSETID" = X'C45CD56E373A11DABF68003005711AC9') AND
 "VSE"."DEACTIVATED" =  0 AND  "V"."ISDELETED" = 0 !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
 
ROLLBACK WORK RELEASE!
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 
CREATE TABLE "INVEST"
(
 "COUNTER"               INTEGER    NOT NULL,
 "CARTNUM"               INTEGER    NOT NULL,
 "MEDORDER"               INTEGER    NOT NULL,
 "FINANSID"               SMALLINT    NOT NULL,
 "POLSER"               VARCHAR (15) ,
 "POLNUM"               VARCHAR (30) ,
 "DOGNUM"               VARCHAR (50) ,
 "COMPANY"               SMALLINT,
 "DOCID"               VARCHAR (10) ,
 "RESID"               VARCHAR (10) NOT NULL,
 "DATERES"               DATE,
 "TIMERES"               TIME,
 "CABID"               VARCHAR (15) ,
 "KUO"               FIXED (3,2)    NOT NULL,
 "IDPRIHOD"               INTEGER,
 "IDRASHOD"               INTEGER,
 "DATE_TARIF"               DATE,
 "COMMENTS"               VARCHAR (1000) ,
 "FACTRESID"               VARCHAR (10) ,
 "REASON"               VARCHAR (100) ,
 "KMU"               INTEGER,
 "KOORDINATOR_COMMENTS"               VARCHAR (1000) ,
 "DOCTORID"               VARCHAR (10) ,
 PRIMARY KEY ("COUNTER")
)!
 
Enter command:
 
CREATE TABLE "T_RESTYPE"
(
 "RESID"               VARCHAR (10) NOT NULL,
 "RESEARCHTYPE"               VARCHAR (255) NOT NULL,
 "TARIF"               FIXED (20,2)    NOT NULL,
 "NOT_EXIST"               BOOLEAN    NOT NULL    DEFAULT FALSE,
 "PLAT"               BOOLEAN    NOT NULL    DEFAULT FALSE,
 "OTKL"               BOOLEAN    NOT NULL    DEFAULT FALSE,
 "BDATE"               DATE    NOT NULL    DEFAULT DATE,
 "EDATE"               DATE,
 "FORMA"               VARCHAR (20) ,
 "OMS_TARIF"               FIXED (20,2),
 "BUD_TARIF"               FIXED (20,2),
 "FORMULAR"               INTEGER,
 "UE"               FIXED (4,1),
 "UE_CHILD"               FIXED (4,1),
 "UE_LABOR"               FIXED (4,1),
 "UE_SECOND"               FIXED (4,1),
 "UE_SECOND_LABOR"               FIXED (4,1),
 "UE_CHILD_LABOR"               FIXED (4,1),
 "MULTI"               SMALLINT,
 "DOSE_G"               FIXED (4,2),
 "DOSE_S"               FIXED (4,2),
 "DOSE_G_CHILD"               FIXED (4,2),
 "LUCH_FILMS"               SMALLINT,
 "DURATION"               SMALLINT,
 "COMPLEXITY"               FIXED (5,3),
 "COMPLEXITY_SMR"               FIXED (5,3)
)!
 
Enter command:
CREATE UNIQUE INDEX "INDEX001" ON "T_RESTYPE"("RESID" ASC, "BDATE" ASC)!
 
Enter command:
 
 
CREATE TABLE "DID_DOC"
(
 "COUNTER"               INTEGER    NOT NULL,
 "RESID"               VARCHAR (10) NOT NULL,
 "RES_NUM"               SMALLINT    NOT NULL,
 "DOCTORID"               VARCHAR (10) ,
 "SMRID"               VARCHAR (10) ,
 "FORMA"               BOOLEAN,
 "DID_DATE"               DATE    NOT NULL    DEFAULT DATE,
 "DID_TIME"               TIME    NOT NULL    DEFAULT TIME,
 "IS_PRINT"               BOOLEAN,
 "ZAV_CONTROL"               VARCHAR (10) ,
 "NOT_READY"               BOOLEAN
)!
 
Enter command:
 
EXPLAIN
SELECT I.COUNTER,
I.RESID, R.TARIF, I.KUO, I.KUO*R.TARIF SUMMA, R.RESEARCHTYPE, I.COMMENTS
FROM < INVEST I, T_RESTYPE R, DID_DOC D >
WHERE
I.RESID=R.RESID AND
I.FINANSID=4 AND
R.BDATE<I.DATE_TARIF AND
(R.EDATE>=I.DATE_TARIF OR R.EDATE IS NULL) AND
I.CARTNUM=51701 AND
I.IDRASHOD IS NULL AND
I.IDPRIHOD IS NOT NULL AND
I.COUNTER=D.COUNTER(+) AND
D.COUNTER IS NULL!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
                   | I                  |                    | TABLE SCAN                               |          1
                   | R                  | INDEX001           | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | RESID              |      (USED INDEX COLUMN)                 |
                   | D                  |                    | TABLE SCAN                               |          1
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          7
 
Enter command:
 
ROLLBACK WORK RELEASE!
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 
CREATE TABLE TAB1(C1 CHAR(5) KEY, C2 INT)!
 
Enter command:
INSERT INTO TAB1 VALUES('12345', 2)!
 
Enter command:
CREATE TABLE TAB2(C1 CHAR(10), C2 INT)!
 
Enter command:
INSERT INTO TAB2 VALUES('absdfg', 2)!
 
Enter command:
 
EXPLAIN
SELECT * FROM <TAB2, TAB1> WHERE TAB1.C1 = '1234567890' !
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
KERN               | TAB2               |                    | TABLE SCAN                               |          1
KERN               | TAB1               | C1                 | JOIN VIA KEY COLUMN                      |          1
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          4
 
Enter command:
SELECT * FROM <TAB2, TAB1> WHERE TAB1.C1 = '1234567890' !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
 
ROLLBACK WORK RELEASE!
 
Enter command:
!** TEST JOIN OF LONGER COLUMN TO SHORTER COLUMN
 
Enter command:
FILE CONNECT ( SUT SUT !
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT   ISOLATION LEVEL 1 !
 
Enter command:
!* LONGER KEY PART ON TOP OF KEY SEQUENCE
 
Enter command:
CREATE TABLE S1 (
C1 CHAR(11) ASCII, C2 CHAR(5) ASCII, C3 CHAR(5) ASCII, C4 CHAR(11) ASCII )!
 
Enter command:
INSERT INTO S1 VALUES ('HALLO'      , 'HALLO', 'HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S1 VALUES ('HALLO HALLO', 'HALLO', 'HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S1 VALUES ('HALLO'      , 'HALLO', 'HALLO', 'HALLO HALLO')!
 
Enter command:
 
 
!* LONGER KEY PART IN MIDDLE OF KEY SEQUENCE
 
Enter command:
CREATE TABLE S2 (
C1 CHAR(5) ASCII, C2 CHAR(11) ASCII, C3 CHAR(5) ASCII, C4 CHAR(11) ASCII )!
 
Enter command:
INSERT INTO S2 VALUES ('HALLO', 'HALLO'      , 'HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S2 VALUES ('HALLO', 'HALLO HALLO', 'HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S2 VALUES ('HALLO', 'HALLO'      , 'HALLO', 'HALLO HALLO')!
 
Enter command:
 
!* LONGER KEY PART ON END OF KEY SEQUENCE
 
Enter command:
CREATE TABLE S3 (
C1 CHAR(5) ASCII, C2 CHAR(5) ASCII, C3 CHAR(11) ASCII, C4 CHAR(11) ASCII )!
 
Enter command:
INSERT INTO S3 VALUES ('HALLO', 'HALLO', 'HALLO'      , 'HALLO')!
 
Enter command:
INSERT INTO S3 VALUES ('HALLO', 'HALLO', 'HALLO HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S3 VALUES ('HALLO', 'HALLO', 'HALLO'      , 'HALLO HALLO')!
 
Enter command:
 
 
CREATE TABLE DST ( K1 CHAR(5) ASCII, K2 CHAR(5) ASCII, K3 CHAR(5) ASCII,
C4 CHAR(5) ASCII, PRIMARY KEY(K1,K2,K3))!
 
Enter command:
INSERT INTO DST VALUES ('HALLO', 'HALLO', 'HALLO', 'HALLO')!
 
Enter command:
 
!* JOIN KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S1.C1, DST.K1
FROM S1, DST
WHERE S1.C1=DST.K1!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S1                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | TABLE SCAN                               |          1
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          5
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S1.C1, DST.K1
FROM S1, DST
WHERE S1.C1=DST.K1!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1          | K1
------------+------
HALLO       | HALLO
HALLO       | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S1.C1,S1.C2,S1.C3,S1.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S1, DST
WHERE S1.C1=DST.K1 AND S1.C2=DST.K2 AND S1.C3=DST.K3 AND S1.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S1                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | TABLE SCAN                               |          1
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          7
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S1.C1,S1.C2,S1.C3,S1.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S1, DST
WHERE S1.C1=DST.K1 AND S1.C2=DST.K2 AND S1.C3=DST.K3 AND S1.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1          | C2    | C3    | C4          | K1    | K2    | K3    | C4
------------+-------+-------+-------------+-------+-------+-------+------
HALLO       | HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* JOIN KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S2.C1,S2.C2, DST.K1,DST.K2
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S2                 |                    | TABLE SCAN                               |          1
SUT                | DST                | K1                 | JOIN VIA KEY RANGE                       |          1
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          5
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S2.C1,S2.C2, DST.K1,DST.K2
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1    | C2          | K1    | K2
------+-------------+-------+------
HALLO | HALLO       | HALLO | HALLO
HALLO | HALLO       | HALLO | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S2.C1,S2.C2,S2.C3,S2.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2 AND S2.C3=DST.K3 AND S2.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S2                 |                    | TABLE SCAN                               |          1
SUT                | DST                | K1                 | JOIN VIA KEY RANGE                       |          1
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          7
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S2.C1,S2.C2,S2.C3,S2.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2 AND S2.C3=DST.K3 AND S2.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1    | C2          | C3    | C4          | K1    | K2    | K3    | C4
------+-------------+-------+-------------+-------+-------+-------+------
HALLO | HALLO       | HALLO | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* JOIN KEY START (SAME AS WHOLE KEY)
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S3.C1,S3.C2,S3.C3, DST.K1,DST.K2,DST.K3
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S3                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | JOIN VIA RANGE OF MULTIPLE KEY COLUMNS   |          1
                   |                    | K1                 |      (USED KEY COLUMN)                   |
                   |                    | K2                 |      (USED KEY COLUMN)                   |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          7
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S3.C1,S3.C2,S3.C3, DST.K1,DST.K2,DST.K3
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1    | C2    | C3          | K1    | K2    | K3
------+-------+-------------+-------+-------+------
HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO
HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S3.C1,S3.C2,S3.C3,S3.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3 AND S3.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S3                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | JOIN VIA RANGE OF MULTIPLE KEY COLUMNS   |          1
                   |                    | K1                 |      (USED KEY COLUMN)                   |
                   |                    | K2                 |      (USED KEY COLUMN)                   |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          7
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S3.C1,S3.C2,S3.C3,S3.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3 AND S3.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1    | C2    | C3          | C4          | K1    | K2    | K3    | C4
------+-------+-------------+-------------+-------+-------+-------+------
HALLO | HALLO | HALLO       | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* DROP PK AND CREATE INDEX
 
Enter command:
ALTER TABLE DST DROP PRIMARY KEY!
 
Enter command:
CREATE INDEX PK ON DST(K1,K2,K3)!
 
Enter command:
 
!* JOIN KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S1.C1, DST.K1
FROM S1, DST
WHERE S1.C1=DST.K1!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S1                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | TABLE SCAN                               |          1
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          5
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S1.C1, DST.K1
FROM S1, DST
WHERE S1.C1=DST.K1!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1          | K1
------------+------
HALLO       | HALLO
HALLO       | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S1.C1,S1.C2,S1.C3,S1.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S1, DST
WHERE S1.C1=DST.K1 AND S1.C2=DST.K2 AND S1.C3=DST.K3 AND S1.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S1                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | TABLE SCAN                               |          1
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          7
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S1.C1,S1.C2,S1.C3,S1.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S1, DST
WHERE S1.C1=DST.K1 AND S1.C2=DST.K2 AND S1.C3=DST.K3 AND S1.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1          | C2    | C3    | C4          | K1    | K2    | K3    | C4
------------+-------+-------+-------------+-------+-------+-------+------
HALLO       | HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* JOIN KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S2.C1,S2.C2, DST.K1,DST.K2
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S2                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          5
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S2.C1,S2.C2, DST.K1,DST.K2
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1    | C2          | K1    | K2
------+-------------+-------+------
HALLO | HALLO       | HALLO | HALLO
HALLO | HALLO       | HALLO | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S2.C1,S2.C2,S2.C3,S2.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2 AND S2.C3=DST.K3 AND S2.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S2                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          7
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S2.C1,S2.C2,S2.C3,S2.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2 AND S2.C3=DST.K3 AND S2.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1    | C2          | C3    | C4          | K1    | K2    | K3    | C4
------+-------------+-------+-------------+-------+-------+-------+------
HALLO | HALLO       | HALLO | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* JOIN KEY START (SAME AS WHOLE KEY)
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S3.C1,S3.C2,S3.C3, DST.K1,DST.K2,DST.K3
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S3                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    | K2                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          7
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S3.C1,S3.C2,S3.C3, DST.K1,DST.K2,DST.K3
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1    | C2    | C3          | K1    | K2    | K3
------+-------+-------------+-------+-------+------
HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO
HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S3.C1,S3.C2,S3.C3,S3.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3 AND S3.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S3                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    | K2                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          7
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S3.C1,S3.C2,S3.C3,S3.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3 AND S3.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1    | C2    | C3          | C4          | K1    | K2    | K3    | C4
------+-------+-------------+-------------+-------+-------+-------+------
HALLO | HALLO | HALLO       | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
 
 
ROLLBACK WORK RELEASE!
 
Enter command:
 
FILE CONNECT ( SUT SUT !
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT   ISOLATION LEVEL 1 !
 
Enter command:
DROP USER KERN !
 
Enter command:
COMMIT WORK RELEASE !
 
Enter command:
 
 
FILE JOIN_R ( 'YES' !
 
Enter command:
SENDERID DBM !
FILE CONNECT ( SUT SUT !
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT   ISOLATION LEVEL 1 !
 
Enter command:
SET PARAMETER OPTIMIZE_OPERATOR_JOIN = 'YES' !
 
Enter command:
COMMIT RELEASE !
 
Enter command:
SENDERID XCI !
 
FILE CONNECT ( SUT SUT !
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT   ISOLATION LEVEL 1 !
 
Enter command:
CREATE USER KERN PASSWORD TEST DBA NOT EXCLUSIVE !
 
Enter command:
COMMIT WORK RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE T ( W CHAR (3),
X CHAR (8) ,
Y FIXED (12))!
 
Enter command:
INSERT T VALUES ('aaa', 'bbb', 12)!
 
Enter command:
INSERT T VALUES ('aaa', 'ccc', 13)!
 
Enter command:
INSERT T VALUES ('b  ', 'ccc', 83)!
 
Enter command:
INSERT T VALUES ('bbb', 'ddd', 124)!
 
Enter command:
INSERT T VALUES ('bbb', 'eee', 125)!
 
Enter command:
INSERT T VALUES ('ccc', 'eee', 135)!
 
Enter command:
INSERT T VALUES ('eee', 'fff', 12561356)!
 
Enter command:
CREATE TABLE TT ( A CHAR (1))!
 
Enter command:
INSERT TT SET A = 'b'!
 
Enter command:
 
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MINOR) AS
  (SELECT X FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT X FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MINOR
FROM PX !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MINOR
--------
fff
fff
ddd
eee
eee
bbb
ccc
 
resultcount :                     7
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MINOR) AS
  (SELECT X FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT X FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MINOR
FROM PX !
 
resultcount :                     7
 
Enter command:
FETCH C INTO :A!
 
MINOR
--------
fff
fff
ddd
eee
eee
bbb
ccc
 
resultcount :                     7
 
Enter command:
PARSING !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MINOR) AS
  (SELECT X FROM T WHERE W = :A
   UNION ALL
   SELECT X FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MINOR
FROM PX !
parsing idnr :       1
 
Enter command:
PARS_EXECUTE!
 
Enter command:
PDESCRIBE!
Parsing idnr :      1
 
Enter command:
EXECUTING !
 
Enter command:
DATA !
 
Enter command:
DECLARE C CURSOR FOR !
Parsing idnr :      1
 
c 3 'aaa'
 
resultcount :                     7
 
Enter command:
NODATA !
 
Enter command:
PARS_THEN_EX !
 
Enter command:
FETCH C INTO :A!
 
MINOR
--------
fff
fff
ddd
eee
eee
bbb
ccc
 
resultcount :                     7
 
Enter command:
PARS_EXECUTE !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, ZAHL, MAINMAJOR, MYLEVEL) AS
  (SELECT W,X,Y,W , 1 FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, Y, MAINMAJOR, MYLEVEL + 1 FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,ZAHL, FIXED (MYLEVEL,5)
FROM PX
ORDER BY ZAHL !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAINMAJOR | MINOR    | ZAHL          | EXPRESSION1
----------+----------+---------------+------------
aaa       | bbb      |            12 |      1
aaa       | ccc      |            13 |      1
aaa       | ddd      |           124 |      2
aaa       | eee      |           125 |      2
aaa       | eee      |           135 |      2
aaa       | fff      |      12561356 |      3
aaa       | fff      |      12561356 |      3
 
resultcount :                     7
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR,MINOR,ZAHL, MAINMAJOR,MAINMINOR,MAINZAHL) AS
  (SELECT W,X,Y, T.* FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, Y, MAINMAJOR,MAINMINOR,MAINZAHL FROM T, PX
       WHERE MINOR = T.W
  )
SELECT *
FROM PX, TT
WITH LOCK ISOLATION LEVEL 2 !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAJOR | MINOR    | ZAHL          | MAINMAJOR | MAINMINOR | MAINZAHL      | A
------+----------+---------------+-----------+-----------+---------------+--
eee   | fff      |      12561356 | aaa       | bbb       |            12 | b
eee   | fff      |      12561356 | aaa       | ccc       |            13 | b
bbb   | ddd      |           124 | aaa       | bbb       |            12 | b
bbb   | eee      |           125 | aaa       | bbb       |            12 | b
ccc   | eee      |           135 | aaa       | ccc       |            13 | b
aaa   | bbb      |            12 | aaa       | bbb       |            12 | b
aaa   | ccc      |            13 | aaa       | ccc       |            13 | b
 
resultcount :                     7
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, ZAHL, MAINMAJOR) AS
  (SELECT W,X,Y,W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, Y, MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,ZAHL
FROM PX
ORDER BY ZAHL !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAINMAJOR | MINOR    | ZAHL
----------+----------+--------------
aaa       | bbb      |            12
aaa       | ccc      |            13
aaa       | ddd      |           124
aaa       | eee      |           125
aaa       | eee      |           135
aaa       | fff      |      12561356
aaa       | fff      |      12561356
 
resultcount :                     7
 
Enter command:
CLOSE C !
 
Enter command:
PARS_THEN_EX !
 
Enter command:
DATA !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, ZAHL, MAINMAJOR) AS
  (SELECT W,X,Y,W FROM T WHERE W = :A
   UNION ALL
   SELECT W, X, Y, MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,ZAHL
FROM PX
ORDER BY ZAHL !
 
c 3 'aaa'
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAINMAJOR | MINOR    | ZAHL
----------+----------+--------------
aaa       | bbb      |            12
aaa       | ccc      |            13
aaa       | ddd      |           124
aaa       | eee      |           125
aaa       | eee      |           135
aaa       | fff      |      12561356
aaa       | fff      |      12561356
 
resultcount :                     7
 
Enter command:
CLOSE C !
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -5015 Missing keyword:UNION                                      0138
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   EXCEPT
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -9000 System error: Not yet implemented                          0143
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -9000 System error: Not yet implemented                          0199
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
UNION
SELECT * FROM T
ORDER BY FOLGE !
 
***ERROR  -3008 Invalid keyword or missing delimiter                       0270
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -9000 System error: Not yet implemented                          0142
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR, ZU_VIELE_NAMEN) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -2012 View column list too long                                  0073
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(Y, LENGTH(Y),1), MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
***ERROR  -8006 Data types must be compatible                              0159
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, FOLGE, MAINMAJOR) AS
  (SELECT W,X,CHR(Y),W FROM T WHERE W = 'aaa'
   UNION ALL
   SELECT W, X, FOLGE || SUBSTR(CHR(Y), LENGTH(CHR(Y)),1),
                              MAINMAJOR FROM T, PX
       WHERE MINOR = T.W
  )
SELECT MAINMAJOR,MINOR,FOLGE
FROM PX
ORDER BY FOLGE !
 
resultcount :                     7
 
Enter command:
FETCH C!
 
MAINMAJOR         :  aaa
MINOR             :  bbb
FOLGE             :  12
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  ddd
FOLGE             :  124
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  eee
FOLGE             :  125
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  fff
FOLGE             :  1256
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  ccc
FOLGE             :  13
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  eee
FOLGE             :  135
--------------------------------------------------------------------------------
MAINMAJOR         :  aaa
MINOR             :  fff
FOLGE             :  1356
 
resultcount :                     7
 
Enter command:
DECLARE C CURSOR FOR
  WITH RECURSIVE PX (MAJOR, MINOR, ZAHL) AS
  (SELECT W,X,Y FROM T WHERE W IN (SELECT * FROM TT)
   UNION ALL
   SELECT W,X,Y FROM T, PX
       WHERE MINOR = T.W AND X < (SELECT 'f' FROM TT)
  )
SELECT *
FROM PX
WHERE ZAHL IN (SELECT Y FROM T) !
 
resultcount :                     2
 
Enter command:
FETCH C !
 
MAJOR | MINOR    | ZAHL
------+----------+--------------
ccc   | eee      |           135
b     | ccc      |            83
 
resultcount :                     2
 
Enter command:
PARS_EXECUTE !
 
Enter command:
COMMIT RELEASE !
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
CREATE TABLE KMS_MESSAGE_REFERENCE
( MESSAGE_ID  SMALLINT,
  PARENT_TYPE SMALLINT,
  PARENT      SMALLINT)!
 
Enter command:
CREATE INDEX I_P_T ON KMS_MESSAGE_REFERENCE (PARENT_TYPE)!
 
Enter command:
INSERT INTO KMS_MESSAGE_REFERENCE VALUES (1,1,1)!
 
Enter command:
INSERT INTO KMS_MESSAGE_REFERENCE VALUES (1,1,2)!
 
Enter command:
 
CREATE TABLE KMS_MESSAGE
(ID     SMALLINT,
 PARENT SMALLINT)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (11, 1)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (12, 1)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (111, 11)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (1111, 111)!
 
Enter command:
INSERT INTO KMS_MESSAGE VALUES (21, 2)!
 
Enter command:
SELECT * FROM KMS_MESSAGE !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
ID     | PARENT
-------+-------
    11 |      1
    12 |      1
   111 |     11
  1111 |    111
    21 |      2
 
resultcount :                     5
 
Enter command:
 
CREATE TABLE KMS_USER_MESSAGE
(MESSAGE_ID SMALLINT,
 USER_ID    SMALLINT,
 READ_TIME  TIME)!
 
Enter command:
CREATE INDEX I ON KMS_USER_MESSAGE (USER_ID)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (11, 4711, TIME)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (12, 9, TIME)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (111, 4711, TIME)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (1111, 9, TIME)!
 
Enter command:
INSERT INTO KMS_USER_MESSAGE VALUES (21, 4711, TIME)!
 
Enter command:
SELECT * FROM KMS_USER_MESSAGE !
 
resultcount :               unknown
 
Enter command:
FETCH !
 
MESSAGE_ID | USER_ID | READ_TIME
-----------+---------+----------
    11     |   4711  | TIMEYYYY
    12     |      9  | TIMEYYYY
   111     |   4711  | TIMEYYYY
  1111     |      9  | TIMEYYYY
    21     |   4711  | TIMEYYYY
 
resultcount :                     5
 
Enter command:
 
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
)
SELECT KMS_MESSAGE.*, READ_TIME
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= 4711
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
 
resultcount :                     4
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D !
 
ID     | PARENT | READ_TIME
-------+--------+----------
    11 |      1 | TIMEYYYY
    12 |      1 | ?????????
   111 |     11 | TIMEYYYY
  1111 |    111 | ?????????
 
resultcount :                     4
 
Enter command:
 
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
     AND KMS_MESSAGE.ID   BETWEEN :ID AND 1000
)
SELECT KMS_MESSAGE.*, READ_TIME
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= 4711
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
n 5 7
 
resultcount :                     3
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D !
 
ID     | PARENT | READ_TIME
-------+--------+----------
    11 |      1 | TIMEYYYY
    12 |      1 | ?????????
   111 |     11 | TIMEYYYY
 
resultcount :                     3
 
Enter command:
 
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
)
SELECT KMS_MESSAGE.*, READ_TIME
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= :UID
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
n 5 4711
 
resultcount :                     4
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D !
 
ID     | PARENT | READ_TIME
-------+--------+----------
    11 |      1 | TIMEYYYY
    12 |      1 | ?????????
   111 |     11 | TIMEYYYY
  1111 |    111 | ?????????
 
resultcount :                     4
 
Enter command:
 
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
)
SELECT KMS_MESSAGE.*,
       KMS_USER_MESSAGE.MESSAGE_ID MID, KMS_USER_MESSAGE.USER_ID USID,
       RESULT.ID RESID, RESULT.PARENT RESPARENT
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= 4711
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
 
resultcount :                     4
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D, :E, :F!
 
ID     | PARENT | MID    | USID   | RESID  | RESPARENT
-------+--------+--------+--------+--------+----------
    11 |      1 |     11 |   4711 |     11 |      1
    12 |      1 | ?????? | ?????? |     12 |      1
   111 |     11 |    111 |   4711 |    111 |     11
  1111 |    111 | ?????? | ?????? |   1111 |    111
 
resultcount :                     4
 
Enter command:
PARSING !
 
Enter command:
DECLARE C CURSOR FOR WITH RECURSIVE RESULT(ID, PARENT) AS (
  SELECT MESSAGE_ID, NULL
    FROM KMS_MESSAGE_REFERENCE
   WHERE PARENT_TYPE=:PT AND PARENT=:P
  UNION ALL
  SELECT KMS_MESSAGE.ID, KMS_MESSAGE.PARENT
    FROM KMS_MESSAGE, RESULT
   WHERE KMS_MESSAGE.PARENT=RESULT.ID
)
SELECT KMS_MESSAGE.*,
       KMS_USER_MESSAGE.MESSAGE_ID MID, KMS_USER_MESSAGE.USER_ID USID,
       RESULT.ID RESID, RESULT.PARENT RESPARENT
  FROM KMS_MESSAGE, KMS_USER_MESSAGE, RESULT
 WHERE KMS_MESSAGE.ID=MESSAGE_ID(+)
   AND USER_ID(+)= :UID
   AND KMS_MESSAGE.ID=RESULT.ID !
parsing idnr :       1
 
Enter command:
DATA !
 
Enter command:
 
EXECUTING !
 
Enter command:
DECLARE !
Parsing idnr :      1
Result name  :    C
 
n 5 1
n 5 1
n 5 4711
 
resultcount :                     4
 
Enter command:
PARS_THEN_EX!
 
Enter command:
NODATA !
 
Enter command:
FETCH C INTO :A, :B, :C, :D, :E, :F, :G !
 
ID     | PARENT | MID    | USID   | RESID  | RESPARENT
-------+--------+--------+--------+--------+----------
    11 |      1 |     11 |   4711 |     11 |      1
    12 |      1 | ?????? | ?????? |     12 |      1
   111 |     11 |    111 |   4711 |    111 |     11
  1111 |    111 | ?????? | ?????? |   1111 |    111
 
resultcount :                     4
 
Enter command:
PARS_EXECUTE!
 
Enter command:
ROLLBACK RELEASE !
 
Enter command:
 
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 
CREATE TABLE "PVC_VSETELEMENT"
(
"VERSIONSETID"           CHAR (16) BYTE    NOT NULL,
"OBJECTID"               CHAR (16) BYTE    NOT NULL,
"VERSIONID"              CHAR (16) BYTE    NOT NULL,
"ACTIVATIONSEQNO"        INTEGER    NOT NULL  DEFAULT 0,
"MODOPERATION"           INTEGER,
"ISIMPORTED"             SMALLINT,
"DEACTIVATED"               SMALLINT,
"CREATIONTIME"               TIMESTAMP    NOT NULL,
"LASTMODIFIED"               TIMESTAMP    NOT NULL,
"AUTOVERSION"               SMALLINT    NOT NULL,
"IDXDECLID"               INTEGER,
"LOCKINGVSID"               CHAR (16) BYTE,
PRIMARY KEY ("VERSIONSETID", "OBJECTID")
)!
 
Enter command:
CREATE INDEX "PVC_VSE_VID_ISN" ON "PVC_VSETELEMENT"(
 "VERSIONSETID" ASC,
 "ACTIVATIONSEQNO" ASC)!
 
Enter command:
CREATE INDEX "PVC_VSE_VS_O_V" ON "PVC_VSETELEMENT"(
 "VERSIONSETID" ASC,
 "OBJECTID" ASC,
 "VERSIONID" ASC)!
 
Enter command:
 
CREATE TABLE "PVC_VERSION"
(
"VERSIONID"               CHAR (16) BYTE    NOT NULL,
"OBJECTID"               CHAR (16) BYTE    NOT NULL,
"BRANCHID"               CHAR (16) BYTE    NOT NULL,
"BRANCHSEQNO"               INTEGER    NOT NULL,
"OBJSTATE"               INTEGER    NOT NULL,
"ISDELETED"               SMALLINT    NOT NULL,
"CREATORNAME"               VARCHAR (255)   NOT NULL,
"CREATIONTIME"               TIMESTAMP    NOT NULL,
"LASTMODIFIED"               TIMESTAMP    NOT NULL,
"ISARCHIVED"               SMALLINT    NOT NULL    DEFAULT      0,
"VERSIONTYPE"               INTEGER    NOT NULL,
"DELETELOCK"               SMALLINT    NOT NULL,
PRIMARY KEY ("VERSIONID")
)!
 
Enter command:
CREATE INDEX "PVC_V_VID_STATE" ON "PVC_VERSION"(
 "VERSIONID" ASC, "OBJSTATE" ASC)!
 
Enter command:
 
EXPLAIN
SELECT /*+ORDERED, JOIN(ACCESS=INDEXACCESS,L2_STRAT_NO_OPTIM,
L2_MORE_STRATEGIES) */ DISTINCT *
FROM "PVC_VSETELEMENT" "VSE" INNER JOIN "PVC_VERSION" "V"
 ON "V"."VERSIONID" = "VSE"."VERSIONID"
WHERE ("VSE"."VERSIONSETID" = X'C45CD580373A11DACEE7003005711AC9'
 OR "VSE"."VERSIONSETID" = X'C45CD56E373A11DABF68003005711AC9') AND
 "VSE"."DEACTIVATED" =  0 AND  "V"."ISDELETED" = 0 !
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
                   | VSE                |                    | DIFFERENT STRATEGIES FOR OR-TERMS        |          1
                   |                    | PVC_VSE_VID_ISN    | RANGE CONDITION FOR INDEX                |
                   |                    |                    | ADDNL. QUALIFICATION ON INDEX            |
                   |                    | VERSIONSETID       |      (USED INDEX COLUMN)                 |
                   |                    | VERSIONSETID       |      (USED KEY COLUMN)                   |
                   |                    | PVC_VSE_VID_ISN    | RANGE CONDITION FOR INDEX                |
                   |                    |                    | ADDNL. QUALIFICATION ON INDEX            |
                   |                    | VERSIONSETID       |      (USED INDEX COLUMN)                 |
                   |                    | VERSIONSETID       |      (USED KEY COLUMN)                   |
                   | V                  | PVC_V_VID_STATE    | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | VERSIONID          |      (USED INDEX COLUMN)                 |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |         10
 
Enter command:
 
SELECT /*+ORDERED, JOIN(ACCESS=INDEXACCESS,L2_STRAT_NO_OPTIM,
L2_MORE_STRATEGIES) */ DISTINCT *
FROM "PVC_VSETELEMENT" "VSE" INNER JOIN "PVC_VERSION" "V"
 ON "V"."VERSIONID" = "VSE"."VERSIONID"
WHERE ("VSE"."VERSIONSETID" = X'C45CD580373A11DACEE7003005711AC9'
 OR "VSE"."VERSIONSETID" = X'C45CD56E373A11DABF68003005711AC9') AND
 "VSE"."DEACTIVATED" =  0 AND  "V"."ISDELETED" = 0 !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
 
ROLLBACK WORK RELEASE!
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 
CREATE TABLE "INVEST"
(
 "COUNTER"               INTEGER    NOT NULL,
 "CARTNUM"               INTEGER    NOT NULL,
 "MEDORDER"               INTEGER    NOT NULL,
 "FINANSID"               SMALLINT    NOT NULL,
 "POLSER"               VARCHAR (15) ,
 "POLNUM"               VARCHAR (30) ,
 "DOGNUM"               VARCHAR (50) ,
 "COMPANY"               SMALLINT,
 "DOCID"               VARCHAR (10) ,
 "RESID"               VARCHAR (10) NOT NULL,
 "DATERES"               DATE,
 "TIMERES"               TIME,
 "CABID"               VARCHAR (15) ,
 "KUO"               FIXED (3,2)    NOT NULL,
 "IDPRIHOD"               INTEGER,
 "IDRASHOD"               INTEGER,
 "DATE_TARIF"               DATE,
 "COMMENTS"               VARCHAR (1000) ,
 "FACTRESID"               VARCHAR (10) ,
 "REASON"               VARCHAR (100) ,
 "KMU"               INTEGER,
 "KOORDINATOR_COMMENTS"               VARCHAR (1000) ,
 "DOCTORID"               VARCHAR (10) ,
 PRIMARY KEY ("COUNTER")
)!
 
Enter command:
 
CREATE TABLE "T_RESTYPE"
(
 "RESID"               VARCHAR (10) NOT NULL,
 "RESEARCHTYPE"               VARCHAR (255) NOT NULL,
 "TARIF"               FIXED (20,2)    NOT NULL,
 "NOT_EXIST"               BOOLEAN    NOT NULL    DEFAULT FALSE,
 "PLAT"               BOOLEAN    NOT NULL    DEFAULT FALSE,
 "OTKL"               BOOLEAN    NOT NULL    DEFAULT FALSE,
 "BDATE"               DATE    NOT NULL    DEFAULT DATE,
 "EDATE"               DATE,
 "FORMA"               VARCHAR (20) ,
 "OMS_TARIF"               FIXED (20,2),
 "BUD_TARIF"               FIXED (20,2),
 "FORMULAR"               INTEGER,
 "UE"               FIXED (4,1),
 "UE_CHILD"               FIXED (4,1),
 "UE_LABOR"               FIXED (4,1),
 "UE_SECOND"               FIXED (4,1),
 "UE_SECOND_LABOR"               FIXED (4,1),
 "UE_CHILD_LABOR"               FIXED (4,1),
 "MULTI"               SMALLINT,
 "DOSE_G"               FIXED (4,2),
 "DOSE_S"               FIXED (4,2),
 "DOSE_G_CHILD"               FIXED (4,2),
 "LUCH_FILMS"               SMALLINT,
 "DURATION"               SMALLINT,
 "COMPLEXITY"               FIXED (5,3),
 "COMPLEXITY_SMR"               FIXED (5,3)
)!
 
Enter command:
CREATE UNIQUE INDEX "INDEX001" ON "T_RESTYPE"("RESID" ASC, "BDATE" ASC)!
 
Enter command:
 
 
CREATE TABLE "DID_DOC"
(
 "COUNTER"               INTEGER    NOT NULL,
 "RESID"               VARCHAR (10) NOT NULL,
 "RES_NUM"               SMALLINT    NOT NULL,
 "DOCTORID"               VARCHAR (10) ,
 "SMRID"               VARCHAR (10) ,
 "FORMA"               BOOLEAN,
 "DID_DATE"               DATE    NOT NULL    DEFAULT DATE,
 "DID_TIME"               TIME    NOT NULL    DEFAULT TIME,
 "IS_PRINT"               BOOLEAN,
 "ZAV_CONTROL"               VARCHAR (10) ,
 "NOT_READY"               BOOLEAN
)!
 
Enter command:
 
EXPLAIN
SELECT I.COUNTER,
I.RESID, R.TARIF, I.KUO, I.KUO*R.TARIF SUMMA, R.RESEARCHTYPE, I.COMMENTS
FROM < INVEST I, T_RESTYPE R, DID_DOC D >
WHERE
I.RESID=R.RESID AND
I.FINANSID=4 AND
R.BDATE<I.DATE_TARIF AND
(R.EDATE>=I.DATE_TARIF OR R.EDATE IS NULL) AND
I.CARTNUM=51701 AND
I.IDRASHOD IS NULL AND
I.IDPRIHOD IS NOT NULL AND
I.COUNTER=D.COUNTER(+) AND
D.COUNTER IS NULL!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
                   | I                  |                    | TABLE SCAN                               |          1
                   | R                  | INDEX001           | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | RESID              |      (USED INDEX COLUMN)                 |
                   | D                  |                    | JOIN VIA KEY RANGE                       |          1
                   |                    |                    | TABLE TEMPORARY SORTED                   |
                   |                    | COUNTER            |      (USED SORT COLUMN)                  |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          5
 
Enter command:
 
ROLLBACK WORK RELEASE!
 
Enter command:
FILE CONNECT ( KERN TEST !
 
Enter command:
CONNECT KERN IDENTIFIED BY TEST   ISOLATION LEVEL 1 !
 
Enter command:
 
CREATE TABLE TAB1(C1 CHAR(5) KEY, C2 INT)!
 
Enter command:
INSERT INTO TAB1 VALUES('12345', 2)!
 
Enter command:
CREATE TABLE TAB2(C1 CHAR(10), C2 INT)!
 
Enter command:
INSERT INTO TAB2 VALUES('absdfg', 2)!
 
Enter command:
 
EXPLAIN
SELECT * FROM <TAB2, TAB1> WHERE TAB1.C1 = '1234567890' !
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
KERN               | TAB2               |                    | TABLE SCAN                               |          1
KERN               | TAB1               | C1                 | JOIN VIA KEY COLUMN                      |          1
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          2
 
Enter command:
SELECT * FROM <TAB2, TAB1> WHERE TAB1.C1 = '1234567890' !
 
***ERROR    100 Row not found                                              0001
 
Enter command:
 
ROLLBACK WORK RELEASE!
 
Enter command:
!** TEST JOIN OF LONGER COLUMN TO SHORTER COLUMN
 
Enter command:
FILE CONNECT ( SUT SUT !
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT   ISOLATION LEVEL 1 !
 
Enter command:
!* LONGER KEY PART ON TOP OF KEY SEQUENCE
 
Enter command:
CREATE TABLE S1 (
C1 CHAR(11) ASCII, C2 CHAR(5) ASCII, C3 CHAR(5) ASCII, C4 CHAR(11) ASCII )!
 
Enter command:
INSERT INTO S1 VALUES ('HALLO'      , 'HALLO', 'HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S1 VALUES ('HALLO HALLO', 'HALLO', 'HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S1 VALUES ('HALLO'      , 'HALLO', 'HALLO', 'HALLO HALLO')!
 
Enter command:
 
 
!* LONGER KEY PART IN MIDDLE OF KEY SEQUENCE
 
Enter command:
CREATE TABLE S2 (
C1 CHAR(5) ASCII, C2 CHAR(11) ASCII, C3 CHAR(5) ASCII, C4 CHAR(11) ASCII )!
 
Enter command:
INSERT INTO S2 VALUES ('HALLO', 'HALLO'      , 'HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S2 VALUES ('HALLO', 'HALLO HALLO', 'HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S2 VALUES ('HALLO', 'HALLO'      , 'HALLO', 'HALLO HALLO')!
 
Enter command:
 
!* LONGER KEY PART ON END OF KEY SEQUENCE
 
Enter command:
CREATE TABLE S3 (
C1 CHAR(5) ASCII, C2 CHAR(5) ASCII, C3 CHAR(11) ASCII, C4 CHAR(11) ASCII )!
 
Enter command:
INSERT INTO S3 VALUES ('HALLO', 'HALLO', 'HALLO'      , 'HALLO')!
 
Enter command:
INSERT INTO S3 VALUES ('HALLO', 'HALLO', 'HALLO HALLO', 'HALLO')!
 
Enter command:
INSERT INTO S3 VALUES ('HALLO', 'HALLO', 'HALLO'      , 'HALLO HALLO')!
 
Enter command:
 
 
CREATE TABLE DST ( K1 CHAR(5) ASCII, K2 CHAR(5) ASCII, K3 CHAR(5) ASCII,
C4 CHAR(5) ASCII, PRIMARY KEY(K1,K2,K3))!
 
Enter command:
INSERT INTO DST VALUES ('HALLO', 'HALLO', 'HALLO', 'HALLO')!
 
Enter command:
 
!* JOIN KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S1.C1, DST.K1
FROM S1, DST
WHERE S1.C1=DST.K1!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S1                 |                    | TABLE SCAN                               |          1
SUT                | DST                | K1                 | JOIN VIA KEY RANGE                       |          1
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S1.C1, DST.K1
FROM S1, DST
WHERE S1.C1=DST.K1!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1          | K1
------------+------
HALLO       | HALLO
HALLO       | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S1.C1,S1.C2,S1.C3,S1.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S1, DST
WHERE S1.C1=DST.K1 AND S1.C2=DST.K2 AND S1.C3=DST.K3 AND S1.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S1                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | JOIN VIA MULTIPLE KEY COLUMNS            |          1
                   |                    | K1                 |      (USED KEY COLUMN)                   |
                   |                    | K2                 |      (USED KEY COLUMN)                   |
                   |                    | K3                 |      (USED KEY COLUMN)                   |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S1.C1,S1.C2,S1.C3,S1.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S1, DST
WHERE S1.C1=DST.K1 AND S1.C2=DST.K2 AND S1.C3=DST.K3 AND S1.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1          | C2    | C3    | C4          | K1    | K2    | K3    | C4
------------+-------+-------+-------------+-------+-------+-------+------
HALLO       | HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* JOIN KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S2.C1,S2.C2, DST.K1,DST.K2
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S2                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | JOIN VIA RANGE OF MULTIPLE KEY COLUMNS   |          1
                   |                    | K1                 |      (USED KEY COLUMN)                   |
                   |                    | K2                 |      (USED KEY COLUMN)                   |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S2.C1,S2.C2, DST.K1,DST.K2
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1    | C2          | K1    | K2
------+-------------+-------+------
HALLO | HALLO       | HALLO | HALLO
HALLO | HALLO       | HALLO | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S2.C1,S2.C2,S2.C3,S2.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2 AND S2.C3=DST.K3 AND S2.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S2                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | JOIN VIA MULTIPLE KEY COLUMNS            |          1
                   |                    | K1                 |      (USED KEY COLUMN)                   |
                   |                    | K2                 |      (USED KEY COLUMN)                   |
                   |                    | K3                 |      (USED KEY COLUMN)                   |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S2.C1,S2.C2,S2.C3,S2.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2 AND S2.C3=DST.K3 AND S2.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1    | C2          | C3    | C4          | K1    | K2    | K3    | C4
------+-------------+-------+-------------+-------+-------+-------+------
HALLO | HALLO       | HALLO | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* JOIN KEY START (SAME AS WHOLE KEY)
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S3.C1,S3.C2,S3.C3, DST.K1,DST.K2,DST.K3
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S3                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | JOIN VIA MULTIPLE KEY COLUMNS            |          1
                   |                    | K1                 |      (USED KEY COLUMN)                   |
                   |                    | K2                 |      (USED KEY COLUMN)                   |
                   |                    | K3                 |      (USED KEY COLUMN)                   |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S3.C1,S3.C2,S3.C3, DST.K1,DST.K2,DST.K3
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1    | C2    | C3          | K1    | K2    | K3
------+-------+-------------+-------+-------+------
HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO
HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S3.C1,S3.C2,S3.C3,S3.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3 AND S3.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S3                 |                    | TABLE SCAN                               |          1
SUT                | DST                |                    | JOIN VIA MULTIPLE KEY COLUMNS            |          1
                   |                    | K1                 |      (USED KEY COLUMN)                   |
                   |                    | K2                 |      (USED KEY COLUMN)                   |
                   |                    | K3                 |      (USED KEY COLUMN)                   |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;KEYACCESS)*/
S3.C1,S3.C2,S3.C3,S3.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3 AND S3.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1    | C2    | C3          | C4          | K1    | K2    | K3    | C4
------+-------+-------------+-------------+-------+-------+-------+------
HALLO | HALLO | HALLO       | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* DROP PK AND CREATE INDEX
 
Enter command:
ALTER TABLE DST DROP PRIMARY KEY!
 
Enter command:
CREATE INDEX PK ON DST(K1,K2,K3)!
 
Enter command:
 
!* JOIN KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S1.C1, DST.K1
FROM S1, DST
WHERE S1.C1=DST.K1!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S1                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S1.C1, DST.K1
FROM S1, DST
WHERE S1.C1=DST.K1!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1          | K1
------------+------
HALLO       | HALLO
HALLO       | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S1.C1,S1.C2,S1.C3,S1.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S1, DST
WHERE S1.C1=DST.K1 AND S1.C2=DST.K2 AND S1.C3=DST.K3 AND S1.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S1                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA MULTIPLE INDEXED COLUMNS        |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    | K2                 |      (USED INDEX COLUMN)                 |
                   |                    | K3                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S1.C1,S1.C2,S1.C3,S1.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S1, DST
WHERE S1.C1=DST.K1 AND S1.C2=DST.K2 AND S1.C3=DST.K3 AND S1.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1          | C2    | C3    | C4          | K1    | K2    | K3    | C4
------------+-------+-------+-------------+-------+-------+-------+------
HALLO       | HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* JOIN KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S2.C1,S2.C2, DST.K1,DST.K2
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S2                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA RANGE OF MULTIPLE INDEXED COL.  |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    | K2                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S2.C1,S2.C2, DST.K1,DST.K2
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1    | C2          | K1    | K2
------+-------------+-------+------
HALLO | HALLO       | HALLO | HALLO
HALLO | HALLO       | HALLO | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S2.C1,S2.C2,S2.C3,S2.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2 AND S2.C3=DST.K3 AND S2.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S2                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA MULTIPLE INDEXED COLUMNS        |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    | K2                 |      (USED INDEX COLUMN)                 |
                   |                    | K3                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S2.C1,S2.C2,S2.C3,S2.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S2, DST
WHERE S2.C1=DST.K1 AND S2.C2=DST.K2 AND S2.C3=DST.K3 AND S2.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1    | C2          | C3    | C4          | K1    | K2    | K3    | C4
------+-------------+-------+-------------+-------+-------+-------+------
HALLO | HALLO       | HALLO | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
!* JOIN KEY START (SAME AS WHOLE KEY)
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S3.C1,S3.C2,S3.C3, DST.K1,DST.K2,DST.K3
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S3                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA MULTIPLE INDEXED COLUMNS        |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    | K2                 |      (USED INDEX COLUMN)                 |
                   |                    | K3                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S3.C1,S3.C2,S3.C3, DST.K1,DST.K2,DST.K3
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3!
 
resultcount :                     2
 
Enter command:
FETCH!
 
C1    | C2    | C3          | K1    | K2    | K3
------+-------+-------------+-------+-------+------
HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO
HALLO | HALLO | HALLO       | HALLO | HALLO | HALLO
 
resultcount :                     2
 
Enter command:
!* JOIN WHOLE KEY START
 
Enter command:
EXPLAIN
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S3.C1,S3.C2,S3.C3,S3.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3 AND S3.C4=DST.C4!
 
OWNER              | TABLENAME          | COLUMN_OR_INDEX    | STRATEGY                                 | PAGECOUNT
-------------------+--------------------+--------------------+------------------------------------------+-----------
SUT                | S3                 |                    | TABLE SCAN                               |          1
SUT                | DST                | PK                 | JOIN VIA MULTIPLE INDEXED COLUMNS        |          1
                   |                    | K1                 |      (USED INDEX COLUMN)                 |
                   |                    | K2                 |      (USED INDEX COLUMN)                 |
                   |                    | K3                 |      (USED INDEX COLUMN)                 |
                   |                    |                    |      NO TEMPORARY RESULTS CREATED        |
                   |                    |                    |      RESULT IS COPIED   , COSTVALUE IS   |          3
 
Enter command:
SELECT /*+ORDERED,JOIN(;INDEXACCESS)*/
S3.C1,S3.C2,S3.C3,S3.C4, DST.K1,DST.K2,DST.K3,DST.C4
FROM S3, DST
WHERE S3.C1=DST.K1 AND S3.C2=DST.K2 AND S3.C3=DST.K3 AND S3.C4=DST.C4!
 
resultcount :                     1
 
Enter command:
FETCH!
 
C1    | C2    | C3          | C4          | K1    | K2    | K3    | C4
------+-------+-------------+-------------+-------+-------+-------+------
HALLO | HALLO | HALLO       | HALLO       | HALLO | HALLO | HALLO | HALLO
 
resultcount :                     1
 
Enter command:
 
 
 
ROLLBACK WORK RELEASE!
 
Enter command:
 
FILE CONNECT ( SUT SUT !
 
Enter command:
CONNECT SUT IDENTIFIED BY SUT   ISOLATION LEVEL 1 !
 
Enter command:
DROP USER KERN !
 
Enter command:
COMMIT WORK RELEASE !
 
Enter command:
 
 
FILE SHUTDOWN !
 
Enter command:
DBMCLI SUPERDBA,COLDUSER!
UTIL_CONNECT SUT,SUT!
OK
 
DB_OFFLINE!
OK
 
BYE!
 
Enter command:
VDNEXIT !
SESSION END
 
