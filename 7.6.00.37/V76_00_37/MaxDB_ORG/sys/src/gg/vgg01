.ad 8
.bm 8
.fm 4
.bt $Copyright (c) 2000-2005 SAP AG$$Page %$
.tm 12
.hm 6
.hs 3
.TT 1 $SQL$Project Distributed Database System$VGG01$
.tt 2 $$$
.TT 3 $ElkeZ$Configuration_Parameter$2000-11-23$
***********************************************************
.nf
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
.fo
.nf
.sp
MODULE  : Configuration_Parameter
=========
.sp
Purpose :
.CM *-END-* purpose -------------------------------------
.sp
.cp 3
Define  :
 
        FUNCTION
              g01aggr_optim : boolean;
 
        FUNCTION
              g01align (val : tsp00_Int4): tsp00_Int4;
 
        FUNCTION
              g01backup_block_count : tsp00_Int4;
 
        FUNCTION
              g01auto_recreate_bad_indexes : boolean;
 
        FUNCTION
              g01cache_size (cache_type : tgg04_CacheType) : tsp00_Int4;
 
        FUNCTION
              g01catalog_cache_init_size : tsp00_Int4;
 
        PROCEDURE
              g01check_mxgg (VAR ok : boolean);
 
        FUNCTION
              g01columncompression : boolean;
 
        FUNCTION
              g01checktablewidth   : boolean;
 
        PROCEDURE
              g01datapart_init (
                    VAR mblock    : tgg00_MessBlock;
                    datapart_ptr  : tgg00_DataPartPtr;
                    datapart_size : tsp00_Int4);
 
        FUNCTION
              g01deadlock_detection : tsp00_Int4;
 
        PROCEDURE
              g01default_configuration;
 
        FUNCTION
              g01diag_minmax_optim : boolean;
 
        FUNCTION
              g01diag_reverse_fetch : boolean;
 
        FUNCTION
              g01optimize_parallel_server : tsp00_Int4;
 
        PROCEDURE
              g01dump (
                    VAR hostfile    : tgg00_VfFileref;
                    VAR buf         : tsp00_Page;
                    VAR out_pno     : tsp00_Int4;
                    VAR out_pos     : integer;
                    VAR host_err    : tsp00_VfReturn;
                    VAR errtext     : tsp00_ErrText);
 
        FUNCTION
              g01dw_io_area_flush : tsp00_Int4;
 
        FUNCTION
              g01dw_io_area_size : tsp00_Int4;
 
        FUNCTION
              g01dw_lru_tail_flush : tsp00_Int4;
 
        FUNCTION
              g01GetSessionAuxCounter (
                    VAR t : tgg00_TransContext) : tsp00_Int4;
 
        FUNCTION
              g01hashed_resultset : boolean;
 
        PROCEDURE
              g01inittabid;
 
        PROCEDURE
              g01int4incr (VAR intvalue : tsp00_C4);
 
        FUNCTION
              g01is_livecache : boolean;
 
        FUNCTION
              g01is_archive : boolean;
 
        FUNCTION
              g01join_hash_min_ratio : tsp00_Int4;
 
        FUNCTION
              g01join_maxtab_level4 : tsp00_Int2;
 
        FUNCTION
              g01join_maxtab_level9 : tsp00_Int2;
 
        FUNCTION
              g01join_parall_minsize : tsp00_Int4;
 
        FUNCTION
              g01join_prefetch_percent : tsp00_Int4;
 
        FUNCTION
              g01join_tablebuffer : tsp00_Int4;
 
        FUNCTION
              g01join_search_level : tgg00_JoinSearchLevel;
 
        FUNCTION
              g01kb_work_st_size : tsp00_Int4;
 
        FUNCTION
              g01kb_workbuf_size : tsp00_Int4;
 
        PROCEDURE
              g01key_assign (
                    VAR source_key : tgg00_Lkey;
                    VAR target_key : tgg00_Lkey;
                    VAR e          : tgg00_BasisError);
 
        PROCEDURE
              g01key_and_len_assign (
                    VAR source_key     : tsp00_Key;
                    source_key_len     : tsp00_Int4;
                    VAR target_key     : tsp00_Key;
                    VAR target_key_len : tsp00_Int2;
                    VAR e              : tgg00_BasisError);
 
        FUNCTION
              g01lock_supply_block : tsp00_Int4;
 
        FUNCTION
              g01one_join_phase : boolean;
 
        FUNCTION
              g01optim_inv_only : boolean;
 
        FUNCTION
              g01max_merge : tsp00_Int4;
 
        FUNCTION
              g01maxcpu : tsp00_Int4;
 
        FUNCTION
              g01usedmaxlogqueuecount : tsp00_Int4;
 
        FUNCTION
              g01logqueuecount : tsp00_Int4;
 
        FUNCTION
              g01maxdatawriter : tsp00_Int4;
 
        FUNCTION
              g01maxobjgarbagecoll : tsp00_Int4;
 
        FUNCTION
              g01maxlocks : tsp00_Int4;
 
        FUNCTION
              g01max_retention_time : tsp00_Int4;
 
        FUNCTION
              g01maxtrans : tsp00_Int4;
 
        FUNCTION
              g01maxuser : tsp00_Int4;
 
        FUNCTION
              g01maxuserstack : tsp00_Int4;
 
        FUNCTION
              g01mb_data_size : tsp00_Int4;
 
        FUNCTION
              g01mb_qual_size : tsp00_Int4;
 
        FUNCTION
              g01mb_stack_size : tsp00_Int4;
 
        FUNCTION
              g01mb_strat_size : tsp00_Int4;
 
        PROCEDURE
              g01mblock_init (
                    VAR source_trans : tgg00_TransContext;
                    mess_type  : tgg00_MessType;
                    mess2_type : tgg00_MessType2;
                    VAR mblock : tgg00_MessBlock);
 
        FUNCTION
              g01min_retention_time : tsp00_Int4;
 
        PROCEDURE
              g01mxerrmsg (
                    nam        : tsp00_Name;
                    int_wrong  : tsp00_Int4;
                    int_ok     : tsp00_Int4);
 
        PROCEDURE
              g01new_dump_page (
                    VAR hostfile : tgg00_VfFileref;
                    VAR buf      : tsp00_Page;
                    VAR out_pno  : tsp00_Int4;
                    VAR out_pos  : integer;
                    VAR host_err : tsp00_VfReturn;
                    VAR errtext  : tsp00_ErrText);
 
        PROCEDURE
              g01next_prim_number (VAR prim_int : tsp00_Int4);
 
        FUNCTION
              g01no_of_backup_devs : tsp00_Int4;
 
        FUNCTION
              g01NumberOfUKTs : tsp00_Int4;
 
        FUNCTION
              g01oms_heap_limit : tsp00_Int4;
 
        FUNCTION
              g01oms_heap_usage_threshold : tsp00_Int4; (* PTS 1110149 *)
 
        FUNCTION
              g01oms_stream_timeout : tsp00_Int4; (* PTS 1115635 *)
 
        FUNCTION
              g01oms_vers_free_threshold : tsp00_Int4; (* PTS 1110149 *)
 
        FUNCTION
              g01oms_heap_count :  tsp00_Int4; (* PTS 1110828 *)
 
        FUNCTION
              g01oms_heap_blocksize :  tsp00_Int4; (* PTS 1110828 *)
 
        FUNCTION
              g01optimize_cache : boolean;
 
        FUNCTION
              g01outer_join_ordered : boolean;
 
        FUNCTION
              g01packet_size : tsp00_Int4;
 
        PROCEDURE
              g01qual_init (
                    VAR mblock : tgg00_MessBlock;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
        FUNCTION
              g01BlobPrefetchLowerLimit : tsp00_Int4;
 
        FUNCTION
              g01region_cnt (region_type : tgg00_RegionType) : tsp00_Int4;
 
        FUNCTION
              g01sm_milliseconds : tsp00_Int4;
 
        FUNCTION
              g01sm_reads : tsp00_Int4;
 
        FUNCTION
              g01sm_selectivity : tsp00_Int4;
 
        PROCEDURE
              g01stack_init (
                    VAR mblock : tgg00_MessBlock;
                    stack_ptr  : tgg00_StackListPtr;
                    stack_size : tsp00_Int4;
                    qual_ptr   : tgg00_QualBufPtr;
                    qual_size  : tsp00_Int4);
 
        PROCEDURE
              g01stratpart_init (
                    VAR mblock     : tgg00_MessBlock;
                    stratpart_ptr  : tsp00_MoveObjPtr;
                    stratpart_size : tsp00_Int4);
 
        PROCEDURE
              g01time_vtrace (
                    VAR t           : tgg00_TransContext;
                    msg             : tsp00_Name;
                    VAR start_sec   : tsp00_Int4;
                    VAR start_msec  : tsp00_Int4);
 
        FUNCTION
              g01trigger : boolean;
 
        FUNCTION
              g01use_join_hashtable : boolean;
 
        FUNCTION
              g01trans_history_size : tsp00_Int4;
 
        FUNCTION
              g01trans_threshold_value : tsp00_Int4;
 
        FUNCTION
              g01userstackoverflow : boolean;
 
        PROCEDURE
              g01vtr_init;
              (* ptocExport hgg01_1.h *)
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8  (* ptocSynonym const char* *);
                    msg_text   : tsp00_C24 (* ptocSynonym const char* *);
                    bad_value  : tsp00_Int4);
 
        PROCEDURE
              g01allocate_msg (
                    msg_label  : tsp00_C8  (* ptocSynonym const char* *);
                    msg_text   : tsp00_C24 (* ptocSynonym const char* *);
                    alloc_size : tsp00_Int4);
 
        PROCEDURE
              g01check (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8  (* ptocSynonym const char* *);
                    msg_text   : tsp00_C24 (* ptocSynonym const char* *);
                    bad_value  : tsp00_Int4;
                    constraint : boolean);
 
        PROCEDURE
              g01opaddrmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8  (* ptocSynonym const char* *);
                    msg_text  : tsp00_C24 (* ptocSynonym const char* *);
                    msg_addr  : tsp00_Addr);
 
        PROCEDURE
              g01opmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8  (* ptocSynonym const char* *);
                    msg_text  : tsp00_C24 (* ptocSynonym const char* *);
                    msg_value : tsp00_Int4);
 
        PROCEDURE
              g01optextmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8 (* ptocSynonym const char* *);
                    msg_text  : tsp00_C40(* ptocSynonym const char* *));
              (* PTS 1107617 E.Z. *)
 
        PROCEDURE
              g01unioptextmsg (
                    msg_enc   : tsp00_Int4;
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8 (* ptocSynonym const char* *);
                    msg_text  : tsp00_C80(* ptocSynonym const char* *));
              (* ptocExport hgg01_2.h *)
 
        PROCEDURE
              g01event_init (VAR new_event : tsp31_event_description);
              (*ptocExport hgg01_3.h*)
 
        FUNCTION
              g01SystemTriggersEnabled : boolean;
 
        FUNCTION
              g01UseSelectFetch : boolean;
 
        FUNCTION
              g01UseVariableInput : boolean;
 
        VAR
              g01code                      : tgg04_CodeGlobals;
              g01controluser               : tgg04_ControlUser;
              g01ConsistentReadEnabled     : boolean;
              g01default_lru               : boolean;
              g01glob                      : tgg00_KernelGlobals;
              g01hashprime                 : tgg00_HashPrimeList;
              g01log_backup_to_pipe        : boolean; (* PTS 1108438 UH 2000-11-22 *)
              g01autosave_distance         : tsp00_Int4;
              g01nil_long_qual             : tgg00_LongQual;
              g01nil_sel                   : tgg00_SfpInitPart;
              g01nil_stack_desc            : tgg00_StackDesc;
              g01nls_sort                  : boolean;
              g01nls_default_map           : tsp00_KnlIdentifier;
              g01serverdb_ident            : tgg04_ServerdbIdent;
              g01sysaccount                : boolean;
              g01diag_moni_parse_on        : boolean;
              g01tabid                     : tgg04_TabIdGlobals;
              g01timeout                   : tgg00_TimeoutGlobals;
              g01unicode                   : boolean; (* PTS 1114297 E.Z. *)
              g01vtrace                    : tgg00_VtraceState;
              g01updstatalgo               : tsp00_Int4;
 
              gg01_no_of_backup_devs       : tsp00_Int4;
              gg01_maxcpu                  : tsp00_Int4;
              gg01_usedmaxlogqueuecount    : tsp00_Int4; (* PTS 1135304 mb 2005-05-19 *)
              gg01_logqueuecount           : tsp00_Int4; (* PTS 1135304 mb 2005-05-19 *)
              gg01_maxlocks                : tsp00_Int4;
              gg01_maxtrans                : tsp00_Int4;
              gg01_maxuser                 : tsp00_Int4;
              gg01_maxuserstack            : tsp00_Int4;
              gg01_ccp_catalog_cache_pages : tsp00_Int4;
              gg01_sequence_cache_pages    : tsp00_Int4;
              gg01_join_prefetch_percent   : tsp00_Int4;
              gg01_max_merge               : tsp00_Int4;
              gg01_trans_regions           : tsp00_Int4;
              gg01_tab_regions             : tsp00_Int4;
              gg01_row_regions             : tsp00_Int4;
              gg01_oms_regions             : tsp00_Int4;
              gg01_data_regions            : tsp00_Int4;
              gg01_backup_block_count      : tsp00_Int4;
              gg01_maxdatawriter           : tsp00_Int4;
              gg01_packet_size             : tsp00_Int4;
              gg01_mb_data_size            : tsp00_Int4;
              gg01_mb_qual_size            : tsp00_Int4;
              gg01_mb_strat_size           : tsp00_Int4;
              gg01_mb_stack_size           : tsp00_Int4;
              gg01_kb_work_st_size         : tsp00_Int4;
              gg01_kb_workbuf_size         : tsp00_Int4;
              gg01_ccs_catalog_cache_size  : tsp00_Int4;
              gg01_lock_supply_block       : tsp00_Int4;
              gg01_deadlock_detection      : tsp00_Int4;
              gg01_dw_io_area_size         : tsp00_Int4;
              gg01_dw_io_area_flush        : tsp00_Int4;
              gg01_dw_lru_tail_flush       : tsp00_Int4;
              gg01_delay_lw                : tsp00_Int4;
              gg01_optim_cache             : boolean;
              gg01_optim_inv_only          : boolean;
              gg01_operator_join           : boolean;
              gg01_operator_join_costfunc  : boolean;
              gg01_hashed_resultset        : boolean;
              gg01_clustered_lobs          : boolean;
              gg01_maxgarbage_collector    : tsp00_Int4;
              gg01_readahead_blobs_gt      : tsp00_Int4;
              gg01_join_search_level       : tsp00_Int4;
              gg01_join_maxtab_level4      : tsp00_Int2;
              gg01_join_maxtab_level9      : tsp00_Int2;
              gg01_oms_heap_limit          : tsp00_Int4;
              gg01_converter_regions       : tsp00_Int4;
              gg01_max_ukt                 : tsp00_Int4;
              gg01_oms_heap_usage_threshold: tsp00_Int4;
              gg01_oms_vers_free_threshold : tsp00_Int4;
              gg01_oms_heap_count          : tsp00_Int4;
              gg01_oms_heap_blocksize      : tsp00_Int4;
              gg01_oms_stream_timeout      : tsp00_Int4;
              gg01_join_tablebuffer        : tsp00_Int4; (* PTS 1120718 *)
              g01restart_time              : tsp00_Int4;
              gg01_max_retention_time      : tsp00_Int4; (* PTS 1130973 *)
              gg01_min_retention_time      : tsp00_Int4; (* PTS 1130973 *)
              gg01_operator_join_sort      : boolean;
              gg01_trans_threshold_value   : tsp00_Int4; (* PTS 1130965 *)
              gg01_trans_history_size      : tsp00_Int4; (* PTS 1130965 *)
              gg01_enable_system_triggers  : boolean;    (* PTS 1131744 *)
              gg01_useselectfetch          : boolean;    (* PTS 1132398 *)
              gg01_usevariableinput        : boolean;    (* PTS 1130828 *)
              gg01_columncompression       : boolean;    (* PTS 1132544 *)
              gg01_checktablewidth         : boolean;    (* PTS 1132544 *)
              gg01_kb_stack_measurement    : boolean;
 
              gg01_diag_reverse_fetch      : boolean;
              gg01_trigger                 : boolean;
              gg01_one_join_phase          : boolean;
              gg01_aggr_optim              : boolean;
              gg01_diag_minmax_optim       : boolean;
              gg01_outer_join_ordered      : boolean;
              gg01_use_join_hashtable      : boolean;
              gg01_sm_reads                : tsp00_Int4;
              gg01_sm_milliseconds         : tsp00_Int4;
              gg01_sm_selectivity          : tsp00_Int4;
              gg01_join_hash_min_ratio     : tsp00_Int4;
              gg01_join_parall_minsize     : tsp00_Int4;
              gg01optimize_parallel_server : tsp00_Int4;
              gg01DataCacheMemoryProtection: boolean;
              gg01_optim_first_rows        : boolean;
              gg01_qual_on_index           : boolean;
 
.CM *-END-* define --------------------------------------
***********************************************************
 
Use     :
 
        FROM
              filesysteminterface_1 :  VBD01;
 
        VAR
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (
                    VAR t        : tgg00_TransContext;
                    trace_layer  : tgg00_Debug;
                    trace_object : tgg00_VtraceType;
                    body_len     : tsp00_Int2;
                    trace_body   : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              GG_param_functions : VGG011;
 
        PROCEDURE
              g011register_update_functions;
 
        PROCEDURE
              g011get_conf_param (
                    VAR b_err : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06CalculateRowIdHashPrimNumbers;
 
        FUNCTION
              gg06Align (
                    length    : tsp00_Int4;
                    alignment : tsp00_Int4) : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17addr_to_line (
                    any_addr   : tsp00_Addr;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_C40);
 
        PROCEDURE
              g17int4to_line (
                    int       : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_C40);
 
        PROCEDURE
              g17nameto_line (
                    n           : tsp00_Name;
                    VAR ln_len  : integer;
                    VAR ln      : tsp00_C40);
 
        PROCEDURE
              g17sname_to_line (
                    n             : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (
                    int        : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        PROCEDURE
              gg999Abort (writeCore : boolean);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vclock (
                    VAR sec      : tsp00_Int4;
                    VAR microsec : tsp00_Int4);
 
        PROCEDURE
              vconf_param_get_string    (
                    VAR conf_param_name   : tsp11_ConfParamName;
                    VAR conf_param_value  : tsp11_ConfParamValue;
                    VAR conf_param_length : tsp00_Int4;
                    VAR update_online     : boolean;
                    VAR permanent_change  : boolean;
                    VAR errtext           : tsp00_ErrText;
                    VAR conf_param_ret    : tsp11_ConfParamReturnValue);
 
        PROCEDURE
              vconf_param_put (VAR conf_param_name : tsp11_ConfParamName;
                    VAR conf_param_value  : tsp11_ConfParamValue;
                    is_numeric            : boolean;
                    permanent_change      : boolean;
                    VAR conf_param_ret    : tsp11_ConfParamReturnValue);
 
        PROCEDURE
              vfwrite (
                    hostfileno        : tsp00_Int4;
                    buf               : tsp_vf_bufaddr;
                    VAR error         : tsp00_VfReturn;
                    VAR errtext       : tsp00_ErrText);
 
        PROCEDURE
              vgetpid (VAR pid : tsp00_TaskId);
 
        FUNCTION
              vGetAvailableKBDynPool : tsp00_Int4 ;  (* PTS 1106794 *)
 
        PROCEDURE
              vmessage (
                    prio         : tsp3_priority;
                    msg_type     : tsp3_msg_type;
                    msg_no       : tsp00_Int4;
                    msg_label    : tsp00_C8;
                    VAR msg_line : tsp00_C40);
              (* PTS 1107617 E.Z. *)
 
        PROCEDURE
              vmessageUnicode(
                    source_encoding : tsp00_Int4;
                    prio         : tsp3_priority;
                    msg_type     : tsp3_msg_type;
                    msg_no       : tsp00_Int4;
                    msg_label    : tsp00_C8;
                    VAR msg_line : tsp00_C80);
 
        PROCEDURE
              vsleft (VAR freestacksize : tsp00_Int4);
 
        PROCEDURE
              vtracewriter_alive;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    obj_upb  : tsp00_Int4;
                    obj      : tsp00_MoveObjPtr;
                    obj_pos  : tsp00_Int4;
                    length   : tsp00_Int4;
                    fillchar : char;
                    VAR e    : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedMove (
                    source_upb  : tsp00_Int4;
                    destin_upb  : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    source_pos  : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    destin_pos  : tsp00_Int4;
                    length      : tsp00_Int4);
 
        PROCEDURE
              SAPDB_PascalOverlappingMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR e       : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalForcedFill (
                    size        : tsp00_Int4;
                    m           : tsp00_MoveObjPtr;
                    pos         : tsp00_Int4;
                    len         : tsp00_Int4;
                    fillchar    : char);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf (
                    int      : tsp00_Int4;
                    VAR dest : tsp00_Line;
                    pos      : tsp00_Int4);
              (* PTS 1107617 E.Z. *)
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        FUNCTION
              s30unilnr (
                    str       : tsp00_MoveObjPtr;
                    skip_val  : tsp00_C2;
                    start_pos : tsp00_Int4;
                    length    : tsp00_Int4) : tsp00_Int4;
 
.CM *-END-* use -----------------------------------------
***********************************************************
 
Synonym :
 
        PROCEDURE
              b120InsertTrace;
 
              tgg11_VtraceBodyPtr tsp00_Addr
 
        PROCEDURE
              g17addr_to_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              g17int4to_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              g17nameto_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              g17trimint4_to_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              s20int4_to_buf;
 
              tsp00_MoveObj tsp00_Name
              tsp00_MoveObj tsp00_Line
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : ElkeZ
.sp
.cp 3
Created : 1987-09-22
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-11-23
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 2;.cp 4
Procedure G01DUMP
.sp
This procedure writes the following G01 variables
to the specified host file.
.sp 2;.cp 4
Procedure G01LOG_ISAM_GLOB_PARAM_INIT
.sp
Reading Parameters from CONFIG-page.
.sp 2;.cp 4
Procedure G01GLOB_PARAM_INIT
.sp
Reading Parameters from CONFIG-table. Called during restart after
filesystem has been restarted and the config-table is accessible.
.sp 2;.cp 4
Procedure G01DEFAULT_CONFIGURATION
.sp
Reading Parameters from XPARAM-container to XPARAM-structure
Called within startup of timeout-process (VAK91).
 
.CM *-END-* specification -------------------------------
***********************************************************
.CM -lll-
Code    :
 
 
CONST
      (*
      cgg01_param_ascii       = 'ASCII             ';
      cgg01_param_europe_date = 'EUR               ';
      cgg01_param_internal    = 'INTERNAL          ';
      cgg01_param_iso_date    = 'ISO               ';
      cgg01_param_jis_date    = 'JIS               ';
      cgg01_param_unicode     = 'UNICODE           ';
      cgg01_param_usa_date    = 'USA               ';
      *)
      (**)
      cgg01_with_zero         = true;
      cgg01_write_core        = true;
      cgg01_refresh_call      = true; (* gg01get_conf_param*)
      (**)
&     ifdef bit64
      (* PTS 1124997 E.Z. *)
&     if $OSSPEC in [ LINUX ]
      cgg01_userstack_reserve = 20000;
&     else
&     if $MACH in [ SUN ]
      cgg01_userstack_reserve =  17000;
&     else
      cgg01_userstack_reserve =  6000;
&     endif
&     endif
&     else
&     if $MACH in [ NMP ]
      cgg01_userstack_reserve = 10000;
&     else
      cgg01_userstack_reserve =  5000;
&     endif
&     endif
 
TYPE
      PageHeaderPtr_t    = ^tgg00_PageHeader;
      tgg01_ConfParamNameAddr = ^tsp11_ConfParamName;
 
 
(*------------------------------*) 
 
PROCEDURE
      g01abort (
            msg_no     : tsp00_Int4;
            msg_label  : tsp00_C8;
            msg_text   : tsp00_C24;
            bad_value  : tsp00_Int4);
 
VAR
      len   : integer;
      opmsg : tsp00_C40;
 
BEGIN
opmsg := bsp_c40;
len   := sizeof (msg_text);
WHILE (msg_text [len] = ' ') AND (len > 1) DO
    len := len - 1;
(*ENDWHILE*) 
SAPDB_PascalForcedMove (sizeof (msg_text), sizeof (opmsg), @msg_text, 1,
      @opmsg, 1, len);
opmsg [len+1] := ';';
len           := len + 2;
g17trimint4_to_line (bad_value, len, opmsg);
vmessage (sp3p_console, sp3m_error, msg_no, msg_label, opmsg);
gg01vtrace_write (sp3m_error, msg_label, opmsg, len);
gg999Abort(cgg01_write_core)
END;
 
(*------------------------------*) 
 
FUNCTION
      g01align (val : tsp00_Int4): tsp00_Int4;
 
CONST
      ALIGN = 16; (* PTS 1106809 jrg 2000-30-05 *)
 
BEGIN
g01align := gg06Align( val, ALIGN);
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01allocate_msg (
            msg_label  : tsp00_C8;
            msg_text   : tsp00_C24;
            alloc_size : tsp00_Int4);
 
VAR
      len   : integer;
      opmsg : tsp00_C40;
      avail : tsp00_Int4;
 
BEGIN
opmsg  := bsp_c40;
len := sizeof (msg_text);
WHILE (msg_text [len] = ' ') AND (len > 1) DO
    len := len - 1;
(*ENDWHILE*) 
SAPDB_PascalForcedMove (sizeof (msg_text), sizeof (opmsg), @msg_text, 1,
      @opmsg, 1, len);
len := len + 1;
IF  alloc_size < 10000000
THEN
    g17int4to_line (alloc_size, NOT cgg01_with_zero, 7, len, opmsg)
ELSE
    g17trimint4_to_line (alloc_size, len, opmsg);
(*ENDIF*) 
vmessage (sp3p_knldiag, sp3m_info, csp3_allocat, msg_label, opmsg);
&ifdef TRACE
(* PTS 1106497 E.Z. *)
IF  (msg_label = csp3_n_dynpool) AND
    (msg_text[1] = 'D')          AND
    (msg_text[2] = 'Y')          AND
    (msg_text[3] = 'N')          AND
    (msg_text[4] = 'P')
THEN
    BEGIN
    opmsg := '  DYNP AVAIL:                           ';
    len := 13;
    avail := vGetAvailableKBDynPool;
    g17int4to_line (avail, NOT cgg01_with_zero, 10, len, opmsg);
    len := len + 11;
    g17int4to_line (alloc_size DIV 1024, NOT cgg01_with_zero, 7, len, opmsg);
    vmessage (sp3p_knldiag, sp3m_info, csp3_allocat, msg_label, opmsg);
    END;
&endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01backup_block_count : tsp00_Int4;
 
BEGIN
g01backup_block_count := gg01_backup_block_count
END;
 
(*------------------------------*) 
 
FUNCTION
      g01auto_recreate_bad_indexes : boolean;
 
VAR
      e          : tgg00_BasisError;
      doRecreate : boolean;
 
BEGIN
e := e_ok;
gg01bool_conf_param_get (@csp11_AUTO_RECREATE_BAD_INDEXES,
      doRecreate, NOT cgg01_refresh_call, e);
IF  e <> e_ok
THEN
    doRecreate := false;
(*ENDIF*) 
g01auto_recreate_bad_indexes := doRecreate;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01cache_size (cache_type : tgg04_CacheType) : tsp00_Int4;
 
VAR
      cache_size : tsp00_Int4;
 
BEGIN
CASE cache_type OF
    cachCatalog_egg04:
        cache_size := gg01_ccp_catalog_cache_pages;
    cachSequence_egg04:
        cache_size := gg01_sequence_cache_pages;
    OTHERWISE
        cache_size := 0
    END;
(*ENDCASE*) 
g01cache_size := cache_size
END;
 
(*------------------------------*) 
 
FUNCTION
      g01catalog_cache_init_size : tsp00_Int4;
 
BEGIN
g01catalog_cache_init_size := gg01_ccs_catalog_cache_size
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01check (
            msg_no     : tsp00_Int4;
            msg_label  : tsp00_C8;
            msg_text   : tsp00_C24;
            bad_value  : tsp00_Int4;
            constraint : boolean);
 
BEGIN
IF  NOT constraint AND g01vtrace.vtrCheck_gg00
THEN
    g01abort (msg_no, msg_label, msg_text, bad_value)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01check_mxgg (VAR ok : boolean);
 
VAR
      mb_part1_lockhead_mx : integer;
      mb_part1head_mx      : integer;
      mb_part1_return_mx   : integer;
      number_mx            : integer;
      rec_key_offset_c     : integer;
      return_stack_entries : integer;
      sfp_init_part_mx     : integer;
      strategystart_mx     : integer;
      tempprefix_mx        : integer;
      treeidhead_mx        : integer;
      treepos_mx           : integer;
      recpart_mx           : integer;
      (* *)
      sel                  : tgg00_SelectFieldsParam;
      strategy_info        : tgg07_StrategyInfo;
      InvInRange_strat     : tgg07_StrInvInRange;
      tree_id              : tgg00_FileId;
      tree_pos             : tgg00_FilePos;
      qual                 : tgg00_QualBuf;
      rec_buf              : tgg00_Rec;
 
BEGIN
(*-----  CGG_REC_KEY_OFFSET  -----*)
rec_key_offset_c := sizeof (rec_buf.recLen_gg00)
      +             sizeof (rec_buf.recKeyLen_gg00)
      +             sizeof (rec_buf.recVarcolOffset_gg00)
      +             sizeof (rec_buf.recVarcolCnt_gg00);
IF  cgg_rec_key_offset <> rec_key_offset_c
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('cgg_rec_key_offset', cgg_rec_key_offset, rec_key_offset_c)
    END;
(*ENDIF*) 
IF  cgg_rec_key_offset <> sizeof (tgg00_HeaderRec)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('cgg_rec_key_offset', cgg_rec_key_offset, sizeof (tgg00_HeaderRec))
    END;
(*ENDIF*) 
;
(*-----  CGG_RETURN_STACK_ENTRIES  -----*)
WITH qual DO
    BEGIN
    return_stack_entries := sizeof (mr_resnum)
          +                 sizeof (mr_res_build)
          +                 sizeof (mr_restree)
          +                 sizeof (mr_keycnt)
          +                 sizeof (mr_fill3)
          +                 sizeof (mr_pagecnt)
          +                 sizeof (mr_first_serial)
          +                 sizeof (mr_last_serial);
    END;
(*ENDWITH*) 
return_stack_entries := (return_stack_entries  - 1)
      DIV sizeof (tgg00_StackEntry) + 1;
IF  cgg04_return_stack_entries <> return_stack_entries
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('cgg_return_stack_e', cgg04_return_stack_entries, return_stack_entries)
    END;
(*ENDIF*) 
;
(*-----  MXGG_BUF_4  -----*)
(* PTS 1116801 E.Z. *)
&ifdef vers80
IF  RECBODY_MXGG00 <> MAX_RECLEN_GG00 - cgg_rec_key_offset
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('RECBODY_MXGG00    ', RECBODY_MXGG00,
          MAX_RECLEN_GG00 - cgg_rec_key_offset)
    END;
(*ENDIF*) 
;
&else
IF  RECBODY_MXGG00 <> sizeof (tsp00_Buf) - cgg_rec_key_offset
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('RECBODY_MXGG00    ', RECBODY_MXGG00,
          sizeof (tsp00_Buf) - cgg_rec_key_offset)
    END;
(*ENDIF*) 
;
&endif
(*-----  MXGG_DOUBLE_BUF  -----*)
IF  DOUBLE_BUF_MXGG00 <> 2 * sizeof (tsp00_Buf)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('DOUBLE_BUF_MXGG00 ', DOUBLE_BUF_MXGG00, 2 * sizeof (tsp00_Buf))
    END;
(*ENDIF*) 
;
(*-----  MXGG_FN  -----*)
IF  FN_MXGG00 <> sizeof (tgg00_Filename)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('FN_MXGG00         ', FN_MXGG00, sizeof (tgg00_Filename))
    END;
(*ENDIF*) 
;
(*-----  MXGG_LOCK  -----*)
IF  LOCK_MXGG04 <> sizeof (tgg00_Lock)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('LOCK_MXGG04       ', LOCK_MXGG04, sizeof (tgg00_Lock))
    END;
(*ENDIF*) 
;
(*-----  MXGG_PART1HEAD  -----*)
WITH qual DO
    mb_part1head_mx := sizeof (mtree) + sizeof (mstack_desc);
(*ENDWITH*) 
IF  MB_PART1_HEAD_MXGG00 <> mb_part1head_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('MB_PART1_HEAD_MXGG', MB_PART1_HEAD_MXGG00, mb_part1head_mx)
    END;
(*ENDIF*) 
;
(*-----  MXGG_MB_PART1_LOCKHEAD  -----*)
mb_part1_lockhead_mx := sizeof (qual.mlock_cnt)
      +                 sizeof (qual.mlock_fill1);
IF  MB_PART1_LOCKHEAD_MXGG04 <> mb_part1_lockhead_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('mxgg_mb_part1_lock', MB_PART1_LOCKHEAD_MXGG04,
          mb_part1_lockhead_mx)
    END;
(*ENDIF*) 
;
(*-----  MXGG_MB_PART1_RETURN  -----*)
WITH qual DO
    mb_part1_return_mx := sizeof (mr_resnum)
          +               sizeof (mr_res_build)
          +               sizeof (mr_restree)
          +               sizeof (mr_keycnt)
          +               sizeof (mr_fill3)
          +               sizeof (mr_pagecnt)
          +               sizeof (mr_first_serial)
          +               sizeof (mr_last_serial);
(*ENDWITH*) 
IF  MB_PART1_RETURN_MXGG00 <> mb_part1_return_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('mxgg_mb_part1_retu', MB_PART1_RETURN_MXGG00,
          mb_part1_return_mx)
    END;
(*ENDIF*) 
;
(*-----  MXGG_NUMBER  -----*)
number_mx := (csp_fixed + 1) DIV 2 + 2;
IF  NUMBER_MXGG04 <> number_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('NUMBER_MXGG04     ', NUMBER_MXGG04, number_mx)
    END;
(*ENDIF*) 
;
(*+++++ MAX_RECLEN_GG00 +++++*)
;
(*-----  MXGG_RECPART / CGG_MAXRECPARTS  -----*)
&ifdef vers80
&ifdef rec32KB
recpart_mx := sizeof (tsp00_Buf) DIV (1 + MAX_RECPARTS_GG00);
IF  RECPART_MXGG00 = recpart_mx
THEN
    recpart_mx := sizeof (tsp00_Buf) DIV 256;
&else
(*ENDIF*) 
recpart_mx := 8192 DIV (1 + MAX_RECPARTS_GG00);
IF  RECPART_MXGG00 = recpart_mx
THEN
    recpart_mx := 8192 DIV 256;
&endif
&else
(*ENDIF*) 
recpart_mx := sizeof (tsp00_Buf) DIV (1 + MAX_RECPARTS_GG00);
IF  RECPART_MXGG00 = recpart_mx
THEN
    recpart_mx := sizeof (tsp00_Buf) DIV 256;
&endif
(*ENDIF*) 
IF  RECPART_MXGG00 <> recpart_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('mxgg_recpart      ', SITE_MXGG04, recpart_mx)
    END;
(*ENDIF*) 
;
(*-----  MXGG_SFP_INIT_PART1  -----*)
sfp_init_part_mx := sizeof (sel)
      -             sizeof (sel.sfp_work_st_top)
      -             sizeof (sel.sfp_work_st_bottom)
      -             sizeof (sel.sfp_work_st_last)
      -             sizeof (sel.sfp_work_st_frame)
      -             sizeof (sel.sfp_workbuf_top)
      -             sizeof (sel.sfp_check_new_rec)
      -             sizeof (sel.sfp_optimized)
      -             sizeof (sel.sfp_dateTimeFormat)
      -             sizeof (sel.sfp_sqlmode)
      -             sizeof (sel.sfp_acv_addr)
      -             sizeof (sel.sfp_param_buf_addr)
      -             sizeof (sel.sfp_cluster_info);
IF  SFP_INIT_PART_MXGG00 <> sfp_init_part_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('SFP_INIT_PART_MXG.', SFP_INIT_PART_MXGG00,
          sfp_init_part_mx)
    END;
(*ENDIF*) 
;
(*-----  MXGG_SITE  -----*)
IF  SITE_MXGG04 <> sizeof (tgg00_ServerdbNo)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('SITE_MXGG04       ', SITE_MXGG04,
          sizeof (tgg00_ServerdbNo))
    END;
(*ENDIF*) 
;
(*-----  MXGG_STACK_ENTRY  -----*)
IF  STACK_ENTRY_MXGG00 <> sizeof (tgg00_StackEntry)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('STACK_ENTRY_MXGG00', STACK_ENTRY_MXGG00,
          sizeof (tgg00_StackEntry))
    END;
(*ENDIF*) 
;
(*-----  STRINVINRANGE_START_MXGG07  -----*)
strategystart_mx :=
      sizeof( InvInRange_strat ) -
      sizeof( InvInRange_strat.siir_keystart ) -
      sizeof( InvInRange_strat.siir_keystop )  -
      sizeof( InvInRange_strat.siir_invstart ) -
      sizeof( InvInRange_strat.siir_invstop );
IF  STRINVINRANGE_START_MXGG07 <> strategystart_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('STRINVINRANGE_STAR', STRINVINRANGE_START_MXGG07,
          strategystart_mx);
    END;
(*ENDIF*) 
;
(*-----  STRATEGY_START_MXGG07  -----*)
WITH strategy_info DO
    strategystart_mx := sizeof (str_result_id         )
          +             sizeof (str_strategy          )
          +             sizeof (str_build_result      )
          +             sizeof (str_distinc           )
          +             sizeof (str_ordering          )
          +             sizeof (str_use_rowno         )
          +             sizeof (str_use_clusterIO     )
          +             sizeof (str_corr_single       )
          +             sizeof (str_union_kind        )
          +             sizeof (str_res_possible      )
          +             sizeof (str_use_order         )
          +             sizeof (str_out_keyseqlen     )
          +             sizeof (str_qual_kind         )
          +             sizeof (str_cnt_strat         )
          +             sizeof (str_rowno             )
          +             sizeof (str_foundresults      )
          +             sizeof (str_key_len           )
          +             sizeof (str_rec_len           )
          +             sizeof (str_union_key_cnt_offs)
          +             sizeof (str_stack_output_offs )
          +             sizeof (str_search_first      )
          +             sizeof (str_all_files         )
          +             sizeof (str_key_order_support )
          +             sizeof (str_selinto           )
          +             sizeof (str_access_mod        )
          +             sizeof (str_filler            );
(*ENDWITH*) 
IF  STRATEGY_START_MXGG07 <> strategystart_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('STRATEGY_START 1  ', STRATEGY_START_MXGG07,
          strategystart_mx)
    END;
(*ENDIF*) 
;
WITH strategy_info DO
    strategystart_mx := sizeof (strategy_info         )
          -             sizeof (str_raw               );
(*ENDWITH*) 
IF  STRATEGY_START_MXGG07 <> strategystart_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('STRATEGY_START 2  ', STRATEGY_START_MXGG07,
          strategystart_mx)
    END;
(*-----  MXGG_STRINGFD  -----*)
(*ENDIF*) 
IF  STRING_FD_MXGG00 <> sizeof (tgg04_StringFileDescr)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('STRING_FD_MXGG00  ', STRING_FD_MXGG00,
          sizeof (tgg04_StringFileDescr))
    END;
(*ENDIF*) 
;
(*-----  MXGG_SURROGATE  -----*)
IF  SURROGATE_MXGG00 <> sizeof (tgg00_Surrogate)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('SURROGATE_MXGG00  ', SURROGATE_MXGG00,
          sizeof (tgg00_Surrogate))
    END;
(*ENDIF*) 
;
(*-----  MXGG_SYSKEY  -----*)
IF  SYSKEY_MXGG00 <> sizeof (tgg00_Syskey)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('SYSKEY_MXGG00     ', SYSKEY_MXGG00, sizeof (tgg00_Syskey))
    END;
(*-----  MXGG_TEMPPREFIX  -----*)
(*ENDIF*) 
;
tempprefix_mx := sizeof (tree_id.fileTfn_gg00     )
      +          sizeof (tree_id.fileTfnNo_gg00   )
      +          sizeof (tree_id.fileZeroSite_gg00)
      +          sizeof (tree_id.fileSession_gg00 );
IF  TEMP_PREFIX_MXGG00 <> tempprefix_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('TEMP_PREFIX_MXGG00', TEMP_PREFIX_MXGG00, tempprefix_mx)
    END;
(*ENDIF*) 
;
(*-----  MXGG_TREEID  -----*)
IF  FILE_ID_MXGG00 <> sizeof (tgg00_FileId)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('FILE_ID_MXGG00    ', FILE_ID_MXGG00, sizeof(tgg00_FileId))
    END;
(*ENDIF*) 
;
(*-----  MXGG_TREEIDHEAD / CGG_TREEID_FN_OFFSET  -----*)
WITH tree_id DO
    treeidhead_mx := sizeof (fileRootCheck_gg00)
          +          sizeof (fileLeafNodes_gg00)
          +          sizeof (fileUserRef_gg00  )
          +          sizeof (fileVersion_gg00  )
          +          sizeof (fileRoot_gg00     )
          +          sizeof (fileHandling_gg00 )
          +          sizeof (fileBdUse_gg00    )
          +          sizeof (fileType_gg00     );
(*ENDWITH*) 
IF  FILE_ID_HEAD_MXGG00 <> treeidhead_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('FILE_ID_HEAD_MXGG.', FILE_ID_HEAD_MXGG00, treeidhead_mx)
    END;
(*ENDIF*) 
IF  cgg_treeid_fn_offset <> treeidhead_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('cgg_treeid_fn_offs', cgg_treeid_fn_offset, treeidhead_mx)
    END;
(*ENDIF*) 
;
(*-----  MXGG_TREEPOS  -----*)
treepos_mx := sizeof (tree_pos);
IF  FILE_POS_MXGG00 <> treepos_mx
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('FILE_POS_MXGG00   ', FILE_POS_MXGG00, treepos_mx)
    END;
(*ENDIF*) 
;
(*-----  MXGG_USERID  -----*)
IF  USERID_MXGG04 <> sizeof (tgg00_UserId)
THEN
    BEGIN
    ok := false;
    g01mxerrmsg ('USERID_MXGG04     ', USERID_MXGG04, sizeof (tgg00_UserId))
    END;
(*ENDIF*) 
;
(*--- check max size of one strategy ---*)
IF  255 < sizeof( tgg07_StrRaw )
THEN
    (* for OR-strategies we code length of tgg07_<strategy> in one byte *)
    BEGIN
    ok := false;
    g01mxerrmsg ('SIZE(TGG07_STRRAW)', MAX_UINT1_SP00, sizeof (tgg07_StrRaw))
    END;
(*ENDIF*) 
;
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01datapart_init (
            VAR mblock    : tgg00_MessBlock;
            datapart_ptr  : tgg00_DataPartPtr;
            datapart_size : tsp00_Int4);
 
BEGIN
IF  datapart_ptr <> NIL
THEN
    BEGIN
    datapart_ptr^.mbp_reclen        := 0;
    datapart_ptr^.mbp_keylen        := 0;
    datapart_ptr^.mbp_varcol_offset := 0;
    datapart_ptr^.mbp_varcol_cnt    := 0;
    END;
(*ENDIF*) 
mblock.mb_data_len  := 0;
mblock.mb_data      := datapart_ptr;
mblock.mb_data_size := datapart_size;
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01stratpart_init (
            VAR mblock     : tgg00_MessBlock;
            stratpart_ptr  : tsp00_MoveObjPtr;
            stratpart_size : tsp00_Int4);
 
BEGIN
mblock.mb_strat_len  := 0;
mblock.mb_strat      := stratpart_ptr;
mblock.mb_strat_size := stratpart_size;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01deadlock_detection : tsp00_Int4;
 
BEGIN
g01deadlock_detection := gg01_deadlock_detection
END;
 
(* PTS 1113051 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      g01default_configuration;
 
CONST
      c_is_perm         = true;
      c_is_numeric      = true;
 
VAR
      conf_param_name   : tsp11_ConfParamName;
      conf_param_value  : tsp11_ConfParamValue;
      conf_param_ret    : tsp11_ConfParamReturnValue;
      i                 : tsp00_Int4;
      curr_prime        : tsp00_Int4;
      sel               : tgg00_SelectFieldsParam;
      b_err             : tgg00_BasisError;
 
BEGIN
g01nls_sort           := false;
FOR i := 1 TO sizeof (g01nls_default_map) DO
    g01nls_default_map[i] := bsp_c1;
(*ENDFOR*) 
g01sysaccount         := false;
g01diag_moni_parse_on := false;
g01updstatalgo        := 0;
g01ConsistentReadEnabled := false;
(* CR 1000201 E.Z. *)
WITH g01glob DO
    BEGIN
    datacachecheck   := false;
    rescnt_unknown   := csp_rescnt_unknown;
    rescnt_0         := csp_rescnt_zero;
    rescnt_1         := csp_rescnt_one;
    db_is_for_sapr3  := false;
    sysmsg_may_exist := false;
    FOR i := 1 TO sizeof (sysuser_name) DO
        sysuser_name[i] := bsp_c1;
    (*ENDFOR*) 
    sysuser_id            := cgg_zero_id;
    timezone              := 0;
    treecheck             := false;
    bd_lock_check         := false;
    bd_subtree            := false;
    kglInstanceType_gg00  := itUNKNOWN_egg00;
    undef_buf [ 1 ]       := csp_undef_byte;
    undef_addr            := @undef_buf;
    END;
(*ENDWITH*) 
g01vtr_init;
g01restart_time:=0;
g011register_update_functions;
g011get_conf_param (b_err);
(*============================================*)
SAPDB_PascalForcedFill (sizeof(conf_param_value), @conf_param_value, 1,
      sizeof(conf_param_value), csp_ascii_blank);
conf_param_value[1] := 'Y';
conf_param_value[2] := 'E';
conf_param_value[3] := 'S';
&ifdef TRACE
conf_param_name := 'TRACE_DEFAULT                   ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'CHECK_REGIONS                   ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'TRACE_OBJECT_ADD                ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'TRACE_OBJECT_GET                ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'TRACE_OBJECT_ALTER              ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'TRACE_OBJECT_FREE               ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'CHECK_TREE                      ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'CHECK_BACKUP                    ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'CHECK_KB_REGIONS                ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'CHECK_LOCK                      ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'CHECK_LOCK_SUPPLY               ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'CHECK_TRANSLIST                 ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
conf_param_name := 'CHECK_TASK_SPECIFIC_CATALOGCACHE';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
&endif
&if $KIND = SLOW or $KIND = QUICK
conf_param_name := 'CHECK_TREE_LOCKS                ';
vconf_param_put (conf_param_name, conf_param_value, NOT c_is_numeric, NOT c_is_perm,
      conf_param_ret);
&endif
WITH sel DO
    BEGIN
    sfp_data_addr        := NIL;
    sfp_rec_addr         := NIL;
    sfp_primkey_addr     := NIL;
    sfp_work_st_addr     := NIL;
    sfp_workbuf_addr     := NIL;
    sfp_oldrec_addr      := NIL;
    sfp_pl_ptr           := NIL;
    sfp_m_result_addr    := NIL;
    sfp_m_firstkeys_addr := NIL;
    (* *)
    sfp_data_size        := 0;
    sfp_work_st_size     := 0;
    sfp_workbuf_size     := 0;
    sfp_workbuf_len      := 0;
    sfp_act_cntresult    := 0;
    sfp_ExpIdxPages      := 0;
    sfp_rows_qual        := 0;
    sfp_rows_read        := 0;
    sfp_m_result_size    := 0;
    sfp_m_result_len     := 0;
    (* *)
    sfp_m_result_cnt     := 1;
    sfp_rec_len          := 0;
    sfp_rec_key_len      := 0;
    sfp_oldkey_len       := 0;
    sfp_oldrec_len       := 0;
    sfp_oldrec_pos       := 0;
    sfp_result_length    := 0;
    sfp_output_offset    := 0;
    sfp_work_st_max      := 0;
    sfp_resrec_maxlen    := csp_maxint2;
    (* *)
    sfp_bd_mess_type     := m_nil;
    sfp_bd_mess2_type    := mm_nil;
    sfp_filler           := false;
    sfp_check_for_result := false;   (* PTS 1105412 E.Z. *)
    (* *)
    sfp_bd_inv_only      := primary_only;
    sfp_bd_return_knf    := false;
    sfp_bd_use_stopkey   := false;
    sfp_first_qual       := true;
    sfp_filler2          := true;
    sfp_result_wanted    := false;
    sfp_pl_ptr           := NIL;
    (* *)
    sfp_varcol_pos.vpl_last := 0;
    FOR i := 1 TO MAX_COL_PER_TAB_GG00 DO
        sfp_varcol_pos.vpl_pos_list [i] := 0;
    (*ENDFOR*) 
    sfp_first_serial     := csp_null_number;
    sfp_last_serial      := csp_null_number;
    END;
(*ENDWITH*) 
WITH g01nil_long_qual DO
    BEGIN
    lq_lock_tabid      := cgg_zero_id;
    lq_pos             := 0;
    lq_len             := 0;
    lq_long_size       := 0;
    lq_long_in_file    := false;
    lq_code            := csp_ascii;
    lq_expand_char [1] := cgg04_falsechar;
    (* ====> lq_try_unlock := false *)
    lq_trunc_req       := false;
    lq_data_offset     := 0;
    END;
(*ENDWITH*) 
g01nil_sel := sel.sfp_init_part;
WITH g01nil_stack_desc DO
    BEGIN
    mcol_pos         := 0;
    mcol_cnt         := 0;
    mmult_pos        := 0;
    mmult_cnt        := 0;
    mqual_pos        := 0;
    mqual_cnt        := 0;
    mview_pos        := 0;
    mview_cnt        := 0;
    mupd_pos         := 0;
    mupd_cnt         := 0;
    mlink_pos        := 0;
    mlink_cnt        := 0;
    mstrat_pos       := 0;
    mstrat_cnt       := 0;
    mstring_pos      := 0;
    mstring_cnt      := 0;
    mtrigger_pos     := 0;
    mtrigger_cnt     := 0;
    minvqual_pos     := 0;
    minvqual_cnt     := 0;
    mresqual_pos     := 0;
    mresqual_cnt     := 0;
    mspecial         := 0;
    mstack_state     := [];
    mbool            := false;
    mcachetrigger    := 0;
    mfirst_free      := 1;
    mst_optimize_pos := 0;
    mst_work_depth   := 0;
    mst_max          := 0;
    mst_addr         := NIL
    END;
(*ENDWITH*) 
gg06CalculateRowIdHashPrimNumbers; (* PTS 1120350 UH 2003-01-21 *)
curr_prime := 255; (* max value of any byte *)
FOR i := 1 TO MAX_HASH_PRIME_GG00 DO
    BEGIN
    g01next_prim_number (curr_prime);
    g01hashprime [i] := curr_prime
    END;
(*ENDFOR*) 
(* *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01dump (
            VAR hostfile    : tgg00_VfFileref;
            VAR buf         : tsp00_Page;
            VAR out_pno     : tsp00_Int4;
            VAR out_pos     : integer;
            VAR host_err    : tsp00_VfReturn;
            VAR errtext     : tsp00_ErrText);
 
CONST
      mark_g01vars  = 'G01VARS ';
      code_g01vars  = 1001;
      mark_g01glob  = 'G01GLOB ';
      code_g01glob  = 1002;
      mark_g01tabid = 'G01TABID';
      code_g01tabid = 1007;
      mark_g01vtrce = 'G01VTRCE';
      code_g01vtrce = 1008;
 
VAR
      i2        : tsp_int_map_c2;
      dump_mark : tsp00_C8;
      buf_ptr   : tsp_vf_bufaddr;
      move_error: tgg00_BasisError;
      site      : tgg00_ServerdbNo;
 
BEGIN
host_err   := vf_ok;
move_error := e_ok;
buf_ptr    := @buf;
(* ------  G 0 1 _ V A R S  ------ *)
g01new_dump_page (hostfile, buf, out_pno, out_pos, host_err, errtext);
IF  host_err = vf_ok
THEN
    BEGIN
    dump_mark := mark_g01vars;
    SAPDB_PascalMove ('VGG01 ',   1,    
          sizeof (dump_mark), sizeof (buf),
          @dump_mark, 1, @buf, out_pos, sizeof (dump_mark), move_error);
    out_pos         := out_pos + sizeof (dump_mark);
    i2.map_int      := code_g01vars;
    buf [out_pos  ] := i2.map_c2 [1];
    buf [out_pos+1] := i2.map_c2 [2];
    out_pos         := out_pos + 2;
    SAPDB_PascalMove ('VGG01 ',   2,    
          sizeof (g01code), sizeof (buf),
          @g01code, 1, @buf, out_pos, sizeof (g01code), move_error);
    out_pos         := out_pos + sizeof (g01code);
    i2.map_int      := 0 (*g01commit_delay*);
    buf [out_pos  ] := i2.map_c2 [1];
    buf [out_pos+1] := i2.map_c2 [2];
    out_pos         := out_pos + 2;
    site            := cgg_zero_c2;
    buf [out_pos  ] := site [1];
    buf [out_pos+1] := site [2];
    out_pos         := out_pos + sizeof (site);
    i2.map_int      := 1 (*g01maxsite*);
    buf [out_pos  ] := i2.map_c2 [1];
    buf [out_pos+1] := i2.map_c2 [2];
    out_pos         := out_pos + 2;
    buf [out_pos  ] := chr (0);
    buf [out_pos+1] := chr (ord (true));
    buf [out_pos+2] := chr (ord (g01sysaccount   ));
    buf [out_pos+3] := chr (ord (g01diag_moni_parse_on ));
    buf [out_pos+4] := chr (ord (true));
    out_pos         := out_pos + 5;
    SAPDB_PascalMove ('VGG01 ',   3,    
          sizeof (g01timeout), sizeof (buf),
          @g01timeout, 1, @buf, out_pos, sizeof (g01timeout), move_error);
    out_pos         := out_pos + sizeof (g01timeout);
    buf [out_pos]   := chr (ord (0));
    out_pos         := out_pos + 1;
    (* ------  G 0 1 G L O B  ------ *)
    IF  out_pos + 9 + sizeof (g01glob) > sizeof (buf)
    THEN
        g01new_dump_page (hostfile, buf, out_pno, out_pos, host_err, errtext)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  host_err = vf_ok
THEN
    BEGIN
    dump_mark := mark_g01glob;
    SAPDB_PascalMove ('VGG01 ',   4,    
          sizeof (dump_mark), sizeof (buf),
          @dump_mark, 1, @buf, out_pos, sizeof (dump_mark), move_error);
    out_pos         := out_pos + sizeof (dump_mark);
    i2.map_int      := code_g01glob;
    buf [out_pos  ] := i2.map_c2 [1];
    buf [out_pos+1] := i2.map_c2 [2];
    out_pos         := out_pos + 2;
    SAPDB_PascalMove ('VGG01 ',   5,    
          sizeof (g01glob), sizeof (buf),
          @g01glob, 1, @buf, out_pos, sizeof (g01glob), move_error);
    out_pos := out_pos + sizeof (g01glob);
    (* ------  G 0 1 T A B I D  ------ *)
    IF  out_pos + 9 + sizeof (g01tabid) > sizeof (buf)
    THEN
        g01new_dump_page (hostfile, buf, out_pno, out_pos, host_err, errtext)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  host_err = vf_ok
THEN
    BEGIN
    dump_mark := mark_g01tabid;
    SAPDB_PascalMove ('VGG01 ',   6,    
          sizeof (dump_mark), sizeof (buf),
          @dump_mark, 1, @buf, out_pos, sizeof (dump_mark), move_error);
    out_pos         := out_pos + sizeof (dump_mark);
    i2.map_int      := code_g01tabid;
    buf [out_pos  ] := i2.map_c2 [1];
    buf [out_pos+1] := i2.map_c2 [2];
    out_pos         := out_pos + 2;
    SAPDB_PascalMove ('VGG01 ',   7,    
          sizeof (g01tabid), sizeof (buf),
          @g01tabid, 1, @buf, out_pos, sizeof (g01tabid), move_error);
    out_pos := out_pos + sizeof (g01tabid);
    (* ------  G 0 1 V T R C E  ------ *)
    IF  out_pos + 9 + sizeof (g01vtrace) > sizeof (buf)
    THEN
        g01new_dump_page (hostfile, buf, out_pno, out_pos, host_err, errtext)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  host_err = vf_ok
THEN
    BEGIN
    dump_mark := mark_g01vtrce;
    SAPDB_PascalMove ('VGG01 ',   8,    
          sizeof (dump_mark), sizeof (buf),
          @dump_mark, 1, @buf, out_pos, sizeof (dump_mark), move_error);
    out_pos         := out_pos + sizeof (dump_mark);
    i2.map_int      := code_g01vtrce;
    buf [out_pos  ] := i2.map_c2 [1];
    buf [out_pos+1] := i2.map_c2 [2];
    out_pos         := out_pos + 2;
    SAPDB_PascalMove ('VGG01 ',   9,    
          sizeof (g01vtrace), sizeof (buf),
          @g01vtrace, 1, @buf, out_pos, sizeof (g01vtrace), move_error);
    out_pos := out_pos + sizeof (g01vtrace);
    (* ------  G 0 1 X P A R M  ------ *)
    (* here was dumping of the old newxparam-structure *)
    END;
(*ENDIF*) 
IF  (out_pos <> 1) AND (host_err = vf_ok)
THEN
    g01new_dump_page (hostfile, buf, out_pno, out_pos, host_err, errtext)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01dw_io_area_flush : tsp00_Int4;
 
BEGIN
g01dw_io_area_flush := gg01_dw_io_area_flush
END;
 
(*------------------------------*) 
 
FUNCTION
      g01dw_io_area_size : tsp00_Int4;
 
BEGIN
g01dw_io_area_size := gg01_dw_io_area_size
END;
 
(*------------------------------*) 
 
FUNCTION
      g01dw_lru_tail_flush : tsp00_Int4;
 
BEGIN
g01dw_lru_tail_flush := gg01_dw_lru_tail_flush
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01event_init (VAR new_event : tsp31_event_description);
 
BEGIN
WITH new_event DO
    BEGIN
    sp31ed_date     := bsp_date;
    sp31ed_time     := bsp_time;
    sp31ed_value_1  := MAX_INT4_SP00;
    sp31ed_value_2  := MAX_INT4_SP00;
    sp31ed_eventcnt := 0;
    sp31ed_ident    := sp31ei_nil;
    sp31ed_priority := sp31ep_nil;
    sp31ed_text_len := 0;
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01SystemTriggersEnabled : boolean;
 
BEGIN
g01SystemTriggersEnabled := gg01_enable_system_triggers;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01UseSelectFetch : boolean;
 
BEGIN
g01UseSelectFetch := gg01_useselectfetch;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01UseVariableInput : boolean;
 
BEGIN
g01UseVariableInput := gg01_usevariableinput;
END;
 
(*------------------------------*) 
 
FUNCTION   (* PTS 1130965 FF *)
      g01trans_history_size : tsp00_Int4;
 
BEGIN
g01trans_history_size := gg01_trans_history_size;
END;
 
(*------------------------------*) 
 
FUNCTION   (* PTS 1130965 FF *)
      g01trans_threshold_value : tsp00_Int4;
 
BEGIN
g01trans_threshold_value := gg01_trans_threshold_value;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01GetSessionAuxCounter (VAR t : tgg00_TransContext) : tsp00_Int4;
 
BEGIN (* h.b. PTS 1107826 *)
WITH t DO
    BEGIN
    trSessionAuxCounter_gg00 := succ(trSessionAuxCounter_gg00);
    g01GetSessionAuxCounter  := trSessionAuxCounter_gg00;
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01join_search_level : tgg00_JoinSearchLevel;
 
BEGIN
CASE gg01_join_search_level OF
    0:
        g01join_search_level := jsLevel0_egg00;
    1,2,3:
        g01join_search_level := jsLevel1_egg00;
    4,5,6,7,8:
        g01join_search_level := jsLevel4_egg00;
    9:
        g01join_search_level := jsLevel9_egg00;
    END;
(*ENDCASE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01join_maxtab_level4 : tsp00_Int2;
 
BEGIN
g01join_maxtab_level4 := gg01_join_maxtab_level4;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01join_maxtab_level9 : tsp00_Int2;
 
BEGIN
g01join_maxtab_level9 := gg01_join_maxtab_level9;
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01inittabid;
 
BEGIN
WITH g01tabid DO
    BEGIN
    (*  *)
    (* PTS 1104393 E.Z. *)
    sys_data_analyze                := b01niltree_id;
    sys_cmd_analyze                 := b01niltree_id;
    (*  *)
    obj_hash                        := b01niltree_id;
    obj_hash.fileObjKeyFileId_gg00  := cgg_obj_key_file_id;
    obj_hash.fileObjKeyFileIndex_gg00 := 0;
    obj_hash.fileType_gg00          := [ftsPerm_egg00, ftsConcurrent_egg00];
    obj_hash.fileTfn_gg00           := tfnOmsInv_egg00;
    obj_hash.fileTfnNo_gg00         := chr (1);
    (* *)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01int4incr (VAR intvalue : tsp00_C4);
 
VAR
      i : integer;
 
BEGIN
IF  ord(intvalue[ 4 ]) < 255
THEN
    intvalue[ 4 ] := succ ( intvalue[ 4 ] )
ELSE
    BEGIN
    intvalue[ 4 ] := chr (0);
    IF  ord(intvalue[ 3 ]) < 255
    THEN
        intvalue[ 3 ] := succ ( intvalue[ 3 ] )
    ELSE
        BEGIN
        intvalue[ 3 ] := chr (0);
        IF  ord(intvalue[ 2 ]) < 255
        THEN
            intvalue[ 2 ] := succ ( intvalue[ 2 ] )
        ELSE
            BEGIN
            intvalue[ 2 ] := chr (0);
            IF  ord(intvalue[ 1 ]) < 127
            THEN
                intvalue[ 1 ] := succ ( intvalue[ 1 ] )
            ELSE
                (* overflow ==> nil_trans = FFFFFFFF = -1 *)
                FOR i := 1 TO 4 DO
                    intvalue[ i ] := chr(255)
                (*ENDFOR*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01is_archive : boolean;
 
BEGIN
g01is_archive := g01glob.kglInstanceType_gg00 = itARCHIVE_egg00;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01is_livecache : boolean;
 
BEGIN
g01is_livecache := g01glob.kglInstanceType_gg00 = itLVC_egg00;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01join_prefetch_percent : tsp00_Int4;
 
BEGIN
g01join_prefetch_percent := gg01_join_prefetch_percent
END;
 
(*------------------------------*) 
 
FUNCTION
      g01kb_work_st_size : tsp00_Int4;
 
BEGIN
g01kb_work_st_size := gg01_kb_work_st_size
END;
 
(*------------------------------*) 
 
FUNCTION
      g01kb_workbuf_size : tsp00_Int4;
 
BEGIN
g01kb_workbuf_size := gg01_kb_workbuf_size
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01key_assign (
            VAR source_key : tgg00_Lkey;
            VAR target_key : tgg00_Lkey;
            VAR e          : tgg00_BasisError);
 
BEGIN
WITH target_key DO
    BEGIN
    keyLen_gg00 := source_key.keyLen_gg00;
    IF  keyLen_gg00 <> 0
    THEN
        (* (keyLen <= 0) OR (keyLen > sizeof (keyVal))   ==> move error *)
        SAPDB_PascalMove ('VGG01 ',  10,    
              sizeof (source_key.keyVal_gg00), sizeof (keyVal_gg00),
              @source_key.keyVal_gg00, 1, @keyVal_gg00, 1, keyLen_gg00, e)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01key_and_len_assign (
            VAR source_key     : tsp00_Key;
            source_key_len     : tsp00_Int4;
            VAR target_key     : tsp00_Key;
            VAR target_key_len : tsp00_Int2;
            VAR e              : tgg00_BasisError);
 
BEGIN
target_key_len := source_key_len;
IF  target_key_len <> 0
THEN
    (* (keyLen <= 0) OR (keyLen > sizeof (keyVal))   ==> move error *)
    SAPDB_PascalOverlappingMove ('VGG01 ',  11,    
          sizeof (source_key), sizeof (target_key),
          @source_key, 1, @target_key, 1, target_key_len, e)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01lock_supply_block : tsp00_Int4;
 
BEGIN
g01lock_supply_block := gg01_lock_supply_block
END;
 
(*------------------------------*) 
 
FUNCTION
      g01optim_inv_only : boolean;
 
BEGIN
g01optim_inv_only := gg01_optim_inv_only;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01max_merge : tsp00_Int4;
 
BEGIN
g01max_merge := gg01_max_merge;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01maxcpu : tsp00_Int4;
 
BEGIN
g01maxcpu := gg01_maxcpu
END;
 
(*------------------------------*) 
 
FUNCTION
      g01usedmaxlogqueuecount : tsp00_Int4;
      (* PTS 1135304 mb 2005-05-19 *)
 
BEGIN
g01usedmaxlogqueuecount := gg01_usedmaxlogqueuecount;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01logqueuecount : tsp00_Int4;
      (* PTS 1135304 mb 2005-05-19 *)
 
BEGIN
g01logqueuecount := gg01_logqueuecount
END;
 
(*------------------------------*) 
 
FUNCTION
      g01maxdatawriter : tsp00_Int4;
 
BEGIN
g01maxdatawriter := gg01_maxdatawriter
END;
 
(*------------------------------*) 
 
FUNCTION
      g01maxobjgarbagecoll : tsp00_Int4;
 
BEGIN
g01maxobjgarbagecoll := gg01_maxgarbage_collector
END;
 
(*------------------------------*) 
 
FUNCTION
      g01maxlocks : tsp00_Int4;
 
BEGIN
g01maxlocks := gg01_maxlocks
END;
 
(*------------------------------*) 
 
FUNCTION
      g01maxtrans : tsp00_Int4;
 
BEGIN
g01maxtrans := gg01_maxtrans
END;
 
(*------------------------------*) 
 
FUNCTION
      g01maxuser : tsp00_Int4;
 
BEGIN
g01maxuser := gg01_maxuser
END;
 
(*------------------------------*) 
 
FUNCTION
      g01maxuserstack : tsp00_Int4;
 
BEGIN
g01maxuserstack := gg01_maxuserstack
END;
 
(*------------------------------*) 
 
FUNCTION  (* PTS 1130973 FF *)
      g01max_retention_time : tsp00_Int4;
 
BEGIN
g01max_retention_time := gg01_max_retention_time;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01mb_data_size : tsp00_Int4;
 
BEGIN
g01mb_data_size := gg01_mb_data_size
END;
 
(*------------------------------*) 
 
FUNCTION
      g01mb_qual_size : tsp00_Int4;
 
BEGIN
g01mb_qual_size := gg01_mb_qual_size
END;
 
(*------------------------------*) 
 
FUNCTION
      g01mb_stack_size : tsp00_Int4;
 
BEGIN
g01mb_stack_size := gg01_mb_stack_size
END;
 
(*------------------------------*) 
 
FUNCTION
      g01mb_strat_size : tsp00_Int4;
 
BEGIN
g01mb_strat_size := gg01_mb_strat_size
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01mblock_init (
            VAR source_trans : tgg00_TransContext;
            mess_type  : tgg00_MessType;
            mess2_type : tgg00_MessType2;
            VAR mblock : tgg00_MessBlock);
 
VAR
      ix : integer;
 
BEGIN
mblock.mb_qual_len     := 0;
mblock.mb_data_len     := 0;
mblock.mb_strat_len    := 0;
mblock.mb_src_site     := cgg04_nil_site;
mblock.mb_reply        := true;
mblock.mb_fill3        := false;
mblock.mb_type         := mess_type;
mblock.mb_type2        := mess2_type;
mblock.mb_struct       := mbs_nil;
mblock.mb_fill1        := false;
mblock.mb_fill2        := 0;
(* *)
mblock.mb_data         := NIL;
mblock.mb_qual         := NIL;
mblock.mb_st           := NIL;
mblock.mb_work_st      := NIL;
mblock.mb_workbuf      := NIL;
mblock.mb_next_mblock  := NIL;
mblock.mb_trns         := @source_trans;
mblock.mb_strat        := NIL;
FOR ix := 0 TO cgg_idx_max_valuefieldlist DO
    mblock.mb_fieldlists[ix] := NIL;
(*ENDFOR*) 
(* *)
mblock.mb_data_size    := 0;
mblock.mb_qual_size    := 0;
mblock.mb_strat_size   := 0;
mblock.mb_st_size      := 0;
mblock.mb_st_max       := 0;
mblock.mb_work_st_max  := 0;
mblock.mb_workbuf_size := 0;
END;
 
(*------------------------------*) 
 
FUNCTION   (* PTS 1130973 FF *)
      g01min_retention_time : tsp00_Int4;
 
BEGIN
g01min_retention_time := gg01_min_retention_time;
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01mxerrmsg (
            nam        : tsp00_Name;
            int_wrong  : tsp00_Int4;
            int_ok     : tsp00_Int4);
 
VAR
      len   : integer;
      opmsg : tsp00_C40;
 
BEGIN
opmsg := bsp_c40;
len   := 0;
g17nameto_line (nam, len, opmsg);
opmsg [len+2] := '=';
len           := len + 3;
g17trimint4_to_line (int_wrong, len, opmsg);
vmessage (sp3p_console, sp3m_error, csp3_size_check,
      csp3_n_size_check, opmsg);
opmsg := bsp_c40;
len   := 0;
g17nameto_line ('sizeof (...) =    ', len, opmsg);
len := len + 1;
g17trimint4_to_line (int_ok, len, opmsg);
vmessage (sp3p_console, sp3m_error, csp3_size_check,
      csp3_n_size_check, opmsg)
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01new_dump_page (
            VAR hostfile : tgg00_VfFileref;
            VAR buf      : tsp00_Page;
            VAR out_pno  : tsp00_Int4;
            VAR out_pos  : integer;
            VAR host_err : tsp00_VfReturn;
            VAR errtext  : tsp00_ErrText);
 
CONST
      FILL_CODE = 254;
 
VAR
      move_error  : tgg00_BasisError; (* dummy_error *)
      page_header : PageHeaderPtr_t;
 
BEGIN
host_err    := vf_ok;
page_header := @buf;
move_error  := e_ok;
(* *)
vtracewriter_alive;
(* *)
IF  out_pos > sizeof (page_header^) + 1
THEN
    BEGIN
    out_pno := out_pno + 1;
    SAPDB_PascalFill ('VGG01 ',  12,    
          sizeof (buf), @buf, out_pos, sizeof (buf) - out_pos + 1,
          chr(FILL_CODE), move_error);
    vfwrite (hostfile.no, @buf, host_err, errtext);
    out_pos := 1;
    END;
(*ENDIF*) 
IF  host_err = vf_ok
THEN
    BEGIN
    page_header^.pageId_gg00    := out_pno;
    page_header^.pageType_gg00  := ptDump_egg00;
    page_header^.pageType2_gg00 := pt2Nil_egg00;
    page_header^.pageCheck_gg00 := chckNil_egg00;
    page_header^.pageMode_gg00  := [ ];
    out_pos := sizeof (page_header^) + 1;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01next_prim_number (VAR prim_int : tsp00_Int4);
 
VAR
      is_prim    : boolean;
      i          : tsp00_Int4;
 
BEGIN
IF  prim_int <= 2
THEN
    prim_int := 2;
(*ENDIF*) 
is_prim := false;
WHILE NOT is_prim DO
    BEGIN
    is_prim  := true;
    prim_int := prim_int + 1;
    i := 3;
    is_prim := prim_int MOD 2 = 1;
    WHILE (i * i <= prim_int) AND is_prim DO
        BEGIN
        is_prim := prim_int MOD i <> 0;
        i       := i + 2
        END
    (*ENDWHILE*) 
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01no_of_backup_devs : tsp00_Int4;
 
BEGIN
g01no_of_backup_devs := gg01_no_of_backup_devs
END;
 
(*------------------------------*) 
 
FUNCTION
      g01NumberOfUKTs : tsp00_Int4;
 
BEGIN
g01NumberOfUKTs := gg01_max_ukt;
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01opaddrmsg (
            msg_prio  : tsp3_priority;
            msg_type  : tsp3_msg_type;
            msg_no    : tsp00_Int4;
            msg_label : tsp00_C8;
            msg_text  : tsp00_C24;
            msg_addr  : tsp00_Addr);
 
VAR
      len   : integer;
      opmsg : tsp00_C40;
 
BEGIN
(* because of typecheck error *)
opmsg := bsp_c40;
len   := sizeof (msg_text);
WHILE (msg_text [len] = ' ') AND (len > 1) DO
    len := len - 1;
(*ENDWHILE*) 
SAPDB_PascalForcedMove (sizeof (msg_text), sizeof (opmsg), @msg_text, 1, @opmsg, 1, len);
IF  (sizeof (msg_addr) > 4) AND (len > 22)
THEN
    len := 22;
(* 40 Bytes:  text (22) + ':' + ' ' + addr (16) *)
(*ENDIF*) 
opmsg [len+1] := ':';
opmsg [len+1] := ' ';
len           := len + 2;
g17addr_to_line (msg_addr, len, opmsg);
IF  msg_prio <> sp3p_nil
THEN
    vmessage (msg_prio, msg_type, msg_no, msg_label, opmsg);
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR (msg_type = sp3m_error)
THEN
    gg01vtrace_write (msg_type, msg_label, opmsg, len)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01opmsg (
            msg_prio  : tsp3_priority;
            msg_type  : tsp3_msg_type;
            msg_no    : tsp00_Int4;
            msg_label : tsp00_C8;
            msg_text  : tsp00_C24;
            msg_value : tsp00_Int4);
 
VAR
      len   : integer;
      opmsg : tsp00_C40;
 
BEGIN
(* because of typecheck error *)
opmsg := bsp_c40;
len   := sizeof (msg_text);
WHILE (msg_text [len] = ' ') AND (len > 1) DO
    len := len - 1;
(*ENDWHILE*) 
SAPDB_PascalForcedMove (sizeof (msg_text), sizeof (opmsg), @msg_text, 1, @opmsg, 1, len);
opmsg [len+1] := ':';
len           := len + 2;
g17trimint4_to_line (msg_value, len, opmsg);
IF  msg_prio <> sp3p_nil
THEN
    vmessage (msg_prio, msg_type, msg_no, msg_label, opmsg);
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR (msg_type = sp3m_error)
THEN
    gg01vtrace_write (msg_type, msg_label, opmsg, len)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01optextmsg (
            msg_prio  : tsp3_priority;
            msg_type  : tsp3_msg_type;
            msg_no    : tsp00_Int4;
            msg_label : tsp00_C8;
            msg_text  : tsp00_C40);
 
VAR
      len : integer;
 
BEGIN
IF  msg_prio <> sp3p_nil
THEN
    vmessage (msg_prio, msg_type, msg_no, msg_label, msg_text);
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR (msg_type = sp3m_error)
THEN
    BEGIN
    len := sizeof (msg_text);
    WHILE (msg_text [len] = ' ') AND (len > 1) DO
        len := len - 1;
    (*ENDWHILE*) 
    gg01vtrace_write (msg_type, msg_label, msg_text, len)
    END
(*ENDIF*) 
END;
 
(* PTS 1107617 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      g01unioptextmsg (
            msg_enc   : tsp00_Int4;
            msg_prio  : tsp3_priority;
            msg_type  : tsp3_msg_type;
            msg_no    : tsp00_Int4;
            msg_label : tsp00_C8;
            msg_text  : tsp00_C80);
 
VAR
      len : integer;
 
BEGIN
IF  msg_prio <> sp3p_nil
THEN
    vmessageUnicode (msg_enc, msg_prio, msg_type, msg_no, msg_label, msg_text);
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00 OR (msg_type = sp3m_error)
THEN
    BEGIN
    len := sizeof (msg_text);
    IF  msg_enc = csp_ascii
    THEN
        WHILE (msg_text [len] = ' ') AND (len > 1) DO
            len := len - 1
        (*ENDWHILE*) 
    ELSE
        len := s30unilnr (@msg_text, csp_unicode_blank, 1, sizeof(msg_text));
    (*ENDIF*) 
    gg01univtrace_write (msg_type, msg_label, msg_text, len)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01oms_heap_limit : tsp00_Int4;
 
BEGIN
g01oms_heap_limit := gg01_oms_heap_limit;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01oms_heap_usage_threshold : tsp00_Int4; (* PTS 1110149 *)
 
BEGIN
g01oms_heap_usage_threshold := gg01_oms_heap_usage_threshold;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01oms_heap_count :  tsp00_Int4; (* PTS 1110828 *)
 
BEGIN
g01oms_heap_count := gg01_oms_heap_count;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01oms_heap_blocksize :  tsp00_Int4; (* PTS 1110828 *)
 
BEGIN
g01oms_heap_blocksize := gg01_oms_heap_blocksize;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01oms_stream_timeout : tsp00_Int4; (* PTS 1115635 *)
 
BEGIN
g01oms_stream_timeout := gg01_oms_stream_timeout;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01oms_vers_free_threshold : tsp00_Int4; (* PTS 1110149 *)
 
BEGIN
g01oms_vers_free_threshold := gg01_oms_vers_free_threshold;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01optimize_cache : boolean;
 
BEGIN
g01optimize_cache := gg01_optim_cache;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01packet_size : tsp00_Int4;
 
BEGIN
g01packet_size := gg01_packet_size
END;
 
(*------------------------------*) 
 
FUNCTION
      g01join_tablebuffer : tsp00_Int4;
 
BEGIN
g01join_tablebuffer (*in bytes*) := gg01_join_tablebuffer * 1024;
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01qual_init (
            VAR mblock : tgg00_MessBlock;
            qual_ptr   : tgg00_QualBufPtr;
            qual_size  : tsp00_Int4);
 
BEGIN
mblock.mb_qual      := qual_ptr;
mblock.mb_qual_len  := 0;
mblock.mb_qual_size := qual_size;
IF  (qual_ptr <> NIL) AND (qual_size >= sizeof (g01nil_stack_desc))
THEN
    mblock.mb_qual^.mstack_desc := g01nil_stack_desc
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01BlobPrefetchLowerLimit : tsp00_Int4;
 
BEGIN
g01BlobPrefetchLowerLimit := gg01_readahead_blobs_gt * sizeof(tsp00_Page);
END;
 
(*------------------------------*) 
 
FUNCTION
      g01region_cnt (region_type : tgg00_RegionType) : tsp00_Int4;
 
VAR
      region_cnt : tsp00_Int4;
 
BEGIN
CASE region_type OF
    rgnConvert_egg00:
        region_cnt := gg01_converter_regions;
    rgnData_egg00:
        region_cnt := gg01_data_regions;
    rgnOMS_egg00 :
        region_cnt := gg01_oms_regions;
    rgnRow_egg00:
        region_cnt := gg01_row_regions;
    rgnSave_egg00:
        region_cnt := 2;
    rgnTab_egg00:
        region_cnt := gg01_tab_regions;
    rgnTrans_egg00:
        region_cnt := gg01_trans_regions;
    OTHERWISE
        region_cnt := 1;
    END;
(*ENDCASE*) 
g01region_cnt := region_cnt
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01stack_init (
            VAR mblock : tgg00_MessBlock;
            stack_ptr  : tgg00_StackListPtr;
            stack_size : tsp00_Int4;
            qual_ptr   : tgg00_QualBufPtr;
            qual_size  : tsp00_Int4);
 
BEGIN
mblock.mb_struct            := mbs_stack_addr;
mblock.mb_st                := stack_ptr;
mblock.mb_st_size           := stack_size;
mblock.mb_st_max            := stack_size DIV sizeof (tgg00_StackEntry);
mblock.mb_qual              := qual_ptr;
mblock.mb_qual_size         := qual_size;
mblock.mb_qual^.mstack_desc := g01nil_stack_desc;
mblock.mb_qual^.mst_addr    := stack_ptr;
mblock.mb_qual^.mst_max     := mblock.mb_st_max;
mblock.mb_qual_len          := MB_PART1_HEAD_MXGG00
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01time_vtrace (
            VAR t           : tgg00_TransContext;
            msg             : tsp00_Name;
            VAR start_sec   : tsp00_Int4;
            VAR start_msec  : tsp00_Int4);
 
VAR
      stop_sec  : tsp00_Int4;
      stop_msec : tsp00_Int4;
      diff_sec  : tsp00_Int4;
      diff_msec : tsp00_Int4;
      trace_ln  : tsp00_Line;
      msg_ptr   : ^tsp00_Name;
 
BEGIN
IF  g01vtrace.vtrTime_gg00
THEN
    BEGIN
    vclock (stop_sec, stop_msec);
    diff_sec  := stop_sec  - start_sec;
    diff_msec := stop_msec - start_msec;
    IF  stop_msec < start_msec
    THEN
        BEGIN
        diff_sec  := diff_sec  - 1;
        diff_msec := diff_msec + 1000000
        END;
    (*ENDIF*) 
    IF  (diff_sec  > 0) OR
        (diff_msec > 0)
    THEN
        BEGIN
        trace_ln [1] := chr (ord (m_nil));
        trace_ln [2] := chr (0);
        trace_ln [3] := chr (0);
        s20int4_to_buf (diff_sec,  trace_ln, 1);
        s20int4_to_buf (diff_msec, trace_ln, sizeof (tsp00_Int4) + 1);
        msg_ptr  := @trace_ln[ sizeof (tsp00_Int4) + sizeof (tsp00_Int4) + 1 ];
        msg_ptr^ := msg;
        b120InsertTrace (t, gg_time, bd_timer,
              sizeof (tsp00_Int4) + sizeof (tsp00_Int4) + sizeof (msg),
              @trace_ln)
        END;
    (*ENDIF*) 
    start_sec  := stop_sec;
    start_msec := stop_msec
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      g01userstackoverflow : boolean;
 
VAR
      stack_left : tsp00_Int4;
 
BEGIN
vsleft (stack_left);
g01userstackoverflow := (stack_left < cgg01_userstack_reserve)
END;
 
(*------------------------------*) 
 
PROCEDURE
      g01vtr_init;
 
BEGIN
(* PTS 1103799 JA 1999-08-30 *)
WITH g01vtrace DO
    BEGIN
    vtrAk_gg00               := false;
    vtrAkDelete_gg00         := false;
    vtrAkInsert_gg00         := false;
    vtrAkPacket_gg00         := false;
    vtrAkSelect_gg00         := false;
    vtrAkShortPacket_gg00    := false;
    vtrAkUpdate_gg00         := false;
    vtrAll_gg00              := false;
    (* *)
    vtrAny_gg00              := false;
    vtrBdIndex_gg00          := false;
    vtrBdPrim_gg00           := false;
    vtrBdString_gg00         := false;
    (* PTS 1107617 E.Z. *)
    vtrIoTrace_gg00          := false;
    vtrKbLock_gg00           := false;
    vtrStrategy_gg00         := false;
    vtrTime_gg00             := false;
    (* *)
    vtrGateway_gg00          := false;
    vtrBdObject_gg00         := false;
    vtrOmsNew_gg00           := false;
    vtrOmsGet_gg00           := false;
    vtrOmsUpd_gg00           := false;
    vtrOmsFree_gg00          := false;
    vtrFiller1_gg00          := 0;
    (* *)
    vtrCheck_gg00            := false;
    vtrRetcodeCheck_gg00     := false;
    vtrStopRetcode_gg00      := 0;
    vtrSession_gg00.ci4_gg00 := cgg_nil_session;
    END
(*ENDWITH*) 
END;
 
(* PTS 1120247 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      gg01bool_conf_param_get (
            conf_param_name  : tgg01_ConfParamNameAddr;
            VAR param_value  : boolean;
            refresh_call     : boolean;
            VAR b_err        : tgg00_BasisError);
 
VAR
      conf_param_compval : tsp00_C8;
      conf_param_value   : tsp11_ConfParamValue;
      conf_param_length  : tsp00_Int4;
      errtext            : tsp00_ErrText;
      conf_param_ret     : tsp11_ConfParamReturnValue;
      move_error         : tgg00_BasisError;
      update_online      : boolean;
      permanent_change   : boolean;
 
BEGIN
IF  b_err = e_ok
THEN
    BEGIN
    move_error := e_ok;
    vconf_param_get_string (conf_param_name^, conf_param_value, conf_param_length,
          update_online, permanent_change,
          errtext, conf_param_ret);
    IF  (conf_param_ret = ok_sp11) AND (conf_param_length <= sizeof(conf_param_compval))
    THEN
        BEGIN
        conf_param_compval := bsp_c8;
        SAPDB_PascalMove ('VGG01 ',  13,    
              sizeof (conf_param_value), sizeof (conf_param_compval),
              @conf_param_value, 1, @conf_param_compval, 1,
              conf_param_length, move_error);
        IF  conf_param_compval = 'YES     '
        THEN
            param_value := true
        ELSE
            IF  conf_param_compval = 'NO      '
            THEN
                param_value := false
            ELSE
                gg01errtest_abort (errtext, refresh_call, b_err);
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        gg01errtest_abort (errtext, refresh_call, b_err);
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      gg01errtest_abort (
            VAR msg_text : tsp00_C40;
            refresh_call : boolean;
            VAR b_err    : tgg00_BasisError);
 
BEGIN
vmessage (sp3p_console, sp3m_error, csp3_xparam_error,
      csp3_n_config, msg_text);
IF  refresh_call
THEN
    b_err := e_conf_parameter_error
ELSE
    gg999Abort(cgg01_write_core);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      gg01vtrace_write (
            msg_type     : tsp3_msg_type;
            msg_label    : tsp00_C8;
            msg_text     : tsp00_C40;
            len_msg_text : integer);
 
VAR
      len        : integer;
      trace_line : tsp00_Line;
      aux_trans  : tgg00_TransContext;
      move_error : tgg00_BasisError;
 
BEGIN
vgetpid (aux_trans.trTaskId_gg00);
WITH aux_trans DO
    BEGIN
    trSessionId_gg00.ci4_gg00    := cgg_nil_session;
    trTransId_gg00.ci6_gg00      := cgg_nil_trans;
    trWriteTransId_gg00.ci6_gg00 := cgg_nil_trans;                   (* PTS 1108234 JA 2000-11-17 *)
    trSubtransId_gg00            := cgg_zero_subtrans
    END;
(*ENDWITH*) 
len := 0;
IF  msg_type = sp3m_error
THEN
    BEGIN
    g17sname_to_line ('***         ', len, trace_line);
    len := len + 1;
    trace_line [len] := ' '
    END;
(*ENDIF*) 
g17sname_to_line ('opmsg:      ', len, trace_line);
move_error      := e_ok;
len             := len + 1;
trace_line[len] := ' ';
SAPDB_PascalMove ('VGG01 ',  14,    
      sizeof (msg_label), sizeof (trace_line),
      @msg_label, 1, @trace_line, len + 1,
      sizeof (msg_label), move_error);
len := len + sizeof (msg_label) + 1;
trace_line [len] := ' ';
SAPDB_PascalMove ('VGG01 ',  15,    
      sizeof (msg_text), sizeof (trace_line),
      @msg_text, 1, @trace_line, len+1,
      len_msg_text, move_error);
len := len + len_msg_text;
b120InsertTrace (aux_trans, gg, gg_opmsg, len, @trace_line)
END;
 
(* PTS 1107617 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      gg01univtrace_write (
            msg_type     : tsp3_msg_type;
            msg_label    : tsp00_C8;
            msg_text     : tsp00_C80;
            len_msg_text : integer);
 
VAR
      len        : integer;
      trace_line : tsp00_Line;
      aux_trans  : tgg00_TransContext;
      move_error : tgg00_BasisError;
 
BEGIN
vgetpid (aux_trans.trTaskId_gg00);
WITH aux_trans DO
    BEGIN
    trSessionId_gg00.ci4_gg00    := cgg_nil_session;
    trTransId_gg00.ci6_gg00      := cgg_nil_trans;
    trWriteTransId_gg00.ci6_gg00 := cgg_nil_trans;  (* PTS 1116852 TS 2002-07-26 *)
    trSubtransId_gg00            := cgg_zero_subtrans
    END;
(*ENDWITH*) 
len := 0;
IF  msg_type = sp3m_error
THEN
    BEGIN
    g17sname_to_line ('***         ', len, trace_line);
    len := len + 1;
    trace_line [len] := ' '
    END;
(*ENDIF*) 
g17sname_to_line ('opmsg:      ', len, trace_line);
move_error      := e_ok;
len             := len + 1;
trace_line[len] := ' ';
SAPDB_PascalMove ('VGG01 ',  16,    
      sizeof (msg_label), sizeof (trace_line),
      @msg_label, 1, @trace_line, len + 1,
      sizeof (msg_label), move_error);
len := len + sizeof (msg_label) + 1;
trace_line [len] := ' ';
SAPDB_PascalMove ('VGG01 ',  17,    
      sizeof (msg_text), sizeof (trace_line),
      @msg_text, 1, @trace_line, len+1,
      len_msg_text, move_error);
len := len + len_msg_text;
b120InsertTrace (aux_trans, gg, gg_opmsg, len, @trace_line)
END;
 
(* PTS 1120247 E.Z. *)
(* incl all calls in gg01get_conf_param and the checks on refresh_call *)
(*------------------------------*) 
 
FUNCTION
      g01hashed_resultset : boolean;
 
BEGIN
g01hashed_resultset := gg01_hashed_resultset
END;
 
(*------------------------------*) 
 
FUNCTION
      g01clustered_lobs : boolean;
 
BEGIN
g01clustered_lobs := gg01_clustered_lobs;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01diag_reverse_fetch : boolean;
 
BEGIN
g01diag_reverse_fetch := gg01_diag_reverse_fetch
END;
 
(*------------------------------*) 
 
FUNCTION
      g01optimize_parallel_server : tsp00_Int4;
 
BEGIN
g01optimize_parallel_server := gg01optimize_parallel_server;
END;
 
(*------------------------------*) 
 
FUNCTION
      g01trigger : boolean;
 
BEGIN
g01trigger := gg01_trigger
END;
 
(*------------------------------*) 
 
FUNCTION
      g01one_join_phase : boolean;
 
BEGIN
g01one_join_phase := gg01_one_join_phase
END;
 
(*------------------------------*) 
 
FUNCTION
      g01aggr_optim : boolean;
 
BEGIN
g01aggr_optim := gg01_aggr_optim
END;
 
(*------------------------------*) 
 
FUNCTION
      g01columncompression : boolean;
 
BEGIN
g01columncompression := gg01_columncompression
END;
 
(*------------------------------*) 
 
FUNCTION
      g01checktablewidth : boolean;
 
BEGIN
g01checktablewidth := gg01_checktablewidth
END;
 
(*------------------------------*) 
 
FUNCTION
      g01diag_minmax_optim : boolean;
 
BEGIN
g01diag_minmax_optim := gg01_diag_minmax_optim
END;
 
(*------------------------------*) 
 
FUNCTION
      g01outer_join_ordered : boolean;
 
BEGIN
g01outer_join_ordered := NOT gg01_outer_join_ordered
END;
 
(*------------------------------*) 
 
FUNCTION
      g01use_join_hashtable : boolean;
 
BEGIN
g01use_join_hashtable := gg01_use_join_hashtable
END;
 
(*------------------------------*) 
 
FUNCTION
      g01sm_reads : tsp00_Int4;
 
BEGIN
g01sm_reads := gg01_sm_reads
END;
 
(*------------------------------*) 
 
FUNCTION
      g01sm_milliseconds : tsp00_Int4;
 
BEGIN
g01sm_milliseconds := gg01_sm_milliseconds
END;
 
(*------------------------------*) 
 
FUNCTION
      g01sm_selectivity : tsp00_Int4;
 
BEGIN
g01sm_selectivity := gg01_sm_selectivity
END;
 
(*------------------------------*) 
 
FUNCTION
      g01join_hash_min_ratio : tsp00_Int4;
 
BEGIN
g01join_hash_min_ratio := gg01_join_hash_min_ratio
END;
 
(*------------------------------*) 
 
FUNCTION
      g01join_parall_minsize : tsp00_Int4;
 
BEGIN
g01join_parall_minsize := gg01_join_parall_minsize
END;
 
(*------------------------------*) 
 
PROCEDURE
      dummy_for_linking_pascal;
 
VAR 
      aux : tsp00_Int4;
 
BEGIN
aux := gg01_delay_lw;
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
