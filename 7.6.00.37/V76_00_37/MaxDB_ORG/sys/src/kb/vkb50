/*!***************************************************************************
 
  module      : vkb50
  author      : JuergenA,UweH
  responsible : UweH
  special area: KB_trans_state
  created     : 1989-06-01
  last changed: 2002-01-01 12:00
  Copyright (c) 2000-2005 SAP AG
  see also    :
  description : transaction list handling
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
*****************************************************************************/
 
.tt 1 $SAP$LiveCache$VKB50$
.tt 3 $UweH$KB_trans_state$2002-01-01$
 
Module  : KB_trans_state
 
Define  :
 
        PROCEDURE
              k50aux_fn_no (
                    TransIndex         : tgg00_TransIndex;
                    IsPerm             : boolean;
                    VAR AuxiliaryFnNo  : tsp00_Int4);
 
        PROCEDURE
              kb50CheckActiveTrans (
                    TaskId           : tsp00_TaskId;
                    VAR WriteTransId : tgg91_TransNo;
                    TransIndex       : tgg00_TransIndex;
                    VAR IsActive     : boolean);
 
        PROCEDURE
              k50check_excl_user (
                    VAR Trans  : tgg00_TransContext;
                    VAR UserId : tgg00_UserId);
 
        PROCEDURE
              kb50CheckObjSelfLocked (
                    VAR Trans        : tgg00_TransContext;
                    VAR Oid          : tgg00_OidSpace (*ptocSynonym ggg92.h: tgg92_KernelOid&*);
                    VAR ObjTransInfo : tgg00_ObjTransInfo;
                    bIsShareLocked   : boolean);
 
        PROCEDURE
              kb50EnterTransRegion (
                    taskid     : tsp00_TaskId;
                    transindex : tgg00_TransIndex);
              (*inlineC class FileDir_IDirectory; *)
 
        PROCEDURE
              kb50GetLocalFileDir (TransIndex : tgg00_TransIndex;
                    VAR filedir : tsp00_Addr (*ptocSynonym FileDir_IDirectory*& *));
 
        PROCEDURE
              kb50LeaveTransRegion (
                    taskid     : tsp00_TaskId;
                    transindex : tgg00_TransIndex);
 
        PROCEDURE
              k50eot_check (
                    VAR t         : tgg00_TransContext;
                    MessType      : tgg00_MessType;
                    MessType2     : tgg00_MessType2);
 
        PROCEDURE
              k50eot_new_trans (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k50excl_scan (
                    TaskId         : tsp00_TaskId;
                    VAR IsEotExcl  : boolean);
 
        PROCEDURE
              k50get_temp_log (
                    TransIndex            : tgg00_TransIndex;
                    VAR LogFileRoot       : tsp00_PageNo;
                    VAR LogCnt            : tsp00_Int4;
                    VAR FunctRollb        : tsp00_Int4;
                    VAR AuxFileExists     : boolean);
 
        FUNCTION
              k50GetLogTransaction (TransIndex : tgg00_TransIndex) : tsp00_Addr (*ptocSynonym void**);
 
        PROCEDURE
              kb50LockObj (
                    VAR Trans        : tgg00_TransContext;
                    VAR ObjFileNo    : tsp00_C8;
                    VAR Oid          : tgg00_OidSpace (*ptocSynonym tgg92_KernelOid&*);
                    VAR ObjTransInfo : tgg00_ObjTransInfo;
                    ignShrLckCsView  : boolean);             (* PTS 1128244 FF 2004-03-18 *)
 
        PROCEDURE       (* new PTS 1128244 FF 2004-03-18 *)
              kb50LockShareObj (
                    VAR Trans : tgg00_TransContext;
                    VAR ObjFileNo    : tsp00_C8;
                    VAR Oid          : tgg00_OidSpace (*ptocSynonym tgg92_KernelOid&*);
                    VAR ObjTransInfo : tgg00_ObjTransInfo);
 
        PROCEDURE
              k50my_state (
                    TransIndex        : tgg00_TransIndex;
                    VAR IsEotExcl     : boolean;
                    VAR AuxPermExists : boolean;
                    VAR TransTaskId   : tsp00_TaskId);
 
        PROCEDURE
              k50new_write_trans (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              k50not_connected (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              kb50ObjConsistentCheck (
                    VAR Trans       : tgg00_TransContext;
                    VAR UpdTransId  : tgg91_TransNo;
                    VAR bConsistent : boolean;
                    VAR bCancelled  : boolean); (* PTS 1120151 FF 2003-JAN-10 *)
 
        FUNCTION
              k50oms_have_obj_locks (TransIndex : tgg00_TransIndex) : boolean;
 
        PROCEDURE
              k50put_temp_log (
                    TransIndex     : tgg00_TransIndex;
                    VAR TransState : tgg00_TransState;
                    LogFileRoot    : tsp00_PageNo;
                    LogCnt         : tsp00_Int4;
                    AuxFileExists  : boolean);
 
        PROCEDURE
              k50RegisterTransaction (
                    TransIndex        : tgg00_TransIndex;
                    LocalTransContext : tsp00_Addr (*ptocSynonym void**));
 
        PROCEDURE       (* PTS 1128244 FF 2004-03-18 before only local proc *)
              k50SatisfyNextWaitingObjRequest (
                    VAR ObjCollGlob : tkb05_ObjCollGlob;
                    VAR CollEntry   : tkb05_ObjCollisionEntry;
                    VAR UpdTransId  : tgg91_TransNo; (*PTS 1135178 FF*)
                    bOnlyIfShareReq : boolean); (*PTS 1135178 FF*)
 
        PROCEDURE
              k50set_redo_process_id (
                    TaskId     : tsp00_TaskId;
                    TransIndex : tgg00_TransIndex);
 
        PROCEDURE
              k50StartDbProcedure (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k50transindex_check (VAR t : tgg00_TransContext);
 
        PROCEDURE
              kb50UnlockObj (
                    TaskId           : tsp00_TaskId;
                    VAR WriteTransId : tgg91_TransNo;
                    TransIndex       : tgg00_TransIndex;
                    VAR Oid          : tgg00_OidSpace (*ptocSynonym tgg92_KernelOid&*);
                    VAR ObjTransInfo : tgg00_ObjTransInfo); (*PTS 1135178 FF*)
 
        PROCEDURE     (* new PTS 1128244 FF 2004-03-18 *)
              kb50UnlockShareObj (TaskId  : tsp00_TaskId;
                    VAR WriteTransId : tgg91_TransNo;
                    TransIndex       : tgg00_TransIndex;
                    VAR Oid          : tgg00_OidSpace (*ptocSynonym tgg92_KernelOid&*);
                    VAR ObjTransInfo : tgg00_ObjTransInfo);
 
        PROCEDURE
              kb50WaitAndRetryObjLock (
                    VAR Trans : tgg00_TransContext;
                    MessType  : tgg00_MessType;
                    MessType2 : tgg00_MessType2);
 
        PROCEDURE
              kb50XxxObjTrace (
                    VAR Trans            : tgg00_TransContext;
                    msg                  : tsp00_Sname (*ptocSynonym const char**);
                    VAR oid              : tgg00_OidSpace (*ptocSynonym tgg92_KernelOid&*);
                    VAR UpdTransId       : tgg91_TransNo;
                    VAR BeforeRef        : tgg91_PageRef;
                    ObjState             : tgg00_ObjState);
              (*ptocExport hkb50_1.h*)
 
        PROCEDURE
              kb50CheckConsistViewOfTrans (
                    VAR Trans     : tgg00_TransContext;
                    VAR ThisTrans : tkb05_TransEntry);
 
        PROCEDURE
              k50DelCollisionEntry (
                    VAR ObjCollGlob    : tkb05_ObjCollGlob;
                    VAR LockTransEntry : tkb05_TransEntry;
                    VAR CollEntry      : tkb05_ObjCollEntryPtr);
 
        PROCEDURE
              k50hash_rowid (
                    VAR RowId          : tkb05_RowId;
                    KeyLen             : tsp00_Int2;
                    VAR HashValue      : tsp00_Int4);
 
        PROCEDURE
              k50init_wanted_rowid_lock (
                    VAR MoveObj    : tsp00_MoveObj;
                    MoveObjSize    : tsp00_Int4;
                    pos            : tsp00_Int4;
                    KeyLen         : integer;
                    VAR WantedLock : tkb05_WantedLock;
                    VAR MoveError  : tgg00_BasisError);
 
        PROCEDURE
              k50init1_wanted_rowid_lock (
                    VAR MoveObj    : tsp00_MoveObj;
                    MoveObjSize    : tsp00_Int4;
                    pos            : tsp00_Int4;
                    KeyLen         : integer;
                    VAR WantedLock : tkb05_WantedLock;
                    VAR MoveError  : tgg00_BasisError);
 
        FUNCTION
              kb50IsValidCollisionEntry (
                    VAR ObjCollEntry : tkb05_ObjCollisionEntry;
                    VAR Oid : tkb05_KernelOid (*ptocSynonym tgg92_KernelOid&*)) : boolean;
 
        PROCEDURE
              kb50RemoveObjLocks (
                    TaskId        : tsp00_TaskId;
                    VAR ThisTrans : tkb05_TransEntry);
              (*ptocExport hkb50_2.h*)
 
        PROCEDURE
              k50hash (
                    VAR buf    : tsp00_Buf;
                    pos        : tsp00_Int4;
                    len        : tsp00_Int4;
                    VAR ResBuf : tsp00_Buf;
                    ResPos     : integer);
 
.CM *-END-* define --------------------------------------
 
Use     :
 
        FROM
              KB_Check : VKB03;
 
        VAR
              kb03Check : tkb00_Check;
 
      ------------------------------ 
 
        FROM
              KB_locklist : VKB51;
 
        VAR
              k51glob : tkb05_Glob;
 
        PROCEDURE
              kb51EnableHistoryRetention;
 
        PROCEDURE
              k51FindConsistView (
                    TaskId          : tsp00_TaskId;
                    TransIndex      : tgg00_TransIndex;
                    ConsistViewNo   : tgg91_TransNo;
                    VAR ConsistView : tkb05_ConsistViewPtr);
 
        PROCEDURE
              k51init_wanted_lock (VAR WantedLock : tkb05_WantedLock);
 
        PROCEDURE
              k51new_select_trans (
                    TaskId                : tsp00_TaskId;
                    VAR SelectTransNo     : tgg91_TransNo);
 
        FUNCTION
              k51tr_index_region (TransIndex : tgg00_TransIndex) : tkb05_RegionNo;
 
      ------------------------------ 
 
        FROM
              KB_ConsistView_lock : VKB511;
 
        PROCEDURE   (* PTS 1122885 FF 2003-07-01 *)
              kb511EnterConsistView1 (
                    Taskid                  : tsp00_TaskId;
                    exclusiveRequest        : boolean);
 
        PROCEDURE   (* PTS 1122885 FF 2003-07-01 *)
              kb511LeaveConsistView1 (
                    Taskid                  : tsp00_TaskId;
                    exclusiveRequest        : boolean);
 
      ------------------------------ 
 
        FROM
              KB_ObjShare_lock : VKB501;
 
        (* PTS 1128244 FF 2004-03-18 new layer for share object locks *)
        (*                                                            *)
        PROCEDURE
              k501GetShareLock(
                    VAR Trans        : tgg00_TransContext;
                    VAR ObjFileNo    : tsp00_C8;
                    VAR ObjTransInfo : tgg00_ObjTransInfo;
                    VAR Oid          : tkb05_KernelOid;
                    ignColEntry      : boolean);  (*PTS 1135178 FF*)
 
        PROCEDURE
              k501GetShareLock2(
                    VAR Trans        : tgg00_TransContext;
                    VAR ObjFileNo    : tsp00_C8;
                    VAR Oid          : tkb05_KernelOid;
                    ignColEntry      : boolean);
 
        FUNCTION
              k501GetExclusiveLock(
                    VAR Trans        : tgg00_TransContext;
                    VAR ObjFileNo    : tsp00_C8;
                    VAR Oid          : tkb05_KernelOid;
                    ignShrLckCsView  : boolean;
                    ignColEntry      : boolean) : tgg00_TransIndex;
 
        FUNCTION
              k501GetCollEntryIdx (
                    VAR Trans        : tgg00_TransContext;
                    VAR CollEntry    : tkb05_KernelOid) : tgg00_TransIndex;
 
        PROCEDURE
              k501IsSelfLocked(
                    VAR Trans        : tgg00_TransContext;
                    VAR Oid          : tkb05_KernelOid;
                    bIsSharedLocked  : boolean);
 
        PROCEDURE
              k501RemoveCollisionEntry (
                    VAR Trans        : tgg00_TransContext;
                    VAR CollEntry    : tkb05_ObjCollisionEntry);
 
        PROCEDURE
              k501StoreCollisionEntry (
                    VAR Trans        : tgg00_TransContext;
                    VAR CollEntry    : tkb05_ObjCollisionEntry);
 
        PROCEDURE
              k501Unlock(
                    VAR Trans          : tkb05_TransEntry;
                    VAR Oid            : tkb05_KernelOid;
                    isExclLock         : boolean );
 
      ------------------------------ 
 
        FROM
              KB_Ext_Trans_Mon : VKB512;
 
        PROCEDURE
              k512MonRestartTransaction(VAR monContextPtr : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              KB_show_lock : VKB52;
 
        PROCEDURE
              k52acc_objcoll_entry (
                    VAR ObjCollGlob     : tkb05_ObjCollGlob;
                    EntryIndex          : tgg00_TransIndex;
                    VAR ObjCollEntryPtr : tkb05_ObjCollEntryPtr);
 
        PROCEDURE
              k52acc_objreq_entry (
                    VAR ObjCollGlob    : tkb05_ObjCollGlob;
                    TransIndex         : tgg00_TransIndex;
                    VAR ObjReqEntryPtr : tkb05_ObjReqEntryPtr);
 
        PROCEDURE
              k52acc_trans_entry (
                    TransIndex        : tgg00_TransIndex;
                    VAR TransEntryPtr : tkb05_TransEntryPtr);
 
        PROCEDURE
              k52begexcl_objcoll (
                    TaskId               : tsp00_TaskId;
                    VAR ObjCollGlobPtr   : tkb05_ObjCollGlobPtr);
 
        PROCEDURE
              k52begexcl_region (
                    TaskId              : tsp00_TaskId;
                    Region              : tkb05_RegionNo;
                    VAR RegionGlobPtr   : tkb05_RegionGlobPtr);
 
        PROCEDURE
              k52endexcl_objcoll (
                    TaskId               : tsp00_TaskId;
                    VAR ObjCollGlobPtr   : tkb05_ObjCollGlobPtr);
 
        PROCEDURE
              k52endexcl_region (
                    TaskId              : tsp00_TaskId;
                    VAR RegionGlobPtr   : tkb05_RegionGlobPtr);
 
        PROCEDURE
              k52flush_trans_entry (VAR TransEntry : tkb05_TransEntry);
 
        PROCEDURE
              k52flush_trans_glob  (VAR TransGlob  : tkb05_TransGlob);
 
        FUNCTION
              k52used_trans_of_region (VAR RegionGlob : tkb05_RegionGlob): tsp00_Int4;
 
        PROCEDURE
              k52x_item_error (
                    msg            : tsp00_C24;
                    ItemKind       : tkb05_ItemKind);
 
        PROCEDURE
              k52x_loop_error (
                    msg            : tsp00_C24;
                    error_no       : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53wait (
                    VAR t     : tgg00_TransContext;
                    MessType  : tgg00_MessType;
                    MessType2 : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              KB_restart_record : VKB57;
 
        PROCEDURE
              k57new_write_trans (
                    TaskId      : tsp00_TaskId;
                    VAR TransNo : tgg91_TransNo);
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (
                    VAR t        : tgg00_TransContext;
                    trace_layer  : tgg00_Debug;
                    trace_object : tgg00_VtraceType;
                    body_len     : tsp00_Int2;
                    trace_body   : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code      : tgg04_CodeGlobals;
              g01hashprime : tgg00_HashPrimeList;
              g01vtrace    : tgg00_VtraceState;
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
        PROCEDURE
              g01check (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4;
                    constraint : boolean);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        FUNCTION
              gg06buildCompressedKey (
                    VAR key           : tsp00_MoveObj;
                    keySize           : tsp00_Int4;
                    keyStartPosition  : tsp00_Int4;
                    keyLength         : tsp00_Int4;
                    compressedKeySize : tsp00_Int4;
                    VAR compressedKey : tkb05_RowId) : boolean;
 
        FUNCTION
              gg06Int4FromUint2 (Uint2 : tsp00_Uint2): tsp00_Int4;
 
        FUNCTION
              gg06IsDummyTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        FUNCTION
              gg06IsEqOidPnoPos (
                    VAR oid1 : tgg00_OidSpace;
                    VAR oid2 : tgg00_OidSpace): boolean;
 
        FUNCTION
              gg06IsNilOid (VAR oid : tgg00_OidSpace): boolean;
 
        FUNCTION
              gg06IsNilTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        FUNCTION    (* PTS 1128244 FF 2004-03-18 *)
              gg06IsZeroTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        PROCEDURE
              gg06OidToLine (
                    VAR oid          : tgg00_OidSpace;
                    VAR LineLen      : integer;
                    VAR Line         : tsp00_Line);
 
        PROCEDURE
              gg06SetDummyTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              gg06SetNilOid (VAR oid : tgg00_OidSpace);
 
        PROCEDURE
              gg06SetNilSession (VAR SessionNo : tgg91_SessionNo);
 
        PROCEDURE
              gg06SetNilTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE   (* PTS 1128244 FF 2004-03-18 *)
              gg06SetZeroTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              gg06TransToLine (
                    VAR TransNo : tgg91_TransNo;
                    VAR LineLen : integer;
                    VAR Line    : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        (* g08cnstview : tsp00_RegionId;    PTS 1122885 FF 2003-07-01 *)
        VAR
              g08lock0    : tsp00_RegionId;
 
        PROCEDURE
              g08check_excl (region : tsp00_RegionId);
 
        PROCEDURE
              g08excl_check (
                    TaskId : tsp00_TaskId;
                    region : tsp00_RegionId);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17basis_err_to_line (
                    b_err      : tgg00_BasisError;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17page_ref_to_line (
                    VAR page_ref : tgg91_PageRef;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (
                    n             : tsp00_Sname;
                    VAR ln_len    : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (
                    int        : tsp00_Int4;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        FUNCTION
              gg999KernelStateIsRedoLogProcessing : boolean;
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbegexcl (
                    TaskId     : tsp00_TaskId;
                    region     : tsp00_RegionId);
 
        PROCEDURE
              vendexcl (
                    TaskId     : tsp00_TaskId;
                    region     : tsp00_RegionId);
 
        PROCEDURE
              vgetpid (VAR pid : tsp00_TaskId);
 
        PROCEDURE
              vsignal (
                    pid    : tsp00_TaskId;
                    ok     : boolean);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id      : tsp00_C6;
                    mod_num     : tsp00_Int4;
                    source_upb  : tsp00_Int4;
                    dest_upb    : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    src_pos     : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    dest_pos    : tsp00_Int4;
                    length      : tsp00_Int4;
                    VAR err     : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf_swap (
                    val        : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tsp00_Buf;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01basis_error (
                    debug : tgg00_Debug;
                    nam   : tsp00_Sname;
                    b_err : tgg00_BasisError);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01int4 (
                    layer    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (
                    layer      : tgg00_Debug;
                    nam_1      : tsp00_Sname;
                    int_1      : tsp00_Int4;
                    nam_2      : tsp00_Sname;
                    int_2      : tsp00_Int4);
 
        PROCEDURE
              t01messtype (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    MessType     : tgg00_MessType);
 
        PROCEDURE
              t01mess2type (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    mess2_type    : tgg00_MessType2);
 
        PROCEDURE
              t01name (debug : tgg00_Debug; nam  : tsp00_Name);
 
        PROCEDURE
              ta01Oid (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    VAR oid  : tgg00_OidSpace);
 
        FUNCTION
              t01trace (debug : tgg00_Debug) : boolean;
 
        PROCEDURE
              ta01TransNo (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    VAR TransNo  : tgg91_TransNo);
&       endif
 
.CM *-END-* use -----------------------------------------
 
Synonym :
 
        PROCEDURE
              gg06buildCompressedKey;
 
              tsp00_MoveObj tkb05_RowId
 
        PROCEDURE
              b120InsertTrace;
 
              tgg11_VtraceBodyPtr tsp00_Addr
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tsp00_Buf
 
.CM *-END-* synonym -------------------------------------
 
***********************************************************
 
 
Specification:
 
The procedures and functions are using the trans entries
of the locklist. The layout description of a trans entry is contained
in the module GKB05.
 
 
Procedure K50AUX_FN_NO
 
The Procedure returns the number of the last auxiliary file
for the transaction specified by TRANSINDEX.
 
 
Procedure K50PREV_LOGPOS
 
Returns the position of the previous log entry for the
transaction specified
by TRANSINDEX.
 
 
Procedure K50PUT_PREV_LOGPOS
 
Sets the position of the previus log entry for
the specified transaction.
 
 
Procedure K50ROLLBACK_LOGPOS
 
Returns for the specified transaction the position of
the previos and the first log entry for the function rollback
(LPNO/POS_PREV_LOG and LPNO/POS_FUNCT_ROLLB).
 
 
Procedure K50SET_TIMEOUT
 
For the transaction, sets the LOCK_TIMEOUT to zero, TE_SECOND_CHANCE
to true and the states TE_TIMEOUT_OCCURRED, TE_COLLISION.
The reason of the procedure call is marked by TE_LOG_FULL or
TE_LOG_REJECT.
 
.CM *-END-* specification -------------------------------
 
***********************************************************
 
Description:
 
.CM *-END-* description ---------------------------------
 
***********************************************************
 
Structure:
 
.CM *-END-* structure -----------------------------------
 
**********************************************************
 
.CM -lll-
Code    :
 
 
CONST
      IS_OK          = true;
      IS_EXCL_LOCK   = true;  (*PTS 1128244 FF 2004-03-18 *)
      ALL_REQ        = false; (*PTS 1135178 FF*)
      ONLY_SHARE_REQ = true;  (*PTS 1135178 FF*)
 
 
(*------------------------------*) 
 
PROCEDURE
      k50aux_fn_no (
            TransIndex         : tgg00_TransIndex;
            IsPerm             : boolean;
            VAR AuxiliaryFnNo  : tsp00_Int4);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
(* outside lock region *)
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50aux_fn_: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    WITH ThisTrans^.teLog_kb05 DO
        BEGIN
        tlogAuxFnNo_kb05 := tlogAuxFnNo_kb05 + 1;
        AuxiliaryFnNo    := tlogAuxFnNo_kb05
        END;
    (*ENDWITH*) 
    IF  IsPerm
    THEN
        ThisTrans^.teInfo_kb05 := ThisTrans^.teInfo_kb05 + [tiAuxPermExists_ekb05]
    (*ENDIF*) 
    END
ELSE
    AuxiliaryFnNo := 0
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50CheckActiveTrans (
            TaskId           : tsp00_TaskId;
            VAR WriteTransId : tgg91_TransNo;
            TransIndex       : tgg00_TransIndex;
            VAR IsActive     : boolean);
 
VAR
      TransRegion : tkb05_RegionNo;
      ThisTrans   : tkb05_TransEntryPtr;
 
BEGIN
&ifdef TRACE
ta01TransNo (kb_lock, 'WriteTransId', WriteTransId);
t01int4     (kb_lock, 'TransIndex  ', TransIndex);
&endif
IsActive := false;
IF  (TransIndex <> cgg_nil_transindex)
    AND
    NOT gg06IsNilTrans (WriteTransId)
    AND
    k51glob.glGenerated_kb05 (* PTS 1113124 UH 2001-12-17 *)
    AND
    (TransIndex <= k51glob.glTransEntries_kb05) (* PTS 1117202 UH 2002-08-13 *)
THEN
    BEGIN
    TransRegion := k51tr_index_region (TransIndex);
    vbegexcl (TaskId, g08lock0 + TransRegion);
    k52acc_trans_entry (TransIndex, ThisTrans);
    IsActive :=
          (ThisTrans^.teState_kb05 <> m_delete)
          AND
          (ThisTrans^.teWriteTransId_kb05 = WriteTransId);
    vendexcl (TaskId, g08lock0 + TransRegion)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50check_excl_user (
            VAR Trans  : tgg00_TransContext;
            VAR UserId : tgg00_UserId);
 
VAR
      CurrRegion      : tkb05_RegionNo;
      TransCnt        : tsp00_Int4;
      TransLimit      : tsp00_Int4;
      CurrTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
(* PTS 1103428 JA 1999-08-16 *)
IF  Trans.trIndex_gg00 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_nil_transindex
ELSE
    Trans.trError_gg00 := e_ok;
(*ENDIF*) 
CurrRegion := 1;
WHILE (CurrRegion <= k51glob.glTransRegions_kb05) AND (Trans.trError_gg00 = e_ok) DO
    BEGIN
    k52begexcl_region (Trans.trTaskId_gg00, CurrRegion, TransRgnGlobPtr);
    TransLimit := k52used_trans_of_region (TransRgnGlobPtr^);
    TransCnt   := 0;
    CurrTrans  := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
    WHILE (CurrTrans <> NIL) AND (Trans.trError_gg00 = e_ok) AND (TransCnt <= TransLimit) DO
        BEGIN
        IF  Trans.trIndex_gg00 <> CurrTrans^.teOwnIndex_kb05
        THEN
            BEGIN
            IF  (tiExclusiveUser_ekb05 in CurrTrans^.teInfo_kb05)
                AND
                (UserId = CurrTrans^.teUserId_kb05)
            THEN
                Trans.trError_gg00 := e_user_already_connected
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        TransCnt  := TransCnt + 1;
        CurrTrans := CurrTrans^.teNextTrans_kb05
        END;
    (*ENDWHILE*) 
    k52endexcl_region (Trans.trTaskId_gg00, TransRgnGlobPtr);
    IF  TransCnt > TransLimit
    THEN
        k52x_loop_error ('k50check_excl_user      ', 1);
    (*ENDIF*) 
    CurrRegion := CurrRegion + 1
    END;
(*ENDWHILE*) 
;
&ifdef TRACE
t01basis_error (kb_lock, 'end k50check', Trans.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50CheckConsistViewOfTrans (
            VAR Trans     : tgg00_TransContext;
            VAR ThisTrans : tkb05_TransEntry);
 
VAR
      bCancelled : boolean;      (* PTS 1120151 FF 2003-JAN-10 *)
 
BEGIN
(*  PTS 1120151 FF 2003-JAN-10  *)
kb50CheckConsistViewOfTransWithCancel(Trans, ThisTrans, bCancelled);
END;
 
(*  PTS 1120151 FF 2003-JAN-10  *)
(*------------------------------*) 
 
PROCEDURE
      kb50CheckConsistViewOfTransWithCancel (
            VAR Trans      : tgg00_TransContext;
            VAR ThisTrans  : tkb05_TransEntry;
            VAR bCancelled : boolean);
 
BEGIN
Trans.trError_gg00 := e_ok;
IF  ThisTrans.teConsistView_kb05 <> NIL
THEN
    BEGIN
    IF  (ThisTrans.teConsistView_kb05^.cstConsistViewNo_kb05.surrTransId_kb05
        <> Trans.trConsistView_gg00)
        OR
        (ThisTrans.teConsistView_kb05^.cstItemKind_kb05 <> ikConsistView_ekb05)
    THEN
        BEGIN
        vbegexcl (Trans.trTaskId_gg00, g08lock0 + ThisTrans.teOwnRegion_kb05);
        ThisTrans.teConsistView_kb05 := NIL;
        k52flush_trans_entry (ThisTrans);
        vendexcl (Trans.trTaskId_gg00, g08lock0 + ThisTrans.teOwnRegion_kb05)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ThisTrans.teConsistView_kb05 = NIL
THEN
    BEGIN
    vbegexcl (Trans.trTaskId_gg00, g08lock0 + ThisTrans.teOwnRegion_kb05);
    k51FindConsistView (Trans.trTaskId_gg00, Trans.trIndex_gg00,
          Trans.trConsistView_gg00, ThisTrans.teConsistView_kb05);
    k52flush_trans_entry (ThisTrans);
    vendexcl (Trans.trTaskId_gg00, g08lock0 + ThisTrans.teOwnRegion_kb05);
    IF  ThisTrans.teConsistView_kb05 = NIL
    THEN
        Trans.trError_gg00 := e_unknown_consist_vers;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (e_ok = Trans.trError_gg00) AND
    ThisTrans.teConsistView_kb05^.cstCancelled_kb05
THEN
    bCancelled := true
ELSE
    bCancelled := false;
(*ENDIF*) 
IF  ThisTrans.teConsistView_kb05 <> NIL
THEN
    ThisTrans.teConsistView_kb05^.cstTimeLastUsed_kb05 := 0 (* outside consist/tab region *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50CheckObjSelfLocked (
            VAR Trans        : tgg00_TransContext;
            VAR Oid          : tgg00_OidSpace;
            VAR ObjTransInfo : tgg00_ObjTransInfo;
            bIsShareLocked   : boolean);
 
VAR
      CollEntry      : tkb05_ObjCollEntryPtr;
      ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
 
BEGIN
Trans.trError_gg00 := e_ok;
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxLockTrace (Trans, '>kb50Check  ', Oid, ObjTransInfo);
(* BEGIN PTS 1128244 FF 2004-03-18 *)
(*ENDIF*) 
IF  gg06IsZeroTrans (ObjTransInfo.otrLockTransId_gg00)
THEN
    k501IsSelfLocked(Trans, Oid, bIsShareLocked)
          (* END PTS 1128244 FF 2004-03-18 *)
ELSE
    IF  (ObjTransInfo.otrLockTransIndex_gg00 = cgg_nil_transindex)
        OR
        gg06IsNilTrans (ObjTransInfo.otrLockTransId_gg00)
    THEN
        Trans.trError_gg00 := e_object_not_locked
    ELSE
        IF  gg06IsDummyTrans (ObjTransInfo.otrLockTransId_gg00)
        THEN
            (* check collision lock entry *)
            BEGIN
            k52begexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
            k52acc_objcoll_entry (ObjCollGlobPtr^, ObjTransInfo.otrLockTransIndex_gg00, CollEntry);
            IF  g01vtrace.vtrKbLock_gg00
            THEN
                kb50XxxTrace (Trans, '  kb50Check1',
                      CollEntry^.objcLockTransId_kb05,
                      CollEntry^.objcLockTransIndex_kb05);
            (*ENDIF*) 
            IF  (CollEntry^.objcLockTransId_kb05 <> Trans.trWriteTransId_gg00)
                OR
                NOT kb50IsValidCollisionEntry (CollEntry^, Oid)
            THEN
                Trans.trError_gg00 := e_object_not_locked
            ELSE
                (* PTS 1128244 FF 2004-03-18 *)
                BEGIN
                IF  gg06IsNilTrans (CollEntry^.objcLockTransId_kb05)
                THEN
                    BEGIN
                    k501RemoveCollisionEntry (Trans, CollEntry^);
                    kb50_DelUnusedCollisionEntry (ObjCollGlobPtr^, CollEntry);
                    ObjTransInfo.otrLockTransIndex_gg00 := Trans.trIndex_gg00;
                    ObjTransInfo.otrLockTransId_gg00    := Trans.trWriteTransId_gg00;
                    IF  g01vtrace.vtrKbLock_gg00
                    THEN
                        kb50XxxLockTrace (Trans, '  kb50Check2', Oid, ObjTransInfo);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            k52endexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr)
            END
        ELSE
            (* check trans list entry *)
            BEGIN
            IF  g01vtrace.vtrKbLock_gg00
            THEN
                kb50XxxTrace (Trans, '  kb50Check2', ObjTransInfo.otrLockTransId_gg00, -1);
            (*ENDIF*) 
            IF  Trans.trWriteTransId_gg00 <> ObjTransInfo.otrLockTransId_gg00
            THEN
                Trans.trError_gg00 := e_object_not_locked
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDIF*) 
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxLockTrace (Trans, '-kb50Check  ', Oid, ObjTransInfo);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50EnterTransRegion (
            taskid     : tsp00_TaskId;
            transindex : tgg00_TransIndex);
 
BEGIN
vbegexcl (taskid, g08lock0 + k51tr_index_region (transindex));
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50LeaveTransRegion (
            taskid     : tsp00_TaskId;
            transindex : tgg00_TransIndex);
 
BEGIN
vendexcl (taskid, g08lock0 + k51tr_index_region (transindex));
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50eot_check (
            VAR t         : tgg00_TransContext;
            MessType      : tgg00_MessType;
            MessType2     : tgg00_MessType2);
 
VAR
      IsError   : boolean;
      BadInt    : tsp00_Int4;
      ThisTrans : tkb05_TransEntryPtr;
      msg       : tsp00_C24;
 
BEGIN
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    BEGIN
    IsError := false;
    IF  (MessType <> m_commit  ) AND
        (MessType <> m_rollback)
    THEN
        BEGIN
        IF  t.trIndex_gg00 = cgg_nil_transindex
        THEN
            BEGIN
            IsError := true;
            BadInt  := t.trIndex_gg00;
            msg     := 'EOT_CHECK: nil trIndex  '
            END
        ELSE
            BEGIN
            k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
            IF  t.trWriteTransId_gg00 <> ThisTrans^.teWriteTransId_kb05
            THEN
                BEGIN
                IsError := true;
                BadInt  := t.trIndex_gg00;
                msg     := 'EOT_CHECK: wrong WrTrans'
                END
            ELSE
                IF  ThisTrans^.teLockMode_kb05 <> tlmEotExcl_ekb05
                THEN
                    BEGIN
                    IsError := true;
                    BadInt  := ord (ThisTrans^.teLockMode_kb05);
                    msg     := 'EOT_CHECK: not eot excl '
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  IsError
    THEN
        BEGIN
&       ifdef TRACE
        t01messtype  (td_always, '*** MessType', MessType );
        t01mess2type (td_always, '   MessType2', MessType2);
&       endif
        g01abort (kb50c1EotCheck_csp03, csp3_n_lock, msg, BadInt)
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50eot_new_trans (VAR t : tgg00_TransContext);
 
VAR
      TransRegion : tkb05_RegionNo;
      ThisTrans   : tkb05_TransEntryPtr;
 
BEGIN
t.trError_gg00 := e_ok;
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex
ELSE
    BEGIN
    k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        BEGIN
        k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50is_obj_c: bad trIndex', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete)
        END;
    (*ENDIF*) 
    ;
    (* PTS 1103667 JA 1999-09-02 *)
    k51new_select_trans (t.trTaskId_gg00, t.trTransId_gg00);
    gg06SetNilTrans     (t.trWriteTransId_gg00);
    TransRegion := k51tr_index_region (t.trIndex_gg00);
    (* *)
    vbegexcl (t.trTaskId_gg00, g08lock0 + TransRegion);
    k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
    ThisTrans^.teSelectTransId_kb05 := t.trTransId_gg00;
    IF  NOT gg06IsNilTrans (ThisTrans^.teWriteTransId_kb05)
    THEN
        t.trError_gg00 := e_cancelled;
    (*ENDIF*) 
    vendexcl (t.trTaskId_gg00, g08lock0 + TransRegion)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50excl_scan (
            TaskId         : tsp00_TaskId;
            VAR IsEotExcl  : boolean);
 
VAR
      CurrRegion      : tkb05_RegionNo;
      TransCnt        : tsp00_Int4;
      TransLimit      : tsp00_Int4;
      CurrTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
IsEotExcl  := false;
CurrRegion := 1;
REPEAT
    k52begexcl_region (TaskId, CurrRegion, TransRgnGlobPtr);
    IF  (TransRgnGlobPtr^.rglTransGlob_kb05^.trLockTransCnt_kb05    > 0) OR
        (TransRgnGlobPtr^.rglTransGlob_kb05^.trObjLockTransCnt_kb05 > 0)
    THEN
        BEGIN
        TransLimit := k52used_trans_of_region (TransRgnGlobPtr^);
        TransCnt   := 0;
        CurrTrans  := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
        WHILE (CurrTrans <> NIL) AND NOT IsEotExcl AND (TransCnt <= TransLimit) DO
            IF  (CurrTrans^.teLockMode_kb05    = tlmEotExcl_ekb05) OR
                (CurrTrans^.teObjLockMode_kb05 = tlmEotExcl_ekb05)
            THEN
                IsEotExcl := true
            ELSE
                BEGIN
                TransCnt  := TransCnt + 1;
                CurrTrans := CurrTrans^.teNextTrans_kb05
                END;
            (*ENDIF*) 
        (*ENDWHILE*) 
        IF  TransCnt > TransLimit
        THEN
            k52x_loop_error ('k50excl_scan            ', 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    k52endexcl_region (TaskId, TransRgnGlobPtr);
    CurrRegion := CurrRegion + 1
UNTIL
    (CurrRegion > k51glob.glTransRegions_kb05) OR IsEotExcl;
(*ENDREPEAT*) 
&ifdef TRACE
t01bool (kb_lock, 'IsEotExcl   ', IsEotExcl);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      k50GetLogTransaction (TransIndex : tgg00_TransIndex) : tsp00_Addr;
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
(* Logging74 UH new *)
(* outside region *)
&ifdef TRACE
t01int4 (kb_lock, 'TransIndex  ', TransIndex);
&endif
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50GetLogT: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    k50GetLogTransaction := ThisTrans^.teLog_kb05.tlogTransPtr_kb05
    END
ELSE
    k50GetLogTransaction := NIL
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50get_temp_log (
            TransIndex            : tgg00_TransIndex;
            VAR LogFileRoot       : tsp00_PageNo;
            VAR LogCnt            : tsp00_Int4;
            VAR FunctRollb        : tsp00_Int4;
            VAR AuxFileExists     : boolean);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
(* outside lock region *)
&ifdef TRACE
t01int4 (kb_lock, 'TransIndex  ', TransIndex);
&endif
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50get_tem: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    LogFileRoot   := ThisTrans^.teLog_kb05.tlogTempFileRoot_kb05;
    LogCnt        := ThisTrans^.teLog_kb05.tlogTempEntryCnt_kb05;
    FunctRollb    := ThisTrans^.teLog_kb05.tlogTempFunctRollb_kb05;
    AuxFileExists := (tiAuxTempExists_ekb05 in ThisTrans^.teInfo_kb05)
    END
ELSE
    BEGIN
    LogFileRoot   := NIL_PAGE_NO_GG00;
    LogCnt        := 0;
    FunctRollb    := 0;
    AuxFileExists := false
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50hash (
            VAR buf    : tsp00_Buf;
            pos        : tsp00_Int4;
            len        : tsp00_Int4;
            VAR ResBuf : tsp00_Buf;
            ResPos     : integer);
 
VAR
      i         : integer;
      j         : integer;
      maxi      : integer;
      maxj      : integer;
      CurrPos   : integer;
      HashValue : tsp00_Int4;
 
BEGIN
HashValue := 0;
CurrPos   := pos - 1;
maxi      := (len - 1) DIV MAX_HASH_PRIME_GG00 + 1;
FOR i := 1 TO maxi DO
    BEGIN
    IF  i = maxi
    THEN
        maxj := len - (maxi - 1) * MAX_HASH_PRIME_GG00
    ELSE
        maxj := MAX_HASH_PRIME_GG00;
    (*ENDIF*) 
    FOR j := 1 TO maxj DO
        HashValue := HashValue + ord (buf [CurrPos+j] ) * g01hashprime [j];
    (*ENDFOR*) 
    CurrPos := CurrPos + maxj
    END;
(*ENDFOR*) 
s20int4_to_buf_swap (HashValue, g01code.kernel_swap, ResBuf, ResPos, sw_normal)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50hash_rowid (
            VAR RowId          : tkb05_RowId;
            KeyLen             : tsp00_Int2;
            VAR HashValue      : tsp00_Int4);
 
VAR
      i   : integer;
      len : integer;
 
BEGIN
HashValue := 0;
IF  KeyLen < sizeof (RowId)
THEN
    len := KeyLen
ELSE
    len := sizeof (RowId);
(*ENDIF*) 
(* 2  -->  skip defined byte *)
FOR i := 2 TO len DO
    HashValue := HashValue + ord (RowId [i]) * g01hashprime [i]
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50init_wanted_rowid_lock (
            VAR MoveObj    : tsp00_MoveObj;
            MoveObjSize    : tsp00_Int4;
            pos            : tsp00_Int4;
            KeyLen         : integer;
            VAR WantedLock : tkb05_WantedLock;
            VAR MoveError  : tgg00_BasisError);
 
BEGIN
(* PTS 1121179 UH 2003-04-07 rewritten due to new compression methode *)
k51init_wanted_lock (WantedLock);
IF  KeyLen > 0
THEN
    WITH WantedLock DO
        BEGIN
        wlRowWanted_kb05 := true;
        wlKeyLen_kb05    := KeyLen;
        IF  wlKeyLen_kb05 <= sizeof (wlRowId_kb05)
        THEN
            SAPDB_PascalMove ('VKB50 ',   1,    
                  MoveObjSize, sizeof (wlRowId_kb05),
                  @MoveObj, pos, @wlRowId_kb05, 1, wlKeyLen_kb05, MoveError)
        ELSE
            (* The key must be compressed. *)
            (* The first part becomes the last bytes of the key. *)
            (* The hashvalues are generated over the whole key *)
            IF  NOT gg06buildCompressedKey (MoveObj, MoveObjSize, pos, KeyLen,
                sizeof(wlRowId_kb05), wlRowId_kb05)
            THEN
                MoveError := e_move_error;
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50init1_wanted_rowid_lock (
            VAR MoveObj    : tsp00_MoveObj;
            MoveObjSize    : tsp00_Int4;
            pos            : tsp00_Int4;
            KeyLen         : integer;
            VAR WantedLock : tkb05_WantedLock;
            VAR MoveError  : tgg00_BasisError);
 
BEGIN
k50init_wanted_rowid_lock (MoveObj, MoveObjSize, pos, KeyLen, WantedLock, MoveError)
END;
 
(*------------------------------*) 
 
FUNCTION
      kb50IsValidCollisionEntry (
            VAR ObjCollEntry : tkb05_ObjCollisionEntry;
            VAR Oid : tkb05_KernelOid): boolean;
 
BEGIN
&ifdef TRACE
ta01TransNo (kb_lock, 'objcLockTrId', ObjCollEntry.objcLockTransId_kb05);
ta01Oid     (kb_lock, 'objcOid     ', ObjCollEntry.objcOid_kb05);
ta01Oid     (kb_lock, 'Oid         ', Oid);
&endif
(* *)
kb50IsValidCollisionEntry :=
      NOT gg06IsNilTrans (ObjCollEntry.objcLockTransId_kb05) AND
      NOT gg06IsNilOid   (ObjCollEntry.objcOid_kb05)         AND
      gg06IsEqOidPnoPos  (ObjCollEntry.objcOid_kb05, Oid);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50LockObj (VAR Trans : tgg00_TransContext;
            VAR ObjFileNo    : tsp00_C8;
            VAR Oid          : tgg00_OidSpace;
            VAR ObjTransInfo : tgg00_ObjTransInfo;
            ignShrLckCsView  : boolean);
 
VAR
      bCollisionEntryUsed : boolean;
      bShareLockEntryUsed : boolean;                (* PTS 1128244 FF 2004-03-18 *)
      bIgnCollEntry       : boolean;                (* PTS 1128244 FF 2004-03-18 *)
      LockTransRegion     : tkb05_RegionNo;
      OwnTransRegion      : tkb05_RegionNo;
      LockTransIndex      : tgg00_TransIndex;
      CollTransIndex      : tgg00_TransIndex;       (* PTS 1128244 FF 2004-03-18 *)
      CollEntry           : tkb05_ObjCollEntryPtr;
      LockTrans           : tkb05_TransEntryPtr;
      ThisTrans           : tkb05_TransEntryPtr;
      ObjCollGlobPtr      : tkb05_ObjCollGlobPtr;
 
BEGIN
(* object is locked by BD-layer while performing lock object *)
(*       ==> ObjTransInfo can not be updated by other tasks  *)
(*       ==> no other requests are inserted                  *)
(*       ==> locks and requests may be released              *)
(*       ==> requests may be changed into locks              *)
(**)
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxLockTrace (Trans, '>kb50LockObj', Oid, ObjTransInfo);
(*ENDIF*) 
Trans.trError_gg00  := e_ok;
OwnTransRegion      := NIL_REGION_KB05;
bCollisionEntryUsed := false;
bShareLockEntryUsed := false;    (* PTS 1128244 FF 2004-03-18 *)
CollEntry           := NIL;
LockTrans           := NIL;
IF  Trans.trIndex_gg00 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_cancelled
ELSE
    BEGIN
    k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);   (* PTS 1131932 FF 14-OCT-2004 *)
    ThisTrans^.teOmsLockMode_kb05 := tlmExcl_ekb05;       (* PTS 1131932 FF 14-OCT-2004 *)
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        BEGIN
        (* k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans); *)
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'kb50LockObj: bad trIndex', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'kb50LockObj: bad trId   ', ThisTrans^.teOwnIndex_kb05,
              Trans.trWriteTransId_gg00 = ThisTrans^.teWriteTransId_kb05)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
ta01TransNo (kb_lock, 'otrLocktrans', ObjTransInfo.otrLockTransId_gg00);
t01p2int4   (kb_lock, 'otrLockIndex', ObjTransInfo.otrLockTransIndex_gg00
      ,               'TransIndex  ', Trans.trIndex_gg00);
ta01TransNo (kb_lock, 'WriteTransId', Trans.trWriteTransId_gg00);
&endif
IF  (Trans.trError_gg00 = e_ok)
    AND
    gg06IsNilTrans (Trans.trWriteTransId_gg00)
THEN
    BEGIN
    (* PTS 1108234 JA 2000-12-12 *)
    k50new_write_trans (Trans);
    kb51EnableHistoryRetention;  (* PTS 1140530 FF 2006-03-09 *)
    END;
(*ENDIF*) 
;
IF  (Trans.trError_gg00 = e_ok)
    AND
    NOT gg06IsNilTrans (ObjTransInfo.otrLockTransId_gg00)
THEN
    BEGIN
    (* BEGIN PTS 1128244 FF 2004-03-18  -- check if object is share locked  *)
    IF  gg06IsZeroTrans (ObjTransInfo.otrLockTransId_gg00)
    THEN
        BEGIN
        bShareLockEntryUsed := true;
        bIgnCollEntry  := false;
        LockTransIndex := cgg_nil_transindex;
        OwnTransRegion := k51tr_index_region (Trans.trIndex_gg00);
        CollTransIndex := k501GetExclusiveLock (Trans, ObjFileNo, Oid, ignShrLckCsView, bIgnCollEntry);
        IF  (Trans.trError_gg00 = e_object_not_locked)
        THEN
            BEGIN
            (* if not locked, mark objectframe as free *)
            ObjTransInfo.otrLockTransIndex_gg00 := cgg_nil_transindex;
            gg06SetNilTrans (ObjTransInfo.otrLockTransId_gg00);
            bShareLockEntryUsed := false;
            Trans.trError_gg00  := e_ok;
            END;
        (*ENDIF*) 
        END;
    (* END PTS 1128244 FF 2004-03-18  -- check if object is share locked  *)
    (*ENDIF*) 
    IF  NOT bShareLockEntryUsed  (* PTS 1128244 FF 2004-03-18  *)
    THEN
        BEGIN
        bCollisionEntryUsed := gg06IsDummyTrans (ObjTransInfo.otrLockTransId_gg00);
        IF  bCollisionEntryUsed
        THEN
            BEGIN
            LockTransIndex  := cgg_nil_transindex;
            LockTransRegion := NIL_REGION_KB05
            END
        ELSE
            BEGIN
            LockTransIndex  := ObjTransInfo.otrLockTransIndex_gg00;
            LockTransRegion := k51tr_index_region (LockTransIndex)
            END;
        (*ENDIF*) 
        IF  bCollisionEntryUsed
        THEN
            BEGIN
            OwnTransRegion  := k51tr_index_region (Trans.trIndex_gg00);
            vbegexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
            k52begexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
            k52acc_objcoll_entry (ObjCollGlobPtr^, ObjTransInfo.otrLockTransIndex_gg00, CollEntry);
            IF  kb50IsValidCollisionEntry (CollEntry^, Oid)
            THEN
                BEGIN
                IF  CollEntry^.objcLockTransId_kb05 <> Trans.trWriteTransId_gg00
                THEN
                    (* not self locked *)
                    Trans.trError_gg00 := e_lock_collision
                ELSE
                    IF  (CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex)
                    THEN
                        BEGIN
                        (* move Lockinfo to object-header and release collision entry *)
                        ObjTransInfo.otrLockTransId_gg00 := CollEntry^.objcLockTransId_kb05;
                        ObjTransInfo.otrLockTransIndex_gg00 := CollEntry^.objcLockTransIndex_kb05;
                        LockTransIndex  := ObjTransInfo.otrLockTransIndex_gg00;
                        LockTransRegion := k51tr_index_region (LockTransIndex);
                        k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);
                        k501RemoveCollisionEntry (Trans, CollEntry^);
                        k50DelCollisionEntry (ObjCollGlobPtr^, ThisTrans^, CollEntry);
                        bCollisionEntryUsed := false;
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                (* the CollisionEntry is unused => the ObjTransInfo must be used *)
                bCollisionEntryUsed := false; (* PTS 1102611 UH 1999-05-06 *)
                gg06SetNilTrans (ObjTransInfo.otrLockTransId_gg00);
                ObjTransInfo.otrLockTransIndex_gg00 := cgg_nil_transindex;
                LockTransIndex  := ObjTransInfo.otrLockTransIndex_gg00;
                LockTransRegion := k51tr_index_region (LockTransIndex)
                END;
            (*ENDIF*) 
            k52endexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
            vendexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
            END
        ELSE
            IF  NOT gg06IsNilTrans (ObjTransInfo.otrLockTransId_gg00)
                AND
                (LockTransIndex <> Trans.trIndex_gg00)
            THEN
                (* NOT (free OR self locked) *)
                BEGIN
                vbegexcl (Trans.trTaskId_gg00, g08lock0 + LockTransRegion);
                k52acc_trans_entry (LockTransIndex, LockTrans);
                IF  (LockTrans^.teState_kb05 <> m_delete)
                    AND
                    (LockTrans^.teWriteTransId_kb05 = ObjTransInfo.otrLockTransId_gg00)
                THEN
                    Trans.trError_gg00 := e_lock_collision;
                (*ENDIF*) 
                vendexcl (Trans.trTaskId_gg00, g08lock0 + LockTransRegion)
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (Trans.trError_gg00 = e_lock_collision)
        AND
        (Trans.trObjReqTimeout_gg00 > 0)
    THEN
        BEGIN
        ;
        (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
        (* vbegexcl (Trans.trTaskId_gg00, g08cnstview);         PTS 1122885 FF & 1103667 JA 1999-09-02 *)
        kb511EnterConsistView1 (Trans.trTaskId_gg00, false ); (* PTS 1122885 FF 2003-07-01 *)
        (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
        ;
        (* object may be unlocked in the meantime ==> check collision again *)
        Trans.trError_gg00 := e_ok;
        IF  bShareLockEntryUsed  (* PTS 1128244 FF 2004-03-18 *)
        THEN
            BEGIN
            (* if object locked then insert request *)
            bIgnCollEntry := false;
            CollTransIndex := k501GetExclusiveLock(Trans, ObjFileNo, Oid, ignShrLckCsView, bIgnCollEntry);
            IF  (Trans.trError_gg00 = e_object_not_locked)
            THEN
                BEGIN
                (* if not locked, mark objectframe as locked *)
                ObjTransInfo.otrLockTransIndex_gg00 := Trans.trIndex_gg00;
                ObjTransInfo.otrLockTransId_gg00    := Trans.trWriteTransId_gg00;
                Trans.trError_gg00                  := e_ok;
                END
            ELSE
                IF  (CollTransIndex <> cgg_nil_transindex ) OR (Trans.trError_gg00 <> e_ok)
                THEN
                    BEGIN
                    Trans.trError_gg00 := e_ok;
                    OwnTransRegion := k51tr_index_region (Trans.trIndex_gg00);
                    vbegexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
                    k52begexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
                    CollTransIndex := k501GetCollEntryIdx( Trans, Oid);
                    IF  (Trans.trError_gg00 = e_object_not_locked)
                    THEN
                        BEGIN
                        (* if not locked, mark objectframe as locked *)
                        ObjTransInfo.otrLockTransIndex_gg00 := Trans.trIndex_gg00;
                        ObjTransInfo.otrLockTransId_gg00    := Trans.trWriteTransId_gg00;
                        Trans.trError_gg00                  := e_ok;
                        END
                    ELSE
                        IF  CollTransIndex <> cgg_nil_transindex
                        THEN
                            BEGIN
                            k52acc_objcoll_entry (ObjCollGlobPtr^, CollTransIndex, CollEntry);
                            kb50_InsOwnObjRequest (Trans, ObjCollGlobPtr^, CollEntry^, ignShrLckCsView,
                                  false (*NOT OmsShareLock*))
                            END
                        ELSE
                            BEGIN
                            kb50_GetCollisionEntry (Trans, ObjCollGlobPtr^, Oid, CollEntry);
                            IF  Trans.trError_gg00 = e_ok
                            THEN
                                BEGIN
                                CollEntry^.objcObjContHndl_kb05 := ObjFileNo;
                                gg06SetZeroTrans (CollEntry^.objcLockTransId_kb05);
                                k501StoreCollisionEntry (Trans, CollEntry^);
                                kb50_InsOwnObjRequest (Trans, ObjCollGlobPtr^, CollEntry^, ignShrLckCsView,
                                      false (*NOT OmsShareLock*));
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                    (*ENDIF*) 
                    k52endexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
                    vendexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
                    END;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT bShareLockEntryUsed  (* PTS 1128244 FF 2004-03-18 *)
        THEN
            BEGIN
            IF  OwnTransRegion = NIL_REGION_KB05
            THEN
                OwnTransRegion := k51tr_index_region (Trans.trIndex_gg00);
            (*ENDIF*) 
            IF  bCollisionEntryUsed
            THEN
                (* if object locked then insert request *)
                BEGIN
                vbegexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
                k52begexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
                k52acc_objcoll_entry (ObjCollGlobPtr^, ObjTransInfo.otrLockTransIndex_gg00, CollEntry);
                IF  kb50IsValidCollisionEntry (CollEntry^, Oid)
                THEN
                    (* object locked *)
                    kb50_InsOwnObjRequest (Trans, ObjCollGlobPtr^, CollEntry^, ignShrLckCsView,
                          false (*NOT OmsShareLock*))
                ELSE
                    (* lock released in the meantime *)
                    bCollisionEntryUsed := false;
                (*ENDIF*) 
                IF  g01vtrace.vtrKbLock_gg00
                THEN
                    kb50XxxTrace (Trans, '  kb50Lock1 ',
                          CollEntry^.objcLockTransId_kb05,
                          CollEntry^.objcLockTransIndex_kb05);
                (*ENDIF*) 
                k52endexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
                vendexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion)
                END
            ELSE
                (* NOT bCollisionEntryUsed: if object locked then insert collision entry + insert request *)
                BEGIN
                kb50_EnterBothRegions (Trans.trTaskId_gg00, OwnTransRegion, LockTransRegion);
                k52begexcl_objcoll    (Trans.trTaskId_gg00, ObjCollGlobPtr);
                k52acc_trans_entry (LockTransIndex, LockTrans);
                CollEntry := NIL;
                IF  (LockTrans^.teState_kb05 <> m_delete)
                    AND
                    (LockTrans^.teWriteTransId_kb05 = ObjTransInfo.otrLockTransId_gg00)
                THEN
                    (* object locked *)
                    BEGIN
                    kb50_InsCollisionEntry (Trans, ObjCollGlobPtr^,
                          LockTrans^, Oid, ObjFileNo, CollEntry);
                    IF  Trans.trError_gg00 = e_ok
                    THEN
                        BEGIN
                        kb50_InsOwnObjRequest (Trans, ObjCollGlobPtr^, CollEntry^, ignShrLckCsView,
                              false (*NOT OmsShareLock*));
                        IF  Trans.trError_gg00 = e_wait_for_lock_release
                        THEN
                            (* request inserted *)
                            BEGIN
                            bCollisionEntryUsed                 := true;
                            ObjTransInfo.otrLockTransIndex_gg00 := CollEntry^.objcOwnIndex_kb05;
                            gg06SetDummyTrans (ObjTransInfo.otrLockTransId_gg00)
                            END
                        ELSE
                            IF  (Trans.trError_gg00 = e_too_many_lock_requests)
                                AND
                                (CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex)
                            THEN
                                (* ObjTransInfo unchanged --> still refers into trans list *)
                                k50DelCollisionEntry (ObjCollGlobPtr^, LockTrans^, CollEntry)
                            (*ENDIF*) 
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  g01vtrace.vtrKbLock_gg00 AND (CollEntry <> NIL)
                THEN
                    kb50XxxTrace (Trans, '  kb50Lock2 ',
                          CollEntry^.objcLockTransId_kb05,
                          CollEntry^.objcLockTransIndex_kb05);
                (*ENDIF*) 
                k52endexcl_objcoll    (Trans.trTaskId_gg00, ObjCollGlobPtr);
                kb50_LeaveBothRegions (Trans.trTaskId_gg00, OwnTransRegion, LockTransRegion)
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ;
        (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
        (* vendexcl (Trans.trTaskId_gg00, g08cnstview);         PTS 1122885 FF && 1103667 JA 1999-09-02 *)
        kb511LeaveConsistView1 (Trans.trTaskId_gg00, false ); (* PTS 1122885 FF 2003-07-01 *)
        (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
        ;
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (Trans.trError_gg00 = e_ok) AND
    NOT bCollisionEntryUsed AND
    NOT bShareLockEntryUsed
THEN
    BEGIN
    ObjTransInfo.otrLockTransIndex_gg00 := Trans.trIndex_gg00;
    ObjTransInfo.otrLockTransId_gg00    := Trans.trWriteTransId_gg00
    END;
(*ENDIF*) 
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxLockTrace (Trans, '-kb50LockObj', Oid, ObjTransInfo);
(*ENDIF*) 
;
&ifdef TRACE
t01basis_error (kb_lock, 'end kb50Lock', Trans.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE  (* new PTS 1128244 FF 2004-03-18  *)
      kb50LockShareObj (VAR Trans : tgg00_TransContext;
            VAR ObjFileNo    : tsp00_C8;
            VAR Oid          : tgg00_OidSpace (*ptocSynonym tgg92_KernelOid&*);
            VAR ObjTransInfo : tgg00_ObjTransInfo);
 
VAR
      LockTransRegion     : tkb05_RegionNo;
      LockTrans           : tkb05_TransEntryPtr;
      LockTransIndex      : tgg00_TransIndex;
      ThisTrans           : tkb05_TransEntryPtr;
      CollEntry           : tkb05_ObjCollEntryPtr;
      ObjCollGlobPtr      : tkb05_ObjCollGlobPtr;
      OwnTransRegion      : tkb05_RegionNo;         (* PTS 1135179 FF 2005-04-25 *)
      CollTransIndex      : tgg00_TransIndex;       (* PTS 1135179 FF 2005-04-25 *)
      bCollisionEntryUsed : boolean;                (* PTS 1135179 FF 2005-04-25 *)
      bShareLockEntryUsed : boolean;                (* PTS 1135179 FF 2005-04-25 *)
      bIgnCollEntry       : boolean;                (* PTS 1135179 FF 2005-04-25 *)
      AuxUpdTransId       : tgg91_TransNo;          (* PTS 1135179 FF 2005-04-25 *)
 
BEGIN
(* object is locked by BD-layer while performing lock object *)
(*       ==> ObjTransInfo can not be updated by other tasks  *)
(*       ==> no other requests are inserted                  *)
(*       ==> locks and requests may be released              *)
(*       ==> requests may be changed into locks              *)
(**)
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxLockTrace (Trans, '>kb50LockShr', Oid, ObjTransInfo);
(*ENDIF*) 
;
Trans.trError_gg00  := e_ok;
bCollisionEntryUsed := false;  (* PTS 1135179 FF 2005-04-25 *)
bShareLockEntryUsed := false;  (* PTS 1135179 FF 2005-04-25 *)
bIgnCollEntry       := false;  (* PTS 1135179 FF 2005-04-25 *)
gg06SetNilTrans(AuxUpdTransId); (* PTS 1135179 FF 2005-04-25 *)
;
IF  Trans.trIndex_gg00 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_cancelled
ELSE
    BEGIN
    k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);   (* PTS 1131932 FF 14-OCT-2004 *)
    ThisTrans^.teOmsLockMode_kb05 := tlmShare_ekb05;      (* PTS 1131932 FF 14-OCT-2004 *)
    IF  kb03Check.chkTrans_kb00
    THEN
        BEGIN
        k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'kb50LockShr: bad trIndex', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'kb50LockShr: bad trId   ', ThisTrans^.teOwnIndex_kb05,
              Trans.trWriteTransId_gg00 = ThisTrans^.teWriteTransId_kb05)
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
ta01TransNo (kb_lock, 'otrLocktrans', ObjTransInfo.otrLockTransId_gg00);
t01p2int4   (kb_lock, 'otrLockIndex', ObjTransInfo.otrLockTransIndex_gg00
      ,               'TransIndex  ', Trans.trIndex_gg00);
ta01TransNo (kb_lock, 'WriteTransId', Trans.trWriteTransId_gg00);
&endif
;
IF  (Trans.trError_gg00 = e_ok)
    AND
    gg06IsNilTrans (Trans.trWriteTransId_gg00)
THEN
    k50new_write_trans (Trans);
(*ENDIF*) 
;
IF  gg06IsDummyTrans (ObjTransInfo.otrLockTransId_gg00)
THEN
    BEGIN
    bCollisionEntryUsed := true;
    OwnTransRegion := k51tr_index_region (Trans.trIndex_gg00);
    vbegexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
    k52begexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
    k52acc_objcoll_entry (ObjCollGlobPtr^, ObjTransInfo.otrLockTransIndex_gg00, CollEntry);
    IF  kb50IsValidCollisionEntry (CollEntry^, Oid)
    THEN
        BEGIN
        IF  g01vtrace.vtrKbLock_gg00
        THEN
            kb50XxxTrace (Trans, '  kb50LckSh1',
                  CollEntry^.objcLockTransId_kb05,
                  CollEntry^.objcLockTransIndex_kb05);
        (*ENDIF*) 
        IF  (CollEntry^.objcLockTransIndex_kb05 = Trans.trIndex_gg00)
            AND
            (CollEntry^.objcLockTransId_kb05 = Trans.trWriteTransId_gg00)
        THEN
            BEGIN
            (* move Lockinfo to object-header and release collision entry *)
            ObjTransInfo.otrLockTransId_gg00 := CollEntry^.objcLockTransId_kb05;
            ObjTransInfo.otrLockTransIndex_gg00 := CollEntry^.objcLockTransIndex_kb05;
            k501GetShareLock(Trans, ObjFileNo, ObjTransInfo, Oid, bIgnCollEntry);
            k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);
            IF  (CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex)
            THEN
                BEGIN
                k501RemoveCollisionEntry (Trans, CollEntry^);
                k50DelCollisionEntry (ObjCollGlobPtr^, ThisTrans^, CollEntry);
                END
            ELSE
                BEGIN
                k501StoreCollisionEntry (Trans, CollEntry^);
                kb50_RemoveCollEntryFromTransCollList (ObjCollGlobPtr^, ThisTrans^, CollEntry^);
                k50SatisfyNextWaitingObjRequest (ObjCollGlobPtr^, CollEntry^, AuxUpdTransId, ONLY_SHARE_REQ)
                END
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            LockTransIndex := CollEntry^.objcLockTransIndex_kb05;
            k52acc_trans_entry (LockTransIndex, ThisTrans);
            IF  (ThisTrans^.teState_kb05 <> m_delete)
                AND
                (ThisTrans^.teWriteTransId_kb05 = CollEntry^.objcLockTransId_kb05)
            THEN
                Trans.trError_gg00 := e_lock_collision;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    k52endexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
    vendexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
    ;
    IF  (Trans.trError_gg00 = e_ok)
    THEN
        BEGIN
        (* mark object frame as 'not locked' *)
        ObjTransInfo.otrLockTransIndex_gg00 := cgg_nil_transindex;
        gg06SetNilTrans (ObjTransInfo.otrLockTransId_gg00);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
IF  (Trans.trError_gg00 = e_ok)
    AND
    (ObjTransInfo.otrLockTransIndex_gg00 <> cgg_nil_transindex)
    AND
    NOT gg06IsNilTrans (ObjTransInfo.otrLockTransId_gg00)
THEN
    BEGIN
    IF  ObjTransInfo.otrLockTransIndex_gg00 <> Trans.trIndex_gg00
    THEN
        (* NOT (free OR self locked) *)
        BEGIN
        LockTransIndex  := ObjTransInfo.otrLockTransIndex_gg00;
        LockTransRegion := k51tr_index_region (LockTransIndex);
        vbegexcl (Trans.trTaskId_gg00, g08lock0 + LockTransRegion);
        k52acc_trans_entry (LockTransIndex, LockTrans);
        IF  (LockTrans^.teState_kb05 <> m_delete)
            AND
            (LockTrans^.teWriteTransId_kb05 = ObjTransInfo.otrLockTransId_gg00)
        THEN
            Trans.trError_gg00 := e_lock_collision;
        (*ENDIF*) 
        vendexcl (Trans.trTaskId_gg00, g08lock0 + LockTransRegion)
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
;
IF  (Trans.trError_gg00 = e_ok)
THEN
    k501GetShareLock(Trans, ObjFileNo, ObjTransInfo, Oid, bIgnCollEntry);
(*ENDIF*) 
;
IF  (Trans.trError_gg00 = e_lock_collision)
    AND
    (Trans.trObjReqTimeout_gg00 > 0)
THEN
    BEGIN
    ;
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    kb511EnterConsistView1 (Trans.trTaskId_gg00, false );
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    ;
    (* object may be unlocked in the meantime ==> check collision again *)
    Trans.trError_gg00 := e_ok;
    OwnTransRegion := k51tr_index_region (Trans.trIndex_gg00);
    bShareLockEntryUsed :=  gg06IsZeroTrans (ObjTransInfo.otrLockTransId_gg00);
    IF  bCollisionEntryUsed
    THEN
        BEGIN
        vbegexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
        k52begexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
        k52acc_objcoll_entry (ObjCollGlobPtr^, ObjTransInfo.otrLockTransIndex_gg00, CollEntry);
        IF  kb50IsValidCollisionEntry (CollEntry^, Oid)
        THEN
            (* object locked *)
            kb50_InsOwnObjRequest (Trans, ObjCollGlobPtr^, CollEntry^, false (*ignShrLckCsView*),
                  true (*OmsShareLock*))
        ELSE
            BEGIN
            k501GetShareLock(Trans, ObjFileNo, ObjTransInfo, Oid, bIgnCollEntry);
            IF  (Trans.trError_gg00 <> e_ok)
            THEN
                BEGIN
                kb50_GetCollisionEntry (Trans, ObjCollGlobPtr^, Oid, CollEntry);
                IF  Trans.trError_gg00 = e_ok
                THEN
                    BEGIN
                    CollEntry^.objcObjContHndl_kb05 := ObjFileNo;
                    gg06SetZeroTrans (CollEntry^.objcLockTransId_kb05);
                    k501StoreCollisionEntry (Trans, CollEntry^);
                    kb50_InsOwnObjRequest (Trans, ObjCollGlobPtr^, CollEntry^, false (*ignShrLckCsView*),
                          true (*OmsShareLock*));
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        k52endexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
        vendexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
        END
    ELSE
        IF  NOT bShareLockEntryUsed
        THEN
            BEGIN
            kb50_EnterBothRegions (Trans.trTaskId_gg00, OwnTransRegion, LockTransRegion);
            k52begexcl_objcoll    (Trans.trTaskId_gg00, ObjCollGlobPtr);
            k52acc_trans_entry (LockTransIndex, LockTrans);
            CollEntry := NIL;
            IF  (LockTrans^.teState_kb05 <> m_delete)
                AND
                (LockTrans^.teWriteTransId_kb05 = ObjTransInfo.otrLockTransId_gg00)
            THEN
                (* object locked *)
                BEGIN
                kb50_InsCollisionEntry (Trans, ObjCollGlobPtr^,
                      LockTrans^, Oid, ObjFileNo, CollEntry);
                IF  Trans.trError_gg00 = e_ok
                THEN
                    BEGIN
                    kb50_InsOwnObjRequest (Trans, ObjCollGlobPtr^, CollEntry^, false (*ignShrLckCsView*),
                          true (*OmsShareLock*));
                    IF  Trans.trError_gg00 = e_wait_for_lock_release
                    THEN
                        (* request inserted *)
                        BEGIN
                        bCollisionEntryUsed                 := true;
                        ObjTransInfo.otrLockTransIndex_gg00 := CollEntry^.objcOwnIndex_kb05;
                        gg06SetDummyTrans (ObjTransInfo.otrLockTransId_gg00)
                        END
                    ELSE
                        IF  (Trans.trError_gg00 = e_too_many_lock_requests)
                            AND
                            (CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex)
                        THEN
                            (* ObjTransInfo unchanged --> still refers into trans list *)
                            k50DelCollisionEntry (ObjCollGlobPtr^, LockTrans^, CollEntry)
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            ELSE
                k501GetShareLock(Trans, ObjFileNo, ObjTransInfo, Oid, bIgnCollEntry);
            (*ENDIF*) 
            k52endexcl_objcoll    (Trans.trTaskId_gg00, ObjCollGlobPtr);
            kb50_LeaveBothRegions (Trans.trTaskId_gg00, OwnTransRegion, LockTransRegion)
            END
        ELSE
            BEGIN
            k501GetShareLock(Trans, ObjFileNo, ObjTransInfo, Oid, bIgnCollEntry);
            IF  (Trans.trError_gg00 <> e_ok)
            THEN
                BEGIN
                Trans.trError_gg00 := e_ok;
                OwnTransRegion := k51tr_index_region (Trans.trIndex_gg00);
                vbegexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
                k52begexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
                CollTransIndex := k501GetCollEntryIdx( Trans, Oid);
                IF  CollTransIndex <> cgg_nil_transindex
                THEN
                    BEGIN
                    k52acc_objcoll_entry (ObjCollGlobPtr^, CollTransIndex, CollEntry);
                    IF  kb50IsValidCollisionEntry (CollEntry^, Oid)
                    THEN
                        kb50_InsOwnObjRequest (Trans, ObjCollGlobPtr^, CollEntry^, false (*ignShrLckCsView*),
                              true (*OmsShareLock*))
                    ELSE
                        BEGIN
                        k501RemoveCollisionEntry (Trans, CollEntry^);
                        k501GetShareLock(Trans, ObjFileNo, ObjTransInfo, Oid, bIgnCollEntry);
                        IF  (Trans.trError_gg00 <> e_ok)
                        THEN
                            CollTransIndex := cgg_nil_transindex;
                        (*ENDIF*) 
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  CollTransIndex = cgg_nil_transindex
                THEN
                    BEGIN
                    kb50_GetCollisionEntry (Trans, ObjCollGlobPtr^, Oid, CollEntry);
                    IF  Trans.trError_gg00 = e_ok
                    THEN
                        BEGIN
                        CollEntry^.objcObjContHndl_kb05 := ObjFileNo;
                        gg06SetZeroTrans (CollEntry^.objcLockTransId_kb05);
                        k501StoreCollisionEntry (Trans, CollEntry^);
                        kb50_InsOwnObjRequest (Trans, ObjCollGlobPtr^, CollEntry^, false (*ignShrLckCsView*),
                              true (*OmsShareLock*));
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                k52endexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
                vendexcl (Trans.trTaskId_gg00, g08lock0 + OwnTransRegion);
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    ;
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    kb511LeaveConsistView1 (Trans.trTaskId_gg00, false );
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    ;
    END;
(*ENDIF*) 
;
IF  (Trans.trError_gg00 = e_ok)
THEN
    BEGIN
    ObjTransInfo.otrLockTransIndex_gg00 := cgg_nil_transindex;
    gg06SetZeroTrans (ObjTransInfo.otrLockTransId_gg00);
    END;
(*ENDIF*) 
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxLockTrace (Trans, '-kb50LockShr', Oid, ObjTransInfo);
(*ENDIF*) 
;
&ifdef TRACE
t01basis_error (kb_lock, 'end kb50Lock', Trans.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50my_state (
            TransIndex        : tgg00_TransIndex;
            VAR IsEotExcl     : boolean;
            VAR AuxPermExists : boolean;
            VAR TransTaskId   : tsp00_TaskId);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
(* outside lock region *)
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50my_stat: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    IsEotExcl     := (ThisTrans^.teLockMode_kb05 = tlmEotExcl_ekb05);
    AuxPermExists := (tiAuxPermExists_ekb05 in ThisTrans^.teInfo_kb05);
    TransTaskId   := ThisTrans^.teTaskId_kb05
    END
ELSE
    BEGIN
    IsEotExcl     := false;
    AuxPermExists := false;
    TransTaskId   := cgg_nil_pid
    END;
(*ENDIF*) 
&ifdef TRACE
t01bool (kb_lock, 'IsEotExcl   ', IsEotExcl);
t01bool (kb_lock, 'AuxPermExist', AuxPermExists);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50new_write_trans (VAR Trans : tgg00_TransContext);
 
VAR
      TransRegion : tkb05_RegionNo;
      ThisTrans   : tkb05_TransEntryPtr;
 
BEGIN
(* check existence of log context *)
g01check (kb50cWrongTransIndex_csp03,
      csp3_n_lock,
      'K50new_w_tr: no logContx', 0,
      Trans.trLogContext_gg00 <> NIL);
(* *)
g01check (kbMsg_csp03, csp3_n_lock, 'Req. WriteTrns  Not Redo',
      Trans.trIndex_gg00, NOT gg999KernelStateIsRedoLogProcessing);
(* *)
(* PTS 1108234 JA 2000-12-12 *)
Trans.trError_gg00 := e_ok;
IF  Trans.trIndex_gg00 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_nil_transindex
ELSE
    BEGIN
    k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        BEGIN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50is_obj_c: bad trIndex', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50is_obj_c: bad trId   ', ThisTrans^.teOwnIndex_kb05,
              gg06IsNilTrans (Trans.trWriteTransId_gg00))
        END;
    (*ENDIF*) 
    ;
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    (*vbegexcl (Trans.trTaskId_gg00, g08cnstview);     PTS 1122885 FF & 1111557 TS 2001-08-30 *)
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    (* k57new_write_trans (Trans.trTaskId_gg00, Trans.trWriteTransId_gg00); PTS 1122885 FF *)
    TransRegion := k51tr_index_region (Trans.trIndex_gg00);
    (* *)
    vbegexcl (Trans.trTaskId_gg00, g08lock0 + TransRegion);
    k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);
    IF  NOT gg06IsNilTrans (ThisTrans^.teWriteTransId_kb05)
    THEN
        Trans.trError_gg00 := e_cancelled
    ELSE
        BEGIN
        k57new_write_trans (Trans.trTaskId_gg00, ThisTrans^.teWriteTransId_kb05); (* PTS 1122885 FF *)
        Trans.trWriteTransId_gg00 := ThisTrans^.teWriteTransId_kb05;        (* PTS 1122885 FF *)
        (* ThisTrans^.teWriteTransId_kb05 := Trans.trWriteTransId_gg00;        PTS 1122885 FF *)
        ThisTrans^.teLog_kb05.tlogTransPtr_kb05 := Trans.trLogContext_gg00; (* Logging74 UH *)
        IF  Trans.trError_gg00 = e_ok
        THEN
            k512MonRestartTransaction(ThisTrans^.teExtTransMonPtr_kb05);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    vendexcl (Trans.trTaskId_gg00, g08lock0 + TransRegion);
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    (*vendexcl (Trans.trTaskId_gg00, g08cnstview);      PTS 1122885 FF & PTS 1111557 TS 2001-08-30 *)
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
&   ifdef TRACE
    ta01TransNo (kb_lock, 'WriteTransId', Trans.trWriteTransId_gg00);
&   endif
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50not_connected (VAR m : tgg00_MessBlock);
 
VAR
      CurrRegion      : tkb05_RegionNo;
      DataPos         : tsp00_Int4;
      TransCnt        : tsp00_Int4;
      TransLimit      : tsp00_Int4;
      CheckId         : tgg00_UserId;
      CurrTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
DataPos := 1;
m.mb_trns^.trError_gg00 := e_ok;
REPEAT
    SAPDB_PascalMove ('VKB50 ',   2,    
          m.mb_data_size, sizeof (CheckId),
          @m.mb_data^.mbp_buf, DataPos, @CheckId, 1, sizeof (CheckId),
          m.mb_trns^.trError_gg00);
    CurrRegion := 1;
    REPEAT
        k52begexcl_region (m.mb_trns^.trTaskId_gg00, CurrRegion, TransRgnGlobPtr);
        TransLimit := k52used_trans_of_region (TransRgnGlobPtr^);
        TransCnt   := 0;
        CurrTrans  := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
        WHILE (CurrTrans <> NIL) AND (m.mb_trns^.trError_gg00 = e_ok) AND (TransCnt <= TransLimit) DO
            IF  CurrTrans^.teUserId_kb05 = CheckId
            THEN
                m.mb_trns^.trError_gg00 := e_alter_drop_user_not_allowed
            ELSE
                BEGIN
                TransCnt  := TransCnt + 1;
                CurrTrans := CurrTrans^.teNextTrans_kb05
                END;
            (*ENDIF*) 
        (*ENDWHILE*) 
        k52endexcl_region (m.mb_trns^.trTaskId_gg00, TransRgnGlobPtr);
        IF  TransCnt > TransLimit
        THEN
            k52x_loop_error ('k50not_connected        ', 1);
        (*ENDIF*) 
        CurrRegion := CurrRegion + 1
    UNTIL
        (CurrRegion > k51glob.glTransRegions_kb05) OR (m.mb_trns^.trError_gg00 <> e_ok);
    (*ENDREPEAT*) 
    DataPos := DataPos + sizeof (CheckId);
UNTIL
    (DataPos > m.mb_data_len) OR (m.mb_trns^.trError_gg00 <> e_ok);
(*ENDREPEAT*) 
m.mb_type  := m_return_error;
m.mb_type2 := mm_nil
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50ObjConsistentCheck (
            VAR Trans       : tgg00_TransContext;
            VAR UpdTransId  : tgg91_TransNo;
            VAR bConsistent : boolean;
            VAR bCancelled  : boolean); (* PTS 1120151 FF 2003-JAN-10 *)
 
VAR
      EntryCnt      : tsp00_Int4;
      CurrOpenIndex : integer;
      ConsistView   : tkb05_ConsistViewPtr;
      CurrOpenEntry : tkb05_OpenTransPtr;
      ThisTrans     : tkb05_TransEntryPtr;
 
BEGIN
(* outside lock region *)
&ifdef TRACE
ta01TransNo (kb_log, 'UpdTransId  ', UpdTransId);
ta01TransNo (kb_log, 'trWriteTrans', Trans.trWriteTransId_gg00);
&endif
Trans.trError_gg00 := e_ok;
bConsistent        := false;
bCancelled         := false;        (* PTS 1120151 FF 2003-JAN-10 *)
ConsistView        := NIL;          (* PTS 1120151 FF 2003-JAN-10 *)
IF  Trans.trIndex_gg00 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_nil_transindex
ELSE
    BEGIN
    k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50is_obj_c: bad trIndex', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    IF  NOT gg06IsNilTrans (Trans.trConsistView_gg00)
    THEN
        (* PTS 1120151 FF 2003-JAN-10 *)
        kb50CheckConsistViewOfTransWithCancel (Trans, ThisTrans^, bCancelled);
    (*ENDIF*) 
    ConsistView := ThisTrans^.teConsistView_kb05;
&   ifdef TRACE
    IF  ConsistView <> NIL
    THEN
        BEGIN
        ta01TransNo (kb_log, 'ConsistView ', ConsistView^.cstConsistViewNo_kb05.surrTransId_kb05);
        ta01TransNo (kb_log, 'MinOpenTrans', ConsistView^.cstMinOpenTransId_kb05)
        END;
&   endif
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  Trans.trError_gg00 = e_ok
THEN
    BEGIN
    (* PTS 1125503 only if trans is creator of consistent view, it may see it's own *)
    (*             data modifications                                               *)
    IF  ((UpdTransId = Trans.trWriteTransId_gg00) AND
        (ConsistView <> NIL) AND                                      (* PTS 1125503 FF 2003-11-19 *)
        (ConsistView^.cstCreatorTransId_kb05 = Trans.trTransId_gg00)) (* PTS 1125503 FF 2003-11-19 *)
        OR
        gg06IsNilTrans (UpdTransId) (* PTS 1001206 JA 1998-07-09 *)
    THEN
        bConsistent := true
    ELSE
        IF  ConsistView <> NIL
        THEN
            BEGIN
            IF  ConsistView^.cstItemKind_kb05 <> ikConsistView_ekb05
            THEN
                k52x_item_error ('kb50ObjConsistentCheck/1', ConsistView^.cstItemKind_kb05);
            (*ENDIF*) 
            IF  UpdTransId.ci6_gg00 < ConsistView^.cstConsistViewNo_kb05.surrTransId_kb05.ci6_gg00
                (*                                                      PTS 1105435 JA 2000-02-01 *)
            THEN
                (* may be consistent *)
                BEGIN
                IF  UpdTransId.ci6_gg00 < ConsistView^.cstMinOpenTransId_kb05.ci6_gg00
                    (*                                                  PTS 1105435 JA 2000-02-01 *)
                THEN
                    bConsistent := true  (* not in open_trans_list *)
                ELSE
                    (* UpdTrans started between MinOpenTrans and start of ConsistView *)
                    BEGIN
                    bConsistent   := true;
                    EntryCnt      := 0;
                    CurrOpenEntry := ConsistView^.cstFirstOpenTrans_kb05;
                    WHILE (CurrOpenEntry <> NIL) AND bConsistent
                          AND
                          (EntryCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
                        BEGIN
                        IF  CurrOpenEntry^.openItemKind_kb05 <> ikOpenTrans_ekb05
                        THEN
                            k52x_item_error ('kb50ObjConsistentCheck/2', ConsistView^.cstItemKind_kb05);
                        (*ENDIF*) 
                        CurrOpenIndex := 1;
                        WHILE (CurrOpenIndex <= CurrOpenEntry^.openCount_kb05) AND bConsistent
                              AND
                              (CurrOpenIndex <= TRANS_PER_OPEN_ENTRY_KB05) (* security *) DO
                            BEGIN
&                           ifdef TRACE
                            ta01TransNo (kb_lock, 'OpenTrnsId  ',
                                  CurrOpenEntry^.openTransId_kb05 [CurrOpenIndex]);
&                           endif
                            IF  UpdTransId = CurrOpenEntry^.openTransId_kb05 [CurrOpenIndex]
                            THEN
                                bConsistent := false;
                            (*ENDIF*) 
                            CurrOpenIndex := CurrOpenIndex + 1
                            END;
                        (*ENDWHILE*) 
                        EntryCnt      := EntryCnt + 1;
                        CurrOpenEntry := CurrOpenEntry^.openNext_kb05
                        END;
                    (*ENDWHILE*) 
                    IF  EntryCnt > k51glob.glMaxItemsPerRegion_kb05
                    THEN
                        k52x_loop_error ('kb50ObjConsistentCheck  ', 1)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
t01bool (kb_lock, 'bConsistent ', bConsistent);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      k50oms_have_obj_locks (TransIndex : tgg00_TransIndex) : boolean;
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
(* PTS 1001485 UH 19980910 *)
(* outside region *)
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    k50oms_have_obj_locks := ThisTrans^.teObjLockMode_kb05 = tlmEotExcl_ekb05
    END
ELSE
    k50oms_have_obj_locks := false
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50put_temp_log (
            TransIndex     : tgg00_TransIndex;
            VAR TransState : tgg00_TransState;
            LogFileRoot    : tsp00_PageNo;
            LogCnt         : tsp00_Int4;
            AuxFileExists  : boolean);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
(* outside lock region *)
&ifdef TRACE
t01int4 (kb_lock, 'TransIndex  ', TransIndex);
&endif
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50put_tem: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    WITH ThisTrans^.teLog_kb05 DO
        BEGIN
        IF  NOT (tsFunctRollbSet_egg00 in TransState)
        THEN
            BEGIN
            TransState := TransState + [tsFunctRollbSet_egg00];
            tlogTempFunctRollb_kb05  := tlogTempEntryCnt_kb05;
            END;
        (*ENDIF*) 
        tlogTempFileRoot_kb05 := LogFileRoot;
        tlogTempEntryCnt_kb05 := LogCnt;
        IF  AuxFileExists
        THEN
            ThisTrans^.teInfo_kb05 := ThisTrans^.teInfo_kb05 + [tiAuxTempExists_ekb05]
        ELSE
            IF  NOT AuxFileExists
            THEN
                ThisTrans^.teInfo_kb05 := ThisTrans^.teInfo_kb05 - [tiAuxTempExists_ekb05];
            (*ENDIF*) 
        (*ENDIF*) 
        IF  LogCnt = 0
        THEN
            tlogTempFunctRollb_kb05 := 0
        (*ENDIF*) 
        END
    (*ENDWITH*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50RemoveObjLocks (
            TaskId        : tsp00_TaskId;
            VAR ThisTrans : tkb05_TransEntry);
 
VAR
      CurrLock       : tgg00_TransIndex;
      NextLock       : tgg00_TransIndex;
      ItemCnt        : tsp00_Int4;
      CollEntry      : tkb05_ObjCollEntryPtr;
      ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
      AuxUpdTransId  : tgg91_TransNo;          (* PTS 1135179 FF 2005-04-25 *)
 
BEGIN
k52begexcl_objcoll (TaskId, ObjCollGlobPtr);
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    g08excl_check (TaskId, g08lock0 + ThisTrans.teOwnRegion_kb05);
(*ENDIF*) 
IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
          'kb50RemoveO: bad trIndex', ThisTrans.teOwnIndex_kb05,
          ThisTrans.teState_kb05 <> m_delete);
(*ENDIF*) 
gg06SetNilTrans(AuxUpdTransId); (* PTS 1135179 FF 2005-04-25 *)
CurrLock := ThisTrans.teFirstCollLock_kb05;
ItemCnt  := 0;
WHILE (CurrLock <> cgg_nil_transindex) AND (ItemCnt <= k51glob.glTransEntries_kb05) DO
    BEGIN
    k52acc_objcoll_entry (ObjCollGlobPtr^, CurrLock, CollEntry);
    NextLock := CollEntry^.objcNextCollLock_kb05;
    (* *)
    IF  CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex
    THEN
        BEGIN
        (* remove collision entry; alter ObjTransInfo not necessary *)
        k50DelCollisionEntry (ObjCollGlobPtr^, ThisTrans, CollEntry);
        END
    ELSE
        BEGIN
        kb50_RemoveCollEntryFromTransCollList (ObjCollGlobPtr^, ThisTrans, CollEntry^);
        k50SatisfyNextWaitingObjRequest (ObjCollGlobPtr^, CollEntry^, AuxUpdTransId, ALL_REQ)
        END;
    (*ENDIF*) 
    ItemCnt  := ItemCnt + 1;
    CurrLock := NextLock
    END;
(*ENDWHILE*) 
k52endexcl_objcoll (TaskId, ObjCollGlobPtr);
IF  ItemCnt > k51glob.glTransEntries_kb05
THEN
    k52x_loop_error ('kb50RemoveObjLocks      ', 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50GetLocalFileDir (
            TransIndex  : tgg00_TransIndex;
            VAR filedir : tsp00_Addr);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
(* outside region *)
&ifdef TRACE
t01int4 (kb_lock, 'TransIndex  ', TransIndex);
&endif
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50GetLogT: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    filedir := ThisTrans^.teLocalFileDirPtr_kb05
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50RegisterTransaction (
            TransIndex        : tgg00_TransIndex;
            LocalTransContext : tsp00_Addr);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
(* Logging74 UH new *)
(* outside region *)
&ifdef TRACE
t01int4 (kb_lock, 'TransIndex  ', TransIndex);
&endif
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50GetLogT: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    ThisTrans^.teLog_kb05.tlogTransPtr_kb05 := LocalTransContext
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50set_redo_process_id (
            TaskId     : tsp00_TaskId;
            TransIndex : tgg00_TransIndex);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
(* outside region *)
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50set_pid: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    ThisTrans^.teTaskId_kb05 := TaskId
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50StartDbProcedure (VAR t : tgg00_TransContext);
 
VAR
      ThisTrans           : tkb05_TransEntryPtr;
      TransRegionGlobPtr  : tkb05_RegionGlobPtr;
 
BEGIN
(* PTS 1107002 2000-06-21 UH renamed from k50oms_wait_checkpoint *)
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex
ELSE
    (* PTS 1110237 E.Z. *)
    t.trError_gg00 := e_ok;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
    THEN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'K50StartDbP: bad trIndex', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    IF  (ThisTrans^.teLockMode_kb05    <> tlmEotExcl_ekb05)
        AND
        (ThisTrans^.teObjLockMode_kb05 <> tlmEotExcl_ekb05)
    THEN
        BEGIN
        k52begexcl_region (t.trTaskId_gg00, ThisTrans^.teOwnRegion_kb05,
              TransRegionGlobPtr);
        ThisTrans^.teObjLockMode_kb05 := tlmEotExcl_ekb05;
        WITH TransRegionGlobPtr^.rglTransGlob_kb05^ DO
            trObjLockTransCnt_kb05 := trObjLockTransCnt_kb05 + 1;
        (*ENDWITH*) 
        k52flush_trans_glob  (TransRegionGlobPtr^.rglTransGlob_kb05^);
        k52flush_trans_entry (ThisTrans^);
        k52endexcl_region (t.trTaskId_gg00, TransRegionGlobPtr);
        END;
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50transindex_check (VAR t : tgg00_TransContext);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
IF  t.trIndex_gg00 <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
    IF  ThisTrans^.teWriteTransId_kb05 <> t.trWriteTransId_gg00
    THEN
        BEGIN
&       ifdef TRACE
        ta01TransNo (kb_lock, 'teWriteTrans', ThisTrans^.teWriteTransId_kb05);
        ta01TransNo (kb_lock, 'trWriteTrans', t.trWriteTransId_gg00);
&       endif
        IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-10-11 *)
        THEN
            g01abort (kbMsg_csp03, csp3_n_lock,
                  'K50transin: bad trIndex ', t.trIndex_gg00);
        (*ENDIF*) 
        t.trIndex_gg00 := cgg_nil_transindex
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50UnlockObj (TaskId  : tsp00_TaskId;
            VAR WriteTransId : tgg91_TransNo;
            TransIndex       : tgg00_TransIndex;
            VAR Oid          : tgg00_OidSpace;
            VAR ObjTransInfo : tgg00_ObjTransInfo);
 
VAR
      TransRegion    : tkb05_RegionNo;
      ThisTrans      : tkb05_TransEntryPtr;
      CollEntry      : tkb05_ObjCollEntryPtr;
      ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
      AuxUpdTransId  : tgg91_TransNo;          (* PTS 1135179 FF 2005-04-25 *)
 
BEGIN
(* object is locked by BD-layer while performing unlock object *)
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxLockTrace2 ('>kb50Unlock ', Oid, ObjTransInfo);
(*ENDIF*) 
IF  (TransIndex <> cgg_nil_transindex)
    AND
    NOT gg06IsNilTrans (WriteTransId)
THEN
    BEGIN
    gg06SetNilTrans(AuxUpdTransId); (* PTS 1135179 FF 2005-04-25 *)
    TransRegion := k51tr_index_region (TransIndex);
    vbegexcl (TaskId, g08lock0 + TransRegion);
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00                                      (* PTS 1103957 JA 1999-10-11 *)
    THEN
        BEGIN
        g01check (kb51cWrongTransindex_csp03, csp3_n_lock,
              'kb50UnlObj: bad trIndex ', TransIndex, ThisTrans^.teState_kb05 <> m_delete);
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'kb50UnlObj: bad trId    ', TransIndex,
              WriteTransId = ThisTrans^.teWriteTransId_kb05)
        END;
    (*ENDIF*) 
    IF  (ObjTransInfo.otrUpdTransId_gg00 <> WriteTransId)
    THEN
        (* object not updated by this trans --> if locked by this trans then unlock *)
        BEGIN
        IF  gg06IsDummyTrans (ObjTransInfo.otrLockTransId_gg00)
        THEN
            (* collision lock entry *)
            BEGIN
            k52begexcl_objcoll (TaskId, ObjCollGlobPtr);
            k52acc_objcoll_entry (ObjCollGlobPtr^, ObjTransInfo.otrLockTransIndex_gg00, CollEntry);
            IF  (CollEntry^.objcLockTransId_kb05 = WriteTransId)
                AND
                kb50IsValidCollisionEntry (CollEntry^, Oid)
            THEN
                (* locked by this trans --> unlock *)
                BEGIN
                IF  CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex
                THEN
                    BEGIN
                    k50DelCollisionEntry (ObjCollGlobPtr^, ThisTrans^, CollEntry);
                    ObjTransInfo.otrLockTransIndex_gg00 := cgg_nil_transindex;
                    gg06SetNilTrans (ObjTransInfo.otrLockTransId_gg00)
                    END
                ELSE
                    BEGIN
                    kb50_RemoveCollEntryFromTransCollList (ObjCollGlobPtr^, ThisTrans^, CollEntry^);
                    k50SatisfyNextWaitingObjRequest (ObjCollGlobPtr^, CollEntry^, AuxUpdTransId, ALL_REQ)
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            k52endexcl_objcoll (TaskId, ObjCollGlobPtr)
            END
        ELSE
            (* PTS 1128244 FF 2004-03-18 *)
            IF  gg06IsZeroTrans (ObjTransInfo.otrLockTransId_gg00)
            THEN
                BEGIN
                k501Unlock(ThisTrans^, Oid, IS_EXCL_LOCK);
                END
            ELSE
                (* trans list entry *)
                IF  (ObjTransInfo.otrLockTransId_gg00 = WriteTransId)
                    AND
                    NOT gg06IsNilTrans (ObjTransInfo.otrLockTransId_gg00)
                THEN
                    (* locked by this trans --> unlock *)
                    BEGIN
                    ObjTransInfo.otrLockTransIndex_gg00 := cgg_nil_transindex;
                    gg06SetNilTrans (ObjTransInfo.otrLockTransId_gg00)
                    END
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    vendexcl (TaskId, g08lock0 + TransRegion)
    END;
(*ENDIF*) 
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxLockTrace2 ('-kb50Unlock ', Oid, ObjTransInfo);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE  (* new PTS 1128244 FF 2004-03-18 *)
      kb50UnlockShareObj (
            TaskId           : tsp00_TaskId;
            VAR WriteTransId : tgg91_TransNo;
            TransIndex       : tgg00_TransIndex;
            VAR Oid          : tgg00_OidSpace;
            VAR ObjTransInfo : tgg00_ObjTransInfo);
 
VAR
      TransRegion    : tkb05_RegionNo;
      ThisTrans      : tkb05_TransEntryPtr;
      CollEntry      : tkb05_ObjCollEntryPtr;
      ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
      AuxUpdTransId  : tgg91_TransNo;          (* PTS 1135179 FF 2005-04-25 *)
 
BEGIN
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxLockTrace2 ('>k50UnlckShr', Oid, ObjTransInfo);
(*ENDIF*) 
;
gg06SetNilTrans(AuxUpdTransId); (* PTS 1135179 FF 2005-04-25 *)
TransRegion        := k51tr_index_region (TransIndex);
vbegexcl (TaskId, g08lock0 + TransRegion);
k52acc_trans_entry (TransIndex, ThisTrans);
IF  gg06IsDummyTrans (ObjTransInfo.otrLockTransId_gg00)
THEN
    (* collision lock entry *)
    BEGIN
    k52begexcl_objcoll (TaskId, ObjCollGlobPtr);
    k52acc_objcoll_entry (ObjCollGlobPtr^, ObjTransInfo.otrLockTransIndex_gg00, CollEntry);
    IF  (CollEntry^.objcLockTransId_kb05 = WriteTransId)
        AND
        kb50IsValidCollisionEntry (CollEntry^, Oid)
    THEN
        (* locked by this trans --> unlock *)
        BEGIN
        IF  CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex
        THEN
            BEGIN
            k50DelCollisionEntry (ObjCollGlobPtr^, ThisTrans^, CollEntry);
            ObjTransInfo.otrLockTransIndex_gg00 := cgg_nil_transindex;
            gg06SetNilTrans (ObjTransInfo.otrLockTransId_gg00)
            END
        ELSE
            BEGIN
            kb50_RemoveCollEntryFromTransCollList (ObjCollGlobPtr^, ThisTrans^, CollEntry^);
            k50SatisfyNextWaitingObjRequest (ObjCollGlobPtr^, CollEntry^, AuxUpdTransId, ALL_REQ)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    k52endexcl_objcoll (TaskId, ObjCollGlobPtr)
    END
ELSE
    IF  gg06IsZeroTrans (ObjTransInfo.otrLockTransId_gg00)
    THEN
        k501Unlock(ThisTrans^, Oid, NOT IS_EXCL_LOCK);
    (*ENDIF*) 
(*ENDIF*) 
vendexcl (TaskId, g08lock0 + TransRegion);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50WaitAndRetryObjLock (
            VAR Trans : tgg00_TransContext;
            MessType  : tgg00_MessType;
            MessType2 : tgg00_MessType2);
 
VAR
      WaitError      : tgg00_BasisError;
      TransRegion    : tkb05_RegionNo;
      ThisTrans      : tkb05_TransEntryPtr;
      CollEntry      : tkb05_ObjCollEntryPtr;
      ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
      CollTransIndex : tgg00_TransIndex;   (* PTS 1128244 FF 2004-03-18 *)
      bShareLockEntryUsed : boolean;       (* PTS 1128244 FF 2004-03-18 *)
      bAquireLock         : boolean;       (* PTS 1128244 FF 2004-03-18 *)
      bIgnCollEntry       : boolean;       (* PTS 1128244 FF 2004-03-18 *)
      bIgnShrLckCsView    : boolean;       (* PTS 1128244 FF 2004-03-18 *)
      bOmsShareLockReq    : boolean;       (* PTS 1135179 FF 2005-04-25 *)
      AuxUpdTransId  : tgg91_TransNo;      (* PTS 1135179 FF 2005-04-25 *)
 
BEGIN
gg06SetNilTrans(AuxUpdTransId); (* PTS 1135179 FF 2005-04-25 *)
k53wait (Trans, MessType, MessType2);
IF  Trans.trIndex_gg00 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_nil_transindex
ELSE
    BEGIN
    WaitError          := Trans.trError_gg00;
    Trans.trError_gg00 := e_ok;
    TransRegion        := k51tr_index_region (Trans.trIndex_gg00);
    vbegexcl (Trans.trTaskId_gg00, g08lock0 + TransRegion);
    k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);
    IF  kb03Check.chkTrans_kb00                                      (* PTS 1103957 JA 1999-10-11 *)
    THEN
        BEGIN
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'kb50_ResetO: bad trIndex', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
        g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
              'kb50_ResetO: bad trId   ', ThisTrans^.teOwnIndex_kb05,
              Trans.trWriteTransId_gg00 = ThisTrans^.teWriteTransId_kb05)
        END;
    (*ENDIF*) 
    ThisTrans^.teTimeoutEnabled_kb05 := false;
    (* security; ObjWait without ObjReq impossible --> if ObjReq <> nil *)
    IF  ThisTrans^.teObjReq_kb05 <> cgg_nil_transindex
    THEN
        BEGIN
        k52begexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
        k52acc_objcoll_entry (ObjCollGlobPtr^, ThisTrans^.teObjReq_kb05, CollEntry);
        kb50_DelObjRequest (ObjCollGlobPtr^, ThisTrans^, CollEntry^, bIgnShrLckCsView, bOmsShareLockReq);
        IF  (WaitError = e_ok)
            AND
            (CollEntry^.objcLockTransId_kb05 <> Trans.trWriteTransId_gg00) (* security: check lock *)
        THEN
            WaitError := e_request_timeout;
        (*ENDIF*) 
        IF  WaitError = e_ok
        THEN
            BEGIN
            (* PTS 1128244 FF 2004-03-18 *)
            CollTransIndex := k501GetCollEntryIdx( Trans, CollEntry^.objcOid_kb05);
            IF  Trans.trError_gg00 = e_ok
            THEN
                BEGIN
                IF  CollTransIndex = CollEntry^.objcOwnIndex_kb05
                THEN
                    BEGIN
                    bShareLockEntryUsed := true;
                    bAquireLock         := true;
                    bIgnCollEntry       := true;
                    IF  bOmsShareLockReq
                    THEN
                        BEGIN
                        k501GetShareLock2(Trans, CollEntry^.objcObjContHndl_kb05, CollEntry^.objcOid_kb05, bIgnCollEntry);
                        IF  Trans.trError_gg00 = e_ok
                        THEN
                            BEGIN
                            IF  (CollEntry^.objcFirstReq_kb05 <> cgg_nil_transindex)
                            THEN
                                k50SatisfyNextWaitingObjRequest (ObjCollGlobPtr^, CollEntry^, AuxUpdTransId, ONLY_SHARE_REQ);
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                        END
                    ELSE
                        CollTransIndex := k501GetExclusiveLock(Trans, CollEntry^.objcObjContHndl_kb05,
                              CollEntry^.objcOid_kb05, bIgnShrLckCsView, bIgnCollEntry);
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  (CollTransIndex <> CollEntry^.objcOwnIndex_kb05)
                    OR
                    (Trans.trError_gg00 <> e_ok)
                THEN
                    BEGIN
                    Trans.trError_gg00 := e_ok;
                    WaitError          := e_request_timeout;
                    END;
                (*ENDIF*) 
                IF  (CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex)
                THEN
                    BEGIN
                    k501RemoveCollisionEntry (Trans, CollEntry^);
                    k50DelCollisionEntry (ObjCollGlobPtr^, ThisTrans^, CollEntry);
                    END
                ELSE
                    (* any other request exists *)
                    IF  ( WaitError <> e_ok )
                    THEN
                        k50SatisfyNextWaitingObjRequest (ObjCollGlobPtr^, CollEntry^, AuxUpdTransId, ALL_REQ);
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                (* insert collision entry into own list of collision locks *)
                Trans.trError_gg00 := e_ok;
                kb50_PutCollEntryIntoTransCollList (ObjCollGlobPtr^, ThisTrans^, CollEntry^);
                END;
            (*ENDIF*) 
            END
        ELSE
            (* wait error occurred (usually request timeout) *)
            BEGIN
            (* PTS 1128244 FF 2004-03-18 *)
            CollTransIndex := k501GetCollEntryIdx( Trans, CollEntry^.objcOid_kb05);
            IF  Trans.trError_gg00 = e_object_not_locked
            THEN
                Trans.trError_gg00 := e_ok;
            (*ENDIF*) 
            IF  CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex
            THEN
                BEGIN
                IF  gg06IsNilTrans (CollEntry^.objcLockTransId_kb05) (* not locked *)
                    OR
                    (* exclusive lock request collided with an existing share lock        *)
                    (* and will be reverted now because no more requests have been queued *)
                    (((gg06IsZeroTrans (CollEntry^.objcLockTransId_kb05)
                    AND
                    (cgg_nil_transindex = CollEntry^.objcLockTransIndex_kb05))
                    OR
                    (* collision lock has been assigned to transaction at the same time *)
                    (* the error was signalled.                                         *)
                    (CollEntry^.objcLockTransId_kb05 = Trans.trWriteTransId_gg00))
                    AND
                    (CollTransIndex = CollEntry^.objcOwnIndex_kb05))      (* PTS 1128244 FF 2004-03-18 *)
                THEN
                    BEGIN
                    k501RemoveCollisionEntry (Trans, CollEntry^); (* PTS 1128244 FF 2004-03-18 *)
                    kb50_DelUnusedCollisionEntry (ObjCollGlobPtr^, CollEntry);
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                (* any other request exists *)
                IF  gg06IsNilTrans (CollEntry^.objcLockTransId_kb05) (* not locked *)
                    OR
                    ((CollEntry^.objcLockTransId_kb05 = Trans.trWriteTransId_gg00) (* security: check lock *)
                    AND
                    (CollTransIndex = CollEntry^.objcOwnIndex_kb05))     (* PTS 1128244 FF 2004-03-18 *)
                THEN
                    k50SatisfyNextWaitingObjRequest (ObjCollGlobPtr^, CollEntry^, AuxUpdTransId, ALL_REQ)
                ELSE
                    IF  gg06IsNilTrans (CollEntry^.objcLockTransId_kb05)
                        AND
                        (cgg_nil_transindex = CollEntry^.objcLockTransIndex_kb05)
                        AND
                        (CollTransIndex = CollEntry^.objcOwnIndex_kb05)
                    THEN
                        k50SatisfyNextWaitingObjRequest (ObjCollGlobPtr^, CollEntry^, AuxUpdTransId, ONLY_SHARE_REQ);
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        k52endexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr)
        END;
    (*ENDIF*) 
    vendexcl (Trans.trTaskId_gg00, g08lock0 + TransRegion);
    IF  WaitError <> e_ok
    THEN
        Trans.trError_gg00 := WaitError
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50_DelUnusedCollisionEntry (
            VAR ObjCollGlob : tkb05_ObjCollGlob;
            VAR CollEntry : tkb05_ObjCollEntryPtr);
 
BEGIN
(* PTS xxx *)
IF  kb03Check.chkRegion_kb00
THEN
    BEGIN
    g08check_excl (ObjCollGlob.oglOwnRegionId_kb05)
    END;
(*ENDIF*) 
IF  kb03Check.chkLock_kb00
THEN
    g01check (kbMsg_csp03, csp3_n_lock, 'kb50_DelCol: req <> nil ',
          CollEntry^.objcOwnIndex_kb05,
          CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex);
(*ENDIF*) 
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxTrace2 ('  kb50DelCol',
          CollEntry^.objcOwnIndex_kb05,
          CollEntry^.objcLockTransId_kb05,
          CollEntry^.objcLockTransIndex_kb05);
(*ENDIF*) 
;
&ifdef TRACE
IF  t01trace (kb_lockentry)
THEN
    WITH CollEntry^ DO
        BEGIN
        t01name     (kb_lockentry, 'kb50_DelCollEntry ');
        t01p2int4   (kb_lockentry, 'objcFirstReq', objcFirstReq_kb05
              ,                    'objcTransIdx', objcLockTransIndex_kb05);
        t01p2int4   (kb_lockentry, 'objcNextColl', objcNextCollLock_kb05
              ,                    'objcPrevColl', objcPrevCollLock_kb05);
        ta01TransNo (kb_lockentry, 'objcLockTrId', objcLockTransId_kb05);
        ta01Oid     (kb_lockentry, 'objcOid     ', objcOid_kb05);
        END;
    (*ENDWITH*) 
&endif
(*ENDIF*) 
;
(* The collision entry is not in lock chain of original transaction *)
(* The original transaction has already removed its locks. *)
(* for safety reset lock-trans values again *)
CollEntry^.objcLockTransIndex_kb05 := cgg_nil_transindex;
gg06SetNilTrans (CollEntry^.objcLockTransId_kb05);
(* *)
gg06SetNilOid (CollEntry^.objcOid_kb05);
(* *)
(* insert into free list *)
CollEntry^.objcNextCollLock_kb05     := ObjCollGlob.oglObjCollFirstFree_kb05;
ObjCollGlob.oglObjCollFirstFree_kb05 := CollEntry^.objcOwnIndex_kb05;
ObjCollGlob.oglObjCollFreeCnt_kb05   := ObjCollGlob.oglObjCollFreeCnt_kb05 + 1;
CollEntry := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50DelCollisionEntry (
            VAR ObjCollGlob    : tkb05_ObjCollGlob;
            VAR LockTransEntry : tkb05_TransEntry;
            VAR CollEntry      : tkb05_ObjCollEntryPtr);
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    BEGIN
    g08check_excl (g08lock0 + LockTransEntry.teOwnRegion_kb05);
    g08check_excl (ObjCollGlob.oglOwnRegionId_kb05)
    END;
(*ENDIF*) 
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    g01check (kbMsg_csp03, csp3_n_lock, 'kb50_DelCol: req <> nil ',
          CollEntry^.objcOwnIndex_kb05,
          CollEntry^.objcFirstReq_kb05 = cgg_nil_transindex);
(*ENDIF*) 
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxTrace2 ('  kb50DelCol',
          CollEntry^.objcOwnIndex_kb05,
          CollEntry^.objcLockTransId_kb05,
          CollEntry^.objcLockTransIndex_kb05);
(*ENDIF*) 
;
&ifdef TRACE
IF  t01trace (kb_lockentry)
THEN
    WITH CollEntry^ DO
        BEGIN
        t01name     (kb_lockentry, 'kb50_DelCollEntry ');
        t01p2int4   (kb_lockentry, 'objcFirstReq', objcFirstReq_kb05
              ,                    'objcTransIdx', objcLockTransIndex_kb05);
        t01p2int4   (kb_lockentry, 'objcNextColl', objcNextCollLock_kb05
              ,                    'objcPrevColl', objcPrevCollLock_kb05);
        ta01TransNo (kb_lockentry, 'objcLockTrId', objcLockTransId_kb05);
        ta01Oid     (kb_lockentry, 'objcOid     ', objcOid_kb05);
        END;
    (*ENDWITH*) 
&endif
(*ENDIF*) 
;
kb50_RemoveCollEntryFromTransCollList (ObjCollGlob, LockTransEntry, CollEntry^);
gg06SetNilOid (CollEntry^.objcOid_kb05);
(* *)
(* insert into free list *)
CollEntry^.objcNextCollLock_kb05     := ObjCollGlob.oglObjCollFirstFree_kb05;
ObjCollGlob.oglObjCollFirstFree_kb05 := CollEntry^.objcOwnIndex_kb05;
ObjCollGlob.oglObjCollFreeCnt_kb05   := ObjCollGlob.oglObjCollFreeCnt_kb05 + 1;
CollEntry := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50_DelObjRequest (
            VAR ObjCollGlob      : tkb05_ObjCollGlob;
            VAR LockTransEntry   : tkb05_TransEntry;
            VAR CollEntry        : tkb05_ObjCollisionEntry;
            VAR bIgnCnstViewChck : boolean;  (* PTS 1128244 FF 2004-03-18 *)
            VAR bOmsShareLockReq : boolean); (* PTS 1135179 FF 2005-04-25 *)
 
VAR
      found        : boolean;
      ReqCnt       : tsp00_Int4;
      CurrReq      : tgg00_TransIndex;
      PrevReq      : tgg00_TransIndex;
      ReqEntry     : tkb05_ObjReqEntryPtr;
      PrevReqEntry : tkb05_ObjReqEntryPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    BEGIN
    g08check_excl (g08lock0 + LockTransEntry.teOwnRegion_kb05);
    g08check_excl (ObjCollGlob.oglOwnRegionId_kb05)
    END;
(*ENDIF*) 
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    g01check (kbMsg_csp03, csp3_n_lock, 'kb50_DelObj: req = nil  ',
          CollEntry.objcOwnIndex_kb05,
          CollEntry.objcFirstReq_kb05 <> cgg_nil_transindex);
(*ENDIF*) 
CurrReq := CollEntry.objcFirstReq_kb05;
PrevReq := cgg_nil_transindex;
ReqCnt  := 0;
found   := false;
WHILE (CurrReq <> cgg_nil_transindex) AND NOT found AND (ReqCnt <= k51glob.glTransEntries_kb05) DO
    IF  CurrReq = LockTransEntry.teOwnIndex_kb05
    THEN
        found := true
    ELSE
        BEGIN
        k52acc_objreq_entry (ObjCollGlob, CurrReq, ReqEntry);
        ReqCnt  := ReqCnt + 1;
        PrevReq := CurrReq;
        CurrReq := ReqEntry^.objrNextReq_kb05
        END;
    (*ENDIF*) 
(*ENDWHILE*) 
IF  ReqCnt > k51glob.glTransEntries_kb05
THEN
    k52x_loop_error ('kb50_DelObjRequest      ', 1);
(*ENDIF*) 
IF  found
THEN
    BEGIN
    k52acc_objreq_entry (ObjCollGlob, CurrReq, ReqEntry);
    (* *)
    IF  g01vtrace.vtrKbLock_gg00
    THEN
        kb50XxxReqTrace2 ('  kb50DelReq',
              ReqEntry^.objrOwnIndex_kb05,
              ReqEntry^.objrCollEntryIndex_kb05,
              ReqEntry^.objrReqTransId_kb05,
              ReqEntry^.objrNextReq_kb05);
    (*ENDIF*) 
    IF  PrevReq = cgg_nil_transindex
    THEN
        CollEntry.objcFirstReq_kb05 := ReqEntry^.objrNextReq_kb05
    ELSE
        BEGIN
        k52acc_objreq_entry (ObjCollGlob, PrevReq, PrevReqEntry);
        PrevReqEntry^.objrNextReq_kb05 := ReqEntry^.objrNextReq_kb05
        END;
    (*ENDIF*) 
    bIgnCnstViewChck := ReqEntry^.objrIgnCnstViewCheck;       (* PTS 1128244 FF 2004-03-18 *)
    bOmsShareLockReq := ReqEntry^.objrOmsShareLockReq;        (* PTS 1135179 FF 2005-04-25 *)
    gg06SetNilTrans (ReqEntry^.objrReqTransId_kb05);         (* set free *)
    ReqEntry^.objrCollEntryIndex_kb05 := cgg_nil_transindex;
    ReqEntry^.objrNextReq_kb05        := cgg_nil_transindex;
    ReqEntry^.objrWaitTaskId_kb05     := cgg_nil_pid;
    ReqEntry^.objrIgnCnstViewCheck    := FALSE;               (* PTS 1128244 FF 2004-03-18 *)
    ReqEntry^.objrOmsShareLockReq     := FALSE;               (* PTS 1135179 FF 2005-04-25 *)
    (* *)
    LockTransEntry.teObjReq_kb05      := cgg_nil_transindex;
    (* *)
    ObjCollGlob.oglObjReqCnt_kb05     := ObjCollGlob.oglObjReqCnt_kb05 - 1
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50_EnterBothRegions (
            TaskId  : tsp00_TaskId;
            Region1 : tkb05_RegionNo;
            Region2 : tkb05_RegionNo);
 
BEGIN
IF  Region1 = Region2
THEN
    vbegexcl (TaskId, g08lock0 + Region1)
ELSE
    IF  Region1 > Region2
    THEN
        BEGIN
        vbegexcl (TaskId, g08lock0 + Region2);
        vbegexcl (TaskId, g08lock0 + Region1)
        END
    ELSE
        BEGIN
        vbegexcl (TaskId, g08lock0 + Region1);
        vbegexcl (TaskId, g08lock0 + Region2)
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE  (* new PTS 1128244 FF 2004-03-18 *)
      kb50_GetCollisionEntry (
            VAR Trans          : tgg00_TransContext;
            VAR ObjCollGlob    : tkb05_ObjCollGlob;
            VAR Oid            : tgg00_OidSpace;
            VAR NewCollEntry   : tkb05_ObjCollEntryPtr);
 
BEGIN
Trans.trError_gg00 := e_ok;
NewCollEntry       := NIL;
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    BEGIN
    g08check_excl (ObjCollGlob.oglOwnRegionId_kb05)
    END;
(*ENDIF*) 
IF  ObjCollGlob.oglObjCollFirstFree_kb05 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_too_many_lock_requests
ELSE
    BEGIN
    k52acc_objcoll_entry (ObjCollGlob, ObjCollGlob.oglObjCollFirstFree_kb05, NewCollEntry);
    ObjCollGlob.oglObjCollFirstFree_kb05  := NewCollEntry^.objcNextCollLock_kb05;
    ObjCollGlob.oglObjCollFreeCnt_kb05    := ObjCollGlob.oglObjCollFreeCnt_kb05 - 1;
    (* *)
    NewCollEntry^.objcNextCollLock_kb05   := cgg_nil_transindex;
    NewCollEntry^.objcFirstReq_kb05       := cgg_nil_transindex;
    NewCollEntry^.objcOid_kb05            := Oid;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50_InsCollisionEntry (
            VAR Trans          : tgg00_TransContext;
            VAR ObjCollGlob    : tkb05_ObjCollGlob;
            VAR LockTransEntry : tkb05_TransEntry;
            VAR Oid            : tgg00_OidSpace;
            ObjFileNo          : tsp00_C8;
            VAR NewCollEntry   : tkb05_ObjCollEntryPtr);
 
BEGIN
Trans.trError_gg00 := e_ok;
NewCollEntry       := NIL;
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    BEGIN
    g08check_excl (g08lock0 + LockTransEntry.teOwnRegion_kb05);
    g08check_excl (ObjCollGlob.oglOwnRegionId_kb05)
    END;
(*ENDIF*) 
IF  ObjCollGlob.oglObjCollFirstFree_kb05 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_too_many_lock_requests
ELSE
    BEGIN
    k52acc_objcoll_entry (ObjCollGlob, ObjCollGlob.oglObjCollFirstFree_kb05, NewCollEntry);
    ObjCollGlob.oglObjCollFirstFree_kb05 := NewCollEntry^.objcNextCollLock_kb05;
    ObjCollGlob.oglObjCollFreeCnt_kb05   := ObjCollGlob.oglObjCollFreeCnt_kb05 - 1;
    (* *)
    NewCollEntry^.objcFirstReq_kb05  := cgg_nil_transindex;
    NewCollEntry^.objcOid_kb05       := Oid;
    NewCollEntry^.objcObjContHndl_kb05 := ObjFileNo;
    kb50_PutCollEntryIntoTransCollList (ObjCollGlob, LockTransEntry, NewCollEntry^);
    ;
    IF  g01vtrace.vtrKbLock_gg00
    THEN
        kb50XxxTrace2 ('  kb50InsCol',
              NewCollEntry^.objcOwnIndex_kb05,
              NewCollEntry^.objcLockTransId_kb05,
              NewCollEntry^.objcLockTransIndex_kb05);
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50_InsOwnObjRequest (
            VAR Trans        : tgg00_TransContext;
            VAR ObjCollGlob  : tkb05_ObjCollGlob;
            VAR CollEntry    : tkb05_ObjCollisionEntry;
            bIgnCnstViewChck : boolean;           (* PTS 1128244 FF 2004-03-18 *)
            bOmsShareLockReq : boolean);          (* PTS 1135179 FF 2005-04-25 *)
 
VAR
      CurrReq      : tgg00_TransIndex;
      PrevReq      : tgg00_TransIndex;
      ReqCnt       : tsp00_Int4;
      CurrReqEntry : tkb05_ObjReqEntryPtr;
      NewReqEntry  : tkb05_ObjReqEntryPtr;
      PrevReqEntry : tkb05_ObjReqEntryPtr;
      ThisTrans    : tkb05_TransEntryPtr;
 
BEGIN
Trans.trError_gg00 := e_wait_for_lock_release;
(* *)
k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    BEGIN
    g08excl_check (Trans.trTaskId_gg00, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    g08excl_check (Trans.trTaskId_gg00, ObjCollGlob.oglOwnRegionId_kb05)
    END;
(*ENDIF*) 
k52acc_objreq_entry (ObjCollGlob, Trans.trIndex_gg00, NewReqEntry);
IF  kb03Check.chkLock_kb00
THEN
    BEGIN
    g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
          'kb50_InsOw: trans used  ', Trans.trIndex_gg00,
          gg06IsNilTrans (NewReqEntry^.objrReqTransId_kb05));
    (* *)
    g01check (kb50cWrongTransIndex_csp03, csp3_n_lock,
          'kb50_InsOw: bad trIndex ', Trans.trIndex_gg00,
          NewReqEntry^.objrOwnIndex_kb05 = Trans.trIndex_gg00)
    END;
(*ENDIF*) 
NewReqEntry^.objrReqTransId_kb05      := Trans.trWriteTransId_gg00;
NewReqEntry^.objrOwnIndex_kb05        := Trans.trIndex_gg00;
NewReqEntry^.objrCollEntryIndex_kb05  := CollEntry.objcOwnIndex_kb05;
NewReqEntry^.objrNextReq_kb05         := cgg_nil_transindex;
NewReqEntry^.objrWaitTaskId_kb05      := Trans.trTaskId_gg00;
NewReqEntry^.objrIgnCnstViewCheck     := bIgnCnstViewChck;   (* PTS 1128244 FF 2004-03-18 *)
NewReqEntry^.objrOmsShareLockReq      := bOmsShareLockReq;   (* PTS 1135179 FF 2005-04-25 *)
(* *)
IF  g01vtrace.vtrKbLock_gg00
THEN
    kb50XxxReqTrace2 ('  kb50InsReq',
          NewReqEntry^.objrOwnIndex_kb05,
          NewReqEntry^.objrCollEntryIndex_kb05,
          NewReqEntry^.objrReqTransId_kb05,
          NewReqEntry^.objrNextReq_kb05);
(*ENDIF*) 
;
ThisTrans^.teObjReq_kb05         := CollEntry.objcOwnIndex_kb05;
ThisTrans^.teObjReqTimeout_kb05  :=
      gg06Int4FromUint2 (Trans.trObjReqTimeout_gg00) + cgg04_lc_timeout_interval; (* PTS 1110314 *)
;
ThisTrans^.teTimeoutEnabled_kb05 := true;
(* *)
ObjCollGlob.oglObjReqCnt_kb05    := ObjCollGlob.oglObjReqCnt_kb05  + 1;
ObjCollGlob.oglCollisions_kb05   := ObjCollGlob.oglCollisions_kb05 + ONE_8BYTE_CNT_GG04;
(* *)
CurrReq := CollEntry.objcFirstReq_kb05;
PrevReq := cgg_nil_transindex;
ReqCnt  := 0;
WHILE (CurrReq <> cgg_nil_transindex) AND (ReqCnt <= k51glob.glTransEntries_kb05) DO
    BEGIN
    k52acc_objreq_entry (ObjCollGlob, CurrReq, CurrReqEntry);
    ReqCnt  := ReqCnt + 1;
    PrevReq := CurrReq;
    CurrReq := CurrReqEntry^.objrNextReq_kb05
    END;
(*ENDWHILE*) 
IF  ReqCnt > k51glob.glTransEntries_kb05
THEN
    k52x_loop_error ('kb50_InsOwnObjRequest   ', 1);
(*ENDIF*) 
IF  PrevReq = cgg_nil_transindex
THEN
    CollEntry.objcFirstReq_kb05 := Trans.trIndex_gg00
ELSE
    BEGIN
    k52acc_objreq_entry (ObjCollGlob, PrevReq, PrevReqEntry);
    PrevReqEntry^.objrNextReq_kb05 := Trans.trIndex_gg00;
&   ifdef TRACE
    IF  t01trace (kb_lockentry)
    THEN
        BEGIN
        t01p2int4   (kb_lockentry, 'PrevReq     ', PrevReq
              ,                    'Prev.CollIdx', PrevReqEntry^.objrCollEntryIndex_kb05);
        ta01TransNo (kb_lockentry, 'Prev.ReqTrns', PrevReqEntry^.objrReqTransId_kb05);
        END;
&   endif
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
IF  t01trace (kb_lockentry)
THEN
    WITH CollEntry DO
        BEGIN
        t01name     (kb_lockentry, 'kb50_InsObjRequest');
        t01p2int4   (kb_lockentry, 'objcFirstReq', objcFirstReq_kb05
              ,                    'objcTransIdx', objcLockTransIndex_kb05);
        t01p2int4   (kb_lockentry, 'objcNextColl', objcNextCollLock_kb05
              ,                    'objcPrevColl', objcPrevCollLock_kb05);
        ta01TransNo (kb_lockentry, 'objcLockTrId', objcLockTransId_kb05);
        ta01Oid     (kb_lockentry, 'objcOid     ', objcOid_kb05);
        t01p2int4   (kb_lockentry, 'New         ', NewReqEntry^.objrOwnIndex_kb05
              ,                    'New.CollIdx ', NewReqEntry^.objrCollEntryIndex_kb05);
        ta01TransNo (kb_lockentry, 'New.ReqTrans', NewReqEntry^.objrReqTransId_kb05);
        END;
    (*ENDWITH*) 
&endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50_LeaveBothRegions (
            TaskId  : tsp00_TaskId;
            Region1 : tkb05_RegionNo;
            Region2 : tkb05_RegionNo);
 
BEGIN
IF  Region1 = Region2
THEN
    vendexcl (TaskId, g08lock0 + Region1)
ELSE
    IF  Region1 > Region2
    THEN
        BEGIN
        vendexcl (TaskId, g08lock0 + Region2);
        vendexcl (TaskId, g08lock0 + Region1)
        END
    ELSE
        BEGIN
        vendexcl (TaskId, g08lock0 + Region1);
        vendexcl (TaskId, g08lock0 + Region2)
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50_PutCollEntryIntoTransCollList (
            VAR ObjCollGlob    : tkb05_ObjCollGlob;
            VAR LockTransEntry : tkb05_TransEntry;
            VAR CollEntry      : tkb05_ObjCollisionEntry);
 
VAR
      NextEntry : tkb05_ObjCollEntryPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    BEGIN
    g08check_excl (g08lock0 + LockTransEntry.teOwnRegion_kb05);
    g08check_excl (ObjCollGlob.oglOwnRegionId_kb05)
    END;
(*ENDIF*) 
CollEntry.objcPrevCollLock_kb05 := cgg_nil_transindex;
CollEntry.objcNextCollLock_kb05 := LockTransEntry.teFirstCollLock_kb05;
IF  CollEntry.objcNextCollLock_kb05 <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_objcoll_entry (ObjCollGlob, CollEntry.objcNextCollLock_kb05, NextEntry);
    NextEntry^.objcPrevCollLock_kb05 := CollEntry.objcOwnIndex_kb05
    END;
(*ENDIF*) 
LockTransEntry.teFirstCollLock_kb05 := CollEntry.objcOwnIndex_kb05;
(* *)
CollEntry.objcLockTransIndex_kb05 := LockTransEntry.teOwnIndex_kb05;
CollEntry.objcLockTransId_kb05    := LockTransEntry.teWriteTransId_kb05
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50_RemoveCollEntryFromTransCollList (
            VAR ObjCollGlob    : tkb05_ObjCollGlob;
            VAR LockTransEntry : tkb05_TransEntry;
            VAR CollEntry      : tkb05_ObjCollisionEntry);
 
VAR
      NextEntry : tkb05_ObjCollEntryPtr;
      PrevEntry : tkb05_ObjCollEntryPtr;
      bDoChaining : boolean;
 
BEGIN
bDoChaining := true;
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    BEGIN
    g08check_excl (g08lock0 + LockTransEntry.teOwnRegion_kb05);
    g08check_excl (ObjCollGlob.oglOwnRegionId_kb05)
    END;
(*ENDIF*) 
IF  CollEntry.objcPrevCollLock_kb05 = cgg_nil_transindex
THEN
    BEGIN
    (* because of OMS share locks collision lock may not be chained to transentry *)
    IF  LockTransEntry.teFirstCollLock_kb05 = CollEntry.objcOwnIndex_kb05
    THEN
        LockTransEntry.teFirstCollLock_kb05 := CollEntry.objcNextCollLock_kb05
    ELSE
        bDoChaining := false;
    (*ENDIF*) 
    END
ELSE
    BEGIN
    k52acc_objcoll_entry (ObjCollGlob, CollEntry.objcPrevCollLock_kb05, PrevEntry);
    (* because of OMS share locks collision lock may not be chained to transentry *)
    IF  PrevEntry^.objcNextCollLock_kb05 = CollEntry.objcOwnIndex_kb05
    THEN
        PrevEntry^.objcNextCollLock_kb05 := CollEntry.objcNextCollLock_kb05
    ELSE
        bDoChaining := false;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  bDoChaining
    AND
    (CollEntry.objcNextCollLock_kb05 <> cgg_nil_transindex)
THEN
    BEGIN
    k52acc_objcoll_entry (ObjCollGlob, CollEntry.objcNextCollLock_kb05, NextEntry);
    NextEntry^.objcPrevCollLock_kb05 := CollEntry.objcPrevCollLock_kb05
    END;
(*ENDIF*) 
CollEntry.objcLockTransIndex_kb05 := cgg_nil_transindex;
gg06SetNilTrans (CollEntry.objcLockTransId_kb05)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k50SatisfyNextWaitingObjRequest (
            VAR ObjCollGlob : tkb05_ObjCollGlob;
            VAR CollEntry   : tkb05_ObjCollisionEntry;
            VAR UpdTransId  : tgg91_TransNo; (*PTS 1135178 FF*)
            bOnlyIfShareReq : boolean);      (*PTS 1135178 FF*)
 
VAR
      CurrReq  : tgg00_TransIndex;
      ReqCnt   : tsp00_Int4;
      ReqEntry : tkb05_ObjReqEntryPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-10-11 *)
THEN
    g08check_excl(ObjCollGlob.oglOwnRegionId_kb05);
&ifdef TRACE
(*ENDIF*) 
IF  t01trace (kb_lockentry)
THEN
    WITH CollEntry DO
        BEGIN
        t01name     (kb_lockentry, 'kb50_SatisfyNextWa');
        t01p2int4   (kb_lockentry, 'objcFirstReq', objcFirstReq_kb05
              ,                    'objcTransIdx', objcLockTransIndex_kb05);
        t01p2int4   (kb_lockentry, 'objcNextColl', objcNextCollLock_kb05
              ,                    'objcPrevColl', objcPrevCollLock_kb05);
        ta01TransNo (kb_lockentry, 'objcLockTrId', objcLockTransId_kb05);
        ta01Oid     (kb_lockentry, 'objcOid     ', objcOid_kb05);
        END;
    (*ENDWITH*) 
&endif
(*ENDIF*) 
CollEntry.objcLockTransIndex_kb05 := cgg_nil_transindex;
gg06SetNilTrans (CollEntry.objcLockTransId_kb05);    (* set lock to free if nobody is waiting *)
CurrReq := CollEntry.objcFirstReq_kb05;
ReqCnt  := 0;
WHILE (CurrReq <> cgg_nil_transindex) AND (ReqCnt <= k51glob.glTransEntries_kb05) DO
    BEGIN
    k52acc_objreq_entry (ObjCollGlob, CurrReq, ReqEntry);
    IF  ReqEntry^.objrWaitTaskId_kb05 <> cgg_nil_pid
    THEN
        BEGIN
        IF  g01vtrace.vtrKbLock_gg00
        THEN
            kb50XxxReqTrace2 ('  kb50Satisf',
                  ReqEntry^.objrOwnIndex_kb05,
                  ReqEntry^.objrCollEntryIndex_kb05,
                  ReqEntry^.objrReqTransId_kb05,
                  ReqEntry^.objrNextReq_kb05);
        (*ENDIF*) 
        IF  bOnlyIfShareReq
            AND
            NOT ReqEntry^.objrOmsShareLockReq
            AND
            NOT (UpdTransId = ReqEntry^.objrReqTransId_kb05)
        THEN
            CurrReq := cgg_nil_transindex
        ELSE
            BEGIN
            CollEntry.objcLockTransIndex_kb05  := ReqEntry^.objrOwnIndex_kb05;
            CollEntry.objcLockTransId_kb05     := ReqEntry^.objrReqTransId_kb05;
            IF  g01vtrace.vtrKbLock_gg00
            THEN
                kb50XxxTrace2 ('  kb50Satisf',
                      CollEntry.objcOwnIndex_kb05,
                      CollEntry.objcLockTransId_kb05,
                      CollEntry.objcLockTransIndex_kb05);
            (*ENDIF*) 
            ;
            (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
            vsignal (ReqEntry^.objrWaitTaskId_kb05, IS_OK);
            (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
            ReqEntry^.objrWaitTaskId_kb05 := cgg_nil_pid;
            CurrReq := cgg_nil_transindex
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  g01vtrace.vtrKbLock_gg00
        THEN
            kb50XxxReqTrace2 ('  kb50Satisf',
                  ReqEntry^.objrOwnIndex_kb05,
                  ReqEntry^.objrCollEntryIndex_kb05,
                  ReqEntry^.objrReqTransId_kb05,
                  ReqEntry^.objrNextReq_kb05);
        (*ENDIF*) 
        CurrReq := ReqEntry^.objrNextReq_kb05;
        END;
    (*ENDIF*) 
    ReqCnt := ReqCnt + 1
    END;
(*ENDWHILE*) 
IF  ReqCnt > k51glob.glTransEntries_kb05
THEN
    k52x_loop_error ('kb50_SatisfyNextWaitingO', 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50XxxObjTrace (
            VAR Trans            : tgg00_TransContext;
            msg                  : tsp00_Sname;
            VAR oid              : tgg00_OidSpace;
            VAR UpdTransId       : tgg91_TransNo;
            VAR BeforeRef        : tgg91_PageRef;
            ObjState             : tgg00_ObjState);
 
VAR
      LineLen : integer;
      Line    : tsp00_Line;
 
BEGIN
LineLen := 0;
g17sname_to_line    (msg,            LineLen, Line);
g17sname_to_line    (' UpdId=     ', LineLen, Line);
gg06TransToLine     (UpdTransId,     LineLen, Line);
g17sname_to_line    (' Before=    ', LineLen, Line);
g17page_ref_to_line (BeforeRef,      LineLen, Line);
g17sname_to_line    (' State=     ', LineLen, Line);
g17trimint4_to_line (ord(ObjState),  LineLen, Line);
g17sname_to_line    (' OID        ', LineLen, Line);
LineLen := LineLen + 1;
Line [LineLen] := ' ';
gg06OidToLine (oid, LineLen, Line);
IF  Trans.trError_gg00 <> e_ok
THEN
    BEGIN
    g17sname_to_line     (' ***        ',     LineLen, Line);
    g17basis_err_to_line (Trans.trError_gg00, LineLen, Line);
    g17sname_to_line     (' ***        ',     LineLen, Line)
    END;
(*ENDIF*) 
b120InsertTrace (Trans, gg, gg_opmsg, LineLen, @Line)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50XxxLockTrace (
            VAR Trans             : tgg00_TransContext;
            msg                   : tsp00_Sname;
            VAR oid               : tgg00_OidSpace;
            VAR ObjTransInfo      : tgg00_ObjTransInfo);
 
VAR
      LineLen : integer;
      Line    : tsp00_Line;
 
BEGIN
LineLen := 0;
g17sname_to_line    (msg,                                 LineLen, Line);
g17sname_to_line    (' Idx=       ',                      LineLen, Line);
g17trimint4_to_line (ObjTransInfo.otrLockTransIndex_gg00, LineLen, Line);
g17sname_to_line    (' LockTr=    ',                      LineLen, Line);
gg06TransToLine     (ObjTransInfo.otrLockTransId_gg00,    LineLen, Line);
g17sname_to_line    (' OID        ',                      LineLen, Line);
LineLen        := LineLen + 1;
Line [LineLen] := ' ';
gg06OidToLine (oid, LineLen, Line);
IF  Trans.trError_gg00 <> e_ok
THEN
    BEGIN
    g17sname_to_line     (' ***        ',     LineLen, Line);
    g17basis_err_to_line (Trans.trError_gg00, LineLen, Line);
    g17sname_to_line     (' ***        ',     LineLen, Line)
    END;
(*ENDIF*) 
b120InsertTrace (Trans, gg, gg_opmsg, LineLen, @Line)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50XxxLockTrace2 (
            msg              : tsp00_Sname;
            VAR oid          : tgg00_OidSpace;
            VAR ObjTransInfo : tgg00_ObjTransInfo);
 
VAR
      AuxTrans : tgg00_TransContext;
 
BEGIN
WITH AuxTrans DO
    BEGIN
    vgetpid (trTaskId_gg00);
    trError_gg00 := e_ok;
    gg06SetNilSession   (trSessionId_gg00);
    gg06SetNilTrans     (trTransId_gg00);
    gg06SetNilTrans     (trWriteTransId_gg00);
    trSubtransId_gg00   := cgg_zero_subtrans;
    END;
(*ENDWITH*) 
kb50XxxLockTrace (AuxTrans, msg, oid, ObjTransInfo)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50XxxTrace (
            VAR Trans         : tgg00_TransContext;
            msg               : tsp00_Sname;
            VAR LockTransId   : tgg91_TransNo;
            LockTransIndex    : tgg00_TransIndex);
 
VAR
      LineLen : integer;
      Line    : tsp00_Line;
 
BEGIN
LineLen := 0;
g17sname_to_line    (msg,            LineLen, Line);
g17sname_to_line    (' LockTr=    ', LineLen, Line);
gg06TransToLine     (LockTransId,    LineLen, Line);
g17sname_to_line    (' LockIdx=   ', LineLen, Line);
g17trimint4_to_line (LockTransIndex, LineLen, Line);
b120InsertTrace (Trans, gg, gg_opmsg, LineLen, @Line)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50XxxTrace2 (
            msg             : tsp00_Sname;
            CollisionIndex  : tgg00_TransIndex;
            VAR LockTransId : tgg91_TransNo;
            LockTransIndex  : tgg00_TransIndex);
 
VAR
      AuxTrans : tgg00_TransContext;
      LineLen : integer;
      Line    : tsp00_Line;
 
BEGIN
WITH AuxTrans DO
    BEGIN
    vgetpid (trTaskId_gg00);
    trError_gg00 := e_ok;
    gg06SetNilSession   (trSessionId_gg00);
    gg06SetNilTrans     (trTransId_gg00);
    gg06SetNilTrans     (trWriteTransId_gg00);
    trSubtransId_gg00   := cgg_zero_subtrans;
    END;
(*ENDWITH*) 
LineLen := 0;
g17sname_to_line    (msg,            LineLen, Line);
g17sname_to_line    (' CollIdx=   ', LineLen, Line);
g17trimint4_to_line (CollisionIndex, LineLen, Line);
g17sname_to_line    (' LockTr=    ', LineLen, Line);
gg06TransToLine     (LockTransId,    LineLen, Line);
g17sname_to_line    (' LockIdx=   ', LineLen, Line);
g17trimint4_to_line (LockTransIndex, LineLen, Line);
b120InsertTrace (AuxTrans, gg, gg_opmsg, LineLen, @Line)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb50XxxReqTrace2 (
            msg             : tsp00_Sname;
            CollReqIndex    : tgg00_TransIndex;
            CollisionIndex  : tgg00_TransIndex;
            VAR ReqTransId  : tgg91_TransNo;
            nextReqIndex    : tgg00_TransIndex);
 
VAR
      AuxTrans : tgg00_TransContext;
      LineLen : integer;
      Line    : tsp00_Line;
 
BEGIN
WITH AuxTrans DO
    BEGIN
    vgetpid (trTaskId_gg00);
    trError_gg00 := e_ok;
    gg06SetNilSession   (trSessionId_gg00);
    gg06SetNilTrans     (trTransId_gg00);
    gg06SetNilTrans     (trWriteTransId_gg00);
    trSubtransId_gg00   := cgg_zero_subtrans;
    END;
(*ENDWITH*) 
LineLen := 0;
g17sname_to_line    (msg,            LineLen, Line);
g17sname_to_line    (' CollReqIdx=', LineLen, Line);
g17trimint4_to_line (CollReqIndex,   LineLen, Line);
g17sname_to_line    (' CollIdx=   ', LineLen, Line);
g17trimint4_to_line (CollisionIndex, LineLen, Line);
g17sname_to_line    (' ReqTr=     ', LineLen, Line);
gg06TransToLine     (ReqTransId,     LineLen, Line);
g17sname_to_line    (' NextReqIdx=', LineLen, Line);
g17trimint4_to_line (nextReqIndex,   LineLen, Line);
b120InsertTrace (AuxTrans, gg, gg_opmsg, LineLen, @Line)
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
