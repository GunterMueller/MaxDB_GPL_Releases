/*!***************************************************************************
 
  module      : vkb51
  author      : JuergenA,UweH
  responsible : UweH
  special area: SQL locks
  Copyright (c) 2000-2005 SAP AG
  see also    :
  description :
 
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
*****************************************************************************/
 
.tt 1 $SAP$LiveCache$VKB51$
.tt 3 $UweH$KB_locklist$2001-05-02$
 
Module  : KB_locklist
 
Define  :
 
        VAR
              k51_kb_func_calls : tsp00_8ByteCounter;
 
        PROCEDURE
              k51all_req_remove (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k51clear_locklist (VAR t : tgg00_TransContext);
 
        PROCEDURE
              kb51DelConsistTrans (
                    TaskId                : tsp00_TaskId;
                    VAR ConsistViewNo     : tgg91_TransNo);
 
        PROCEDURE
              kb51CancelConsistTrans (
                    TaskId            : tsp00_TaskId;
                    VAR ConsistViewNo : tgg91_TransNo;
                    VAR StartDate     : tsp00_Int4;
                    VAR StartTime     : tsp00_Int4;
                    bUseMinRetentionTime : boolean);
 
        PROCEDURE
              k51del_transentry_from_locklist (
                    TaskId           : tsp00_TaskId;
                    VAR TransIndex   : tgg00_TransIndex;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              kb51EnableHistoryRetention;
 
        PROCEDURE
              k51enter_all_trans_regions (TaskId : tsp00_TaskId);
 
        PROCEDURE
              k51examine_trans (VAR t : tgg00_TransContext);
 
        FUNCTION
              kb51ExclusiveRequestExists (TaskId : tsp00_TaskId;
                    VAR WantedTabId : tgg00_Surrogate) : boolean;
 
        PROCEDURE
              kb51GetFirstOpenRedoTrans (
                    TaskId         : tsp00_TaskId;
                    VAR TransIndex : tgg00_TransIndex);
 
        PROCEDURE
              kb51GetMinTrans (
                    TaskId                      : tsp00_TaskId;
                    VAR MinConsistUsedTransId   : tgg91_TransNo;
                    VAR RetainHistory           : boolean);
 
        PROCEDURE
              kb51GetNextOpenRedoTrans (
                    TaskId         : tsp00_TaskId;
                    VAR TransIndex : tgg00_TransIndex);
 
        PROCEDURE
              kb51GetFirstWriteTrans (VAR WriteTransIndex : tgg00_TransIndex);
 
        PROCEDURE
              kb51GetNextWriteTrans (VAR WriteTransIndex : tgg00_TransIndex);
 
        PROCEDURE
              kb51CreateRedoTransEntry (
                    TaskId         : tsp00_TaskId;
                    WriteTransId   : tgg91_TransNo;
                    VAR TransIndex : tgg00_TransIndex;
                    VAR err        : tgg00_BasisError);
 
        PROCEDURE
              kb51GetRedoTransEntry (
                    TaskId         : tsp00_TaskId;
                    WriteTransId   : tgg91_TransNo;
                    VAR TransIndex : tgg00_TransIndex);
 
        PROCEDURE
              kb51GetLastSelectTransNo (
                    TaskId                : tsp00_TaskId;
                    VAR SelectTransNo     : tgg91_TransNo);
 
        PROCEDURE
              k51get_transindex (
                    TaskId              : tsp00_TaskId;
                    WantedSessionId     : tgg91_SessionNo;
                    WantedWriteTransId  : tgg91_TransNo;
                    InTransRegion       : boolean;
                    VAR TransIndex      : tgg00_TransIndex);
 
        PROCEDURE
              k51handle_request_timeout (VAR Trans : tgg00_TransContext);
 
        FUNCTION
              k51is_locklist_generated (taskid : tsp00_TaskId) : boolean;
 
        PROCEDURE
              kb51IsConsistUsedTransId (
                    TaskId                      : tsp00_TaskId;
                    VAR WriteTransId            : tgg91_TransNo;
                    VAR MinConsistUsedTransId   : tgg91_TransNo;
                    VAR IsTransUsed             : boolean);
 
        FUNCTION
              kb51IsObjTransUsed (
                    TaskId               : tsp00_TaskId;
                    VAR Oid              : tgg00_OidSpace (*ptocSynonym ggg92.h: tgg92_KernelOid&*);
                    VAR ObjTransInfo     : tgg00_ObjTransInfo;
                    ignoreVersions       : boolean ;
                    VAR OldestTransNo    : tgg91_TransNo): boolean;
 
        PROCEDURE
              k51IsTriggerGcNeeded (
                    TaskId             : tsp00_TaskId;
                    TransIndex         : tgg00_TransIndex;
                    VAR OldestTransId  : tgg91_TransNo;
                    VAR IsNeeded       : boolean);
 
        PROCEDURE
              k51leave_all_trans_regions (TaskId : tsp00_TaskId);
 
        FUNCTION
              k51max_locks_per_table : tsp00_Int4;
 
        PROCEDURE
              k51new_select_trans (
                    TaskId                : tsp00_TaskId;
                    VAR SelectTransNo     : tgg91_TransNo);
 
        PROCEDURE
              k51new_session (VAR Trans : tgg00_TransContext);
 
        FUNCTION
              k51number_of_trans_entries : tsp00_Int2;
 
        PROCEDURE
              k51remove_locks (
                    TaskId            : tsp00_TaskId;
                    TransIndex        : tgg00_TransIndex;
                    VAR TransState    : tgg00_TransState);
 
        PROCEDURE     (* PTS 1122885 FF 2003-07-01 *)
              k51remove_locks_2 (
                    VAR Trans         : tgg00_TransContext;
                    TransIndex        : tgg00_TransIndex;
                    VAR TransState    : tgg00_TransState);
 
        PROCEDURE
              k51reset_statistics (TaskId : tsp00_TaskId);
 
        PROCEDURE
              k51restart_locklist (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k51row_excl_check (
                    VAR t     : tgg00_TransContext;
                    VAR TabId : tgg00_Surrogate;
                    VAR k     : tgg00_Lkey);
 
        PROCEDURE
              k51set_not_generated;
 
        PROCEDURE
              k51set_userid (
                    VAR t          : tgg00_TransContext;
                    VAR UserId     : tgg00_UserId;
                    VAR TermId     : tsp00_TermId;
                    IsExclusive    : boolean;
                    IsNologSession : boolean);
 
        PROCEDURE
              kb51StartConsistTrans (VAR Trans : tgg00_TransContext;
                    omsVersion : boolean );
 
        PROCEDURE
              kb51UpdateMinTrans (
                    TaskId    : tsp00_TaskId;
                    triggerGC : boolean );
 
        PROCEDURE
              kb51UpdateMinTransIfNeeded (
                    TaskId           : tsp00_TaskId);
 
        PROCEDURE
              k51sys_share_remove (
                    TaskId                : tsp00_TaskId;
                    TransIndex            : tgg00_TransIndex;
                    VAR TransState        : tgg00_TransState);
 
        PROCEDURE
              k51tab_eot_excl_check (
                    VAR t     : tgg00_TransContext;
                    VAR TabId : tgg00_Surrogate);
 
        PROCEDURE
              k51temp_tab_share_unlock (
                    VAR t           : tgg00_TransContext;
                    VAR WantedTabid : tgg00_Surrogate);
 
        PROCEDURE
              k51unlock_table (
                    TaskId            : tsp00_TaskId;
                    TransIndex        : tgg00_TransIndex;
                    VAR TransState    : tgg00_TransState;
                    VAR Lock          : tgg00_Lock);
 
        PROCEDURE  (* PTS 1134645 FF 2005-04-06 *)
              k51WaitForAllOlderActiveTransToStop (VAR Trans : tgg00_TransContext);
              (*ptocExport hkb51_2.h *)
 
        VAR
              k51glob  : tkb05_Glob;
 
        PROCEDURE
              k51check_ins_lock (
                    VAR t                : tgg00_TransContext;
                    VAR WantedLock       : tkb05_WantedLock;
                    VAR rowLockCollision : boolean);
 
        PROCEDURE
              k51FindConsistView (
                    TaskId          : tsp00_TaskId;
                    TransIndex      : tgg00_TransIndex;
                    ConsistViewNo   : tgg91_TransNo;
                    VAR ConsistView : tkb05_ConsistViewPtr);
 
        PROCEDURE
              kb51GetSessionStart (
                    VAR Trans          : tgg00_TransContext;
                    VAR Date           : tsp00_Int4;
                    VAR Time           : tsp00_Int4);
 
        PROCEDURE
              k51info_lock (
                    TaskId         : tsp00_TaskId;
                    VAR LockInfo   : tkb05_LockInfo);
 
        PROCEDURE
              k51init_wanted_lock (VAR WantedLock : tkb05_WantedLock);
 
        PROCEDURE
              kb51sfree_segment (
                    VAR SupplyPoolGlob : tkb05_SupplyPoolGlob;
                    VAR FreeSegment    : tkb05_SupplySegmPtr);
 
        PROCEDURE
              kb51sget_segment (
                    VAR t              : tgg00_TransContext;
                    VAR SupplyPoolGlob : tkb05_SupplyPoolGlob;
                    VAR NewSegment     : tkb05_SupplySegmPtr);
 
        FUNCTION
              k51tr_index_region (TransIndex : tgg00_TransIndex) : tkb05_RegionNo;
 
        PROCEDURE
              k51unlock (
                    TaskId         : tsp00_TaskId;
                    TransIndex     : tgg00_TransIndex;
                    VAR TransState : tgg00_TransState;
                    VAR WantedLock : tkb05_WantedLock);
 
.CM *-END-* define --------------------------------------
 
Use     :
 
        FROM
              KB_Check : VKB03;
 
        VAR
              kb03Check : tkb00_Check;
 
      ------------------------------ 
 
        FROM
              KB_trans_state : VKB50;
 
        PROCEDURE
              kb50CheckConsistViewOfTrans (
                    VAR Trans     : tgg00_TransContext;
                    VAR ThisTrans : tkb05_TransEntry);
 
        PROCEDURE
              k50hash_rowid (
                    VAR RowId          : tkb05_RowId;
                    KeyLen             : tsp00_Int2;
                    VAR HashValue      : tsp00_Int4);
 
        PROCEDURE
              k50init_wanted_rowid_lock (
                    VAR MoveObj    : tsp00_Key;
                    MoveObjSize    : tsp00_Int4;
                    pos            : tsp00_Int4;
                    KeyLen         : integer;
                    VAR WantedLock : tkb05_WantedLock;
                    VAR MoveError  : tgg00_BasisError);
 
        FUNCTION
              kb50IsValidCollisionEntry (
                    VAR ObjCollEntry : tkb05_ObjCollisionEntry;
                    VAR Oid : tkb05_KernelOid) : boolean;
 
        PROCEDURE
              k50new_write_trans (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              kb50RemoveObjLocks (
                    TaskId        : tsp00_TaskId;
                    VAR ThisTrans : tkb05_TransEntry);
 
      ------------------------------ 
 
        FROM
              Trans_GlobalContext_Wrapper : VKB509;
 
        PROCEDURE
              kb509SetTransactionStartTime(
                    VAR Trans : tkb05_TransEntry);
 
      ------------------------------ 
 
        FROM
              KB_ConsistView_lock : VKB511;
 
        PROCEDURE    (* PTS 1122885 FF 2003-07-01 *)
              kb511EnterConsistView1 (Taskid : tsp00_TaskId;
                    exclusiveRequest        : boolean);
 
        PROCEDURE    (* PTS 1122885 FF 2003-07-01 *)
              kb511LeaveConsistView1 (Taskid : tsp00_TaskId;
                    exclusiveRequest        : boolean);
 
        PROCEDURE    (* PTS 1122885 FF 2003-07-01 *)
              kb511EnterConsistView2 (Taskid : tsp00_TaskId;
                    exclusiveRequest        : boolean);
 
        PROCEDURE    (* PTS 1122885 FF 2003-07-01 *)
              kb511LeaveConsistView2 (Taskid : tsp00_TaskId;
                    exclusiveRequest        : boolean);
 
        PROCEDURE
              kb511InitRWConsistLocks;
 
      ------------------------------ 
 
        FROM
              KB_ObjShare_lock : VKB501;
 
        (* PTS 1128244 FF 2004-03-18 new layer for share object locks *)
        (*                                                            *)
        PROCEDURE
              k501DestroyTransLockInfo (
                    VAR Trans            : tkb05_TransEntry;
                    VAR ThisWriteTransId : tgg91_TransNo);
 
        PROCEDURE
              k501InitOMSShareLocks;
 
        FUNCTION
              k501IsObjTransUsed (
                    TaskId              : tsp00_TaskId;
                    VAR Oid             : tgg00_OidSpace (*ptocSynonym tgg92_KernelOid&*);
                    ignoreVersions      : boolean;
                    VAR UpdTransId_gg00 : tgg91_TransNo;
                    VAR ActTransNo      : tgg91_TransNo): boolean;
 
        PROCEDURE
              k501SetMinTrans(
                    TaskId               : tsp00_TaskId;
                    VAR MinTrans         : tgg91_TransNo);
 
      ------------------------------ 
 
        FROM
              KB_Ext_Trans_Mon : VKB512;
 
        PROCEDURE
              k512MonInit;
 
        PROCEDURE
              k512MonRestartTransaction(VAR monContextPtr : tsp00_Addr);
 
        PROCEDURE
              k512MonStartTransaction(
                    VAR Trans         : tgg00_TransContext;
                    VAR monContextPtr : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              KB_show_lock : VKB52;
 
        PROCEDURE
              k52acc_objcoll_entry (
                    VAR ObjCollGlob     : tkb05_ObjCollGlob;
                    EntryIndex          : tgg00_TransIndex;
                    VAR ObjCollEntryPtr : tkb05_ObjCollEntryPtr);
 
        PROCEDURE
              k52acc_objreq_entry (
                    VAR ObjCollGlob    : tkb05_ObjCollGlob;
                    TransIndex         : tgg00_TransIndex;
                    VAR ObjReqEntryPtr : tkb05_ObjReqEntryPtr);
 
        PROCEDURE
              k52acc_trans_entry (
                    TransIndex        : tgg00_TransIndex;
                    VAR TransEntryPtr : tkb05_TransEntryPtr);
 
        PROCEDURE
              k52begexcl_lockstate (
                    TaskId                 : tsp00_TaskId;
                    VAR LockStateGlobPtr   : tkb05_LockStateGlobPtr);
 
        PROCEDURE
              k52begexcl_objcoll (
                    TaskId               : tsp00_TaskId;
                    VAR ObjCollGlobPtr   : tkb05_ObjCollGlobPtr);
 
        PROCEDURE
              k52begexcl_region (
                    TaskId              : tsp00_TaskId;
                    Region              : tkb05_RegionNo;
                    VAR RegionGlobPtr   : tkb05_RegionGlobPtr);
 
        PROCEDURE
              k52begexcl_supply_pool (
                    TaskId                   : tsp00_TaskId;
                    VAR SupplyPoolGlobPtr    : tkb05_SupplyPoolGlobPtr);
 
        PROCEDURE
              k52endexcl_lockstate (
                    TaskId                 : tsp00_TaskId;
                    VAR LockStateGlobPtr   : tkb05_LockStateGlobPtr);
 
        PROCEDURE
              k52endexcl_objcoll (
                    TaskId               : tsp00_TaskId;
                    VAR ObjCollGlobPtr   : tkb05_ObjCollGlobPtr);
 
        PROCEDURE
              k52endexcl_region (
                    TaskId              : tsp00_TaskId;
                    VAR RegionGlobPtr   : tkb05_RegionGlobPtr);
 
        PROCEDURE
              k52endexcl_supply_pool (
                    TaskId                   : tsp00_TaskId;
                    VAR SupplyPoolGlobPtr    : tkb05_SupplyPoolGlobPtr);
 
        PROCEDURE
              k52flush_consist_view    (VAR ConsistView   : tkb05_ConsistView);
 
        PROCEDURE
              k52flush_hash_open_trans (VAR HashOpenTrans : tkb05_HashOpenTrans);
 
        PROCEDURE
              k52flush_objreq_entry    (VAR ObjReqEntry   : tkb05_ObjReqEntry);
 
        PROCEDURE
              k52flush_row_lock        (VAR RowLock       : tkb05_RowLock);
 
        PROCEDURE
              k52flush_row_trans       (VAR RowTrans      : tkb05_RowTrans);
 
        PROCEDURE
              k52flush_tab_lock        (VAR TabLock       : tkb05_TabLock);
 
        PROCEDURE
              k52flush_tab_trans       (VAR TabTrans      : tkb05_TabTrans);
 
        PROCEDURE
              k52flush_trans_entry     (VAR TransEntry    : tkb05_TransEntry);
 
        PROCEDURE
              k52flush_trans_glob      (VAR TransGlob     : tkb05_TransGlob);
 
        PROCEDURE
              k52flush_trans_waiting   (VAR TransWaiting  : boolean);
 
        FUNCTION
              k52used_items_of_region (VAR RegionGlob : tkb05_RegionGlob): tsp00_Int4;
 
        FUNCTION
              k52used_trans_of_region (VAR RegionGlob : tkb05_RegionGlob): tsp00_Int4;
 
        PROCEDURE
              k52x_item_error (
                    msg            : tsp00_C24;
                    ItemKind       : tkb05_ItemKind);
 
        PROCEDURE
              k52x_loop_error (
                    msg            : tsp00_C24;
                    error_no       : tsp00_Int4);
&       ifdef TRACE
 
        PROCEDURE
              k52xaddr_rowl (
                    debug   : tgg00_Debug;
                    msg     : tsp00_Sname;
                    RowLock : tkb05_RowLockPtr);
 
        PROCEDURE
              k52xaddr_rowl_check (
                    VAR RowRegionGlob : tkb05_RegionGlob;
                    RowLock : tkb05_RowLockPtr);
 
        PROCEDURE
              k52xaddr_rowt (
                    debug    : tgg00_Debug;
                    msg      : tsp00_Sname;
                    RowTrans : tkb05_RowTransPtr);
 
        PROCEDURE
              k52xaddr_rowt_check (
                    VAR TransRegionGlob : tkb05_RegionGlob;
                    RowTrans : tkb05_RowTransPtr);
 
        PROCEDURE
              k52xaddr_tabl (
                    debug   : tgg00_Debug;
                    msg     : tsp00_Sname;
                    TabLock : tkb05_TabLockPtr);
 
        PROCEDURE
              k52xaddr_tabl_check (
                    VAR TabRegionGlob : tkb05_RegionGlob;
                    TabLock : tkb05_TabLockPtr);
 
        PROCEDURE
              k52xaddr_tabt (
                    debug    : tgg00_Debug;
                    msg      : tsp00_Sname;
                    TabTrans : tkb05_TabTransPtr);
 
        PROCEDURE
              k52xaddr_tabt_check (
                    VAR TransRegionGlob : tkb05_RegionGlob;
                    TabTrans : tkb05_TabTransPtr);
 
        PROCEDURE
              k52xregion_supply_check (VAR RegionGlob : tkb05_RegionGlob);
 
        PROCEDURE
              k52xreq (
                    debug    : tgg00_Debug;
                    Req      : tkb05_ReqPtr);
 
        PROCEDURE
              k52xrow_lock (
                    debug : tgg00_Debug;
                    Row : tkb05_RowLockPtr);
 
        PROCEDURE
              k52xrow_region_check (VAR RowRegionGlob : tkb05_RegionGlob);
 
        PROCEDURE
              k52xrow_trans (
                    debug : tgg00_Debug;
                    Row : tkb05_RowTransPtr);
 
        PROCEDURE
              k52xtab_lock (
                    debug : tgg00_Debug;
                    Tab : tkb05_TabLockPtr);
 
        PROCEDURE
              k52xtab_region_check (VAR TabRegionGlob : tkb05_RegionGlob);
 
        PROCEDURE
              k52xtab_trans (
                    debug : tgg00_Debug;
                    Tab : tkb05_TabTransPtr);
 
        PROCEDURE
              k52xtrans (
                    debug      : tgg00_Debug;
                    TransEntry : tkb05_TransEntryPtr);
 
        PROCEDURE
              k52xwanted_lock (
                    debug            : tgg00_Debug;
                    VAR WantedLock   : tkb05_WantedLock);
&       endif
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        FUNCTION
              kb560IsSys2CatalogTable(
                    VAR tabId : tgg00_Surrogate) : boolean;
 
        FUNCTION
              kb560TransactionIsOpen (TransPtr : tsp00_Addr) : boolean;
 
      ------------------------------ 
 
        FROM
              KB_restart_record : VKB57;
 
        PROCEDURE
              k57new_session (
                    TaskId           : tsp00_TaskId;
                    VAR SessionId    : tgg91_SessionNo);
 
        PROCEDURE
              k57new_write_trans (
                    TaskId      : tsp00_TaskId;
                    VAR TransNo : tgg91_TransNo);
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11put_date_time (
                    VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_4 : VBD04;
 
        PROCEDURE
              bd04CancelOmsVersion (
                    TaskId            : tsp00_TaskId;
                    VAR ConsistViewNo : tgg91_TransNo);
 
      ------------------------------ 
 
        FROM
              error_text_handling : VBD06;
 
        PROCEDURE
              b06put_errtxt (
                    VAR t         : tgg00_TransContext;
                    taskId        : tsp00_TaskId;
                    errlen        : integer;
                    etexttype     : tgg04_ErrorText;
                    b_err_in      : tgg00_BasisError;
                    VAR errtxt    : tsp00_C256;
                    VAR b_err_out : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (
                    VAR t        : tgg00_TransContext;
                    trace_layer  : tgg00_Debug;
                    trace_object : tgg00_VtraceType;
                    body_len     : tsp00_Int2;
                    trace_body   : tgg11_VtraceBodyPtr);
 
      ------------------------------ 
 
        FROM
              Filedirectory : VBD170;
 
        PROCEDURE
              bd170CreateUserFiledirectory (VAR Trans : tgg00_TransContext;
                    VAR pFiledir : tsp00_Addr);
 
        PROCEDURE
              bd170DeleteUserFiledirectory (VAR Trans : tgg00_TransContext;
                    VAR pFiledir : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              object_garbage_collection : VBD91;
 
        PROCEDURE
              bd91InitRWRecreateIndex; (* PTS 1134645 FF 2005-04-06 *)
 
        FUNCTION
              b91MaxRetentionTime : tsp00_Int4;
 
        FUNCTION
              b91MinRetentionTime : tsp00_Int4;
 
        PROCEDURE
              bd91StartOMSGarbageCollectionIfRequired (TaskId : tsp00_TaskId);
 
      ------------------------------ 
 
        FROM
              BD_Wrapper : VBD999;
 
        PROCEDURE
              bd999SetMinTrans(VAR MinTrans : tgg91_TransNo (*ptocconst *));
 
        FUNCTION
              bd999GetDataIOBlockCount : tsp00_Int4;
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01timeout : tgg00_TimeoutGlobals;
              g01vtrace  : tgg00_VtraceState;
 
        PROCEDURE
              g01abort (
                    MsgNo     : tsp00_Int4;
                    MsgLabel  : tsp00_C8;
                    MsgText   : tsp00_C24;
                    BadValue  : tsp00_Int4);
 
        FUNCTION
              g01align (val : tsp00_Int4): tsp00_Int4;
 
        PROCEDURE
              g01allocate_msg (
                    MsgLabel  : tsp00_C8;
                    MsgText   : tsp00_C24;
                    AllocSize : tsp00_Int4);
 
        PROCEDURE
              g01check (
                    MsgNo      : tsp00_Int4;
                    MsgLabel   : tsp00_C8;
                    MsgText    : tsp00_C24;
                    BadValue   : tsp00_Int4;
                    Constraint : boolean);
 
        FUNCTION
              g01deadlock_detection : tsp00_Int4;
 
        FUNCTION
              g01lock_supply_block : tsp00_Int4;
 
        FUNCTION
              g01maxlocks : tsp00_Int4;
 
        FUNCTION
              g01maxtrans : tsp00_Int4;
 
        FUNCTION
              g01region_cnt (RegionType : tgg00_RegionType) : tsp00_Int4;
 
        PROCEDURE
              g01time_vtrace (
                    VAR t           : tgg00_TransContext;
                    msg             : tsp00_Name;
                    VAR StartSec    : tsp00_Int4;
                    VAR StartMsec   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        PROCEDURE
              gg06BuildRedoSession (VAR Session : tgg91_SessionNo;
                    VAR transno : tgg91_TransNo);
 
        FUNCTION    (* PTS 1128244 FF 2004-03-18 *)
              gg06IsZeroTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        FUNCTION
              gg06IsDummyTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        FUNCTION
              gg06IsMaxTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        FUNCTION
              gg06IsNilTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        FUNCTION
              gg06SessionGetInt4 (VAR SessionNo : tgg91_SessionNo): tsp00_Int4;
 
        PROCEDURE
              gg06SetNilOid (VAR oid : tgg00_OidSpace);
 
        PROCEDURE
              gg06SetNilSession (VAR SessionNo : tgg91_SessionNo);
 
        PROCEDURE
              gg06SetNilTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              gg06SetZeroTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              gg06TransIncr (VAR TransNo : tgg91_TransNo);
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        (* g08cnstview : tsp00_RegionId; PTS 1122885 FF 2003-07-01 *)
        VAR
              g08lockinit : tsp00_RegionId;
              g08lockpool : tsp00_RegionId;
              g08lockreq  : tsp00_RegionId;
              g08lockwait : tsp00_RegionId;
              g08lock0    : tsp00_RegionId;
 
        PROCEDURE
              g08check_excl (Region : tsp00_RegionId);
 
        PROCEDURE
              g08excl_check (
                    TaskId          : tsp00_TaskId;
                    Region          : tsp00_RegionId);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        FUNCTION
              gg999KernelStateIsOnline : boolean;
 
        PROCEDURE
              gg999TryToResumeRedoReader (taskid : tsp00_TaskId);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vallocat (
                    Length     : tsp00_Int4;
                    VAR p      : tsp00_ObjAddr;
                    VAR ok     : boolean);
 
        PROCEDURE
              vbegexcl (
                    TaskId     : tsp00_TaskId;
                    Region     : tsp00_RegionId);
 
        PROCEDURE
              vclock (
                    VAR sec      : tsp00_Int4;
                    VAR microsec : tsp00_Int4);
 
        PROCEDURE
              vendexcl (
                    TaskId     : tsp00_TaskId;
                    Region     : tsp00_RegionId);
 
        PROCEDURE
              vgetpid (VAR TaskId : tsp00_TaskId);
 
        PROCEDURE
              vprio (
                    TaskId  : tsp00_TaskId;
                    prio    : tsp00_Uint1;
                    SetPrio : boolean);
 
        PROCEDURE
              vresume (TaskId    : tsp00_TaskId);
 
        PROCEDURE
              vsignal (
                    TaskId    : tsp00_TaskId;
                    ok        : boolean);
 
        PROCEDURE
              vsleep (
                    pid   : tsp00_TaskId;
                    limit : tsp00_Int2);
 
        PROCEDURE
              vwait (TaskId : tsp00_TaskId; VAR ok : boolean);
 
        PROCEDURE
              vfreebuf (count     : tsp00_Int4;
                    p             : tsp00_Addr;
                    VAR ok        : boolean);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    obj_upb  : tsp00_Int4;
                    obj      : tsp00_MoveObjPtr;
                    obj_pos  : tsp00_Int4;
                    length   : tsp00_Int4;
                    fillchar : char;
                    VAR e    : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    ModuleId    : tsp00_C6;
                    ModuleNo    : tsp00_Int4;
                    SourceUpb   : tsp00_Int4;
                    DestUpb     : tsp00_Int4;
                    source      : tsp00_MoveObjPtr;
                    SrcPos      : tsp00_Int4;
                    destin      : tsp00_MoveObjPtr;
                    DestPos     : tsp00_Int4;
                    Length      : tsp00_Int4;
                    VAR err     : tgg00_BasisError);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    BufAddr  : tkb05_TransEntryPtr);
 
        PROCEDURE
              t01addr_1 (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    bufaddr    : tkb05_SupplyItemPtr);
 
        PROCEDURE
              t01addr_2 (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    bufaddr    : tkb05_SupplySegmPtr);
 
        PROCEDURE
              t01basis_error (
                    debug : tgg00_Debug;
                    nam : tsp00_Sname;
                    err : tgg00_BasisError);
 
        PROCEDURE
              t01c4int (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    int       : tsp00_C4);
 
        PROCEDURE
              t01bool (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    curr_bool : boolean);
 
        PROCEDURE
              t01int4 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (
                    debug      : tgg00_Debug;
                    nam_1      : tsp00_Sname;
                    int_1      : tsp00_Int4;
                    nam_2      : tsp00_Sname;
                    int_2      : tsp00_Int4);
 
        PROCEDURE
              t01localstate (
                    debug : tgg00_Debug;
                    nam : tsp00_Sname;
                    s   : tgg00_TransState);
 
        PROCEDURE
              t01lockmode (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    LockMode     : tgg00_LockReqMode);
 
        PROCEDURE
              t01lockstate (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    LockState     : tgg00_LockReqState);
 
        PROCEDURE
              t01name1 (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    n         : tsp00_Name);
 
        PROCEDURE
              ta01SessionTrans (
                    debug             : tgg00_Debug;
                    nam               : tsp00_Sname;
                    VAR session       : tgg91_SessionNo;
                    VAR trans         : tgg91_TransNo;
                    VAR write_trans   : tgg91_TransNo;
                    VAR subtrans      : tgg00_SubtransNo);
 
        PROCEDURE
              ta01Session (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    VAR session  : tgg91_SessionNo);
 
        PROCEDURE
              t01surrogate (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR TabId     : tgg00_Surrogate);
 
        FUNCTION
              t01trace (debug : tgg00_Debug) : boolean;
 
        PROCEDURE
              t01trans (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR t     : tgg00_TransContext);
 
        PROCEDURE
              ta01TransNo (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    VAR TransNo  : tgg91_TransNo);
&       endif
 
.CM *-END-* use -----------------------------------------
 
Synonym :
 
        PROCEDURE
              k50init_wanted_rowid_lock;
 
              tsp00_MoveObj tsp00_Key

        PROCEDURE
              vfreebuf;
 
              tsp00_PageAddr tsp00_Addr
 
&             ifdef TRACE
 
        PROCEDURE
              t01addr;
 
              tsp00_BufAddr tkb05_TransEntryPtr
 
        PROCEDURE
              t01addr_1;
 
              tsp00_BufAddr tkb05_SupplyItemPtr
 
        PROCEDURE
              t01addr_2;
 
              tsp00_BufAddr tkb05_SupplySegmPtr
&             endif
 
.CM *-END-* synonym -------------------------------------
 
***********************************************************
 
Specification:
 
Monitoring:
 
The monitor variables are set to zero in K51RESTART_LOCKLIST
and are written into the dump HostFile by K51DUMP.
This module contains the following monitor variables:
 
COUNT_KB_CALLS  Number of procedure calls of K51TIMEOUT_CHECK
 
TIME_K51TIMEOUT elapsed time in K51TIMEOUT_CHECK
 
TIME_INSERT     elapsed time for all insert locks
 
TIME_REMOVE     elapsed time for all remove locks (COMMIT/ROLLBACK without KEEP LOCK)
 
The types LOCKMODE and TRANSLOCKMODE are used for managing the
locks; LOCKMODE identifies the exact Lock and TRANSLOCKMODE
simply indicates whether an exclusive Lock (WRITE_LOCK), a share Lock
(READ_LOCK) or an special exclusive Lock (EXCL_LOCK) (i.e. an exclusive
Lock that can be released before the end of a transaction) exists.
 
Significance of the individual Lock modes:
 
sys exclusive   Exlcusive Lock on a table and its description
                in the system catalog.
                Other users are not allowed to read or change the table description
                or the contents of the table.
 
sys share       Share Lock on a table description in the system catalog.
                Other users are not allowed to change the table description.
 
 
tab exclusive   Exclusive Lock on a table. Other users are not allowed to
                change the table description or to read or change the table contents.
 
tab share       Share Lock on a table. Other users are not allowed to
                change the table description or the table contents.
 
row exclusive   Exclusive Lock on a Row of a table. Other users are not
                allowed to change the table description or to read or change the table Row.
 
row share       Share Lock on a Row of a table. Other users are not
                allowed to change the table description or the table Row.
 
 
Procedure K51LOCKLIST_CLOSED
 
Checkpoints can be written only when no exclusive locks exist in the
Lock list. In order to empty the Lock list, it is closed.
If no write transactions are present, a checkpoint
is written and K51CLOSED_LOCKLIST is set to none.
A checkpoint is triggered by the commit or rollback command.
The Lock list is also closed for some utilities (e.g. SAVE DATA).
 
 
Procedure K51CLEAR_LOCKLIST
 
The timeout process calls this procedure to handle the request timeout
and request timeout. The process decrements the Timeout values by 30
seconds. The requests for which timeout was given are removed from the
request list and the associated processes are activated.
 
 
Procedure K51CHECK_INS_LOCK
 
Checks whether or not a Lock-list entry
collides with already existing locks of other transactions. If yes,
this fact is recorded for the other transactions to be taken into
account in the event of a Timeout (set TE_COLLISION). Since only
the prefix and postfix and 4 bytes hash of the key are contained in the Lock, a
collision also occurs if a part of the key is not identical but
the key Length matches.
If a collision occurrs E_LOCK_COLLISION is set.
 
 
Collisions occur under the following conditions:
 
         | Locked
         | sys   | tab   | tab   | row   | row   | row   | sys
wanted   | excl  | excl  | share | excl  | share | optim | share
---------+-------+-------+-------+-------+-------+-------+-------
sys excl |   X   |   X   |   X   |   X   |   X   |   2)  |   X
---------+-------+-------+-------+-------+-------+---------------
tab excl |   X   |   X   |   X   |   X   |   X   |   2)  |
---------+-------+-------+-------+-------+-------+---------------
tab share|   X   |   X   |       |   X   |       |       |
---------+-------+-------+-------+-------+-------+---------------
row excl |   X   |   X   |   X   |   1)  |   1)  |   2)  |
---------+-------+-------+-------+-------+-------+---------------
row share|   X   |   X   |       |   1)  |       |       |
---------+-------+-------+-------+-------+-------+---------------
row optim|   X   |   X   |       |   1)  |       |       |
---------+-------+-------+-------+-------+-------+---------------
sys share|   X   |       |       |       |       |       |
  1) = collision only if the Row key matches
 
 
Procedure K51DUMP_LOCKLIST
 
This procedure writes either "K51UNDEF" if GENERATED = false, or
it writes the dump information to the specified host file:
 
 
Procedure K51GET_TRANSINDEX
 
Returns the array index (TRANSINDEX) for the specified transaction.
 
 
Procedure K51INFO_LOCK
 
Returns the available Number of Lock entries (MAX_LOCKS), the
Number of used Lock entries (LOCKS_USED), the Number of allocated
Lock buffers (BUFFERS), the Lock escalation size (KEY_PER_TAB),
the Number of Lock transactions (LOCK_TRANS) and the Number
of request transactions (REQ_TRANS).
 
 
Function K51IS_CLOSED_LOCKLIST
 
Returns TRUE if the locklist is closed (K51.CLOSED_LOCKLIST).
 
 
Procedure K51LOGPOS_INSERT
 
Inserts a TransId with a Log position. This
procedure is used during restart to identify the last Log position
of an open transactions for a rollback.
 
 
Function K51MAX_LOCKS_PER_TABLE
 
Supplies the maximum Number of key locks for a table (Lock escalation).
If this Number is exceeded, the entire table should be Locked.
 
 
Procedure K51REMOVE_LOCKS
 
All Lock list entries of a transaction are removed from the Lock list.
If the Lock list is now empty, this is signalled by the parameter
EMPTY so that it is then possible to write a checkpoint.
 
 
Procedure K51RESTART_LOCKLIST
 
Initializes all Lock list elements with the mode 'free'
and releases the Lock list (LOCKLIST_CLOSED := false).
 
 
Procedure K51ROW_EXCL_CHECK
 
Returns the error KB_REC_NOT_LOCKED if
the specified table id and key is not Locked.
 
Procedure K51SET_NOT_GENERATED
 
Sets the state indicating that no Lock pages have been allocated.
This procedure is called when the kernel is initialized.
 
 
Procedure K51TIMEOUT_CHECK
 
Checks the Timeout state.
In the case of entry into KB layer, the last Log position
is assigned to LAST_FUNCTION_ROLLBACK so that it is possible to
backout all data changes for a K05FUNCTION call (e.g. an insert with index changes).
 
 
Procedure K51UNLOCK_KEY
 
The specified key Lock is removed from the Lock list, given
it is only Locked in share mode or for update (KEY_READLOCK, KEY_EXCL).
 
 
Procedure KB51DEADLOCK_DETECTION
 
Starting from THIS_TRANS, searches to find out whether there is
a direct DEADLOCK with ROOT_TRANS or continues to search recursively
in the transaction that has locks on the requests of THIS_TRANS.
The recursive search is limited by DEADLOCK_SEARCH_LIMIT.
 
 
Procedure KB51NEW_TRANS
 
Inserts a new Trans entry in the translock list, initializes the list
with the specified Lock entry and returns its array position (INDEX).
 
.CM *-END-* specification -------------------------------
 
***********************************************************
 
Description:
 
.CM *-END-* description ---------------------------------
 
***********************************************************
 
Structure:
 
.CM *-END-* structure -----------------------------------
 
**********************************************************
 
.CM -lll-
Code    :
 
 
CONST
      AVERAGE_ROW_LOCKS_PER_TAB =   5;
      ESCALATION_INTERVAL       = 100;
      ITEMS_PER_ROW_LOCK        =   3; (* RowTrans + RowLock + RowId *)
      MIN_EXTENT_SEGMS_PER_RGN  =   3;
      MIN_HASH_PER_REGION       =   3;
      MIN_SUPPLY_ITEMS_PER_RGN  = 100;
      MIN_TRANS_PER_REGION      =   5;
      USER_LOCK_PRIO            =   1;
      (* *)
      HOLD_TAB_LOCK       = true;
      IGNORE_REQ_PRIORITY = true;
      IN_TRANS_REGION     = true;
      IS_OK               = true;
      RELEASE_ROW_LOCKS   = true;
      REMOVE_EXCL_ROWS    = true;
      REQUEST_TIMEOUT     = true;
      SATISFY_REQUESTS    = true;
      SET_PRIO            = true;
      (* PTS 1106064 JA 2000-03-21 *)
      (* PTS 1114187 *)
      (* PTS 1116157 FF 2002-06-07 *)
      IF_GC_WAITTIME_DONE = true;
      (* *)
      ERR_DEADLOCK = 'DEADLOCK DETECTED   ';
 
 
(*------------------------------*) 
 
PROCEDURE
      k51all_req_remove (VAR t : tgg00_TransContext);
 
VAR
      CurrTransRegion : tkb05_RegionNo;
      TransCnt        : tsp00_Int4;
      TransLimit      : tsp00_Int4;
      CurrTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
t.trError_gg00 := e_ok;
FOR CurrTransRegion := 1 TO k51glob.glTransRegions_kb05 DO
    BEGIN
    k52begexcl_region (t.trTaskId_gg00, CurrTransRegion, TransRgnGlobPtr);
    TransLimit := k52used_trans_of_region (TransRgnGlobPtr^);
    TransCnt   := 0;
    CurrTrans  := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
    WHILE (CurrTrans <> NIL) AND (TransCnt <= TransLimit) DO
        BEGIN
        IF  CurrTrans^.teTimeoutEnabled_kb05
        THEN
            BEGIN
            IF  CurrTrans^.teObjReq_kb05 <> cgg_nil_transindex
            THEN
                kb51_ObjReqTimeoutHandling (t, CurrTrans)
            ELSE
                IF  CurrTrans^.teReqTab_kb05 <> NIL
                THEN
                    BEGIN
                    (* PTS 1106270 JA 2000-04-06: timeout is handled by waiting task *)
                    kb51signal_resume (t.trTaskId_gg00, CurrTrans^.teOwnIndex_kb05, NOT IS_OK)
                    END
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        TransCnt  := TransCnt + 1;
        CurrTrans := CurrTrans^.teNextTrans_kb05
        END;
    (*ENDWHILE*) 
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
    IF  TransCnt > TransLimit
    THEN
        k52x_loop_error ('k51all_req_remove       ', 1)
    (*ENDIF*) 
    END
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51check_ins_lock (
            VAR t                : tgg00_TransContext;
            VAR WantedLock       : tkb05_WantedLock;
            VAR rowLockCollision : boolean);
 
VAR
      AlreadyLocked     : boolean;
      Collided          : boolean;
      IgnoreReqPriority : boolean;
      LockEscalation    : boolean;
      TabCollided       : boolean;
      WaitInserted      : boolean;
      WantedHandling    : tkb05_Handling;
      WantedLockMode    : tgg00_LockReqMode;
      TransLockMode     : tkb05_TransLockMode;
      AuxHandling       : tkb05_Handling;
      RowRegion         : tkb05_RegionNo;
      TabRegion         : tkb05_RegionNo;
      TransRegion       : tkb05_RegionNo;
      RowHash           : tsp00_Int4;
      TabHash           : tsp00_Int4;
      TabOptimVers      : tsp00_Int4;
      RowOptimVers      : tsp00_Int4;
      StartSec          : tsp00_Int4;
      StartMsec         : tsp00_Int4;
      ConsistRow        : tkb05_RowTransPtr; (* JA 1998-09-30 *)
      PrevRow           : tkb05_RowTransPtr;
      PrevTab           : tkb05_TabTransPtr;
      Row               : tkb05_RowTransPtr;
      RowLock           : tkb05_RowLockPtr;
      Tab               : tkb05_TabTransPtr;
      TabLock           : tkb05_TabLockPtr;
      TabRegionGlobPtr  : tkb05_RegionGlobPtr;
      ThisTrans         : tkb05_TransEntryPtr;
      TransRgnGlobPtr   : tkb05_RegionGlobPtr;
 
BEGIN
&ifdef TRACE
t01trans (kb_lock, 'check_ins_tr', t);
k52xwanted_lock (kb_lock, WantedLock);
&endif
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g01check (kb51c1CheckInsLock_csp03, csp3_n_lock,
          'wrong Lock mode         ', ord (WantedLock.wlMode_kb05),
          WantedLock.wlMode_kb05 <> lckFree_egg00);
    (* *)
    g01check (kb51c2CheckInsLock_csp03, csp3_n_lock,
          'wrong handling          ', 0,
          (**)
          (* collision test only, nowait *)
          (WantedLock.wlHandling_kb05 = [hdCheckCollision_ekb05])
          OR
          (* collision test only, wait *)
          (WantedLock.wlHandling_kb05 = [hdCheckCollision_ekb05, hdInsReq_ekb05])
          OR
          (* insert lock, nowait *)
          (WantedLock.wlHandling_kb05 = [hdCheckCollision_ekb05, hdInsLock_ekb05])
          OR
          (* insert lock, wait *)
          (WantedLock.wlHandling_kb05 = [hdCheckCollision_ekb05, hdInsLock_ekb05, hdInsReq_ekb05])
          OR
          (* insert lock without collision check *)
          (WantedLock.wlHandling_kb05 = [hdInsLock_ekb05]));
    (* *)
&   ifdef NOT_USED
    IF  (lrsIgnoreInsert_egg00 in WantedLock.wlState_kb05)
        AND
        NOT (hdInsLock_ekb05 in WantedLock.wlHandling_kb05)
    THEN
        g01check (kb51c2CheckInsLock_csp03, csp3_n_lock,
              'IgnIns must have InsLock', 0, false);
&   endif
    (*ENDIF*) 
    END;
(*ENDIF*) 
t.trError_gg00 := e_ok;
AlreadyLocked  := false;
Collided       := false;
TabCollided    := false;
LockEscalation := false;
WaitInserted   := false;
TransRegion    := k51tr_index_region (t.trIndex_gg00);     (* PTS 1132041 FF 20-OCT-2004 *)
(* TransRegion    := kb51trans_region (t.trSessionId_gg00); PTS 1132041 *)
TransLockMode  := tlmFree_ekb05;
ThisTrans      := NIL;
Row            := NIL;
Tab            := NIL;
RowLock        := NIL;
TabLock        := NIL;
PrevRow        := NIL;
PrevTab        := NIL;
WantedHandling := WantedLock.wlHandling_kb05;
WantedLockMode := WantedLock.wlMode_kb05;
IF  g01vtrace.vtrTime_gg00
THEN
    vclock (StartSec, StartMsec);
(*ENDIF*) 
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex
ELSE
    IF  gg06IsNilTrans (t.trWriteTransId_gg00)
        AND
        (lrsEotExcl_egg00 in WantedLock.wlState_kb05)
    THEN
        k50new_write_trans (t);
    (*ENDIF*) 
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    (* check outside Trans Region *)
    kb51cancel_and_log_full_check (t, ThisTrans);
(*ENDIF*) 
IF  g01vtrace.vtrTime_gg00
THEN
    g01time_vtrace (t, 'k51: timeout_check', StartSec, StartMsec);
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND (ThisTrans = NIL)
THEN
    t.trError_gg00 := e_nil_transindex;                              (* PTS 1107452 JA 2000-08-08 *)
(*ENDIF*) 
IF  NOT gg999KernelStateIsOnline
THEN
    BEGIN
    WantedLock.wlGrantedMode_kb05 := WantedLock.wlMode_kb05;
    rowLockCollision              := false;
    END
ELSE
    BEGIN
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        TransLockMode := ThisTrans^.teLockMode_kb05;
        IF  TransLockMode <> tlmEotExcl_ekb05                            (* PTS 1001791 UH 1999-01-04 *)
        THEN
            (* used for checkpoint-collision-check and hint for request order *)
            TransLockMode := ThisTrans^.teObjLockMode_kb05;              (* PTS 1001791 UH 1999-01-04 *)
        (* PTS 1110237 E.Z. *)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok                                            (* PTS 1107452 JA 2000-08-08 *)
    THEN
        BEGIN
        kb51tabid_search (ThisTrans, WantedLock.wlTabId_kb05, Tab, PrevTab);
        IF  g01vtrace.vtrTime_gg00
        THEN
            g01time_vtrace (t, 'kb51tabid_search  ', StartSec, StartMsec);
        (*ENDIF*) 
        IF  Tab <> NIL
        THEN
            BEGIN
&           ifdef TRACE
            k52xtab_trans (kb_lockentry, Tab);
&           endif
            TabLock := Tab^.ttTab_kb05;
            kb51tab_already_locked (t.trTaskId_gg00, ThisTrans, Tab, WantedLock, AlreadyLocked);
            IF  NOT AlreadyLocked AND WantedLock.wlRowWanted_kb05
            THEN
                BEGIN
                IF  Tab^.ttKeySort_kb05                                  (* PTS 1107056 JA 2001-03-01 *)
                THEN
                    BEGIN
                    kb51rowid_search (ThisTrans, Tab, WantedLock, Row, PrevRow);
                    IF  tab^.ttRowShareLocks_kb05 + tab^.ttRowExclLocks_kb05 > MAX_SORTED_ROW_LOCKS_KB05
                    THEN
                        (* outside region - private access only *)
                        Tab^.ttKeySort_kb05 := false                     (* PTS 1107056 JA 2001-03-01 *)
                    (*ENDIF*) 
                    END
                ELSE
                    (* PTS 1107056 JA 2001-03-01 *)
                    IF  kb51exists_row_lock (t.trTaskId_gg00, t.trIndex_gg00, WantedLock,
                        AlreadyLocked) (* PTS 1115302 UH 2002-05-02 *)
                        AND
                        NOT AlreadyLocked (* PTS 1115302 UH 2002-05-02 *)
                    THEN
                        kb51rowid_search (ThisTrans, Tab, WantedLock, Row, PrevRow);
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  g01vtrace.vtrTime_gg00
                THEN
                    g01time_vtrace (t, 'kb51rowid_search  ', StartSec, StartMsec);
                (*ENDIF*) 
                IF  Row <> NIL
                THEN
                    BEGIN
&                   ifdef TRACE
                    k52xrow_trans (kb_lockentry, Row);
&                   endif
                    RowLock := Row^.rtRow_kb05;
                    kb51row_already_locked (t.trTaskId_gg00, ThisTrans, Row, WantedLock, AlreadyLocked);
                    END;
                (*ENDIF*) 
                IF  NOT AlreadyLocked
                THEN
                    BEGIN
                    kb51try_escalation (t.trRowLocksPerSqlCmd_gg00, WantedLock, Tab, LockEscalation);
                    (* PTS 1001067 *)
                    IF  LockEscalation
                        AND
                        (WantedLock.wlMode_kb05 = lckTabShare_egg00)
                        AND
                        (Tab^.ttLockMode_kb05   = lckTabShare_egg00)
                    THEN
                        (* try:  temp tab share -> tab share *)
                        kb51tab_already_locked (t.trTaskId_gg00, ThisTrans, Tab, WantedLock, AlreadyLocked)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  g01vtrace.vtrTime_gg00
    THEN
        vclock (StartSec, StartMsec);
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) AND NOT AlreadyLocked
        AND
        k51glob.glSupplyPoolGlob_kb05^.poolEmptyWarning_kb05   (* outside lockpool Region *)
        AND
        ((hdInsLock_ekb05 in WantedLock.wlHandling_kb05) OR
        ( hdInsReq_ekb05  in WantedLock.wlHandling_kb05))
    THEN
        t.trError_gg00 := e_too_many_lock_requests;
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) AND NOT AlreadyLocked
    THEN
        BEGIN
        IgnoreReqPriority := NOT (hdInsLock_ekb05 in WantedLock.wlHandling_kb05);
        IF  LockEscalation
            AND NOT (hdInsReq_ekb05 in WantedLock.wlHandling_kb05)
        THEN
            BEGIN
            kb51tab_lock_check_ins (t,
                  NIL, (* not in TabRegion *)
                  WantedLock, TransLockMode, IgnoreReqPriority,
                  Tab, Row, TabRegion, TabHash, TabLock,
                  TabOptimVers, Collided, WaitInserted);
            IF  g01vtrace.vtrTime_gg00
            THEN
                g01time_vtrace (t, 'k51: escalation   ', StartSec, StartMsec);
            (*ENDIF*) 
            IF  Collided
            THEN
                (* reset Lock escalation state *)
                BEGIN
                LockEscalation              := false;
                Collided                    := false;
                WantedLock.wlHandling_kb05  := WantedHandling;
                WantedLock.wlMode_kb05      := WantedLockMode;
                WantedLock.wlRowWanted_kb05 := true
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (t.trError_gg00 = e_ok)
            AND
            (NOT LockEscalation OR (hdInsReq_ekb05 in WantedLock.wlHandling_kb05))
        THEN
            kb51tab_lock_check_ins (t,
                  NIL, (* not in TabRegion *)
                  WantedLock, TransLockMode, IgnoreReqPriority,
                  Tab, Row, TabRegion, TabHash, TabLock,
                  TabOptimVers, Collided, WaitInserted);
        (*ENDIF*) 
        TabCollided := Collided;
        IF  g01vtrace.vtrTime_gg00
        THEN
            g01time_vtrace (t, 'kb51tab_lock_check', StartSec, StartMsec);
        (*ENDIF*) 
        IF  (t.trError_gg00 = e_ok)
            AND
            WantedLock.wlRowWanted_kb05
            AND
            (NOT Collided OR (hdInsReq_ekb05 in WantedLock.wlHandling_kb05))
        THEN
            BEGIN
            (* PTS 1103743 JA 1999-08-25 *)
            t.trRowLocksPerSqlCmd_gg00 := t.trRowLocksPerSqlCmd_gg00 + ONE_8BYTE_CNT_GG04;
            kb51row_lock_check_ins (t, WantedLock,
                  TransLockMode, (* JA 1996-12-04 *)
                  Row, RowRegion, RowHash, RowLock, RowOptimVers,
                  Collided, WaitInserted);
            IF  g01vtrace.vtrTime_gg00
            THEN
                g01time_vtrace (t, 'kb51row_lock_check', StartSec, StartMsec);
            (*ENDIF*) 
            IF  (
                Collided
                OR
                (t.trError_gg00 = e_lock_dirty)
                OR
                (t.trError_gg00 = e_lock_collision_with_inserted_row)
                )
                AND
                NOT TabCollided
                AND
                ((hdInsLock_ekb05 in WantedLock.wlHandling_kb05) OR
                ( hdInsReq_ekb05  in WantedLock.wlHandling_kb05))
            THEN
                (* Tab Lock inserted -> change Tab Lock into Req *)
                BEGIN
                k52begexcl_region (t.trTaskId_gg00, TabRegion, TabRegionGlobPtr);
                IF  hdInsLock_ekb05 in WantedLock.wlHandling_kb05
                THEN
                    (* remove inserted Tab Lock *)
                    kb51row_from_tab_lock_release (t.trTaskId_gg00,
                          TabRegionGlobPtr,
                          TabRegion, TabHash, TabLock,
                          WantedLock.wlMode_kb05,
                          (hdInsReq_ekb05 in WantedLock.wlHandling_kb05) AND (t.trError_gg00 = e_ok));
                (*ENDIF*) 
                IF  (t.trError_gg00 = e_ok) AND
                    (hdInsReq_ekb05 in WantedLock.wlHandling_kb05)
                THEN
                    (* insert request on Tab level *)
                    BEGIN
                    AuxHandling := WantedLock.wlHandling_kb05;
                    WantedLock.wlHandling_kb05 := [hdInsReq_ekb05];
                    kb51tab_lock_check_ins (t,
                          TabRegionGlobPtr,
                          WantedLock, TransLockMode, IgnoreReqPriority,
                          Tab, Row, TabRegion, TabHash, TabLock,
                          TabOptimVers, Collided, WaitInserted);
                    WantedLock.wlHandling_kb05 := AuxHandling  ;
                    END;
                (*ENDIF*) 
                k52endexcl_region (t.trTaskId_gg00, TabRegionGlobPtr);
                IF  g01vtrace.vtrTime_gg00
                THEN
                    g01time_vtrace (t, 'k51: collision    ', StartSec, StartMsec)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  t.trError_gg00 = e_too_many_lock_requests
            THEN
                kb51abort_list_overflow (t.trIndex_gg00)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  (t.trError_gg00 = e_ok) AND
            (((hdInsLock_ekb05 in WantedLock.wlHandling_kb05) AND NOT Collided)
            OR
            (( hdInsReq_ekb05  in WantedLock.wlHandling_kb05) AND     Collided))
        THEN
            BEGIN
            IF  g01vtrace.vtrTime_gg00
            THEN
                vclock (StartSec, StartMsec);
            (*ENDIF*) 
            k52begexcl_region (t.trTaskId_gg00, TransRegion, TransRgnGlobPtr);
            kb51trans_lock_mode_insert (TransRgnGlobPtr^.rglTransGlob_kb05^,
                  ThisTrans, Collided, WantedLock.wlMode_kb05, WantedLock.wlState_kb05);
            kb51tab_trans_insert (t, TransRgnGlobPtr^, Collided, ThisTrans, WantedLock,
                  TabRegion, TabHash, TabLock, PrevTab, Tab);
            IF  (t.trError_gg00 = e_ok) AND NOT Collided
                AND NOT WantedLock.wlRowWanted_kb05
            THEN
                BEGIN
                WantedLock.wlGrantedMode_kb05 := Tab^.ttLockMode_kb05;
                IF  lrsConsistent_egg00 in Tab^.ttLockState_kb05
                THEN
                    kb51consistent_tab_remove (t.trTaskId_gg00, TransRgnGlobPtr^, ThisTrans, Tab)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (t.trError_gg00 = e_ok)
                AND
                WantedLock.wlRowWanted_kb05
            THEN
                BEGIN
                kb51row_trans_insert (t, TransRgnGlobPtr^, Collided, ThisTrans, Tab,
                      WantedLock, RowRegion, RowHash, RowLock, PrevRow,
                      RowOptimVers, TabOptimVers, Row);
                IF  (t.trError_gg00 = e_ok) AND NOT Collided
                THEN
                    BEGIN
                    WantedLock.wlGrantedMode_kb05 := Row^.rtLockMode_kb05;
                    IF  (Tab^.ttConsistentRow_kb05 <> NIL) AND
                        (Tab^.ttConsistentRow_kb05 <> Row)     (* JA 1998-09-25 *)
                    THEN
                        BEGIN
                        ConsistRow := Tab^.ttConsistentRow_kb05; (* JA 1998-09-30 *)
                        kb51row_remove (t.trTaskId_gg00, TransRgnGlobPtr^, ThisTrans, Tab, ConsistRow);
                        IF  ConsistRow = NIL
                        THEN
                            Tab^.ttConsistentRow_kb05 := NIL; (* JA 1998-09-30 *)
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    IF  lrsConsistent_egg00 in Row^.rtLockState_kb05
                    THEN
                        BEGIN
                        Tab^.ttConsistentRow_kb05 := Row;
                        k52flush_tab_trans (Tab^)
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  g01vtrace.vtrTime_gg00
            THEN
                g01time_vtrace (t, 'k51: Tab/Row Trans', StartSec, StartMsec);
            (*ENDIF*) 
            IF  (t.trError_gg00 = e_ok) AND NOT Collided
                AND NOT WantedLock.wlRowWanted_kb05
                AND (Tab^.ttFirstRow_kb05 <> NIL)
            THEN
                WITH Tab^ DO
                    BEGIN
                    IF  (ttLockMode_kb05 = lckTabShare_egg00)
                        AND
                        NOT (lrsTemp_egg00 in ttLockState_kb05)
                        AND
                        ((ttRowShareLocks_kb05 > 0) OR
                        ( ttRowOptimCnt_kb05   > 0))
                    THEN
                        kb51rows_remove (t.trTaskId_gg00, TransRgnGlobPtr^,
                              ThisTrans, Tab, NOT REMOVE_EXCL_ROWS)
                    ELSE
                        IF  (ttLockMode_kb05 in [lckSysExcl_egg00, lckTabExcl_egg00])
                            AND
                            ((ttRowExclLocks_kb05  > 0) OR
                            ( ttRowShareLocks_kb05 > 0) OR
                            ( ttRowOptimCnt_kb05   > 0))
                        THEN
                            kb51rows_remove (t.trTaskId_gg00, TransRgnGlobPtr^,
                                  ThisTrans, Tab, REMOVE_EXCL_ROWS);
                        (*ENDIF*) 
                    (*ENDIF*) 
                    IF  g01vtrace.vtrTime_gg00
                    THEN
                        g01time_vtrace (t, 'k51rows_remove    ', StartSec, StartMsec)
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
            (*ENDIF*) 
            IF  LockEscalation
            THEN
                BEGIN
                WITH TransRgnGlobPtr^.rglTransGlob_kb05^ DO              (* PTS 1103743 JA 1999-08-25 *)
                    trEscalations_kb05 := trEscalations_kb05 + ONE_8BYTE_CNT_GG04;
                (*ENDWITH*) 
                k52flush_trans_glob (TransRgnGlobPtr^.rglTransGlob_kb05^)
                END;
            (*ENDIF*) 
            k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
            IF  t.trError_gg00 = e_too_many_lock_requests
            THEN
                kb51abort_list_overflow (t.trIndex_gg00);
            (*ENDIF*) 
            ;
&           ifdef TRACE
            k52xtrans (kb_lockentry, ThisTrans);
&           endif
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_lock_dirty
        THEN
            BEGIN
            k52begexcl_region (t.trTaskId_gg00, TransRegion, TransRgnGlobPtr);
            kb51row_remove (t.trTaskId_gg00, TransRgnGlobPtr^, ThisTrans, Tab, Row);
            k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
            IF  ThisTrans^.teLockMode_kb05 = tlmFree_ekb05
            THEN
                t.trState_gg00 := t.trState_gg00 - [tsLocked_egg00]
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    rowLockCollision := NOT TabCollided;
    IF  (t.trError_gg00 = e_ok) AND Collided
    THEN
        BEGIN
        IF  hdInsReq_ekb05 in WantedLock.wlHandling_kb05
        THEN
            BEGIN
            t.trError_gg00 := e_wait_for_lock_release;
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                (ThisTrans^.teLockMode_kb05 <> tlmFree_ekb05)
            THEN
                kb51deadlock_detection (t, ThisTrans);
            (*ENDIF*) 
            IF  t.trError_gg00 = e_wait_for_lock_release
            THEN
                ThisTrans^.teTimeoutEnabled_kb05 := true; (* outside region *)
            (*ENDIF*) 
            END
        ELSE
            t.trError_gg00 := e_lock_collision
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) AND
        (hdInsLock_ekb05 in WantedLock.wlHandling_kb05)
    THEN
        t.trState_gg00 := t.trState_gg00 + [tsLocked_egg00];
    (*ENDIF*) 
    IF  LockEscalation
    THEN
        BEGIN
        WantedLock.wlHandling_kb05  := WantedHandling;
        WantedLock.wlMode_kb05      := WantedLockMode;
        WantedLock.wlRowWanted_kb05 := true
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
t01lockmode    (kb_lock, 'GrantedMode ', WantedLock.wlGrantedMode_kb05);
t01basis_error (kb_lock, 'end check_in', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51clear_locklist (VAR t : tgg00_TransContext);
 
VAR
      CurrTransRegion   : tkb05_RegionNo;
      CurrTabRowRegion  : tkb05_RegionNo;
      CurrInterval      : tsp00_Int4;
      CurrTime          : tsp00_Int4;
      DummyMsec         : tsp00_Int4;
      ConsistCnt        : tsp00_Int4;
      TransCnt          : tsp00_Int4;
      TransLimit        : tsp00_Int4;
      UsedItems         : tsp00_Int4;
      UsedRegionItems   : tsp00_Int4;
      UsedSegms         : tsp00_Int4;
      CurrConsistView   : tkb05_ConsistViewPtr;
      CurrTrans         : tkb05_TransEntryPtr;
      LockStateGlobPtr  : tkb05_LockStateGlobPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
      TabRowRgnGlobPtr  : tkb05_RegionGlobPtr;
      TransRgnGlobPtr   : tkb05_RegionGlobPtr;
      Trace             : tgg11_KbTrace;
 
BEGIN
t.trError_gg00 := e_ok;
IF  g01vtrace.vtrAll_gg00
THEN
    BEGIN
    Trace.kbMessType_gg11  := m_begin;
    Trace.kbMessType2_gg11 := mm_nil;
    Trace.kbError_gg11     := e_ok;
    b120InsertTrace (t, kb, vttKbClearLockList_egg00, sizeof (Trace), @Trace)
    END;
(*ENDIF*) 
vclock (CurrTime, DummyMsec);
k52begexcl_lockstate (t.trTaskId_gg00, LockStateGlobPtr);
IF  LockStateGlobPtr^.lglTimeLastClear_kb05 > 0
THEN
    CurrInterval := ((CurrTime - LockStateGlobPtr^.lglTimeLastClear_kb05 + 2) DIV 5) * 5
ELSE
    CurrInterval := cgg04_timeout_interval;
(*ENDIF*) 
LockStateGlobPtr^.lglTimeLastClear_kb05 := CurrTime;
k52endexcl_lockstate (t.trTaskId_gg00, LockStateGlobPtr);
UsedItems       := 0;
CurrTransRegion := 1;
WHILE (t.trError_gg00 = e_ok) AND (CurrTransRegion <= k51glob.glTransRegions_kb05) DO
    BEGIN
    k52begexcl_region (t.trTaskId_gg00, CurrTransRegion, TransRgnGlobPtr);
&   ifdef TRACE
    WITH TransRgnGlobPtr^.rglTransGlob_kb05^ DO
        BEGIN
        t01p2int4 (kb_lock, 'LockTrans   ', trLockTransCnt_kb05
              ,             'ReqTrans    ', trReqTransCnt_kb05);
        t01int4   (kb_lock, 'connectOnly ', trConnectOnlyCnt_kb05)
        END;
    (*ENDWITH*) 
&   endif
    UsedItems  := UsedItems + k52used_items_of_region (TransRgnGlobPtr^);
    TransLimit := k52used_trans_of_region (TransRgnGlobPtr^);
    TransCnt   := 0;
    CurrTrans  := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
    WHILE (CurrTrans <> NIL) AND (TransCnt <= TransLimit) DO
        BEGIN
        IF  CurrTrans^.teTimeoutEnabled_kb05
        THEN
            WITH CurrTrans^ DO
                BEGIN
                IF  teReqTab_kb05 <> NIL
                THEN
                    teReqTimeout_kb05    := teReqTimeout_kb05    - CurrInterval
                ELSE
                    teObjReqTimeout_kb05 := teObjReqTimeout_kb05 - CurrInterval;
                (*ENDIF*) 
                IF  teCancelAddr_kb05 <> NIL
                THEN
                    BEGIN
                    IF  teCancelAddr_kb05^.to_cancel
                    THEN
                        BEGIN
                        teReqTimeout_kb05    := 0;
                        teObjReqTimeout_kb05 := 0
                        END
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                IF  teReqTimeout_kb05 <= 0
                THEN
                    teReqTimeout_kb05 := 0;
                (*ENDIF*) 
                IF  teObjReqTimeout_kb05 < 0
                THEN
                    teObjReqTimeout_kb05 := 0;
                (*ENDIF*) 
                IF  (teObjReqTimeout_kb05 = 0) AND (teObjReq_kb05 <> cgg_nil_transindex)
                THEN
                    BEGIN
                    WITH TransRgnGlobPtr^.rglTransGlob_kb05^ DO
                        (* PTS 1103743 JA 1999-08-25 *)
                        trObjReqTimeouts_kb05 := trObjReqTimeouts_kb05 + ONE_8BYTE_CNT_GG04;
                    (*ENDWITH*) 
                    kb51_ObjReqTimeoutHandling (t, CurrTrans)
                    END
                ELSE
                    IF  (teReqTimeout_kb05 = 0) AND (teReqTab_kb05 <> NIL)
                    THEN
                        BEGIN
                        WITH TransRgnGlobPtr^.rglTransGlob_kb05^ DO
                            (* PTS 1103743 JA 1999-08-25 *)
                            trSqlReqTimeouts_kb05 := trSqlReqTimeouts_kb05 + ONE_8BYTE_CNT_GG04;
                        (*ENDWITH*) 
                        (* PTS 1106270 JA 2000-04-06: timeout is handled by waiting task *)
                        kb51signal_resume (t.trTaskId_gg00, teOwnIndex_kb05, NOT IS_OK)
                        END;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  (teLockMode_kb05 = tlmEotExcl_ekb05)
                    AND
                    (MAX_INT4_SP00 - teTimeLastWrite_kb05 - CurrInterval >= 0)
                THEN
                    teTimeLastWrite_kb05 := teTimeLastWrite_kb05 + CurrInterval
                (*ENDIF*) 
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        TransCnt  := TransCnt + 1;
        CurrTrans := CurrTrans^.teNextTrans_kb05
        END;
    (*ENDWHILE*) 
&   ifdef TRACE
    WITH TransRgnGlobPtr^.rglTransGlob_kb05^ DO
        BEGIN
        t01p2int4 (kb_lock, 'LockTrans   ', trLockTransCnt_kb05
              ,             'ReqTrans    ', trReqTransCnt_kb05);
        t01int4   (kb_lock, 'ConnectOnly ', trConnectOnlyCnt_kb05)
        END;
    (*ENDWITH*) 
&   endif
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
    IF  TransCnt > TransLimit
    THEN
        k52x_loop_error ('k51clear_locklist       ', 1);
    (*ENDIF*) 
    CurrTransRegion := CurrTransRegion + 1
    END;
(*ENDWHILE*) 
FOR CurrTabRowRegion := k51glob.glTransRegions_kb05 + 1 TO k51glob.glRegions_kb05 DO
    BEGIN
    k52begexcl_region (t.trTaskId_gg00, CurrTabRowRegion, TabRowRgnGlobPtr);
    UsedRegionItems := k52used_items_of_region (TabRowRgnGlobPtr^);
    UsedItems       := UsedItems + UsedRegionItems;
    IF  TabRowRgnGlobPtr^.rglFirstConsistView_kb05 <> NIL
    THEN
        BEGIN
        CurrConsistView := TabRowRgnGlobPtr^.rglFirstConsistView_kb05;
        ConsistCnt      := 0;
        WHILE (CurrConsistView <> NIL) AND (ConsistCnt <= UsedRegionItems) DO
            BEGIN
            IF  CurrConsistView^.cstItemKind_kb05 <> ikConsistView_ekb05
            THEN
                k52x_item_error ('k51clear_locklist       ', CurrConsistView^.cstItemKind_kb05);
            (*ENDIF*) 
            CurrConsistView^.cstTimeLastUsed_kb05 :=
                  CurrConsistView^.cstTimeLastUsed_kb05 + CurrInterval;
            ConsistCnt      := ConsistCnt + 1;
            CurrConsistView := CurrConsistView^.cstNextConsistView_kb05
            END;
        (*ENDWHILE*) 
        IF  ConsistCnt > UsedRegionItems
        THEN
            k52x_loop_error ('k51clear_locklist       ', 2);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    k52endexcl_region (t.trTaskId_gg00, TabRowRgnGlobPtr)
    END;
(*ENDFOR*) 
IF  UsedItems > 0
THEN
    BEGIN
    k52begexcl_supply_pool (t.trTaskId_gg00, SupplyPoolGlobPtr);
    WITH SupplyPoolGlobPtr^ DO
        BEGIN
        UsedSegms := k51glob.glSupplyPoolSegments_kb05 - poolFreeSegments_kb05;
        (* PTS 1103743 JA 1999-08-25 *)
        poolItemsUsedAmount_kb05 := poolItemsUsedAmount_kb05 + UsedItems;
        poolSegmsUsedAmount_kb05 := poolSegmsUsedAmount_kb05 + UsedSegms;
        poolAmountPoints_kb05    := poolAmountPoints_kb05    + ONE_8BYTE_CNT_GG04
        END;
    (*ENDWITH*) 
    k52endexcl_supply_pool (t.trTaskId_gg00, SupplyPoolGlobPtr)
    END;
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00
THEN
    BEGIN
    Trace.kbMessType_gg11  := m_return_error;
    Trace.kbMessType2_gg11 := mm_nil;
    Trace.kbError_gg11     := t.trError_gg00;
    b120InsertTrace (t, kb, vttKbClearLockList_egg00, sizeof (Trace), @Trace)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51UpdateMinTrans (
            TaskId    : tsp00_TaskId;
            triggerGC : boolean );
 
VAR
      CurrTabRegion     : tkb05_RegionNo;         (* PTS 1105568 JA 2000-02-10 *)
      CurrTransRegion   : tkb05_RegionNo;         (* PTS 1130054 FF 2004-06-11 *)
      MinOpen           : tgg91_TransNo;          (* PTS 1105568 JA 2000-02-10 *)
      MinNonVersOpen    : tgg91_TransNo;          (* PTS 1130354 FF 2004-06-25 *)
      MinConsist        : tgg91_TransNo;          (* PTS 1105568 JA 2000-02-10 *)
      MinNonVersConsist : tgg91_TransNo;          (* PTS 1130354 FF 2004-06-25 *)
      MinBefore         : tgg91_TransNo;          (* PTS 1106064 JA 2000-03-21 *)
      MinNonVersBefore  : tgg91_TransNo;          (* PTS 1130354 FF 2004-06-25 *)
      MinAfter          : tgg91_TransNo;          (* PTS 1106064 JA 2000-03-21 *)
      MinNonVersAfter   : tgg91_TransNo;          (* PTS 1130354 FF 2004-06-25 *)
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
      TabRegionGlobPtr  : tkb05_RegionGlobPtr;
      TransRgnGlobPtr   : tkb05_RegionGlobPtr;    (* PTS 1130054 FF 2004-06-11 *)
      CurrTrans         : tkb05_TransEntryPtr;    (* PTS 1130054 FF 2004-06-11 *)
      TransCnt          : tsp00_Int4;             (* PTS 1130054 FF 2004-06-11 *)
      MinOpenTrIdx      : tgg00_TransIndex;
 
BEGIN
MinOpenTrIdx := 0;
gg06SetNilTrans (MinOpen   );
gg06SetNilTrans (MinNonVersOpen );                (* PTS 1130354 FF 2004-06-25 *)
gg06SetNilTrans (MinConsist);
gg06SetNilTrans (MinNonVersConsist);              (* PTS 1130354 FF 2004-06-25 *)
FOR CurrTabRegion := k51glob.glTransRegions_kb05 + 1
      TO k51glob.glTransRegions_kb05 + k51glob.glTabRegions_kb05 DO
    BEGIN
    k52begexcl_region (TaskId, CurrTabRegion, TabRegionGlobPtr);
    kb51min_transid_assign (MinOpen,           TabRegionGlobPtr^.rglMinOpenTransId_kb05);
    (* PTS 1130354 FF 2004-06-25 *)
    kb51min_transid_assign (MinNonVersOpen,    TabRegionGlobPtr^.rglMinNonVersOpTrId_kb05);
    kb51min_transid_assign (MinConsist,        TabRegionGlobPtr^.rglMinConsistViewNo_kb05);
    (* PTS 1130354 FF 2004-06-25 *)
    kb51min_transid_assign (MinNonVersConsist, TabRegionGlobPtr^.rglMinNonVersCSVNo_kb05);
    TabRegionGlobPtr := NIL
    END;
(*ENDFOR*) 
;
(* within all TabRegions *)
;
(* PTS 1130054 FF 2004-06-11 *)
IF  NOT gg06IsNilTrans(MinOpen)
THEN
    BEGIN
    ;
    MinAfter := MinOpen;                                        (* PTS 1106064 JA 2000-03-21 *)
    kb51min_transid_assign (MinAfter, MinConsist);              (* PTS 1106064 JA 2000-03-21 *)
    MinNonVersAfter := MinNonVersOpen;                           (* PTS 1130354 FF 2004-06-25 *)
    kb51min_transid_assign (MinNonVersAfter, MinNonVersConsist); (* PTS 1130354 FF 2004-06-25 *)
    ;
    k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    ;
    MinBefore := SupplyPoolGlobPtr^.poolMinOpenTransId_kb05;    (* PTS 1106064 JA 2000-03-21 *)
    kb51min_transid_assign (MinBefore, SupplyPoolGlobPtr^.poolMinConsistViewNo_kb05);
    MinNonVersBefore := SupplyPoolGlobPtr^.poolMinNonVersOpTrId_kb05; (* PTS 1130354 FF 2004-06-25 *)
    kb51min_transid_assign (MinNonVersBefore, SupplyPoolGlobPtr^.poolMinNonVersCSVNo_kb05);
    ;
    SupplyPoolGlobPtr^.poolMinOpenTransId_kb05   := MinOpen;
    SupplyPoolGlobPtr^.poolMinNonVersOpTrId_kb05 := MinNonVersOpen;    (* PTS 1130354 FF 2004-06-25 *)
    SupplyPoolGlobPtr^.poolMinConsistViewNo_kb05 := MinConsist;
    SupplyPoolGlobPtr^.poolMinNonVersCSVNo_kb05  := MinNonVersConsist; (* PTS 1130354 FF 2004-06-25 *)
    ;
    k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    END
ELSE (* PTS 1130354 FF 2004-06-25 *)
    BEGIN
    k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    ;
    MinBefore := SupplyPoolGlobPtr^.poolMinOpenTransId_kb05;    (* PTS 1106064 JA 2000-03-21 *)
    kb51min_transid_assign (MinBefore, SupplyPoolGlobPtr^.poolMinConsistViewNo_kb05);
    MinNonVersBefore := SupplyPoolGlobPtr^.poolMinNonVersOpTrId_kb05; (* PTS 1130354 FF 2004-06-25 *)
    kb51min_transid_assign (MinNonVersBefore, SupplyPoolGlobPtr^.poolMinNonVersCSVNo_kb05);
    ;
    SupplyPoolGlobPtr^.poolMinConsistViewNo_kb05 := MinConsist;
    SupplyPoolGlobPtr^.poolMinNonVersCSVNo_kb05  := MinNonVersConsist;
    ;
    k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    END;
(*ENDIF*) 
;
FOR CurrTabRegion := k51glob.glTransRegions_kb05 + k51glob.glTabRegions_kb05
      DOWNTO k51glob.glTransRegions_kb05 + 1 DO
    vendexcl (TaskId, g08lock0 + CurrTabRegion);
(*ENDFOR*) 
;
(* *** BEGIN *** PTS 1130054 FF 2004-06-11 *)
IF  gg06IsNilTrans(MinOpen)
THEN
    BEGIN
    (* CNSTVIEW region is needed, because else kb51StartConsistTrans could *)
    (* possess a trConsistView_gg00 stamp, which hasn't yet been anchored  *)
    (* within global control structures, but which has to be obeyed        *)
    (* my MinOpenTrans setting                                             *)
    ;
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    kb511EnterConsistView1 (TaskId, true );
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    ;
    (* all glTransRegions_kb05 are needed, because k50new_write_trans could        *)
    (* already possess a trWriteTransId_gg00 stamp, which hasn't yet been anchored *)
    (* within global control structures, but which has to be obeyed                *)
    (* my MinOpenTrans setting                                                     *)
    FOR CurrTransRegion := 1 TO k51glob.glTransRegions_kb05 DO
        BEGIN
        k52begexcl_region (TaskId, CurrTransRegion, TransRgnGlobPtr);
        CurrTrans := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
        TransCnt  := 0;
        WHILE (CurrTrans <> NIL)
              AND
              (TransCnt <= k51glob.glTransEntriesPerRegion_kb05) DO
            BEGIN
            IF  (CurrTrans^.teConsistView_kb05 <> NIL)
            THEN
                BEGIN
                kb51min_transid_assign (MinOpen,
                      CurrTrans^.teConsistView_kb05^.cstMinOpenTransId_kb05);
                IF  MinOpen = CurrTrans^.teConsistView_kb05^.cstMinOpenTransId_kb05
                THEN
                    MinOpenTrIdx := cgg_nil_transindex;
                (*ENDIF*) 
                IF  NOT CurrTrans^.teConsistView_kb05^.cstOmsVersion_kb05
                THEN
                    kb51min_transid_assign (MinNonVersOpen,
                          CurrTrans^.teConsistView_kb05^.cstMinOpenTransId_kb05);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  NOT gg06IsNilTrans (CurrTrans^.teWriteTransId_kb05)
            THEN
                BEGIN
                kb51min_transid_assign (MinOpen, CurrTrans^.teWriteTransId_kb05);
                IF  MinOpen = CurrTrans^.teWriteTransId_kb05
                THEN
                    MinOpenTrIdx := CurrTrans^.teOwnIndex_kb05;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            TransCnt  := TransCnt + 1;
            CurrTrans := CurrTrans^.teNextTrans_kb05
            END;
        (*ENDWHILE*) 
        TransRgnGlobPtr := NIL;
        END;
    (*ENDFOR*) 
    IF  gg06IsNilTrans(MinOpen)
    THEN
        BEGIN
        MinOpenTrIdx := -1;
        k57new_write_trans       (TaskId, MinOpen);
        END;
    (*ENDIF*) 
    FOR CurrTransRegion := k51glob.glTransRegions_kb05 DOWNTO 1 DO
        vendexcl (TaskId, g08lock0 + CurrTransRegion);
    (*ENDFOR*) 
    ;
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    kb511LeaveConsistView1 (TaskId, true );
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    ;
    MinAfter := MinOpen;
    kb51min_transid_assign (MinAfter, MinConsist);
    kb51max_transid_assign (MinNonVersOpen, MinOpen);
    ;
    MinNonVersAfter := MinNonVersOpen;
    kb51min_transid_assign (MinNonVersAfter, MinNonVersConsist);
    ;
    k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    ;
    kb51max_transid_assign (SupplyPoolGlobPtr^.poolMinOpenTransId_kb05, MinOpen);
    IF  SupplyPoolGlobPtr^.poolMinOpenTransId_kb05 = MinOpen
    THEN
        SupplyPoolGlobPtr^.poolMinOpenIdx_kb05 := MinOpenTrIdx;
    (*ENDIF*) 
    kb51max_transid_assign (SupplyPoolGlobPtr^.poolMinNonVersOpTrId_kb05, MinNonVersOpen);
    ;
    k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    ;
    END;
(* *** END *** PTS 1130054 FF 2004-06-11 *)
(*ENDIF*) 
;
IF  triggerGC AND (MinNonVersBefore <> MinNonVersAfter) (* PTS 1130354 FF 2004-06-25 *)
    AND
    NOT gg06IsNilTrans(MinNonVersAfter)
THEN
    (* PTS 1128244 FF 2004-03-18 *)
    k501SetMinTrans( TaskId, MinNonVersAfter );
(*ENDIF*) 
;
bd999SetMinTrans( MinAfter );
;
IF  triggerGC AND (MinBefore <> MinAfter)
THEN
    (* PTS 1106064 JA 2000-03-21 *)
    kb51_TriggerOmsGarbageCollection (TaskId)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51UpdateMinTransIfNeeded (
            TaskId           : tsp00_TaskId );
 
CONST
      DO_TRIGGER_GC  = true;
 
VAR
      ThisTrans         : tkb05_TransEntryPtr;
      bUpdateMinTrans   : boolean;
 
BEGIN
IF  (k51glob.glSupplyPoolGlob_kb05^.poolMinOpenIdx_kb05 <> cgg_nil_transindex)
THEN
    BEGIN
    bUpdateMinTrans := false;
    IF  k51glob.glSupplyPoolGlob_kb05^.poolMinOpenIdx_kb05 > cgg_nil_transindex
    THEN
        BEGIN
        k52acc_trans_entry( k51glob.glSupplyPoolGlob_kb05^.poolMinOpenIdx_kb05, ThisTrans );
        IF  NOT (( k51glob.glSupplyPoolGlob_kb05^.poolMinOpenTransId_kb05
            = ThisTrans^.teWriteTransId_kb05 )
            AND NOT ( m_delete = ThisTrans^.teState_kb05 ))
        THEN
            bUpdateMinTrans := true;
        (*ENDIF*) 
        END
    ELSE
        IF  k51glob.glSupplyPoolGlob_kb05^.poolMinOpenIdx_kb05 = -1
        THEN
            BEGIN
            bUpdateMinTrans := true;
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    IF  bUpdateMinTrans
    THEN
        kb51UpdateMinTrans (TaskId, DO_TRIGGER_GC);
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51DetermineMinOpenTrans (
            TaskId                : tsp00_TaskId;
            ConsistRgnGlobPtr     : tkb05_RegionGlobPtr;
            VAR UpdateMinTrans    : boolean );
 
VAR
      ItemCnt           : tsp00_Int4;
      MinOpen           : tgg91_TransNo;          (* PTS 1105568 JA 2000-02-10 *)
      MinConsist        : tgg91_TransNo;          (* PTS 1105568 JA 2000-02-10 *)
      MinNonVersOpen    : tgg91_TransNo;          (* PTS 1130354 FF 2004-06-25 *)
      MinNonVersConsist : tgg91_TransNo;          (* PTS 1130354 FF 2004-06-25 *)
      CurrConsist       : tkb05_ConsistViewPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
 
BEGIN
(* determine new rglMinOpenTransId_kb05 and rglMinConsistViewNo_kb05 *)
WITH ConsistRgnGlobPtr^ DO
    BEGIN
    MinOpen    := rglMinOpenTransId_kb05;
    MinConsist := rglMinConsistViewNo_kb05;
    MinNonVersOpen    := rglMinNonVersOpTrId_kb05; (* PTS 1130354 FF 2004-06-25 *)
    MinNonVersConsist := rglMinNonVersCSVNo_kb05; (* PTS 1130354 FF 2004-06-25 *)
    gg06SetNilTrans (rglMinOpenTransId_kb05  );
    gg06SetNilTrans (rglMinConsistViewNo_kb05);
    gg06SetNilTrans (rglMinNonVersOpTrId_kb05);    (* PTS 1130354 FF 2004-06-25 *)
    gg06SetNilTrans (rglMinNonVersCSVNo_kb05);     (* PTS 1130354 FF 2004-06-25 *)
    CurrConsist := rglFirstConsistView_kb05;
    ItemCnt     := 0;
    WHILE (CurrConsist <> NIL) AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        IF  CurrConsist^.cstItemKind_kb05 <> ikConsistView_ekb05
        THEN
            k52x_item_error ('kb51DetermMinOpenTrans/1', CurrConsist^.cstItemKind_kb05);
        (*ENDIF*) 
        kb51min_transid_assign (rglMinOpenTransId_kb05, CurrConsist^.cstMinOpenTransId_kb05);
        kb51min_transid_assign (rglMinConsistViewNo_kb05,
              CurrConsist^.cstConsistViewNo_kb05.surrTransId_kb05);
        IF  NOT CurrConsist^.cstOmsVersion_kb05              (* PTS 1130354 FF 2004-06-25 *)
        THEN
            BEGIN
            kb51min_transid_assign (rglMinNonVersOpTrId_kb05, CurrConsist^.cstMinOpenTransId_kb05);
            kb51min_transid_assign (rglMinNonVersCSVNo_kb05,
                  CurrConsist^.cstConsistViewNo_kb05.surrTransId_kb05);
            END;
        (* *)
        (* without ObjSeq: PTS 1105435 JA 2000-02-01 *)
        (* kb51min_objseq_assign (rglMinOpenObjSeq_kb05, CurrConsist^.cstMinOpenObjSeq_kb05); *)
        (* kb51min_objseq_assign (rglMinConsistObjSeq_kb05, CurrConsist^.cstStartObjSeq_kb05);*)
        (*ENDIF*) 
        ItemCnt     := ItemCnt + 1;
        CurrConsist := CurrConsist^.cstNextConsistView_kb05
        END;
    (*ENDWHILE*) 
    IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
    THEN
        k52x_loop_error ('k51del_consist_trans    ', 4);
    (*ENDIF*) 
    IF  (MinOpen           <> rglMinOpenTransId_kb05  ) OR              (* PTS 1105568 JA 2000-02-10 *)
        (MinConsist        <> rglMinConsistViewNo_kb05) OR
        (MinNonVersOpen    <> rglMinNonVersOpTrId_kb05) OR              (* PTS 1130354 FF 2004-06-25 *)
        (MinNonVersConsist <> rglMinNonVersCSVNo_kb05 )                 (* PTS 1130354 FF 2004-06-25 *)
    THEN
        (* PTS 1105568 JA 2000-02-10 *)
        BEGIN
        k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
        UpdateMinTrans :=
              (MinOpen           = SupplyPoolGlobPtr^.poolMinOpenTransId_kb05  ) OR
              (MinConsist        = SupplyPoolGlobPtr^.poolMinConsistViewNo_kb05) OR
              (* PTS 1130354 FF 2004-06-25 *)
              (MinNonVersOpen    = SupplyPoolGlobPtr^.poolMinNonVersOpTrId_kb05) OR
              (* PTS 1130354 FF 2004-06-25 *)
              (MinNonVersConsist = SupplyPoolGlobPtr^.poolMinNonVersCSVNo_kb05);
        k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr)
        END;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51RemoveHashOpenTrans (
            TaskId           : tsp00_TaskId;
            VAR ConsistView  : tkb05_ConsistViewPtr);
 
VAR
      CurrOpenIndex     : integer;
      ItemCnt           : tsp00_Int4;
      CurrOpenEntry     : tkb05_OpenTransPtr;
      HashRegionGlobPtr : tkb05_RegionGlobPtr;
      UnivItemPtr       : tkb05_UnivItemPtr;
 
BEGIN
CurrOpenEntry := ConsistView^.cstFirstOpenTrans_kb05;
ItemCnt       := 0;
WHILE (CurrOpenEntry <> NIL) AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
    BEGIN
    IF  CurrOpenEntry^.openItemKind_kb05 <> ikOpenTrans_ekb05
    THEN
        k52x_item_error ('kb51RemoveHashOpenTrans ', CurrOpenEntry^.openItemKind_kb05);
    (*ENDIF*) 
    IF  (CurrOpenEntry^.openCount_kb05 <= 0)
        OR
        (CurrOpenEntry^.openCount_kb05 > TRANS_PER_OPEN_ENTRY_KB05)
    THEN
        k52x_loop_error ('kb51RemoveHashOpenTrans ', 1);
    (*ENDIF*) 
    FOR CurrOpenIndex := 1 TO CurrOpenEntry^.openCount_kb05 DO
        BEGIN
        k52begexcl_region (TaskId, CurrOpenEntry^.openHashRegion_kb05 [CurrOpenIndex],
              HashRegionGlobPtr);
        IF  CurrOpenEntry^.openOwnHashTrans_kb05 [CurrOpenIndex]^.hshUsedCnt_kb05 > 1
        THEN
            BEGIN
            WITH CurrOpenEntry^.openOwnHashTrans_kb05 [CurrOpenIndex]^ DO
                hshUsedCnt_kb05 := hshUsedCnt_kb05 - 1;
            (*ENDWITH*) 
            k52flush_hash_open_trans (CurrOpenEntry^.openOwnHashTrans_kb05 [CurrOpenIndex]^)
            END
        ELSE
            (* remove HashOpenTrans *)
            BEGIN
            UnivItemPtr.uiHashOpenTrans_kb05 :=
                  CurrOpenEntry^.openOwnHashTrans_kb05 [CurrOpenIndex];
            IF  UnivItemPtr.uiHashOpenTrans_kb05^.hshItemKind_kb05 <> ikHashOpenTrans_ekb05
            THEN
                k52x_item_error ('kb51RemoveHashOpenTrans ',
                      UnivItemPtr.uiHashOpenTrans_kb05^.hshItemKind_kb05);
            (*ENDIF*) 
            UnivItemPtr.uiTabLock_kb05^.tlItemKind_kb05          := ikTabLock_ekb05;
            CurrOpenEntry^.openOwnHashTrans_kb05 [CurrOpenIndex] := NIL;
            kb51free_tab_lock (TaskId, HashRegionGlobPtr^, UnivItemPtr.uiTabLock_kb05,
                  UnivItemPtr.uiHashOpenTrans_kb05^.hshOwnHashValue_kb05);
            END;
        (*ENDIF*) 
        k52endexcl_region (TaskId, HashRegionGlobPtr)
        END;
    (*ENDFOR*) 
    ItemCnt       := ItemCnt + 1;
    CurrOpenEntry := CurrOpenEntry^.openNext_kb05
    END;
(*ENDWHILE*) 
IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
THEN
    k52x_loop_error ('kb51RemoveHashOpenTrans ', 2);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51DelConsistTrans (
            TaskId                : tsp00_TaskId;
            VAR ConsistViewNo     : tgg91_TransNo);
 
CONST
      DO_TRIGGER_GC  = true;
 
VAR
      EntryFound        : boolean;
      UpdateMinTrans    : boolean;                (* PTS 1105568 JA 2000-02-10 *)
      TryToAquiredEntry : boolean;                (* PTS 1120151 FF 2003-01-29*)
      ConsistRegion     : tkb05_RegionNo;
      TransRegion       : tkb05_RegionNo;
      ConsistHash       : tsp00_Int4;
      ItemCnt           : tsp00_Int4;
      ConsistTabId      : tkb05_SurrogateTransId;
      ConsistView       : tkb05_ConsistViewPtr;
      CurrOpenEntry     : tkb05_OpenTransPtr;
      DummyPrevTab      : tkb05_TabLockPtr;
      ConsistRgnGlobPtr : tkb05_RegionGlobPtr;
      ThisTrans         : tkb05_TransEntryPtr;
      UnivItemPtr       : tkb05_UnivItemPtr;
 
BEGIN
&ifdef TRACE
ta01TransNo (kb_lock, 'ConsistView ', ConsistViewNo);
&endif
ConsistView    := NIL;
UpdateMinTrans := false;                                             (* PTS 1105568 JA 2000-02-10 *)
;
kb511EnterConsistView2 (TaskId, false );                             (* PTS 1130354 FF 2004-07-08 *)
;
IF  NOT gg06IsNilTrans (ConsistViewNo)
THEN
    (* ----- search ConsistView ----- *)
    BEGIN
    WITH ConsistTabId DO
        BEGIN
        surrId_kb05      := CONSIST_TRANS_PREFIX_GG00;
        surrTransId_kb05 := ConsistViewNo
        END;
    (*ENDWITH*) 
    kb51tab_hash (ConsistTabId.surrId_kb05, ConsistHash, ConsistRegion);
    (* PTS 1120151 FF 2003-01-29  to synchronize kb51DelConsistTrans with    *)
    (* kb51CancelConsistTrans if trying to work on same entry, the flag      *)
    (* ConsistView^.cstInWork_kb05 is used in conjunction with a busy        *)
    (* wait loop, interrupted only by dispatching via vsleep                 *)
    (* this logic became necessary, because 'ConsistRegion' will be          *)
    (* released meanwhile                                                    *)
    TryToAquiredEntry := true;
    WHILE TryToAquiredEntry DO
        BEGIN
        k52begexcl_region (TaskId, ConsistRegion, ConsistRgnGlobPtr);
        kb51tablock_search (ConsistRgnGlobPtr^,
              ConsistTabId.surrId_kb05, ConsistHash, UnivItemPtr.uiTabLock_kb05,
              DummyPrevTab, EntryFound);
        IF  EntryFound
        THEN
            BEGIN
            ConsistView := UnivItemPtr.uiConsistView_kb05;
            IF  ConsistView^.cstInWork_kb05
            THEN
                vsleep(TaskId, 0)
            ELSE
                BEGIN
                ConsistView^.cstInWork_kb05 := true;
                TryToAquiredEntry           := false;
                END
            (*ENDIF*) 
            END
        ELSE
            TryToAquiredEntry := false;
        (*ENDIF*) 
        k52endexcl_region (TaskId, ConsistRgnGlobPtr) (* PTS 1122864 *)
        END;
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  (ConsistView <> NIL)
THEN
    BEGIN
    IF  ConsistView^.cstCurrTransIndex_kb05 <> cgg_nil_transindex
    THEN
        (* ----- remove pointer: TransEntry -> ConsistView ----- *)
        BEGIN
        TransRegion := k51tr_index_region (ConsistView^.cstCurrTransIndex_kb05);
        vbegexcl (TaskId, g08lock0 + TransRegion);
        k52acc_trans_entry (ConsistView^.cstCurrTransIndex_kb05, ThisTrans);
        IF  ConsistView = ThisTrans^.teConsistView_kb05
        THEN
            ThisTrans^.teConsistView_kb05 := NIL; (* JA 1998-11-11 *)
        (*ENDIF*) 
        ThisTrans := NIL; (* security *)
        vendexcl (TaskId, g08lock0 + TransRegion)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ( ConsistView <> NIL )
THEN
    BEGIN
    IF  NOT ConsistView^.cstCancelled_kb05 (* PTS 1120151 FF 2003-01-29 *)
    THEN
        (* ----- remove HashOpenTrans entries / outside ConsistRegion ----- *)
        kb51RemoveHashOpenTrans (TaskId, ConsistView);
    (*ENDIF*) 
    ;
    (* ----- remove OpenTrans entries and ConsistView ------ *)
    k52begexcl_region (TaskId, ConsistRegion, ConsistRgnGlobPtr);
    CurrOpenEntry := ConsistView^.cstFirstOpenTrans_kb05;
    ItemCnt       := 0;
    WHILE (CurrOpenEntry <> NIL) AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        UnivItemPtr.uiOpenTrans_kb05 := CurrOpenEntry;
        CurrOpenEntry                := CurrOpenEntry^.openNext_kb05;
        ItemCnt                      := ItemCnt + 1;
        kb51free_supply_item (TaskId, ConsistRgnGlobPtr^, UnivItemPtr, ikOpenTrans_ekb05);
        ConsistRgnGlobPtr^.rglOpenTransCnt_kb05 := ConsistRgnGlobPtr^.rglOpenTransCnt_kb05 - 1
        END;
    (*ENDWHILE*) 
    IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
    THEN
        k52x_loop_error ('k51del_consist_trans    ', 3);
    (*ENDIF*) 
    IF  ConsistView^.cstCancelled_kb05 (* PTS 1120151 FF 2003-01-29 *)
    THEN
        BEGIN
        ConsistView^.cstCancelled_kb05 := false;
        IF  ConsistView^.cstPrevConsistView_kb05 = NIL
        THEN
            ConsistRgnGlobPtr^.rglCancelConsView_kb05 := ConsistView^.cstNextConsistView_kb05
        ELSE
            ConsistView^.cstPrevConsistView_kb05^.cstNextConsistView_kb05 :=
                  ConsistView^.cstNextConsistView_kb05;
        (*ENDIF*) 
        IF  ConsistView^.cstNextConsistView_kb05 <> NIL
        THEN
            ConsistView^.cstNextConsistView_kb05^.cstPrevConsistView_kb05 :=
                  ConsistView^.cstPrevConsistView_kb05;
        (*ENDIF*) 
        IF  ConsistView^.cstItemKind_kb05 <> ikConsistView_ekb05
        THEN
            k52x_item_error ('kb51DelConsistTrans/1   ', ConsistView^.cstItemKind_kb05);
        (*ENDIF*) 
        ConsistRgnGlobPtr^.rglCancelCsViewCnt_kb05 := ConsistRgnGlobPtr^.rglCancelCsViewCnt_kb05 - 1;
        END
    ELSE
        BEGIN
        IF  ConsistView^.cstPrevConsistView_kb05 = NIL
        THEN
            ConsistRgnGlobPtr^.rglFirstConsistView_kb05 := ConsistView^.cstNextConsistView_kb05
        ELSE
            ConsistView^.cstPrevConsistView_kb05^.cstNextConsistView_kb05 :=
                  ConsistView^.cstNextConsistView_kb05;
        (*ENDIF*) 
        IF  ConsistView^.cstNextConsistView_kb05 <> NIL
        THEN
            ConsistView^.cstNextConsistView_kb05^.cstPrevConsistView_kb05 :=
                  ConsistView^.cstPrevConsistView_kb05;
        (*ENDIF*) 
        IF  ConsistView^.cstItemKind_kb05 <> ikConsistView_ekb05
        THEN
            k52x_item_error ('kb51DelConsistTrans/1   ', ConsistView^.cstItemKind_kb05);
        (*ENDIF*) 
        ConsistRgnGlobPtr^.rglConsistViewCnt_kb05 := ConsistRgnGlobPtr^.rglConsistViewCnt_kb05 - 1;
        END;
    (*ENDIF*) 
    ConsistView^.cstInWork_kb05                 := false;
    UnivItemPtr.uiConsistView_kb05              := ConsistView;
    UnivItemPtr.uiTabLock_kb05^.tlItemKind_kb05 := ikTabLock_ekb05;
    kb51free_tab_lock (TaskId, ConsistRgnGlobPtr^, UnivItemPtr.uiTabLock_kb05, ConsistHash);
    ConsistView := NIL; (* JA 1998-09-25 *)
    kb51DetermineMinOpenTrans (TaskId, ConsistRgnGlobPtr, UpdateMinTrans);
    k52endexcl_region (TaskId, ConsistRgnGlobPtr);
    IF  UpdateMinTrans                                               (* PTS 1105568 JA 2000-02-10 *)
    THEN
        kb51UpdateMinTrans (TaskId, DO_TRIGGER_GC);
    (*ENDIF*) 
    END;
(*ENDIF*) 
kb511LeaveConsistView2 (TaskId, false );                             (* PTS 1130354 FF 2004-07-08 *)
END;
 
(* PTS 1120151 FF 2003-JAN-10   *)
(*------------------------------*) 
 
PROCEDURE
      kb51CancelConsistTrans (
            TaskId            : tsp00_TaskId;
            VAR ConsistViewNo : tgg91_TransNo;
            VAR StartDate     : tsp00_Int4;
            VAR StartTime     : tsp00_Int4;
            bUseMinRetentionTime : boolean); (* PTS 1122577 FF *)
 
CONST
      DO_TRIGGER_GC  = true;
 
VAR
      EntryFound        : boolean;
      UpdateMinTrans    : boolean;                (* PTS 1105568 JA 2000-02-10 *)
      ConsistRegion     : tkb05_RegionNo;
      ConsistHash       : tsp00_Int4;
      ConsistTabId      : tkb05_SurrogateTransId;
      ConsistView       : tkb05_ConsistViewPtr;
      DummyPrevTab      : tkb05_TabLockPtr;
      ConsistRgnGlobPtr : tkb05_RegionGlobPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
      UnivItemPtr       : tkb05_UnivItemPtr;
      ActClockSecs      : tsp00_Int4;                   (* PTS 1122577 FF *)
      ActClockMSecs     : tsp00_Int4;                   (* PTS 1122577 FF *)
      min               : tsp00_Int4;                   (* PTS 1122577 FF *)
      bIsForOmsVersion  : boolean;                      (* PTS 1132447 FF *)
 
BEGIN
ConsistView    := NIL;
UpdateMinTrans := false;
bIsForOmsVersion := false;
gg06SetNilTrans (ConsistViewNo);
IF  (bUseMinRetentionTime AND
    (b91MinRetentionTime > 0)) OR
    (b91MaxRetentionTime > 0) (* PTS 1122577 FF *)
THEN
    BEGIN
    (* start PTS 1122577 FF *)
    vclock (ActClockSecs, ActClockMSecs);
    IF  bUseMinRetentionTime
    THEN
        min := b91MinRetentionTime * 60
    ELSE
        min := b91MaxRetentionTime * 60;
    (*ENDIF*) 
    (* end PTS 1122577 FF *)
    k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    IF  SupplyPoolGlobPtr <> NIL
    THEN
        ConsistViewNo := SupplyPoolGlobPtr^.poolMinConsistViewNo_kb05
    ELSE
        gg06SetNilTrans (ConsistViewNo);
    (*ENDIF*) 
    k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
&   ifdef TRACE
    ta01TransNo (kb_lock, 'ConsistView ', ConsistViewNo);
&   endif
    IF  NOT gg06IsNilTrans (ConsistViewNo)
    THEN
        (* ----- search ConsistView ----- *)
        BEGIN
        WITH ConsistTabId DO
            BEGIN
            surrId_kb05      := CONSIST_TRANS_PREFIX_GG00;
            surrTransId_kb05 := ConsistViewNo
            END;
        (*ENDWITH*) 
        kb51tab_hash (ConsistTabId.surrId_kb05, ConsistHash, ConsistRegion);
        k52begexcl_region (TaskId, ConsistRegion, ConsistRgnGlobPtr);
        kb51tablock_search (ConsistRgnGlobPtr^,
              ConsistTabId.surrId_kb05, ConsistHash, UnivItemPtr.uiTabLock_kb05,
              DummyPrevTab, EntryFound);
        IF  EntryFound
        THEN
            BEGIN
            ConsistView := UnivItemPtr.uiConsistView_kb05;
            (* ignore if in work by kb51DelConsistTrans or already cancelled   *)
            (* cancelled may occurr because kb51UpdateMinTrans is called after *)
            (* releasing consist Region and resetting cstInWork_kb05           *)
            IF  ConsistView^.cstInWork_kb05 OR ConsistView^.cstCancelled_kb05
            THEN
                ConsistView := NIL
            ELSE
                IF  min > ( ActClockSecs - ConsistView^.cstStartClockstamp_kb05 )
                THEN
                    BEGIN
                    gg06SetNilTrans (ConsistViewNo);
                    ConsistView := NIL
                    END
                ELSE
                    ConsistView^.cstInWork_kb05 := true;
                (*ENDIF*) 
            (*ENDIF*) 
            END
        ELSE
            gg06SetNilTrans (ConsistViewNo);
        (*ENDIF*) 
        k52endexcl_region (TaskId, ConsistRgnGlobPtr)
        END;
    (*ENDIF*) 
    IF  ( ConsistView <> NIL )
    THEN
        BEGIN
        (* ----- remove HashOpenTrans entries / outside ConsistRegion ----- *)
        kb51RemoveHashOpenTrans (TaskId, ConsistView);
        k52begexcl_region (TaskId, ConsistRegion, ConsistRgnGlobPtr);
        ;
        bIsForOmsVersion := ConsistView^.cstOmsVersion_kb05; (* PTS 1132447 FF *)
        StartDate := ConsistView^.cstStartDate_kb05;
        StartTime := ConsistView^.cstStartTime_kb05;
        (* unchain ConsistView from rglFirstConsistView_kb05 *)
        IF  ConsistView^.cstPrevConsistView_kb05 = NIL
        THEN
            ConsistRgnGlobPtr^.rglFirstConsistView_kb05 := ConsistView^.cstNextConsistView_kb05
        ELSE
            ConsistView^.cstPrevConsistView_kb05^.cstNextConsistView_kb05 :=
                  ConsistView^.cstNextConsistView_kb05;
        (*ENDIF*) 
        IF  ConsistView^.cstNextConsistView_kb05 <> NIL
        THEN
            ConsistView^.cstNextConsistView_kb05^.cstPrevConsistView_kb05 :=
                  ConsistView^.cstPrevConsistView_kb05;
        (*ENDIF*) 
        IF  ConsistView^.cstItemKind_kb05 <> ikConsistView_ekb05
        THEN
            k52x_item_error ('kb51CancelConsistTrans  ', ConsistView^.cstItemKind_kb05);
        (* rechain ConsistView to rglCancelConsView_kb05 *)
        (*ENDIF*) 
        ConsistView^.cstPrevConsistView_kb05        := NIL;
        ConsistView^.cstNextConsistView_kb05        := ConsistRgnGlobPtr^.rglCancelConsView_kb05;
        ConsistRgnGlobPtr^.rglCancelConsView_kb05   := ConsistView;
        IF  ConsistView^.cstNextConsistView_kb05 <> NIL
        THEN
            ConsistView^.cstNextConsistView_kb05^.cstPrevConsistView_kb05 := ConsistView;
        (*ENDIF*) 
        ConsistRgnGlobPtr^.rglCancelCsViewCnt_kb05  := ConsistRgnGlobPtr^.rglCancelCsViewCnt_kb05 + 1;
        ConsistView^.cstCancelled_kb05              := true;
        ConsistRgnGlobPtr^.rglConsistViewCnt_kb05   := ConsistRgnGlobPtr^.rglConsistViewCnt_kb05 - 1;
        ;
        kb51DetermineMinOpenTrans (TaskId, ConsistRgnGlobPtr, UpdateMinTrans);
        ;
        ConsistView^.cstInWork_kb05                 := false;
        k52endexcl_region (TaskId, ConsistRgnGlobPtr);
        IF  UpdateMinTrans                                               (* PTS 1105568 JA 2000-02-10 *)
        THEN
            kb51UpdateMinTrans (TaskId, DO_TRIGGER_GC);
        (*ENDIF*) 
        END;
    (* BEGIN PTS 1132447 FF *)
    (*ENDIF*) 
    IF  NOT gg06IsNilTrans (ConsistViewNo)
        AND bIsForOmsVersion
    THEN
        bd04CancelOmsVersion(TaskId, ConsistViewNo);
    (* END PTS PTS 1132447 FF *)
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51del_transentry_from_locklist (
            TaskId           : tsp00_TaskId;
            VAR TransIndex   : tgg00_TransIndex;
            VAR TransContext : tgg00_TransContext);
 
VAR
      TransRegion           : tkb05_RegionNo;
      ThisTrans             : tkb05_TransEntryPtr;
      TransRgnGlobPtr       : tkb05_RegionGlobPtr;
      tryToResumeRedoReader : boolean;
 
BEGIN
&ifdef TRACE
t01int4 (kb_lock, 'del TransIdx', TransIndex);
&endif
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    TransRegion := k51tr_index_region (TransIndex);
    k52begexcl_region (TaskId, TransRegion, TransRgnGlobPtr);
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  ThisTrans <> NIL
    THEN
        BEGIN
        kb51del_trans_entry (TransRgnGlobPtr^.rglTransGlob_kb05^, ThisTrans, TransContext);
        tryToResumeRedoReader := true;
        END
    ELSE
        tryToResumeRedoReader := false;
    (*ENDIF*) 
    k52endexcl_region (TaskId, TransRgnGlobPtr);
    IF  tryToResumeRedoReader
    THEN
        gg999TryToResumeRedoReader (TransContext.trTaskId_gg00);
    (*ENDIF*) 
    END;
(*ENDIF*) 
TransIndex := cgg_nil_transindex
END;
 
(* PTS 1140529 FF 2006-03-09 *)
(*------------------------------*) 
 
PROCEDURE
      kb51EnableHistoryRetention;
 
VAR
      TaskId : tsp00_TaskId;
 
BEGIN
IF  NOT k51glob.glHistoryNeeded_kb05
THEN
    BEGIN
    vgetpid(TaskId);
    vbegexcl (TaskId, g08lockinit);
    k51glob.glHistoryNeeded_kb05 := true;
    vendexcl (TaskId, g08lockinit);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51enter_all_trans_regions (TaskId : tsp00_TaskId);
 
VAR
      CurrRegion : integer;
 
BEGIN
FOR CurrRegion := 1 TO k51glob.glTransRegions_kb05 DO
    vbegexcl (TaskId, g08lock0 + CurrRegion);
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51examine_trans (VAR t : tgg00_TransContext);
 
VAR
      DummyTrans : tkb05_TransEntryPtr;
 
BEGIN
t.trError_gg00 := e_ok;
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex
ELSE
    (* check outside Trans Region *)
    kb51cancel_and_log_full_check (t, DummyTrans);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51FindConsistView (
            TaskId          : tsp00_TaskId;
            TransIndex      : tgg00_TransIndex;
            ConsistViewNo   : tgg91_TransNo;
            VAR ConsistView : tkb05_ConsistViewPtr);
 
VAR
      EntryFound        : boolean;
      ConsistRegion     : tkb05_RegionNo;
      ConsistHash       : tsp00_Int4;
      DummyPrevTab      : tkb05_TabLockPtr;
      UnivItemPtr       : tkb05_UnivItemPtr;
      ConsistTabId      : tkb05_SurrogateTransId;
      ConsistRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
ConsistView := NIL;
EntryFound  := false;
WITH ConsistTabId DO
    BEGIN
    surrId_kb05      := CONSIST_TRANS_PREFIX_GG00;
    surrTransId_kb05 := ConsistViewNo
    END;
(*ENDWITH*) 
kb51tab_hash (ConsistTabId.surrId_kb05, ConsistHash, ConsistRegion);
k52begexcl_region (TaskId, ConsistRegion, ConsistRgnGlobPtr);
kb51tablock_search (ConsistRgnGlobPtr^,
      ConsistTabId.surrId_kb05, ConsistHash, UnivItemPtr.uiTabLock_kb05,
      DummyPrevTab, EntryFound);
IF  EntryFound
THEN
    BEGIN
    ConsistView := UnivItemPtr.uiConsistView_kb05;
    ConsistView^.cstCurrTransIndex_kb05 := TransIndex
    END;
(*ENDIF*) 
k52endexcl_region (TaskId, ConsistRgnGlobPtr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51GetFirstOpenRedoTrans (
            TaskId         : tsp00_TaskId;
            VAR TransIndex : tgg00_TransIndex);
 
BEGIN
kb51_NextOpenRedoTrans (TaskId, TransIndex, true)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51GetNextOpenRedoTrans (
            TaskId         : tsp00_TaskId;
            VAR TransIndex : tgg00_TransIndex);
 
BEGIN
kb51_NextOpenRedoTrans (TaskId, TransIndex, false)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51GetFirstWriteTrans (VAR WriteTransIndex : tgg00_TransIndex);
 
BEGIN
kb51_NextWriteTrans (WriteTransIndex, true)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51GetNextWriteTrans (VAR WriteTransIndex : tgg00_TransIndex);
 
BEGIN
kb51_NextWriteTrans (WriteTransIndex, false)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51GetRedoTransEntry (
            TaskId         : tsp00_TaskId;
            WriteTransId   : tgg91_TransNo;
            VAR TransIndex : tgg00_TransIndex);
 
VAR
      AuxSession      : tgg91_SessionNo;
      TransRegion     : tkb05_RegionNo;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
gg06BuildRedoSession (AuxSession, WriteTransId);
TransRegion := kb51trans_region (AuxSession);
k52begexcl_region (TaskId, TransRegion, TransRgnGlobPtr);
k51get_transindex (TaskId, AuxSession, WriteTransId, IN_TRANS_REGION, TransIndex);
k52endexcl_region (TaskId, TransRgnGlobPtr);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51CreateRedoTransEntry (
            TaskId         : tsp00_TaskId;
            WriteTransId   : tgg91_TransNo;
            VAR TransIndex : tgg00_TransIndex;
            VAR err        : tgg00_BasisError);
 
VAR
      AuxTrans        : tgg00_TransContext;
      AuxSession      : tgg91_SessionNo;
      TransRegion     : tkb05_RegionNo;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
gg06BuildRedoSession (AuxSession, WriteTransId);
TransRegion := kb51trans_region (AuxSession);
k52begexcl_region (TaskId, TransRegion, TransRgnGlobPtr);
IF  TransRgnGlobPtr^.rglTransGlob_kb05^.trFirstFree_kb05 = NIL
THEN
    TransIndex := cgg_nil_transindex
ELSE
    BEGIN
    AuxTrans.trSessionId_gg00    := AuxSession;
    AuxTrans.trTransId_gg00      := WriteTransId;
    AuxTrans.trWriteTransId_gg00 := WriteTransId;
    AuxTrans.trSubtransId_gg00   := cgg_zero_subtrans;
    AuxTrans.trIndex_gg00        := cgg_nil_transindex;
    AuxTrans.trError_gg00        := e_ok;
    AuxTrans.trState_gg00        := [ ];
    AuxTrans.trTaskId_gg00       := TaskId;
    AuxTrans.trRteCommPtr_gg00   := NIL;
    kb51new_trans (AuxTrans, TransRgnGlobPtr);
    err := AuxTrans.trError_gg00;
    IF  err = e_ok
    THEN
        TransIndex := AuxTrans.trIndex_gg00;
    (*ENDIF*) 
    END;
(*ENDIF*) 
k52endexcl_region (TaskId, TransRgnGlobPtr);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51GetSessionStart (VAR Trans : tgg00_TransContext;
            VAR Date           : tsp00_Int4;
            VAR Time           : tsp00_Int4);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
Date := -1;
Time := -1;
IF  Trans.trIndex_gg00 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_nil_transindex
ELSE
    (* PTS 1133987 UH 2005-02-16 *)
    (*kb51cancel_and_log_full_check (Trans, ThisTrans);*)
    BEGIN
    Trans.trError_gg00 := e_ok;
    ThisTrans          := NIL;
    k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans);
    IF  ThisTrans <> NIL
    THEN
        BEGIN
        vbegexcl (Trans.trTaskId_gg00, g08lock0 + ThisTrans^.teOwnRegion_kb05);
&       ifdef TRACE
        k52xtrans (kb_lockentry, ThisTrans);
&       endif
        IF  ThisTrans^.teState_kb05 <> m_delete
        THEN
            BEGIN
            Date := ThisTrans^.teStartDate_kb05;
            Time := ThisTrans^.teStartTime_kb05;
            END;
        (*ENDIF*) 
        vendexcl (Trans.trTaskId_gg00, g08lock0 + ThisTrans^.teOwnRegion_kb05);
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51get_transindex (
            TaskId              : tsp00_TaskId;
            WantedSessionId     : tgg91_SessionNo;
            WantedWriteTransId  : tgg91_TransNo;
            InTransRegion       : boolean;
            VAR TransIndex      : tgg00_TransIndex);
 
VAR
      Found           : boolean;
      TransRegion     : tkb05_RegionNo;
      TransCnt        : tsp00_Int4;
      TransHash       : tsp00_Int4;
      ThisTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
&ifdef TRACE
ta01Session (kb_lock, 'SessionId   ', WantedSessionId);
ta01TransNo (kb_lock, 'WriteTransId', WantedWriteTransId);
&endif
TransIndex  := cgg_nil_transindex;
TransRegion := kb51trans_region (WantedSessionId);
kb51trans_hash (WantedSessionId, TransHash);
IF  InTransRegion
THEN
    BEGIN
    TransRgnGlobPtr := k51glob.glRegionGlob_kb05^[TransRegion];
    IF  kb03Check.chkRegion_kb00
    THEN
        g08excl_check (TaskId, g08lock0 + TransRegion)
    (*ENDIF*) 
    END
ELSE
    k52begexcl_region (TaskId, TransRegion, TransRgnGlobPtr);
(*ENDIF*) 
ThisTrans := TransRgnGlobPtr^.rglTransGlob_kb05^.trTransHash_kb05^[TransHash];
Found     := false;
TransCnt  := 0;
WHILE (ThisTrans <> NIL) AND NOT Found AND (TransCnt <= k51glob.glTransEntriesPerRegion_kb05) DO
    IF  ThisTrans^.teWriteTransId_kb05 = WantedWriteTransId
    THEN
        Found := true
    ELSE
        BEGIN
        TransCnt  := TransCnt + 1;
        ThisTrans := ThisTrans^.teNextHash_kb05
        END;
    (*ENDIF*) 
(*ENDWHILE*) 
IF  TransCnt > k51glob.glTransEntriesPerRegion_kb05
THEN
    k52x_loop_error ('k51get_transindex       ', 1);
(*ENDIF*) 
IF  ThisTrans <> NIL
THEN
    TransIndex := ThisTrans^.teOwnIndex_kb05;
(*ENDIF*) 
;
&ifdef TRACE
k52xtrans (kb_lockentry, ThisTrans);
&endif
IF  NOT InTransRegion
THEN
    k52endexcl_region (TaskId, TransRgnGlobPtr);
(*ENDIF*) 
;
&ifdef TRACE
t01addr (kb_lock, 'Trans       ', ThisTrans);
t01int4 (kb_lock, 'TransIndex  ', TransIndex);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51handle_request_timeout (VAR Trans : tgg00_TransContext);
 
VAR
      ThisTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
(* PTS 1106270 JA 2000-04-06 *)
Trans.trError_gg00 := e_ok;
IF  Trans.trIndex_gg00 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_nil_transindex
ELSE
    BEGIN
    k52acc_trans_entry (Trans.trIndex_gg00, ThisTrans); (* outside region *)
    IF  ThisTrans^.teReqTab_kb05 <> NIL
    THEN
        BEGIN
        k52begexcl_region (Trans.trTaskId_gg00, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
        ThisTrans^.teTimeoutEnabled_kb05 := false;
        kb51req_timeout_handling (Trans, TransRgnGlobPtr, ThisTrans);
        k52endexcl_region (Trans.trTaskId_gg00, TransRgnGlobPtr)
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51info_lock (
            TaskId         : tsp00_TaskId;
            VAR LockInfo   : tkb05_LockInfo);
 
VAR
      CurrRegion        : tkb05_RegionNo;
      AuxAvg            : tsp00_8ByteCounter;
      CurrRegionGlobPtr : tkb05_RegionGlobPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
      ObjCollGlobPtr    : tkb05_ObjCollGlobPtr;
 
BEGIN
(* PTS 1103743 JA 1999-08-25 *)
WITH LockInfo DO
    BEGIN
    infLockTrans_kb05      := 0;
    infReqTrans_kb05       := 0;
    infObjLockTrans_kb05   := 0;
    infEscalValue_kb05     := k51glob.glMaxRowsPerTab_kb05;
    infMaxEntries_kb05     := k51glob.glItems_kb05;
    infEntriesUsed_kb05    := 0;
    infAvgUsed_kb05        := 0;
    infMaxUsed_kb05        := 0;
    infConsistViewCnt_kb05 := 0;
    infOpenTransCnt_kb05   := 0;
    infSqlCollisions_kb05  := 0;
    infOmsCollisions_kb05  := 0;
    infEscalations_kb05    := 0;
    infDeadlocks_kb05      := 0;
    infSqlReqTimeouts_kb05 := 0;
    infObjReqTimeouts_kb05 := 0;
    infRowEntryAmount_kb05 := 0;
    infTabEntryAmount_kb05 := 0;
    infKbCalls_kb05        := k51_kb_func_calls;
    ;
    FOR CurrRegion := 1 TO k51glob.glRegions_kb05 DO
        BEGIN
        k52begexcl_region (TaskId, CurrRegion, CurrRegionGlobPtr);
        infEntriesUsed_kb05 := infEntriesUsed_kb05 + k52used_items_of_region (CurrRegionGlobPtr^);
        WITH CurrRegionGlobPtr^ DO
            BEGIN
            infConsistViewCnt_kb05 := infConsistViewCnt_kb05 + rglConsistViewCnt_kb05;
            infOpenTransCnt_kb05   := infOpenTransCnt_kb05   + rglOpenTransCnt_kb05;
            infSqlCollisions_kb05  := infSqlCollisions_kb05  + rglCollisions_kb05;
&           ifdef TRACE
            t01int4   (kb_lockentry, 'Region      ', CurrRegion);
            t01p2int4 (kb_lockentry, 'FreeItems   ', rglFreeItems_kb05
                  ,                  'ExtFreeItems', rglExtentFreeItems_kb05);
&           endif
            END;
        (*ENDWITH*) 
        IF  CurrRegion <= k51glob.glTransRegions_kb05
        THEN
            WITH CurrRegionGlobPtr^.rglTransGlob_kb05^ DO
                BEGIN
                infLockTrans_kb05      := infLockTrans_kb05      + trLockTransCnt_kb05;
                infReqTrans_kb05       := infReqTrans_kb05       + trReqTransCnt_kb05;
                infObjLockTrans_kb05   := infObjLockTrans_kb05   + trObjLockTransCnt_kb05;
                infEscalations_kb05    := infEscalations_kb05    + trEscalations_kb05;
                infDeadlocks_kb05      := infDeadlocks_kb05      + trDeadlocks_kb05;
                infSqlReqTimeouts_kb05 := infSqlReqTimeouts_kb05 + trSqlReqTimeouts_kb05;
                infObjReqTimeouts_kb05 := infObjReqTimeouts_kb05 + trObjReqTimeouts_kb05;
                infRowEntryAmount_kb05 := infRowEntryAmount_kb05 + trRowEntryAmount_kb05;
                infTabEntryAmount_kb05 := infTabEntryAmount_kb05 + trTabEntryAmount_kb05
                END;
            (*ENDWITH*) 
        (*ENDIF*) 
        k52endexcl_region (TaskId, CurrRegionGlobPtr)
        END;
    (*ENDFOR*) 
    ;
    k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    WITH k51glob, SupplyPoolGlobPtr^ DO
        BEGIN
        infMaxUsed_kb05 :=
              ITEMS_PER_SUPPLY_SEGM_KB05 * (glSupplyPoolSegments_kb05 - poolMinFreeSegms_kb05)
              +
              glRegions_kb05 * glSupplyItemsPerRegion_kb05;
        IF  poolAmountPoints_kb05 > 0
        THEN
            AuxAvg := trunc (poolItemsUsedAmount_kb05 / poolAmountPoints_kb05)
        ELSE
            AuxAvg := 0;
        (*ENDIF*) 
        IF  AuxAvg > MAX_INT4_SP00
        THEN
            infAvgUsed_kb05 := infMaxUsed_kb05
        ELSE
            infAvgUsed_kb05 := trunc(AuxAvg);
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
    k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    k52begexcl_objcoll (TaskId, ObjCollGlobPtr);
    infOmsCollisions_kb05 := ObjCollGlobPtr^.oglCollisions_kb05;
    k52endexcl_objcoll (TaskId, ObjCollGlobPtr)
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51init_wanted_lock (VAR WantedLock : tkb05_WantedLock);
 
BEGIN
WantedLock := k51glob.glNilWantedLock_kb05
END;
 
(*------------------------------*) 
 
FUNCTION
      k51is_locklist_generated (taskid : tsp00_TaskId) : boolean;
 
BEGIN
vbegexcl (taskid, g08lockinit);
k51is_locklist_generated := k51glob.glGenerated_kb05;
vendexcl (taskid, g08lockinit);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51IsConsistUsedTransId (
            TaskId                      : tsp00_TaskId;
            VAR WriteTransId            : tgg91_TransNo;
            VAR MinConsistUsedTransId   : tgg91_TransNo;
            VAR IsTransUsed             : boolean);
 
VAR
      TabRegion         : tkb05_RegionNo;
      TabHash           : tsp00_Int4;
      DummyTabLock      : tkb05_TabLockPtr;
      DummyPrevTab      : tkb05_TabLockPtr;
      MinOpenTransId    : tgg91_TransNo;
      OpenTransTabId    : tkb05_SurrogateTransId;
      TabRegionGlobPtr  : tkb05_RegionGlobPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
 
BEGIN
(* PTS 1105568 JA 2000-02-10 *)
(* NOTE!: the check is valid for closed transactions only - otherwise use kb51IsObjTransUsed *)
(*                                                                                           *)
(*        Do not compare MinConsistUsedTransId with a transaction, which was not             *)
(*        closed at procedure call                                                           *)
(**)
IF  NOT k51glob.glGenerated_kb05
    OR
    NOT k51glob.glHistoryNeeded_kb05 (* PTS 1140529 FF 2006-03-09 *)
THEN
    (* PTS ? UH 2001-11-28 *)
    BEGIN
    (* lock list is not initialized => no trans can be in use and there is no minconsused *)
    (* the garbage collectors may run if the filesystem is initialized, but not yet the locklist *)
    gg06SetNilTrans (MinConsistUsedTransId);
    IsTransUsed := false
    END
ELSE
    BEGIN
    k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    MinOpenTransId        := SupplyPoolGlobPtr^.poolMinOpenTransId_kb05;
    MinConsistUsedTransId := SupplyPoolGlobPtr^.poolMinConsistViewNo_kb05;
    k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    (**)
    IsTransUsed := false;
    IF  NOT gg06IsNilTrans (MinConsistUsedTransId)                       (* PTS 1106263 JA 2000-04-05 *)
        AND
        (MinConsistUsedTransId.ci6_gg00 <= WriteTransId.ci6_gg00)
    THEN
        IsTransUsed := true
    ELSE
        IF  NOT gg06IsNilTrans (MinOpenTransId)                          (* PTS 1106263 JA 2000-04-05 *)
            AND
            (MinOpenTransId.ci6_gg00 <= WriteTransId.ci6_gg00)
        THEN
            (* --------- check: trans contained in open_trans_list -----------*)
            BEGIN
            OpenTransTabId.surrId_kb05      := OPEN_TRANS_PREFIX_GG00;
            OpenTransTabId.surrTransId_kb05 := WriteTransId;
            kb51tab_hash (OpenTransTabId.surrId_kb05, TabHash, TabRegion);
            k52begexcl_region (TaskId, TabRegion, TabRegionGlobPtr);
            kb51tablock_search (TabRegionGlobPtr^, OpenTransTabId.surrId_kb05, TabHash,
                  DummyTabLock, DummyPrevTab, IsTransUsed);
            k52endexcl_region (TaskId, TabRegionGlobPtr)
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    kb51min_transid_assign (MinConsistUsedTransId, MinOpenTransId)
    END
(*ENDIF*) 
END;
 
(* new: PTS 1130354 *)
(*------------------------------*) 
 
PROCEDURE
      kb51_GetOldestConsistUsedTransId (
            TaskId                      : tsp00_TaskId;
            VAR WriteTransId            : tgg91_TransNo;
            ignoreVersions              : boolean;
            VAR MinConsistUsedTransId   : tgg91_TransNo;
            VAR IsTransUsed             : boolean);
 
VAR
      TabRegion         : tkb05_RegionNo;
      TabHash           : tsp00_Int4;
      DummyTabLock      : tkb05_TabLockPtr;
      DummyPrevTab      : tkb05_TabLockPtr;
      MinOpenTransId    : tgg91_TransNo;
      OpenTransTabId    : tkb05_SurrogateTransId;
      TabRegionGlobPtr  : tkb05_RegionGlobPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
      ConsistHash       : tsp00_Int4;
      ConsistTabId      : tkb05_SurrogateTransId;
      ConsistRegion     : tkb05_RegionNo;
      ConsistRgnGlobPtr : tkb05_RegionGlobPtr;
      ConsistView       : tkb05_ConsistViewPtr;
      UnivItemPtr       : tkb05_UnivItemPtr;
      EntryFound        : boolean;
      CnstViewSyncUsed  : boolean;
 
BEGIN
(* NOTE!: the check is valid for closed transactions only - otherwise use kb51IsObjTransUsed *)
(*                                                                                           *)
(*        Do not compare MinConsistUsedTransId with a transaction, which was not             *)
(*        closed at procedure call                                                           *)
(**)
IF  NOT k51glob.glGenerated_kb05
THEN
    BEGIN
    (* lock list is not initialized => no trans can be in use and there is no minconsused *)
    (* the garbage collectors may run if the filesystem is initialized, but not yet the locklist *)
    gg06SetNilTrans (MinConsistUsedTransId);
    IsTransUsed := false
    END
ELSE
    BEGIN
    CnstViewSyncUsed := false;
    EntryFound       := false;
    WHILE NOT EntryFound DO
        BEGIN
        k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
        MinOpenTransId        := SupplyPoolGlobPtr^.poolMinOpenTransId_kb05;
        IF  ignoreVersions
        THEN
            MinConsistUsedTransId := SupplyPoolGlobPtr^.poolMinNonVersCSVNo_kb05
        ELSE
            MinConsistUsedTransId := SupplyPoolGlobPtr^.poolMinConsistViewNo_kb05;
        (*ENDIF*) 
        k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
        ;
        IsTransUsed := false;
        IF  NOT gg06IsNilTrans (MinConsistUsedTransId)
        THEN
            BEGIN
            WITH ConsistTabId DO
                BEGIN
                surrId_kb05      := CONSIST_TRANS_PREFIX_GG00;
                surrTransId_kb05 := MinConsistUsedTransId;
                END;
            (*ENDWITH*) 
            kb51tab_hash (ConsistTabId.surrId_kb05, ConsistHash, ConsistRegion);
            k52begexcl_region (TaskId, ConsistRegion, ConsistRgnGlobPtr);
            kb51tablock_search (ConsistRgnGlobPtr^,
                  ConsistTabId.surrId_kb05, ConsistHash, UnivItemPtr.uiTabLock_kb05,
                  DummyPrevTab, EntryFound);
            IF  EntryFound
            THEN
                BEGIN
                ConsistView := UnivItemPtr.uiConsistView_kb05;
                IF  (ConsistView^.cstMinOpenTransId_kb05.ci6_gg00 <= WriteTransId.ci6_gg00)
                THEN
                    BEGIN
                    IsTransUsed := true;
                    MinConsistUsedTransId := ConsistView^.cstCreatorTransId_kb05;
                    END;
                (*ENDIF*) 
                END
            ELSE
                IF  CnstViewSyncUsed
                THEN
                    (* must never occur, at least NOT after using ConsistView RW-Lock *)
                    g01abort (kbMsg_csp03, csp3_n_lock, 'MinConsistTransId NOTFND', TaskId);
                (*ENDIF*) 
            (*ENDIF*) 
            k52endexcl_region (TaskId, ConsistRgnGlobPtr)
            END
        ELSE
            EntryFound  := true;
        (*ENDIF*) 
        IF  CnstViewSyncUsed
        THEN
            BEGIN
            kb511LeaveConsistView2 (TaskId, true );
            kb511LeaveConsistView1 (TaskId, true );
            CnstViewSyncUsed := false;
            END
        ELSE
            IF  NOT EntryFound
            THEN
                BEGIN
                (* readerWriter Region have to be aquired within following sequence, *)
                (* because kb51DelConsistTrans calling kb51UpdateMinTrans uses       *)
                (* exactly this sequence                                             *)
                kb511EnterConsistView2 (TaskId, true );
                kb511EnterConsistView1 (TaskId, true );
                CnstViewSyncUsed := true;
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END
    (*ENDWHILE*) 
    END
(*ENDIF*) 
END;
 
(* changed PTS 1130354 *)
(*------------------------------*) 
 
FUNCTION
      kb51IsObjTransUsed (
            TaskId               : tsp00_TaskId;
            VAR Oid              : tgg00_OidSpace;
            VAR ObjTransInfo     : tgg00_ObjTransInfo;
            ignoreVersions       : boolean ;
            VAR OldestTransNo    : tgg91_TransNo): boolean;
 
VAR
      IsUsedAct       : boolean;
      IsUsed          : boolean;
      TransRegion     : tkb05_RegionNo;
      DummyMinTransId : tgg91_TransNo;
      ObjCollEntry    : tkb05_ObjCollEntryPtr;
      ObjCollGlobPtr  : tkb05_ObjCollGlobPtr;
      ThisTrans       : tkb05_TransEntryPtr;
      UpdTransId_gg00 : tgg91_TransNo;
      ActTransNo      : tgg91_TransNo;
 
BEGIN
&ifdef TRACE
t01int4     (kb_lock, 'otrLockIndex', ObjTransInfo.otrLockTransIndex_gg00);
ta01TransNo (kb_lock, 'otrLockTrId ', ObjTransInfo.otrLockTransId_gg00   );
ta01TransNo (kb_lock, 'otrUpdTrnsId', ObjTransInfo.otrUpdTransId_gg00    );
&endif
IsUsed := false;
IsUsedAct := false;
gg06SetZeroTrans (OldestTransNo);
IF  (ObjTransInfo.otrLockTransIndex_gg00 <> cgg_nil_transindex)
    OR
    gg06IsZeroTrans(ObjTransInfo.otrLockTransId_gg00)
THEN
    BEGIN
    (* --------- check: trans active -----------*)
    (* PTS 1128244 FF 2004-03-18 *)
    IF  gg06IsZeroTrans(ObjTransInfo.otrLockTransId_gg00)
    THEN
        BEGIN
        IsUsedAct := k501IsObjTransUsed( TaskId, Oid, ignoreVersions, UpdTransId_gg00, ActTransNo );
        END
    ELSE
        BEGIN
        IF  gg06IsDummyTrans (ObjTransInfo.otrLockTransId_gg00)
        THEN
            (* check collision lock entry *)
            BEGIN
            k52begexcl_objcoll (TaskId, ObjCollGlobPtr);
            k52acc_objcoll_entry (ObjCollGlobPtr^, ObjTransInfo.otrLockTransIndex_gg00, ObjCollEntry);
            IsUsedAct := kb50IsValidCollisionEntry (ObjCollEntry^, Oid);
            IF  IsUsedAct
            THEN
                BEGIN
                TransRegion := k51tr_index_region (ObjCollEntry^.objcLockTransIndex_kb05);
                vbegexcl (TaskId, g08lock0 + TransRegion);
                k52acc_trans_entry (ObjCollEntry^.objcLockTransIndex_kb05, ThisTrans);
                UpdTransId_gg00 := ObjCollEntry^.objcLockTransId_kb05;
                ActTransNo      := ThisTrans^.teSelectTransId_kb05;
                vendexcl (TaskId, g08lock0 + TransRegion);
                END;
            (*ENDIF*) 
            k52endexcl_objcoll (TaskId, ObjCollGlobPtr);
            END
        ELSE
            (* check trans list entry *)
            BEGIN
            TransRegion := k51tr_index_region (ObjTransInfo.otrLockTransIndex_gg00);
            vbegexcl (TaskId, g08lock0 + TransRegion);
            k52acc_trans_entry (ObjTransInfo.otrLockTransIndex_gg00, ThisTrans);
            IsUsedAct := ThisTrans^.teWriteTransId_kb05 = ObjTransInfo.otrLockTransId_gg00;
            IF  IsUsedAct
            THEN
                BEGIN
                UpdTransId_gg00 := ThisTrans^.teWriteTransId_kb05;
                ActTransNo      := ThisTrans^.teSelectTransId_kb05;
                END;
            (*ENDIF*) 
            vendexcl (TaskId, g08lock0 + TransRegion);
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT IsUsedAct
THEN
    UpdTransId_gg00 := ObjTransInfo.otrUpdTransId_gg00;
(*ENDIF*) 
kb51_GetOldestConsistUsedTransId (TaskId,
      UpdTransId_gg00,
      ignoreVersions,
      OldestTransNo, IsUsed);
IF  ( NOT IsUsed) AND IsUsedAct
THEN
    BEGIN
    OldestTransNo := ActTransNo;
    IsUsed        := true;
    END;
(*ENDIF*) 
;
kb51IsObjTransUsed := IsUsed;
&ifdef TRACE
t01bool (kb_lock, 'is_obj_used ', IsUsed);
&endif
END;
 
(* PTS 1132156 FF *)
(*------------------------------*) 
 
PROCEDURE
      k51IsTriggerGcNeeded (
            TaskId             : tsp00_TaskId;
            TransIndex         : tgg00_TransIndex;
            VAR OldestTransId  : tgg91_TransNo;
            VAR IsNeeded       : boolean);
 
VAR
      (*SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;*)
      ThisTrans         : tkb05_TransEntryPtr;
      MinTrans          : tgg91_TransNo;
 
BEGIN
IF  TransIndex <> cgg_nil_transindex (* PTS 1134260 UH 2005-03-04 *)
THEN
    BEGIN
    IsNeeded := false;
    ;
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  ThisTrans <> NIL
    THEN
        BEGIN
        IF  ( tlmFree_ekb05 = ThisTrans^.teOmsLockMode_kb05 )
        THEN
            BEGIN
            (* check is done dirty, because if decision is taken wrong, this means, that *)
            (* garbagecollection is triggered once without any need.                     *)
            (*k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);*)
            MinTrans := k51glob.glSupplyPoolGlob_kb05^.poolMinOpenTransId_kb05;
            (*k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);*)
            ;
            IF  gg06IsNilTrans (MinTrans)
            THEN
                IsNeeded := true
            ELSE
                IF  MinTrans.ci6_gg00 > OldestTransId.ci6_gg00
                THEN
                    IsNeeded := true;
                (*ENDIF*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51leave_all_trans_regions (TaskId : tsp00_TaskId);
 
VAR
      CurrRegion : integer;
 
BEGIN
FOR CurrRegion := 1 TO k51glob.glTransRegions_kb05 DO
    vendexcl (TaskId, g08lock0 + CurrRegion);
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      k51max_locks_per_table : tsp00_Int4;
 
BEGIN
(* outside Lock Region *)
k51max_locks_per_table := k51glob.glMaxRowsPerTab_kb05
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51new_select_trans (
            TaskId                : tsp00_TaskId;
            VAR SelectTransNo     : tgg91_TransNo);
 
BEGIN
vbegexcl (TaskId, g08lockinit);
IF  gg06IsMaxTrans (k51glob.glSelectTransGeneration_kb05)
THEN
    gg06SetZeroTrans (k51glob.glSelectTransGeneration_kb05)
ELSE
    gg06TransIncr (k51glob.glSelectTransGeneration_kb05);
(*ENDIF*) 
SelectTransNo := k51glob.glSelectTransGeneration_kb05;
vendexcl (TaskId, g08lockinit)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51GetLastSelectTransNo (
            TaskId                : tsp00_TaskId;
            VAR SelectTransNo     : tgg91_TransNo);
 
BEGIN
vbegexcl (TaskId, g08lockinit);
SelectTransNo := k51glob.glSelectTransGeneration_kb05;
vendexcl (TaskId, g08lockinit)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51GetMinTrans (
            TaskId                      : tsp00_TaskId;
            VAR MinConsistUsedTransId   : tgg91_TransNo;
            VAR RetainHistory           : boolean);
 
VAR
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
 
BEGIN
IF  NOT k51glob.glGenerated_kb05
THEN
    BEGIN
    (* lock list is not initialized => no trans can be in use and there is no minconsused *)
    (* the garbage collectors may run if the filesystem is initialized, but not yet the locklist *)
    gg06SetNilTrans (MinConsistUsedTransId);
    RetainHistory := false
    END
ELSE
    BEGIN
    k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    MinConsistUsedTransId := SupplyPoolGlobPtr^.poolMinOpenTransId_kb05;
    k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    RetainHistory := k51glob.glHistoryNeeded_kb05;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51new_session (VAR Trans : tgg00_TransContext);
 
BEGIN
IF  NOT k51glob.glGenerated_kb05
THEN
    g01abort (kbMsg_csp03, csp3_n_lock,
          'LOCKLIST NOT INITIALIZED', Trans.trTaskId_gg00);
(*ENDIF*) 
Trans.trError_gg00 := e_ok;
Trans.trState_gg00 := [ ];
k57new_session      (Trans.trTaskId_gg00, Trans.trSessionId_gg00);
k51new_select_trans (Trans.trTaskId_gg00, Trans.trTransId_gg00);
gg06SetNilTrans     (Trans.trWriteTransId_gg00);
Trans.trSubtransId_gg00 := cgg_zero_subtrans;
kb51new_trans (Trans, NIL (* not in trans region *));
END;
 
(*------------------------------*) 
 
FUNCTION
      k51number_of_trans_entries : tsp00_Int2;
 
VAR
      TransEntries : tsp00_Int2;
      TransRegions : tsp00_Int2;
 
BEGIN
(* PTS 1104245 JA 2000-02-08 *)
TransRegions := kb51number_of_trans_regions;
TransEntries := g01maxtrans;
IF  TransEntries > MAX_TRANS_GG04 - TransRegions
THEN
    TransEntries := MAX_TRANS_GG04 - TransRegions
ELSE
    IF  TransEntries < MIN_TRANS_PER_REGION * TransRegions
    THEN
        TransEntries := MIN_TRANS_PER_REGION * TransRegions;
    (*ENDIF*) 
(*ENDIF*) 
k51number_of_trans_entries := ((TransEntries + TransRegions - 1) DIV TransRegions) * TransRegions
END;
 
(*------------------------------*) 
 
PROCEDURE  (* PTS 1122885 FF 2003-07-01 *)
      kb51_remove_locks (
            TaskId              : tsp00_TaskId;
            TransIndex          : tgg00_TransIndex;
            TransRegion         : tkb05_RegionNo);
 
VAR
      CurrRowRegion    : tkb05_RegionNo;
      CurrTabRegion    : tkb05_RegionNo;
      RowItemCnt       : tsp00_Int4;
      TabItemCnt       : tsp00_Int4;
      CurrRow          : tkb05_RowTransPtr;
      CurrTab          : tkb05_TabTransPtr;
      FirstTab         : tkb05_TabTransPtr;
      RowRegionGlobPtr : tkb05_RegionGlobPtr;
      TabRegionGlobPtr : tkb05_RegionGlobPtr;
      ThisTrans        : tkb05_TransEntryPtr;
      TransRgnGlobPtr  : tkb05_RegionGlobPtr;
      UnivItemPtr      : tkb05_UnivItemPtr;
 
BEGIN
k52begexcl_region (TaskId, TransRegion, TransRgnGlobPtr);        (* PTS 1103667 JA 1999-09-02 *)
k52acc_trans_entry (TransIndex, ThisTrans);
IF  ThisTrans <> NIL
THEN
    BEGIN
    IF  ThisTrans^.teReqTab_kb05 <> NIL  (* JA 1999-01-13 *)
    THEN
        BEGIN
        CurrTab := ThisTrans^.teReqTab_kb05;
        CurrRow := ThisTrans^.teReqRow_kb05;
        kb51remove_trans_request   (TaskId, TransRgnGlobPtr^.rglTransGlob_kb05^, ThisTrans);
        (* *)
        k52endexcl_region (TaskId, TransRgnGlobPtr);             (* PTS 1106270 JA 2000-04-06 *)
        kb51remove_tab_row_request (TaskId, REQUEST_TIMEOUT,
              ThisTrans^.teOwnIndex_kb05, CurrTab, CurrRow);
        k52begexcl_region (TaskId, TransRegion, TransRgnGlobPtr) (* PTS 1106270 JA 2000-04-06 *)
        END;
    (*ENDIF*) 
    FirstTab := ThisTrans^.teFirstTab_kb05;
    ThisTrans^.teFirstTab_kb05        := NIL;   (* avoid inconsistent access *)
    ThisTrans^.teTabRecentlyUsed_kb05 := NIL;
    ThisTrans^.teRowRecentlyUsed_kb05 := NIL;
    IF  FirstTab <> NIL
    THEN
        (* Release tab_locks and row_locks outside Trans Region *)
        BEGIN
        k52endexcl_region (TaskId, TransRgnGlobPtr);
        (* --- TabLock Release --- *)
        FOR CurrTabRegion := k51glob.glTransRegions_kb05 + 1
              TO k51glob.glTransRegions_kb05 + k51glob.glTabRegions_kb05 DO
            BEGIN
            TabRegionGlobPtr := NIL;
            CurrTab          := FirstTab;
            TabItemCnt       := 0;
            WHILE (CurrTab <> NIL) AND (TabItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
                BEGIN
                IF  (CurrTabRegion = CurrTab^.ttTabRegion_kb05)
                    AND
                    (* ttTab could be deleted by remove_tab_row_request *)
                    (CurrTab^.ttTab_kb05 <> NIL)                 (* PTS 1106270 JA 2000-04-06 *)
                THEN
                    BEGIN
                    IF  TabRegionGlobPtr = NIL
                    THEN
                        k52begexcl_region (TaskId, CurrTabRegion, TabRegionGlobPtr);
                    (*ENDIF*) 
                    kb51t_release_tab_lock (TaskId, TabRegionGlobPtr^,
                          ThisTrans, CurrTab, RELEASE_ROW_LOCKS)
                    END;
                (*ENDIF*) 
                TabItemCnt := TabItemCnt + 1;
                CurrTab    := CurrTab^.ttNextTab_kb05
                END;
            (*ENDWHILE*) 
            IF  TabRegionGlobPtr <> NIL
            THEN
                k52endexcl_region (TaskId, TabRegionGlobPtr);
            (*ENDIF*) 
            IF  TabItemCnt > k51glob.glMaxItemsPerRegion_kb05
            THEN
                k52x_loop_error ('k51remove_locks         ', 1)
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        ;
        (* --- RowLock Release --- *)
        FOR CurrRowRegion := k51glob.glTransRegions_kb05 + k51glob.glTabRegions_kb05 + 1
              TO k51glob.glRegions_kb05 DO
            BEGIN
            RowRegionGlobPtr := NIL;
            CurrTab          := FirstTab;
            TabItemCnt       := 0;
            WHILE (CurrTab <> NIL) AND (TabItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
                BEGIN
                CurrRow    := CurrTab^.ttFirstRow_kb05;
                RowItemCnt := 0;
                WHILE (CurrRow <> NIL) AND (RowItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
                    BEGIN
                    IF  (CurrRowRegion = CurrRow^.rtRowRegion_kb05)
                        AND
                        (* rtRow could be deleted by remove_tab_row_request *)
                        (CurrRow^.rtRow_kb05 <> NIL)             (* PTS 1106270 JA 2000-04-06 *)
                    THEN
                        BEGIN
                        IF  RowRegionGlobPtr = NIL
                        THEN
                            k52begexcl_region (TaskId, CurrRowRegion, RowRegionGlobPtr);
                        (*ENDIF*) 
                        kb51r_release_row_lock (TaskId, RowRegionGlobPtr^, TransIndex,
                              CurrRow, SATISFY_REQUESTS);
                        END;
                    (*ENDIF*) 
                    RowItemCnt := RowItemCnt + 1;
                    CurrRow    := CurrRow^.rtNextRow_kb05
                    END;
                (*ENDWHILE*) 
                IF  RowItemCnt > k51glob.glMaxItemsPerRegion_kb05
                THEN
                    k52x_loop_error ('k51remove_locks         ', 2);
                (*ENDIF*) 
                TabItemCnt := TabItemCnt + 1;
                CurrTab    := CurrTab^.ttNextTab_kb05
                END;
            (*ENDWHILE*) 
            IF  RowRegionGlobPtr <> NIL
            THEN
                k52endexcl_region (TaskId, RowRegionGlobPtr);
            (*ENDIF*) 
            IF  TabItemCnt > k51glob.glMaxItemsPerRegion_kb05
            THEN
                k52x_loop_error ('k51remove_locks         ', 3);
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        k52begexcl_region (TaskId, TransRegion, TransRgnGlobPtr)
        END;
    (*ENDIF*) 
    CurrTab    := FirstTab;
    TabItemCnt := 0;
    WHILE (CurrTab <> NIL) AND (TabItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        CurrRow    := CurrTab^.ttFirstRow_kb05;
        RowItemCnt := 0;
        WHILE (CurrRow <> NIL) AND (RowItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
            BEGIN
            UnivItemPtr.uiRowTrans_kb05 := CurrRow;
            CurrRow                     := CurrRow^.rtNextRow_kb05;
            RowItemCnt                  := RowItemCnt + 1;
            kb51free_supply_item (TaskId, TransRgnGlobPtr^, UnivItemPtr, ikRowTrans_ekb05)
            END;
        (*ENDWHILE*) 
        IF  RowItemCnt > k51glob.glMaxItemsPerRegion_kb05
        THEN
            k52x_loop_error ('k51remove_locks         ', 4);
        (*ENDIF*) 
        UnivItemPtr.uiTabTrans_kb05 := CurrTab;
        CurrTab                     := CurrTab^.ttNextTab_kb05;
        TabItemCnt                  := TabItemCnt + 1;
        kb51free_supply_item (TaskId, TransRgnGlobPtr^, UnivItemPtr, ikTabTrans_ekb05)
        END;
    (*ENDWHILE*) 
    IF  TabItemCnt > k51glob.glMaxItemsPerRegion_kb05
    THEN
        k52x_loop_error ('k51remove_locks         ', 5);
    (*ENDIF*) 
    kb51tr_finish_trans_lock (TransRgnGlobPtr^.rglTransGlob_kb05^, ThisTrans)
    END;
(*ENDIF*) 
;
&ifdef TRACE
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    k52xregion_supply_check (TransRgnGlobPtr^);
&endif
(*ENDIF*) 
k52endexcl_region (TaskId, TransRgnGlobPtr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51remove_locks (
            TaskId            : tsp00_TaskId;
            TransIndex        : tgg00_TransIndex;
            VAR TransState    : tgg00_TransState);
 
VAR
      TransRegion      : tkb05_RegionNo;
      ThisTrans        : tkb05_TransEntryPtr;
      TransRgnGlobPtr  : tkb05_RegionGlobPtr;
      ThisWriteTransId : tgg91_TransNo;                          (* PTS 1128244 FF 2004-03-18 *)
      bUpdateMinTrans  : boolean;
 
BEGIN
bUpdateMinTrans := false;
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    ;
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    (* vbegexcl (TaskId, g08cnstview);                            * PTS 1122885 FF 2003-07-01 *)
    kb511EnterConsistView1 (TaskId, true );                       (* PTS 1122885 FF 2003-07-01 *)
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    ;
    TransRegion := k51tr_index_region (TransIndex);
    k52begexcl_region (TaskId, TransRegion, TransRgnGlobPtr);
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  ThisTrans <> NIL
    THEN
        BEGIN
&       ifdef TRACE
        k52xtrans (kb_lockentry, ThisTrans);
        t01addr   (kb_lock, 'ThisTrans   ', ThisTrans);
        t01int4   (kb_lock, 'TransIndex  ', TransIndex);
&       endif
        IF  (ThisTrans^.teFirstCollLock_kb05 <> cgg_nil_transindex)
            OR
            (ThisTrans^.teShrLockListPtr_kb05 <> NIL)                (* PTS 1128244 FF 2004-03-18 *)
        THEN
            kb50RemoveObjLocks (TaskId, ThisTrans^);
        (*ENDIF*) 
        ;
        (* gg06SetNilRef (ThisTrans^.teStartObjSeq_kb05);               PTS 1105435 JA 2000-02-01 *)
        ThisWriteTransId := ThisTrans^.teWriteTransId_kb05;          (* PTS 1128244 FF 2004-03-18 *)
        (* teWriteTransId := nil --> object locks released *)
        IF  NOT gg06IsNilTrans(ThisTrans^.teWriteTransId_kb05)
        THEN
            BEGIN
            gg06SetNilTrans     (ThisTrans^.teWriteTransId_kb05);        (* PTS 1103667 JA 1999-09-02 *)
            bUpdateMinTrans  := true;
            END;
        (*ENDIF*) 
        ThisTrans^.teSubtransId_kb05 := cgg_zero_subtrans;           (* PTS 1103667 JA 1999-09-02 *)
        IF  ThisTrans^.teConsistView_kb05 <> NIL
        THEN
            ThisTrans^.teConsistView_kb05 := NIL;
        (*ENDIF*) 
        ThisTrans^.teOmsLockMode_kb05 := tlmFree_ekb05;              (* PTS 1131932 FF 14-OCT-2004 *)
        k501DestroyTransLockInfo(ThisTrans^, ThisWriteTransId);      (* PTS 1128244 FF 2004-03-18 *)
        kb509SetTransactionStartTime(ThisTrans^);                    (* PTS 1131982 FF 28-OCT-2004 *)
        k52flush_trans_entry (ThisTrans^);
        END;
    (*ENDIF*) 
    k52endexcl_region (TaskId, TransRgnGlobPtr);                     (* PTS 1103667 JA 1999-09-02 *)
    ;
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    (*vendexcl (TaskId, g08cnstview);                      PTS 1122885 FF & 1103667 JA 1999-09-02 *)
    kb511LeaveConsistView1 (TaskId, true );                           (* PTS 1122885 FF 2003-07-01 *)
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    ;
    kb51_remove_locks (TaskId, TransIndex, TransRegion);             (* PTS 1122885 FF 2003-07-01 *)
    ;
    IF  bUpdateMinTrans
    THEN
        kb51UpdateMinTransIfNeeded(TaskId);
    (*ENDIF*) 
    END;
(*ENDIF*) 
TransState := TransState - [tsLocked_egg00,  tsTempUpdated_egg00
      ,                     tsUpdated_egg00, tsSubUpdated_egg00]
END;
 
(*------------------------------*) 
 
PROCEDURE     (* PTS 1122885 FF 2003-07-01 *)
      k51remove_locks_2 (
            VAR Trans         : tgg00_TransContext;
            TransIndex        : tgg00_TransIndex;
            VAR TransState    : tgg00_TransState);
 
VAR
      TransRegion      : tkb05_RegionNo;
      ThisTrans        : tkb05_TransEntryPtr;
      TransRgnGlobPtr  : tkb05_RegionGlobPtr;
      TaskId           : tsp00_TaskId;
      bUseRegion       : boolean;
      bUpdateMinTrans  : boolean;
 
BEGIN
bUpdateMinTrans := false;
TaskId := Trans.trTaskId_gg00;
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    bUseRegion := false;
    TransRegion := k51tr_index_region (TransIndex);
    (*IF  gg06IsNilTrans (Trans.trWriteTransId_gg00)
          THEN
          BEGIN *)
    k52begexcl_region (TaskId, TransRegion, TransRgnGlobPtr);
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  ThisTrans <> NIL
    THEN
        BEGIN
        (* IF gg06IsNilTrans (ThisTrans^.teWriteTransId_kb05) PTS 1131932 FF 14-OCT-2004 *)
        IF  ( tlmFree_ekb05 = ThisTrans^.teOmsLockMode_kb05 )
        THEN
            BEGIN
&           ifdef TRACE
            k52xtrans (kb_lockentry, ThisTrans);
            t01addr   (kb_lock, 'ThisTrans   ', ThisTrans);
            t01int4   (kb_lock, 'TransIndex  ', TransIndex);
&           endif
            ThisTrans^.teSubtransId_kb05 := cgg_zero_subtrans;           (* PTS 1103667 JA 1999-09-02 *)
            IF  ThisTrans^.teConsistView_kb05 <> NIL
            THEN
                ThisTrans^.teConsistView_kb05 := NIL;
            (*ENDIF*) 
            ThisTrans^.teOmsLockMode_kb05 := tlmFree_ekb05;              (* PTS 1131932 FF 14-OCT-2004 *)
            IF  NOT gg06IsNilTrans(ThisTrans^.teWriteTransId_kb05)
            THEN
                BEGIN
                gg06SetNilTrans     (ThisTrans^.teWriteTransId_kb05);        (* PTS 1131932 FF 2004-OCT-14 *)
                bUpdateMinTrans := true;
                END;
            (*ENDIF*) 
            kb509SetTransactionStartTime(ThisTrans^);                    (* PTS 1131982 FF 28-OCT-2004 *)
            k52flush_trans_entry (ThisTrans^);
            END
        ELSE
            bUseRegion := true;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    k52endexcl_region (TaskId, TransRgnGlobPtr);                     (* PTS 1103667 JA 1999-09-02 *)
    (* END
          ELSE
          bUseRegion := true;
          *ENDIF *)
    ;
    IF  bUseRegion
    THEN
        k51remove_locks (TaskId, TransIndex, TransState)
    ELSE
        kb51_remove_locks (TaskId, TransIndex, TransRegion);             (* PTS 1122885 FF 2003-07-01 *)
    (*ENDIF*) 
    ;
    IF  bUpdateMinTrans
    THEN
        kb51UpdateMinTransIfNeeded(TaskId);
    (*ENDIF*) 
    ;
    END;
(*ENDIF*) 
TransState := TransState - [tsLocked_egg00,  tsTempUpdated_egg00
      ,                     tsUpdated_egg00, tsSubUpdated_egg00]
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51reset_statistics (TaskId : tsp00_TaskId);
 
VAR
      CurrRegion        : tkb05_RegionNo;
      CurrRegionGlobPtr : tkb05_RegionGlobPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
 
BEGIN
IF  k51glob.glGenerated_kb05
THEN
    BEGIN
    k51_kb_func_calls := 0;
    FOR CurrRegion := 1 TO k51glob.glTransRegions_kb05 DO
        BEGIN
        k52begexcl_region (TaskId, CurrRegion, CurrRegionGlobPtr);
        CurrRegionGlobPtr^.rglCollisions_kb05 := 0;
        IF  CurrRegion <= k51glob.glTransRegions_kb05
        THEN
            BEGIN
            WITH CurrRegionGlobPtr^.rglTransGlob_kb05^ DO
                BEGIN
                trRowEntryAmount_kb05  := 0;
                trTabEntryAmount_kb05  := 0;
                trSqlReqTimeouts_kb05  := 0;
                trObjReqTimeouts_kb05  := 0;
                trDeadlocks_kb05       := 0;
                trEscalations_kb05     := 0
                END;
            (*ENDWITH*) 
            k52flush_trans_glob (CurrRegionGlobPtr^.rglTransGlob_kb05^);
            END;
        (*ENDIF*) 
        k52endexcl_region (TaskId, CurrRegionGlobPtr);
        END;
    (*ENDFOR*) 
    k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
    WITH SupplyPoolGlobPtr^ DO
        BEGIN
        poolSegmsUsedAmount_kb05 := 0;
        poolItemsUsedAmount_kb05 := 0;
        poolAmountPoints_kb05    := 0;
        poolMinFreeSegms_kb05    := poolFreeSegments_kb05
        END;
    (*ENDWITH*) 
    k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51restart_locklist (VAR t : tgg00_TransContext);
 
VAR
      CurrRegion             : tkb05_RegionNo;
      i                      : tsp00_Int4;
      OffsetFirstRgnTransIdx : tgg00_TransIndex;
      UnivAddr               : tkb05_UnivPtr;
      ThisRegionGlob         : tkb05_RegionGlobPtr;
      ThisTrans              : tkb05_TransEntryPtr;
 
BEGIN
t.trError_gg00 := e_ok;
vbegexcl (t.trTaskId_gg00, g08lockinit);
k51_kb_func_calls := 0;
IF  NOT k51glob.glGenerated_kb05
THEN
    BEGIN
    WITH k51glob DO
        BEGIN
        glTransRegions_kb05 := kb51number_of_trans_regions;
        glRowRegions_kb05   := g01region_cnt (rgnRow_egg00);
        glTabRegions_kb05   := g01region_cnt (rgnTab_egg00);
        IF  glTabRegions_kb05  < 1
        THEN
            glTabRegions_kb05 := 1;
        (*ENDIF*) 
        IF  glRowRegions_kb05  < 1
        THEN
            glRowRegions_kb05 := 1;
        (*ENDIF*) 
        IF  glTransRegions_kb05 + glTabRegions_kb05 + glRowRegions_kb05 > MAX_REGIONS_KB05
        THEN
            BEGIN
            IF  glTabRegions_kb05  > (MAX_REGIONS_KB05 - glTransRegions_kb05) DIV 2
            THEN
                glTabRegions_kb05 := (MAX_REGIONS_KB05 - glTransRegions_kb05) DIV 2;
            (*ENDIF*) 
            IF  glTransRegions_kb05 + glTabRegions_kb05 + glRowRegions_kb05 > MAX_REGIONS_KB05
            THEN
                glRowRegions_kb05 := MAX_REGIONS_KB05 - glTransRegions_kb05 - glTabRegions_kb05
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        glRegions_kb05 := glTransRegions_kb05 + glRowRegions_kb05 + glTabRegions_kb05;
        ;
        (* generated             := -.-  already initialized by k51set_not_generated *)
        ;
        glSupplyItemsPerRegion_kb05 := g01lock_supply_block;
        IF  glSupplyItemsPerRegion_kb05 < MIN_SUPPLY_ITEMS_PER_RGN
        THEN
            glSupplyItemsPerRegion_kb05 := MIN_SUPPLY_ITEMS_PER_RGN
        ELSE
            IF  glSupplyItemsPerRegion_kb05 > MAX_SUPPLY_BLOCK_ITEMS_KB05
            THEN
                glSupplyItemsPerRegion_kb05 := MAX_SUPPLY_BLOCK_ITEMS_KB05;
            (*ENDIF*) 
        (*ENDIF*) 
        ;
        glSupplyPoolSegments_kb05 :=
              (g01maxlocks * ITEMS_PER_ROW_LOCK + ITEMS_PER_SUPPLY_SEGM_KB05 - 1)
              DIV ITEMS_PER_SUPPLY_SEGM_KB05;
        IF  glSupplyPoolSegments_kb05 > MAX_SUPPLY_SEGMENTS_KB05
        THEN
            glSupplyPoolSegments_kb05 := MAX_SUPPLY_SEGMENTS_KB05
        ELSE
            IF  glSupplyPoolSegments_kb05 < glRegions_kb05 * MIN_EXTENT_SEGMS_PER_RGN
            THEN
                glSupplyPoolSegments_kb05 := glRegions_kb05 * MIN_EXTENT_SEGMS_PER_RGN;
            (*ENDIF*) 
        (*ENDIF*) 
        ;
        glSupplyPoolItems_kb05   := ITEMS_PER_SUPPLY_SEGM_KB05 * glSupplyPoolSegments_kb05;
        glMaxItemsPerRegion_kb05 := glSupplyPoolItems_kb05 + glSupplyItemsPerRegion_kb05;
        glItems_kb05             :=
              glSupplyPoolItems_kb05 + glSupplyItemsPerRegion_kb05 * glRegions_kb05;
        ;
        glRowHashEntriesPerRegion_kb05 := g01maxlocks DIV glRowRegions_kb05;
        IF  glRowHashEntriesPerRegion_kb05 < MIN_HASH_PER_REGION
        THEN
            glRowHashEntriesPerRegion_kb05 := MIN_HASH_PER_REGION
        ELSE
            IF  glRowHashEntriesPerRegion_kb05 > MAX_ROW_HASH_KB05
            THEN
                glRowHashEntriesPerRegion_kb05 := MAX_ROW_HASH_KB05;
            (*ENDIF*) 
        (*ENDIF*) 
        ;
        glTabHashEntriesPerRegion_kb05 :=
              (g01maxlocks DIV AVERAGE_ROW_LOCKS_PER_TAB) DIV glTabRegions_kb05;
        IF  glTabHashEntriesPerRegion_kb05 < MIN_HASH_PER_REGION
        THEN
            glTabHashEntriesPerRegion_kb05 := MIN_HASH_PER_REGION
        ELSE
            IF  glTabHashEntriesPerRegion_kb05 > MAX_TAB_HASH_KB05
            THEN
                glTabHashEntriesPerRegion_kb05 := MAX_TAB_HASH_KB05;
            (*ENDIF*) 
        (*ENDIF*) 
        ;
        glTransEntries_kb05              := k51number_of_trans_entries;
        glTransEntriesPerRegion_kb05     := glTransEntries_kb05 DIV glTransRegions_kb05;
        glTransHashEntriesPerRegion_kb05 := glTransEntriesPerRegion_kb05;
        IF  glTransHashEntriesPerRegion_kb05 > MAX_TRANS_HASH_KB05
        THEN
            glTransHashEntriesPerRegion_kb05 := MAX_TRANS_HASH_KB05;
&       ifdef TRACE
        (*ENDIF*) 
        IF  t01trace (kb_lock)
        THEN
            BEGIN
            t01p2int4 (kb_lock, 'g01maxlocks ', g01maxlocks
                  ,             'g01maxtrans ', g01maxtrans);
            t01p2int4 (kb_lock, 'glRegions   ', glRegions_kb05
                  ,             'glTransEntr ', glTransEntries_kb05);
            t01p2int4 (kb_lock, 'glTransHashE', glTransHashEntriesPerRegion_kb05
                  ,             'glItems     ', glItems_kb05);
            t01p2int4 (kb_lock, 'glRowHashEnt', glRowHashEntriesPerRegion_kb05
                  ,             'glPoolSegms ', glSupplyPoolSegments_kb05);
            t01p2int4 (kb_lock, 'glTabHashEnt', glTabHashEntriesPerRegion_kb05
                  ,             'glSItemsPerR', glSupplyItemsPerRegion_kb05)
            END;
&       endif
        (*ENDIF*) 
        ;
        glHistoryNeeded_kb05      := false; (* PTS 1140529 FF 2006-03-09 *)
        glFiller2_kb05            := 0;
        glDeadlockDetection_kb05  := g01deadlock_detection;
        glMaxRowsPerTab_kb05      := g01maxlocks DIV 5; (* 20% of available entries *)
        glFiller3_kb05            := 0;
        gg06SetZeroTrans (glSelectTransGeneration_kb05);
        ;
        WITH glNilWantedLock_kb05 DO
            BEGIN
            wlTabId_kb05       := cgg_zero_id;
            wlMode_kb05        := lckFree_egg00;
            wlState_kb05       := [ ];
            wlKeyLen_kb05      := 0;
            wlRowWanted_kb05   := false;
            wlHandling_kb05    := [ ];
            wlGrantedMode_kb05 := lckFree_egg00;
            wlFiller1_kb05     := false;
            FOR i := 1 TO sizeof (wlRowId_kb05) DO
                wlRowId_kb05 [i] := chr(0)
            (*ENDFOR*) 
            END;
        (*ENDWITH*) 
        WITH glNilOpenTrans_kb05 DO
            BEGIN
            openItemKind_kb05      := ikOpenTrans_ekb05;
            openExtentItem_kb05    := false;
            openChkOwnRegion_kb05  := NIL_REGION_KB05;
            openChkTransIndex_kb05 := cgg_nil_transindex;
            openChkTaskId_kb05     := cgg_nil_pid;
            (* *)
            openNext_kb05          := NIL;
            (* *)
            openCount_kb05         := 0;
            openFiller1_kb05       := 0;
            (* *)
            FOR i := 1 TO TRANS_PER_OPEN_ENTRY_KB05 DO
                BEGIN
                openOwnHashTrans_kb05 [i] := NIL;
                openHashRegion_kb05   [i] := NIL_REGION_KB05;
                gg06SetNilTrans (openTransId_kb05 [i])
                END
            (*ENDFOR*) 
            END;
        (*ENDWITH*) 
        WITH glNilReq_kb05 DO
            BEGIN
            rqItemKind_kb05      := ikRequest_ekb05;
            rqExtentItem_kb05    := false;
            rqChkOwnRegion_kb05  := NIL_REGION_KB05;
            rqChkTransIndex_kb05 := cgg_nil_transindex;
            rqChkTaskId_kb05     := cgg_nil_pid;
            (* *)
            rqNextReq_kb05       := NIL;
            rqPrevReq_kb05       := NIL;
            (* *)
            rqLastReq_kb05       := NIL;
            (* *)
            rqTransIndex_kb05    := cgg_nil_transindex;
            rqEotWanted_kb05     := false;
            rqReqMode_kb05       := lckFree_egg00;
            rqLockMode_kb05      := lckFree_egg00;
            rqTransLockMode_kb05 := tlmFree_ekb05; (* JA 1996-12-04 *)
            rqFiller1_kb05       := 0;
            (* *)
            rqRowShareLocks_kb05 := 0;
            rqRowExclLocks_kb05  := 0
            END;
        (*ENDWITH*) 
        WITH glNilRowLock_kb05 DO
            BEGIN
            rlItemKind_kb05         := ikRowLock_ekb05;
            rlExtentItem_kb05       := false;
            rlChkOwnRegion_kb05     := NIL_REGION_KB05;
            rlChkTransIndex_kb05    := cgg_nil_transindex;
            rlChkTaskId_kb05        := cgg_nil_pid;
            (* *)
            rlTabId_kb05            := cgg_zero_id;
            (* *)
            rlNextHashRow_kb05      := NIL;
            rlRowIdItem_kb05        := NIL;
            (* *)
            rlFirstReqRow_kb05      := NIL;
            (* *)
            rlShortKey_kb05         := glNilWantedLock_kb05.wlShortKey_kb05;
            rlKeyLen_kb05           := 0;
            rlExclTransIndex_kb05   := cgg_nil_transindex;
            rlLockState_kb05        := [];    (* PTS 1115302 UH 2002-05-02 *)
            rlFiller_kb05           := false; (* PTS 1115302 UH 2002-05-02 *)
            (* *)
            rlRowShareLocks_kb05    := 0;
            rlRowOptimCnt_kb05      := 0;
            (* *)
            rlRowOptimVers_kb05     := 0;
            rlShare1TransIndex_kb05 := cgg_nil_transindex;
            rlShare2TransIndex_kb05 := cgg_nil_transindex
            END;
        (*ENDWITH*) 
        WITH glNilRowTrans_kb05 DO
            BEGIN
            rtItemKind_kb05      := ikRowTrans_ekb05;
            rtExtentItem_kb05    := false;
            rtChkOwnRegion_kb05  := NIL_REGION_KB05;
            rtChkTransIndex_kb05 := cgg_nil_transindex;
            rtChkTaskId_kb05     := cgg_nil_pid;
            (* *)
            rtRow_kb05           := NIL;
            rtNextRow_kb05       := NIL;
            (* *)
            rtPrevRow_kb05       := NIL;
            (* *)
            rtShortKey_kb05      := glNilWantedLock_kb05.wlShortKey_kb05;
            rtKeyLen_kb05        := 0;
            rtLockMode_kb05      := lckFree_egg00;
            rtLockState_kb05     := [ ];
            rtReqMode_kb05       := lckFree_egg00;
            rtReqState_kb05      := [ ];
            (* *)
            rtRowRegion_kb05     := NIL_REGION_KB05;
            rtSharedLocked_kb05  := false;                           (* PTS 1107452 JA 2000-08-08 *)
            rtOptimSet_kb05      := false;                           (* PTS 1107452 JA 2000-08-08 *)
            rtRowHash_kb05       := 0;
            (* *)
            rtRowOptimVers_kb05  := 0;
            rtTabOptimVers_kb05  := 0
            END;
        (*ENDWITH*) 
        WITH glNilTabLock_kb05 DO
            BEGIN
            tlItemKind_kb05         := ikTabLock_ekb05;
            tlExtentItem_kb05       := false;
            tlChkOwnRegion_kb05     := NIL_REGION_KB05;
            tlChkTransIndex_kb05    := cgg_nil_transindex;
            tlChkTaskId_kb05        := cgg_nil_pid;
            (* *)
            tlTabId_kb05            := cgg_zero_id;
            (* *)
            tlNextHashTab_kb05      := NIL;
            tlFirstReqTab_kb05      := NIL;
            (* *)
            tlFirstReqRow_kb05      := NIL;
            (* *)
            tlIsSysExcl_kb05        := false;
            tlFiller1_kb05          := false;
            tlExclTransIndex_kb05   := cgg_nil_transindex;
            tlShare1TransIndex_kb05 := cgg_nil_transindex;
            tlShare2TransIndex_kb05 := cgg_nil_transindex;
            (* *)
            tlSysShareLocks_kb05    := 0;
            tlTabShareLocks_kb05    := 0;
            (* *)
            tlTabOptimVers_kb05     := 0;
            tlRowShareLocks_kb05    := 0;
            (* *)
            tlRowOptimCnt_kb05      := 0;
            tlRowExclLocks_kb05     := 0
            END;
        (*ENDWITH*) 
        WITH glNilTabTrans_kb05 DO
            BEGIN
            ttItemKind_kb05      := ikTabTrans_ekb05;
            ttExtentItem_kb05    := false;
            ttChkOwnRegion_kb05  := NIL_REGION_KB05;
            ttChkTransIndex_kb05 := cgg_nil_transindex;
            ttChkTaskId_kb05     := cgg_nil_pid;
            (* *)
            ttTabId_kb05         := cgg_zero_id;
            (* *)
            ttTab_kb05           := NIL;
            ttFirstRow_kb05      := NIL;
            (* *)
            ttConsistentRow_kb05 := NIL;
            ttNextTab_kb05       := NIL;
            (* *)
            ttLockMode_kb05      := lckFree_egg00;
            ttLockState_kb05     := [ ];
            ttReqMode_kb05       := lckFree_egg00;
            ttReqState_kb05      := [ ];
            ttKeySort_kb05       := true;                            (* PTS 1107056 JA 2001-03-01 *)
            ttFiller1_kb05       := false;
            ttTabRegion_kb05     := NIL_REGION_KB05;
            (* *)
            ttTabHash_kb05       := 0;
            ttRowShareLocks_kb05 := 0;
            (* *)
            ttRowOptimCnt_kb05   := 0;
            ttRowExclLocks_kb05  := 0
            END;
        (*ENDWITH*) 
        WITH glNilTransEntry_kb05 DO
            BEGIN
            teOwnAddr_kb05         := NIL;
            teNextHash_kb05        := NIL;
            (* *)
            tePrevHash_kb05        := NIL;
            teNextTrans_kb05       := NIL;
            (* *)
            tePrevTrans_kb05       := NIL;
            teFirstTab_kb05        := NIL;
            (* *)
            teTabRecentlyUsed_kb05 := NIL;
            teRowRecentlyUsed_kb05 := NIL;
            (* *)
            teReqTab_kb05          := NIL;
            teReqRow_kb05          := NIL;
            (* *)
            teConsistView_kb05     := NIL;
            teCancelAddr_kb05      := NIL;
            (* *)
            teOwnIndex_kb05        := cgg_nil_transindex;
            teOwnRegion_kb05       := NIL_REGION_KB05;
            gg06SetNilSession   (teSessionId_kb05);
            (* *)
            gg06SetNilTrans     (teSelectTransId_kb05);
            gg06SetNilTrans     (teWriteTransId_kb05);
            teSubtransId_kb05      := cgg_zero_subtrans;
            (* *)
            teUserId_kb05          := cgg_zero_userid;
            teTermId_kb05          := bsp_termid;
            teTimeoutEnabled_kb05  := false;
            teFiller2_kb05         := false;
            (* *)
            teTaskId_kb05          := cgg_nil_pid;
            teInfo_kb05            := [ ];
            teFiller8_kb05         := false;
            teLockMode_kb05        := tlmFree_ekb05;
            teReqMode_kb05         := tlmFree_ekb05;
            (* *)
            teReqTimeout_kb05      := 0;
            teTimeLastWrite_kb05   := 0;
            (* *)
            teState_kb05           := m_nil;
            teObjLockMode_kb05     := tlmFree_ekb05;
            teFiller3_kb05         := 0;
            teFiller4_kb05         := 0;
            (* *)
            teStartDate_kb05       := 0;
            teStartTime_kb05       := 0;
            (* *)
            teFirstCollLock_kb05   := cgg_nil_transindex;
            teObjReq_kb05          := cgg_nil_transindex;
            teObjReqTimeout_kb05   := 0;
            (* *)
            teWaiting_kb05         := false;
            teOmsLockMode_kb05     := tlmFree_ekb05;  (* PTS 1131932 FF 14-OCT-2004 *)
            teFiller6_kb05         := 0;
            teFiller7_kb05         := 0;
            teLocalFileDirPtr_kb05 := NIL;
            teShrLockListPtr_kb05  := NIL;   (* PTS 1128244 FF 2004-03-18 *)
            teExtTransMonPtr_kb05  := NIL;   (* PTS 1130965 FF 2004-08-12 *)
            END;
        (*ENDWITH*) 
        WITH glNilTransEntry_kb05.teLog_kb05 DO
            BEGIN
            tlogAuxFnNo_kb05                   := 0;
            tlogTempFunctRollb_kb05            := 0;
            (* *)
            tlogTempEntryCnt_kb05              := 0;
            tlogTempFileRoot_kb05              := NIL_PAGE_NO_GG00;
            (* *)
            tlogTransPtr_kb05                  := NIL; (* Logging74 UH *)
&           ifdef BIT64
&           else
            glFillerAddr_kb05                  := NIL; (* Logging74 UH *)
&           endif
            END;
        (*ENDWITH*) 
        ;
        (* ======================================================================================= *)
        g01allocate_msg (csp3_n_dynpool, 'DYNP_K51_LOCK_LIST     :',
              g01align (glRegions_kb05 *           sizeof (tkb05_RegionGlobPtr))
              +         glRegions_kb05 * g01align (SPACE_BETWEEN_REGIONS_KB05)
              +         glRegions_kb05 * g01align (sizeof (tkb05_RegionGlob))
              +         glRegions_kb05 * g01align (glSupplyItemsPerRegion_kb05 * sizeof (tkb05_SupplyItem))
              (* *)
              + glTransRegions_kb05 * g01align (sizeof (tkb05_TransGlob))
              + glTransRegions_kb05 * g01align (glTransHashEntriesPerRegion_kb05 * sizeof (tkb05_TransEntryPtr))
              + glTransRegions_kb05 * g01align (glTransEntriesPerRegion_kb05     * sizeof (tkb05_TransEntry   ))
              (* *)
              + g01align (glTransEntries_kb05 * sizeof (tkb05_TransEntryPtr    ))
              + g01align (glTransEntries_kb05 * sizeof (tkb05_ObjCollisionEntry))
              + g01align (glTransEntries_kb05 * sizeof (tkb05_ObjReqEntry      ))
              (* *)
              + glTabRegions_kb05 * g01align (glTabHashEntriesPerRegion_kb05 * sizeof (tkb05_TabLockPtr))
              + glRowRegions_kb05 * g01align (glRowHashEntriesPerRegion_kb05 * sizeof (tkb05_RowLockPtr))
              (* *)
              + g01align (glSupplyPoolSegments_kb05 *           sizeof (tkb05_SupplySegmPtr))
              +           glSupplyPoolSegments_kb05 * g01align (SPACE_BETWEEN_REGIONS_KB05 )
              +           glSupplyPoolSegments_kb05 * g01align (sizeof (tkb05_SupplySegment))
              (* *)
              + g01align (sizeof (tkb05_SupplyPoolGlob))
              + g01align (sizeof (tkb05_LockStateGlob ))
              + g01align (sizeof (tkb05_ObjCollGlob   ))
              + 3 * g01align (SPACE_BETWEEN_REGIONS_KB05));
        (* ======================================================================================= *)
        ;
        g01allocate_msg (csp3_n_dynpool, 'LOCK maxlocks          :', g01maxlocks);
        g01allocate_msg (csp3_n_dynpool, 'LOCK items             :', glItems_kb05);
        (**)
        g01allocate_msg (csp3_n_dynpool, 'LOCK Regions           :', glRegions_kb05);
        g01allocate_msg (csp3_n_dynpool, 'LOCK TransRegions      :', glTransRegions_kb05);
        g01allocate_msg (csp3_n_dynpool, 'LOCK RegionGlob+Space  :',
              glRegions_kb05 *
              (g01align (SPACE_BETWEEN_REGIONS_KB05) + g01align (sizeof (tkb05_RegionGlob))));
        g01allocate_msg (csp3_n_dynpool, 'LOCK TransGlob         :',
              glTransRegions_kb05 * g01align (sizeof (tkb05_TransGlob)));
        g01allocate_msg (csp3_n_dynpool, 'LOCK SupplyItemsPerRgn :', glSupplyItemsPerRegion_kb05);
        g01allocate_msg (csp3_n_dynpool, 'LOCK SupplySize        :',
              glRegions_kb05 * g01align (glSupplyItemsPerRegion_kb05 * sizeof (tkb05_SupplyItem)));
        (**)
        g01allocate_msg (csp3_n_dynpool, 'LOCK RowHash entries   :',
              glRowHashEntriesPerRegion_kb05 * glRowRegions_kb05);
        g01allocate_msg (csp3_n_dynpool, 'LOCK TabHash entries   :',
              glTabHashEntriesPerRegion_kb05 * glTabRegions_kb05);
        g01allocate_msg (csp3_n_dynpool, 'LOCK Row+Tab hash size :',
              glRowRegions_kb05
              * g01align (glRowHashEntriesPerRegion_kb05 * sizeof (tkb05_RowLockPtr)) +
              glTabRegions_kb05
              * g01align (glTabHashEntriesPerRegion_kb05 * sizeof (tkb05_TabLockPtr)));
        (**)
        g01allocate_msg (csp3_n_dynpool, 'LOCK Trans entries     :',
              glTransEntries_kb05);
        g01allocate_msg (csp3_n_dynpool, 'LOCK trans_list size   :',
              glTransRegions_kb05 * g01align (glTransEntriesPerRegion_kb05 * sizeof (tkb05_TransEntry)));
        g01allocate_msg (csp3_n_dynpool, 'LOCK TransPtrList      :',
              g01align (glTransEntries_kb05 * sizeof (tkb05_TransEntryPtr)));
        g01allocate_msg (csp3_n_dynpool, 'LOCK TransHash entries :',
              glTransHashEntriesPerRegion_kb05 * glTransRegions_kb05);
        g01allocate_msg (csp3_n_dynpool, 'LOCK TransHash size    :',
              glTransRegions_kb05 *
              g01align (glTransHashEntriesPerRegion_kb05 * sizeof (tkb05_TransEntryPtr)));
        (* *)
        g01allocate_msg (csp3_n_dynpool, 'LOCK SupplyPoolSegments:', glSupplyPoolSegments_kb05);
        g01allocate_msg (csp3_n_dynpool, 'LOCK SupplyPoolSize    :',
              g01align (glSupplyPoolSegments_kb05 * sizeof (tkb05_SupplySegmPtr)) +
              glSupplyPoolSegments_kb05 * g01align (sizeof (tkb05_SupplySegment)));
        (* *)
        g01allocate_msg (csp3_n_dynpool, 'LOCK ObjColl_list size :',
              g01align (glTransEntries_kb05 * sizeof (tkb05_ObjCollisionEntry)));
        g01allocate_msg (csp3_n_dynpool, 'LOCK ObjReq_list size  :',
              g01align (glTransEntries_kb05 * sizeof (tkb05_ObjReqEntry)));
        (* ======================================================================================= *)
        ;
        (*---- RegionGlobList ----*)
        kb51vallocate (glRegions_kb05 * sizeof (tkb05_RegionGlobPtr), UnivAddr, t.trError_gg00);
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            glRegionGlob_kb05 := UnivAddr.uvRgnGlobPtrList_kb05;
            (*---- SupplyPoolGlob ----*)
            kb51vallocate (SPACE_BETWEEN_REGIONS_KB05, UnivAddr, t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                kb51vallocate (sizeof (tkb05_SupplyPoolGlob), UnivAddr, t.trError_gg00)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            glSupplyPoolGlob_kb05 := UnivAddr.uvSupplyPoolGlob_kb05;
            (*---- SupplySegmList ----*)
            kb51vallocate (glSupplyPoolSegments_kb05 * sizeof (tkb05_SupplySegmPtr),
                  UnivAddr, t.trError_gg00)
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            glSupplyPoolGlob_kb05^.poolSupplySegmList_kb05 := UnivAddr.uvSupplySegmPtrList_kb05;
            (*---- LockStateGlob ----*)
            kb51vallocate (SPACE_BETWEEN_REGIONS_KB05, UnivAddr, t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                kb51vallocate (sizeof (tkb05_LockStateGlob), UnivAddr, t.trError_gg00)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            glLockStateGlob_kb05 := UnivAddr.uvLockStateGlob_kb05;
            (*---- ObjCollGlob ----*)
            kb51vallocate (SPACE_BETWEEN_REGIONS_KB05, UnivAddr, t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                kb51vallocate (sizeof (tkb05_ObjCollGlob), UnivAddr, t.trError_gg00)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            glObjCollGlob_kb05 := UnivAddr.uvObjCollGlob_kb05;
            (*---- ObjCollList ----*)
            kb51vallocate (glTransEntries_kb05 * sizeof (tkb05_ObjCollisionEntry),
                  UnivAddr, t.trError_gg00)
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            glObjCollGlob_kb05^.oglObjCollList_kb05 := UnivAddr.uvObjCollList_kb05;
            (*---- ObjReqList ----*)
            kb51vallocate (glTransEntries_kb05 * sizeof (tkb05_ObjReqEntry),
                  UnivAddr, t.trError_gg00)
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            glObjCollGlob_kb05^.oglObjReqList_kb05 := UnivAddr.uvObjReqList_kb05;
            (*---- TransList ----*)
            kb51vallocate (SPACE_BETWEEN_REGIONS_KB05, UnivAddr, t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                kb51vallocate (glTransEntries_kb05 * sizeof (tkb05_TransEntryPtr),
                      UnivAddr, t.trError_gg00)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            glTransList_kb05 := UnivAddr.uvTransPtrList_kb05;
        (*ENDIF*) 
        ;
        CurrRegion := 1;
        WHILE (CurrRegion <= glRegions_kb05) AND (t.trError_gg00 = e_ok) DO
            BEGIN
            (*---- RegionGlob ----*)
            kb51vallocate (SPACE_BETWEEN_REGIONS_KB05, UnivAddr, t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                kb51vallocate (sizeof (tkb05_RegionGlob), UnivAddr, t.trError_gg00);
            (*ENDIF*) 
            IF  t.trError_gg00 = e_ok
            THEN
                BEGIN
                glRegionGlob_kb05^[CurrRegion] := UnivAddr.uvRegionGlob_kb05;
                (* *)
                ThisRegionGlob := glRegionGlob_kb05^[CurrRegion];
                (* *)
                ThisRegionGlob^.rglTransGlob_kb05   := NIL;
                ThisRegionGlob^.rglSupplyBlock_kb05 := NIL;
                ThisRegionGlob^.rglRowHash_kb05     := NIL;
                ThisRegionGlob^.rglTabHash_kb05     := NIL
                END;
            (*ENDIF*) 
            IF  t.trError_gg00 = e_ok
            THEN
                kb51vallocate (glSupplyItemsPerRegion_kb05 * sizeof (tkb05_SupplyItem),
                      UnivAddr, t.trError_gg00);
            (*ENDIF*) 
            IF  t.trError_gg00 = e_ok
            THEN
                ThisRegionGlob^.rglSupplyBlock_kb05 := UnivAddr.uvSupplyBlock_kb05;
            (*ENDIF*) 
            IF  (t.trError_gg00 = e_ok)
                AND
                (CurrRegion <= glTransRegions_kb05)
            THEN
                BEGIN
                (*---- TransGlob ----*)
                kb51vallocate (sizeof (tkb05_TransGlob), UnivAddr, t.trError_gg00);
                IF  t.trError_gg00 = e_ok
                THEN
                    BEGIN
                    ThisRegionGlob^.rglTransGlob_kb05 := UnivAddr.uvTransGlob_kb05;
                    (*---- TransEntry ----*)
                    kb51vallocate (glTransEntriesPerRegion_kb05 * sizeof(tkb05_TransEntry),
                          UnivAddr, t.trError_gg00);
                    IF  t.trError_gg00 = e_ok
                    THEN
                        BEGIN
                        OffsetFirstRgnTransIdx := (CurrRegion-1) * glTransEntriesPerRegion_kb05;
                        FOR i := 1 TO glTransEntriesPerRegion_kb05 DO
                            glTransList_kb05^[i + OffsetFirstRgnTransIdx] :=
                                  @UnivAddr.uvTransList_kb05^[i];
                        (*ENDFOR*) 
                        (*---- TransHash ----*)
                        kb51vallocate (
                              glTransHashEntriesPerRegion_kb05 * sizeof(tkb05_TransEntryPtr),
                              UnivAddr, t.trError_gg00)
                        END;
                    (*ENDIF*) 
                    IF  t.trError_gg00 = e_ok
                    THEN
                        ThisRegionGlob^.rglTransGlob_kb05^.trTransHash_kb05 :=
                              UnivAddr.uvTransPtrList_kb05
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (t.trError_gg00 = e_ok)
                AND
                (CurrRegion >  glTransRegions_kb05                    ) AND
                (CurrRegion <= glTransRegions_kb05 + glTabRegions_kb05)
            THEN
                BEGIN
                (*---- TabHash ----*)
                kb51vallocate (glTabHashEntriesPerRegion_kb05 * sizeof (tkb05_TabLockPtr),
                      UnivAddr, t.trError_gg00);
                IF  t.trError_gg00 = e_ok
                THEN
                    ThisRegionGlob^.rglTabHash_kb05 := UnivAddr.uvTabHash_kb05
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  (t.trError_gg00 = e_ok)
                AND
                (CurrRegion > glTransRegions_kb05 + glTabRegions_kb05)
            THEN
                BEGIN
                (*---- RowHash ----*)
                kb51vallocate (glRowHashEntriesPerRegion_kb05 * sizeof (tkb05_RowLockPtr),
                      UnivAddr, t.trError_gg00);
                IF  t.trError_gg00 = e_ok
                THEN
                    ThisRegionGlob^.rglRowHash_kb05 := UnivAddr.uvRowHash_kb05
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            CurrRegion := CurrRegion + 1
            END;
        (*ENDWHILE*) 
        ;
        i := 1;
        WHILE (i <= glSupplyPoolSegments_kb05) AND (t.trError_gg00 = e_ok) DO
            BEGIN
            (*---- SupplySegment ----*)
            kb51vallocate (SPACE_BETWEEN_REGIONS_KB05, UnivAddr, t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                kb51vallocate (sizeof (tkb05_SupplySegment), UnivAddr, t.trError_gg00);
            (*ENDIF*) 
            IF  t.trError_gg00 = e_ok
            THEN
                glSupplyPoolGlob_kb05^.poolSupplySegmList_kb05^[i] := UnivAddr.uvSupplySegm_kb05;
            (*ENDIF*) 
            i := i + 1
            END
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
    kb511InitRWConsistLocks; (* PTS 1126629 FF 2003-12-22 *)
    k501InitOMSShareLocks;   (* PTS 1128244 FF 2004-03-18 *)
    k512MonInit;             (* PTS 1130956 FF 2004-08-19 *)
    bd91InitRWRecreateIndex; (* PTS 1134645 FF 2005-04-06 *)
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    WITH k51glob DO
        BEGIN
        WITH glSupplyPoolGlob_kb05^ DO
            BEGIN
            poolFirstFreeSegm_kb05   := poolSupplySegmList_kb05^[1];
            (* *)
            poolFreeSegments_kb05    := glSupplyPoolSegments_kb05;
            poolMinFreeSegms_kb05    := glSupplyPoolSegments_kb05;
            (* *)
            poolFiller1_kb05         := 0;
            gg06SetNilTrans (poolMinOpenTransId_kb05  );
            gg06SetNilTrans (poolMinConsistViewNo_kb05);
            gg06SetNilTrans (poolMinNonVersOpTrId_kb05);  (* PTS 1130354 FF 2004-06-28*)
            gg06SetNilTrans (poolMinNonVersCSVNo_kb05);   (* PTS 1130354 FF 2004-06-28*)
            (* *)
            poolSegmsUsedAmount_kb05 := 0;
            (* *)
            poolItemsUsedAmount_kb05 := 0;
            (* *)
            poolAmountPoints_kb05    := 0;
            (* *)
            poolEmptyWarning_kb05    := false;
            poolFiller2_kb05         := false;
            poolMinOpenIdx_kb05      := -1;
            poolOwnRegionId_kb05     := g08lockpool;
            gg06SetNilTrans (poolMinNonVersCSVNo_kb05);     (* PTS 1130354 FF 2004-06-28*)
            (* *)
            FOR i := 1 TO glSupplyPoolSegments_kb05 - 1 DO
                poolSupplySegmList_kb05^[i]^.sgmNext_kb05 := poolSupplySegmList_kb05^[i+1];
            (*ENDFOR*) 
            poolSupplySegmList_kb05^[glSupplyPoolSegments_kb05]^.sgmNext_kb05 := NIL
            END;
        (*ENDWITH*) 
        ;
        WITH glLockStateGlob_kb05^ DO
            BEGIN
            lglTimeLastClear_kb05    := 0;
            lglOwnRegionId_kb05      := g08lockinit;
            END;
        (*ENDWITH*) 
        ;
        WITH glObjCollGlob_kb05^ DO
            BEGIN
            oglObjCollFirstFree_kb05 := 1; (* first entry of ObjCollList *)
            oglObjCollFreeCnt_kb05   := glTransEntries_kb05;
            oglObjReqCnt_kb05        := 0;
            oglFiller1_kb05          := 0;
            (* *)
            oglFiller2_kb05          := 0;
            oglOwnRegionId_kb05      := g08lockwait;
            (* *)
            oglCollisions_kb05       := 0;
            (* *)
            FOR i := 1 TO glTransEntries_kb05 DO
                BEGIN
                WITH oglObjCollList_kb05^[i] DO
                    BEGIN
                    objcOwnIndex_kb05       := i;
                    objcFirstReq_kb05       := cgg_nil_transindex;
                    objcNextCollLock_kb05   := cgg_nil_transindex;
                    objcPrevCollLock_kb05   := cgg_nil_transindex;
                    (* *)
                    gg06SetNilTrans (objcLockTransId_kb05);
                    objcLockTransIndex_kb05 := cgg_nil_transindex;
                    (* *)
                    gg06SetNilOid (objcOid_kb05);
                    (* *)
                    IF  i < glTransEntries_kb05
                    THEN
                        objcNextCollLock_kb05 := objcOwnIndex_kb05 + 1
                    (*ENDIF*) 
                    END;
                (*ENDWITH*) 
                WITH oglObjReqList_kb05^[i] DO
                    BEGIN
                    gg06SetNilTrans (objrReqTransId_kb05);
                    objrOwnIndex_kb05       := i;
                    (* *)
                    objrCollEntryIndex_kb05 := cgg_nil_transindex;
                    objrNextReq_kb05        := cgg_nil_transindex;
                    objrWaitTaskId_kb05     := cgg_nil_pid;
                    END
                (*ENDWITH*) 
                END
            (*ENDFOR*) 
            END;
        (*ENDWITH*) 
        ;
        FOR CurrRegion := 1 TO glRegions_kb05 DO
            WITH glRegionGlob_kb05^[CurrRegion]^ DO
                BEGIN
                rglFirstConsistView_kb05 := NIL;
                rglFirstFree_kb05        := @rglSupplyBlock_kb05^[1];
                rglCancelConsView_kb05   := NIL;             (* PTS 1120151 FF 2003-01-29 *)
                (* *)
                rglExtentFirstSegm_kb05  := NIL;
                rglExtentFirstFree_kb05  := NIL;
                (* *)
                rglOwnRegion_kb05        := CurrRegion;
                rglFiller1_kb05          := 0;
                rglFreeItems_kb05        := glSupplyItemsPerRegion_kb05;
                (* *)
                rglExtentItems_kb05      := 0;
                rglExtentFreeItems_kb05  := 0;
                (* *)
                rglConsistViewCnt_kb05   := 0;
                rglCancelCsViewCnt_kb05  := 0;               (* PTS 1120151 FF 2003-01-29 *)
                rglOpenTransCnt_kb05     := 0;
                (* *)
                gg06SetNilTrans (rglMinOpenTransId_kb05  );
                gg06SetNilTrans (rglMinConsistViewNo_kb05);
                gg06SetNilTrans (rglMinNonVersOpTrId_kb05);  (* PTS 1130354 FF 2004-06-28*)
                gg06SetNilTrans (rglMinNonVersCSVNo_kb05);   (* PTS 1130354 FF 2004-06-28*)
                (* *)
                rglCollisions_kb05       := 0;
                (* *)
                IF  rglRowHash_kb05 <> NIL
                THEN
                    FOR i := 1 TO glRowHashEntriesPerRegion_kb05 DO  (* PTS 1107137 JA 2000-07-06 *)
                        rglRowHash_kb05^[i] := NIL;
                    (*ENDFOR*) 
                (*ENDIF*) 
                IF  rglTabHash_kb05 <> NIL
                THEN
                    FOR i := 1 TO glTabHashEntriesPerRegion_kb05 DO
                        rglTabHash_kb05^[i] := NIL;
                    (*ENDFOR*) 
                (*ENDIF*) 
                FOR i := 1 TO glSupplyItemsPerRegion_kb05 DO
                    WITH rglSupplyBlock_kb05^[i] DO
                        BEGIN
                        siItemKind_kb05      := ikFree_ekb05;
                        siExtentItem_kb05    := false;
                        siChkOwnRegion_kb05  := NIL_REGION_KB05;
                        siChkTransIndex_kb05 := cgg_nil_transindex;
                        siChkTaskId_kb05     := cgg_nil_pid;
                        IF  i < glSupplyItemsPerRegion_kb05
                        THEN
                            siNext_kb05 := @rglSupplyBlock_kb05^[i+1]
                        ELSE
                            siNext_kb05 := NIL
                        (*ENDIF*) 
                        END
                    (*ENDWITH*) 
                (*ENDFOR*) 
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
        ;
        FOR CurrRegion := 1 TO glTransRegions_kb05 DO
            WITH glRegionGlob_kb05^[CurrRegion]^.rglTransGlob_kb05^ DO
                BEGIN
                OffsetFirstRgnTransIdx := (CurrRegion-1) * glTransEntriesPerRegion_kb05;
                (* *)
                trFirst_kb05           := NIL;
                trFirstFree_kb05       := glTransList_kb05^[OffsetFirstRgnTransIdx + 1];
                (* *)
                trFreeEntries_kb05     := glTransEntriesPerRegion_kb05;
                trConnectOnlyCnt_kb05  := 0;
                trLockTransCnt_kb05    := 0;
                trReqTransCnt_kb05     := 0;
                (* *)
                trObjLockTransCnt_kb05 := 0;
                trOwnRegion_kb05       := CurrRegion;
                trFiller1_kb05  := cgg_nil_pid;
                (* *)
                trRowEntryAmount_kb05  := 0;
                trTabEntryAmount_kb05  := 0;
                trSqlReqTimeouts_kb05  := 0;
                trObjReqTimeouts_kb05  := 0;
                trDeadlocks_kb05       := 0;
                trEscalations_kb05     := 0;
                (* *)
                FOR i := 1 TO glTransHashEntriesPerRegion_kb05 DO
                    trTransHash_kb05^[i] := NIL;
                (*ENDFOR*) 
                FOR i := 1 TO glTransEntriesPerRegion_kb05 DO
                    BEGIN
                    ThisTrans  := glTransList_kb05^[OffsetFirstRgnTransIdx + i];
                    ThisTrans^ := glNilTransEntry_kb05;
                    (* *)
                    ThisTrans^.teOwnRegion_kb05 := CurrRegion;
                    ThisTrans^.teOwnAddr_kb05   := ThisTrans;
                    ThisTrans^.teOwnIndex_kb05  := OffsetFirstRgnTransIdx + i;
                    ThisTrans^.teState_kb05     := m_delete; (* free indicator *)
                    IF  i < glTransEntriesPerRegion_kb05
                    THEN
                        ThisTrans^.teNextTrans_kb05 :=
                              glTransList_kb05^[ThisTrans^.teOwnIndex_kb05 +1]
                    ELSE
                        ThisTrans^.teNextTrans_kb05 := NIL
                    (*ENDIF*) 
                    END
                (*ENDFOR*) 
                END;
            (*ENDWITH*) 
        (*ENDFOR*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    k51glob.glGenerated_kb05 := true;
(*ENDIF*) 
vendexcl (t.trTaskId_gg00, g08lockinit);
&ifdef TRACE
t01basis_error (kb_lock, 'end restart ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51row_excl_check (
            VAR t     : tgg00_TransContext;
            VAR TabId : tgg00_Surrogate;
            VAR k     : tgg00_Lkey);
 
VAR
      Locked       : boolean;
      DummyPrevTab : tkb05_TabTransPtr;
      DummyPrevRow : tkb05_RowTransPtr;
      Row          : tkb05_RowTransPtr;
      Tab          : tkb05_TabTransPtr;
      ThisTrans    : tkb05_TransEntryPtr;
      WantedLock   : tkb05_WantedLock;
 
BEGIN
t.trError_gg00 := e_ok;
Locked         := false;
Row            := NIL;
Tab            := NIL;
ThisTrans      := NIL;
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex
ELSE
    BEGIN
    k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-09-15 *)
    THEN
        g01check (kb51cWrongTransindex_csp03, csp3_n_lock,
              'k51row_exc: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND (ThisTrans <> NIL)
THEN
    BEGIN
    IF  (ThisTrans^.teLockMode_kb05 = tlmExcl_ekb05   ) OR
        (ThisTrans^.teLockMode_kb05 = tlmEotExcl_ekb05)
    THEN
        BEGIN
        kb51tabid_search (ThisTrans, TabId, Tab, DummyPrevTab);
        IF  Tab <> NIL
        THEN
            BEGIN
            Locked := (Tab^.ttLockMode_kb05 = lckSysExcl_egg00)
                  OR  (Tab^.ttLockMode_kb05 = lckTabExcl_egg00);
            IF  NOT Locked AND (Tab^.ttRowExclLocks_kb05 > 0)
            THEN
                BEGIN
                k50init_wanted_rowid_lock (k.k, sizeof (k.k), 1, k.len, WantedLock, t.trError_gg00);
                kb51rowid_search (ThisTrans, Tab, WantedLock, Row, DummyPrevRow);
                IF  Row <> NIL
                THEN
                    BEGIN
                    Locked := (Row^.rtLockMode_kb05 = lckRowExcl_egg00);
&                   ifdef UWE
                    IF  Locked
                        AND
                        (Row^.rtReqState_kb05 = ForInsert)
                        AND
                        (WantedLock.Mode_ekb05 = sharelock)
                    THEN
                        Locked := false;
&                   endif
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND NOT Locked
THEN
    t.trError_gg00 := e_rec_not_locked;
(*ENDIF*) 
;
&ifdef TRACE
t01basis_error (kb_lock, 'excl check  ', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51set_not_generated;
 
BEGIN
(* outside Lock Region *)
k51glob.glGenerated_kb05 := false
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51set_userid (
            VAR t          : tgg00_TransContext;
            VAR UserId     : tgg00_UserId;
            VAR TermId     : tsp00_TermId;
            IsExclusive    : boolean;
            IsNologSession : boolean);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
&ifdef TRACE
t01c4int (kb_lock, 'UserId      ', UserId);
t01name1 (kb_lock, 'TermId      ', TermId);
&endif
t.trError_gg00 := e_ok;
ThisTrans      := NIL;
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex
ELSE
    (* check outside Trans Region *)
    kb51cancel_and_log_full_check (t, ThisTrans);
(*ENDIF*) 
;
IF  (t.trError_gg00 = e_ok) AND (ThisTrans <> NIL)
THEN
    BEGIN
    vbegexcl (t.trTaskId_gg00, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    WITH ThisTrans^ DO
        BEGIN
        teUserId_kb05 := UserId;
        teTermId_kb05 := TermId;
        teInfo_kb05   := teInfo_kb05 + [tiUserTask_ekb05];
        IF  IsExclusive
        THEN
            teInfo_kb05 := teInfo_kb05 + [tiExclusiveUser_ekb05];
        (*ENDIF*) 
        a11put_date_time (teStartDate_kb05, teStartTime_kb05);
        END;
    (*ENDWITH*) 
    k52flush_trans_entry (ThisTrans^);
    vendexcl (t.trTaskId_gg00, g08lock0 + ThisTrans^.teOwnRegion_kb05)
    END;
(*ENDIF*) 
;
&ifdef TRACE
t01int4 (kb_lock, 't.trIndex   ', t.trIndex_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51StartConsistTrans (VAR Trans : tgg00_TransContext;
            omsVersion : boolean  );
 
VAR
      EntryFound        : boolean;
      CurrTransRegion   : tkb05_RegionNo;
      ConsistRegion     : tkb05_RegionNo;
      ConsistHash       : tsp00_Int4;
      TransCnt          : tsp00_Int4;
      MinOpenTrans      : tgg91_TransNo;
      MinOpen           : tgg91_TransNo;       (* PTS 1105568 JA 2000-02-10 *)
      MinConsist        : tgg91_TransNo;       (* PTS 1105568 JA 2000-02-10 *)
      MinNonVersOpen    : tgg91_TransNo;       (* PTS 1130354 FF 2004-06-25 *)
      MinNonVersConsist : tgg91_TransNo;       (* PTS 1130354 FF 2004-06-25 *)
      ConsistTabId      : tkb05_SurrogateTransId;
      ConsistRgnGlobPtr : tkb05_RegionGlobPtr;
      CurrTrans         : tkb05_TransEntryPtr;
      PrevTab           : tkb05_TabLockPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
      ThisConsistView   : tkb05_ConsistViewPtr;
      ThisTrans         : tkb05_TransEntryPtr;
      TransRgnGlobPtr   : tkb05_RegionGlobPtr;
      UnivConsistView   : tkb05_UnivItemPtr;
      ClockMSecs        : tsp00_Int4;          (* PTS 1122577 FF *)
 
BEGIN
&ifdef TRACE
t01trans (kb_lock, 'consist_trns', Trans);
&endif
Trans.trError_gg00 := e_ok;
ThisTrans          := NIL;
ThisConsistView    := NIL;
gg06SetNilTrans (MinOpenTrans);
kb51EnableHistoryRetention;  (* PTS 1140529 FF 2006-03-09 *)
IF  Trans.trIndex_gg00 = cgg_nil_transindex
THEN
    Trans.trError_gg00 := e_nil_transindex
ELSE
    (* check outside Trans Region *)
    kb51cancel_and_log_full_check (Trans, ThisTrans);
(*ENDIF*) 
IF  (Trans.trError_gg00 = e_ok) AND (ThisTrans <> NIL)
THEN
    (* insert consistent trans *)
    BEGIN
    IF  NOT gg06IsNilTrans (Trans.trConsistView_gg00)
    THEN
        kb51DelConsistTrans (Trans.trTaskId_gg00, Trans.trConsistView_gg00);
    (*ENDIF*) 
    ;
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    (* vbegexcl (Trans.trTaskId_gg00, g08cnstview);               * PTS 1122885 FF 2003-07-01 *)
    kb511EnterConsistView1 (Trans.trTaskId_gg00, false );         (* PTS 1122885 FF 2003-07-01 *)
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    ;
    (*                                                  without ObjSeq: PTS 1105435 JA 2000-02-01 *)
    k57new_write_trans (Trans.trTaskId_gg00, Trans.trConsistView_gg00);
    WITH ConsistTabId DO
        BEGIN
        surrId_kb05      := CONSIST_TRANS_PREFIX_GG00;
        surrTransId_kb05 := Trans.trConsistView_gg00;
        MinOpenTrans     := Trans.trConsistView_gg00
        END;
    (*ENDWITH*) 
    kb51tab_hash (ConsistTabId.surrId_kb05, ConsistHash, ConsistRegion);
    k52begexcl_region (Trans.trTaskId_gg00, ConsistRegion, ConsistRgnGlobPtr);
    kb51tablock_search (ConsistRgnGlobPtr^, ConsistTabId.surrId_kb05, ConsistHash,
          UnivConsistView.uiTabLock_kb05, PrevTab, EntryFound);
    IF  NOT EntryFound
    THEN
        BEGIN
        kb51new_tablock (Trans, ConsistRgnGlobPtr^, ConsistHash, PrevTab,
              UnivConsistView.uiTabLock_kb05);
        IF  Trans.trError_gg00 = e_ok
        THEN
            WITH ConsistRgnGlobPtr^ DO
                rglConsistViewCnt_kb05 := rglConsistViewCnt_kb05 + 1
            (*ENDWITH*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  Trans.trError_gg00 = e_ok
    THEN
        BEGIN
        ThisConsistView := UnivConsistView.uiConsistView_kb05;
        (* *)
        ThisConsistView^.cstItemKind_kb05        := ikConsistView_ekb05;
        ThisConsistView^.cstConsistViewNo_kb05   := ConsistTabId;
        (* *)
        (* cstNextHashTab already set by kb51new_tablock *)
        ThisConsistView^.cstNextConsistView_kb05  := ConsistRgnGlobPtr^.rglFirstConsistView_kb05;
        (* *)
        ThisConsistView^.cstPrevConsistView_kb05 := NIL;
        ThisConsistView^.cstFirstOpenTrans_kb05  := NIL;
        (* *)
        a11put_date_time (ThisConsistView^.cstStartDate_kb05, ThisConsistView^.cstStartTime_kb05);
        vclock (ThisConsistView^.cstStartClockstamp_kb05, ClockMSecs); (* PTS 1122577 FF *)
        (* *)
        ThisConsistView^.cstTimeLastUsed_kb05    := 0;
        ThisConsistView^.cstCancelled_kb05       := false;    (* PTS 1120151 FF 2003-01-29 *)
        ThisConsistView^.cstInWork_kb05          := false;    (* PTS 1120151 FF 2003-01-29 *)
        ThisConsistView^.cstCreatorTransId_kb05  := Trans.trTransId_gg00; (* PTS 1125503 FF 2003-11-19 *)
        (* *)
        ThisConsistView^.cstMinOpenTransId_kb05  := MinOpenTrans;
        ThisConsistView^.cstCurrTransIndex_kb05  := Trans.trIndex_gg00;
        ThisConsistView^.cstOmsVersion_kb05      := omsVersion; (* PTS 1130354 FF 2004-06-25 *)
        (* *)
        IF  ThisConsistView^.cstNextConsistView_kb05 <> NIL
        THEN
            ThisConsistView^.cstNextConsistView_kb05^.cstPrevConsistView_kb05 := ThisConsistView;
        (*ENDIF*) 
        ConsistRgnGlobPtr^.rglFirstConsistView_kb05 := ThisConsistView;
        ThisTrans^.teConsistView_kb05               := ThisConsistView;
        k52flush_consist_view (ThisConsistView^);
        IF  Trans.trError_gg00 = e_ok
        THEN
            k512MonRestartTransaction(ThisTrans^.teExtTransMonPtr_kb05);
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    k52endexcl_region (Trans.trTaskId_gg00, ConsistRgnGlobPtr);
    ;
    CurrTransRegion := 1;
    WHILE (Trans.trError_gg00 =  e_ok)
          AND
          (ThisConsistView <> NIL ) AND (CurrTransRegion <= k51glob.glTransRegions_kb05) DO
        BEGIN
        k52begexcl_region (Trans.trTaskId_gg00, CurrTransRegion, TransRgnGlobPtr);
        CurrTrans := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
        TransCnt  := 0;
        WHILE (Trans.trError_gg00 = e_ok) AND (CurrTrans <> NIL)
              AND
              (TransCnt <= k51glob.glTransEntriesPerRegion_kb05) DO
            BEGIN
            IF  NOT gg06IsNilTrans (CurrTrans^.teWriteTransId_kb05) AND (* PTS 1105435 JA 2000-02-01 *)
                (* PTS 1122885 FF 2003-07-01 *)
                (CurrTrans^.teWriteTransId_kb05.ci6_gg00 < Trans.trConsistView_gg00.ci6_gg00 )
            THEN
                (* insert every open valid trans entry           *)
                (* own entry is used for garbage collection only *)
                BEGIN
                k52begexcl_region (Trans.trTaskId_gg00, ConsistRegion, ConsistRgnGlobPtr);
                kb51append_trans_to_open_list (Trans, ConsistRgnGlobPtr^,
                      ThisConsistView^, CurrTrans^.teWriteTransId_kb05);
                kb51min_transid_assign (MinOpenTrans, CurrTrans^.teWriteTransId_kb05);
                k52endexcl_region (Trans.trTaskId_gg00, ConsistRgnGlobPtr)
                END;
            (*ENDIF*) 
            TransCnt  := TransCnt + 1;
            CurrTrans := CurrTrans^.teNextTrans_kb05
            END;
        (*ENDWHILE*) 
        k52endexcl_region (Trans.trTaskId_gg00, TransRgnGlobPtr);
        IF  TransCnt > k51glob.glTransEntriesPerRegion_kb05
        THEN
            k52x_loop_error ('k51start_consist_trans  ', 1);
        (*ENDIF*) 
        CurrTransRegion := CurrTransRegion + 1
        END;
    (*ENDWHILE*) 
    ;
    (* endexcl g08cnstview moved to the end of procedure                PTS 1105568 JA 2000-02-10 *)
    IF  (Trans.trError_gg00 = e_ok) AND (ThisConsistView <> NIL)
    THEN
        BEGIN
        k52begexcl_region (Trans.trTaskId_gg00, ConsistRegion, ConsistRgnGlobPtr);
        ThisConsistView^.cstMinOpenTransId_kb05 := MinOpenTrans;
        WITH ConsistRgnGlobPtr^ DO
            BEGIN
            MinOpen           := rglMinOpenTransId_kb05;                    (* PTS 1105568 JA 2000-02-10 *)
            MinNonVersOpen    := rglMinNonVersOpTrId_kb05;                  (* PTS 1130354 FF 2004-06-25 *)
            MinConsist        := rglMinConsistViewNo_kb05;                  (* PTS 1105568 JA 2000-02-10 *)
            MinNonVersConsist := rglMinNonVersCSVNo_kb05;                   (* PTS 1130354 FF 2004-06-25 *)
            kb51min_transid_assign (rglMinOpenTransId_kb05, MinOpenTrans);
            kb51min_transid_assign (rglMinConsistViewNo_kb05,
                  ThisConsistView^.cstConsistViewNo_kb05.surrTransId_kb05);
            IF  NOT ThisConsistView^.cstOmsVersion_kb05              (* PTS 1130354 FF 2004-06-25 *)
            THEN
                BEGIN
                kb51min_transid_assign (rglMinNonVersOpTrId_kb05, MinOpenTrans);
                kb51min_transid_assign (rglMinNonVersCSVNo_kb05,
                      ThisConsistView^.cstConsistViewNo_kb05.surrTransId_kb05);
                END;
            (**)
            (*ENDIF*) 
            IF  (MinOpen           <> rglMinOpenTransId_kb05  ) OR    (* PTS 1105568 JA 2000-02-10 *)
                (MinNonVersOpen    <> rglMinNonVersOpTrId_kb05) OR    (* PTS 1130354 FF 2004-06-25 *)
                (MinConsist        <> rglMinConsistViewNo_kb05) OR
                (MinNonVersConsist <> rglMinNonVersCSVNo_kb05)        (* PTS 1130354 FF 2004-06-25 *)
            THEN
                (* PTS 1105568 JA 2000-02-10 *)
                BEGIN
                k52begexcl_supply_pool (Trans.trTaskId_gg00, SupplyPoolGlobPtr);
                kb51min_transid_assign
                      (SupplyPoolGlobPtr^.poolMinOpenTransId_kb05,   rglMinOpenTransId_kb05);
                kb51min_transid_assign
                      (SupplyPoolGlobPtr^.poolMinConsistViewNo_kb05, rglMinConsistViewNo_kb05);
                kb51min_transid_assign                               (* PTS 1130354 FF 2004-06-25 *)
                      (SupplyPoolGlobPtr^.poolMinNonVersOpTrId_kb05, rglMinNonVersOpTrId_kb05);
                kb51min_transid_assign                               (* PTS 1130354 FF 2004-06-25 *)
                      (SupplyPoolGlobPtr^.poolMinNonVersCSVNo_kb05, rglMinNonVersCSVNo_kb05);
                k52endexcl_supply_pool (Trans.trTaskId_gg00, SupplyPoolGlobPtr)
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        k52endexcl_region (Trans.trTaskId_gg00, ConsistRgnGlobPtr)
        END;
    (*ENDIF*) 
    IF  (Trans.trError_gg00 = e_ok) AND (ThisConsistView <> NIL)
    THEN
        kb51ins_hash_open_trans (Trans, ThisConsistView^);
    (*ENDIF*) 
    ;
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    (* vendexcl (Trans.trTaskId_gg00, g08cnstview);                  * PTS 1122885 FF 2003-07-01 *)
    kb511LeaveConsistView1 (Trans.trTaskId_gg00, false );            (* PTS 1122885 FF 2003-07-01 *)
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    END;
(*ENDIF*) 
IF  Trans.trError_gg00 = e_too_many_lock_requests
THEN
    kb51abort_list_overflow (Trans.trIndex_gg00);
(*ENDIF*) 
;
&ifdef TRACE
t01basis_error (kb_lock, 'end check_in', Trans.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51append_trans_to_open_list (
            VAR Trans             : tgg00_TransContext;
            VAR ConsistRegionGlob : tkb05_RegionGlob;
            VAR ConsistView       : tkb05_ConsistView;
            VAR OpenTransId       : tgg91_TransNo);
 
VAR
      NewEntryWanted : boolean;
      UnivOpenTrans  : tkb05_UnivItemPtr;
 
BEGIN
Trans.trError_gg00 := e_ok;
IF  kb03Check.chkRegion_kb00
THEN
    g08excl_check (Trans.trTaskId_gg00, g08lock0 + ConsistRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
IF  ConsistView.cstFirstOpenTrans_kb05 = NIL
THEN
    NewEntryWanted := true
ELSE
    NewEntryWanted :=
          ConsistView.cstFirstOpenTrans_kb05^.openCount_kb05 >= TRANS_PER_OPEN_ENTRY_KB05;
(*ENDIF*) 
IF  NewEntryWanted
THEN
    BEGIN
    kb51get_supply_item (Trans, ConsistRegionGlob, ikOpenTrans_ekb05, UnivOpenTrans);
    IF  Trans.trError_gg00 = e_ok
    THEN
        BEGIN
        UnivOpenTrans.uiOpenTrans_kb05^.openNext_kb05 := ConsistView.cstFirstOpenTrans_kb05;
        ConsistView.cstFirstOpenTrans_kb05            := UnivOpenTrans.uiOpenTrans_kb05;
        ConsistRegionGlob.rglOpenTransCnt_kb05        := ConsistRegionGlob.rglOpenTransCnt_kb05 + 1
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  Trans.trError_gg00 = e_ok
THEN
    WITH ConsistView.cstFirstOpenTrans_kb05^ DO
        BEGIN
        openCount_kb05 := openCount_kb05 + 1;
        openTransId_kb05 [openCount_kb05] := OpenTransId
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51ins_hash_open_trans (
            VAR Trans       : tgg00_TransContext;
            VAR ConsistView : tkb05_ConsistView);
 
VAR
      HashTransExists : boolean;
      OpenEntryCnt    : tsp00_Int4;
      HashValue       : tsp00_Int4;
      CurrOpenIndex   : integer;
      CurrOpenEntry   : tkb05_OpenTransPtr;
      HashRgnGlobPtr  : tkb05_RegionGlobPtr;
      PrevTab         : tkb05_TabLockPtr;
      UnivHashTrans   : tkb05_UnivItemPtr;
      WantedSurrogate : tkb05_SurrogateTransId;
 
BEGIN
(* outside TransRegion and ConsistRegion *)
CurrOpenEntry := ConsistView.cstFirstOpenTrans_kb05;
OpenEntryCnt  := 0;
WHILE (Trans.trError_gg00 = e_ok)
      AND
      (CurrOpenEntry <> NIL) AND (OpenEntryCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
    BEGIN
    CurrOpenIndex := 1;
    WHILE (Trans.trError_gg00 = e_ok) AND (CurrOpenIndex <= CurrOpenEntry^.openCount_kb05)
          AND
          (CurrOpenIndex <= TRANS_PER_OPEN_ENTRY_KB05) (* security *) DO
        BEGIN
        WantedSurrogate.surrId_kb05        := OPEN_TRANS_PREFIX_GG00;
        WantedSurrogate.surrTransId_kb05   := CurrOpenEntry^.openTransId_kb05 [CurrOpenIndex];
        UnivHashTrans.uiHashOpenTrans_kb05 := NIL;
        PrevTab                            := NIL;
        kb51tab_hash (WantedSurrogate.surrId_kb05,
              HashValue, CurrOpenEntry^.openHashRegion_kb05 [CurrOpenIndex]);
        k52begexcl_region (Trans.trTaskId_gg00,
              CurrOpenEntry^.openHashRegion_kb05 [CurrOpenIndex], HashRgnGlobPtr);
        kb51tablock_search (HashRgnGlobPtr^, WantedSurrogate.surrId_kb05, HashValue,
              UnivHashTrans.uiTabLock_kb05, PrevTab, HashTransExists);
        IF  HashTransExists
        THEN
            WITH UnivHashTrans.uiHashOpenTrans_kb05^ DO
                hshUsedCnt_kb05 := hshUsedCnt_kb05 + 1
            (*ENDWITH*) 
        ELSE
            BEGIN
            kb51new_tablock (Trans, HashRgnGlobPtr^, HashValue,
                  PrevTab, UnivHashTrans.uiTabLock_kb05);
            IF  Trans.trError_gg00 = e_ok
            THEN
                WITH UnivHashTrans.uiHashOpenTrans_kb05^ DO
                    BEGIN
                    hshItemKind_kb05     := ikHashOpenTrans_ekb05;
                    hshTransId_kb05      := WantedSurrogate;
                    (* hshNextHashTab       already set by kb51new_tablock *)
                    hshUsedCnt_kb05      := 1;
                    hshOwnHashValue_kb05 := HashValue
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  Trans.trError_gg00 = e_ok
        THEN
            k52flush_hash_open_trans (UnivHashTrans.uiHashOpenTrans_kb05^);
        (*ENDIF*) 
        k52endexcl_region (Trans.trTaskId_gg00, HashRgnGlobPtr);
        CurrOpenEntry^.openOwnHashTrans_kb05 [CurrOpenIndex] := UnivHashTrans.uiHashOpenTrans_kb05;
        CurrOpenIndex := CurrOpenIndex + 1
        END;
    (*ENDWHILE*) 
    OpenEntryCnt  := OpenEntryCnt + 1;
    CurrOpenEntry := CurrOpenEntry^.openNext_kb05
    END;
(*ENDWHILE*) 
IF  OpenEntryCnt > k51glob.glMaxItemsPerRegion_kb05
THEN
    k52x_loop_error ('k51start_consist_trans  ', 2)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51sys_share_remove (
            TaskId                : tsp00_TaskId;
            TransIndex            : tgg00_TransIndex;
            VAR TransState        : tgg00_TransState);
 
VAR
      ItemCnt    : tsp00_Int4;
      NextTab    : tkb05_TabTransPtr;
      CurrTab    : tkb05_TabTransPtr;
      ThisTrans  : tkb05_TransEntryPtr;
      WantedLock : tkb05_WantedLock;
 
BEGIN
(* PTS 1103526 JA 1999-09-03 *)
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  ThisTrans <> NIL
    THEN
        BEGIN
        CurrTab := ThisTrans^.teFirstTab_kb05;
        ItemCnt := 0;
        WHILE (CurrTab <> NIL) AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
            BEGIN
            IF  CurrTab^.ttItemKind_kb05 <> ikTabTrans_ekb05
            THEN
                k52x_item_error ('k51sys_share_remove     ', CurrTab^.ttItemKind_kb05);
            (*ENDIF*) 
            NextTab := CurrTab^.ttNextTab_kb05;
            IF  CurrTab^.ttLockMode_kb05 = lckSysShare_egg00
            THEN
                BEGIN
                k51init_wanted_lock (WantedLock);
                WantedLock.wlTabId_kb05 := CurrTab^.ttTabId_kb05;
                WantedLock.wlMode_kb05  := lckSysShare_egg00;
                k51unlock (TaskId, TransIndex, TransState, WantedLock)
                END;
            (*ENDIF*) 
            ItemCnt := ItemCnt + 1;
            CurrTab := NextTab
            END;
        (*ENDWHILE*) 
        IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
        THEN
            k52x_loop_error ('k51sys_share_remove     ', 1)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51tab_eot_excl_check (
            VAR t     : tgg00_TransContext;
            VAR TabId : tgg00_Surrogate);
 
VAR
      EotLocked    : boolean;
      DummyPrevTab : tkb05_TabTransPtr;
      Tab          : tkb05_TabTransPtr;
      ThisTrans    : tkb05_TransEntryPtr;
 
BEGIN
t.trError_gg00 := e_ok;
EotLocked      := false;
Tab            := NIL;
ThisTrans      := NIL;
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex
ELSE
    BEGIN
    k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-09-15 *)
    THEN
        g01check (kb51cWrongTransindex_csp03, csp3_n_lock,
              'k51tab_eot: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND (ThisTrans <> NIL)
THEN
    BEGIN
    IF  ThisTrans^.teLockMode_kb05 = tlmEotExcl_ekb05
    THEN
        BEGIN
        kb51tabid_search (ThisTrans, TabId, Tab, DummyPrevTab);
        IF  Tab <> NIL
        THEN
            EotLocked :=
                  ((Tab^.ttLockMode_kb05 = lckSysExcl_egg00) OR
                  ( Tab^.ttLockMode_kb05 = lckTabExcl_egg00))
                  AND
                  (lrsEotExcl_egg00 in Tab^.ttLockState_kb05)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND NOT EotLocked
THEN
    t.trError_gg00 := e_rec_not_locked;
(*ENDIF*) 
;
&ifdef TRACE
t01basis_error (kb_lock, 'eotexcl chck', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51temp_tab_share_unlock (
            VAR t           : tgg00_TransContext;
            VAR WantedTabid : tgg00_Surrogate);
 
VAR
      Tab             : tkb05_TabTransPtr;
      DummyPrev       : tkb05_TabTransPtr;
      ThisTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
&ifdef TRACE
t01surrogate (kb_lock, 'unlock_tabid', WantedTabid);
&endif
t.trError_gg00 := e_ok;
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex
ELSE
    BEGIN
    k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-09-15 *)
    THEN
        g01check (kb51cWrongTransindex_csp03, csp3_n_lock,
              'k51temp_ta: bad trIndex ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND (ThisTrans <> NIL)
THEN
    BEGIN
    kb51tabid_search (ThisTrans, WantedTabid, Tab, DummyPrev);
    IF  Tab <> NIL
    THEN
        BEGIN
&       ifdef TRACE
        k52xtab_trans (kb_lockentry, Tab);
&       endif
        IF  (Tab^.ttLockMode_kb05 = lckTabShare_egg00) AND
            (lrsTemp_egg00 in Tab^.ttLockState_kb05)
        THEN
            BEGIN
            k52begexcl_region (t.trTaskId_gg00, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
            kb51tab_remove (t.trTaskId_gg00, TransRgnGlobPtr^, ThisTrans, Tab);
            k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
            IF  ThisTrans^.teLockMode_kb05 = tlmFree_ekb05
            THEN
                t.trState_gg00 := t.trState_gg00 - [tsLocked_egg00]
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      k51tr_index_region (TransIndex : tgg00_TransIndex) : tkb05_RegionNo;
 
BEGIN
(* outside Region *)
IF  TransIndex > k51glob.glTransEntries_kb05
THEN
    (* PTS 1117202 UH 2002-08-13 *)
    k51tr_index_region := 1 + (k51glob.glTransEntries_kb05-1) DIV k51glob.glTransEntriesPerRegion_kb05
ELSE
    k51tr_index_region := 1 + (TransIndex-1) DIV k51glob.glTransEntriesPerRegion_kb05
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51unlock (
            TaskId         : tsp00_TaskId;
            TransIndex     : tgg00_TransIndex;
            VAR TransState : tgg00_TransState;
            VAR WantedLock : tkb05_WantedLock);
 
VAR
      Release         : boolean;
      Row             : tkb05_RowTransPtr;
      Tab             : tkb05_TabTransPtr;
      DummyPrevRow    : tkb05_RowTransPtr;
      DummyPrevTab    : tkb05_TabTransPtr;
      ThisTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
&ifdef TRACE
k52xwanted_lock (kb_lock, WantedLock);
&endif
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g01check (kb51c1Unlock1_csp03, csp3_n_lock,
          'wrong Lock mode         ', ord (WantedLock.wlMode_kb05),
          NOT (WantedLock.wlMode_kb05 in [lckFree_egg00, lckSysExcl_egg00]));
(*ENDIF*) 
Release   := false;
Tab       := NIL;
Row       := NIL;
ThisTrans := NIL;
IF  TransIndex <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (TransIndex, ThisTrans);
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-09-15 *)
    THEN
        g01check (kb51cWrongTransindex_csp03, csp3_n_lock,
              'k51unlock: bad trIndex  ', ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
    (*ENDIF*) 
    kb51tabid_search (ThisTrans, WantedLock.wlTabId_kb05, Tab, DummyPrevTab);
    IF  Tab <> NIL
    THEN
        BEGIN
&       ifdef TRACE
        k52xtab_trans (kb_lockentry, Tab);
&       endif
        IF  WantedLock.wlRowWanted_kb05
        THEN
            BEGIN
            kb51rowid_search (ThisTrans, Tab, WantedLock, Row, DummyPrevRow);
            IF  Row <> NIL
            THEN
                BEGIN
&               ifdef TRACE
                k52xrow_trans (kb_lockentry, Row);
&               endif
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (Tab <> NIL) AND NOT WantedLock.wlRowWanted_kb05
THEN
    BEGIN
    CASE Tab^.ttLockMode_kb05 OF
        lckTabExcl_egg00:
            Release :=
                  (WantedLock.wlMode_kb05 = lckTabExcl_egg00)
                  AND NOT (lrsEotExcl_egg00 in Tab^.ttLockState_kb05);
        lckTabShare_egg00:
            Release :=
                  (WantedLock.wlMode_kb05 = lckTabShare_egg00) OR
                  (WantedLock.wlMode_kb05 = lckTabExcl_egg00);
        lckSysShare_egg00:
            Release := true;
        OTHERWISE
            Release := false
        END;
    (*ENDCASE*) 
    IF  Release
    THEN
        BEGIN
        k52begexcl_region (TaskId, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
        kb51tab_remove (TaskId, TransRgnGlobPtr^, ThisTrans, Tab);
        k52endexcl_region (TaskId, TransRgnGlobPtr)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (Row <> NIL) AND WantedLock.wlRowWanted_kb05
THEN
    BEGIN
    CASE Row^.rtLockMode_kb05 OF
        lckRowExcl_egg00:
            Release :=
                  (WantedLock.wlMode_kb05 = lckRowExcl_egg00)
                  AND NOT (lrsEotExcl_egg00 in Row^.rtLockState_kb05);
        lckRowShare_egg00:
            Release :=
                  (WantedLock.wlMode_kb05 = lckRowShare_egg00) OR
                  (WantedLock.wlMode_kb05 = lckRowExcl_egg00);
        lckRowOptimistic_egg00:
            Release := true;
        OTHERWISE
            Release := false
        END;
    (*ENDCASE*) 
    IF  Release
    THEN
        BEGIN
        k52begexcl_region (TaskId, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
        kb51row_remove (TaskId, TransRgnGlobPtr^, ThisTrans, Tab, Row);
        k52endexcl_region (TaskId, TransRgnGlobPtr)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ThisTrans <> NIL
THEN
    BEGIN
    IF  ThisTrans^.teLockMode_kb05 = tlmFree_ekb05
    THEN
        TransState := TransState - [tsLocked_egg00]
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k51unlock_table (
            TaskId            : tsp00_TaskId;
            TransIndex        : tgg00_TransIndex;
            VAR TransState    : tgg00_TransState;
            VAR Lock          : tgg00_Lock);
 
VAR
      WantedLock : tkb05_WantedLock;
 
BEGIN
k51init_wanted_lock (WantedLock);
WITH WantedLock DO
    BEGIN
    wlTabId_kb05 := Lock.lockTabId_gg00;
    wlMode_kb05  := Lock.lockMode_gg00;
    wlState_kb05 := Lock.lockState_gg00;
    END;
(*ENDWITH*) 
k51unlock (TaskId, TransIndex, TransState, WantedLock)
END;
 
(* PTS 1134645 FF 2005-04-06 *)
(*------------------------------*) 
 
PROCEDURE
      k51WaitForAllOlderActiveTransToStop (VAR Trans : tgg00_TransContext);
 
VAR
      Transcount      : tgg91_TransNo;
      CurrTransRegion : tkb05_RegionNo;
      CurrTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
      TransCnt        : tsp00_Int4;
      bWait           : boolean;
 
BEGIN
k51new_select_trans (Trans.trTaskId_gg00, Transcount);
bWait := false;
CurrTransRegion := 1;
WHILE (Trans.trError_gg00 =  e_ok)
      AND
      NOT bWait
      AND
      (CurrTransRegion <= k51glob.glTransRegions_kb05) DO
    BEGIN
    bWait := false;
    k52begexcl_region (Trans.trTaskId_gg00, CurrTransRegion, TransRgnGlobPtr);
    CurrTrans := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
    TransCnt  := 0;
    WHILE (Trans.trError_gg00 = e_ok) AND (CurrTrans <> NIL)
          AND
          NOT bWait
          AND
          (TransCnt <= k51glob.glTransEntriesPerRegion_kb05) DO
        BEGIN
        IF  ( NOT gg06IsNilTrans (CurrTrans^.teWriteTransId_kb05)
            OR
            (CurrTrans^.teConsistView_kb05 <> NIL))
            AND
            (CurrTrans^.teSelectTransId_kb05.ci6_gg00 < Transcount.ci6_gg00)
            AND
            (Trans.trTransId_gg00 <> CurrTrans^.teSelectTransId_kb05)
        THEN
            bWait := true
        ELSE
            BEGIN
            TransCnt  := TransCnt + 1;
            CurrTrans := CurrTrans^.teNextTrans_kb05
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    k52endexcl_region (Trans.trTaskId_gg00, TransRgnGlobPtr);
    IF  bWait
    THEN
        BEGIN
        bWait := false;
        vsleep(Trans.trTaskId_gg00, 1);
        IF  (Trans.trRteCommPtr_gg00 <> NIL)
            AND
            (Trans.trRteCommPtr_gg00^.to_cancel)
        THEN
            BEGIN
            Trans.trError_gg00 := e_cancelled;
            Trans.trRteCommPtr_gg00^.to_cancel := FALSE;
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        IF  TransCnt > k51glob.glTransEntriesPerRegion_kb05
        THEN
            k52x_loop_error ('k51WrtTrnsOlderActTrns  ', 1);
        (*ENDIF*) 
        CurrTransRegion := CurrTransRegion + 1;
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51abort_list_overflow (TransIndex : tgg00_TransIndex);
 
BEGIN
g01abort (kb51x1AbortListOverflow_csp03, csp3_n_lock,
      'list is full, TransIndex', TransIndex);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51add_segment_to_region (
            VAR RegionGlob : tkb05_RegionGlob;
            NewSegment : tkb05_SupplySegmPtr);
 
VAR
      ItemIndex : integer;
      CurrItem  : tkb05_SupplyItemPtr;
      NextItem  : tkb05_SupplyItemPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00
THEN
    g08check_excl (g08lock0 + RegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
WITH RegionGlob DO
    BEGIN
    NewSegment^.sgmNext_kb05 := rglExtentFirstSegm_kb05;
    rglExtentFirstSegm_kb05  := NewSegment;
    rglExtentItems_kb05      := rglExtentItems_kb05     + ITEMS_PER_SUPPLY_SEGM_KB05;
    rglExtentFreeItems_kb05  := rglExtentFreeItems_kb05 + ITEMS_PER_SUPPLY_SEGM_KB05;
    (* *)
    NextItem := NIL;
    FOR ItemIndex := ITEMS_PER_SUPPLY_SEGM_KB05 DOWNTO 1 DO
        BEGIN
        CurrItem                       := @NewSegment^.sgmItemList_kb05 [ItemIndex];
        CurrItem^.siItemKind_kb05      := ikFree_ekb05;
        CurrItem^.siExtentItem_kb05    := true;
        CurrItem^.siChkTransIndex_kb05 := cgg_nil_transindex;
        CurrItem^.siChkTaskId_kb05     := cgg_nil_pid;
        IF  NextItem = NIL
        THEN
            CurrItem^.siNext_kb05 := rglExtentFirstFree_kb05
        ELSE
            CurrItem^.siNext_kb05 := NextItem;
        (*ENDIF*) 
        NextItem := CurrItem
        END;
    (*ENDFOR*) 
    rglExtentFirstFree_kb05 := NextItem
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51cancel_and_log_full_check (
            VAR t         : tgg00_TransContext;
            VAR ThisTrans : tkb05_TransEntryPtr);
 
VAR
      auxErr: tgg00_BasisError;
 
BEGIN
(* PTS 1133987 UH 2005-02-16 THIS MAY ONLY BE USED BY THE TRANSACTION ITSELF *)
t.trError_gg00 := e_ok;
ThisTrans      := NIL;
IF  t.trIndex_gg00 <> cgg_nil_transindex
THEN
    BEGIN
    k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
&   ifdef TRACE
    k52xtrans (kb_lockentry, ThisTrans);
&   endif
    IF  kb03Check.chkTrans_kb00 (* PTS 1103957 JA 1999-09-15 *)
    THEN
        BEGIN
        g01check (kb51cWrongTransindex_csp03, csp3_n_lock,
              'kb51timeou: bad trIndex ',
              ThisTrans^.teOwnIndex_kb05,
              ThisTrans^.teState_kb05 <> m_delete);
        (* *)
        g01check (kb51cWrongTransindex_csp03, csp3_n_lock,
              'kb51timeou: bad trId    ', ThisTrans^.teOwnIndex_kb05,
              t.trWriteTransId_gg00 = ThisTrans^.teWriteTransId_kb05)
        END;
    (*ENDIF*) 
    IF  ThisTrans^.teTimeoutEnabled_kb05
    THEN
        BEGIN
        vbegexcl (t.trTaskId_gg00, g08lock0 + ThisTrans^.teOwnRegion_kb05);
        ThisTrans^.teTimeoutEnabled_kb05 := false;
        k52flush_trans_entry (ThisTrans^);
        vendexcl (t.trTaskId_gg00, g08lock0 + ThisTrans^.teOwnRegion_kb05);
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND (ThisTrans <> NIL)
THEN
    BEGIN
    IF  (t.trError_gg00 = e_ok)
        AND
        ((t.trRteCommPtr_gg00^.to_cancel)
        OR
        (tiCancelled_ekb05 in ThisTrans^.teInfo_kb05))
    THEN
        t.trError_gg00 := e_cancelled
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND (ThisTrans <> NIL)
THEN
    BEGIN
&   ifdef TRACE
    t01localstate (kb_log, 'trState     ', t.trState_gg00);
&   endif
    ;
    (* PTS 1106270 JA 2000-04-06:                                               *)
    (*   this procedure is called from inside and outside KB-functions,         *)
    (*   therefore the handling of tsFunctRollbSet is removed                   *)
    (*   tsFunctRollbSet_egg00 is handled when inserting new SQL/OMS-Logentries *)
    ;
    IF  ThisTrans^.teReqTab_kb05 <> NIL
    THEN
        kb51lock_own_request (t, ThisTrans);
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) AND NOT gg06IsNilTrans (t.trConsistView_gg00)
    THEN
        kb50CheckConsistViewOfTrans (t, ThisTrans^)
    (*ENDIF*) 
    END
ELSE
    (* PTS 1141009 FF 7-APR-2006 *)
    IF  (ThisTrans <> NIL) AND (ThisTrans^.teReqTab_kb05 <> NIL)
    THEN
        BEGIN
        auxErr := t.trError_gg00;
        k51handle_request_timeout (t);
        t.trError_gg00 := auxErr;
        END;
    (*ENDIF*) 
(*ENDIF*) 
IF  t.trError_gg00 = e_wait_for_lock_release
THEN
    ThisTrans^.teTimeoutEnabled_kb05 := true; (* outside region *)
(*ENDIF*) 
;
&ifdef TRACE
ta01SessionTrans (kb_lock, 'cancel_check', t.trSessionId_gg00
      ,                                    t.trTransId_gg00
      ,                                    t.trWriteTransId_gg00
      ,                                    t.trSubtransId_gg00);
t01int4          (kb_lock, 't.trIndex   ', t.trIndex_gg00);
ta01TransNo      (kb_lock, 't.trCnstView', t.trConsistView_gg00);
t01addr          (kb_lock, 'ThisTrans   ', ThisTrans);
t01basis_error   (kb_lock, 'end kb51canc', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51compare_rowid (
            VAR WantedRowId    : tkb05_RowId;
            VAR WantedShortKey : tkb05_ShortKey;
            WantedKeyLen       : tsp00_Int2;
            EntryRowidPtr      : tkb05_RowIdItemPtr;
            VAR EntryShortKey  : tkb05_ShortKey;
            EntryKeyLen        : tsp00_Int2;
            VAR Result         : tsp00_LcompResult);
 
BEGIN
(* WantedRowId > entry_rowid  ==>  l_greater *)
IF  EntryRowidPtr = NIL
THEN
    BEGIN
    IF  WantedShortKey = EntryShortKey
    THEN
        BEGIN
        IF  WantedKeyLen = EntryKeyLen
        THEN
            Result := l_equal
        ELSE
            IF  WantedKeyLen > EntryKeyLen
            THEN
                Result := l_greater
            ELSE
                Result := l_less
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        IF  WantedShortKey > EntryShortKey
        THEN
            Result := l_greater
        ELSE
            Result := l_less
        (*ENDIF*) 
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  EntryRowidPtr^.riItemKind_kb05 <> ikRowId_ekb05
    THEN
        k52x_item_error ('kb51compare_rowid       ', EntryRowidPtr^.riItemKind_kb05);
    (*ENDIF*) 
    IF  WantedRowId = EntryRowidPtr^.riRowId_kb05
    THEN
        BEGIN
        IF  WantedKeyLen = EntryKeyLen
        THEN
            Result := l_equal
        ELSE
            IF  WantedKeyLen > EntryKeyLen
            THEN
                Result := l_greater
            ELSE
                Result := l_less
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        IF  WantedRowId > EntryRowidPtr^.riRowId_kb05
        THEN
            Result := l_greater
        ELSE
            Result := l_less
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51consistent_tab_remove (
            TaskId              : tsp00_TaskId;
            VAR TransRegionGlob : tkb05_RegionGlob;
            ThisTrans           : tkb05_TransEntryPtr;
            ThisTab             : tkb05_TabTransPtr);
 
VAR
      Found   : boolean;
      ItemCnt : tsp00_Int4;
      CurrTab : tkb05_TabTransPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (TaskId, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51consis: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransRegionGlob.rglOwnRegion_kb05);
    END;
(*ENDIF*) 
CurrTab := ThisTrans^.teFirstTab_kb05;
ItemCnt := 0;
Found   := false;
WHILE (CurrTab <> NIL) AND NOT Found AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
    IF  (CurrTab <> ThisTab) AND (lrsConsistent_egg00 in CurrTab^.ttLockState_kb05)
    THEN
        Found := true
    ELSE
        BEGIN
        ItemCnt := ItemCnt + 1;
        CurrTab := CurrTab^.ttNextTab_kb05
        END;
    (*ENDIF*) 
(*ENDWHILE*) 
IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
THEN
    k52x_loop_error ('kb51consistent_tab_remov', 1);
(*ENDIF*) 
IF  CurrTab <> NIL
THEN
    kb51tab_remove (TaskId, TransRegionGlob, ThisTrans, CurrTab)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51deadlock_detection (
            VAR t     : tgg00_TransContext;
            ThisTrans : tkb05_TransEntryPtr);
 
VAR
      DeadlockFound   : boolean;
      DummyOk         : boolean;
      SignalSent      : boolean;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
t.trError_gg00 := e_wait_for_lock_release;
DeadlockFound  := false;
vbegexcl (t.trTaskId_gg00, g08lockreq);
kb51search_deadlock (t.trIndex_gg00, t.trIndex_gg00, 0, DeadlockFound);
vendexcl (t.trTaskId_gg00, g08lockreq);
IF  DeadlockFound
THEN
    BEGIN
    SignalSent := false;
    vbegexcl (t.trTaskId_gg00, g08lockwait);
    IF  ThisTrans^.teWaiting_kb05
    THEN
        BEGIN
        ThisTrans^.teWaiting_kb05 := false;
        k52flush_trans_waiting (ThisTrans^.teWaiting_kb05)
        END
    ELSE
        SignalSent := true;
    (*ENDIF*) 
    vendexcl (t.trTaskId_gg00, g08lockwait);
    IF  SignalSent
    THEN
        BEGIN
        (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
        vwait (t.trTaskId_gg00, DummyOk);
        (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
        END;
    (*ENDIF*) 
    k52begexcl_region (t.trTaskId_gg00, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
    WITH TransRgnGlobPtr^.rglTransGlob_kb05^ DO
        (* PTS 1103743 JA 1999-08-25 *)
        trDeadlocks_kb05 := trDeadlocks_kb05 + ONE_8BYTE_CNT_GG04;
    (*ENDWITH*) 
    kb51req_timeout_handling (t, TransRgnGlobPtr, ThisTrans);
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
    t.trError_gg00 := e_work_rolled_back;
    kb51put_errtext (t, ERR_DEADLOCK);
    t.trError_gg00 := e_rollback_wanted
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51del_trans_entry (
            VAR TransGlob : tkb05_TransGlob;
            VAR ThisTrans : tkb05_TransEntryPtr;
            VAR TransContext : tgg00_TransContext); (* PTS 1133444 mb 2005-01-19 *)
 
VAR
      TransHash : tsp00_Int4;
      ok        : boolean;
 
BEGIN
&ifdef TRACE
t01addr          (kb_lock, 'ThisTrans   ', ThisTrans);
t01int4          (kb_lock, 'TransIndex  ', ThisTrans^.teOwnIndex_kb05);
ta01SessionTrans (kb_lock, 'del  Trans  ', ThisTrans^.teSessionId_kb05
      ,                                    ThisTrans^.teSelectTransId_kb05
      ,                                    ThisTrans^.teWriteTransId_kb05
      ,                                    ThisTrans^.teSubtransId_kb05);
&endif
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08check_excl (g08lock0 + ThisTrans^.teOwnRegion_kb05);
(*ENDIF*) 
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g01check (kb51c1DelTransEntry_csp03, csp3_n_lock,
          'del Trans: Lock exists  ', ThisTrans^.teOwnIndex_kb05,
          (ThisTrans^.teLockMode_kb05 = tlmFree_ekb05));
    (* *)
    g01check (kb51c2DelTransEntry_csp03, csp3_n_lock,
          'del Trans: Req exists   ', ThisTrans^.teOwnIndex_kb05,
          (ThisTrans^.teReqMode_kb05 = tlmFree_ekb05));
    (* *)
    g01check (kb51c1DelTransEntry_csp03, csp3_n_lock,
          'del Trans: Tab exists   ', ThisTrans^.teOwnIndex_kb05,
          (ThisTrans^.teFirstTab_kb05 = NIL));
    END;
(*ENDIF*) 
IF  (ThisTrans^.teTaskId_kb05 <> cgg_nil_pid)
THEN
    vprio (ThisTrans^.teTaskId_kb05, USER_LOCK_PRIO, NOT SET_PRIO);
(*ENDIF*) 
IF  ThisTrans^.tePrevTrans_kb05 <> NIL
THEN
    ThisTrans^.tePrevTrans_kb05^.teNextTrans_kb05 := ThisTrans^.teNextTrans_kb05
ELSE
    TransGlob.trFirst_kb05 := ThisTrans^.teNextTrans_kb05;
(*ENDIF*) 
IF  ThisTrans^.teNextTrans_kb05 <> NIL
THEN
    ThisTrans^.teNextTrans_kb05^.tePrevTrans_kb05 := ThisTrans^.tePrevTrans_kb05;
(*ENDIF*) 
IF  ThisTrans^.tePrevHash_kb05 <> NIL
THEN
    ThisTrans^.tePrevHash_kb05^.teNextHash_kb05 := ThisTrans^.teNextHash_kb05
ELSE
    BEGIN
    kb51trans_hash (ThisTrans^.teSessionId_kb05, TransHash);
    TransGlob.trTransHash_kb05^[TransHash] := ThisTrans^.teNextHash_kb05
    END;
(*ENDIF*) 
IF  ThisTrans^.teNextHash_kb05 <> NIL
THEN
    ThisTrans^.teNextHash_kb05^.tePrevHash_kb05 := ThisTrans^.tePrevHash_kb05;
(*ENDIF*) 
ThisTrans^.teState_kb05 := m_delete;
(* It may be the case that trLocalFileDirPtr_gg00 is inherited. So never release *)
(* it but only teLocalFileDirPtr_kb05 (PTS 1133444 mb 2005-01-19)                *)
bd170DeleteUserFiledirectory(TransContext, ThisTrans^.teLocalFileDirPtr_kb05);
ThisTrans^.teLocalFileDirPtr_kb05 := NIL;
TransContext.trLocalFileDirPtr_gg00 := NIL;
if ( TransContext.trClusterIOPtr_gg00  <> NIL )
THEN
    BEGIN
    vfreebuf (bd999GetDataIOBlockCount, TransContext.trClusterIOPtr_gg00, ok);
    (* something if not ok *)
    TransContext.trClusterIOPtr_gg00    := NIL;
    TransContext.trClusterIOSize_gg00   := 0;
    END;
WITH TransGlob DO
    BEGIN
    trConnectOnlyCnt_kb05       := trConnectOnlyCnt_kb05 - 1;
    ThisTrans^.teNextTrans_kb05 := trFirstFree_kb05;
    trFirstFree_kb05            := ThisTrans;
    ThisTrans                   := NIL;
    trFreeEntries_kb05          := trFreeEntries_kb05 + 1;
    END;
(*ENDWITH*) 
&ifdef TRACE
WITH TransGlob DO
    BEGIN
    t01p2int4 (kb_lock, 'ReqTransCnt ', trReqTransCnt_kb05
          ,             'LockTransCnt', trLockTransCnt_kb05);
    t01p2int4 (kb_lock, 'ConnectOnlyC', trConnectOnlyCnt_kb05
          ,             'FreeEntries ', trFreeEntries_kb05)
    END;
(*ENDWITH*) 
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      kb51exists_row_lock (
            TaskId                : tsp00_TaskId;
            OwnIndex              : tgg00_TransIndex;
            VAR WantedLock        : tkb05_WantedLock;
            VAR AlreadyLocked     : boolean) : boolean;
 
VAR
      RowHash       : tsp00_Int4;
      RowRegion     : tkb05_RegionNo;
      RowLock       : tkb05_RowLockPtr;
      PrevRow       : tkb05_RowLockPtr;
      RowRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
(* PTS 1107056 JA 2001-03-01 *)
RowLock := NIL;
kb51row_hash (WantedLock.wlRowId_kb05, WantedLock.wlKeyLen_kb05, RowHash, RowRegion);
k52begexcl_region (TaskId, RowRegion, RowRgnGlobPtr);
IF  RowLock = NIL
THEN
    kb51rowid_hash_search (RowRgnGlobPtr^, RowHash, WantedLock, RowLock, PrevRow);
(*ENDIF*) 
IF  RowLock <> NIL
THEN
    AlreadyLocked := (OwnIndex = RowLock^.rlExclTransIndex_kb05)
          AND
          (lrsEotExcl_egg00 in RowLock^.rlLockState_kb05);
(*ENDIF*) 
k52endexcl_region (TaskId, RowRgnGlobPtr);
kb51exists_row_lock := (RowLock <> NIL);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51free_req (
            TaskId            : tsp00_TaskId;
            VAR ReqRegionGlob : tkb05_RegionGlob;
            TransIndex        : tgg00_TransIndex;
            VAR FirstReq      : tkb05_ReqPtr);
 
VAR
      Found       : boolean;
      ItemCnt     : tsp00_Int4;
      RemoveReq   : tkb05_ReqPtr;
      PrevReq     : tkb05_ReqPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08excl_check (TaskId, g08lock0 + ReqRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
IF  FirstReq <> NIL
THEN
    BEGIN
    RemoveReq := NIL;
    IF  FirstReq^.rqTransIndex_kb05 = TransIndex
    THEN
        BEGIN
        RemoveReq := FirstReq;
        FirstReq  := FirstReq^.rqNextReq_kb05;
        IF  FirstReq <> NIL
        THEN
            FirstReq^.rqLastReq_kb05 := RemoveReq^.rqLastReq_kb05
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        RemoveReq := FirstReq;
        PrevReq   := NIL;
        Found     := false;
        ItemCnt   := 0;
        WHILE (RemoveReq <> NIL) AND NOT Found AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
            IF  RemoveReq^.rqTransIndex_kb05 = TransIndex
            THEN
                Found := true
            ELSE
                BEGIN
                ItemCnt   := ItemCnt + 1;
                PrevReq   := RemoveReq;
                RemoveReq := RemoveReq^.rqNextReq_kb05
                END;
            (*ENDIF*) 
        (*ENDWHILE*) 
        IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
        THEN
            k52x_loop_error ('kb51free_req            ', 1);
        (*ENDIF*) 
        IF  RemoveReq <> NIL
        THEN
            BEGIN
            IF  FirstReq^.rqLastReq_kb05 = RemoveReq
            THEN
                FirstReq^.rqLastReq_kb05 := PrevReq;
            (*ENDIF*) 
            PrevReq^.rqNextReq_kb05 := RemoveReq^.rqNextReq_kb05
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  RemoveReq <> NIL
    THEN
        BEGIN
        UnivItemPtr.uiReq_kb05 := RemoveReq;
        kb51free_supply_item (TaskId, ReqRegionGlob, UnivItemPtr, ikRequest_ekb05)
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51free_supply_item (
            TaskId         : tsp00_TaskId;
            VAR RegionGlob : tkb05_RegionGlob;
            UnivItemPtr    : tkb05_UnivItemPtr;
            ItemKind       : tkb05_ItemKind);
 
VAR
      SegmentCnt      : tsp00_Int4;
      FreeItem        : tkb05_SupplyItemPtr;
      CurrSegment     : tkb05_SupplySegmPtr;
      FreeSegment     : tkb05_SupplySegmPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
 
BEGIN
FreeItem := UnivItemPtr.uiSupplyItem_kb05;
&ifdef TRACE
t01addr_1 (kb_lock, 'FreeItem    ', FreeItem);
&endif
IF  kb03Check.chkRegion_kb00
THEN
    g08check_excl (g08lock0 + RegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
IF  kb03Check.chkLock_kb00 AND (RegionGlob.rglOwnRegion_kb05 < MAX_UINT1_SP00)
THEN
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51free_sup: wrong item', ord (FreeItem^.siItemKind_kb05),
          FreeItem^.siChkOwnRegion_kb05 = RegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
IF  FreeItem^.siItemKind_kb05 <> ItemKind
THEN
    k52x_item_error ('kb51free_supply_item    ', FreeItem^.siItemKind_kb05);
(*ENDIF*) 
FreeItem^.siItemKind_kb05      := ikFree_ekb05;
FreeItem^.siChkTransIndex_kb05 := cgg_nil_transindex;
FreeItem^.siChkTaskId_kb05     := TaskId;
WITH RegionGlob DO
    IF  FreeItem^.siExtentItem_kb05
    THEN
        BEGIN
        FreeItem^.siNext_kb05   := rglExtentFirstFree_kb05;
        rglExtentFirstFree_kb05 := FreeItem;
        rglExtentFreeItems_kb05 := rglExtentFreeItems_kb05 + 1;
        IF  rglExtentFreeItems_kb05 >= rglExtentItems_kb05
        THEN
            (* extension unused --> relase extension segments *)
            BEGIN
            CurrSegment := rglExtentFirstSegm_kb05;
            SegmentCnt  := 0;
            k52begexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
            WHILE (CurrSegment <> NIL) AND (SegmentCnt <= k51glob.glSupplyPoolSegments_kb05) DO
                BEGIN
                FreeSegment := CurrSegment;
                CurrSegment := CurrSegment^.sgmNext_kb05;
                SegmentCnt  := SegmentCnt + 1;
                kb51sfree_segment (SupplyPoolGlobPtr^, FreeSegment)
                END;
            (*ENDWHILE*) 
            k52endexcl_supply_pool (TaskId, SupplyPoolGlobPtr);
            IF  SegmentCnt > k51glob.glSupplyPoolSegments_kb05
            THEN
                k52x_loop_error ('kb51free_supply_item    ', 1);
            (*ENDIF*) 
            rglExtentFirstSegm_kb05 := NIL;
            rglExtentFirstFree_kb05 := NIL;
            rglExtentItems_kb05     := 0;
            rglExtentFreeItems_kb05 := 0
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        FreeItem^.siNext_kb05 := rglFirstFree_kb05;
        rglFirstFree_kb05     := FreeItem;
        rglFreeItems_kb05     := rglFreeItems_kb05 + 1
        END;
    (*ENDIF*) 
(*ENDWITH*) 
;
&ifdef TRACE
t01p2int4 (kb_lock, 'Region      ', RegionGlob.rglOwnRegion_kb05
      ,             'FreeItems   ', RegionGlob.rglFreeItems_kb05);
t01p2int4 (kb_lock, 'ExtentItems ', RegionGlob.rglExtentItems_kb05
      ,             'ExtFreeItems', RegionGlob.rglExtentFreeItems_kb05);
IF  kb03Check.chkLockSupply_kb00
THEN
    k52xregion_supply_check (RegionGlob);
&endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51free_tab_lock (
            TaskId              : tsp00_TaskId;
            VAR TabRegionGlob   : tkb05_RegionGlob;
            VAR Tab             : tkb05_TabLockPtr;
            TabHash             : tsp00_Int4);
 
VAR
      CurrHash    : tkb05_TabLockPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
      ItemCnt     : tsp00_Int4;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08excl_check (TaskId, g08lock0 + TabRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
CurrHash := TabRegionGlob.rglTabHash_kb05^[TabHash];
IF  CurrHash = Tab
THEN
    TabRegionGlob.rglTabHash_kb05^[TabHash] := Tab^.tlNextHashTab_kb05
ELSE
    BEGIN
    IF  CurrHash <> NIL
    THEN
        BEGIN
        ItemCnt := 0;
        WHILE (CurrHash^.tlNextHashTab_kb05 <> Tab) AND
              (CurrHash^.tlNextHashTab_kb05 <> NIL) AND
              (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
            BEGIN
            ItemCnt  := ItemCnt + 1;
            CurrHash := CurrHash^.tlNextHashTab_kb05
            END;
        (*ENDWHILE*) 
        IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
        THEN
            k52x_loop_error ('kb51free_tab_lock       ', 1);
        (*ENDIF*) 
        IF  CurrHash <> NIL
        THEN
            BEGIN
            IF  CurrHash^.tlNextHashTab_kb05 = Tab
            THEN
                CurrHash^.tlNextHashTab_kb05 := Tab^.tlNextHashTab_kb05
            ELSE
                CurrHash := NIL (* for check handling *)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  kb03Check.chkLock_kb00
THEN
    g01check (kb51c1TryFreeTabLock_csp03, csp3_n_lock,
          'try free Tab: hash = nil', 0, CurrHash <> NIL);
(*ENDIF*) 
UnivItemPtr.uiTabLock_kb05 := Tab;
Tab := NIL;
kb51free_supply_item (TaskId, TabRegionGlob, UnivItemPtr, ikTabLock_ekb05)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51get_supply_item (
            VAR t                : tgg00_TransContext;
            VAR RegionGlob       : tkb05_RegionGlob;
            WantedItemKind       : tkb05_ItemKind;
            VAR UnivItemPtr      : tkb05_UnivItemPtr);
 
VAR
      IsExtentItem      : boolean;
      NewItem           : tkb05_SupplyItemPtr;
      NewSegment        : tkb05_SupplySegmPtr;
      SupplyPoolGlobPtr : tkb05_SupplyPoolGlobPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08excl_check (t.trTaskId_gg00, g08lock0 + RegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
t.trError_gg00 := e_ok;
NewItem        := NIL;
IsExtentItem   := false;
IF  RegionGlob.rglFirstFree_kb05 <> NIL
THEN
    WITH RegionGlob DO
        BEGIN
        NewItem           := rglFirstFree_kb05;
        rglFirstFree_kb05 := rglFirstFree_kb05^.siNext_kb05;
        rglFreeItems_kb05 := rglFreeItems_kb05 -1
        END
    (*ENDWITH*) 
ELSE
    (* supply empty --> use supply extension *)
    BEGIN
    IF  RegionGlob.rglExtentFirstFree_kb05 = NIL
    THEN
        BEGIN
        k52begexcl_supply_pool (t.trTaskId_gg00, SupplyPoolGlobPtr);
        kb51sget_segment       (t, SupplyPoolGlobPtr^, NewSegment);
        k52endexcl_supply_pool (t.trTaskId_gg00, SupplyPoolGlobPtr);
        IF  t.trError_gg00 = e_ok
        THEN
            kb51add_segment_to_region (RegionGlob, NewSegment)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        WITH RegionGlob DO
            BEGIN
            IsExtentItem           := true;
            NewItem                := rglExtentFirstFree_kb05;
            rglExtentFirstFree_kb05 := rglExtentFirstFree_kb05^.siNext_kb05;
            rglExtentFreeItems_kb05 := rglExtentFreeItems_kb05 -1
            END
        (*ENDWITH*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    IF  NewItem^.siItemKind_kb05 <> ikFree_ekb05
    THEN
        k52x_item_error ('kb51get_supply_item     ', NewItem^.siItemKind_kb05);
    (*ENDIF*) 
    CASE WantedItemKind OF
        ikRequest_ekb05:
            NewItem^.siReq_kb05         := k51glob.glNilReq_kb05;
        ikRowLock_ekb05:
            NewItem^.siRowLock_kb05     := k51glob.glNilRowLock_kb05;
        ikRowTrans_ekb05:
            NewItem^.siRowTrans_kb05    := k51glob.glNilRowTrans_kb05;
        ikTabLock_ekb05:
            NewItem^.siTabLock_kb05     := k51glob.glNilTabLock_kb05;
        ikTabTrans_ekb05:
            NewItem^.siTabTrans_kb05    := k51glob.glNilTabTrans_kb05;
        ikOpenTrans_ekb05:
            NewItem^.siOpenTrans_kb05   := k51glob.glNilOpenTrans_kb05;
        OTHERWISE
            BEGIN
            SAPDB_PascalFill ('VKB51 ',   1,    
                  sizeof (NewItem^),
                  @NewItem^, 1, sizeof (NewItem^), chr (0), t.trError_gg00);
            NewItem^.siItemKind_kb05 := WantedItemKind
            END
        END;
    (*ENDCASE*) 
    NewItem^.siExtentItem_kb05   := IsExtentItem;
    NewItem^.siChkTaskId_kb05    := t.trTaskId_gg00;
    IF  RegionGlob.rglOwnRegion_kb05 < MAX_UINT1_SP00
    THEN
        NewItem^.siChkOwnRegion_kb05 := RegionGlob.rglOwnRegion_kb05;
    (*ENDIF*) 
    IF  t.trIndex_gg00 < MAX_UINT1_SP00
    THEN
        NewItem^.siChkTransIndex_kb05 := t.trIndex_gg00
    (*ENDIF*) 
    END;
(*ENDIF*) 
UnivItemPtr.uiSupplyItem_kb05 := NewItem;
(**)
&ifdef TRACE
t01p2int4      (kb_lock, 'Region      ', RegionGlob.rglOwnRegion_kb05
      ,                  'FreeItems   ', RegionGlob.rglFreeItems_kb05);
t01p2int4      (kb_lock, 'ExtentItems ', RegionGlob.rglExtentItems_kb05
      ,                  'ExtFreeItems', RegionGlob.rglExtentFreeItems_kb05);
t01addr_1      (kb_lock, 'NewItem     ', NewItem);
t01basis_error (kb_lock, 'end get_sply', t.trError_gg00);
IF  kb03Check.chkLockSupply_kb00
THEN
    k52xregion_supply_check (RegionGlob);
&endif
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51ins_row_mode (
            Row             : tkb05_RowTransPtr;
            WantedMode      : tgg00_LockReqMode;
            WantedState     : tgg00_LockReqState;
            TabOptimVers    : tsp00_Int4;
            RowOptimVers    : tsp00_Int4);
 
BEGIN
&ifdef TRACE
t01lockmode  (kb_lock, 'old ROW mode', Row^.rtLockMode_kb05);
t01lockstate (kb_lock, '       state', Row^.rtLockState_kb05);
&endif
IF  lrsConsistent_egg00 in WantedState
THEN
    BEGIN
    IF  Row^.rtLockMode_kb05 = lckFree_egg00
    THEN
        Row^.rtLockState_kb05 := [lrsConsistent_egg00]
    (*ENDIF*) 
    END
ELSE
    Row^.rtLockState_kb05 := Row^.rtLockState_kb05 - [lrsConsistent_egg00];
(*ENDIF*) 
(* keep Tab^.ttRowShareLocks_kb05 and Tab^.ttRowOptimCnt_kb05 *)
(* to assure consistent TabLock counters                      *)
CASE WantedMode OF
    lckRowExcl_egg00:
        BEGIN
        Row^.rtLockMode_kb05 := lckRowExcl_egg00;
        IF  lrsEotExcl_egg00 in WantedState
        THEN
            Row^.rtLockState_kb05 := Row^.rtLockState_kb05 + [lrsEotExcl_egg00]
        (*ENDIF*) 
        END;
    lckRowShare_egg00:
        BEGIN
        IF  Row^.rtLockMode_kb05 <> lckRowExcl_egg00
        THEN
            BEGIN
            Row^.rtLockMode_kb05     := lckRowShare_egg00;
            Row^.rtSharedLocked_kb05 := true                         (* PTS 1107452 JA 2000-08-08 *)
            END
        (*ENDIF*) 
        END;
    lckRowOptimistic_egg00:
        IF  (Row^.rtLockMode_kb05 <> lckRowExcl_egg00 ) AND
            (Row^.rtLockMode_kb05 <> lckRowShare_egg00)
        THEN
            BEGIN
            Row^.rtLockMode_kb05     := lckRowOptimistic_egg00;
            Row^.rtTabOptimVers_kb05 := TabOptimVers;
            Row^.rtRowOptimVers_kb05 := RowOptimVers;
            Row^.rtOptimSet_kb05     := true                         (* PTS 1107452 JA 2000-08-08 *)
            END;
        (*ENDIF*) 
    OTHERWISE;
    END;
(*ENDCASE*) 
&ifdef TRACE
t01lockmode  (kb_lock, 'new ROW mode', Row^.rtLockMode_kb05);
t01lockstate (kb_lock, '       state', Row^.rtLockState_kb05);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51ins_tab_mode (
            Tab             : tkb05_TabTransPtr;
            WantedMode      : tgg00_LockReqMode;
            WantedState     : tgg00_LockReqState);
 
BEGIN
&ifdef TRACE
t01lockmode  (kb_lock, 'old TAB mode', Tab^.ttLockMode_kb05);
t01lockstate (kb_lock, '       state', Tab^.ttLockState_kb05);
&endif
CASE WantedMode OF
    lckSysExcl_egg00  (*
    ===========  *):
        BEGIN
        Tab^.ttLockMode_kb05  := lckSysExcl_egg00;
        Tab^.ttLockState_kb05 := [lrsEotExcl_egg00]
        END;
    lckTabExcl_egg00  (*
    ===========  *):
        BEGIN
        IF  Tab^.ttLockMode_kb05 <> lckSysExcl_egg00
        THEN
            BEGIN
            Tab^.ttLockMode_kb05  := lckTabExcl_egg00;
            Tab^.ttLockState_kb05 := Tab^.ttLockState_kb05 - [lrsConsistent_egg00, lrsTemp_egg00];
            IF  lrsEotExcl_egg00 in WantedState
            THEN
                Tab^.ttLockState_kb05 := Tab^.ttLockState_kb05 + [lrsEotExcl_egg00]
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    lckTabShare_egg00  (*
    ============  *):
        IF  (Tab^.ttLockMode_kb05 <> lckSysExcl_egg00) AND
            (Tab^.ttLockMode_kb05 <> lckTabExcl_egg00)
        THEN
            BEGIN
            IF  (lrsTemp_egg00 in WantedState)
                AND
                (Tab^.ttLockMode_kb05 <> lckTabShare_egg00)
            THEN
                Tab^.ttLockState_kb05 := Tab^.ttLockState_kb05 + [lrsTemp_egg00];
            (*ENDIF*) 
            IF  NOT (lrsTemp_egg00 in WantedState)
            THEN
                Tab^.ttLockState_kb05 := Tab^.ttLockState_kb05 - [lrsTemp_egg00];
            (*ENDIF*) 
            Tab^.ttLockMode_kb05  := lckTabShare_egg00;
            Tab^.ttLockState_kb05 := Tab^.ttLockState_kb05 - [lrsConsistent_egg00]
            END;
        (*ENDIF*) 
    lckSysShare_egg00  (*
    ============  *):
        CASE Tab^.ttLockMode_kb05 OF
            lckSysExcl_egg00, lckTabExcl_egg00, lckTabShare_egg00:
                ;
            OTHERWISE
                BEGIN
                IF  (lrsConsistent_egg00 in WantedState)
                    AND
                    (Tab^.ttLockMode_kb05 = lckFree_egg00)
                THEN
                    Tab^.ttLockState_kb05 := [lrsConsistent_egg00];
                (*ENDIF*) 
                IF  NOT (lrsConsistent_egg00 in WantedState)
                THEN
                    Tab^.ttLockState_kb05 := Tab^.ttLockState_kb05 - [lrsConsistent_egg00];
                (*ENDIF*) 
                Tab^.ttLockMode_kb05 := lckSysShare_egg00
                END
            END;
        (*ENDCASE*) 
    lckRowExcl_egg00  (*
    ===========  *):
        Tab^.ttRowExclLocks_kb05 := Tab^.ttRowExclLocks_kb05 + 1;
    lckRowShare_egg00  (*
    ============  *):
        Tab^.ttRowShareLocks_kb05 := Tab^.ttRowShareLocks_kb05 + 1;
    lckRowOptimistic_egg00  (*
    =================  *):
        Tab^.ttRowOptimCnt_kb05 := Tab^.ttRowOptimCnt_kb05 + 1;
    OTHERWISE
        ;
    END;
(*ENDCASE*) 
&ifdef TRACE
t01lockmode  (kb_lock, 'new TAB mode', Tab^.ttLockMode_kb05);
t01lockstate (kb_lock, '       state', Tab^.ttLockState_kb05);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51lock_own_request (
            VAR t                 : tgg00_TransContext;
            ThisTrans             : tkb05_TransEntryPtr);
 
VAR
      Collided        : boolean;
      WaitInserted    : boolean;
      TransLockMode   : tkb05_TransLockMode;
      DummyRegion     : tkb05_RegionNo;
      TabRegion       : tkb05_RegionNo;
      TabHash         : tsp00_Int4;
      DummyHash       : tsp00_Int4;
      RowOptimVers    : tsp00_Int4;
      TabOptimVers    : tsp00_Int4;
      ReqTab          : tkb05_TabTransPtr;
      ReqRow          : tkb05_RowTransPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
      WantedLock      : tkb05_WantedLock;
 
BEGIN
t.trError_gg00 := e_ok;
Collided       := false;
WaitInserted   := false;
ReqTab         := ThisTrans^.teReqTab_kb05;
ReqRow         := ThisTrans^.teReqRow_kb05;
&ifdef TRACE
k52xtab_trans (kb_lockentry, ReqTab);
k52xrow_trans (kb_lockentry, ReqRow);
&endif
IF  ReqTab^.ttItemKind_kb05 <> ikTabTrans_ekb05
THEN
    k52x_item_error ('kb51lock_own_request/1  ', ReqTab^.ttItemKind_kb05);
(*ENDIF*) 
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g01check (kb51c1LockOwnRequest_csp03, csp3_n_lock,
          'Lock own Tab Req: nil   ', 0,
          ReqTab <> NIL);
    (* *)
    g01check (kb51c2LockOwnRequest_csp03, csp3_n_lock,
          'invalid Lock own Tab Req', ThisTrans^.teOwnIndex_kb05,
          ReqTab^.ttReqMode_kb05 <> lckFree_egg00);
    (* *)
    g01check (kb51c3LockOwnRequest_csp03, csp3_n_lock,
          'invalid Lock own Row Req', ThisTrans^.teOwnIndex_kb05,
          (ReqRow = NIL)
          OR
          (ReqTab^.ttReqMode_kb05 in [lckRowShare_egg00, lckRowOptimistic_egg00, lckRowExcl_egg00]))
    END;
(*ENDIF*) 
k51init_wanted_lock (WantedLock);
WITH WantedLock, ReqTab^ DO
    BEGIN
    wlTabId_kb05    := ttTabId_kb05;
    wlMode_kb05     := ttReqMode_kb05;
    wlState_kb05    := ttReqState_kb05;
    wlHandling_kb05 := [hdCheckCollision_ekb05, hdInsLock_ekb05, hdCheckOwnReq_ekb05]
    END;
(*ENDWITH*) 
IF  ReqRow <> NIL
THEN
    WITH WantedLock, ReqRow^ DO
        BEGIN
        IF  rtItemKind_kb05 <> ikRowTrans_ekb05
        THEN
            k52x_item_error ('kb51lock_own_request/2  ', rtItemKind_kb05);
        (*ENDIF*) 
        wlRowWanted_kb05 := true;
        wlKeyLen_kb05    := rtKeyLen_kb05;
        IF  rtRow_kb05^.rlRowIdItem_kb05 = NIL
        THEN
            wlShortKey_kb05 := rtShortKey_kb05
        ELSE
            wlRowId_kb05 := rtRow_kb05^.rlRowIdItem_kb05^.riRowId_kb05
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(* PTS 1001791 UH 1999-01-04 begin *)
(*ENDIF*) 
TransLockMode := ThisTrans^.teLockMode_kb05;
IF  TransLockMode <> tlmEotExcl_ekb05
THEN
    (* used for checkpoint-collision-check and hint for request order *)
    TransLockMode := ThisTrans^.teObjLockMode_kb05;
(* PTS 1001791 UH 1999-01-04 end *)
(*ENDIF*) 
kb51tab_lock_check_ins (t,
      NIL, (* not in TabRegion *)
      WantedLock, TransLockMode, NOT IGNORE_REQ_PRIORITY,
      ReqTab, ReqRow, TabRegion, TabHash,
      ReqTab^.ttTab_kb05, TabOptimVers, Collided, WaitInserted);
IF  (t.trError_gg00 = e_ok) AND WantedLock.wlRowWanted_kb05
THEN
    BEGIN
    IF  NOT Collided
    THEN
        BEGIN
        kb51row_lock_check_ins (t, WantedLock,
              ThisTrans^.teLockMode_kb05,
              ReqRow, DummyRegion, DummyHash, ReqRow^.rtRow_kb05,
              RowOptimVers, Collided, WaitInserted);
        IF  Collided
            OR (t.trError_gg00 = e_lock_collision_with_inserted_row) (*PTS 1141009 FF*)
        THEN
            (* Tab Lock already inserted -> change Tab Lock into Req *)
            kb51row_from_tab_lock_release (t.trTaskId_gg00,
                  NIL, (* not in TabRegion *)
                  TabRegion, TabHash, ReqTab^.ttTab_kb05,
                  WantedLock.wlMode_kb05, HOLD_TAB_LOCK AND (t.trError_gg00 = e_ok)) (*PTS 1141009 FF*)
        (*ENDIF*) 
        END
    ELSE
        (* Collided on Tab level *)
        IF  WantedLock.wlMode_kb05 = lckRowExcl_egg00
        THEN
            (* remove exclusive reservation *)
            BEGIN
            vbegexcl (t.trTaskId_gg00, g08lock0 + ReqRow^.rtRowRegion_kb05);
            IF  ReqRow^.rtRow_kb05^.rlExclTransIndex_kb05 = t.trIndex_gg00
            THEN
                BEGIN
                IF  (k51glob.glDeadlockDetection_kb05 > 0)
                    AND
                    (ReqRow^.rtRow_kb05^.rlFirstReqRow_kb05 <> NIL)
                THEN
                    vbegexcl (t.trTaskId_gg00, g08lockreq);
                (*ENDIF*) 
                ReqRow^.rtRow_kb05^.rlExclTransIndex_kb05 := cgg_nil_transindex;
                k52flush_row_lock (ReqRow^.rtRow_kb05^);
                (**)
                IF  (k51glob.glDeadlockDetection_kb05 > 0)
                    AND
                    (ReqRow^.rtRow_kb05^.rlFirstReqRow_kb05 <> NIL)
                THEN
                    vendexcl (t.trTaskId_gg00, g08lockreq)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            vendexcl (t.trTaskId_gg00, g08lock0 + ReqRow^.rtRowRegion_kb05)
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND NOT Collided
THEN
    BEGIN
    k52begexcl_region (t.trTaskId_gg00, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
    kb51remove_trans_request (t.trTaskId_gg00, TransRgnGlobPtr^.rglTransGlob_kb05^, ThisTrans);
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
    (* *)
    kb51remove_tab_row_request (t.trTaskId_gg00, NOT REQUEST_TIMEOUT,
          ThisTrans^.teOwnIndex_kb05, ReqTab, ReqRow)
    END;
(*ENDIF*) 
k52begexcl_region (t.trTaskId_gg00, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
IF  (t.trError_gg00 = e_ok) AND NOT Collided
THEN
    BEGIN
    ThisTrans^.teReqTimeout_kb05 := g01timeout.timeReq_gg00;
    kb51trans_lock_mode_insert (TransRgnGlobPtr^.rglTransGlob_kb05^,
          ThisTrans, Collided, WantedLock.wlMode_kb05, WantedLock.wlState_kb05);
    kb51ins_tab_mode  (ReqTab, WantedLock.wlMode_kb05, WantedLock.wlState_kb05);
    IF  ReqRow <> NIL
    THEN
        kb51ins_row_mode (ReqRow, WantedLock.wlMode_kb05, WantedLock.wlState_kb05,
              TabOptimVers, RowOptimVers)
    (*ENDIF*) 
    END;
(*ENDIF*) 
k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
IF  (t.trError_gg00 = e_ok) AND Collided
THEN
    t.trError_gg00 := e_wait_for_lock_release
(*ENDIF*) 
END;
 
(* removed kb51min_objseq_assign: PTS 1105435 JA 2000-02-01 *)
(* new  PTS 1130054 FF 2004-06-11 *)
(*------------------------------*) 
 
PROCEDURE
      kb51max_transid_assign (
            VAR destin : tgg91_TransNo;
            source : tgg91_TransNo);
 
BEGIN
IF  gg06IsNilTrans (destin)
THEN
    destin := source
ELSE
    IF  NOT gg06IsNilTrans (source) AND (destin.ci6_gg00 < source.ci6_gg00)
    THEN
        destin := source
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51min_transid_assign (
            VAR destin : tgg91_TransNo;
            source : tgg91_TransNo);
 
BEGIN
IF  gg06IsNilTrans (destin)
THEN
    destin := source
ELSE
    IF  NOT gg06IsNilTrans (source) AND (destin.ci6_gg00 > source.ci6_gg00)
    THEN
        destin := source
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51new_req (
            VAR t             : tgg00_TransContext;
            VAR ReqRegionGlob : tkb05_RegionGlob;
            WantedMode        : tgg00_LockReqMode;
            WantedState       : tgg00_LockReqState;
            TransLockMode     : tkb05_TransLockMode;
            OwnLockMode       : tgg00_LockReqMode;
            OwnRowShare       : tsp00_Int4;
            OwnRowExcl        : tsp00_Int4;
            VAR FirstReq      : tkb05_ReqPtr;
            VAR WaitInserted  : boolean);
 
VAR
      NewReq      : tkb05_ReqPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
      ThisTrans   : tkb05_TransEntryPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08excl_check (t.trTaskId_gg00, g08lock0 + ReqRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
t.trError_gg00 := e_ok;
kb51get_supply_item (t, ReqRegionGlob, ikRequest_ekb05, UnivItemPtr);
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    NewReq                       := UnivItemPtr.uiReq_kb05;
    NewReq^.rqTransIndex_kb05    := t.trIndex_gg00;
    NewReq^.rqReqMode_kb05       := WantedMode;
    NewReq^.rqEotWanted_kb05     := lrsEotExcl_egg00 in WantedState;
    NewReq^.rqLockMode_kb05      := OwnLockMode;
    NewReq^.rqTransLockMode_kb05 := TransLockMode;
    NewReq^.rqRowShareLocks_kb05 := OwnRowShare;
    NewReq^.rqRowExclLocks_kb05  := OwnRowExcl;
    IF  FirstReq = NIL
    THEN
        FirstReq := NewReq
    ELSE
        BEGIN
        IF  FirstReq^.rqLastReq_kb05 = NIL
        THEN
            FirstReq^.rqNextReq_kb05 := NewReq
        ELSE
            FirstReq^.rqLastReq_kb05^.rqNextReq_kb05 := NewReq;
        (*ENDIF*) 
        FirstReq^.rqLastReq_kb05 := NewReq
        END;
    (*ENDIF*) 
&   ifdef TRACE
    k52xreq (kb_lockentry, NewReq);
&   endif
    IF  NOT WaitInserted
    THEN
        BEGIN
        vbegexcl (t.trTaskId_gg00, g08lockwait);
        k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
        ThisTrans^.teWaiting_kb05 := true;
        k52flush_trans_waiting (ThisTrans^.teWaiting_kb05);
        vendexcl (t.trTaskId_gg00, g08lockwait);
        WaitInserted := true
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51new_tablock (
            VAR t             : tgg00_TransContext;
            VAR TabRegionGlob : tkb05_RegionGlob;
            TabHash           : tsp00_Int4;
            PrevTab           : tkb05_TabLockPtr;
            VAR TabLock       : tkb05_TabLockPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
IF  g01vtrace.vtrCheck_gg00
THEN
    g08excl_check (t.trTaskId_gg00, g08lock0 + TabRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
t.trError_gg00 := e_ok;
kb51get_supply_item (t, TabRegionGlob, ikTabLock_ekb05, UnivItemPtr);
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    TabLock := UnivItemPtr.uiTabLock_kb05;
    IF  PrevTab = NIL
    THEN
        BEGIN
        TabLock^.tlNextHashTab_kb05             := TabRegionGlob.rglTabHash_kb05^[TabHash];
        TabRegionGlob.rglTabHash_kb05^[TabHash] := TabLock
        END
    ELSE
        BEGIN
        TabLock^.tlNextHashTab_kb05 := PrevTab^.tlNextHashTab_kb05;
        PrevTab^.tlNextHashTab_kb05 := TabLock
        END;
    (*ENDIF*) 
    ;
&   ifdef TRACE
    IF  kb03Check.chkLockSupply_kb00
    THEN
        k52xaddr_tabl_check (TabRegionGlob, TabLock);
&   endif
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51new_trans (
            VAR t               : tgg00_TransContext;
            AccessedTransRgnPtr : tkb05_RegionGlobPtr);
 
VAR
      TransRegion     : tkb05_RegionNo;
      TransHash       : tsp00_Int4;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
      NewTransEntry   : tkb05_TransEntryPtr;
 
BEGIN
&ifdef TRACE
ta01SessionTrans (kb_lock, 'new Trans   ',
      t.trSessionId_gg00, t.trTransId_gg00, t.trWriteTransId_gg00, t.trSubtransId_gg00);
&endif
t.trError_gg00 := e_ok;
t.trIndex_gg00 := cgg_nil_transindex;
NewTransEntry  := NIL;
kb51trans_hash (t.trSessionId_gg00, TransHash);
TransRegion := kb51trans_region (t.trSessionId_gg00);
IF  AccessedTransRgnPtr = NIL
THEN
    k52begexcl_region (t.trTaskId_gg00, TransRegion, TransRgnGlobPtr)
ELSE
    BEGIN
    TransRgnGlobPtr := AccessedTransRgnPtr;
    IF  kb03Check.chkRegion_kb00
    THEN
        BEGIN
        g08excl_check (t.trTaskId_gg00, g08lock0 + TransRegion);
        (* *)
        g01check (kbMsg_csp03, csp3_n_lock,
              'kb51row_fr: wrong TabReg', TransRegion,
              TransRegion = TransRgnGlobPtr^.rglOwnRegion_kb05)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  TransRgnGlobPtr^.rglTransGlob_kb05^.trFirstFree_kb05 = NIL
THEN
    t.trError_gg00 := e_too_many_lock_requests
ELSE
    WITH TransRgnGlobPtr^.rglTransGlob_kb05^ DO
        BEGIN
        NewTransEntry      := trFirstFree_kb05;
        trFirstFree_kb05   := NewTransEntry^.teNextTrans_kb05;
        trFreeEntries_kb05 := trFreeEntries_kb05 - 1;
        t.trIndex_gg00     := NewTransEntry^.teOwnIndex_kb05;
        NewTransEntry^     := k51glob.glNilTransEntry_kb05; (* --> own_addr/index/Region := nil *)
        NewTransEntry^.teOwnAddr_kb05   := NewTransEntry;   (* restore *)
        NewTransEntry^.teOwnIndex_kb05  := t.trIndex_gg00;  (* restore *)
        NewTransEntry^.teOwnRegion_kb05 := TransRegion;     (* restore *)
        NewTransEntry^.teNextTrans_kb05 := trFirst_kb05;
        IF  trFirst_kb05 <> NIL
        THEN
            trFirst_kb05^.tePrevTrans_kb05 := NewTransEntry;
        (*ENDIF*) 
        trFirst_kb05 := NewTransEntry;
        (* TRANS HASH LIST *)
        NewTransEntry^.teNextHash_kb05 := trTransHash_kb05^[TransHash];
        IF  trTransHash_kb05^[TransHash] <> NIL
        THEN
            trTransHash_kb05^[TransHash]^.tePrevHash_kb05 := NewTransEntry;
        (*ENDIF*) 
        trTransHash_kb05^[TransHash] := NewTransEntry;
        WITH NewTransEntry^ DO
            BEGIN
            teSessionId_kb05     := t.trSessionId_gg00;
            teWriteTransId_kb05  := t.trWriteTransId_gg00;
            teSubtransId_kb05    := t.trSubtransId_gg00;
            teSelectTransId_kb05 := t.trTransId_gg00;
            teTaskId_kb05        := t.trTaskId_gg00;
            teCancelAddr_kb05    := t.trRteCommPtr_gg00;
            teReqTimeout_kb05    := g01timeout.timeReq_gg00;
            (* NEXT NOT FOR REDO TRANSACTIONS - UH 2004-02-05 *)
            bd170CreateUserFiledirectory (t, teLocalFileDirPtr_kb05);
            t.trLocalFileDirPtr_gg00 := teLocalFileDirPtr_kb05;
            k512MonStartTransaction( t, teExtTransMonPtr_kb05);
            kb509SetTransactionStartTime(NewTransEntry^);             (* PTS 1131982 FF 28-OCT-2004 *)
            teOmsLockMode_kb05   := tlmFree_ekb05;                    (* PTS 1131932 FF 14-OCT-2004 *)
            t.trClusterIOPtr_gg00  := NIL;
            t.trClusterIOSize_gg00 := 0;
            END;
        (*ENDWITH*) 
        trConnectOnlyCnt_kb05 := trConnectOnlyCnt_kb05 + 1;
&       ifdef TRACE
        t01p2int4 (kb_lock, 'connect only', trConnectOnlyCnt_kb05
              ,             'new transidx', t.trIndex_gg00);
&       endif
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  AccessedTransRgnPtr = NIL
THEN
    BEGIN
    IF  NewTransEntry <> NIL
    THEN
        k52flush_trans_entry (NewTransEntry^);
    (*ENDIF*) 
    k52flush_trans_glob  (TransRgnGlobPtr^.rglTransGlob_kb05^);
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr)
    END;
(*ENDIF*) 
;
&ifdef TRACE
t01addr        (kb_lock, 'newTrnsEntry', NewTransEntry);
t01basis_error (kb_lock, 'end new_tran', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51_NextOpenRedoTrans (
            TaskId         : tsp00_TaskId;
            VAR TransIndex : tgg00_TransIndex;
            GetFirst       : boolean);
 
VAR
      TransCnt   : tsp00_Int4;
      TransLimit : tsp00_Int4;
      CurrRegion : tkb05_RegionNo;
      CurrTrans  : tkb05_TransEntryPtr;
 
BEGIN
IF  GetFirst
THEN
    BEGIN
    CurrRegion := 1;
    CurrTrans  := NIL
    END
ELSE
    BEGIN
    k52acc_trans_entry (TransIndex, CurrTrans);
    CurrRegion := CurrTrans^.teOwnRegion_kb05;
    CurrTrans  := CurrTrans^.teNextTrans_kb05;
    IF  CurrTrans = NIL
    THEN
        CurrRegion := CurrRegion + 1
    (*ENDIF*) 
    END;
(*ENDIF*) 
TransIndex := cgg_nil_transindex;
WHILE (CurrRegion <= k51glob.glTransRegions_kb05) AND (TransIndex = cgg_nil_transindex) DO
    BEGIN
    ;
    vbegexcl (TaskId, g08lock0 + CurrRegion);
    ;
    IF  CurrTrans = NIL
    THEN
        CurrTrans := k51glob.glRegionGlob_kb05^[CurrRegion]^.rglTransGlob_kb05^.trFirst_kb05;
    (*ENDIF*) 
    TransLimit := k52used_trans_of_region (k51glob.glRegionGlob_kb05^[CurrRegion]^);
    TransCnt   := 0;
    WHILE (CurrTrans <> NIL) AND (TransCnt <= TransLimit) AND (TransIndex = cgg_nil_transindex) DO
        IF  (CurrTrans^.teLog_kb05.tlogTransPtr_kb05 <> NIL)
            AND
            kb560TransactionIsOpen (CurrTrans^.teLog_kb05.tlogTransPtr_kb05)
        THEN
            TransIndex := CurrTrans^.teOwnIndex_kb05
        ELSE
            BEGIN
            CurrTrans := CurrTrans^.teNextTrans_kb05;
            TransCnt  := TransCnt + 1
            END;
        (*ENDIF*) 
    (*ENDWHILE*) 
    IF  TransCnt > TransLimit
    THEN
        k52x_loop_error ('kb51GetNextOpenRedoTrans', 1);
    (*ENDIF*) 
    ;
    vendexcl (TaskId, g08lock0 + CurrRegion);
    ;
    IF  TransIndex = cgg_nil_transindex
    THEN
        CurrRegion := CurrRegion + 1
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
;
&ifdef TRACE
t01int4 (kb_lock, 'OpTransIndex', TransIndex);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51_NextWriteTrans (
            VAR WriteTransIndex : tgg00_TransIndex;
            GetFirst : boolean);
 
VAR
      TransCnt   : tsp00_Int4;
      TransLimit : tsp00_Int4;
      CurrRegion : tkb05_RegionNo;
      CurrTrans  : tkb05_TransEntryPtr;
 
BEGIN
IF  GetFirst
THEN
    BEGIN
    CurrRegion := 1;
    CurrTrans  := NIL
    END
ELSE
    BEGIN
    k52acc_trans_entry (WriteTransIndex, CurrTrans);
    CurrRegion := CurrTrans^.teOwnRegion_kb05;
    CurrTrans  := CurrTrans^.teNextTrans_kb05;
    IF  CurrTrans = NIL
    THEN
        CurrRegion := CurrRegion + 1
    (*ENDIF*) 
    END;
(*ENDIF*) 
WriteTransIndex := cgg_nil_transindex;
WHILE (CurrRegion <= k51glob.glTransRegions_kb05) AND (WriteTransIndex = cgg_nil_transindex) DO
    BEGIN
    IF  kb03Check.chkRegion_kb00
    THEN
        g08check_excl (g08lock0 + CurrRegion);
    (*ENDIF*) 
    IF  CurrTrans = NIL
    THEN
        CurrTrans := k51glob.glRegionGlob_kb05^[CurrRegion]^.rglTransGlob_kb05^.trFirst_kb05;
    (*ENDIF*) 
    TransLimit := k52used_trans_of_region (k51glob.glRegionGlob_kb05^[CurrRegion]^);
    TransCnt   := 0;
    WHILE (CurrTrans <> NIL) AND (TransCnt <= TransLimit) AND (WriteTransIndex = cgg_nil_transindex) DO
        IF  CurrTrans^.teLog_kb05.tlogTransPtr_kb05 <> NIL
        THEN
            WriteTransIndex := CurrTrans^.teOwnIndex_kb05
        ELSE
            BEGIN
            CurrTrans := CurrTrans^.teNextTrans_kb05;
            TransCnt  := TransCnt + 1
            END;
        (*ENDIF*) 
    (*ENDWHILE*) 
    IF  TransCnt > TransLimit
    THEN
        k52x_loop_error ('kb51GetNextWriteTrans   ', 1);
    (*ENDIF*) 
    IF  WriteTransIndex = cgg_nil_transindex
    THEN
        CurrRegion := CurrRegion + 1
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
;
&ifdef TRACE
t01int4 (kb_lock, 'WrTransIndex', WriteTransIndex);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      kb51number_of_trans_regions: tsp00_Int2;
 
VAR
      TransRegions : tsp00_Int2;
 
BEGIN
(* PTS 1104245 JA 2000-02-08 *)
TransRegions := g01region_cnt (rgnTrans_egg00);
IF  TransRegions  < 1
THEN
    TransRegions := 1
ELSE
    IF  TransRegions  > MAX_TRANS_REGIONS_KB05
    THEN
        TransRegions := MAX_TRANS_REGIONS_KB05;
    (*ENDIF*) 
(*ENDIF*) 
kb51number_of_trans_regions := TransRegions
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51_ObjReqTimeoutHandling (
            VAR Trans : tgg00_TransContext;
            ReqTrans : tkb05_TransEntryPtr);
 
VAR
      CurrReq        : tgg00_TransIndex;
      ReqCnt         : tsp00_Int4;
      CollEntry      : tkb05_ObjCollEntryPtr;
      ReqEntry       : tkb05_ObjReqEntryPtr;
      ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08excl_check (Trans.trTaskId_gg00, g08lock0 + ReqTrans^.teOwnRegion_kb05);
(*ENDIF*) 
IF  ReqTrans^.teObjReq_kb05 <> cgg_nil_transindex
THEN
    BEGIN
    IF  g01vtrace.vtrAll_gg00
    THEN
        kb51_TraceReqTimeout (Trans, ReqTrans);
    (*ENDIF*) 
    k52begexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
    k52acc_objcoll_entry (ObjCollGlobPtr^, ReqTrans^.teObjReq_kb05, CollEntry);
    CurrReq := CollEntry^.objcFirstReq_kb05;
    ReqCnt  := 0;
    WHILE (CurrReq <> cgg_nil_transindex) AND (ReqCnt <= k51glob.glTransEntries_kb05) DO
        BEGIN
        k52acc_objreq_entry (ObjCollGlobPtr^, CurrReq, ReqEntry);
        IF  ReqEntry^.objrReqTransId_kb05 = ReqTrans^.teWriteTransId_kb05
        THEN
            BEGIN
            IF  ReqEntry^.objrWaitTaskId_kb05 = ReqTrans^.teTaskId_kb05
            THEN
                (* still waiting *)
                BEGIN
                ReqEntry^.objrWaitTaskId_kb05 := cgg_nil_pid;
                k52flush_objreq_entry (ReqEntry^);
                (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
                vsignal (ReqTrans^.teTaskId_kb05, NOT IS_OK);
                (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
                END;
            (*ENDIF*) 
            CurrReq := cgg_nil_transindex
            END
        ELSE
            CurrReq := ReqEntry^.objrNextReq_kb05;
        (*ENDIF*) 
        ReqCnt := ReqCnt + 1
        END;
    (*ENDWHILE*) 
    k52endexcl_objcoll (Trans.trTaskId_gg00, ObjCollGlobPtr);
    IF  ReqCnt > k51glob.glTransEntries_kb05
    THEN
        k52x_loop_error ('kb51_ObjReqTimeoutHandli', 1)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51r_release_row_lock (
            TaskId                   : tsp00_TaskId;
            VAR RowRegionGlob        : tkb05_RegionGlob;
            TransIndex               : tgg00_TransIndex;
            RowTrans                 : tkb05_RowTransPtr;
            SatisfyRequests          : boolean);
 
VAR
      Row : tkb05_RowLockPtr;
 
BEGIN
&ifdef TRACE
k52xrow_trans (kb_lockentry, RowTrans);
&endif
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (TaskId, g08lock0 + RowTrans^.rtRowRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51rt_rel: wrong RowReg',
          RowTrans^.rtRowRegion_kb05,
          RowTrans^.rtRowRegion_kb05 = RowRegionGlob.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
Row := RowTrans^.rtRow_kb05;
IF  Row^.rlItemKind_kb05 <> ikRowLock_ekb05
THEN
    k52x_item_error ('kb51r_release_row_lock  ', Row^.rlItemKind_kb05);
(*ENDIF*) 
CASE RowTrans^.rtLockMode_kb05 OF
    lckRowShare_egg00:
        BEGIN
        Row^.rlRowShareLocks_kb05 := Row^.rlRowShareLocks_kb05 - 1;
        IF  k51glob.glDeadlockDetection_kb05 > 0
        THEN
            BEGIN
            IF  (Row^.rlShare1TransIndex_kb05 = TransIndex) OR
                (Row^.rlShare2TransIndex_kb05 = TransIndex)
            THEN
                BEGIN
                IF  Row^.rlFirstReqRow_kb05 <> NIL
                THEN
                    vbegexcl (TaskId, g08lockreq);
                (*ENDIF*) 
                IF  Row^.rlShare1TransIndex_kb05 = TransIndex
                THEN
                    Row^.rlShare1TransIndex_kb05 := cgg_nil_transindex
                ELSE
                    Row^.rlShare2TransIndex_kb05 := cgg_nil_transindex;
                (*ENDIF*) 
                IF  Row^.rlFirstReqRow_kb05 <> NIL
                THEN
                    BEGIN
                    k52flush_row_lock (Row^);
                    vendexcl (TaskId, g08lockreq)
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    lckRowOptimistic_egg00:
        Row^.rlRowOptimCnt_kb05 := Row^.rlRowOptimCnt_kb05 - 1;
    lckRowExcl_egg00:
        (* in case of keep Lock TransIndex may be overwritten *)
        IF  Row^.rlExclTransIndex_kb05 = TransIndex
        THEN
            BEGIN
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                (Row^.rlFirstReqRow_kb05 <> NIL)
            THEN
                vbegexcl (TaskId, g08lockreq);
            (*ENDIF*) 
            Row^.rlExclTransIndex_kb05 := cgg_nil_transindex;
            (**)
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                (Row^.rlFirstReqRow_kb05 <> NIL)
            THEN
                BEGIN
                k52flush_row_lock (Row^);
                vendexcl (TaskId, g08lockreq)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    OTHERWISE ;
    END;
(*ENDCASE*) 
&ifdef TRACE
k52xrow_lock (kb_lockentry, Row);
&endif
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g01check (kb51c1RReleaseRowLock_csp03, csp3_n_lock,
          'rel Row: Row share < 0  ', Row^.rlRowShareLocks_kb05,
          Row^.rlRowShareLocks_kb05 >= 0);
    (* *)
    g01check (kb51c2RReleaseRowLock_csp03, csp3_n_lock,
          'rel Row: Row optim < 0  ', Row^.rlRowOptimCnt_kb05,
          Row^.rlRowOptimCnt_kb05 >= 0)
    END;
(*ENDIF*) 
IF  SatisfyRequests
THEN
    kb51r_satisfy_row_lock (TaskId, RowRegionGlob, Row);
(*ENDIF*) 
kb51try_free_row_lock (TaskId, RowRegionGlob, Row, RowTrans^.rtRowHash_kb05);
IF  Row = NIL
THEN
    RowTrans^.rtRow_kb05 := NIL
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51r_satisfy_row_lock (
            TaskId                   : tsp00_TaskId;
            VAR RowRegionGlob        : tkb05_RegionGlob;
            Row                      : tkb05_RowLockPtr);
 
VAR
      CollisionErr : tgg00_BasisError;
      ItemCnt      : tsp00_Int4;
      CurrReq      : tkb05_ReqPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00
THEN
    g08excl_check (TaskId, g08lock0 + RowRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
IF  Row^.rlItemKind_kb05 <> ikRowLock_ekb05
THEN
    k52x_item_error ('kb51r_satisfy_row_lock/1', Row^.rlItemKind_kb05);
(*ENDIF*) 
CollisionErr := e_ok;
CurrReq      := Row^.rlFirstReqRow_kb05;
ItemCnt      := 0;
WHILE (CurrReq <> NIL) AND (CollisionErr = e_ok)
      AND
      (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
    BEGIN
&   ifdef TRACE
    k52xreq (kb_lockentry, CurrReq);
&   endif
    IF  CurrReq^.rqItemKind_kb05 <> ikRequest_ekb05
    THEN
        k52x_item_error ('kb51r_satisfy_row_lock/2', CurrReq^.rqItemKind_kb05);
    (*ENDIF*) 
    kb51row_collision (CurrReq^.rqTransIndex_kb05, Row,
          CurrReq^.rqReqMode_kb05, [], CurrReq^.rqRowShareLocks_kb05,
          CollisionErr);
    IF  CollisionErr = e_lock_collision
    THEN
        CollisionErr := e_ok (* PTS 1122307 UH 2003-06-17 *)
    ELSE
        BEGIN
        IF  CurrReq^.rqReqMode_kb05 <> lckRowExcl_egg00
        THEN
            CollisionErr := e_ok (* PTS 1122307 UH 2003-06-17 *)
        ELSE
            (* reservation of Row excl Lock *)
            BEGIN
            CollisionErr := e_lock_collision; (* PTS 1122307 UH 2003-06-17 *)
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                (Row^.rlFirstReqRow_kb05 <> NIL)
            THEN
                vbegexcl (TaskId, g08lockreq);
            (*ENDIF*) 
            Row^.rlExclTransIndex_kb05 := CurrReq^.rqTransIndex_kb05;
            (**)
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                (Row^.rlFirstReqRow_kb05 <> NIL)
            THEN
                BEGIN
                k52flush_row_lock (Row^);
                vendexcl (TaskId, g08lockreq)
                END;
            (*ENDIF*) 
            IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00
            THEN
                kb51vtrace_row (m_insert, mm_key,
                      CurrReq^.rqTransIndex_kb05, CurrReq^.rqReqMode_kb05, Row)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        kb51signal_resume (TaskId, CurrReq^.rqTransIndex_kb05, IS_OK)
        END;
    (*ENDIF*) 
    ItemCnt := ItemCnt + 1;
    CurrReq := CurrReq^.rqNextReq_kb05
    END;
(*ENDWHILE*) 
IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
THEN
    k52x_loop_error ('kb51r_satisfy_row_lock  ', 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51remove_tab_row_request (
            TaskId           : tsp00_TaskId;
            IsRequestTimeout : boolean;
            OwnTransIndex    : tgg00_TransIndex;
            ReqTab           : tkb05_TabTransPtr;
            ReqRow           : tkb05_RowTransPtr);
 
VAR
      TabRgnGlobPtr : tkb05_RegionGlobPtr;
      RowRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
k52begexcl_region (TaskId, ReqTab^.ttTabRegion_kb05, TabRgnGlobPtr);
&ifdef TRACE
k52xtab_lock (kb_lockentry, ReqTab^.ttTab_kb05);
&endif
IF  (OwnTransIndex = ReqTab^.ttTab_kb05^.tlExclTransIndex_kb05)
    AND
    IsRequestTimeout
    AND
    (ReqTab^.ttLockMode_kb05 <> lckTabExcl_egg00)
THEN
    (* delete reservation of Tab excl Lock *)
    BEGIN
    IF  (k51glob.glDeadlockDetection_kb05 > 0)
        AND
        ((ReqTab^.ttTab_kb05^.tlFirstReqTab_kb05 <> NIL) OR
        ( ReqTab^.ttTab_kb05^.tlFirstReqRow_kb05 <> NIL))
    THEN
        vbegexcl (TaskId, g08lockreq);
    (*ENDIF*) 
    ReqTab^.ttTab_kb05^.tlExclTransIndex_kb05 := cgg_nil_transindex;
    (**)
    IF  (k51glob.glDeadlockDetection_kb05 > 0)
        AND
        ((ReqTab^.ttTab_kb05^.tlFirstReqTab_kb05 <> NIL) OR
        ( ReqTab^.ttTab_kb05^.tlFirstReqRow_kb05 <> NIL))
    THEN
        BEGIN
        k52flush_tab_lock (ReqTab^.ttTab_kb05^);
        vendexcl (TaskId, g08lockreq)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  ReqRow = NIL
THEN
    kb51free_req (TaskId, TabRgnGlobPtr^, OwnTransIndex, ReqTab^.ttTab_kb05^.tlFirstReqTab_kb05)
ELSE
    kb51free_req (TaskId, TabRgnGlobPtr^, OwnTransIndex, ReqTab^.ttTab_kb05^.tlFirstReqRow_kb05);
(*ENDIF*) 
kb51t_satisfy_tab_lock (TaskId, TabRgnGlobPtr^, ReqTab^.ttTab_kb05, ReqTab^.ttReqMode_kb05);
kb51try_free_tab_lock  (TaskId, TabRgnGlobPtr^, ReqTab^.ttTab_kb05, ReqTab^.ttTabHash_kb05);
&ifdef TRACE
IF  kb03Check.chkLockSupply_kb00
THEN
    k52xtab_region_check (TabRgnGlobPtr^);
&endif
(*ENDIF*) 
k52endexcl_region (TaskId, TabRgnGlobPtr);
IF  ReqRow <> NIL
THEN
    BEGIN
    k52begexcl_region (TaskId, ReqRow^.rtRowRegion_kb05, RowRgnGlobPtr);
&   ifdef TRACE
    k52xrow_lock (kb_lockentry, ReqRow^.rtRow_kb05);
&   endif
    IF  (OwnTransIndex = ReqRow^.rtRow_kb05^.rlExclTransIndex_kb05)
        AND
        IsRequestTimeout
        AND
        (ReqRow^.rtLockMode_kb05 <> lckRowExcl_egg00)
    THEN
        (* delete reservation of Row excl Lock *)
        BEGIN
        IF  (k51glob.glDeadlockDetection_kb05 > 0)
            AND
            (ReqRow^.rtRow_kb05^.rlFirstReqRow_kb05 <> NIL)
        THEN
            vbegexcl (TaskId, g08lockreq);
        (*ENDIF*) 
        ReqRow^.rtRow_kb05^.rlExclTransIndex_kb05 := cgg_nil_transindex;
        (**)
        IF  (k51glob.glDeadlockDetection_kb05 > 0)
            AND
            (ReqRow^.rtRow_kb05^.rlFirstReqRow_kb05 <> NIL)
        THEN
            BEGIN
            k52flush_row_lock (ReqRow^.rtRow_kb05^);
            vendexcl (TaskId, g08lockreq)
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    kb51free_req (TaskId, RowRgnGlobPtr^, OwnTransIndex, ReqRow^.rtRow_kb05^.rlFirstReqRow_kb05);
    kb51r_satisfy_row_lock (TaskId, RowRgnGlobPtr^, ReqRow^.rtRow_kb05);
    kb51try_free_row_lock (TaskId, RowRgnGlobPtr^, ReqRow^.rtRow_kb05, ReqRow^.rtRowHash_kb05);
&   ifdef TRACE
    IF  kb03Check.chkLockSupply_kb00
    THEN
        k52xrow_region_check (RowRgnGlobPtr^);
&   endif
    (*ENDIF*) 
    k52endexcl_region (TaskId, RowRgnGlobPtr)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51remove_trans_request (
            TaskId        : tsp00_TaskId;
            VAR TransGlob : tkb05_TransGlob;
            ThisTrans     : tkb05_TransEntryPtr);
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08check_excl (g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51remove: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransGlob.trOwnRegion_kb05)
    END;
(*ENDIF*) 
IF  k51glob.glDeadlockDetection_kb05 > 0
THEN
    vbegexcl (TaskId, g08lockreq);
(*ENDIF*) 
ThisTrans^.teReqTab_kb05^.ttReqMode_kb05  := lckFree_egg00;
ThisTrans^.teReqTab_kb05^.ttReqState_kb05 := [ ];
IF  ThisTrans^.teReqRow_kb05 <> NIL
THEN
    BEGIN
    ThisTrans^.teReqRow_kb05^.rtReqMode_kb05  := lckFree_egg00;
    ThisTrans^.teReqRow_kb05^.rtReqState_kb05 := [ ]
    END;
(*ENDIF*) 
ThisTrans^.teReqMode_kb05 := tlmFree_ekb05;
ThisTrans^.teReqTab_kb05  := NIL;
ThisTrans^.teReqRow_kb05  := NIL;
(**)
IF  k51glob.glDeadlockDetection_kb05 > 0
THEN
    BEGIN
    k52flush_trans_entry (ThisTrans^);
    vendexcl (TaskId, g08lockreq)
    END;
(*ENDIF*) 
TransGlob.trReqTransCnt_kb05 := TransGlob.trReqTransCnt_kb05 - 1;
IF  (ThisTrans^.teLockMode_kb05    = tlmFree_ekb05) AND
    (ThisTrans^.teObjLockMode_kb05 = tlmFree_ekb05) (* JA 1998-08-24 *)
THEN
    TransGlob.trConnectOnlyCnt_kb05 := TransGlob.trConnectOnlyCnt_kb05 + 1;
(*ENDIF*) 
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g01check (kb51c1RemoveTransRequest_csp03, csp3_n_lock,
          'remove request: cnt < 0 ', TransGlob.trReqTransCnt_kb05,
          TransGlob.trReqTransCnt_kb05 >= 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51req_timeout_handling (
            VAR t                     : tgg00_TransContext;
            VAR TransRgnGlobPtr       : tkb05_RegionGlobPtr;
            ReqTrans                  : tkb05_TransEntryPtr);
 
VAR
      Row : tkb05_RowTransPtr;
      Tab : tkb05_TabTransPtr;
 
BEGIN
(* parameter TransRgnGlobPtr (var --> var Ptr): PTS 1106270 JA 2000-04-06 *)
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (t.trTaskId_gg00, g08lock0 + ReqTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51rm_tab: wrong Region',
          ReqTrans^.teOwnRegion_kb05,
          ReqTrans^.teOwnRegion_kb05 = TransRgnGlobPtr^.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
IF  ReqTrans^.teReqTab_kb05 <> NIL
THEN
    BEGIN
    IF  g01vtrace.vtrAll_gg00
    THEN
        kb51_TraceReqTimeout (t, ReqTrans);
    (*ENDIF*) 
    Tab := ReqTrans^.teReqTab_kb05;
    Row := ReqTrans^.teReqRow_kb05;
    IF  Tab^.ttItemKind_kb05 <> ikTabTrans_ekb05
    THEN
        k52x_item_error ('kb51req_timeout_handl/1 ', Tab^.ttItemKind_kb05);
    (*ENDIF*) 
    kb51remove_trans_request   (t.trTaskId_gg00, TransRgnGlobPtr^.rglTransGlob_kb05^, ReqTrans);
    (* *)
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);            (* PTS 1106270 JA 2000-04-06 *)
    kb51remove_tab_row_request (t.trTaskId_gg00, REQUEST_TIMEOUT,
          ReqTrans^.teOwnIndex_kb05, Tab, Row);
    k52begexcl_region (t.trTaskId_gg00, ReqTrans^.teOwnRegion_kb05, TransRgnGlobPtr);(*2000-04-06 *)
    (* *)
    IF  Row <> NIL
    THEN
        BEGIN
        IF  Row^.rtItemKind_kb05 <> ikRowTrans_ekb05
        THEN
            k52x_item_error ('kb51req_timeout_handl/2 ', Row^.rtItemKind_kb05);
        (*ENDIF*) 
        IF  Row^.rtLockMode_kb05 = lckFree_egg00
        THEN
            kb51rm_row_trans_remove (t.trTaskId_gg00, TransRgnGlobPtr^, ReqTrans, Tab, Row)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (Tab^.ttLockMode_kb05 = lckFree_egg00) AND
        (Tab^.ttFirstRow_kb05 = NIL)
    THEN
        kb51rm_tab_trans_remove (t.trTaskId_gg00, TransRgnGlobPtr^, ReqTrans, Tab);
    (*ENDIF*) 
    ReqTrans^.teReqTimeout_kb05 := g01timeout.timeReq_gg00;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51reset_trans_entry (ThisTrans : tkb05_TransEntryPtr);
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08check_excl (g08lock0 + ThisTrans^.teOwnRegion_kb05);
(*ENDIF*) 
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g01check (kb51c1ResetTransEntry_csp03, csp3_n_lock,
          'reset Trans: Lock exists', ThisTrans^.teOwnIndex_kb05,
          (ThisTrans^.teLockMode_kb05 = tlmFree_ekb05));
    (* *)
    g01check (kb51c2ResetTransEntry_csp03, csp3_n_lock,
          'reset Trans: Req exists ', ThisTrans^.teOwnIndex_kb05,
          (ThisTrans^.teReqMode_kb05 = tlmFree_ekb05));
    (* *)
    g01check (kb51c2ResetTransEntry_csp03, csp3_n_lock,
          'reset Trans: Req exists ', ThisTrans^.teOwnIndex_kb05,
          (ThisTrans^.teFirstTab_kb05 = NIL))
    END;
(*ENDIF*) 
WITH ThisTrans^ DO
    BEGIN
    IF  (teTaskId_kb05 <> cgg_nil_pid)
    THEN
        vprio (teTaskId_kb05, USER_LOCK_PRIO, NOT SET_PRIO);
    (*ENDIF*) 
    teTabRecentlyUsed_kb05 := NIL;
    teRowRecentlyUsed_kb05 := NIL;
    IF  tiExclusiveUser_ekb05 in teInfo_kb05
    THEN
        teInfo_kb05 := [tiExclusiveUser_ekb05]
    ELSE
        teInfo_kb05 := [ ];
    (*ENDIF*) 
    teLockMode_kb05      := tlmFree_ekb05;
    teReqMode_kb05       := tlmFree_ekb05;
    teReqTimeout_kb05    := g01timeout.timeReq_gg00;
    teTimeLastWrite_kb05 := 0;
    teState_kb05         := m_nil;
    teObjLockMode_kb05   := tlmFree_ekb05;
    teFirstCollLock_kb05 := cgg_nil_transindex;
    teObjReq_kb05        := cgg_nil_transindex;
    teObjReqTimeout_kb05 := 0;
    teWaiting_kb05       := false;
    teOmsLockMode_kb05   := tlmFree_ekb05;
    END;
(*ENDWITH*) 
ThisTrans^.teLog_kb05 := k51glob.glNilTransEntry_kb05.teLog_kb05
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51rm_row_trans_remove (
            TaskId                    : tsp00_TaskId;
            VAR TransRegionGlob       : tkb05_RegionGlob;
            ThisTrans                 : tkb05_TransEntryPtr;
            Tab                       : tkb05_TabTransPtr;
            VAR Row                   : tkb05_RowTransPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (TaskId, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51rm_row: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransRegionGlob.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
IF  Tab^.ttConsistentRow_kb05 = Row
THEN
    Tab^.ttConsistentRow_kb05 := NIL;
(*ENDIF*) 
IF  ThisTrans^.teRowRecentlyUsed_kb05 = Row
THEN
    BEGIN
    ThisTrans^.teTabRecentlyUsed_kb05 := NIL;
    ThisTrans^.teRowRecentlyUsed_kb05 := NIL
    END;
(*ENDIF*) 
IF  Row^.rtPrevRow_kb05 = NIL
THEN
    Tab^.ttFirstRow_kb05 := Row^.rtNextRow_kb05
ELSE
    Row^.rtPrevRow_kb05^.rtNextRow_kb05 := Row^.rtNextRow_kb05;
(*ENDIF*) 
IF  Row^.rtNextRow_kb05 <> NIL
THEN
    Row^.rtNextRow_kb05^.rtPrevRow_kb05 := Row^.rtPrevRow_kb05;
(*ENDIF*) 
UnivItemPtr.uiRowTrans_kb05 := Row;
Row := NIL; (* JA 1998-09-25 *)
kb51free_supply_item (TaskId, TransRegionGlob, UnivItemPtr, ikRowTrans_ekb05)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51rm_tab_trans_remove (
            TaskId                    : tsp00_TaskId;
            VAR TransRegionGlob       : tkb05_RegionGlob;
            ThisTrans                 : tkb05_TransEntryPtr;
            VAR Tab                   : tkb05_TabTransPtr);
 
VAR
      ItemCnt     : tsp00_Int4;
      CurrTab     : tkb05_TabTransPtr;
      PrevTab     : tkb05_TabTransPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (TaskId, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51rm_tab: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransRegionGlob.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
PrevTab := NIL;
CurrTab := ThisTrans^.teFirstTab_kb05;
ItemCnt := 0;
WHILE (CurrTab <> Tab) AND (CurrTab <> NIL) AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
    BEGIN
    ItemCnt := ItemCnt + 1;
    PrevTab := CurrTab;
    CurrTab := CurrTab^.ttNextTab_kb05
    END;
(*ENDWHILE*) 
IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
THEN
    k52x_loop_error ('kb51rm_tab_trans_remove ', 1);
(*ENDIF*) 
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g01check (kb51c1RmTabTransRemove_csp03, csp3_n_lock,
          'tab_trans_remove: nil   ', ThisTrans^.teOwnIndex_kb05,
          CurrTab <> NIL);
(*ENDIF*) 
IF  PrevTab = NIL
THEN
    ThisTrans^.teFirstTab_kb05 := Tab^.ttNextTab_kb05
ELSE
    PrevTab^.ttNextTab_kb05    := Tab^.ttNextTab_kb05;
(*ENDIF*) 
WITH ThisTrans^ DO
    IF  teTabRecentlyUsed_kb05 = Tab
    THEN
        BEGIN
        teTabRecentlyUsed_kb05 := NIL;
        teRowRecentlyUsed_kb05 := NIL
        END;
    (*ENDIF*) 
(*ENDWITH*) 
UnivItemPtr.uiTabTrans_kb05 := Tab;
Tab := NIL; (* JA 1998-09-25 *)
kb51free_supply_item (TaskId, TransRegionGlob, UnivItemPtr, ikTabTrans_ekb05)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51row_already_locked (
            TaskId            : tsp00_TaskId;
            ThisTrans         : tkb05_TransEntryPtr;
            Row               : tkb05_RowTransPtr;
            VAR WantedLock    : tkb05_WantedLock;
            VAR AlreadyLocked : boolean);
 
VAR
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
AlreadyLocked   := false;
TransRgnGlobPtr := NIL;
CASE WantedLock.wlMode_kb05 OF
    lckRowOptimistic_egg00:
        AlreadyLocked := (Row^.rtLockMode_kb05 <> lckFree_egg00);
    lckRowShare_egg00:
        AlreadyLocked :=
              (Row^.rtLockMode_kb05 = lckRowShare_egg00) OR
              (Row^.rtLockMode_kb05 = lckRowExcl_egg00 );
    lckRowExcl_egg00:
        AlreadyLocked := (Row^.rtLockMode_kb05 = lckRowExcl_egg00);
    OTHERWISE
        AlreadyLocked := false
    END;
(*ENDCASE*) 
IF  AlreadyLocked
    AND NOT (lrsEotExcl_egg00 in   Row^.rtLockState_kb05)
    AND     (lrsEotExcl_egg00 in WantedLock.wlState_kb05)
THEN
    BEGIN
    vbegexcl (TaskId, g08lock0 + Row^.rtRowRegion_kb05);
    WITH Row^.rtRow_kb05^ DO
        rlRowOptimVers_kb05 := rlRowOptimVers_kb05 + 1;
    (*ENDWITH*) 
    k52flush_row_lock (Row^.rtRow_kb05^);
    vendexcl (TaskId, g08lock0 + Row^.rtRowRegion_kb05);
    (**)
    k52begexcl_region (TaskId, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
    IF  ThisTrans^.teLockMode_kb05 = tlmEotExcl_ekb05
    THEN
        BEGIN
        ThisTrans^.teLockMode_kb05 := tlmEotExcl_ekb05;
        Row^.rtLockState_kb05      := Row^.rtLockState_kb05 + [lrsEotExcl_egg00]
        END
    ELSE
        AlreadyLocked := false
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  AlreadyLocked
    AND  NOT (lrsConsistent_egg00 in WantedLock.wlState_kb05)
    AND  (    lrsConsistent_egg00 in Row^.rtLockState_kb05  )
THEN
    BEGIN
    IF  TransRgnGlobPtr = NIL
    THEN
        k52begexcl_region (TaskId, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
    (*ENDIF*) 
    Row^.rtLockState_kb05 := Row^.rtLockState_kb05 - [lrsConsistent_egg00]
    END;
(*ENDIF*) 
IF  TransRgnGlobPtr <> NIL
THEN
    BEGIN
    k52flush_row_trans   (Row^);
    k52flush_trans_entry (ThisTrans^);
    k52endexcl_region (TaskId, TransRgnGlobPtr)
    END;
(*ENDIF*) 
IF  AlreadyLocked
THEN
    WantedLock.wlGrantedMode_kb05 := Row^.rtLockMode_kb05;
(*ENDIF*) 
;
&ifdef TRACE
t01bool (kb_lock, 'already_lock', AlreadyLocked);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51row_collision (
            TransIndex     : tgg00_TransIndex;
            RowLock        : tkb05_RowLockPtr;
            WantedLockMode : tgg00_LockReqMode;
            WantedLockState: tgg00_LockReqState;
            OwnRowShare    : tsp00_Int4;
            VAR err        : tgg00_BasisError);
 
VAR
      CollisionTrans : tkb05_TransEntryPtr;
 
BEGIN
(* within specific Row Region *)
&ifdef TRACE
k52xrow_lock (kb_lockentry, RowLock);
&endif
IF  RowLock^.rlItemKind_kb05 <> ikRowLock_ekb05
THEN
    k52x_item_error ('kb51row_collision       ', RowLock^.rlItemKind_kb05);
(*ENDIF*) 
err := e_ok;
WITH RowLock^ DO
    IF  (rlExclTransIndex_kb05 <> cgg_nil_transindex) AND
        (rlExclTransIndex_kb05 <> TransIndex        )
    THEN
        BEGIN
        IF  (lrsIgnoreInsert_egg00 in WantedLockState)
            AND
            (lrsForInsert_egg00 in rlLockState_kb05)
            AND
            (WantedLockMode = lckRowShare_egg00)
        THEN
            err := e_lock_collision_with_inserted_row
        ELSE
            BEGIN
            err := e_lock_collision;
            k52acc_trans_entry (rlExclTransIndex_kb05, CollisionTrans);
            IF  (CollisionTrans^.teReqMode_kb05 = tlmFree_ekb05)
                AND                                                  (* dirty read *)
                (tiUserTask_ekb05 in CollisionTrans^.teInfo_kb05)
            THEN
                vprio (CollisionTrans^.teTaskId_kb05, USER_LOCK_PRIO, SET_PRIO)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END
    ELSE
        IF  (WantedLockMode = lckRowExcl_egg00)
            AND
            (rlRowShareLocks_kb05 - OwnRowShare > 0)
        THEN
            err := e_lock_collision;
        (*ENDIF*) 
    (*ENDIF*) 
(*ENDWITH*) 
IF  (g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00) AND (err <> e_ok)
THEN
    kb51vtrace_row (m_lock, mm_key, TransIndex, WantedLockMode, RowLock);
(*ENDIF*) 
;
&ifdef TRACE
t01basis_error (kb_lock, 'end row_coll', err);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51row_from_tab_lock_release (
            TaskId            : tsp00_TaskId;
            AccessedTabRgnPtr : tkb05_RegionGlobPtr;
            TabRegion         : tkb05_RegionNo;
            TabHash           : tsp00_Int4;
            VAR TabLock       : tkb05_TabLockPtr;
            ReleaseRowMode    : tgg00_LockReqMode;
            HoldTabLock       : boolean);
 
VAR
      TabRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
&ifdef TRACE
t01lockmode (kb_lockentry, 'ReleaseMode ', ReleaseRowMode);
t01bool     (kb_lockentry, 'HoldTabLock ', HoldTabLock);
&endif
IF  AccessedTabRgnPtr = NIL
THEN
    k52begexcl_region (TaskId, TabRegion, TabRgnGlobPtr)
ELSE
    BEGIN
    TabRgnGlobPtr := AccessedTabRgnPtr;
    IF  kb03Check.chkRegion_kb00
    THEN
        BEGIN
        g08excl_check (TaskId, g08lock0 + TabRegion);
        (* *)
        g01check (kbMsg_csp03, csp3_n_lock,
              'kb51row_fr: wrong TabReg', TabRegion,
              TabRegion = TabRgnGlobPtr^.rglOwnRegion_kb05)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
CASE ReleaseRowMode OF
    lckRowShare_egg00:
        TabLock^.tlRowShareLocks_kb05 := TabLock^.tlRowShareLocks_kb05 - 1;
    lckRowOptimistic_egg00:
        TabLock^.tlRowOptimCnt_kb05   := TabLock^.tlRowOptimCnt_kb05   - 1;
    lckRowExcl_egg00:
        BEGIN
        TabLock^.tlRowExclLocks_kb05  := TabLock^.tlRowExclLocks_kb05  - 1;
        (* PTS 1139806 UH 2006-02-09 next *)
&       ifdef UWE
        IF  ForInsert in ReleaseRowState
        THEN
            TabLock^.tlRowExclLocksForInsert_kb05 := TabLock^.tlRowExclLocksForInsert_kb05 - 1;
&       endif
        (*ENDIF*) 
        END;
    OTHERWISE ;
    END;
(*ENDCASE*) 
&ifdef TRACE
t01p2int4 (kb_lock, 'RowShareLcks', TabLock^.tlRowShareLocks_kb05
      ,             'RowExclLocks', TabLock^.tlRowExclLocks_kb05);
&ifdef UWE
t01int4   (kb_lock, 'ForInsert   ', TabLock^.tlRowExclLocksForInsert_kb05);
&endif
&endif
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g01check (kb51c1RowFromTabLock_csp03, csp3_n_lock,
          'Row rel: Row share < 0  ', TabLock^.tlRowShareLocks_kb05,
          TabLock^.tlRowShareLocks_kb05 >= 0);
    (* *)
    g01check (kb51c2RowFromTabLock_csp03, csp3_n_lock,
          'Row rel: Row optim < 0  ', TabLock^.tlRowOptimCnt_kb05,
          TabLock^.tlRowOptimCnt_kb05 >= 0);
    (* *)
    g01check (kb51c3RowFromTabLock_csp03, csp3_n_lock,
          'Row rel: Row excl < 0   ', TabLock^.tlRowExclLocks_kb05,
          TabLock^.tlRowExclLocks_kb05 >= 0);
    (* *)
&   ifdef UWE
    g01check (kb51c3RowFromTabLock_csp03, csp3_n_lock,
          'Row rel: ForInsert < 0  ', TabLock^.tlRowExclLocksForInsert_kb05,
          TabLock^.tlRowExclLocksForInsert_kb05 >= 0);(* PTS 1139806 UH 2006-02-09 *)
&   endif
    END;
(*ENDIF*) 
kb51t_satisfy_tab_lock (TaskId, TabRgnGlobPtr^, TabLock, ReleaseRowMode);
IF  NOT HoldTabLock
THEN
    kb51try_free_tab_lock (TaskId, TabRgnGlobPtr^, TabLock, TabHash);
(*ENDIF*) 
IF  AccessedTabRgnPtr = NIL
THEN
    k52endexcl_region (TaskId, TabRgnGlobPtr)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51row_hash (
            VAR RowId         : tkb05_RowId;
            KeyLen            : tsp00_Int2;
            VAR RowHash       : tsp00_Int4;
            VAR RowRegion     : tkb05_RegionNo);
 
VAR
 
      Number : RECORD
            CASE integer OF
                1:
                    (n : tsp00_Int4);
                2:
                    (c : tsp00_C4)
                END;
            (*ENDCASE*) 
 
      absval : tsp00_Int4;
 
BEGIN
(* outside Region *)
IF  (KeyLen = 1 + sizeof (tgg00_Surrogate))
    AND
    (RowId [1] = csp_defined_byte)
THEN
    (* may be syskey *)
    Number.n := (ord (RowId [7]) + ord (RowId [3])) * 65536
          +      ord (RowId [8]) * 256
          +      ord (RowId [9])
ELSE
    k50hash_rowid (RowId, KeyLen, Number.n);
(*ENDIF*) 
&ifdef TRACE
t01p2int4 (kb_lock, 'Number      ', Number.n
      ,             'RowHashEntri', k51glob.glRowHashEntriesPerRegion_kb05);
&endif
absval := abs (Number.n);
RowHash   := 1 + (absval MOD k51glob.glRowHashEntriesPerRegion_kb05);
RowRegion := 1 + (absval MOD k51glob.glRowRegions_kb05)
      + k51glob.glTransRegions_kb05 + k51glob.glTabRegions_kb05;
&ifdef TRACE
t01p2int4 (kb_lock, 'RowHash     ', RowHash
      ,             'RowRegion   ', RowRegion);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51row_lock_check_ins (
            VAR t            : tgg00_TransContext;
            VAR WantedLock   : tkb05_WantedLock;
            TransLockMode    : tkb05_TransLockMode;
            RowTrans         : tkb05_RowTransPtr;
            VAR RowRegion    : tkb05_RegionNo;
            VAR RowHash      : tsp00_Int4;
            VAR RowLock      : tkb05_RowLockPtr;
            VAR RowOptimVers : tsp00_Int4;
            VAR Collided     : boolean;
            VAR WaitInserted : boolean);
 
VAR
      IsInserted    : boolean;
      IsOwnRow      : boolean;
      OwnLockMode   : tgg00_LockReqMode;
      OwnRowOptim   : tsp00_Int4;
      OwnRowShare   : tsp00_Int4;
      PrevRow       : tkb05_RowLockPtr;
      UnivItemPtr   : tkb05_UnivItemPtr;
      RowIdUnivItem : tkb05_UnivItemPtr;
      ThisTrans     : tkb05_TransEntryPtr;
      RowRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
&ifdef TRACE
k52xaddr_rowt (kb_lock, 'RowTrans    ', RowTrans);
k52xaddr_rowl (kb_lock, 'RowLock     ', RowLock);
t01bool       (kb_lock, 'Collided    ', Collided);
&endif
t.trError_gg00 := e_ok;
IsOwnRow       := (RowLock <> NIL);
IsInserted     := false;
RowOptimVers   := 0;
OwnLockMode    := lckFree_egg00;
OwnRowShare    := 0;
OwnRowOptim    := 0;
PrevRow        := NIL;
IF  RowTrans = NIL
THEN
    kb51row_hash (WantedLock.wlRowId_kb05, WantedLock.wlKeyLen_kb05, RowHash, RowRegion)
ELSE
    BEGIN
    IF  RowTrans^.rtItemKind_kb05 <> ikRowTrans_ekb05
    THEN
        k52x_item_error ('kb51row_lock_check_ins/1', RowTrans^.rtItemKind_kb05);
    (*ENDIF*) 
    RowRegion   := RowTrans^.rtRowRegion_kb05;
    RowHash     := RowTrans^.rtRowHash_kb05;
    OwnLockMode := RowTrans^.rtLockMode_kb05;
    IF  OwnLockMode = lckRowShare_egg00
    THEN
        OwnRowShare := 1;
    (*ENDIF*) 
    IF  OwnLockMode = lckRowOptimistic_egg00
    THEN
        OwnRowOptim := 1
    (*ENDIF*) 
    END;
(*ENDIF*) 
k52begexcl_region (t.trTaskId_gg00, RowRegion, RowRgnGlobPtr);
IF  RowLock = NIL
THEN
    kb51rowid_hash_search (RowRgnGlobPtr^, RowHash, WantedLock, RowLock, PrevRow);
(*ENDIF*) 
IF  (RowLock <> NIL) AND NOT Collided
    AND
    (hdCheckCollision_ekb05 in WantedLock.wlHandling_kb05)
THEN
    BEGIN
    kb51row_collision (t.trIndex_gg00, RowLock,
          WantedLock.wlMode_kb05, WantedLock.wlState_kb05,
          OwnRowShare, t.trError_gg00);
    IF  t.trError_gg00 = e_lock_collision
    THEN
        BEGIN
        Collided       := true;
        t.trError_gg00 := e_ok
        END;
    (*ENDIF*) 
    IF  Collided
    THEN
        WITH RowRgnGlobPtr^ DO
            (* PTS 1103743 JA 1999-08-25 *)
            rglCollisions_kb05 := rglCollisions_kb05 + ONE_8BYTE_CNT_GG04;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) AND (RowTrans <> NIL)
    THEN
        BEGIN
        IF  (RowTrans^.rtLockMode_kb05 = lckRowOptimistic_egg00)
            AND
            (WantedLock.wlMode_kb05 = lckRowExcl_egg00)
            AND
            (RowTrans^.rtRowOptimVers_kb05 <> RowLock^.rlRowOptimVers_kb05)
        THEN
            t.trError_gg00 := e_lock_dirty
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok)
    AND
    (RowLock = NIL)
    AND
    (((hdInsLock_ekb05 in WantedLock.wlHandling_kb05) AND NOT Collided)
    OR
    ( (hdInsReq_ekb05  in WantedLock.wlHandling_kb05) AND     Collided))
THEN
    BEGIN
    IF  WantedLock.wlKeyLen_kb05 > sizeof(tkb05_ShortKey)
    THEN
        kb51get_supply_item (t, RowRgnGlobPtr^, ikRowId_ekb05, RowIdUnivItem);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb51get_supply_item (t, RowRgnGlobPtr^, ikRowLock_ekb05, UnivItemPtr);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        RowLock                   := UnivItemPtr.uiRowLock_kb05;
        RowLock^.rlTabId_kb05     := WantedLock.wlTabId_kb05;
        RowLock^.rlKeyLen_kb05    := WantedLock.wlKeyLen_kb05;
        RowLock^.rlShortKey_kb05  := WantedLock.wlShortKey_kb05;
        RowLock^.rlLockState_kb05 := WantedLock.wlState_kb05; (* PTS 1115302 UH 2002-05-02 *)
        IF  PrevRow = NIL
        THEN
            BEGIN
            RowLock^.rlNextHashRow_kb05              := RowRgnGlobPtr^.rglRowHash_kb05^[RowHash];
            RowRgnGlobPtr^.rglRowHash_kb05^[RowHash] := RowLock
            END
        ELSE
            BEGIN
            RowLock^.rlNextHashRow_kb05 := PrevRow^.rlNextHashRow_kb05;
            PrevRow^.rlNextHashRow_kb05 := RowLock
            END;
        (*ENDIF*) 
        IF  WantedLock.wlKeyLen_kb05 > sizeof(RowLock^.rlShortKey_kb05)
        THEN
            BEGIN
            RowLock^.rlRowIdItem_kb05               := RowIdUnivItem.uiRowIdItem_kb05;
            RowLock^.rlRowIdItem_kb05^.riRowId_kb05 := WantedLock.wlRowId_kb05
            END;
        (*ENDIF*) 
        ;
&       ifdef TRACE
        IF  kb03Check.chkLockSupply_kb00
        THEN
            k52xaddr_rowl_check (RowRgnGlobPtr^, RowLock);           (* PTS 1104245 JA 2000-02-08 *)
&       endif
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  RowLock <> NIL
THEN
    BEGIN
    IF  RowLock^.rlItemKind_kb05 <> ikRowLock_ekb05
    THEN
        k52x_item_error ('kb51row_lock_check_ins/2', RowLock^.rlItemKind_kb05)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND NOT Collided
    AND
    (hdInsLock_ekb05 in WantedLock.wlHandling_kb05)
THEN
    BEGIN
    IsInserted := true;
    CASE WantedLock.wlMode_kb05 OF
        lckRowShare_egg00:
            BEGIN
            RowLock^.rlRowShareLocks_kb05 := RowLock^.rlRowShareLocks_kb05 + 1;
            RowLock^.rlRowOptimCnt_kb05   := RowLock^.rlRowOptimCnt_kb05 - OwnRowOptim;
            IF  k51glob.glDeadlockDetection_kb05 > 0
            THEN
                BEGIN
                IF  ((RowLock^.rlShare1TransIndex_kb05 = cgg_nil_transindex) OR
                    ( RowLock^.rlShare2TransIndex_kb05 = cgg_nil_transindex))
                    AND
                    (RowLock^.rlShare1TransIndex_kb05 <> t.trIndex_gg00)
                    AND
                    (RowLock^.rlShare2TransIndex_kb05 <> t.trIndex_gg00)
                THEN
                    BEGIN
                    IF  RowLock^.rlFirstReqRow_kb05 <> NIL
                    THEN
                        vbegexcl (t.trTaskId_gg00, g08lockreq);
                    (*ENDIF*) 
                    IF  RowLock^.rlShare1TransIndex_kb05 = cgg_nil_transindex
                    THEN
                        RowLock^.rlShare1TransIndex_kb05 := t.trIndex_gg00
                    ELSE
                        RowLock^.rlShare2TransIndex_kb05 := t.trIndex_gg00;
                    (*ENDIF*) 
                    IF  RowLock^.rlFirstReqRow_kb05 <> NIL
                    THEN
                        BEGIN
                        k52flush_row_lock (RowLock^);
                        vendexcl (t.trTaskId_gg00, g08lockreq)
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        lckRowExcl_egg00:
            BEGIN
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                (RowLock^.rlFirstReqRow_kb05 <> NIL)
            THEN
                vbegexcl (t.trTaskId_gg00, g08lockreq);
            (*ENDIF*) 
            ;
            (* in case of keep Lock TransIndex may be overwritten *)
            RowLock^.rlExclTransIndex_kb05 := t.trIndex_gg00;
            (**)
            IF  k51glob.glDeadlockDetection_kb05 > 0
            THEN
                BEGIN
                IF  RowLock^.rlShare1TransIndex_kb05 = t.trIndex_gg00
                THEN
                    RowLock^.rlShare1TransIndex_kb05 := cgg_nil_transindex
                ELSE
                    IF  RowLock^.rlShare2TransIndex_kb05 = t.trIndex_gg00
                    THEN
                        RowLock^.rlShare2TransIndex_kb05 := cgg_nil_transindex;
                    (*ENDIF*) 
                (*ENDIF*) 
                IF  RowLock^.rlFirstReqRow_kb05 <> NIL
                THEN
                    BEGIN
                    k52flush_row_lock (RowLock^);
                    vendexcl (t.trTaskId_gg00, g08lockreq)
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            RowLock^.rlRowShareLocks_kb05 := RowLock^.rlRowShareLocks_kb05 - OwnRowShare;
            RowLock^.rlRowOptimCnt_kb05   := RowLock^.rlRowOptimCnt_kb05   - OwnRowOptim;
            IF  lrsEotExcl_egg00 in WantedLock.wlState_kb05
            THEN
                RowLock^.rlRowOptimVers_kb05 := RowLock^.rlRowOptimVers_kb05 + 1
            (*ENDIF*) 
            END;
        lckRowOptimistic_egg00:
            RowLock^.rlRowOptimCnt_kb05 := RowLock^.rlRowOptimCnt_kb05 + 1;
        OTHERWISE
            t.trError_gg00 := e_not_implemented
        END;
    (*ENDCASE*) 
    RowOptimVers := RowLock^.rlRowOptimVers_kb05;
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND Collided
THEN
    BEGIN
    IF  hdInsReq_ekb05 in WantedLock.wlHandling_kb05
    THEN
        (* insert request *)
        BEGIN
        IsInserted := true;
        kb51new_req (t, RowRgnGlobPtr^, WantedLock.wlMode_kb05, WantedLock.wlState_kb05,
              TransLockMode, OwnLockMode, OwnRowShare, 0,
              RowLock^.rlFirstReqRow_kb05, WaitInserted)
        END
    ELSE
        IF  (hdCheckOwnReq_ekb05 in WantedLock.wlHandling_kb05)
            AND NOT WaitInserted
        THEN
            BEGIN
            vbegexcl (t.trTaskId_gg00, g08lockwait);
            k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
            ThisTrans^.teWaiting_kb05 := true;
            k52flush_trans_waiting (ThisTrans^.teWaiting_kb05);
            vendexcl (t.trTaskId_gg00, g08lockwait);
            WaitInserted := true
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
k52xrow_lock (kb_lockentry, RowLock);
&endif
(**)
IF  RowLock <> NIL
THEN
    k52flush_row_lock (RowLock^);
(*ENDIF*) 
k52endexcl_region (t.trTaskId_gg00, RowRgnGlobPtr);
(**)
IF  NOT IsInserted AND NOT IsOwnRow
THEN
    RowLock := NIL;
(*ENDIF*) 
;
&ifdef TRACE
k52xaddr_rowl  (kb_lock, 'RowLock     ', RowLock);
t01bool        (kb_lock, 'Collided    ', Collided);
t01basis_error (kb_lock, 'end row_lock', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51row_remove (
            TaskId              : tsp00_TaskId;
            VAR TransRegionGlob : tkb05_RegionGlob;
            ThisTrans         : tkb05_TransEntryPtr;
            VAR Tab           : tkb05_TabTransPtr;
            VAR Row           : tkb05_RowTransPtr);
 
VAR
      RowRgnGlobPtr : tkb05_RegionGlobPtr;
      TabRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (TaskId, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51row_re: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransRegionGlob.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
k52begexcl_region (TaskId, Row^.rtRowRegion_kb05, RowRgnGlobPtr);
kb51r_release_row_lock (TaskId, RowRgnGlobPtr^, ThisTrans^.teOwnIndex_kb05, Row, SATISFY_REQUESTS);
k52endexcl_region (TaskId, RowRgnGlobPtr);
(**)
k52begexcl_region (TaskId, Tab^.ttTabRegion_kb05, TabRgnGlobPtr);
kb51rt_release_row_of_tab_lock (TaskId, TabRgnGlobPtr^, ThisTrans, Tab, Row);
k52endexcl_region (TaskId, TabRgnGlobPtr);
(**)
kb51rm_row_trans_remove (TaskId, TransRegionGlob, ThisTrans, Tab, Row);
(**)
IF  (Tab^.ttLockMode_kb05 = lckFree_egg00) AND
    (Tab^.ttFirstRow_kb05 = NIL          )
THEN
    kb51rm_tab_trans_remove (TaskId, TransRegionGlob, ThisTrans, Tab)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51row_trans_insert (
            VAR t                 : tgg00_TransContext;
            VAR TransRegionGlob   : tkb05_RegionGlob;
            InsertReq             : boolean;
            ThisTrans             : tkb05_TransEntryPtr;
            ThisTab               : tkb05_TabTransPtr;
            VAR WantedLock        : tkb05_WantedLock;
            RowRegion             : tkb05_RegionNo;
            RowHash               : tsp00_Int4;
            RowLock               : tkb05_RowLockPtr;
            PrevRow               : tkb05_RowTransPtr;
            RowOptimVers          : tsp00_Int4;
            TabOptimVers          : tsp00_Int4;
            VAR Row               : tkb05_RowTransPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
&ifdef TRACE
t01bool       (kb_lock, 'InsertReq   ', InsertReq);
k52xaddr_rowl (kb_lock, 'RowLock     ', RowLock);
k52xaddr_rowt (kb_lock, 'Row         ', Row     );
k52xaddr_rowt (kb_lock, 'PrevRow     ', PrevRow);
&endif
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (t.trTaskId_gg00, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51row_tr: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransRegionGlob.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
t.trError_gg00 := e_ok;
IF  Row = NIL
THEN
    BEGIN
    kb51get_supply_item (t, TransRegionGlob, ikRowTrans_ekb05, UnivItemPtr);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        Row                   := UnivItemPtr.uiRowTrans_kb05;
        Row^.rtRow_kb05       := RowLock;
        Row^.rtShortKey_kb05  := WantedLock.wlShortKey_kb05;
        Row^.rtKeyLen_kb05    := WantedLock.wlKeyLen_kb05;
        Row^.rtRowRegion_kb05 := RowRegion;
        Row^.rtRowHash_kb05   := RowHash;
        IF  PrevRow = NIL
        THEN
            BEGIN
            Row^.rtNextRow_kb05      := ThisTab^.ttFirstRow_kb05;
            ThisTab^.ttFirstRow_kb05 := Row
            END
        ELSE
            BEGIN
            Row^.rtNextRow_kb05     := PrevRow^.rtNextRow_kb05;
            Row^.rtPrevRow_kb05     := PrevRow;
            PrevRow^.rtNextRow_kb05 := Row
            END;
        (*ENDIF*) 
        IF  Row^.rtNextRow_kb05 <> NIL
        THEN
            Row^.rtNextRow_kb05^.rtPrevRow_kb05 := Row;
        (*ENDIF*) 
        WITH TransRegionGlob.rglTransGlob_kb05^ DO
            (* PTS 1103743 JA 1999-08-25 *)
            trRowEntryAmount_kb05 := trRowEntryAmount_kb05 + ONE_8BYTE_CNT_GG04;
        (*ENDWITH*) 
&       ifdef TRACE
        IF  kb03Check.chkLockSupply_kb00
        THEN
            k52xaddr_rowt_check (TransRegionGlob, Row);              (* PTS 1104245 JA 2000-02-08 *)
&       endif
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    IF  InsertReq
    THEN
        BEGIN
        IF  k51glob.glDeadlockDetection_kb05 > 0
        THEN
            vbegexcl (t.trTaskId_gg00, g08lockreq);
        (*ENDIF*) 
        ThisTrans^.teReqRow_kb05 := Row;
        Row^.rtReqMode_kb05      := WantedLock.wlMode_kb05;
        Row^.rtReqState_kb05     := WantedLock.wlState_kb05;
        (**)
        IF  k51glob.glDeadlockDetection_kb05 > 0
        THEN
            BEGIN
            k52flush_trans_entry (ThisTrans^);
            k52flush_row_trans   (Row^);
            vendexcl (t.trTaskId_gg00, g08lockreq)
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        kb51ins_row_mode (Row, WantedLock.wlMode_kb05, WantedLock.wlState_kb05,
              TabOptimVers, RowOptimVers);
        ThisTrans^.teTabRecentlyUsed_kb05 := ThisTab;
        ThisTrans^.teRowRecentlyUsed_kb05 := Row;
        IF  ThisTab^.ttConsistentRow_kb05 = Row
        THEN
            ThisTab^.ttConsistentRow_kb05 := NIL
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
k52xrow_trans  (kb_lockentry, Row);
k52xaddr_rowt  (kb_lock, 'Row         ', Row);
t01basis_error (kb_lock, 'end row_tran', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51rowid_hash_search (
            VAR RowRegionGlob : tkb05_RegionGlob;
            RowHash        : tsp00_Int4;
            VAR WantedLock : tkb05_WantedLock;
            VAR RowLock    : tkb05_RowLockPtr;
            VAR PrevRow    : tkb05_RowLockPtr);
 
VAR
      Found         : boolean;
      CompareResult : tsp00_LcompResult;
      ItemCnt       : tsp00_Int4;
 
BEGIN
(* TabId ascending, RowId descending *)
IF  kb03Check.chkRegion_kb00
THEN
    g08check_excl (g08lock0 + RowRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
RowLock := RowRegionGlob.rglRowHash_kb05^[RowHash];
PrevRow := NIL;
Found   := false;
ItemCnt := 0;
WHILE (RowLock <> NIL) AND NOT Found AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
    BEGIN
    IF  WantedLock.wlTabId_kb05 = RowLock^.rlTabId_kb05
    THEN
        BEGIN
        WITH RowLock^, WantedLock DO
            kb51compare_rowid (
                  wlRowId_kb05,     wlShortKey_kb05, wlKeyLen_kb05,
                  rlRowIdItem_kb05, rlShortKey_kb05, rlKeyLen_kb05,
                  CompareResult);
        (*ENDWITH*) 
        IF  CompareResult = l_equal
        THEN
            Found := true
        ELSE
            IF  CompareResult = l_greater
            THEN
                (* descending:  WantedRowId > entry_rowid *)
                RowLock := NIL
            ELSE
                BEGIN
                PrevRow := RowLock;
                RowLock := RowLock^.rlNextHashRow_kb05
                END
            (*ENDIF*) 
        (*ENDIF*) 
        END
    ELSE
        IF  WantedLock.wlTabId_kb05 < RowLock^.rlTabId_kb05
        THEN
            RowLock := NIL
        ELSE
            BEGIN
            PrevRow := RowLock;
            RowLock := RowLock^.rlNextHashRow_kb05
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    ItemCnt := ItemCnt + 1
    END;
(*ENDWHILE*) 
IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
THEN
    k52x_loop_error ('kb51rowid_hash_search   ', 1);
(*ENDIF*) 
;
&ifdef TRACE
k52xaddr_rowl (kb_lock, 'RowLock     ', RowLock);
k52xaddr_rowl (kb_lock, 'PrevRow     ', PrevRow);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51rowid_search (
            ThisTrans             : tkb05_TransEntryPtr;
            Tab                   : tkb05_TabTransPtr;
            VAR WantedLock        : tkb05_WantedLock;
            VAR Row               : tkb05_RowTransPtr;
            VAR PrevRow           : tkb05_RowTransPtr);
 
VAR
      Found            : boolean;
      SearchDescending : boolean;
      CompareResult    : tsp00_LcompResult;
      ItemCnt          : tsp00_Int4;
 
BEGIN
&ifdef TRACE
k52xaddr_tabt (kb_lock, 'Tab         ', Tab);
&endif
Found            := false;
SearchDescending := true; (* rows are sorted descending *)
Row              := Tab^.ttFirstRow_kb05;
PrevRow          := NIL;
IF  (ThisTrans^.teTabRecentlyUsed_kb05  = Tab) AND
    (ThisTrans^.teRowRecentlyUsed_kb05 <> NIL) AND
    Tab^.ttKeySort_kb05                                              (* PTS 1107056 JA 2001-03-01 *)
THEN
    BEGIN
    IF  ThisTrans^.teTabRecentlyUsed_kb05^.ttItemKind_kb05 <> ikTabTrans_ekb05
    THEN
        k52x_item_error ('kb51rowid_search/1      ',
              ThisTrans^.teTabRecentlyUsed_kb05^.ttItemKind_kb05);
    (*ENDIF*) 
    IF  ThisTrans^.teRowRecentlyUsed_kb05^.rtItemKind_kb05 <> ikRowTrans_ekb05
    THEN
        k52x_item_error ('kb51rowid_search/2      ',
              ThisTrans^.teRowRecentlyUsed_kb05^.rtItemKind_kb05);
    (*ENDIF*) 
    WITH ThisTrans^.teRowRecentlyUsed_kb05^, WantedLock DO
        kb51compare_rowid
              (          wlRowId_kb05,      wlShortKey_kb05, wlKeyLen_kb05,
              rtRow_kb05^.rlRowIdItem_kb05, rtShortKey_kb05, rtKeyLen_kb05,
              CompareResult);
    (*ENDWITH*) 
    IF  CompareResult = l_equal
    THEN
        BEGIN
        Found   := true;
        Row     := ThisTrans^.teRowRecentlyUsed_kb05;
        PrevRow := Row^.rtPrevRow_kb05
        END
    ELSE
        IF  CompareResult = l_less
        THEN
            (* wanted < recently_used  ==>  start descending search *)
            BEGIN
            PrevRow := ThisTrans^.teRowRecentlyUsed_kb05;
            Row     := PrevRow^.rtNextRow_kb05
            END
        ELSE
            (* wanted > recently_used  ==>  start ascending search *)
            BEGIN
            Row := ThisTrans^.teRowRecentlyUsed_kb05^.rtPrevRow_kb05;
            SearchDescending := false
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  SearchDescending
THEN
    (* rows are sorted descending:  use NextRow *)
    BEGIN
    ItemCnt := 0;
    WHILE (Row <> NIL) AND NOT Found AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        IF  Row^.rtItemKind_kb05 <> ikRowTrans_ekb05
        THEN
            k52x_item_error ('kb51rowid_search/3      ', Row^.rtItemKind_kb05);
        (*ENDIF*) 
        WITH Row^, WantedLock DO
            kb51compare_rowid
                  (           wlRowId_kb05,     wlShortKey_kb05, wlKeyLen_kb05,
                  rtRow_kb05^.rlRowIdItem_kb05, rtShortKey_kb05, rtKeyLen_kb05,
                  CompareResult);
        (*ENDWITH*) 
        IF  CompareResult = l_equal
        THEN
            Found := true
        ELSE
            IF  (CompareResult = l_greater) AND Tab^.ttKeySort_kb05  (* PTS 1107056 JA 2001-03-01 *)
            THEN
                (* wanted > curr  ==>  insert behind curr.PrevRow *)
                Row := NIL
            ELSE
                (* wanted < curr  ==>  follow curr.next *)
                BEGIN
                PrevRow := Row;
                Row     := Row^.rtNextRow_kb05
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        ItemCnt := ItemCnt + 1
        END;
    (*ENDWHILE*) 
    IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
    THEN
        k52x_loop_error ('kb51rowid_search        ', 1)
    (*ENDIF*) 
    END
ELSE
    (* rows are sorted descending:  ascending search ==> use PrevRow *)
    BEGIN
    ItemCnt := 0;
    WHILE (Row <> NIL) AND NOT Found AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        IF  Row^.rtItemKind_kb05 <> ikRowTrans_ekb05
        THEN
            k52x_item_error ('kb51rowid_search/4      ', Row^.rtItemKind_kb05);
        (*ENDIF*) 
        WITH Row^, WantedLock DO
            kb51compare_rowid
                  (           wlRowId_kb05,     wlShortKey_kb05, wlKeyLen_kb05,
                  rtRow_kb05^.rlRowIdItem_kb05, rtShortKey_kb05, rtKeyLen_kb05,
                  CompareResult);
        (*ENDWITH*) 
        IF  CompareResult = l_equal
        THEN
            BEGIN
            Found   := true;
            PrevRow := Row^.rtPrevRow_kb05
            END
        ELSE
            IF  CompareResult = l_greater
            THEN
                (* wanted > curr  ==>  follow curr.prev *)
                Row := Row^.rtPrevRow_kb05
            ELSE
                (* wanted < curr  ==>  insert behind curr *)
                BEGIN
                PrevRow := Row;
                Row     := NIL
                END;
            (*ENDIF*) 
        (*ENDIF*) 
        ItemCnt := ItemCnt + 1
        END;
    (*ENDWHILE*) 
    IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
    THEN
        k52x_loop_error ('kb51rowid_search        ', 2)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  Row <> NIL
THEN
    BEGIN
    IF  Row^.rtRow_kb05 = NIL
    THEN
        k52x_item_error ('kb51rowid_search/5      ', ikNone_ekb05)
    ELSE
        IF  Row^.rtRow_kb05^.rlItemKind_kb05 <> ikRowLock_ekb05
        THEN
            k52x_item_error ('kb51rowid_search/6      ', Row^.rtRow_kb05^.rlItemKind_kb05)
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
k52xaddr_rowt (kb_lock, 'Row         ', Row);
k52xaddr_rowt (kb_lock, 'PrevRow     ', PrevRow);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51rows_remove (
            TaskId              : tsp00_TaskId;
            VAR TransRegionGlob : tkb05_RegionGlob;
            ThisTrans           : tkb05_TransEntryPtr;
            Tab                 : tkb05_TabTransPtr;
            RemoveExclRows      : boolean);
 
VAR
      RowFound          : boolean;
      CurrRegion        : tkb05_RegionNo;
      ItemCnt           : tsp00_Int4;
      CurrRow           : tkb05_RowTransPtr;
      NextRow           : tkb05_RowTransPtr;
      CurrRegionGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (TaskId, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51rows_r: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransRegionGlob.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
RowFound          := true;
CurrRegion        := k51glob.glTransRegions_kb05 + k51glob.glTabRegions_kb05 + 1;
WHILE (CurrRegion <= k51glob.glRegions_kb05) AND RowFound DO
    BEGIN
    CurrRegionGlobPtr := NIL;
    RowFound          := false;
    ItemCnt           := 0;
    CurrRow           := Tab^.ttFirstRow_kb05;
    WHILE (CurrRow <> NIL) AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        NextRow := CurrRow^.rtNextRow_kb05;
        IF  RemoveExclRows
            OR
            (CurrRow^.rtLockMode_kb05 <> lckRowExcl_egg00)
        THEN
            BEGIN
            RowFound := true;
            IF  CurrRegion = CurrRow^.rtRowRegion_kb05
            THEN
                BEGIN
                (* IF  lrsEotExcl_egg00 in CurrRow^.rtLockState_kb05       JA 1998-09-28 *)
                (* THEN                                                 *)
                (*    Tab^.ttLockState_kb05 :=                          *)
                (*          Tab^.ttLockState_kb05 + [lrsEotExcl_egg00]; *)
                IF  CurrRegionGlobPtr = NIL
                THEN
                    k52begexcl_region (TaskId, CurrRegion, CurrRegionGlobPtr);
                (*ENDIF*) 
                kb51r_release_row_lock (TaskId, CurrRegionGlobPtr^, ThisTrans^.teOwnIndex_kb05,
                      CurrRow, NOT SATISFY_REQUESTS);
                kb51rm_row_trans_remove (TaskId, TransRegionGlob, ThisTrans, Tab, CurrRow)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ItemCnt := ItemCnt + 1;
        CurrRow := NextRow
        END;
    (*ENDWHILE*) 
    IF  CurrRegionGlobPtr <> NIL
    THEN
        k52endexcl_region (TaskId, CurrRegionGlobPtr);
    (*ENDIF*) 
    IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
    THEN
        k52x_loop_error ('kb51rows_remove         ', 1);
    (*ENDIF*) 
    CurrRegion := CurrRegion + 1
    END;
(*ENDWHILE*) 
vbegexcl (TaskId, g08lock0 + Tab^.ttTabRegion_kb05);
WITH Tab^.ttTab_kb05^ DO
    BEGIN
    tlRowShareLocks_kb05 := tlRowShareLocks_kb05 - Tab^.ttRowShareLocks_kb05;
    tlRowOptimCnt_kb05   := tlRowOptimCnt_kb05   - Tab^.ttRowOptimCnt_kb05;
    IF  RemoveExclRows
    THEN
        BEGIN
        tlRowExclLocks_kb05 := tlRowExclLocks_kb05 - Tab^.ttRowExclLocks_kb05;
&       ifdef UWE
        (* PTS 1139806 UH 2006-02-09 next *)
        IF  ForInsert in ReleaseRowState
        THEN
            tlRowExclLocksForInsert_kb05 := tlRowExclLocksForInsert_kb05 - 1;
&       endif
        (*ENDIF*) 
        END;
&   ifdef TRACE
    (*ENDIF*) 
    t01p2int4 (kb_lock, 'RowShareLcks', tlRowShareLocks_kb05
          ,             'RowExclLocks', tlRowExclLocks_kb05);
&   ifdef UWE
    t01int4   (kb_lock, 'ForInsert   ', tlRowExclLocksForInsert_kb05);
&   endif
&   endif
    END;
(*ENDWITH*) 
k52flush_tab_lock (Tab^.ttTab_kb05^);
vendexcl (TaskId, g08lock0 + Tab^.ttTabRegion_kb05);
Tab^.ttRowShareLocks_kb05 := 0;
Tab^.ttRowOptimCnt_kb05   := 0;
IF  RemoveExclRows
THEN
    Tab^.ttRowExclLocks_kb05 := 0;
(*ENDIF*) 
Tab^.ttConsistentRow_kb05         := NIL;
ThisTrans^.teTabRecentlyUsed_kb05 := NIL;
ThisTrans^.teRowRecentlyUsed_kb05 := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51rt_release_row_of_tab_lock (
            TaskId            : tsp00_TaskId;
            VAR TabRegionGlob : tkb05_RegionGlob;
            ThisTrans         : tkb05_TransEntryPtr;
            TabTrans          : tkb05_TabTransPtr;
            RowTrans          : tkb05_RowTransPtr);
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (TaskId, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    g08excl_check (TaskId, g08lock0 + TabTrans^.ttTabRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51rt_rel: wrong TabReg',
          TabTrans^.ttTabRegion_kb05,
          TabTrans^.ttTabRegion_kb05 = TabRegionGlob.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
IF  TabTrans^.ttItemKind_kb05 <> ikTabTrans_ekb05
THEN
    k52x_item_error ('kb51rt_release_row_of/1 ', TabTrans^.ttItemKind_kb05);
(*ENDIF*) 
IF  TabTrans^.ttTab_kb05^.tlItemKind_kb05 <> ikTabLock_ekb05
THEN
    k52x_item_error ('kb51rt_release_row_of/2 ', TabTrans^.ttTab_kb05^.tlItemKind_kb05);
(*ENDIF*) 
IF  RowTrans^.rtItemKind_kb05 <> ikRowTrans_ekb05
THEN
    k52x_item_error ('kb51rt_release_row_of/3 ', RowTrans^.rtItemKind_kb05);
(*ENDIF*) 
IF  RowTrans^.rtLockMode_kb05 = lckRowExcl_egg00                     (* PTS 1107452 JA 2000-08-08 *)
THEN
    BEGIN
    TabTrans^.ttTab_kb05^.tlRowExclLocks_kb05 := TabTrans^.ttTab_kb05^.tlRowExclLocks_kb05 -1;
&   ifdef UWE
&   endif
    TabTrans^.ttRowExclLocks_kb05             := TabTrans^.ttRowExclLocks_kb05 -1
    END;
(*ENDIF*) 
IF  RowTrans^.rtSharedLocked_kb05                                    (* PTS 1107452 JA 2000-08-08 *)
THEN
    BEGIN
    TabTrans^.ttTab_kb05^.tlRowShareLocks_kb05 := TabTrans^.ttTab_kb05^.tlRowShareLocks_kb05 -1;
    TabTrans^.ttRowShareLocks_kb05             := TabTrans^.ttRowShareLocks_kb05 -1
    END;
(*ENDIF*) 
IF  RowTrans^.rtOptimSet_kb05                                        (* PTS 1107452 JA 2000-08-08 *)
THEN
    BEGIN
    TabTrans^.ttTab_kb05^.tlRowOptimCnt_kb05 := TabTrans^.ttTab_kb05^.tlRowOptimCnt_kb05 -1;
    TabTrans^.ttRowOptimCnt_kb05             := TabTrans^.ttRowOptimCnt_kb05 -1
    END;
(*ENDIF*) 
;
&ifdef TRACE
t01p2int4    (kb_lock, 'RowShareLcks', TabTrans^.ttTab_kb05^.tlRowShareLocks_kb05
      ,                'RowExclLocks', TabTrans^.ttTab_kb05^.tlRowExclLocks_kb05);
k52xtab_lock (kb_lockentry, TabTrans^.ttTab_kb05);
&endif
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g01check (kb51c1RtReleaseRow_csp03, csp3_n_lock,
          'Row rel: Row share < 0  ',
          TabTrans^.ttTab_kb05^.tlRowShareLocks_kb05,
          TabTrans^.ttTab_kb05^.tlRowShareLocks_kb05 >= 0);
    (* *)
    g01check (kb51c2RtReleaseRow_csp03, csp3_n_lock,
          'Row rel: Row optim < 0  ',
          TabTrans^.ttTab_kb05^.tlRowOptimCnt_kb05,
          TabTrans^.ttTab_kb05^.tlRowOptimCnt_kb05 >= 0);
    (* *)
    g01check (kb51c3RtReleaseRow_csp03, csp3_n_lock,
          'Row rel: Row excl < 0   ',
          TabTrans^.ttTab_kb05^.tlRowExclLocks_kb05,
          TabTrans^.ttTab_kb05^.tlRowExclLocks_kb05 >= 0)
    END;
(*ENDIF*) 
kb51t_satisfy_tab_lock (TaskId, TabRegionGlob, TabTrans^.ttTab_kb05, RowTrans^.rtLockMode_kb05);
kb51try_free_tab_lock  (TaskId, TabRegionGlob, TabTrans^.ttTab_kb05, TabTrans^.ttTabHash_kb05)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51search_deadlock (
            SourceTransIndex  : tgg00_TransIndex;
            CurrTransIndex    : tgg00_TransIndex;
            SearchLevel       : tsp00_Int4;
            VAR DeadlockFound : boolean);
 
TYPE
      t_SearchTrans = (
            ExclTab_e,
            ShareTab1_e,
            ShareTab2_e,
            ExclRow_e,
            ShareRow1_e,
            ShareRow2_e,
            ListEnd_e);
 
VAR
      i         : t_SearchTrans;
      Trans     : ARRAY [ExclTab_e .. ShareRow2_e] OF tgg00_TransIndex;
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00
THEN
    g08check_excl (g08lockreq);
(*ENDIF*) 
FOR i := ExclTab_e TO ShareRow2_e DO
    Trans [i] := cgg_nil_transindex;
(*ENDFOR*) 
k52acc_trans_entry (CurrTransIndex, ThisTrans);
IF  ThisTrans^.teReqTab_kb05 <> NIL
THEN
    WITH ThisTrans^.teReqTab_kb05^.ttTab_kb05^ DO
        BEGIN
        IF  (tlExclTransIndex_kb05 <> cgg_nil_transindex) AND
            (tlExclTransIndex_kb05 <> CurrTransIndex   )
        THEN
            BEGIN
            IF  tlExclTransIndex_kb05 = SourceTransIndex
            THEN
                DeadlockFound := true
            ELSE
                Trans [ExclTab_e] := tlExclTransIndex_kb05
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT DeadlockFound
            AND (tlShare1TransIndex_kb05 <> cgg_nil_transindex)
            AND (tlShare1TransIndex_kb05 <> CurrTransIndex   )
        THEN
            BEGIN
            IF  tlShare1TransIndex_kb05 = SourceTransIndex
            THEN
                DeadlockFound := true
            ELSE
                Trans [ShareTab1_e] := tlShare1TransIndex_kb05
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT DeadlockFound
            AND (tlShare2TransIndex_kb05 <> cgg_nil_transindex)
            AND (tlShare2TransIndex_kb05 <> CurrTransIndex   )
        THEN
            BEGIN
            IF  tlShare2TransIndex_kb05 = SourceTransIndex
            THEN
                DeadlockFound := true
            ELSE
                Trans [ShareTab2_e] := tlShare2TransIndex_kb05
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  NOT DeadlockFound AND (ThisTrans^.teReqRow_kb05 <> NIL)
THEN
    WITH ThisTrans^.teReqRow_kb05^.rtRow_kb05^ DO
        BEGIN
        IF  (rlExclTransIndex_kb05 <> cgg_nil_transindex) AND
            (rlExclTransIndex_kb05 <> CurrTransIndex   )
        THEN
            BEGIN
            IF  rlExclTransIndex_kb05 = SourceTransIndex
            THEN
                DeadlockFound := true
            ELSE
                Trans [ExclRow_e] := rlExclTransIndex_kb05
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT DeadlockFound
            AND (rlShare1TransIndex_kb05 <> cgg_nil_transindex)
            AND (rlShare1TransIndex_kb05 <> CurrTransIndex   )
        THEN
            BEGIN
            IF  rlShare1TransIndex_kb05 = SourceTransIndex
            THEN
                DeadlockFound := true
            ELSE
                Trans [ShareRow1_e] := rlShare1TransIndex_kb05
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  NOT DeadlockFound
            AND (rlShare2TransIndex_kb05 <> cgg_nil_transindex)
            AND (rlShare2TransIndex_kb05 <> CurrTransIndex   )
        THEN
            BEGIN
            IF  rlShare2TransIndex_kb05 = SourceTransIndex
            THEN
                DeadlockFound := true
            ELSE
                Trans [ShareRow2_e] := rlShare2TransIndex_kb05
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  NOT DeadlockFound
    AND
    (SearchLevel <= k51glob.glDeadlockDetection_kb05)
THEN
    BEGIN
    i := ExclTab_e;
    REPEAT
        IF  Trans [i] <> cgg_nil_transindex
        THEN
            kb51search_deadlock (SourceTransIndex, Trans [i], SearchLevel+1, DeadlockFound);
        (*ENDIF*) 
        i := succ (i)
    UNTIL
        (i = ListEnd_e) OR DeadlockFound
    (*ENDREPEAT*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51sfree_segment (
            VAR SupplyPoolGlob : tkb05_SupplyPoolGlob;
            VAR FreeSegment : tkb05_SupplySegmPtr);
 
BEGIN
&ifdef TRACE
t01addr_2 (kb_lock, 'FreeSegment ', FreeSegment);
&endif
IF  kb03Check.chkRegion_kb00
THEN
    g08check_excl (SupplyPoolGlob.poolOwnRegionId_kb05);
(*ENDIF*) 
WITH SupplyPoolGlob DO
    BEGIN
    FreeSegment^.sgmNext_kb05 := poolFirstFreeSegm_kb05;
    poolFirstFreeSegm_kb05    := FreeSegment;
    poolFreeSegments_kb05     := poolFreeSegments_kb05 + 1;
    poolEmptyWarning_kb05     := (poolFreeSegments_kb05 <= MIN_EXTENT_SEGMS_PER_RGN)
    END;
(*ENDWITH*) 
FreeSegment := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51sget_segment (
            VAR t              : tgg00_TransContext;
            VAR SupplyPoolGlob : tkb05_SupplyPoolGlob;
            VAR NewSegment     : tkb05_SupplySegmPtr);
 
BEGIN
t.trError_gg00 := e_ok;
IF  kb03Check.chkRegion_kb00
THEN
    g08excl_check (t.trTaskId_gg00, SupplyPoolGlob.poolOwnRegionId_kb05);
(*ENDIF*) 
IF  SupplyPoolGlob.poolFirstFreeSegm_kb05 = NIL
THEN
    BEGIN
    t.trError_gg00 := e_too_many_lock_requests;
    NewSegment     := NIL
    END
ELSE
    WITH SupplyPoolGlob DO
        BEGIN
        NewSegment             := poolFirstFreeSegm_kb05;
        poolFirstFreeSegm_kb05 := NewSegment^.sgmNext_kb05;
        poolFreeSegments_kb05  := poolFreeSegments_kb05 - 1;
        poolEmptyWarning_kb05  := (poolFreeSegments_kb05 <= MIN_EXTENT_SEGMS_PER_RGN);
        IF  poolFreeSegments_kb05 < poolMinFreeSegms_kb05
        THEN
            poolMinFreeSegms_kb05 := poolFreeSegments_kb05
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
&ifdef TRACE
t01addr_2 (kb_lock, 'NewSegment  ', NewSegment);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51signal_resume (
            TaskId     : tsp00_TaskId;
            TransIndex : tgg00_TransIndex;
            ok         : boolean);
 
VAR
      ThisTrans : tkb05_TransEntryPtr;
 
BEGIN
vbegexcl (TaskId, g08lockwait);
k52acc_trans_entry (TransIndex, ThisTrans);
IF  ThisTrans^.teWaiting_kb05
THEN
    BEGIN
    ThisTrans^.teWaiting_kb05 := false;
    k52flush_trans_waiting (ThisTrans^.teWaiting_kb05);
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    vsignal (ThisTrans^.teTaskId_kb05, ok);
    (*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*)
    END;
(*ENDIF*) 
vendexcl (TaskId, g08lockwait)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51_TriggerOmsGarbageCollection (TaskId : tsp00_TaskId);
 
BEGIN
bd91StartOMSGarbageCollectionIfRequired (TaskId);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51t_satisfy_tab_lock (
            TaskId            : tsp00_TaskId;
            VAR TabRegionGlob : tkb05_RegionGlob;
            Tab               : tkb05_TabLockPtr;
            ReleaseMode       : tgg00_LockReqMode);
 
VAR
      CollisionErr : tgg00_BasisError;
      ReqKind      : (tab_req, row_req, nil_req);
      OwnSysShare  : integer;
      OwnTabShare  : integer;
      ItemCnt      : tsp00_Int4;
      CurrReq      : tkb05_ReqPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00
THEN
    g08excl_check (TaskId, g08lock0 + TabRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
IF  Tab^.tlItemKind_kb05 <> ikTabLock_ekb05
THEN
    k52x_item_error ('kb51t_satisfy_tab_lock/1', Tab^.tlItemKind_kb05);
(*ENDIF*) 
CollisionErr := e_ok;
ReqKind      := tab_req;
WHILE (ReqKind <> nil_req) AND (CollisionErr = e_ok) DO
    BEGIN
    IF  ReqKind = tab_req
    THEN
        CurrReq := Tab^.tlFirstReqTab_kb05
    ELSE
        CurrReq := Tab^.tlFirstReqRow_kb05;
    (*ENDIF*) 
    ItemCnt := 0;
    WHILE (CurrReq <> NIL) AND (CollisionErr = e_ok)
          AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
&       ifdef TRACE
        k52xreq (kb_lockentry, CurrReq);
&       endif
        IF  CurrReq^.rqItemKind_kb05 <> ikRequest_ekb05
        THEN
            k52x_item_error ('kb51t_satisfy_tab_lock/2', CurrReq^.rqItemKind_kb05);
        (*ENDIF*) 
        OwnSysShare := 0;
        OwnTabShare := 0;
        IF  CurrReq^.rqLockMode_kb05 = lckSysShare_egg00
        THEN
            OwnSysShare := 1
        ELSE
            IF  CurrReq^.rqLockMode_kb05 = lckTabShare_egg00
            THEN
                OwnTabShare := 1;
            (*ENDIF*) 
        (*ENDIF*) 
        kb51tab_collision (CurrReq^.rqTransIndex_kb05, Tab,
              CurrReq^.rqReqMode_kb05,
              OwnSysShare, OwnTabShare,
              CurrReq^.rqRowShareLocks_kb05,
              CurrReq^.rqRowExclLocks_kb05, CollisionErr);
        IF  CollisionErr <> e_ok
        THEN
            CollisionErr := e_ok
        ELSE
            BEGIN
            IF  (CurrReq^.rqReqMode_kb05 = lckSysExcl_egg00) OR
                (CurrReq^.rqReqMode_kb05 = lckTabExcl_egg00)
            THEN
                (* reservation of Tab excl Lock *)
                BEGIN
                IF  (k51glob.glDeadlockDetection_kb05 > 0)
                    AND
                    ((Tab^.tlFirstReqTab_kb05 <> NIL) OR
                    ( Tab^.tlFirstReqRow_kb05 <> NIL))
                THEN
                    vbegexcl (TaskId, g08lockreq);
                (*ENDIF*) 
                Tab^.tlExclTransIndex_kb05:= CurrReq^.rqTransIndex_kb05;
                (**)
                IF  (k51glob.glDeadlockDetection_kb05 > 0)
                    AND
                    ((Tab^.tlFirstReqTab_kb05 <> NIL) OR
                    ( Tab^.tlFirstReqRow_kb05 <> NIL))
                THEN
                    BEGIN
                    k52flush_tab_lock (Tab^);
                    vendexcl (TaskId, g08lockreq)
                    END;
                (*ENDIF*) 
                IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00
                THEN
                    kb51vtrace_tab (m_insert, mm_table,
                          CurrReq^.rqTransIndex_kb05, CurrReq^.rqReqMode_kb05, Tab)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            kb51signal_resume (TaskId, CurrReq^.rqTransIndex_kb05, IS_OK)
            END;
        (*ENDIF*) 
        ItemCnt := ItemCnt + 1;
        CurrReq := CurrReq^.rqNextReq_kb05
        END;
    (*ENDWHILE*) 
    IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
    THEN
        k52x_loop_error ('kb51t_satisfy_tab_lock  ', 1);
    (*ENDIF*) 
    IF  ReqKind = row_req
    THEN
        ReqKind := nil_req
    ELSE
        IF  (ReleaseMode = lckSysExcl_egg00 ) OR
            (ReleaseMode = lckSysShare_egg00) OR (* PTS 1124101 UH 2003-09-10 added *)
            (ReleaseMode = lckTabExcl_egg00 ) OR
            (ReleaseMode = lckTabShare_egg00)
        THEN
            (* check Row requests *)
            ReqKind := row_req
        ELSE
            (* Row released: Row/Row collision impossible on Tab level*)
            ReqKind := nil_req
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51t_release_tab_lock (
            TaskId                   : tsp00_TaskId;
            VAR TabRegionGlob        : tkb05_RegionGlob;
            ThisTrans                : tkb05_TransEntryPtr;
            TabTrans                 : tkb05_TabTransPtr;
            ReleaseRowLocks          : boolean);
 
VAR
      Tab : tkb05_TabLockPtr;
 
BEGIN
&ifdef TRACE
k52xtab_trans (kb_lockentry, TabTrans);
&endif
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (TaskId, g08lock0 + TabTrans^.ttTabRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51t_rel: wrong TabReg ',
          TabTrans^.ttTabRegion_kb05,
          TabTrans^.ttTabRegion_kb05 = TabRegionGlob.rglOwnRegion_kb05);
    END;
(*ENDIF*) 
IF  TabTrans^.ttItemKind_kb05 <> ikTabTrans_ekb05
THEN
    k52x_item_error ('kb51t_release_tab_lock/1', TabTrans^.ttItemKind_kb05);
(*ENDIF*) 
IF  TabTrans^.ttTab_kb05^.tlItemKind_kb05 <> ikTabLock_ekb05
THEN
    k52x_item_error ('kb51t_release_tab_lock/2', TabTrans^.ttTab_kb05^.tlItemKind_kb05);
(*ENDIF*) 
Tab := TabTrans^.ttTab_kb05;
CASE TabTrans^.ttLockMode_kb05 OF
    lckSysExcl_egg00, lckTabExcl_egg00:
        (* in case of keep Lock TransIndex may be overwritten *)
        IF  Tab^.tlExclTransIndex_kb05 = ThisTrans^.teOwnIndex_kb05
        THEN
            BEGIN
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                ((Tab^.tlFirstReqTab_kb05 <> NIL) OR
                ( Tab^.tlFirstReqRow_kb05 <> NIL))
            THEN
                vbegexcl (TaskId, g08lockreq);
            (*ENDIF*) 
            Tab^.tlExclTransIndex_kb05 := cgg_nil_transindex;
            Tab^.tlIsSysExcl_kb05      := false;
            (**)
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                ((Tab^.tlFirstReqTab_kb05 <> NIL) OR
                ( Tab^.tlFirstReqRow_kb05 <> NIL))
            THEN
                vendexcl (TaskId, g08lockreq)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    lckSysShare_egg00:
        Tab^.tlSysShareLocks_kb05 := Tab^.tlSysShareLocks_kb05 - 1;
    lckTabShare_egg00:
        BEGIN
        Tab^.tlTabShareLocks_kb05 := Tab^.tlTabShareLocks_kb05 - 1;
        IF  k51glob.glDeadlockDetection_kb05 > 0
        THEN
            BEGIN
            IF  (Tab^.tlShare1TransIndex_kb05 = ThisTrans^.teOwnIndex_kb05)
                OR
                (Tab^.tlShare2TransIndex_kb05 = ThisTrans^.teOwnIndex_kb05)
            THEN
                BEGIN
                IF  (Tab^.tlFirstReqTab_kb05 <> NIL) OR
                    (Tab^.tlFirstReqRow_kb05 <> NIL)
                THEN
                    vbegexcl (TaskId, g08lockreq);
                (*ENDIF*) 
                IF  Tab^.tlShare1TransIndex_kb05 =
                    ThisTrans^.teOwnIndex_kb05
                THEN
                    Tab^.tlShare1TransIndex_kb05 := cgg_nil_transindex
                ELSE
                    Tab^.tlShare2TransIndex_kb05 := cgg_nil_transindex;
                (*ENDIF*) 
                IF  (Tab^.tlFirstReqTab_kb05 <> NIL) OR
                    (Tab^.tlFirstReqRow_kb05 <> NIL)
                THEN
                    vendexcl (TaskId, g08lockreq)
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    OTHERWISE ;
    END;
(*ENDCASE*) 
IF  ReleaseRowLocks
THEN
    BEGIN
    Tab^.tlRowShareLocks_kb05 := Tab^.tlRowShareLocks_kb05 - TabTrans^.ttRowShareLocks_kb05;
    Tab^.tlRowOptimCnt_kb05   := Tab^.tlRowOptimCnt_kb05   - TabTrans^.ttRowOptimCnt_kb05;
    Tab^.tlRowExclLocks_kb05  := Tab^.tlRowExclLocks_kb05  - TabTrans^.ttRowExclLocks_kb05
    END;
(*ENDIF*) 
;
&ifdef TRACE
t01p2int4 (kb_lock, 'RowShareLcks', Tab^.tlRowShareLocks_kb05
      ,             'RowExclLocks', Tab^.tlRowExclLocks_kb05);
k52xtab_lock (kb_lockentry, Tab);
&endif
IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g01check (kb51c1TReleaseTabLock_csp03, csp3_n_lock,
          'Tab rel: sys share < 0  ', Tab^.tlSysShareLocks_kb05,
          Tab^.tlSysShareLocks_kb05 >= 0);
    g01check (kb51c2TReleaseTabLock_csp03, csp3_n_lock,
          'Tab rel: Tab share < 0  ', Tab^.tlTabShareLocks_kb05,
          Tab^.tlTabShareLocks_kb05 >= 0);
    g01check (kb51c3TReleaseTabLock_csp03, csp3_n_lock,
          'Tab rel: Row share < 0  ', Tab^.tlRowShareLocks_kb05,
          Tab^.tlRowShareLocks_kb05 >= 0);
    g01check (kb51c4TReleaseTabLock_csp03, csp3_n_lock,
          'Tab rel: Row optim < 0  ', Tab^.tlRowOptimCnt_kb05,
          Tab^.tlRowOptimCnt_kb05 >= 0);
    g01check (kb51c5TReleaseTabLock_csp03, csp3_n_lock,
          'Tab rel: Row excl < 0   ', Tab^.tlRowExclLocks_kb05,
          Tab^.tlRowExclLocks_kb05 >= 0)
    END;
(*ENDIF*) 
kb51t_satisfy_tab_lock (TaskId, TabRegionGlob, Tab, TabTrans^.ttLockMode_kb05);
kb51try_free_tab_lock  (TaskId, TabRegionGlob, Tab, TabTrans^.ttTabHash_kb05);
IF  Tab = NIL
THEN
    TabTrans^.ttTab_kb05 := NIL
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51tab_already_locked (
            TaskId            : tsp00_TaskId;
            ThisTrans         : tkb05_TransEntryPtr;
            Tab               : tkb05_TabTransPtr;
            VAR WantedLock    : tkb05_WantedLock;
            VAR AlreadyLocked : boolean);
 
VAR
      RowInsteadOfSys : boolean;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
AlreadyLocked   := false;
RowInsteadOfSys := false;
CASE WantedLock.wlMode_kb05 OF
    lckSysExcl_egg00:
        AlreadyLocked := (Tab^.ttLockMode_kb05 = lckSysExcl_egg00);
    lckSysShare_egg00:
        IF  (Tab^.ttRowExclLocks_kb05  > 0) OR
            (Tab^.ttRowShareLocks_kb05 > 0)
        THEN
            BEGIN
            AlreadyLocked   := true;
            RowInsteadOfSys := true
            END
        ELSE
            IF  Tab^.ttLockMode_kb05 <> lckFree_egg00
            THEN
                BEGIN
                AlreadyLocked := true;
                (* TEMP state of tab_share remains unchanged *)
                IF  (Tab^.ttLockMode_kb05 = lckSysShare_egg00)
                    AND NOT (lrsConsistent_egg00 in WantedLock.wlState_kb05)
                    AND     (lrsConsistent_egg00 in   Tab^.ttLockState_kb05)
                THEN
                    BEGIN
                    vbegexcl (TaskId, g08lock0 + ThisTrans^.teOwnRegion_kb05);
                    Tab^.ttLockState_kb05 := Tab^.ttLockState_kb05 - [lrsConsistent_egg00];
                    k52flush_tab_trans (Tab^);
                    vendexcl (TaskId, g08lock0 + ThisTrans^.teOwnRegion_kb05)
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    lckTabExcl_egg00, lckRowExcl_egg00:
        AlreadyLocked :=
              (Tab^.ttLockMode_kb05 = lckSysExcl_egg00) OR
              (Tab^.ttLockMode_kb05 = lckTabExcl_egg00);
    lckTabShare_egg00:
        IF  (Tab^.ttLockMode_kb05 = lckSysExcl_egg00 ) OR
            (Tab^.ttLockMode_kb05 = lckTabExcl_egg00 ) OR
            (Tab^.ttLockMode_kb05 = lckTabShare_egg00)
        THEN
            BEGIN
            AlreadyLocked := true;
            IF  (Tab^.ttLockMode_kb05 = lckTabShare_egg00)
                AND NOT (lrsTemp_egg00 in WantedLock.wlState_kb05)
                AND     (lrsTemp_egg00 in   Tab^.ttLockState_kb05)
            THEN
                BEGIN
                k52begexcl_region (TaskId, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
                Tab^.ttLockState_kb05 := Tab^.ttLockState_kb05 - [lrsTemp_egg00];
                IF  (Tab^.ttFirstRow_kb05 <> NIL)
                    AND
                    ((Tab^.ttRowShareLocks_kb05 > 0) OR
                    ( Tab^.ttRowOptimCnt_kb05   > 0))
                THEN
                    kb51rows_remove (TaskId, TransRgnGlobPtr^, ThisTrans, Tab, NOT REMOVE_EXCL_ROWS)
                ELSE
                    k52flush_tab_trans (Tab^);
                (*ENDIF*) 
                k52endexcl_region (TaskId, TransRgnGlobPtr)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    lckRowShare_egg00, lckRowOptimistic_egg00:
        AlreadyLocked :=
              (Tab^.ttLockMode_kb05 = lckSysExcl_egg00)
              OR
              (Tab^.ttLockMode_kb05 = lckTabExcl_egg00)
              OR
              ((Tab^.ttLockMode_kb05 = lckTabShare_egg00)
              AND NOT (lrsTemp_egg00 in Tab^.ttLockState_kb05))
    END;
(*ENDCASE*) 
IF  AlreadyLocked
    AND NOT (lrsEotExcl_egg00 in   Tab^.ttLockState_kb05)
    AND     (lrsEotExcl_egg00 in WantedLock.wlState_kb05)
THEN
    BEGIN
    vbegexcl (TaskId, g08lock0 + Tab^.ttTabRegion_kb05);
    WITH Tab^.ttTab_kb05^ DO
        tlTabOptimVers_kb05 := tlTabOptimVers_kb05 + 1;
    (*ENDWITH*) 
    k52flush_tab_lock (Tab^.ttTab_kb05^);
    vendexcl (TaskId, g08lock0 + Tab^.ttTabRegion_kb05);
    (**)
    k52begexcl_region (TaskId, ThisTrans^.teOwnRegion_kb05, TransRgnGlobPtr);
    IF  ThisTrans^.teLockMode_kb05 = tlmEotExcl_ekb05
    THEN
        BEGIN
        ThisTrans^.teLockMode_kb05 := tlmEotExcl_ekb05;
        Tab^.ttLockState_kb05      := Tab^.ttLockState_kb05 + [lrsEotExcl_egg00];
        k52flush_trans_entry (ThisTrans^);
        k52flush_tab_trans   (Tab^)
        END
    ELSE
        AlreadyLocked := false;
    (*ENDIF*) 
    k52endexcl_region (TaskId, TransRgnGlobPtr)
    END;
(*ENDIF*) 
IF  AlreadyLocked
THEN
    BEGIN
    WantedLock.wlGrantedMode_kb05 := Tab^.ttLockMode_kb05;
    IF  RowInsteadOfSys
    THEN
        BEGIN
        IF  Tab^.ttRowExclLocks_kb05 > 0
        THEN
            WantedLock.wlGrantedMode_kb05 := lckRowExcl_egg00
        ELSE
            WantedLock.wlGrantedMode_kb05 := lckRowShare_egg00
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
t01bool (kb_lock, 'AlreadyLcked', AlreadyLocked);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51tab_collision (
            TransIndex     : tgg00_TransIndex;
            TabLock        : tkb05_TabLockPtr;
            WantedLockMode : tgg00_LockReqMode;
            OwnSysShare    : tsp00_Int4;
            OwnTabShare    : tsp00_Int4;
            OwnRowShare    : tsp00_Int4;
            OwnRowExcl     : tsp00_Int4;
            VAR err        : tgg00_BasisError);
 
VAR
      CollisionTrans : tkb05_TransEntryPtr;
 
BEGIN
(* within specific Tab Region *)
err := e_ok;
&ifdef TRACE
k52xtab_lock (kb_lockentry, TabLock);
&endif
IF  TabLock^.tlItemKind_kb05 <> ikTabLock_ekb05
THEN
    k52x_item_error ('kb51tab_collision       ', TabLock^.tlItemKind_kb05);
(*ENDIF*) 
WITH TabLock^ DO
    BEGIN
    CASE WantedLockMode OF
        lckSysShare_egg00:
            IF  (tlExclTransIndex_kb05 <> cgg_nil_transindex) AND
                (tlExclTransIndex_kb05 <> TransIndex        ) AND
                tlIsSysExcl_kb05
            THEN
                err := e_lock_collision;
            (*ENDIF*) 
        lckSysExcl_egg00:
            IF  (tlTabShareLocks_kb05 - OwnTabShare > 0) OR
                (tlRowShareLocks_kb05 - OwnRowShare > 0) OR
                (tlRowExclLocks_kb05  - OwnRowExcl  > 0) OR
                (tlSysShareLocks_kb05 - OwnSysShare > 0) OR
                (   (tlExclTransIndex_kb05 <> cgg_nil_transindex)
                AND (tlExclTransIndex_kb05 <> TransIndex       ))
            THEN
                err := e_lock_collision;
            (*ENDIF*) 
        lckTabShare_egg00:
            IF  (tlRowExclLocks_kb05 - OwnRowExcl > 0)
                OR
                ((tlExclTransIndex_kb05 <> cgg_nil_transindex) AND
                ( tlExclTransIndex_kb05 <> TransIndex       ))
            THEN
                err := e_lock_collision;
            (*ENDIF*) 
        lckTabExcl_egg00:
            IF  (tlTabShareLocks_kb05 - OwnTabShare > 0) OR
                (tlRowShareLocks_kb05 - OwnRowShare > 0) OR
                (tlRowExclLocks_kb05  - OwnRowExcl  > 0) OR
                (   (tlExclTransIndex_kb05 <> cgg_nil_transindex)
                AND (tlExclTransIndex_kb05 <> TransIndex       ))
            THEN
                err := e_lock_collision;
            (*ENDIF*) 
        lckRowShare_egg00, lckRowOptimistic_egg00:
            IF  (tlExclTransIndex_kb05 <> cgg_nil_transindex) AND
                (tlExclTransIndex_kb05 <> TransIndex        )
            THEN
                err := e_lock_collision;
            (*ENDIF*) 
        lckRowExcl_egg00:
            IF  (tlTabShareLocks_kb05 - OwnTabShare > 0)
                OR
                ((tlExclTransIndex_kb05 <> cgg_nil_transindex) AND
                ( tlExclTransIndex_kb05 <> TransIndex       ))
            THEN
                err := e_lock_collision;
            (*ENDIF*) 
        OTHERWISE
            err := e_not_implemented
        END;
    (*ENDCASE*) 
    IF  (g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00)
        AND
        (err <> e_ok)
    THEN
        kb51vtrace_tab (m_lock, mm_table, TransIndex, WantedLockMode, TabLock);
    (*ENDIF*) 
    IF  err = e_lock_collision
    THEN
        BEGIN
        IF  (tlExclTransIndex_kb05 <> cgg_nil_transindex) AND
            (tlExclTransIndex_kb05 <> TransIndex        )
        THEN
            BEGIN
            k52acc_trans_entry (tlExclTransIndex_kb05, CollisionTrans);
            IF  (CollisionTrans^.teReqMode_kb05 = tlmFree_ekb05)
                AND                                                  (* dirty read *)
                (tiUserTask_ekb05 in CollisionTrans^.teInfo_kb05)
            THEN
                vprio (CollisionTrans^.teTaskId_kb05, USER_LOCK_PRIO, SET_PRIO)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
&ifdef TRACE
t01basis_error (kb_lock, 'end tab_coll', err);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51tab_hash (
            VAR TabId         : tgg00_Surrogate;
            VAR TabHash       : tsp00_Int4;
            VAR TabRegion     : tkb05_RegionNo);
 
VAR
      Number : tsp00_Int4;
 
BEGIN
(* outside Region *)
IF  kb560IsSys2CatalogTable (TabId)
THEN
    BEGIN
    TabRegion := 1;
    TabHash   := 1
    END
ELSE
    BEGIN
    Number := (ord (TabId [6]) + ord (TabId [2])) * 65536
          +    ord (TabId [7]) * 256
          +    ord (TabId [8]);
    TabRegion := 1 + (Number MOD k51glob.glTabRegions_kb05);
    TabHash   := 1 + (Number MOD k51glob.glTabHashEntriesPerRegion_kb05);
    IF  (TabHash = 1) AND (TabRegion = 1) AND (k51glob.glTabHashEntriesPerRegion_kb05 > 1)
    THEN
        (* Hash 1 of region 1 is reserved for syscatalog2 *)
        TabHash := 2
    (*ENDIF*) 
    END;
(*ENDIF*) 
TabRegion := k51glob.glTransRegions_kb05 + TabRegion;
&ifdef TRACE
t01p2int4 (kb_lock, 'TabHash     ', TabHash
      ,             'TabRegion   ', TabRegion);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51tab_lock_check_ins (
            VAR t             : tgg00_TransContext;
            AccessedTabRgnPtr : tkb05_RegionGlobPtr;
            VAR WantedLock    : tkb05_WantedLock;
            TransLockMode     : tkb05_TransLockMode;
            IgnoreReqPriority : boolean;
            TabTrans          : tkb05_TabTransPtr;
            RowTrans          : tkb05_RowTransPtr;
            VAR TabRegion     : tkb05_RegionNo;
            VAR TabHash       : tsp00_Int4;
            VAR TabLock       : tkb05_TabLockPtr;
            VAR TabOptimVers  : tsp00_Int4;
            VAR Collided      : boolean;
            VAR WaitInserted  : boolean);
 
VAR
      IsInserted    : boolean;
      IsOwnTab      : boolean;
      TabFound      : boolean;
      OwnLockMode   : tgg00_LockReqMode;
      OwnSysShare   : tsp00_Int4;
      OwnTabShare   : tsp00_Int4;
      OwnRowShare   : tsp00_Int4;
      OwnRowExcl    : tsp00_Int4;
      PrevTab       : tkb05_TabLockPtr;
      ThisTrans     : tkb05_TransEntryPtr;
      TabRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
&ifdef TRACE
k52xaddr_tabt (kb_lock, 'TabTrans    ', TabTrans);
k52xaddr_tabl (kb_lock, 'TabLock     ', TabLock);
t01bool       (kb_lock, 'Collided    ', Collided);
&endif
IF  (AccessedTabRgnPtr <> NIL) AND kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08excl_check (t.trTaskId_gg00, g08lock0 + AccessedTabRgnPtr^.rglOwnRegion_kb05);
(*ENDIF*) 
t.trError_gg00 := e_ok;
IsOwnTab       := (TabLock <> NIL);
IsInserted     := false;
TabOptimVers   := 0;
OwnLockMode    := lckFree_egg00;
OwnSysShare    := 0;
OwnTabShare    := 0;
PrevTab        := NIL;
IF  TabTrans = NIL
THEN
    BEGIN
    kb51tab_hash (WantedLock.wlTabId_kb05, TabHash, TabRegion);
    OwnRowShare := 0;
    OwnRowExcl  := 0
    END
ELSE
    BEGIN
    IF  TabTrans^.ttItemKind_kb05 <> ikTabTrans_ekb05
    THEN
        k52x_item_error ('kb51tab_lock_check_ins/1', TabTrans^.ttItemKind_kb05);
    (*ENDIF*) 
    TabRegion   := TabTrans^.ttTabRegion_kb05;
    TabHash     := TabTrans^.ttTabHash_kb05;
    OwnRowShare := TabTrans^.ttRowShareLocks_kb05;
    OwnRowExcl  := TabTrans^.ttRowExclLocks_kb05;
    OwnLockMode := TabTrans^.ttLockMode_kb05;
    IF  OwnLockMode = lckSysShare_egg00
    THEN
        OwnSysShare := 1;
    (*ENDIF*) 
    IF  OwnLockMode = lckTabShare_egg00
    THEN
        OwnTabShare := 1
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  AccessedTabRgnPtr = NIL
THEN
    k52begexcl_region (t.trTaskId_gg00, TabRegion, TabRgnGlobPtr)
ELSE
    BEGIN
    TabRgnGlobPtr := AccessedTabRgnPtr;
    IF  kb03Check.chkLock_kb00
    THEN
        g01check (kbMsg_csp03, csp3_n_lock,
              'kb51tab_lo: wrong TabReg', TabRegion,
              TabRegion = TabRgnGlobPtr^.rglOwnRegion_kb05);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  IsOwnTab
THEN
    TabFound := true
ELSE
    kb51tablock_search (TabRgnGlobPtr^,
          WantedLock.wlTabId_kb05, TabHash, TabLock, PrevTab, TabFound);
(*ENDIF*) 
IF  NOT Collided AND (hdCheckCollision_ekb05 in WantedLock.wlHandling_kb05)
THEN
    BEGIN
    IF  TabFound
    THEN
        kb51tab_collision (t.trIndex_gg00, TabLock, WantedLock.wlMode_kb05,
              OwnSysShare, OwnTabShare, OwnRowShare, OwnRowExcl, t.trError_gg00);
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok)
        AND TabFound
        AND WantedLock.wlRowWanted_kb05
        AND NOT IgnoreReqPriority
    THEN
        BEGIN
        IF  (TabLock^.tlFirstReqTab_kb05 <> NIL)
            AND (OwnLockMode = lckFree_egg00)
            AND (OwnRowShare = 0)
            AND (OwnRowExcl  = 0)
            AND (TransLockMode <> tlmEotExcl_ekb05)
        THEN
            (* queue behind Tab requests *)
            t.trError_gg00 := e_lock_collision
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_lock_collision
    THEN
        BEGIN
        Collided       := true;
        t.trError_gg00 := e_ok
        END;
    (*ENDIF*) 
    IF  Collided
    THEN
        WITH TabRgnGlobPtr^ DO
            (* PTS 1103743 JA 1999-08-25 *)
            rglCollisions_kb05 := rglCollisions_kb05 + ONE_8BYTE_CNT_GG04;
        (*ENDWITH*) 
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) AND TabFound AND (RowTrans <> NIL)
    THEN
        BEGIN
        IF  RowTrans^.rtItemKind_kb05 <> ikRowTrans_ekb05
        THEN
            k52x_item_error ('kb51tab_lock_check_ins/2', RowTrans^.rtItemKind_kb05);
        (*ENDIF*) 
        IF  (RowTrans^.rtLockMode_kb05 = lckRowOptimistic_egg00)
            AND
            (WantedLock.wlMode_kb05    = lckRowExcl_egg00)
            AND
            (RowTrans^.rtTabOptimVers_kb05 <> TabLock^.tlTabOptimVers_kb05)
        THEN
            t.trError_gg00 := e_lock_dirty
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND NOT TabFound
    AND
    (((hdInsLock_ekb05 in WantedLock.wlHandling_kb05) AND NOT Collided)
    OR
    ( (hdInsReq_ekb05  in WantedLock.wlHandling_kb05) AND     Collided))
THEN
    BEGIN
    kb51new_tablock (t, TabRgnGlobPtr^, TabHash, PrevTab, TabLock);
    IF  t.trError_gg00 = e_ok
    THEN
        TabLock^.tlTabId_kb05 := WantedLock.wlTabId_kb05
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  TabLock <> NIL
THEN
    BEGIN
    IF  TabLock^.tlItemKind_kb05 <> ikTabLock_ekb05
    THEN
        k52x_item_error ('kb51tab_lock_check_ins/3', TabLock^.tlItemKind_kb05)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND NOT Collided
    AND
    (hdInsLock_ekb05 in WantedLock.wlHandling_kb05)
THEN
    BEGIN
    IsInserted := true;
    CASE WantedLock.wlMode_kb05 OF
        lckSysShare_egg00:
            TabLock^.tlSysShareLocks_kb05 := TabLock^.tlSysShareLocks_kb05 + 1;
        lckSysExcl_egg00, lckTabExcl_egg00:
            BEGIN
            (* in case of keep Lock: TransIndex may be overwritten *)
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                ((TabLock^.tlFirstReqTab_kb05 <> NIL) OR
                ( TabLock^.tlFirstReqRow_kb05 <> NIL))
            THEN
                vbegexcl (t.trTaskId_gg00, g08lockreq);
            (*ENDIF*) 
            TabLock^.tlExclTransIndex_kb05 := t.trIndex_gg00;
            (**)
            IF  TabLock^.tlShare1TransIndex_kb05 = t.trIndex_gg00
            THEN
                TabLock^.tlShare1TransIndex_kb05 := cgg_nil_transindex
            ELSE
                IF  TabLock^.tlShare2TransIndex_kb05 = t.trIndex_gg00
                THEN
                    TabLock^.tlShare2TransIndex_kb05 := cgg_nil_transindex;
                (*ENDIF*) 
            (*ENDIF*) 
            IF  (k51glob.glDeadlockDetection_kb05 > 0)
                AND
                ((TabLock^.tlFirstReqTab_kb05 <> NIL) OR
                ( TabLock^.tlFirstReqRow_kb05 <> NIL))
            THEN
                BEGIN
                k52flush_tab_lock (TabLock^);
                vendexcl (t.trTaskId_gg00, g08lockreq)
                END;
            (*ENDIF*) 
            WITH TabLock^ DO
                BEGIN
                tlIsSysExcl_kb05     := (WantedLock.wlMode_kb05 = lckSysExcl_egg00);
                tlTabShareLocks_kb05 := tlTabShareLocks_kb05 - OwnTabShare;
                tlSysShareLocks_kb05 := tlSysShareLocks_kb05 - OwnSysShare;
                IF  (WantedLock.wlMode_kb05 = lckSysExcl_egg00)
                    OR
                    (lrsEotExcl_egg00 in WantedLock.wlState_kb05)
                THEN
                    tlTabOptimVers_kb05 := tlTabOptimVers_kb05 + 1
                (*ENDIF*) 
                END
            (*ENDWITH*) 
            END;
        lckTabShare_egg00:
            BEGIN
            TabLock^.tlTabShareLocks_kb05 := TabLock^.tlTabShareLocks_kb05 + 1;
            TabLock^.tlSysShareLocks_kb05 := TabLock^.tlSysShareLocks_kb05 - OwnSysShare;
            IF  k51glob.glDeadlockDetection_kb05 > 0
            THEN
                BEGIN
                IF  ((TabLock^.tlShare1TransIndex_kb05 = cgg_nil_transindex) OR
                    ( TabLock^.tlShare2TransIndex_kb05 = cgg_nil_transindex))
                    AND
                    (TabLock^.tlShare1TransIndex_kb05 <> t.trIndex_gg00)
                    AND
                    (TabLock^.tlShare2TransIndex_kb05 <> t.trIndex_gg00)
                THEN
                    BEGIN
                    IF  (TabLock^.tlFirstReqTab_kb05 <> NIL) OR
                        (TabLock^.tlFirstReqRow_kb05 <> NIL)
                    THEN
                        vbegexcl (t.trTaskId_gg00, g08lockreq);
                    (*ENDIF*) 
                    IF  TabLock^.tlShare1TransIndex_kb05 = cgg_nil_transindex
                    THEN
                        TabLock^.tlShare1TransIndex_kb05 := t.trIndex_gg00
                    ELSE
                        TabLock^.tlShare2TransIndex_kb05 := t.trIndex_gg00;
                    (*ENDIF*) 
                    IF  (TabLock^.tlFirstReqTab_kb05 <> NIL) OR
                        (TabLock^.tlFirstReqRow_kb05 <> NIL)
                    THEN
                        BEGIN
                        k52flush_tab_lock (TabLock^);
                        vendexcl (t.trTaskId_gg00, g08lockreq)
                        END
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        lckRowShare_egg00:
            TabLock^.tlRowShareLocks_kb05 := TabLock^.tlRowShareLocks_kb05 + 1;
        lckRowExcl_egg00:
            (* PTS 1107452 JA 2000-08-08 *)
            TabLock^.tlRowExclLocks_kb05 := TabLock^.tlRowExclLocks_kb05 + 1;
        lckRowOptimistic_egg00:
            TabLock^.tlRowOptimCnt_kb05 := TabLock^.tlRowOptimCnt_kb05 + 1;
        OTHERWISE
            t.trError_gg00 := e_not_implemented
        END;
    (*ENDCASE*) 
    TabOptimVers := TabLock^.tlTabOptimVers_kb05;
&   ifdef TRACE
    t01p2int4 (kb_lock, 'RowShareLcks', TabLock^.tlRowShareLocks_kb05
          ,             'RowExclLocks', TabLock^.tlRowExclLocks_kb05);
&   endif
    END;
(*ENDIF*) 
IF  (t.trError_gg00 = e_ok) AND Collided
THEN
    BEGIN
    IF  hdInsReq_ekb05 in WantedLock.wlHandling_kb05
    THEN
        BEGIN
        IsInserted := true;
        IF  WantedLock.wlRowWanted_kb05
        THEN
            (* ReqRow list *)
            kb51new_req (t, TabRgnGlobPtr^,
                  WantedLock.wlMode_kb05,
                  WantedLock.wlState_kb05,
                  TransLockMode,
                  OwnLockMode, OwnRowShare, OwnRowExcl,
                  TabLock^.tlFirstReqRow_kb05, WaitInserted)
        ELSE
            (* ReqTab list *)
            kb51new_req (t, TabRgnGlobPtr^,
                  WantedLock.wlMode_kb05,
                  WantedLock.wlState_kb05,
                  TransLockMode,
                  OwnLockMode, OwnRowShare, OwnRowExcl,
                  TabLock^.tlFirstReqTab_kb05, WaitInserted)
        (*ENDIF*) 
        END
    ELSE
        IF  (hdCheckOwnReq_ekb05 in WantedLock.wlHandling_kb05)
            AND NOT WaitInserted
        THEN
            BEGIN
            vbegexcl (t.trTaskId_gg00, g08lockwait);
            k52acc_trans_entry (t.trIndex_gg00, ThisTrans);
            ThisTrans^.teWaiting_kb05 := true;
            k52flush_trans_waiting (ThisTrans^.teWaiting_kb05);
            vendexcl (t.trTaskId_gg00, g08lockwait);
            WaitInserted := true
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
k52xtab_lock (kb_lockentry, TabLock);
&endif
IF  AccessedTabRgnPtr = NIL
THEN
    BEGIN
    IF  TabLock <> NIL
    THEN
        k52flush_tab_lock (TabLock^);
    (*ENDIF*) 
    k52endexcl_region (t.trTaskId_gg00, TabRgnGlobPtr)
    END;
(*ENDIF*) 
IF  NOT IsInserted AND NOT IsOwnTab
THEN
    TabLock := NIL;
(*ENDIF*) 
;
&ifdef TRACE
k52xaddr_tabl  (kb_lock, 'TabLock     ', TabLock);
t01bool        (kb_lock, 'Collided    ', Collided);
t01basis_error (kb_lock, 'end tab_lock', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      kb51ExclusiveRequestExists (TaskId : tsp00_TaskId;
            VAR WantedTabId : tgg00_Surrogate) : boolean;
 
VAR
      TabRegion         : tkb05_RegionNo;
      TabHash           : tsp00_Int4;
      TabRegionGlobPtr  : tkb05_RegionGlobPtr;
      TabLock           : tkb05_TabLockPtr;
      DummyPrevTab      : tkb05_TabLockPtr;
      request           : tkb05_ReqPtr;
      ItemCnt           : tsp00_Int4;
      TabFound          : boolean;
      result            : boolean;
 
BEGIN
result := false;
kb51tab_hash (WantedTabId, TabHash, TabRegion);
k52begexcl_region (TaskId, TabRegion, TabRegionGlobPtr);
kb51tablock_search (TabRegionGlobPtr^, WantedTabId, TabHash,
      TabLock, DummyPrevTab, TabFound);
IF  TabFound AND (TabLock <> NIL)
THEN
    BEGIN
    ItemCnt := 0;
    request := TabLock^.tlFirstReqTab_kb05;
    WHILE (request <> NIL) AND NOT result
          AND
          (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        IF  (request^.rqReqMode_kb05 = lckTabExcl_egg00)
            OR
            (request^.rqReqMode_kb05 = lckSysExcl_egg00)
        THEN
            result := true
        ELSE
            BEGIN
            request := request^.rqNextReq_kb05;
            ItemCnt := ItemCnt + 1;
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
    THEN
        k52x_loop_error ('kb51ExclusiveRequestExis', 1);
    (*ENDIF*) 
    ItemCnt := 0;
    request := TabLock^.tlFirstReqRow_kb05;
    WHILE (request <> NIL) AND NOT result
          AND
          (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        IF  request^.rqReqMode_kb05 = lckRowExcl_egg00
        THEN
            result := true
        ELSE
            BEGIN
            request := request^.rqNextReq_kb05;
            ItemCnt := ItemCnt + 1;
            END;
        (*ENDIF*) 
        END;
    (*ENDWHILE*) 
    IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
    THEN
        k52x_loop_error ('kb51ExclusiveRequestExis', 2);
    (*ENDIF*) 
    END;
(*ENDIF*) 
k52endexcl_region (TaskId, TabRegionGlobPtr);
kb51ExclusiveRequestExists := result;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51tab_remove (
            TaskId              : tsp00_TaskId;
            VAR TransRegionGlob : tkb05_RegionGlob;
            ThisTrans           : tkb05_TransEntryPtr;
            VAR Tab             : tkb05_TabTransPtr);
 
VAR
      TabRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (TaskId, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51tab_re: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransRegionGlob.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
k52begexcl_region (TaskId, Tab^.ttTabRegion_kb05, TabRgnGlobPtr);
kb51t_release_tab_lock (TaskId, TabRgnGlobPtr^, ThisTrans, Tab, NOT RELEASE_ROW_LOCKS);
k52endexcl_region (TaskId, TabRgnGlobPtr);
(* *)
Tab^.ttLockMode_kb05  := lckFree_egg00;
Tab^.ttLockState_kb05 := [ ];
IF  Tab^.ttFirstRow_kb05 = NIL
THEN
    kb51rm_tab_trans_remove (TaskId, TransRegionGlob, ThisTrans, Tab)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51tab_trans_insert (
            VAR t                 : tgg00_TransContext;
            VAR TransRegionGlob   : tkb05_RegionGlob;
            InsertReq             : boolean;
            ThisTrans             : tkb05_TransEntryPtr;
            VAR WantedLock        : tkb05_WantedLock;
            TabRegion             : tkb05_RegionNo;
            TabHash               : tsp00_Int4;
            TabLock               : tkb05_TabLockPtr;
            PrevTab               : tkb05_TabTransPtr;
            VAR Tab               : tkb05_TabTransPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
&ifdef TRACE
t01bool       (kb_lock, 'InsertReq   ', InsertReq);
k52xaddr_tabl (kb_lock, 'TabLock     ', TabLock);
k52xaddr_tabt (kb_lock, 'Tab         ', Tab     );
k52xaddr_tabt (kb_lock, 'PrevTab     ', PrevTab);
&endif
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08excl_check (t.trTaskId_gg00, g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51tab_tr: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransRegionGlob.rglOwnRegion_kb05)
    END;
(*ENDIF*) 
t.trError_gg00 := e_ok;
IF  Tab = NIL
THEN
    BEGIN
    kb51get_supply_item (t, TransRegionGlob, ikTabTrans_ekb05, UnivItemPtr);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        Tab                   := UnivItemPtr.uiTabTrans_kb05;
        Tab^.ttTab_kb05       := TabLock;
        Tab^.ttTabId_kb05     := WantedLock.wlTabId_kb05;
        Tab^.ttTabRegion_kb05 := TabRegion;
        Tab^.ttTabHash_kb05   := TabHash;
        IF  PrevTab = NIL
        THEN
            BEGIN
            Tab^.ttNextTab_kb05        := ThisTrans^.teFirstTab_kb05;
            ThisTrans^.teFirstTab_kb05 := Tab
            END
        ELSE
            BEGIN
            Tab^.ttNextTab_kb05     := PrevTab^.ttNextTab_kb05;
            PrevTab^.ttNextTab_kb05 := Tab
            END;
        (*ENDIF*) 
        WITH TransRegionGlob.rglTransGlob_kb05^ DO
            (* PTS 1103743 JA 1999-08-25 *)
            trTabEntryAmount_kb05 := trTabEntryAmount_kb05 + ONE_8BYTE_CNT_GG04;
        (*ENDWITH*) 
        ;
&       ifdef TRACE
        IF  kb03Check.chkLockSupply_kb00
        THEN
            k52xaddr_tabt_check (TransRegionGlob, Tab);
&       endif
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    IF  InsertReq
    THEN
        BEGIN
        IF  k51glob.glDeadlockDetection_kb05 > 0
        THEN
            vbegexcl (t.trTaskId_gg00, g08lockreq);
        (*ENDIF*) 
        ThisTrans^.teReqTab_kb05 := Tab;
        Tab^.ttReqMode_kb05      := WantedLock.wlMode_kb05;
        Tab^.ttReqState_kb05     := WantedLock.wlState_kb05;
        (**)
        IF  k51glob.glDeadlockDetection_kb05 > 0
        THEN
            BEGIN
            k52flush_trans_entry (ThisTrans^);
            k52flush_tab_trans   (Tab^);
            vendexcl (t.trTaskId_gg00, g08lockreq)
            END
        (*ENDIF*) 
        END
    ELSE
        kb51ins_tab_mode (Tab, WantedLock.wlMode_kb05, WantedLock.wlState_kb05)
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
k52xtab_trans  (kb_lockentry, Tab);
t01basis_error (kb_lock, 'end tab_tran', t.trError_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51tabid_search (
            ThisTrans             : tkb05_TransEntryPtr;
            VAR WantedTabid       : tgg00_Surrogate;
            VAR Tab               : tkb05_TabTransPtr;
            VAR InsPrevTab        : tkb05_TabTransPtr);
 
VAR
      Found   : boolean;
      ItemCnt : tsp00_Int4;
 
BEGIN
Found      := false;
Tab        := NIL;
InsPrevTab := NIL;
IF  ThisTrans^.teTabRecentlyUsed_kb05 <> NIL
THEN
    BEGIN
    IF  ThisTrans^.teTabRecentlyUsed_kb05^.ttItemKind_kb05 <> ikTabTrans_ekb05
    THEN
        k52x_item_error ('kb51tabid_search/1      ',
              ThisTrans^.teTabRecentlyUsed_kb05^.ttItemKind_kb05);
    (*ENDIF*) 
    IF  WantedTabid = ThisTrans^.teTabRecentlyUsed_kb05^.ttTabId_kb05
    THEN
        BEGIN
        Found := true;
        Tab   := ThisTrans^.teTabRecentlyUsed_kb05
        END
    ELSE
        IF  WantedTabid > ThisTrans^.teTabRecentlyUsed_kb05^.ttTabId_kb05
        THEN
            (* wanted > entry  ==>  start ascending search *)
            BEGIN
            InsPrevTab := ThisTrans^.teTabRecentlyUsed_kb05;
            Tab        := InsPrevTab^.ttNextTab_kb05
            END
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  Tab = NIL
THEN
    Tab := ThisTrans^.teFirstTab_kb05;
(*ENDIF*) 
ItemCnt := 0;
WHILE (Tab <> NIL) AND NOT Found AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
    BEGIN
    IF  Tab^.ttItemKind_kb05 <> ikTabTrans_ekb05
    THEN
        k52x_item_error ('kb51tabid_search/2      ', Tab^.ttItemKind_kb05);
    (*ENDIF*) 
    IF  WantedTabid = Tab^.ttTabId_kb05
    THEN
        Found := true
    ELSE
        IF  WantedTabid < Tab^.ttTabId_kb05
        THEN
            Tab := NIL
        ELSE
            BEGIN
            InsPrevTab := Tab;
            Tab        := Tab^.ttNextTab_kb05
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    ItemCnt := ItemCnt + 1
    END;
(*ENDWHILE*) 
IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
THEN
    k52x_loop_error ('kb51tabid_search        ', 1);
(*ENDIF*) 
IF  Tab <> NIL
THEN
    BEGIN
    IF  Tab^.ttTab_kb05 = NIL
    THEN
        k52x_item_error ('kb51tabid_search/3      ', ikNone_ekb05)
    ELSE
        IF  Tab^.ttTab_kb05^.tlItemKind_kb05 <> ikTabLock_ekb05
        THEN
            k52x_item_error ('kb51tabid_search/4      ', Tab^.ttTab_kb05^.tlItemKind_kb05);
        (*ENDIF*) 
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
k52xaddr_tabt (kb_lock, 'Tab         ', Tab);
k52xaddr_tabt (kb_lock, 'InsPrevTab  ', InsPrevTab);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51tablock_search (
            VAR TabRegionGlob : tkb05_RegionGlob;
            VAR WantedTabId : tgg00_Surrogate;
            TabHash         : tsp00_Int4;
            VAR TabLock     : tkb05_TabLockPtr;
            VAR PrevTab     : tkb05_TabLockPtr;
            VAR TabFound    : boolean);
 
VAR
      ItemCnt : tsp00_Int4;
 
BEGIN
IF  kb03Check.chkRegion_kb00
THEN
    g08check_excl (g08lock0 + TabRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
TabLock  := TabRegionGlob.rglTabHash_kb05^[TabHash];
PrevTab  := NIL;
TabFound := false;
ItemCnt  := 0;
WHILE (TabLock <> NIL) AND NOT TabFound AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
    BEGIN
    IF  (TabLock^.tlItemKind_kb05 <> ikTabLock_ekb05      ) AND
        (TabLock^.tlItemKind_kb05 <> ikConsistView_ekb05  ) AND
        (TabLock^.tlItemKind_kb05 <> ikHashOpenTrans_ekb05)
    THEN
        k52x_item_error ('kb51tablock_search/1    ', TabLock^.tlItemKind_kb05);
    (*ENDIF*) 
    IF  WantedTabId = TabLock^.tlTabId_kb05
    THEN
        TabFound := true
    ELSE
        IF  WantedTabId < TabLock^.tlTabId_kb05
        THEN
            TabLock := NIL
        ELSE
            BEGIN
            PrevTab := TabLock;
            TabLock := TabLock^.tlNextHashTab_kb05
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    ItemCnt := ItemCnt + 1
    END;
(*ENDWHILE*) 
IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
THEN
    k52x_loop_error ('kb51tablock_search      ', 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51tr_finish_trans_lock (
            VAR TransGlob : tkb05_TransGlob;
            ThisTrans : tkb05_TransEntryPtr);
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    BEGIN
    g08check_excl (g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51tr_rel: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransGlob.trOwnRegion_kb05)
    END;
(*ENDIF*) 
IF  ThisTrans^.teObjLockMode_kb05 <> tlmFree_ekb05
THEN
    WITH TransGlob DO
        BEGIN
        trObjLockTransCnt_kb05 := trObjLockTransCnt_kb05 - 1;
        IF  ThisTrans^.teLockMode_kb05 = tlmFree_ekb05
        THEN
            (* JA 1998-08-24 *)
            trConnectOnlyCnt_kb05 := trConnectOnlyCnt_kb05 + 1
        (*ENDIF*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
ThisTrans^.teObjLockMode_kb05 := tlmFree_ekb05;
IF  ThisTrans^.teLockMode_kb05 <> tlmFree_ekb05
THEN
    WITH TransGlob DO
        BEGIN
        trLockTransCnt_kb05   := trLockTransCnt_kb05   - 1;
        trConnectOnlyCnt_kb05 := trConnectOnlyCnt_kb05 + 1;
        END;
    (*ENDWITH*) 
(*ENDIF*) 
ThisTrans^.teObjLockMode_kb05 := tlmFree_ekb05; (* JA 1998-08-24 *)
ThisTrans^.teLockMode_kb05    := tlmFree_ekb05;
kb51reset_trans_entry (ThisTrans)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51_TraceReqTimeout (
            VAR Trans                 : tgg00_TransContext;
            ThisTrans                 : tkb05_TransEntryPtr);
 
VAR
      TimeoutTrace : tgg11_KbTimeoutTrace;
 
BEGIN
IF  g01vtrace.vtrAll_gg00
THEN
    WITH ThisTrans^ DO
        BEGIN
        TimeoutTrace.kbtmoHead_gg11.kbMessType_gg11  := m_rollback;
        TimeoutTrace.kbtmoHead_gg11.kbMessType2_gg11 := mm_nil;
        TimeoutTrace.kbtmoHead_gg11.kbError_gg11     := Trans.trError_gg00;
        TimeoutTrace.kbtmoTask_gg11                  := teTaskId_kb05;
        TimeoutTrace.kbtmoSession_gg11               := teSessionId_kb05;
        TimeoutTrace.kbtmoTransId_gg11               := teWriteTransId_kb05;
        TimeoutTrace.kbtmoSubtrans_gg11              := teSubtransId_kb05;
        b120InsertTrace (Trans, kb, vttKbRequestTimeout_egg00, sizeof (TimeoutTrace), @TimeoutTrace);
        Trans.trError_gg00 := e_ok
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51trans_hash (
            Session           : tgg91_SessionNo;
            VAR TransHash     : tsp00_Int4);
 
VAR
      AuxSession : tgg91_SessionNo;
 
BEGIN
(* outside Region *)
AuxSession              := Session;
AuxSession.ci4_gg00 [1] := chr (0); (* avoid int4 overflow / negative int4 *)
TransHash   := 1 + (gg06SessionGetInt4 (AuxSession) MOD k51glob.glTransHashEntriesPerRegion_kb05);
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51trans_lock_mode_insert (
            VAR TransGlob : tkb05_TransGlob;
            ThisTrans   : tkb05_TransEntryPtr;
            InsertReq   : boolean;
            WantedMode  : tgg00_LockReqMode;
            WantedState : tgg00_LockReqState);
 
VAR
      TransMode : tkb05_TransLockMode;
 
BEGIN
&ifdef TRACE
t01addr (kb_lock, 'ThisTrans   ', ThisTrans);
t01bool (kb_lock, 'InsertReq   ', InsertReq);
&endif
IF  kb03Check.chkRegion_kb00
THEN
    BEGIN
    g08check_excl (g08lock0 + ThisTrans^.teOwnRegion_kb05);
    (* *)
    g01check (kbMsg_csp03, csp3_n_lock,
          'kb51trans_: wrong Region',
          ThisTrans^.teOwnRegion_kb05,
          ThisTrans^.teOwnRegion_kb05 = TransGlob.trOwnRegion_kb05);
    END;
(*ENDIF*) 
IF  InsertReq
THEN
    TransMode := ThisTrans^.teReqMode_kb05
ELSE
    TransMode := ThisTrans^.teLockMode_kb05;
(*ENDIF*) 
IF  TransMode <> tlmEotExcl_ekb05
THEN
    CASE WantedMode OF
        lckSysExcl_egg00, lckTabExcl_egg00, lckRowExcl_egg00:
            IF  lrsEotExcl_egg00 in WantedState
            THEN
                TransMode := tlmEotExcl_ekb05
            ELSE
                TransMode := tlmExcl_ekb05;
            (*ENDIF*) 
        lckSysShare_egg00, lckTabShare_egg00,
        lckRowShare_egg00, lckRowOptimistic_egg00:
            IF  TransMode = tlmFree_ekb05
            THEN
                TransMode := tlmShare_ekb05
            (*ENDIF*) 
        END;
    (*ENDCASE*) 
(*ENDIF*) 
IF  InsertReq
THEN
    BEGIN
    IF  ThisTrans^.teReqMode_kb05 = tlmFree_ekb05
    THEN
        WITH TransGlob DO
            BEGIN
            trReqTransCnt_kb05 := trReqTransCnt_kb05 + 1;
            IF  (ThisTrans^.teLockMode_kb05    = tlmFree_ekb05) AND
                (ThisTrans^.teObjLockMode_kb05 = tlmFree_ekb05) (* JA 1998-08-24 *)
            THEN
                trConnectOnlyCnt_kb05 := trConnectOnlyCnt_kb05 - 1
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    ThisTrans^.teReqMode_kb05 := TransMode
    END
ELSE
    BEGIN
    IF  ThisTrans^.teLockMode_kb05 = tlmFree_ekb05
    THEN
        WITH TransGlob DO
            BEGIN
            trLockTransCnt_kb05 := trLockTransCnt_kb05 + 1;
            IF  (ThisTrans^.teReqMode_kb05     = tlmFree_ekb05) AND
                (ThisTrans^.teObjLockMode_kb05 = tlmFree_ekb05) (* JA 1998-08-24 *)
            THEN
                trConnectOnlyCnt_kb05 := trConnectOnlyCnt_kb05 - 1
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
    (*ENDIF*) 
    ThisTrans^.teLockMode_kb05 := TransMode
    END;
(*ENDIF*) 
&ifdef TRACE
t01int4 (kb_lock, 'TransMode   ', ord (TransMode));
&endif
END;
 
(*------------------------------*) 
 
FUNCTION
      kb51trans_region (Session : tgg91_SessionNo): tkb05_RegionNo;
 
BEGIN
(* outside Region *)
kb51trans_region := 1 + (ord (Session.ci4_gg00 [4]) MOD k51glob.glTransRegions_kb05)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51try_escalation (
            row_locks_per_user_command : tsp00_8ByteCounter;
            VAR WantedLock     : tkb05_WantedLock;
            Tab                : tkb05_TabTransPtr;
            VAR LockEscalation : boolean);
 
BEGIN
IF  (hdCheckCollision_ekb05 in WantedLock.wlHandling_kb05) AND
    (hdInsLock_ekb05        in WantedLock.wlHandling_kb05) AND
    (Tab^.ttRowExclLocks_kb05 + Tab^.ttRowShareLocks_kb05 >= k51glob.glMaxRowsPerTab_kb05)
THEN
    BEGIN
    IF  ( Tab^.ttRowExclLocks_kb05 + Tab^.ttRowShareLocks_kb05 = k51glob.glMaxRowsPerTab_kb05)
        OR
        ((Tab^.ttRowExclLocks_kb05 + Tab^.ttRowShareLocks_kb05) MOD ESCALATION_INTERVAL = 0)
    THEN
        BEGIN
        LockEscalation := true;
        IF  (WantedLock.wlMode_kb05 = lckRowExcl_egg00) (* JA 1997-04-25 *)
            OR
            (Tab^.ttRowExclLocks_kb05 > k51glob.glMaxRowsPerTab_kb05 DIV 2)
        THEN
            WantedLock.wlMode_kb05 := lckTabExcl_egg00
        ELSE
            WantedLock.wlMode_kb05 := lckTabShare_egg00;
        (*ENDIF*) 
        WantedLock.wlRowWanted_kb05 := false;
        IF  (row_locks_per_user_command >= k51glob.glMaxRowsPerTab_kb05)
            AND
            (hdInsReq_ekb05 in WantedLock.wlHandling_kb05)
        THEN
            WantedLock.wlHandling_kb05 := [hdCheckCollision_ekb05, hdInsLock_ekb05, hdInsReq_ekb05]
        ELSE
            WantedLock.wlHandling_kb05 := [hdCheckCollision_ekb05, hdInsLock_ekb05]
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51try_free_row_lock (
            TaskId                  : tsp00_TaskId;
            VAR RowRegionGlob       : tkb05_RegionGlob;
            VAR Row                 : tkb05_RowLockPtr;
            RowHash                 : tsp00_Int4);
 
VAR
      ItemCnt     : tsp00_Int4;
      CurrHash    : tkb05_RowLockPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08excl_check (TaskId, g08lock0 + RowRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
IF  (Row^.rlRowShareLocks_kb05 <= 0)                  AND
    (Row^.rlRowOptimCnt_kb05   <= 0)                  AND
    (Row^.rlExclTransIndex_kb05 = cgg_nil_transindex) AND
    (Row^.rlFirstReqRow_kb05    = NIL)
THEN
    (* remove Row Lock entry *)
    BEGIN
    IF  Row^.rlRowIdItem_kb05 <> NIL
    THEN
        BEGIN
        UnivItemPtr.uiRowIdItem_kb05 := Row^.rlRowIdItem_kb05;
        kb51free_supply_item (TaskId, RowRegionGlob, UnivItemPtr, ikRowId_ekb05);
        Row^.rlRowIdItem_kb05 := NIL
        END;
    (*ENDIF*) 
    CurrHash := RowRegionGlob.rglRowHash_kb05^[RowHash];
    IF  CurrHash = Row
    THEN
        RowRegionGlob.rglRowHash_kb05^[RowHash] := Row^.rlNextHashRow_kb05
    ELSE
        BEGIN
        IF  CurrHash <> NIL
        THEN
            BEGIN
            ItemCnt := 0;
            WHILE (CurrHash^.rlNextHashRow_kb05 <> Row) AND
                  (CurrHash^.rlNextHashRow_kb05 <> NIL) AND
                  (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
                BEGIN
                ItemCnt  := ItemCnt + 1;
                CurrHash := CurrHash^.rlNextHashRow_kb05
                END;
            (*ENDWHILE*) 
            IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
            THEN
                k52x_loop_error ('kb51try_free_row_lock   ', 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  kb03Check.chkLock_kb00 (* PTS 1103957 JA 1999-09-15 *)
        THEN
            g01check (kb51c1TryFreeRowLock_csp03, csp3_n_lock,
                  'try free Row: hash = nil', 0, CurrHash <> NIL);
        (*ENDIF*) 
        IF  CurrHash <> NIL
        THEN
            CurrHash^.rlNextHashRow_kb05 := Row^.rlNextHashRow_kb05
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    UnivItemPtr.uiRowLock_kb05 := Row;
    Row := NIL; (* JA 1998-09-25 *)
    kb51free_supply_item (TaskId, RowRegionGlob, UnivItemPtr, ikRowLock_ekb05)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51try_free_tab_lock (
            TaskId                  : tsp00_TaskId;
            VAR TabRegionGlob       : tkb05_RegionGlob;
            VAR Tab                 : tkb05_TabLockPtr;
            TabHash                 : tsp00_Int4);
 
BEGIN
&ifdef TRACE
t01p2int4 (kb_lock, 'RowShareLcks', Tab^.tlRowShareLocks_kb05
      ,             'RowExclLocks', Tab^.tlRowExclLocks_kb05);
&endif
IF  kb03Check.chkRegion_kb00 (* PTS 1103957 JA 1999-09-15 *)
THEN
    g08excl_check (TaskId, g08lock0 + TabRegionGlob.rglOwnRegion_kb05);
(*ENDIF*) 
IF  (Tab^.tlSysShareLocks_kb05 <= 0)                  AND
    (Tab^.tlTabShareLocks_kb05 <= 0)                  AND
    (Tab^.tlRowShareLocks_kb05 <= 0)                  AND
    (Tab^.tlRowOptimCnt_kb05   <= 0)                  AND
    (Tab^.tlRowExclLocks_kb05  <= 0)                  AND
    (Tab^.tlExclTransIndex_kb05 = cgg_nil_transindex) AND
    (Tab^.tlFirstReqTab_kb05    = NIL)                AND
    (Tab^.tlFirstReqRow_kb05    = NIL)
THEN
    (* remove Tab Lock entry *)
    kb51free_tab_lock (TaskId, TabRegionGlob, Tab, TabHash)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51vallocate (
            Length          : tsp00_Int4;
            VAR UnivAddr    : tkb05_UnivPtr;
            VAR err         : tgg00_BasisError);
 
VAR
      IsOk : boolean;
 
BEGIN
err  := e_ok;
IsOk := true;
vallocat (Length, UnivAddr.uvAddr_kb05, IsOk);
IF  NOT IsOk
THEN
    err := e_sysbuf_storage_exceeded;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51vtrace_row (
            MessType           : tgg00_MessType;
            MessType2          : tgg00_MessType2;
            ReqTransIndex      : tgg00_TransIndex;
            ReqMode            : tgg00_LockReqMode;
            RowLock            : tkb05_RowLockPtr);
 
VAR
      OutKeyLen : integer;
      MoveError : tgg00_BasisError;
      Trace     : tgg11_KbLockTrace;
 
BEGIN
WITH Trace.kblcHead_gg11 DO
    BEGIN
    kblHead_gg11.kbMessType_gg11  := MessType;
    kblHead_gg11.kbMessType2_gg11 := MessType2;
    kblHead_gg11.kbError_gg11     := e_ok;
    kblTabId_gg11                 := RowLock^.rlTabId_kb05;
    kblReqMode_gg11               := ReqMode;
    kblKeyLen_gg11                := RowLock^.rlKeyLen_kb05;
    IF  ReqTransIndex = cgg_nil_transindex
    THEN
        kblReqTask_gg11 := cgg_nil_pid
    ELSE
        kblReqTask_gg11 := k51glob.glTransList_kb05^[ReqTransIndex]^.teTaskId_kb05;
    (*ENDIF*) 
    IF  RowLock^.rlExclTransIndex_kb05 = cgg_nil_transindex
    THEN
        kblLockTask_gg11 := cgg_nil_pid
    ELSE
        kblLockTask_gg11 := k51glob.glTransList_kb05^[RowLock^.rlExclTransIndex_kb05]^.teTaskId_kb05
    (*ENDIF*) 
    END;
(*ENDWITH*) 
MoveError := e_ok;
OutKeyLen := RowLock^.rlKeyLen_kb05;
IF  OutKeyLen > sizeof (tgg11_VtraceBody) - sizeof (Trace.kblcHead_gg11)
THEN
    OutKeyLen := sizeof (tgg11_VtraceBody) - sizeof (Trace.kblcHead_gg11);
(*ENDIF*) 
IF  RowLock^.rlKeyLen_kb05 <= sizeof (RowLock^.rlShortKey_kb05)
THEN
    SAPDB_PascalMove ('VKB51 ',   2,    
          sizeof (RowLock^.rlShortKey_kb05), sizeof (Trace.kblcInfo_gg11),
          @RowLock^.rlShortKey_kb05, 1,
          @Trace.kblcInfo_gg11, 1, OutKeyLen, MoveError)
ELSE
    BEGIN
    IF  OutKeyLen > sizeof (RowLock^.rlRowIdItem_kb05^.riRowId_kb05)
    THEN
        OutKeyLen := sizeof (RowLock^.rlRowIdItem_kb05^.riRowId_kb05);
    (*ENDIF*) 
    SAPDB_PascalMove ('VKB51 ',   3,    
          sizeof (RowLock^.rlRowIdItem_kb05^.riRowId_kb05), sizeof (Trace.kblcInfo_gg11),
          @RowLock^.rlRowIdItem_kb05^.riRowId_kb05, 1,
          @Trace.kblcInfo_gg11, 1, OutKeyLen, MoveError)
    END;
(*ENDIF*) 
IF  MoveError = e_ok
THEN
    kb51vtrace_write (sizeof (Trace.kblcHead_gg11) + OutKeyLen, Trace)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51vtrace_tab (
            MessType           : tgg00_MessType;
            MessType2          : tgg00_MessType2;
            ReqTransIndex      : tgg00_TransIndex;
            ReqMode            : tgg00_LockReqMode;
            TabLock            : tkb05_TabLockPtr);
 
VAR
      Trace : tgg11_KbLockTrace;
 
BEGIN
WITH Trace.kblcHead_gg11 DO
    BEGIN
    kblHead_gg11.kbMessType_gg11  := MessType;
    kblHead_gg11.kbMessType2_gg11 := MessType2;
    kblHead_gg11.kbError_gg11     := e_ok;
    kblTabId_gg11                 := TabLock^.tlTabId_kb05;
    kblReqMode_gg11               := ReqMode;
    kblKeyLen_gg11                := 0;
    IF  ReqTransIndex = cgg_nil_transindex
    THEN
        kblReqTask_gg11 := cgg_nil_pid
    ELSE
        kblReqTask_gg11 := k51glob.glTransList_kb05^[ReqTransIndex]^.teTaskId_kb05;
    (*ENDIF*) 
    IF  TabLock^.tlExclTransIndex_kb05 = cgg_nil_transindex
    THEN
        kblLockTask_gg11 := cgg_nil_pid
    ELSE
        kblLockTask_gg11 := k51glob.glTransList_kb05^[TabLock^.tlExclTransIndex_kb05]^.teTaskId_kb05
    (*ENDIF*) 
    END;
(*ENDWITH*) 
kb51vtrace_write (sizeof (Trace.kblcHead_gg11), Trace)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51vtrace_write (
            TraceLen      : tsp00_Int2;
            VAR LockTrace : tgg11_KbLockTrace);
 
VAR
      AuxTrans : tgg00_TransContext;
 
BEGIN
AuxTrans.trError_gg00 := e_ok;
vgetpid             (AuxTrans.trTaskId_gg00);
gg06SetNilSession   (AuxTrans.trSessionId_gg00);
gg06SetNilTrans     (AuxTrans.trTransId_gg00);
gg06SetNilTrans     (AuxTrans.trWriteTransId_gg00);
AuxTrans.trSubtransId_gg00 := cgg_zero_subtrans;
b120InsertTrace (AuxTrans, kb, vttKbLockCollision_egg00, TraceLen, @LockTrace)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb51put_errtext (
            VAR t   : tgg00_TransContext;
            errtext : tsp00_C20);
 
VAR
      orig_err  : tgg00_BasisError;
      len       : integer;
      err_str   : tsp00_C256;
 
BEGIN
IF  errtext = bsp_c20
THEN
    len := 0
ELSE
    BEGIN
    len := sizeof (errtext);
    WHILE (len > 1) AND (errtext [len] = ' ') DO
        len := len - 1;
    (*ENDWHILE*) 
    orig_err       := t.trError_gg00;
    t.trError_gg00 := e_ok;
    SAPDB_PascalMove ('VKB51 ',   4,    
          sizeof (errtext), sizeof (err_str),
          @errtext, 1, @err_str, 1, len, t.trError_gg00);
    IF  t.trError_gg00 = e_ok
    THEN
        b06put_errtxt (t, t.trTaskId_gg00, len, errtext_char,
              orig_err, err_str, t.trError_gg00);
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok)
        AND
        NOT (tsErrTextExist_egg00 in t.trState_gg00)
    THEN
        t.trState_gg00 := t.trState_gg00 + [tsErrTextExist_egg00];
    (*ENDIF*) 
    t.trError_gg00 := orig_err
    END
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
