/****************************************************************************
  module      : vkb53
  author      : JuergenA,UweH
  responsible : UweH
  special area: SQL locks
  see also    :
  description : transaction end handling
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2001-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
*****************************************************************************/
 
.tt 1 $SAP$LiveCache$VKB53$
.tt 3 $UweH$KB_transaction$2001-05-02$
 
Module  : KB_transaction
 
Define  :
 
        PROCEDURE
              k53bd_keylist_lock (
                    VAR t               : tgg00_TransContext;
                    VAR InvId           : tgg00_FileId;
                    VAR KeyListBuf      : tsp00_Buf;
                    KeyListLen          : integer);
 
        PROCEDURE
              k53bd_share_lock (
                    VAR t             : tgg00_TransContext;
                    VAR FileId        : tgg00_FileId;
                    VAR RecBuf        : tgg00_Rec);
 
        PROCEDURE
              k53commit (
                    VAR t      : tgg00_TransContext;
                    MessType2  : tgg00_MessType2);
 
        PROCEDURE
              k53connect (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k53end_of_trans (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k53eot_excl_lock (
                    VAR t             : tgg00_TransContext;
                    VAR TreeId        : tgg00_FileId;
                    VAR k             : tgg00_Lkey;
                    forInsert         : boolean;
                    WantedMode        : tgg00_LockReqMode;
                    VAR GrantedMode   : tgg00_LockReqMode);
 
        PROCEDURE
              k53internal_lock (
                    VAR t             : tgg00_TransContext;
                    VAR LockTabId     : tgg00_Surrogate;
                    VAR k             : tgg00_Lkey;
                    LockHandling      : tgg00_HandlingSet;
                    WantedMode        : tgg00_LockReqMode;
                    VAR GrantedMode   : tgg00_LockReqMode);
 
        PROCEDURE
              k53key_unlock (
                    VAR t          : tgg00_TransContext;
                    UnlockMode     : tgg00_LockReqMode;
                    TabId          : tgg00_Surrogate;
                    VAR k          : tgg00_Lkey);
 
        PROCEDURE
              k53key_unlock2 (
                    VAR t           : tgg00_TransContext;
                    UnlockMode      : tgg00_LockReqMode;
                    TabId           : tgg00_Surrogate;
                    VAR Key         : tsp00_Key (*ptocSynonym tsp00_KeyPtr*);
                    KeyLen          : integer);
 
        PROCEDURE
              k53lock (
                    VAR t           : tgg00_TransContext;
                    VAR LockTabId   : tgg00_Surrogate;
                    VAR k           : tgg00_Lkey;
                    WantedMode      : tgg00_LockReqMode;
                    WantedState     : tgg00_LockReqState;
                    Nowait          : boolean;
                    CollisionTest   : boolean;
                    VAR GrantedMode : tgg00_LockReqMode);
 
        PROCEDURE
              k53lock_command (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k53lock_syskey (VAR trans  : tgg00_TransContext;
                    VAR tabid            : tgg00_Surrogate;
                    VAR key              : tgg00_Lkey;
                    VAR grantedlock      : tgg00_LockReqMode);
 
        PROCEDURE
              k53perm_temp_lock (
                    VAR t              : tgg00_TransContext;
                    LockUnlock         : tgg00_MessType;
                    LockMode           : tgg00_LockReqMode;
                    LockHandling       : tgg00_HandlingSet;
                    VAR LockTabId      : tgg00_Surrogate;
                    VAR k              : tgg00_Lkey);
 
        PROCEDURE
              k53release (
                    VAR t            : tgg00_TransContext;
                    force_release    : boolean;
                    internal_session : boolean);
 
        PROCEDURE
              k53rollback (
                    VAR t        : tgg00_TransContext;
                    MessType2    : tgg00_MessType2);
 
        PROCEDURE
              k53row_lock (
                    VAR t           : tgg00_TransContext;
                    VAR FileId      : tgg00_FileId;
                    VAR k           : tgg00_Lkey;
                    VAR RecBuf      : tsp00_Buf;
                    RecPos          : integer;
                    MessType        : tgg00_MessType;
                    ResultCount     : tsp00_Int4;
                    VAR GrantedMode : tgg00_LockReqMode);
 
        PROCEDURE
              k53row_lock_by_key (
                    VAR t           : tgg00_TransContext;
                    VAR FileId      : tgg00_FileId;
                    VAR k           : tsp00_Key (*ptocSynonym tsp00_KeyPtr*);
                    KeyLen          : tsp00_Int4;
                    MessType        : tgg00_MessType;
                    ResultCount     : tsp00_Int4;
                    VAR GrantedMode : tgg00_LockReqMode);
 
        PROCEDURE
              k53set_sys2_cat_excl_nowait (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k53signal_commit (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k53StartInternalSession (
                    VAR TransContext    : tgg00_TransContext;
                    VAR AuxTransContext : tgg00_TransContext;
                    bOpenNewTrans       : boolean;
                    bInheritLocalFDir   : boolean);
 
        PROCEDURE
              k53StopInternalSession (
                    VAR TransContext    : tgg00_TransContext;
                    VAR AuxTransContext : tgg00_TransContext;
                    typeOfTransEnd      : tgg00_MessType);
 
        PROCEDURE
              k53temp_unlock (
                    VAR t           : tgg00_TransContext;
                    VAR LockTabId   : tgg00_Surrogate;
                    VAR k           : tgg00_Lkey;
                    LockMode        : tgg00_LockReqMode);
 
        PROCEDURE
              k53unlock (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k53wait (
                    VAR t     : tgg00_TransContext;
                    MessType  : tgg00_MessType;
                    MessType2 : tgg00_MessType2);
 
.CM *-END-* define --------------------------------------
 
Use     :
 
        FROM
              object_garbage_collection : VBD91;
 
        PROCEDURE
              bd91TransEnd(
                    VAR t   : tgg00_TransContext;
                    commit  : boolean);
 
      ------------------------------ 
 
        FROM
              SQLManager :vak101;
 
        PROCEDURE
              a101_DestroyAllGroupedTempFiles(
                    VAR trans      : tgg00_TransContext;
                    VAR fileName   : tgg00_Filename);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : VBD998;
 
        PROCEDURE
              bd998ResetAllCachedLockStates(
                    VAR LocalFileDir   : tsp00_Addr);
 
      ------------------------------ 
 
        FROM
              KB_trans_state : VKB50;
 
        PROCEDURE
              k50check_excl_user (
                    VAR Trans  : tgg00_TransContext;
                    VAR UserId : tgg00_UserId);
 
        PROCEDURE
              k50eot_new_trans (VAR t : tgg00_TransContext);
 
        PROCEDURE
              kb50GetLocalFileDir (
                    TransIndex  : tgg00_TransIndex;
                    VAR filedir : tsp00_Addr);
 
        PROCEDURE
              k50init_wanted_rowid_lock (
                    VAR MoveObj    : tsp00_MoveObj;
                    MoveObjSize    : tsp00_Int4;
                    pos            : tsp00_Int4;
                    KeyLen         : integer;
                    VAR WantedLock : tkb05_WantedLock;
                    VAR MoveError  : tgg00_BasisError);
 
        PROCEDURE
              k50init1_wanted_rowid_lock (
                    VAR MoveObj    : tsp00_Key;
                    MoveObjSize    : tsp00_Int4;
                    pos            : tsp00_Int4;
                    KeyLen         : integer;
                    VAR WantedLock : tkb05_WantedLock;
                    VAR MoveError  : tgg00_BasisError);
 
        PROCEDURE
              k50my_state (
                    TransIndex        : tgg00_TransIndex;
                    VAR IsEotExcl     : boolean;
                    VAR AuxPermExists : boolean;
                    VAR TransTaskId   : tsp00_TaskId);
 
        PROCEDURE
              k50new_write_trans (VAR Trans : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              KB_locklist : VKB51;
 
        PROCEDURE
              k51check_ins_lock (
                    VAR t                : tgg00_TransContext;
                    VAR WantedLock       : tkb05_WantedLock;
                    VAR rowLockCollision : boolean);
 
        PROCEDURE
              k51del_transentry_from_locklist (
                    TaskId           : tsp00_TaskId;
                    VAR TransIndex   : tgg00_TransIndex;
                    VAR TransContext : tgg00_TransContext);
 
        PROCEDURE
              k51examine_trans (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k51handle_request_timeout (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              k51init_wanted_lock (VAR WantedLock : tkb05_WantedLock);
 
        FUNCTION
              k51max_locks_per_table : tsp00_Int4;
 
        PROCEDURE
              k51new_session (VAR Trans : tgg00_TransContext);
 
        PROCEDURE   (* PTS 1122885 FF 2003-07-01 *)
              k51remove_locks_2 (
                    VAR Trans         : tgg00_TransContext;
                    TransIndex        : tgg00_TransIndex;
                    VAR TransState    : tgg00_TransState);
 
        PROCEDURE
              k51set_userid (
                    VAR t          : tgg00_TransContext;
                    VAR UserId     : tgg00_UserId;
                    VAR TermId     : tsp00_TermId;
                    IsExclusive    : boolean;
                    IsNologSession : boolean);
 
        PROCEDURE
              k51temp_tab_share_unlock (
                    VAR t           : tgg00_TransContext;
                    VAR WantedTabid : tgg00_Surrogate);
 
        PROCEDURE
              k51unlock (
                    TaskId         : tsp00_TaskId;
                    TransIndex     : tgg00_TransIndex;
                    VAR TransState : tgg00_TransState;
                    VAR WantedLock : tkb05_WantedLock);
 
      ------------------------------ 
 
        FROM
              KB_show_lock : VKB52;
 
        PROCEDURE
              k52acc_trans_entry (
                    TransIndex        : tgg00_TransIndex;
                    VAR TransEntryPtr : tkb05_TransEntryPtr);
 
      ------------------------------ 
 
        FROM
              KB_ObjShare_lock : VKB501;
 
        (* PTS 1128244 FF 2004-03-18 new layer for share object locks *)
        (*                                                            *)
        PROCEDURE
              k501MarkTransend (
                    TransIdx         : tgg00_TransIndex;
                    committed        : boolean);
 
      ------------------------------ 
 
        FROM
              KB_Ext_Trans_Mon : VKB512;
 
        PROCEDURE
              k512MonEndTransaction(
                    TaskId        : tsp00_TaskId;
                    TransIndex    : tgg00_TransIndex;
                    committed     : boolean );
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560CommitLogTransaction (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              kb560CreateLogTransaction (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              kb560DeleteLogTransaction (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              kb560RollbackLogTransAction (
                    VAR Trans    : tgg00_TransContext;
                    RollbackKind : tgg00_MessType2;
                    SubTransNo   : tgg00_SubtransNo);
 
        FUNCTION
              kb560IsSys1CatalogTable(
                    VAR tabId : tgg00_Surrogate) : boolean;
 
        PROCEDURE
              kb560GetSys2CatalogTabId(
                    VAR tabId : tgg00_Surrogate);
 
      ------------------------------ 
 
        FROM
              KB_file_table_handling : VKB64;
 
        PROCEDURE
              k64build_aux_fn_prefix (
                    VAR transid    : tgg91_TransNo;
                    is_perm        : boolean;
                    VAR aux_id     : tgg00_FileId;
                    VAR prefix_len : integer);
 
      ------------------------------ 
 
        FROM
              KB_ServerTasks : VKB900;
 
        PROCEDURE
              kb900DropAuxFiles(VAR trans : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        PROCEDURE
              b01prefix_destroy_files (
                    VAR t      : tgg00_TransContext;
                    VAR prefix : tgg00_Filename;
                    PrefixLen  : integer);
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (
                    VAR t        : tgg00_TransContext;
                    trace_layer  : tgg00_Debug;
                    trace_object : tgg00_VtraceType;
                    body_len     : tsp00_Int2;
                    trace_body   : tgg11_VtraceBodyPtr);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01vtrace : tgg00_VtraceState;
 
        PROCEDURE
              g01time_vtrace (
                    VAR t           : tgg00_TransContext;
                    msg             : tsp00_Name;
                    VAR StartSec    : tsp00_Int4;
                    VAR StartMsec   : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04build_temp_tree_id (
                    VAR curr : tgg00_FileId;
                    VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        VAR
              g08LockParallel : tsp00_RegionId;
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbegexcl (
                    TaskId     : tsp00_TaskId;
                    Region     : tsp00_RegionId);
 
        PROCEDURE
              vclock (
                    VAR sec      : tsp00_Int4;
                    VAR microsec : tsp00_Int4);
 
        PROCEDURE
              vendexcl (
                    TaskId     : tsp00_TaskId;
                    Region     : tsp00_RegionId);
 
        PROCEDURE
              vwait (TaskId : tsp00_TaskId; VAR IsOk : boolean);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id     : tsp00_C6;
                    mod_num    : tsp00_Int4;
                    source_upb : tsp00_Int4;
                    destin_upb : tsp00_Int4;
                    source     : tsp00_MoveObjPtr;
                    source_pos : tsp00_Int4;
                    destin     : tsp00_MoveObjPtr;
                    destin_pos : tsp00_Int4;
                    Length     : tsp00_Int4;
                    VAR err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        PROCEDURE
              gg999Offline (error : tgg00_BasisError);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01buf (
                    debug    : tgg00_Debug;
                    VAR buf  : tsp00_Key;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01handling (
                    layer : tgg00_Debug;
                    nam : tsp00_Sname;
                    s   : tgg00_HandlingSet);
 
        PROCEDURE
              t01int4 (
                    layer    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam1 : tsp00_Sname;
                    int1 : tsp00_Int4;
                    nam2 : tsp00_Sname;
                    int2 : tsp00_Int4);
 
        PROCEDURE
              t01lkey (
                    layer : tgg00_Debug;
                    VAR k : tgg00_Lkey);
 
        PROCEDURE
              t01lock (
                    layer    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    VAR Lock : tgg00_Lock);
 
        PROCEDURE
              t01lockmode (
                    layer        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    LockMode     : tgg00_LockReqMode);
 
        PROCEDURE
              t01lockstate (
                    layer         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    LockState     : tgg00_LockReqState);
 
        PROCEDURE
              t01msgcheck (
                    msg            : tsp00_C30;
                    CheckCondition : boolean;
                    BadInt         : tsp00_Int4);
 
        PROCEDURE
              ta01SessionTrans (
                    debug             : tgg00_Debug;
                    nam               : tsp00_Sname;
                    VAR session       : tgg91_SessionNo;
                    VAR trans         : tgg91_TransNo;
                    VAR write_trans   : tgg91_TransNo;
                    VAR subtrans      : tgg00_SubtransNo);
 
        PROCEDURE
              t01sname (
                    layer     : tgg00_Debug;
                    nam       : tsp00_Sname);
 
        PROCEDURE
              t01tabid (
                    layer     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR TabId : tgg00_Surrogate);
 
        FUNCTION
              t01trace (debug : tgg00_Debug) : boolean;
 
        PROCEDURE
              t01trans (
                    layer     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR t     : tgg00_TransContext);
 
        PROCEDURE
              t01treeid (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
&       endif
 
.CM *-END-* use -----------------------------------------
 
Synonym :
 
        PROCEDURE
              k50init1_wanted_rowid_lock;
 
              tsp00_MoveObj tsp00_Key
&             ifdef TRACE
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tsp00_Key
&             endif
 
.CM *-END-* synonym -------------------------------------
 
***********************************************************
 
Specification:
 
Procedure K53BD_SHARELOCK
 
Sets and implicit Lock:
 
SYS1CAT:        SYS_SHARE Lock for the tableid contained in REC
 
inv file:       ROW_SHARE Lock for all keys contained in the
                        keylist buffer (REC_BUF)
 
table:          ROW_SHARE Lock for the key contained in REC_BUF
 
 
Procedure K53CMD_ROLLBACK
 
A rollback is executed for the last log entries created after
the last entering of KB to undo all effects done by a K05FUNCTIONS call.
 
 
Procedure K53COMMIT
 
If eot excl locks for this transaction
exist in the Lock list, a COMMIT log entry is written.
Locks belonging to the transaction
are removed from the Lock list via KB53CLEAR_LOCKLIST.
If the local site is merely participant in a distributed transaction,
then the transentry in the locklist is removed.
If, after the last checkpoint, a sufficient Number of log pages
(checkpointdistance) was written, this procedure also causes the Lock
list to be Locked for checkpointing. Writing the checkpoint
is done by the task which removes the last eot excl Lock from
the Lock list. If no checkpoint has been written,
a check is run to find out whether a savepoint should occur.
 
 
Procedure K53CONNECT
 
Inserts a transentry into the locklist and writes a connect log entry
onto the log without setting 'previous logpos'. The log entry is
used only by audit and may be scanned with diagnose tools.
 
 
Procedure K53EOT_EXCL_LOCK
 
Implements the setting of a an eot excl Lock
for the following operations:
       create, drop, insert, delete and update.
 
The Lock is specified by the tree id contained in
the message buffer and the key. If the tree id specifies the
SYS1_CATALOG a ROW EXCL LOCK is changed into a SYS EXCL LOCK
on the involved table.
 
If no ROW EXCL LOCK is requested, the key does not
have to be defined (DUMMY_KEY to get a correct compilation).
 
If the Lock request leads to a collision and the handling
state does not contain HS_NOWAIT,
the Lock request is stored in the request list until it can be satisfied
and the message E_WAIT_FOR_LOCK_RELEASE is returned.
 
 
Procedure K53INSERT_TRANS
 
Issued (by AK) for every site with TransState TS_UPDATED
during the Two-Phase-Commit protocol. Saves the Result of the
current transaction into the TRANSFILE, so that inquiries from
partners can be satisfied later.
A logentry is not necessary because after a crash the restart
will redo the transfile inserts when rolling forward the
signal commit and the commit entries.
The deletes from the transfile, issued by messages from the
participants, are logged and can be rolled forward by restart.
 
 
Procedure K53INTERNAL_LOCK
 
Use K53LOCK instead of this procedure.
 
 
Procedure K53KEEP_LOCK
 
Implements 'commit work' and sets the specified locks
via KB53MULTI_LOCK.
If eot excl locks for this transaction exist in the Lock list,
a COMMIT log entry is written. In any case, the Lock-list entries
belonging to the transaction are removed from the Lock list via
KB53CLEAR_LOCKLIST. The requested locks are then
newly inserted in the Lock list under the next transnumber.
 
 
Procedure K53LOCK
 
Generates a Lock entry specified by the table id LOCK_TABID, the
key K (Row Lock only; otherwise dummy), the WANTED_MODE
and WANTED_STATE. Furthermore NOWAIT can be specified and
for sys share and Row share locks the inserting of a
Lock can be skipped by setting COLLSION_TEST. COLLISION_TEST
results in a consistent Lock, if a collision occurs.
GRANTED_MODE returns the Locked mode set in the Lock list
(e.g. Tab excl instead of wanted Row excl).
If a Row share or sys share Lock is specified in combination with
LRS_CONSISTENT, only 'consistent' is Locked, i.e. a
'consistent' key Lock that has been present up to now for the same table
is overwritten by the new Lock.
 
 
Procedure K53LOCK_COMMAND
 
Processes a set of Lock requests that are contained in PART1 of the
message buffer via KB53MULTI_LOCK.
 
The message2 type MM_TEST results in the error message E_LOCK_COLLISION
in the event of a Lock collision.
Otherwise in the event of a Lock collision the error message
E_WAIT_FOR_LOCK_RELEASE
is returned. If a request Timeout occurs and there are no temp locks
specified in part1 or set by this transaction,
then all modifications on the Lock list caused by this procedure
are rolled back.
 
 
Procedure K53PERM_TEMP_LOCK
 
Use K53LOCK instead of this procedure.
 
 
Procedure K53RELEASE
 
Removes the transentry for the current Session from the locklist. All
Session specific temp files are destroyed.
 
 
Procedure K53ROLLBACK
 
If eot excl locks for this transaction
exist in the Lock list, a ROLLBACK log entry is written
and a rollback is performed by KB53ROLLBACK_HANDLING.
Locks belonging to the transaction
are removed from the Lock list via KB53CLEAR_LOCKLIST.
 
If, after the last checkpoint, a sufficient Number of log pages
(checkpointdistance) was written, this procedure also causes the Lock
list to be Locked for checkpointing. Writing the checkpoint
is done by the task which removes the last eot excl Lock from
the Lock list. If no checkpoint has been written,
a check is run to find out whether a savepoint should occur.
 
 
Procedure K53ROW_LOCK
 
Implements the implicit setting of a Lock for a select command.
Depending on the message type a share or exclusive Lock is created.
The key K must be a primary key. The entry id if a cluster file
is Locked as a table id. This id is contained in REC_BUF.
 
 
Procedure K53SET_SYS2_CAT_EXCL_NOWAIT
 
Sets an eot exlusive Tab Lock on system catalog 2. If a collision occurs
the procedure returns the error E_LOCK_COLLISION (Nowait!).
 
 
Procedure K53SIGNAL_COMMIT
 
First part of the Two-Phase-Commit Protocol. The new state is recorded
in the Lock list and a logentry is forced to stable storage. Together
with this logentry the logwriter writes all logentries of the current
transaction to disk, and guarantees thereby that the site can
commit the transaction during the following protocol phase.
All share locks are released to minimize the collision rate
(now the transaction is pending until commit).
 
 
Procedure K53SUBTRANS_ROLLBACK
 
A rollback is executed for the last log entries matching the
subtrans specified by M.MB_TRANS.TR_ID.SUBTRANS.
 
 
Procedure K53TEMP_UNLOCK
 
A temp lockentry specified by the table id LOCK_TABID, the
key K (Row Lock only; otherwise dummy) and the LOCK_MODE
is removed from the Lock list.
 
 
Procedure K53TP_COMMIT_TWO_PHASE
 
K53COMMIT is called, and if the local site is participant
in a distributed transaction, then a notify message
concerning the completed commit is sent to the coordinator
to delete the commit info from the transfile.
 
 
Procedure K53TP_ROLLBACK_TWO_PHASE
 
K53ROLLBACK is called, and if the local site is participant
in a distributed transaction, then a notify message
concerning the completed rollback is sent to the coordinator
to delete the commit info from the transfile.
 
 
Procedure K53UNLOCK
 
The locks specified in part1 of the message buffer are removed from
the Lock list.
 
 
Procedure K53WAIT
 
This procedure must be only called after E_WAIT_FOR_LOCK_RELEASE.
A wait is performed and afterwards ctimeout check is performed
to reenter KB instead of calling K05FUNCTIONS.
 
 
Procedure KB53CHECK_MODE_STATE
 
In a slow kernel the following checks are performed:
 
 
              |                 permitted states
LOCK MODE     |
              | temp | consistent | collision test | eot excl  | pending
--------------+------+------------+----------------+-----------+--------
sys share     |      |     x      |       x        |           |
              |      |            |                |           |
sys excl      |      |            |                | mandatory |    x
              |      |            |                |           |
Tab share     |  x   |            |                |           |
              |      |            |                |           |
Tab excl      |  x   |            |                |     x     |    x
              |      |            |                |           |
Row share     |  x   |     x      |       x        |           |
              |      |            |                |           |
Row excl      |  x   |     x      |                |     x     |    x
              |      |            |                |           |
Row optimistic|      |     x      |                |           |
 
        consistent ==> NOT temp
        eot excl   ==> NOT temp, NOT consistent
        pending    ==> NOT temp, NOT consistent
 
 
Procedure KB53CLEAR_LOCKLIST
 
Removes the locks of this transaction from the Lock list and calls
a checkpoint or savepoint if applicable.
If a checkpoint is written K51SATISFY_REQUESTS is called
to activate other tasks blocked by closed locklist.
 
 
Procedure KB53MULTI_LOCK
 
Processes a set of Lock requests that are contained in PART2.
If a collision occurs and NOWAIT is set the error message
E_LOCK_COLLISION is returned; otherwise in case of a collision
E_WAIT_FOR_LOCK_RELEASE is raised and Collided entries are inserted
into the request list.
 
If more than one entry is specified in PART2
and none of the entries is specified as temp
and any Lock collision occurres, then
the entries are inserted as temporary locks or requests in order
to rollback the Lock list modifications in case of a Lock Timeout.
 
 
Procedure KB53ROLLBACK_HANDLING
 
The temporary and permanent modifications are rolled back.
If eot excl locks for this transaction exist in the Lock list,
a rollnack log entry is written.
 
.CM *-END-* specification -------------------------------
 
***********************************************************
 
Description:
 
.CM *-END-* description ---------------------------------
 
***********************************************************
 
Structure:
 
.CM *-END-* structure -----------------------------------
 
**********************************************************
 
.CM -lll-
Code    :
 
 
CONST
      COLLISION_TEST     = true;
      NOWAIT             = true;
      PERM               = true;
      c_internal_session = true;
      c_committed        = true;  (* PTS 1128244 FF 2004-03-18 *)
      c_rollbacked       = false; (* PTS 1128244 FF 2004-03-18 *)
 
TYPE
      t_AllLocks = ARRAY [1..MAX_QUALBUF_LOCKS_GG00] OF tkb05_WantedLock;
 
 
(*------------------------------*) 
 
PROCEDURE
      k53bd_keylist_lock (
            VAR t               : tgg00_TransContext;
            VAR InvId           : tgg00_FileId;
            VAR KeyListBuf      : tsp00_Buf;
            KeyListLen          : integer);
 
VAR
      DummyGranted : tgg00_LockReqMode;
      LockKeyPos   : integer;
      LockKey      : tgg00_Lkey;
 
BEGIN
t.trError_gg00 := e_ok;
IF  NOT (ftsTemp_egg00 in InvId.fileType_gg00)
THEN
    BEGIN
    IF      (hsWithoutLock_egg00    in InvId.fileHandling_gg00) AND
        NOT (hsOptimisticLock_egg00 in InvId.fileHandling_gg00)
    THEN
        BEGIN
        IF  t.trIndex_gg00 = cgg_nil_transindex
        THEN
            t.trError_gg00 := e_nil_transindex
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        LockKeyPos := 1;
        WHILE (t.trError_gg00 = e_ok) AND (LockKeyPos <= KeyListLen) DO
            BEGIN
            LockKey.len := ord (KeyListBuf [LockKeyPos]);
            SAPDB_PascalMove ('VKB53 ',   1,    
                  sizeof (KeyListBuf), sizeof (LockKey.k),
                  @KeyListBuf, LockKeyPos+1,
                  @LockKey.k, 1, LockKey.len, t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                BEGIN
                (* dummy parameter: KeyListBuf, 0 *)
                k53row_lock (t, InvId, LockKey, KeyListBuf, 0, m_get, 1, DummyGranted);
                LockKeyPos := LockKeyPos + 1 + LockKey.len
                END
            (*ENDIF*) 
            END
        (*ENDWHILE*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53bd_share_lock (
            VAR t             : tgg00_TransContext;
            VAR FileId        : tgg00_FileId;
            VAR RecBuf        : tgg00_Rec);
 
VAR
      DummyGranted : tgg00_LockReqMode;
      LockKey      : tgg00_Lkey;
 
BEGIN
t.trError_gg00 := e_ok;
IF  NOT (ftsTemp_egg00 in FileId.fileType_gg00)
THEN
    BEGIN
    LockKey.len := RecBuf.keylen;
    SAPDB_PascalMove ('VKB53 ',   2,    
          sizeof (RecBuf.buf), sizeof (LockKey.k),
          @RecBuf.buf, cgg_rec_key_offset + 1,
          @LockKey.k, 1, LockKey.len, t.trError_gg00);
    IF  t.trError_gg00 = e_ok
    THEN
        k53row_lock (t, FileId, LockKey, RecBuf.buf, 1, m_get, 1, DummyGranted)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53commit (
            VAR t      : tgg00_TransContext;
            MessType2  : tgg00_MessType2);
 
VAR
      bDropAuxFiles     : boolean;      (* PTS 1104414 JA 1999-11-01 *)
      TempTreeId        : tgg00_FileId;
      dummyIsEotExcl    : boolean;
      dummyTaskId       : tsp00_TaskId;
 
BEGIN
t.trError_gg00          := e_ok;
&ifdef TRACE
t01sname (ak_isolev, '  k53commit ');
&endif
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex;
(*ENDIF*) 
;
(* PTS 1135542 FF 2005-05-13 && PTS 1139346 FF *)
IF  (t.trError_gg00 = e_ok) AND
    NOT (( t.trFreePagesForIns_gg00 = NIL ) AND ( t.trSchemaShrLockHash_gg00 = NIL ))
THEN
    bd91TransEnd(t, true (*commit*));
(*ENDIF*) 
;
IF  (t.trError_gg00 = e_ok) AND (MessType2 = mm_destroy_temp)
THEN
    BEGIN
    g04build_temp_tree_id (TempTreeId, t);
    a101_DestroyAllGroupedTempFiles (t, TempTreeId.fileName_gg00);
    IF  t.trError_gg00 = e_file_not_found
    THEN
        t.trError_gg00 := e_ok;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    kb560CommitLogTransaction (t);
    IF  t.trError_gg00 = e_ok
    THEN
        k50my_state (t.trIndex_gg00, dummyIsEotExcl, bDropAuxFiles, dummyTaskId);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        k501MarkTransend (t.trIndex_gg00, c_committed); (* PTS 1128244 FF 2004-03-18 *)
        k512MonEndTransaction(t.trTaskId_gg00, t.trIndex_gg00, c_committed );
        IF  (NIL <> t.trLocalFileDirPtr_gg00)
        THEN
            bd998ResetAllCachedLockStates(t.trLocalFileDirPtr_gg00);
        (*ENDIF*) 
        k51remove_locks_2 (t, t.trIndex_gg00, t.trState_gg00);
        END;
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) AND bDropAuxFiles
    THEN
        (* PTS 1104414 JA 1999-11-01 *)
        BEGIN
        kb900DropAuxFiles(t);
        t.trError_gg00 := e_ok (* ignore errors / commit already done *)
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        k50eot_new_trans (t);
    (*ENDIF*) 
    IF  t.trError_gg00 <> e_ok
    THEN
        gg999Offline (t.trError_gg00);
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53connect (VAR m : tgg00_MessBlock);
 
VAR
      IsExclusive    : boolean;      (* PTS 1103428 JA 1999-08-16 *)
      pos            : integer;
      UserId         : tgg00_UserId;
      TermId         : tsp00_TermId;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
pos := sizeof (tsp00_KnlIdentifier) + 1;
SAPDB_PascalMove ('VKB53 ',   3,    
      m.mb_data_size, sizeof (TermId),
      @m.mb_data^.mbp_buf, pos, @TermId, 1, sizeof (TermId),
      m.mb_trns^.trError_gg00);
pos := pos + sizeof (tsp00_TermId) + sizeof (tgg00_ServerdbNo);
SAPDB_PascalMove ('VKB53 ',   4,    
      m.mb_data_size, sizeof (UserId),
      @m.mb_data^.mbp_buf, pos,
      @UserId, 1, sizeof (UserId),
      m.mb_trns^.trError_gg00);
pos            := pos + sizeof (UserId);
(*IsNologSession := m.mb_data^.mbp_buf[pos] = chr (ord (true)); obsolete UH 2004-11-11 *)
IsExclusive    := m.mb_type2 = mm_user; (* PTS 1103428 JA 1999-08-16 *)
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    k51set_userid (m.mb_trns^, UserId, TermId, IsExclusive, false);
(*ENDIF*) 
IF  (m.mb_trns^.trError_gg00 = e_ok) AND IsExclusive
THEN
    k50check_excl_user (m.mb_trns^, UserId) (* PTS 1103428 JA 1999-08-16 *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53end_of_trans (VAR m : tgg00_MessBlock);
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
k51examine_trans (m.mb_trns^);
IF  (m.mb_trns^.trError_gg00 = e_rollback_wanted)
    OR
    (m.mb_trns^.trError_gg00 = e_cancelled)
THEN
    m.mb_trns^.trError_gg00 := e_ok;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    IF  m.mb_type = m_commit
    THEN
        k53commit (m.mb_trns^, m.mb_type2)
    ELSE
        k53rollback (m.mb_trns^, m.mb_type2)
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
ta01SessionTrans (kb_lock, 'Trans       ',
      m.mb_trns^.trSessionId_gg00,
      m.mb_trns^.trTransId_gg00,
      m.mb_trns^.trWriteTransId_gg00,
      m.mb_trns^.trSubtransId_gg00);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53eot_excl_lock (
            VAR t             : tgg00_TransContext;
            VAR TreeId        : tgg00_FileId;
            VAR k             : tgg00_Lkey;
            forInsert         : boolean;
            WantedMode        : tgg00_LockReqMode;
            VAR GrantedMode   : tgg00_LockReqMode);
 
VAR
      LockMode     : tgg00_LockReqMode;
      LockState    : tgg00_LockReqState;
      StartSec     : tsp00_Int4;
      StartMsec    : tsp00_Int4;
      LockTabId    : tgg00_Surrogate;
 
BEGIN
t.trError_gg00 := e_ok;
&ifdef TRACE
t01msgcheck ('K51EOT_EXCL_LOCK: mode <> excl',
      WantedMode in [lckSysExcl_egg00, lckTabExcl_egg00, lckRowExcl_egg00],
      ord (WantedMode));
&endif
IF  g01vtrace.vtrTime_gg00
THEN
    vclock (StartSec, StartMsec);
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    IF  kb560IsSys1CatalogTable (TreeId.fileTabId_gg00)
    THEN
        BEGIN
        SAPDB_PascalMove ('VKB53 ',   5,    
              sizeof (k.k), sizeof (LockTabId),
              @k.k, 1, @LockTabId, 1, sizeof (LockTabId), t.trError_gg00);
        LockMode := lckSysExcl_egg00
        END
    ELSE
        BEGIN
        LockTabId := TreeId.fileTabId_gg00;
        LockMode  := WantedMode
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    IF  forInsert
    THEN
        LockState := [lrsEotExcl_egg00, lrsForInsert_egg00]
    ELSE
        LockState := [lrsEotExcl_egg00];
    (*ENDIF*) 
    k53lock (t, LockTabId, k, LockMode, LockState,
          (hsNoWait_egg00 in TreeId.fileHandling_gg00),
          NOT COLLISION_TEST, GrantedMode);
    END;
(*ENDIF*) 
IF  g01vtrace.vtrTime_gg00
THEN
    g01time_vtrace (t, 'k53eot_excl_lock  ', StartSec, StartMsec)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53internal_lock (
            VAR t             : tgg00_TransContext;
            VAR LockTabId     : tgg00_Surrogate;
            VAR k             : tgg00_Lkey;
            LockHandling      : tgg00_HandlingSet;
            WantedMode        : tgg00_LockReqMode;
            VAR GrantedMode   : tgg00_LockReqMode);
 
VAR
      LockState : tgg00_LockReqState;
 
BEGIN
&ifdef TRACE
t01handling (ak_isolev, 'lock_handlng', LockHandling);
t01handling (kb_lock,   'lock_handlng', LockHandling);
&endif
LockState := [ ];
IF  hsConsistentLock_egg00 in LockHandling
THEN
    LockState := LockState + [lrsConsistent_egg00];
(*ENDIF*) 
IF  hsNoWaitForInserts_egg00 in LockHandling
THEN
    LockState := LockState + [lrsIgnoreInsert_egg00];
(*ENDIF*) 
IF  (WantedMode = lckSysExcl_egg00)
    OR
    ((WantedMode in [lckTabExcl_egg00, lckRowExcl_egg00]) AND
    NOT (hsIntentExcl_egg00 in LockHandling))
THEN
    LockState := LockState + [lrsEotExcl_egg00];
(*ENDIF*) 
k53lock (t, LockTabId, k, WantedMode, LockState,
      (hsNoWait_egg00 in LockHandling),
      (hsCollisionTest_egg00 in LockHandling),
      GrantedMode)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53key_unlock (
            VAR t          : tgg00_TransContext;
            UnlockMode     : tgg00_LockReqMode;
            TabId          : tgg00_Surrogate;
            VAR k          : tgg00_Lkey);
 
VAR
      WantedLock : tkb05_WantedLock;
      LockTabId  : tgg00_Surrogate;
 
BEGIN
t.trError_gg00 := e_ok;
IF  t.trIndex_gg00 <> cgg_nil_transindex
THEN
    BEGIN
    IF  kb560IsSys1CatalogTable (TabId)
        AND
        (UnlockMode = lckSysShare_egg00)
    THEN
        (* PTS 1126907 UH 2004-01-23 added this branch *)
        BEGIN
        SAPDB_PascalMove ('VKB53 ',   6,    
              sizeof (k.k), sizeof (LockTabId),
              @k.k, 1, @LockTabId, 1, sizeof (LockTabId), t.trError_gg00);
        k51init_wanted_lock (WantedLock);
        END
    ELSE
        BEGIN
        k50init1_wanted_rowid_lock (k.k, sizeof (k.k), 1, k.len,
              WantedLock, t.trError_gg00);
        LockTabId := TabId;
        END;
    (*ENDIF*) 
    WITH WantedLock DO
        BEGIN
        wlTabId_kb05 := LockTabId;
        wlMode_kb05  := UnlockMode;
        wlState_kb05 := [ ]
        END;
    (*ENDWITH*) 
    k51unlock (t.trTaskId_gg00, t.trIndex_gg00, t.trState_gg00, WantedLock)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53key_unlock2 (
            VAR t           : tgg00_TransContext;
            UnlockMode      : tgg00_LockReqMode;
            TabId           : tgg00_Surrogate;
            VAR Key         : tsp00_Key;
            KeyLen          : integer);
 
VAR
      WantedLock : tkb05_WantedLock;
 
BEGIN
t.trError_gg00 := e_ok;
IF  t.trIndex_gg00 <> cgg_nil_transindex
THEN
    BEGIN
    k50init1_wanted_rowid_lock (Key, sizeof (Key), 1, KeyLen,
          WantedLock, t.trError_gg00);
    WITH WantedLock DO
        BEGIN
        wlTabId_kb05 := TabId;
        wlMode_kb05  := UnlockMode;
        wlState_kb05 := [ ]
        END;
    (*ENDWITH*) 
    k51unlock (t.trTaskId_gg00, t.trIndex_gg00, t.trState_gg00, WantedLock)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53lock (
            VAR t           : tgg00_TransContext;
            VAR LockTabId   : tgg00_Surrogate;
            VAR k           : tgg00_Lkey;
            WantedMode      : tgg00_LockReqMode;
            WantedState     : tgg00_LockReqState;
            Nowait          : boolean;
            CollisionTest   : boolean;
            VAR GrantedMode : tgg00_LockReqMode);
 
VAR
      WantedLock       : tkb05_WantedLock;
      rowLockCollision : boolean;
 
BEGIN
t.trError_gg00 := e_ok;
GrantedMode    := lckFree_egg00;
&ifdef TRACE
IF  t01trace (ak_isolev) OR t01trace (kb_lock)
THEN
    BEGIN
    t01sname     (ak_isolev, '   k53lock  ');
    t01trans     (kb_lock,   'Trans       ', t);
    t01lockmode  (td_always, 'WantedMode  ', WantedMode);
    t01lockstate (td_always, 'WantedState ', WantedState);
    t01p2int4    (td_always, 'Nowait      ', ord (Nowait)
          ,                  'coll_test   ', ord (CollisionTest));
    t01tabid     (td_always, 'LockTabId   ', LockTabId);
    IF  WantedMode in
        [lckRowExcl_egg00, lckRowShare_egg00, lckRowOptimistic_egg00]
    THEN
        t01lkey (td_always, k)
    ELSE
        t01sname (ak_isolev, '            ');
    (*ENDIF*) 
    END;
(*ENDIF*) 
kb53check_mode_state (WantedMode, WantedState, CollisionTest);
&endif
IF  WantedMode in
    [lckRowShare_egg00, lckRowExcl_egg00, lckRowOptimistic_egg00]
THEN
    k50init1_wanted_rowid_lock (k.k, sizeof (k.k), 1, k.len,
          WantedLock, t.trError_gg00)
ELSE
    k51init_wanted_lock (WantedLock);
(*ENDIF*) 
WITH WantedLock DO
    BEGIN
    wlTabId_kb05    := LockTabId;
    wlMode_kb05     := WantedMode;
    wlState_kb05    := WantedState;
    wlHandling_kb05 := [hdCheckCollision_ekb05];
    IF  NOT CollisionTest
    THEN
        wlHandling_kb05 := wlHandling_kb05 + [hdInsLock_ekb05];
    (*ENDIF*) 
    IF  NOT Nowait
    THEN
        wlHandling_kb05 := wlHandling_kb05 + [hdInsReq_ekb05]
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  t.trError_gg00 = e_ok
THEN
    k51check_ins_lock (t, WantedLock, rowLockCollision);
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    GrantedMode := WantedLock.wlGrantedMode_kb05;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53lock_syskey (VAR trans  : tgg00_TransContext;
            VAR tabid            : tgg00_Surrogate;
            VAR key              : tgg00_Lkey;
            VAR grantedlock      : tgg00_LockReqMode);
 
VAR
      WantedLock : tkb05_WantedLock;
      rowLockCollision : boolean;
 
BEGIN
trans.trError_gg00 := e_ok;
grantedlock        := lckFree_egg00;
&ifdef TRACE
IF  t01trace (kb_lock)
THEN
    BEGIN
    t01trans (kb_lock,   'Trans       ', trans);
    t01tabid (td_always, 'LockTabId   ', tabid);
    t01lkey  (td_always, key)
    END;
&endif
(*ENDIF*) 
k50init1_wanted_rowid_lock (key.keyVal_gg00, sizeof (key.keyVal_gg00),
      1, key.keyLen_gg00,
      WantedLock, trans.trError_gg00);
IF  trans.trError_gg00 = e_ok
THEN
    BEGIN
    WITH WantedLock DO
        BEGIN
        wlTabId_kb05    := tabid;
        wlMode_kb05     := lckRowExcl_egg00;
        wlState_kb05    := [lrsEotExcl_egg00, lrsForInsert_egg00];
        wlHandling_kb05 := [hdCheckCollision_ekb05,hdInsLock_ekb05];
        END;
    (*ENDWITH*) 
    k51check_ins_lock (trans, WantedLock, rowLockCollision);
    IF  (trans.trError_gg00 = e_lock_collision) AND NOT rowLockCollision
    THEN
        BEGIN
        trans.trError_gg00         := e_ok;
        WantedLock.wlHandling_kb05 := WantedLock.wlHandling_kb05 + [hdInsReq_ekb05];
        k51check_ins_lock (trans, WantedLock, rowLockCollision);
        END;
    (*ENDIF*) 
    IF  trans.trError_gg00 = e_ok
    THEN
        grantedlock := WantedLock.wlGrantedMode_kb05;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb53lock_by_key (
            VAR t           : tgg00_TransContext;
            VAR LockTabId   : tgg00_Surrogate;
            VAR k           : tsp00_Key;
            KeyLen          : tsp00_Int4;
            WantedMode      : tgg00_LockReqMode;
            WantedState     : tgg00_LockReqState;
            Nowait          : boolean;
            CollisionTest   : boolean;
            VAR GrantedMode : tgg00_LockReqMode);
 
VAR
      WantedLock       : tkb05_WantedLock;
      rowLockCollision : boolean;
 
BEGIN
t.trError_gg00 := e_ok;
GrantedMode    := lckFree_egg00;
&ifdef TRACE
IF  t01trace (ak_isolev) OR t01trace (kb_lock)
THEN
    BEGIN
    t01sname     (ak_isolev, '   k53lock  ');
    t01trans     (kb_lock,   'Trans       ', t);
    t01lockmode  (td_always, 'WantedMode  ', WantedMode);
    t01lockstate (td_always, 'WantedState ', WantedState);
    t01p2int4    (td_always, 'Nowait      ', ord (Nowait)
          ,                  'coll_test   ', ord (CollisionTest));
    t01tabid     (td_always, 'LockTabId   ', LockTabId);
    IF  WantedMode in
        [lckRowExcl_egg00, lckRowShare_egg00, lckRowOptimistic_egg00]
    THEN
        BEGIN
        t01buf (td_always, k, 1, KeyLen);
        (* t01lkey (td_always, k) *)
        END
    ELSE
        t01sname (ak_isolev, '            ');
    (*ENDIF*) 
    END;
(*ENDIF*) 
kb53check_mode_state (WantedMode, WantedState, CollisionTest);
&endif
IF  WantedMode in
    [lckRowShare_egg00, lckRowExcl_egg00, lckRowOptimistic_egg00]
THEN
    k50init1_wanted_rowid_lock (k, sizeof (k), 1, KeyLen,
          WantedLock, t.trError_gg00)
ELSE
    k51init_wanted_lock (WantedLock);
(*ENDIF*) 
WITH WantedLock DO
    BEGIN
    wlTabId_kb05    := LockTabId;
    wlMode_kb05     := WantedMode;
    wlState_kb05    := WantedState;
    wlHandling_kb05 := [hdCheckCollision_ekb05];
    IF  NOT CollisionTest
    THEN
        wlHandling_kb05 := wlHandling_kb05 + [hdInsLock_ekb05];
    (*ENDIF*) 
    IF  NOT Nowait
    THEN
        wlHandling_kb05 := wlHandling_kb05 + [hdInsReq_ekb05]
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  t.trError_gg00 = e_ok
THEN
    k51check_ins_lock (t, WantedLock, rowLockCollision);
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    GrantedMode := WantedLock.wlGrantedMode_kb05;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53lock_command (VAR m : tgg00_MessBlock);
 
VAR
      i           : integer;
      WantedLocks : t_AllLocks;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
i := 1;
WHILE (i <= m.mb_qual^.mlock_cnt)
      AND
      (m.mb_trns^.trError_gg00 = e_ok) DO
    BEGIN
    WITH m.mb_qual^.mlock [i] DO
        BEGIN
        IF  lockMode_gg00 in
            [lckRowShare_egg00, lckRowExcl_egg00, lckRowOptimistic_egg00]
        THEN
            k50init_wanted_rowid_lock (m.mb_data^.mbp_buf,
                  m.mb_data_size,
                  cgg_rec_key_offset + lockKeyPos_gg00, lockKeyLen_gg00,
                  WantedLocks [i], m.mb_trns^.trError_gg00)
        ELSE
            k51init_wanted_lock (WantedLocks [i]);
        (*ENDIF*) 
        WITH WantedLocks [i] DO
            BEGIN
            wlTabId_kb05    := lockTabId_gg00;
            wlMode_kb05     := lockMode_gg00;
            wlState_kb05    := lockState_gg00;
            wlHandling_kb05 := [hdCheckCollision_ekb05, hdInsLock_ekb05];
            IF  m.mb_type2 <> mm_test
            THEN
                wlHandling_kb05 := wlHandling_kb05 + [hdInsReq_ekb05]
            (*ENDIF*) 
            END
        (*ENDWITH*) 
        END;
    (*ENDWITH*) 
    i := i + 1
    END;
(*ENDWHILE*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    kb53multi_lock (m, WantedLocks);
(*ENDIF*) 
m.mb_type  := m_return_error;
m.mb_type2 := mm_nil
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53perm_temp_lock (
            VAR t              : tgg00_TransContext;
            LockUnlock         : tgg00_MessType;
            LockMode           : tgg00_LockReqMode;
            LockHandling       : tgg00_HandlingSet;
            VAR LockTabId      : tgg00_Surrogate;
            VAR k              : tgg00_Lkey);
 
VAR
      LockState    : tgg00_LockReqState;
      DummyGranted : tgg00_LockReqMode;
 
BEGIN
t.trError_gg00 := e_ok;
IF  LockUnlock = m_lock
THEN
    BEGIN
&   ifdef TRACE
    t01handling (ak_isolev, 'lock_handlng', LockHandling);
    t01handling (kb_lock,   'lock_handlng', LockHandling);
&   endif
    IF  hsTempLock_egg00 in LockHandling
    THEN
        LockState := [lrsTemp_egg00]
    ELSE
        LockState := [ ];
    (*ENDIF*) 
    k53lock (t, LockTabId, k, LockMode, LockState,
          (hsNoWait_egg00         in LockHandling),
          (hsCollisionTest_egg00 in LockHandling),
          DummyGranted)
    END
ELSE
    IF  LockUnlock = m_unlock
    THEN
        k53temp_unlock (t, LockTabId, k, LockMode)
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53release (
            VAR t            : tgg00_TransContext;
            force_release    : boolean;
            internal_session : boolean);
 
VAR
      TempTreeId    : tgg00_FileId;
 
BEGIN
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex
ELSE
    (* PTS 1103938 JA 199-09-23 *)
    BEGIN
    IF  tsLocked_egg00 in t.trState_gg00
    THEN
        (* commit/rollback missing *)
        k53rollback (t, mm_nil); (* UH 18-12-1998 *)
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) OR force_release
    THEN
        BEGIN
        t.trError_gg00 := e_ok;
        IF  NOT internal_session
        THEN
            BEGIN
            g04build_temp_tree_id (TempTreeId, t);
            a101_DestroyAllGroupedTempFiles (t, TempTreeId.fileName_gg00);
            IF  t.trError_gg00 = e_file_not_found
            THEN
                t.trError_gg00 := e_ok;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) OR force_release
    THEN
        (* remove stamp locks etc. *)
        BEGIN
        t.trError_gg00 := e_ok;
        k51remove_locks_2 (t, t.trIndex_gg00, t.trState_gg00);
        END;
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) OR force_release
    THEN
        k51del_transentry_from_locklist (t.trTaskId_gg00, t.trIndex_gg00, t)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  force_release
THEN
    t.trError_gg00 := e_ok (* PTS 1103938 JA 199-09-23 *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53rollback (
            VAR t        : tgg00_TransContext;
            MessType2    : tgg00_MessType2);
 
VAR
      TempTreeId       : tgg00_FileId;
 
BEGIN
t.trError_gg00 := e_ok;
&ifdef TRACE
t01sname (ak_isolev, '  k53rollbac');
&endif
IF  t.trIndex_gg00 = cgg_nil_transindex
THEN
    t.trError_gg00 := e_nil_transindex;
(*ENDIF*) 
;
(* PTS 1135542 FF 2005-05-13 *)
IF  (t.trError_gg00 = e_ok) AND
    NOT (( t.trFreePagesForIns_gg00 = NIL ) AND ( t.trSchemaShrLockHash_gg00 = NIL ))
THEN
    bd91TransEnd(t, false (*rollback*));
(*ENDIF*) 
;
IF  (t.trError_gg00 = e_ok) AND (MessType2 = mm_destroy_temp)
THEN
    BEGIN
    g04build_temp_tree_id (TempTreeId, t);
    a101_DestroyAllGroupedTempFiles (t, TempTreeId.fileName_gg00);
    IF  t.trError_gg00 = e_file_not_found
    THEN
        t.trError_gg00 := e_ok;
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    BEGIN
    kb560RollbackLogTransAction (t, mm_rollback, cgg_zero_subtrans);
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        k501MarkTransend (t.trIndex_gg00, c_rollbacked);                (* PTS 1128244 FF 2004-03-18 *)
        k512MonEndTransaction(t.trTaskId_gg00, t.trIndex_gg00, c_rollbacked );
        IF  (NIL <> t.trLocalFileDirPtr_gg00)
        THEN
            bd998ResetAllCachedLockStates(t.trLocalFileDirPtr_gg00);
        (*ENDIF*) 
        k51remove_locks_2 (t, t.trIndex_gg00, t.trState_gg00);
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        k50eot_new_trans (t);
    (*ENDIF*) 
    IF  t.trError_gg00 <> e_ok
    THEN
        gg999Offline (t.trError_gg00);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  t.trError_gg00 = e_work_rolled_back
THEN
    t.trError_gg00 := e_ok
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53row_lock (
            VAR t           : tgg00_TransContext;
            VAR FileId      : tgg00_FileId;
            VAR k           : tgg00_Lkey;
            VAR RecBuf      : tsp00_Buf;
            RecPos          : integer;
            MessType        : tgg00_MessType;
            ResultCount     : tsp00_Int4;
            VAR GrantedMode : tgg00_LockReqMode);
 
VAR
      CollisionTest : boolean;
      LockMode      : tgg00_LockReqMode;
      LockState     : tgg00_LockReqState;
      AuxKeyLen     : integer;
      StartSec      : tsp00_Int4;
      StartMsec     : tsp00_Int4;
      LockTabId     : tgg00_Surrogate;
 
BEGIN
(* RecBuf and RecPos originally inserted to lock clusters *)
(* further use: exclusive locks within records            *)
t.trError_gg00 := e_ok;
&ifdef TRACE
t01treeid (kb_lock, 'FileId:     ', FileId);
t01msgcheck ('K53ROW_LOCK: temp table       ',
      NOT (ftsTemp_egg00 in FileId.fileType_gg00), 0);
&endif
IF  MessType in [m_delete, m_insert, m_update, m_update_rec]
THEN
    LockState := [lrsEotExcl_egg00]
ELSE
    LockState := [ ];
(*ENDIF*) 
IF      (hsWithoutLock_egg00    in FileId.fileHandling_gg00) AND
    NOT (hsOptimisticLock_egg00 in FileId.fileHandling_gg00) AND
    NOT (lrsEotExcl_egg00       in LockState)
THEN
    BEGIN
    IF  t.trIndex_gg00 = cgg_nil_transindex
    THEN
        t.trError_gg00 := e_nil_transindex
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  g01vtrace.vtrTime_gg00
    THEN
        vclock (StartSec, StartMsec);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        AuxKeyLen     := k.len;
        CollisionTest := false;
        IF  kb560IsSys1CatalogTable (FileId.fileTabId_gg00)
        THEN
            BEGIN
            SAPDB_PascalMove ('VKB53 ',   7,    
                  sizeof (k.k), sizeof (LockTabId),
                  @k.k, 1, @LockTabId, 1, sizeof (LockTabId), t.trError_gg00);
            IF  lrsEotExcl_egg00 in LockState
            THEN
                LockMode  := lckSysExcl_egg00
            ELSE
                BEGIN
                LockMode      := lckSysShare_egg00;
                CollisionTest :=
                      (hsCollisionTest_egg00 in FileId.fileHandling_gg00);
                IF  hsConsistentLock_egg00 in FileId.fileHandling_gg00
                THEN
                    LockState := [lrsConsistent_egg00];
                (*ENDIF*) 
                IF  hsNoWaitForInserts_egg00 in FileId.fileHandling_gg00
                THEN
                    LockState := LockState + [lrsIgnoreInsert_egg00];
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            (* user table *)
            BEGIN
            LockTabId := FileId.fileTabId_gg00;
            IF  lrsEotExcl_egg00 in LockState
            THEN
                BEGIN
                IF  ResultCount < k51max_locks_per_table
                THEN
                    BEGIN
                    LockMode := lckRowExcl_egg00;
                    IF  MessType = m_insert
                    THEN
                        LockState := LockState + [lrsForInsert_egg00]
                    (*ENDIF*) 
                    END
                ELSE
                    LockMode := lckTabExcl_egg00
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  hsConsistentLock_egg00 in FileId.fileHandling_gg00
                THEN
                    LockState := [lrsConsistent_egg00];
                (*ENDIF*) 
                IF  hsNoWaitForInserts_egg00 in FileId.fileHandling_gg00
                THEN
                    LockState := LockState + [lrsIgnoreInsert_egg00];
                (*ENDIF*) 
                IF  hsOptimisticLock_egg00 in FileId.fileHandling_gg00
                THEN
                    LockMode := lckRowOptimistic_egg00
                ELSE
                    IF  hsIntentExcl_egg00 in FileId.fileHandling_gg00
                    THEN
                        LockMode := lckRowExcl_egg00
                    ELSE
                        BEGIN
                        LockMode := lckRowShare_egg00;
                        CollisionTest :=
                              (hsCollisionTest_egg00 in FileId.fileHandling_gg00)
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            k53lock (t, LockTabId, k, LockMode, LockState,
                  (hsNoWait_egg00 in FileId.fileHandling_gg00),
                  CollisionTest, GrantedMode);
        (*ENDIF*) 
        k.len := AuxKeyLen
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_lock_collision_with_inserted_row
    THEN
        t.trError_gg00 := e_key_not_found;
    (*ENDIF*) 
    IF  g01vtrace.vtrTime_gg00
    THEN
        g01time_vtrace (t, 'k53row_lock       ', StartSec, StartMsec)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53row_lock_by_key (
            VAR t           : tgg00_TransContext;
            VAR FileId      : tgg00_FileId;
            VAR k           : tsp00_Key;
            KeyLen          : tsp00_Int4;
            MessType        : tgg00_MessType;
            ResultCount     : tsp00_Int4;
            VAR GrantedMode : tgg00_LockReqMode);
 
VAR
      CollisionTest : boolean;
      LockMode      : tgg00_LockReqMode;
      LockState     : tgg00_LockReqState;
      StartSec      : tsp00_Int4;
      StartMsec     : tsp00_Int4;
      LockTabId     : tgg00_Surrogate;
 
BEGIN
t.trError_gg00 := e_ok;
&ifdef TRACE
t01treeid (kb_lock, 'FileId:     ', FileId);
t01msgcheck ('K53ROW_LOCK: temp table       ',
      NOT (ftsTemp_egg00 in FileId.fileType_gg00), 0);
&endif
IF  MessType in [m_delete, m_insert, m_update, m_update_rec]
THEN
    BEGIN
    IF  MessType = m_insert
    THEN
        LockState := [lrsEotExcl_egg00, lrsForInsert_egg00]
    ELSE
        LockState := [lrsEotExcl_egg00]
    (*ENDIF*) 
    END
ELSE
    LockState := [ ];
(*ENDIF*) 
IF      (hsWithoutLock_egg00    in FileId.fileHandling_gg00) AND
    NOT (hsOptimisticLock_egg00 in FileId.fileHandling_gg00) AND
    NOT (lrsEotExcl_egg00       in LockState)
THEN
    BEGIN
    IF  t.trIndex_gg00 = cgg_nil_transindex
    THEN
        t.trError_gg00 := e_nil_transindex
    (*ENDIF*) 
    END
ELSE
    BEGIN
    IF  g01vtrace.vtrTime_gg00
    THEN
        vclock (StartSec, StartMsec);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        CollisionTest := false;
        IF  kb560IsSys1CatalogTable (FileId.fileTabId_gg00)
        THEN
            BEGIN
            SAPDB_PascalMove ('VKB53 ',   8,    
                  sizeof (k), sizeof (LockTabId),
                  @k, 1, @LockTabId, 1, sizeof (LockTabId), t.trError_gg00);
            IF  lrsEotExcl_egg00 in LockState
            THEN
                LockMode  := lckSysExcl_egg00
            ELSE
                BEGIN
                LockMode      := lckSysShare_egg00;
                CollisionTest :=
                      (hsCollisionTest_egg00 in FileId.fileHandling_gg00);
                IF  hsConsistentLock_egg00 in FileId.fileHandling_gg00
                THEN
                    LockState := [lrsConsistent_egg00];
                (*ENDIF*) 
                IF  hsNoWaitForInserts_egg00 in FileId.fileHandling_gg00
                THEN
                    LockState := LockState + [lrsIgnoreInsert_egg00];
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END
        ELSE
            (* user table *)
            BEGIN
            LockTabId := FileId.fileTabId_gg00;
            IF  lrsEotExcl_egg00 in LockState
            THEN
                BEGIN
                IF  ResultCount < k51max_locks_per_table
                THEN
                    LockMode := lckRowExcl_egg00
                ELSE
                    LockMode := lckTabExcl_egg00
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  hsConsistentLock_egg00 in FileId.fileHandling_gg00
                THEN
                    LockState := [lrsConsistent_egg00];
                (*ENDIF*) 
                IF  hsNoWaitForInserts_egg00 in FileId.fileHandling_gg00
                THEN
                    LockState := LockState + [lrsIgnoreInsert_egg00];
                (*ENDIF*) 
                IF  hsOptimisticLock_egg00 in FileId.fileHandling_gg00
                THEN
                    LockMode := lckRowOptimistic_egg00
                ELSE
                    IF  hsIntentExcl_egg00 in FileId.fileHandling_gg00
                    THEN
                        LockMode := lckRowExcl_egg00
                    ELSE
                        BEGIN
                        LockMode := lckRowShare_egg00;
                        CollisionTest :=
                              (hsCollisionTest_egg00 in FileId.fileHandling_gg00)
                        END
                    (*ENDIF*) 
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            BEGIN
            IF  t.trSyncParallelServers_gg00
            THEN
                vbegexcl(t.trTaskId_gg00, g08LockParallel);
            (*ENDIF*) 
            kb53lock_by_key (t, LockTabId, k, KeyLen, LockMode, LockState,
                  (hsNoWait_egg00 in FileId.fileHandling_gg00),
                  CollisionTest, GrantedMode);
            IF  t.trSyncParallelServers_gg00
            THEN
                vendexcl(t.trTaskId_gg00, g08LockParallel);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  g01vtrace.vtrTime_gg00
    THEN
        g01time_vtrace (t, 'k53row_lock       ', StartSec, StartMsec)
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53set_sys2_cat_excl_nowait (VAR t : tgg00_TransContext);
 
VAR
      DummyGranted : tgg00_LockReqMode;
      DummyKey     : tgg00_Lkey;
      sys2_cat     : tgg00_Surrogate;
 
BEGIN
t.trError_gg00 := e_ok;
kb560GetSys2CatalogTabId (sys2_cat);
k53lock (t, sys2_cat, DummyKey,
      lckTabExcl_egg00, [lrsEotExcl_egg00],
      NOWAIT, NOT COLLISION_TEST, DummyGranted)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53signal_commit (VAR m : tgg00_MessBlock);
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53temp_unlock (
            VAR t           : tgg00_TransContext;
            VAR LockTabId   : tgg00_Surrogate;
            VAR k           : tgg00_Lkey;
            LockMode        : tgg00_LockReqMode);
 
BEGIN
t.trError_gg00 := e_ok;
&ifdef TRACE
IF  t01trace (ak_isolev) OR t01trace (kb_lock)
THEN
    BEGIN
    t01sname    (ak_isolev, '  k53temp_un');
    t01lockmode (td_always, 'LockMode    ', LockMode);
    t01tabid    (td_always, 'LockTabId   ', LockTabId);
    IF  LockMode in
        [lckRowExcl_egg00, lckRowShare_egg00, lckRowOptimistic_egg00]
    THEN
        t01lkey (td_always, k)
    (*ENDIF*) 
    END;
&endif
(*ENDIF*) 
IF  LockMode = lckTabShare_egg00
THEN
    k51temp_tab_share_unlock (t, LockTabId)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53unlock (VAR m : tgg00_MessBlock);
 
VAR
      i          : integer;
      WantedLock : tkb05_WantedLock;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
&ifdef TRACE
t01sname (ak_isolev, '  k53unlock ');
&endif
IF  m.mb_trns^.trIndex_gg00 = cgg_nil_transindex
THEN
    m.mb_trns^.trError_gg00 := e_nil_transindex;
(*ENDIF*) 
IF  (m.mb_trns^.trError_gg00 = e_ok)
    AND
    (m.mb_trns^.trIndex_gg00 <> cgg_nil_transindex)
THEN
    BEGIN
    i := 1;
    WHILE (i <= m.mb_qual^.mlock_cnt)
          AND (m.mb_trns^.trError_gg00 = e_ok) DO
        BEGIN
        WITH m.mb_qual^.mlock [i] DO
            BEGIN
&           ifdef TRACE
            t01lockmode  (ak_isolev, 'lockMode    ', lockMode_gg00);
            t01lockstate (ak_isolev, 'lockState   ', lockState_gg00);
            t01tabid     (ak_isolev, 'lockTabId   ', lockTabId_gg00);
&           endif
            IF  lrsTemp_egg00 in lockState_gg00
            THEN
                BEGIN
                IF  lockMode_gg00 = lckTabShare_egg00
                THEN
                    k51temp_tab_share_unlock (m.mb_trns^, lockTabId_gg00)
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                IF  lockMode_gg00 in
                    [lckRowShare_egg00, lckRowExcl_egg00, lckRowOptimistic_egg00]
                THEN
                    k50init_wanted_rowid_lock (m.mb_data^.mbp_buf,
                          m.mb_data_size,
                          cgg_rec_key_offset + lockKeyPos_gg00, lockKeyLen_gg00,
                          WantedLock, m.mb_trns^.trError_gg00)
                ELSE
                    k51init_wanted_lock (WantedLock);
                (*ENDIF*) 
                WITH WantedLock DO
                    BEGIN
                    wlTabId_kb05 := lockTabId_gg00;
                    wlMode_kb05  := lockMode_gg00;
                    wlState_kb05 := lockState_gg00;
                    END;
                (*ENDWITH*) 
                IF  m.mb_trns^.trError_gg00 = e_ok
                THEN
                    k51unlock (m.mb_trns^.trTaskId_gg00, m.mb_trns^.trIndex_gg00,
                          m.mb_trns^.trState_gg00, WantedLock)
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDWITH*) 
        i := i + 1
        END
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
m.mb_type  := m_return_error;
m.mb_type2 := mm_nil
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53wait (
            VAR t     : tgg00_TransContext;
            MessType  : tgg00_MessType;
            MessType2 : tgg00_MessType2);
 
VAR
      IsOk  : boolean;
      trace : tgg11_KbTrace;
 
BEGIN
t.trError_gg00 := e_ok;
&ifdef TRACE
t01sname (ak_isolev, '  k53wait   ');
&endif
REPEAT
    IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00
    THEN
        BEGIN
        trace.kbMessType_gg11  := MessType;
        trace.kbMessType2_gg11 := MessType2;
        trace.kbError_gg11     := e_ok;
        b120InsertTrace (t, kb, vttKbLockWait_egg00, sizeof (trace), @trace)
        END;
    (*ENDIF*) 
    vwait (t.trTaskId_gg00, IsOk);
    IF  IsOk
    THEN
        BEGIN
        t.trError_gg00 := e_ok;
        k51examine_trans (t)
        END
    ELSE
        (* PTS 1106270 JA 2000-04-06 *)
        BEGIN
        t.trError_gg00 := e_ok;
        k51handle_request_timeout (t);
        IF  t.trError_gg00 = e_ok
        THEN
            t.trError_gg00 := e_request_timeout;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  g01vtrace.vtrAll_gg00 OR g01vtrace.vtrKbLock_gg00
    THEN
        BEGIN
        trace.kbError_gg11 := t.trError_gg00;
        b120InsertTrace (t, kb, vttKbLockWaitResume_egg00, sizeof (trace), @trace)
        END;
    (*ENDIF*) 
UNTIL
    t.trError_gg00 <> e_wait_for_lock_release
(*ENDREPEAT*) 
END;
 
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      kb53check_mode_state (
            LockMode      : tgg00_LockReqMode;
            LockState     : tgg00_LockReqState;
            CollisionTest : boolean);
 
BEGIN
t01msgcheck ('illegal Lock mode             ', (LockMode in [
      lckSysShare_egg00,
      lckSysExcl_egg00,
      lckTabShare_egg00,
      lckTabExcl_egg00,
      lckRowShare_egg00,
      lckRowExcl_egg00,
      lckRowOptimistic_egg00 ]), ord (LockMode));
IF  lrsConsistent_egg00 in LockState
THEN
    BEGIN
    t01msgcheck ('illegal consistent Lock state ', (LockMode in [
          lckSysShare_egg00,
          lckRowShare_egg00,
          lckRowExcl_egg00,
          lckRowOptimistic_egg00 ]), ord (LockMode));
    t01msgcheck ('consistent and temp           ',
          NOT (lrsTemp_egg00 in LockState), ord (LockMode))
    END;
(*ENDIF*) 
IF  lrsEotExcl_egg00 in LockState
THEN
    BEGIN
    t01msgcheck ('illegal eot_excl Lock state   ', (LockMode in [
          lckSysExcl_egg00,
          lckTabExcl_egg00,
          lckRowExcl_egg00 ]), ord (LockMode));
    t01msgcheck ('eot excl and temp             ',
          NOT (lrsTemp_egg00 in LockState), ord (LockMode));
    t01msgcheck ('eot excl and consistent       ',
          NOT (lrsConsistent_egg00 in LockState), ord (LockMode))
    END
ELSE
    t01msgcheck ('eot_excl missing in Lock state',
          (LockMode <> lckSysExcl_egg00), ord (LockMode));
(*ENDIF*) 
IF  lrsTemp_egg00 in LockState
THEN
    t01msgcheck ('illegal temp Lock state       ', (LockMode in [
          lckTabShare_egg00,
          lckTabExcl_egg00,
          lckRowShare_egg00,
          lckRowExcl_egg00  ]), ord (LockMode));
(*ENDIF*) 
IF  CollisionTest
THEN
    t01msgcheck ('illegal CollisionTest         ', (LockMode in [
          lckTabShare_egg00,
          lckSysShare_egg00,
          lckRowShare_egg00 ]), ord (LockMode));
(*ENDIF*) 
IF  ((lrsForInsert_egg00 in LockState)
    AND
    (lrsIgnoreInsert_egg00 in LockState))
    OR
    ((lrsIgnoreInsert_egg00 in LockState)
    AND
    (lrsForInsert_egg00 in LockState))
THEN
    t01msgcheck ('illegal Insert Ignoration     ', false, 0)
(*ENDIF*) 
END;
 
&endif
(*------------------------------*) 
 
PROCEDURE
      kb53multi_lock (
            VAR m           : tgg00_MessBlock;
            VAR WantedLocks : t_AllLocks);
 
VAR
      i                : integer;
      rowLockCollision : boolean;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
&ifdef TRACE
t01sname (ak_isolev, '  kb53multi_');
FOR i := 1 TO m.mb_qual^.mlock_cnt DO
    BEGIN
    t01int4 (kb_lock, 'index       ', i);
    t01lock (kb_lock, 'Lock        ', m.mb_qual^.mlock [i])
    END;
(*ENDFOR*) 
&endif
i := 1;
WHILE (m.mb_trns^.trError_gg00 = e_ok)
      AND (i <= m.mb_qual^.mlock_cnt) DO
    BEGIN
&   ifdef TRACE
    WITH WantedLocks [i] DO
        BEGIN
        t01lockmode  (ak_isolev, 'WantedMode  ', wlMode_kb05);
        t01lockstate (ak_isolev, 'WantedState ', wlState_kb05);
        t01tabid     (ak_isolev, 'WantedTabid ', wlTabId_kb05);
        kb53check_mode_state (wlMode_kb05, wlState_kb05,
              NOT COLLISION_TEST);
        END;
    (*ENDWITH*) 
&   endif
    (* NOT check all locks => NOT all entries marked (TE_COLLISION) *)
    k51check_ins_lock (m.mb_trns^, WantedLocks [i], rowLockCollision);
    IF  m.mb_trns^.trError_gg00 = e_wait_for_lock_release
    THEN
        k53wait (m.mb_trns^, m.mb_type, m.mb_type2);
    (*ENDIF*) 
    i := i + 1
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53StartInternalSession (
            VAR TransContext    : tgg00_TransContext;
            VAR AuxTransContext : tgg00_TransContext;
            bOpenNewTrans       : boolean;
            bInheritLocalFDir   : boolean);
 
VAR
      TransEntryPtr : tkb05_TransEntryPtr;
 
BEGIN
(* The consistent view is inherited from parent transaction *)
(* ******************************************************** *)
(* TEMP FILES WHICH ARE CREATED DURING AN INTERNAL SESSION  *)
(* HAVE TO BE EXPLICITELY REMOVED BY THE CREATOR.           *)
(* THEY ARE NOT REMOVED AUTOMATICALLY AT THE END OF THE     *)
(* INTERNAL SESSION.                                        *)
(* ******************************************************** *)
AuxTransContext := TransContext; (* save existing trans context *)
TransContext.trChild_gg00 := cgg_nil_child;
k51new_session (TransContext);
(* check if internal session should use file directory of enclosing session: *)
(* this is required, if internal session need to access temporary files      *)
(* created by enclosing session                                              *)
IF  bInheritLocalFDir
THEN
    TransContext.trLocalFileDirPtr_gg00 := AuxTransContext.trLocalFileDirPtr_gg00;
(* *)
(*ENDIF*) 
IF  TransContext.trError_gg00 = e_ok
THEN
    kb560CreateLogTransaction (TransContext);
(*ENDIF*) 
IF  (TransContext.trError_gg00 = e_ok)
    AND
    bOpenNewTrans
THEN
    k50new_write_trans (TransContext);
(*ENDIF*) 
IF  TransContext.trError_gg00 = e_ok
THEN
    BEGIN
    k52acc_trans_entry (TransContext.trIndex_gg00, TransEntryPtr);
    TransEntryPtr^.teTermId_kb05 := 'INTERNAL TRANS    ';
    END;
(*ENDIF*) 
IF  TransContext.trError_gg00 <> e_ok
THEN
    BEGIN
    AuxTransContext.trError_gg00 := TransContext.trError_gg00;
    TransContext.trError_gg00    := e_ok;
    k51del_transentry_from_locklist (TransContext.trTaskId_gg00,
          TransContext.trIndex_gg00,
          TransContext); (* PTS 1133444 mb 2005-01-19 *)
    kb560DeleteLogTransaction       (TransContext);
    TransContext                 := AuxTransContext;
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k53StopInternalSession (
            VAR TransContext    : tgg00_TransContext;
            VAR AuxTransContext : tgg00_TransContext;
            typeOfTransEnd      : tgg00_MessType);
 
BEGIN
AuxTransContext.trError_gg00 := TransContext.trError_gg00;
IF  typeOfTransEnd = m_rollback
THEN
    k53rollback (TransContext, mm_nil)
ELSE
    k53commit (TransContext, mm_nil);
(*ENDIF*) 
k53release (TransContext, true, c_internal_session);
kb560DeleteLogTransaction (TransContext);
IF  TransContext.trError_gg00 <> e_ok
THEN
    AuxTransContext.trError_gg00 := TransContext.trError_gg00;
(* restore old trans *)
(*ENDIF*) 
TransContext := AuxTransContext;
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
