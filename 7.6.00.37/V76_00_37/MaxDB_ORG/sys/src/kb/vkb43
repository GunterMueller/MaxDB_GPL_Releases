/****************************************************************************
  module      : vkb43
  author      : JuergenA
  responsible : UweH
  special area:
  see also    :
  description :
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2001-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
*****************************************************************************/
 
.tt 1 $SAP$LiveCache$VKB43$
.tt 3 $UweH$KB_stringcol_copy_trunc_expand$1999-07-20$
 
Module  : KB_stringcol_copy_trunc_expand
 
Define  :
 
        PROCEDURE
              k43begin_load (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k43cnew_lock_column (
                    VAR m       : tgg00_MessBlock;
                    copy_target : boolean);
 
        PROCEDURE
              k43CopyLongColumn (
                    mtrans           : tgg00_TransContextPtr;
                    VAR mheader      : tgg00_MessBufHeader;
                    VAR sourceTabid  : tgg00_Surrogate;
                    VAR sourceLongId : tgg00_Surrogate;
                    VAR destTabid    : tgg00_Surrogate;
                    VAR destLongId   : tgg00_Surrogate;
                    createFile       : boolean);
 
        PROCEDURE
              k43ctrunc_column (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k43cwrite_column (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k43cnwrite_column (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k43_ins_copy_column (
                    VAR mtrans            : tgg00_TransContextPtr;
                    VAR mheader           : tgg00_MessBufHeader;
                    VAR src_tree          : tgg00_FileId;
                    VAR dst_tree          : tgg00_FileId;
                    VAR src_tab_id        : tgg00_Surrogate;
                    VAR src_surr          : tgg00_Surrogate;
                    VAR dst_surr          : tgg00_Surrogate;
                    dst_has_shrt_col_file : boolean;
                    VAR shrt_col_rec_ptr  : tgg00_RecPtr;
                    use_shrt_col_rec      : boolean);
 
        PROCEDURE
              k43ttwrite_string (
                    VAR t              : tgg00_TransContext;
                    VAR prim_tabid     : tgg00_Surrogate;
                    VAR curr_file      : tgg00_FileId;
                    VAR curr_long_qual : tgg00_LongQual;
                    buf_size           : tsp00_Int4;
                    buf_addr           : tsp00_MoveObjPtr;
                    inpos              : tsp00_Int4;
                    inlen              : tsp00_Int4;
                    VAR str_vers       : tsp00_Int4);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
&       ifdef TRACE
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01buf1 (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_Buf;
                    startpos : integer;
                    endpos   : integer);
 
        PROCEDURE
              t01int4 (
                    layer    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    int      : tsp00_Int4);
 
        PROCEDURE
              t01long_qual (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR long_qual : tgg00_LongQual);
 
        PROCEDURE
              t01moveobj (
                    layer    : tgg00_Debug;
                    VAR buf  : tsp00_MoveObj;
                    startpos : tsp00_Int4;
                    endpos   : tsp00_Int4);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              t01surrogate (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    VAR tabid : tgg00_Surrogate);
 
        PROCEDURE
              t01treeid (
                    debug      : tgg00_Debug;
                    nam        : tsp00_Sname;
                    VAR treeid : tgg00_FileId);
&       endif
 
      ------------------------------ 
 
        FROM
              Select_Help_Procedures : VGG04;
 
        PROCEDURE
              g04short_col_tree_build (
                    VAR table_surrogate : tgg00_Surrogate (*ptocConst*);
                    VAR short_col_tree  : tgg00_FileId;
                    VAR b_err           : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              KB_CopyUpdBlob_interface : VKB431;
 
        PROCEDURE
              kb431CopyBlob (
                    VAR TransContext : tgg00_TransContext;
                    VAR DestinTabId  : tgg00_Surrogate;
                    VAR SourceBlob   : tgg00_FileId;
                    VAR DestinBlob   : tgg00_FileId;
                    OldDestinVersion : tsp00_Int4;
                    OldDestinLength  : tsp00_Int4;
                    SourceOffset     : tsp00_Int4;
                    DestinOffset     : tsp00_Int4;
                    CopyLength       : tsp00_Int4);
 
        PROCEDURE
              kb431TruncateBlob (
                    VAR TransContext    : tgg00_TransContext;
                    VAR tableId         : tgg00_Surrogate;
                    VAR Blob            : tgg00_FileId;
                    BlobVersion         : tsp00_Int4;
                    OldBlobLength       : tsp00_Int4;
                    NewTruncatedBlobLen : tsp00_Int4);
 
        PROCEDURE
              kb431UpdateBlob (
                    VAR TransContext : tgg00_TransContext;
                    VAR tableId         : tgg00_Surrogate;
                    VAR Blob         : tgg00_FileId;
                    BlobVersion      : tsp00_Int4;
                    OldBlobLength    : tsp00_Int4;
                    InsertOffset     : tsp00_Int4;
                    pBuf             : tsp00_MoveObjPtr;
                    BufOffset        : tsp00_Int4;
                    BufLength        : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              KB_stringcol_open_close : VKB44;
 
        PROCEDURE
              k44copy_move_shrt_to_bstr_file (
                    VAR mtrans     : tgg00_TransContextPtr;
                    VAR mheader    : tgg00_MessBufHeader;
                    VAR src_tabid  : tgg00_Surrogate;
                    VAR dest_tabid : tgg00_Surrogate;
                    VAR src_tree   : tgg00_FileId;
                    VAR dst_tree   : tgg00_FileId;
                    VAR shc_buf    : tgg00_Rec;
                    use_shc_buf    : boolean;
                    move_shc_entry : boolean);
 
        PROCEDURE
              k44get_shrt_col_rec (
                    mtrans         : tgg00_TransContextPtr;
                    VAR mtree      : tgg00_FileId;
                    VAR shc_buf    : tgg00_Rec;
                    VAR prim_tabid : tgg00_Surrogate;
                    VAR shc_id     : tgg00_Surrogate);
 
        PROCEDURE
              k44get_short_col_rec (
                    VAR m          : tgg00_MessBlock;
                    VAR shc_buf    : tgg00_Rec;
                    VAR prim_tabid : tgg00_Surrogate;
                    VAR shc_id     : tgg00_Surrogate);
 
        PROCEDURE
              k44insdelupdshort_col_rec (
                    VAR mtrans     : tgg00_TransContextPtr;
                    VAR mheader    : tgg00_MessBufHeader;
                    VAR mtree      : tgg00_FileId;
                    VAR shc_buf    : tgg00_Rec;
                    VAR prim_tabid : tgg00_Surrogate;
                    VAR shc_id     : tgg00_Surrogate;
                    mess_type      : tgg00_MessType;
                    use_shc_buf    : boolean);
 
        PROCEDURE
              k44ins_del_upd_short_col_rec (
                    VAR m          : tgg00_MessBlock;
                    VAR shc_buf    : tgg00_Rec;
                    VAR prim_tabid : tgg00_Surrogate;
                    VAR shc_id     : tgg00_Surrogate;
                    mess_type      : tgg00_MessType;
                    use_shc_buf    : boolean);
 
        PROCEDURE
              k44upgrade_to_bstr_file (
                    VAR m          : tgg00_MessBlock;
                    VAR prim_tabid : tgg00_Surrogate;
                    VAR shc_buf    : tgg00_Rec;
                    use_shc_buf    : boolean);
 
      ------------------------------ 
 
        FROM
              KB_stringcol_read_search_length : VKB45;
 
        PROCEDURE
              k45test_short_col_upgraded (
                    VAR m        : tgg00_MessBlock;
                    VAR upgraded : boolean);
 
      ------------------------------ 
 
        FROM
              KB_trans_state : VKB50;
 
        PROCEDURE
              k50new_write_trans (VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              KB_locklist : VKB51;
 
        PROCEDURE
              k51row_excl_check (
                    VAR t     : tgg00_TransContext;
                    VAR tabid : tgg00_Surrogate;
                    VAR k     : tgg00_Lkey);
 
        PROCEDURE
              k51unlock_table (
                    TaskId            : tsp00_TaskId;
                    TransIndex        : tgg00_TransIndex;
                    VAR TransState    : tgg00_TransState;
                    VAR Lock          : tgg00_Lock);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53eot_excl_lock (
                    VAR t             : tgg00_TransContext;
                    VAR TreeId        : tgg00_FileId;
                    VAR k             : tgg00_Lkey;
                    forInsert         : boolean;
                    WantedMode        : tgg00_LockReqMode;
                    VAR GrantedMode   : tgg00_LockReqMode);
 
        PROCEDURE
              k53lock (
                    VAR t            : tgg00_TransContext;
                    VAR lock_tabid   : tgg00_Surrogate;
                    VAR k            : tgg00_Lkey;
                    wanted_mode      : tgg00_LockReqMode;
                    wanted_state     : tgg00_LockReqState;
                    nowait           : boolean;
                    collision_test   : boolean;
                    VAR granted_mode : tgg00_LockReqMode);
 
        PROCEDURE
              k53internal_lock (
                    VAR t             : tgg00_TransContext;
                    VAR lock_tabid    : tgg00_Surrogate;
                    VAR k             : tgg00_Lkey;
                    lock_handling     : tgg00_HandlingSet;
                    wanted_mode       : tgg00_LockReqMode;
                    VAR granted_mode  : tgg00_LockReqMode);
 
        PROCEDURE
              k53temp_unlock (
                    VAR t           : tgg00_TransContext;
                    VAR LockTabId   : tgg00_Surrogate;
                    VAR k           : tgg00_Lkey;
                    LockMode        : tgg00_LockReqMode);
 
        PROCEDURE
              k53wait (
                    VAR t     : tgg00_TransContext;
                    MessType  : tgg00_MessType;
                    MessType2 : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              KB_restart_record : VKB57;
 
        PROCEDURE
              k57table_key_get (
                    pid             : tsp00_TaskId;
                    VAR trans_state : tgg00_TransState;
                    VAR syskey      : tgg00_Lkey);
 
      ------------------------------ 
 
        FROM
              KB_file_table_handling : VKB64;
 
        PROCEDURE
              k64create_bd_file (
                    VAR t          : tgg00_TransContext;
                    VAR tree_id    : tgg00_FileId;
                    mess_type      : tgg00_MessType;
                    mess2_type     : tgg00_MessType2;
                    eFiletypeSet   : tgg00_ExtendedFiletypeSet;
                    str_col_cnt    : tsp00_Int2);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1 : VBD01;
 
        VAR
              b01zerokey    : tsp00_Key;
              b01niltree_id : tgg00_FileId;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_2 : VBD02;
 
        PROCEDURE
              b02get_record (
                    VAR t          : tgg00_TransContext;
                    VAR file_id    : tgg00_FileId;
                    VAR rk         : tgg00_Lkey;
                    VAR b          : tgg00_Rec);
 
        PROCEDURE
              b02repl_record (
                    VAR t           : tgg00_TransContext;
                    VAR file_id     : tgg00_FileId;
                    VAR b           : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_5 : VBD05;
 
        PROCEDURE
              b05get_str_version  (
                    VAR t        : tgg00_TransContext;
                    VAR file_id  : tgg00_FileId;
                    VAR str_vers : tsp00_Int4);
 
        PROCEDURE
              b05length_bytestr (
                    VAR t           : tgg00_TransContext;
                    VAR file_id     : tgg00_FileId;
                    VAR filelength  : tsp00_Int4;
                    VAR page_count  : tsp00_Int4;
                    VAR str_version : tsp00_Int4);
 
        PROCEDURE
              bd05ReadLob (
                    VAR t        : tgg00_TransContext;
                    VAR file_id  : tgg00_FileId;
                    pos          : tsp00_Int4;
                    VAR length   : tsp00_Int4;
                    buf_size     : tsp00_Int4;
                    buf_addr     : tsp00_MoveObjPtr;
                    bufpos       : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        FUNCTION
              gg06IsNilTrans (VAR TransNo : tgg91_TransNo): boolean;
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        PROCEDURE
              gg999Abort (writeCore : boolean);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id     : tsp00_C6;
                    mod_num    : tsp00_Int4;
                    source_upd : tsp00_Int4;
                    destin_upb : tsp00_Int4;
                    source     : tsp00_MoveObjPtr;
                    source_pos : tsp00_Int4;
                    destin     : tsp00_MoveObjPtr;
                    destin_pos : tsp00_Int4;
                    length     : tsp00_Int4;
                    VAR err    : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30cmp (
                    VAR buf1     : tsp00_MoveObj;
                    fieldpos1    : tsp00_Int4;
                    fieldlength1 : tsp00_Int4;
                    VAR buf2     : tsp00_Buf;
                    fieldpos2    : tsp00_Int4;
                    fieldlength2 : tsp00_Int4;
                    VAR l_result : tsp00_LcompResult);
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              s30cmp;
 
              tsp00_MoveObj tsp00_Buf
 
.CM *-END-* synonym -------------------------------------
 
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
.sp 2
K43ctrunc_column
.sp;.in +3
A string column or file is truncated to the length
specified in the message buffer's first stack entry
(in the eval4_var field).
This procedure always runs with logging in order to obtain
a reliable version of a trunc command with all
restart and rollback facilities a special BD-layer
routine was required.
.sp 2;.in -3
Specification:
.sp 2
K43cwrite_column
.sp;.in +3
Adds a maximum of 8104 Bytes to a string column or file.
The position and length parameters are sent as part1
stack entries (message buffer). Part2 contains the front
part of the byte string with a maximum length of 4092
bytes and part1 contains the remaining bytes. If the length
exceeds 4092 bytes (i.e. part2_length = 4092 and
part1 also contains some bytes), the subfunction
ttwrite_string will be executed twice:
.sp
.nf
     part2_length = 3000
 
     --> ttwrite_string (pos, len, part2)
.sp 2
     part2_length = 4092
     part1_length = 3000 + mess_part_header + stack size
 
     --> ttwrite_string (pos, len, part2)
         ttwrite_string (incr pos, reduced len, part1)
.fo
.sp 2;.in -3
ttwrite_string
.sp;.in +3
Adds (or replaces) a maximum of 4092
bytes (buffer) to (in) a string column or file and is
called from the K43cwrite column procedure.
If the eop_field of the first stack entry is not
in [ op_buffered, op_unbuffered ], the operation
is done with logging (i.e. a logentry will be written).
To avoid log overflow, the procedure tries
to reduce the number of bytes that will be written
to the log as before and after image.
.sp 2;.in -3
.CM *-END-* specification -------------------------------
.sp 2
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp 2
.cm  hier input description
====> for description of the logentries see VKB40
.CM *-END-* description ---------------------------------
.fo
.sp 2
***********************************************************
.sp
.cp 10
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 10
.nf
.oc _/1
.CM -lll-
Code    :
 
 
CONST
      c_collision_test  = true;
      c_copy_target     = true;
      c_nowait          = true;
      c_use_shc_buf     = true;
      c_move_target     = true;
      (**)
      c_str_id_sign     = 128;
      c_pos_str_id_sign =   3;
      (* PTS 1120287 E.Z. *)
      c_write_core = true;
      (* PTS 1129416 *)
      c_doUpdateIfDuplicate = true;
 
 
(*------------------------------*) 
 
PROCEDURE
      kb43cmpct (
            size_1        : tsp00_Int4;
            size_2        : tsp00_Int4;
            VAR buf1      : tsp00_MoveObj;
            pos1          : tsp00_Int4;
            s30len1       : tsp00_Int4;
            VAR buf2      : tsp00_MoveObj;
            pos2          : tsp00_Int4;
            s30len2       : tsp00_Int4;
            VAR front_pos : tsp00_Int4;
            VAR rear_pos  : tsp00_Int4);
      (* PTS 1123151 mb 2003-07-17 moved from vsp33 *)
 
VAR
      s30eq, eq2 : boolean;
      i, j       : tsp00_Int4;
 
BEGIN
IF  (pos1 + s30len1 - 1 > size_1) OR
    (pos2 + s30len2 - 1 > size_2)
THEN
    gg999Abort (c_write_core);
(*ENDIF*) 
eq2 := true;
i := pos1;
j := pos2;
s30eq := true;
front_pos := 0;
rear_pos := 0;
WHILE s30eq AND (j < pos2 + s30len1) DO
    IF  buf1 [ i ] <> buf2 [ j ]
    THEN
        BEGIN
        front_pos := (j - pos2) + 1;
        s30eq := false
        END
    ELSE
        BEGIN
        i := i+1;
        j := j+1
        END;
    (*ENDIF*) 
(*ENDWHILE*) 
IF  s30len2 > s30len1
THEN
    BEGIN
    rear_pos := s30len2;
    eq2 := false;
    IF  s30eq
    THEN
        front_pos := s30len1 + 1
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  NOT s30eq AND eq2
THEN
    BEGIN
    i := pos1 + s30len1 - 1;
    j := pos2 + s30len2 - 1;
    s30eq := true;
    WHILE s30eq AND (j >= front_pos)
          DO
        IF  buf1 [ i ] <> buf2 [ j ]
        THEN
            BEGIN
            rear_pos := (j - pos2) + 1;
            s30eq := false
            END
        ELSE
            BEGIN
            i := i-1;
            j := j-1
            END;
        (*ENDIF*) 
    (*ENDWHILE*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k43begin_load (VAR m : tgg00_MessBlock);
 
VAR
      dummy_granted : tgg00_LockReqMode;
      str_col_no    : integer;
      pkey          : tgg00_Lkey;
      colkey        : tgg00_Lkey;
      dummy_key     : tgg00_Lkey;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
k53eot_excl_lock (m.mb_trns^, m.mb_qual^.mtree, dummy_key, false, lckSysExcl_egg00, dummy_granted);
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    str_col_no := m.mb_qual^.mcol_pos;
    pkey.len   := m.mb_data^.mbp_keylen;
    SAPDB_PascalMove ('VKB43 ',   1,    
          m.mb_data_size, sizeof (pkey.k),
          @m.mb_data^.mbp_buf, cgg_rec_key_offset + 1,
          @pkey.k, 1, pkey.len, m.mb_trns^.trError_gg00)
    END;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    b02get_record (m.mb_trns^, m.mb_qual^.mtree, pkey,
          m.mb_data^.mbp_rec);
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    k57table_key_get(m.mb_trns^.trTaskId_gg00,
          m.mb_trns^.trState_gg00, colkey);
    m.mb_data^.mbp_buf [ (str_col_no - 1) * cgg_col_fd_size
          + m.mb_data^.mbp_keylen + cgg_rec_key_offset + 1 ] := chr (0);
    SAPDB_PascalMove ('VKB43 ',   2,    
          sizeof (colkey.k), m.mb_data_size,
          @colkey.k, 1,
          @m.mb_data^.mbp_buf,
          (str_col_no - 1) * cgg_col_fd_size + m.mb_data^.mbp_keylen +
          cgg_rec_key_offset + 2,
          sizeof (tgg00_Surrogate), m.mb_trns^.trError_gg00)
    END;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    b02repl_record (m.mb_trns^, m.mb_qual^.mtree, m.mb_data^.mbp_rec);
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    SAPDB_PascalMove ('VKB43 ',   3,    
          sizeof (colkey.k), m.mb_data_size,
          @colkey.k, 1,
          @m.mb_data^.mbp_buf, cgg_rec_key_offset + 1,
          sizeof (tgg00_Surrogate), m.mb_trns^.trError_gg00);
    m.mb_data^.mbp_info.basesyskey.sreclen := SURROGATE_MXGG00 + 4;
    m.mb_data^.mbp_info.basesyskey.skeylen := SURROGATE_MXGG00
    END;
(* PTS XXX TS 2005-09-05 *)
(* Do not write before image for LOB value, because in case of a rollback      *)
(* the LOB will be removed by truncating the primary base table with bd09Reorg *)
(*
      IF  m.mb_trns^.trError_gg00 = e_ok
      THEN
      kb641BeginLoadLong (m.mb_trns^, m.mb_qual^.LOBTREEID);
      *)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k43cnew_lock_column (
            VAR m       : tgg00_MessBlock;
            copy_target : boolean);
 
VAR
      col_lock_pos : integer;
      col_lock     : tgg00_Lock;
      col_key      : tgg00_Lkey;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
col_key.keyLen_gg00     := 0;
col_key.keyVal_gg00     := b01zerokey;
IF  NOT copy_target
THEN
    col_lock_pos := cgg_rec_key_offset + 1
ELSE
    col_lock_pos := cgg_rec_key_offset + LOCK_MXGG04 + 1;
(*ENDIF*) 
SAPDB_PascalMove ('VKB43 ',   4,    
      m.mb_data_size, sizeof (col_lock),
      @m.mb_data^.mbp_buf, col_lock_pos,
      @col_lock, 1, sizeof (col_lock), m.mb_trns^.trError_gg00);
&ifdef TRACE
t01int4   (fs_kb, 'copy_target ', ord (copy_target));
t01p2int4 (fs_kb, 'lockKeyPos  ', col_lock.lockKeyPos_gg00
      ,           'lockKeyLen  ', col_lock.lockKeyLen_gg00);
t01buf1 (fs_kb, m.mb_data^.mbp_4kbuf, cgg_rec_key_offset +
      col_lock.lockKeyPos_gg00, col_lock.lockKeyLen_gg00);
&endif
IF  col_lock.lockMode_gg00 = lckRowExcl_egg00
THEN
    col_lock.lockState_gg00 := [lrsEotExcl_egg00];
(*ENDIF*) 
SAPDB_PascalMove ('VKB43 ',   5,    
      m.mb_data_size, sizeof (col_key.k),
      @m.mb_data^.mbp_buf,
      col_lock.lockKeyPos_gg00 + cgg_rec_key_offset,
      @col_key.k, 1, col_lock.lockKeyLen_gg00, m.mb_trns^.trError_gg00);
col_key.len := col_lock.lockKeyLen_gg00;
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    kb43internal_lock (m, m.mb_data^.mbp_4kbuf,
          col_lock, col_key, col_lock_pos)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb43internal_lock (
            VAR m        : tgg00_MessBlock;
            VAR col_buf  : tsp00_Buf;
            VAR col_lock : tgg00_Lock;
            VAR col_key  : tgg00_Lkey;
            col_lock_pos : integer);
 
VAR
      log_required  : boolean;
      granted_lock  : tgg00_LockReqMode;
      str_mode      : tgg00_LockReqMode;
      dummy_granted : tgg00_LockReqMode;
      str_id        : tgg00_Surrogate;
      dummy_k       : tgg00_Lkey;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
k51row_excl_check (m.mb_trns^, col_lock.lockTabId_gg00, col_key);
log_required := (m.mb_trns^.trError_gg00 = e_rec_not_locked) AND
      (col_lock.lockMode_gg00 = lckRowExcl_egg00);
IF  m.mb_trns^.trError_gg00 = e_rec_not_locked
THEN
    m.mb_trns^.trError_gg00 := e_ok;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    WITH col_lock DO
        k53internal_lock (m.mb_trns^, lockTabId_gg00, col_key,
              [  ], lockMode_gg00, granted_lock);
    (*ENDWITH*) 
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_wait_for_lock_release
THEN
    k53wait (m.mb_trns^, m.mb_type, m.mb_type2);
(*ENDIF*) 
IF  (m.mb_trns^.trError_gg00 = e_ok) AND log_required
THEN
    BEGIN
    str_mode := lckTabExcl_egg00;
    str_id   := m.mb_qual^.mtree.fileTabId_gg00;
    str_id [c_pos_str_id_sign] := chr (c_str_id_sign);
    k53lock (m.mb_trns^, str_id, dummy_k, str_mode, [],
          NOT c_nowait, NOT c_collision_test, dummy_granted);
    IF  m.mb_trns^.trError_gg00 = e_wait_for_lock_release
    THEN
        k53wait (m.mb_trns^, m.mb_type, m.mb_type2)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  (m.mb_trns^.trError_gg00 = e_ok) AND log_required
THEN
    BEGIN
    col_lock.lockMode_gg00  := granted_lock;
    col_buf [col_lock_pos + SURROGATE_MXGG00 + 2] :=
          chr (ord (col_lock.lockMode_gg00))
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k43cnwrite_column (VAR m : tgg00_MessBlock);
 
VAR
      new_file      : boolean;
      dummy_granted : tgg00_LockReqMode;
      eFiletypeSet  : tgg00_ExtendedFiletypeSet;
      save_lq_pos   : tsp00_Int4;
      save_lq_len   : tsp00_Int4;
      input_pos     : tsp00_Int4;
      input_len     : tsp00_Int4;
      rest_len      : tsp00_Int4;
      str_vers      : tsp00_Int4;
      lc_treeid     : tgg00_FileId;
      lcl_lock      : tgg00_Lock;
      dummy_k       : tgg00_Lkey;
 
BEGIN
WITH m, mb_qual^, ml_long_qual DO
    BEGIN
&   ifdef TRACE
    t01p2int4    (fs_kb, 'part1_len   ', mb_qual_len
          ,              'part2_len   ', mb_data_len );
    t01long_qual (fs_kb, 'writ0 l_qual', ml_long_qual);
&   endif
    mb_trns^.trError_gg00 := e_ok;
    save_lq_pos           := lq_pos;
    save_lq_len           := lq_len;
    IF  lq_pos = -1
    THEN
        BEGIN
        new_file    := true;
        lq_pos      := 1;
        save_lq_pos := 1
        END
    ELSE
        new_file := false;
    (*ENDIF*) 
    IF  hsNoLog_egg00 in mtree.fileHandling_gg00
    THEN
        mb_trns^.trError_gg00 := e_not_implemented
    ELSE
        BEGIN
        WITH lcl_lock DO
            BEGIN
            lockTabId_gg00  := mtree.fileTabId_gg00;
            lockTabId_gg00 [c_pos_str_id_sign] := chr (c_str_id_sign);
            lockSite_gg00   := cgg04_nil_site;
            lockMode_gg00   := lckTabExcl_egg00;
            lockState_gg00  := [ ];
            lockKeyLen_gg00 := 0;
            lockKeyPos_gg00 := 0;
            END;
        (*ENDWITH*) 
        IF  save_lq_pos = 1
        THEN
            BEGIN
            (* surrogate locking for putval mode *)
            (* first write                       *)
            k53lock (mb_trns^, lcl_lock.lockTabId_gg00, dummy_k,
                  lcl_lock.lockMode_gg00, [lrsEotExcl_egg00],
                  NOT c_nowait, NOT c_collision_test, dummy_granted);
            IF  mb_trns^.trError_gg00 = e_wait_for_lock_release
            THEN
                k53wait (mb_trns^, mb_type, mb_type2)
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  mb_trns^.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  ((save_lq_pos = 1) AND NOT new_file)
        THEN
            BEGIN
            mb_type2 := mm_trunc;
            lq_pos   := save_lq_pos - 1;
            k43ctrunc_column (m);
&           ifdef TRACE
            t01p2int4 (fs_kb, 'part1_len   ', mb_qual_len
                  ,           'part2_len   ', mb_data_len );
            t01long_qual (fs_kb, 'writ1 l_qual', ml_long_qual);
&           endif
            IF  mb_trns^.trError_gg00 = e_ok
            THEN
                BEGIN
                mb_type2 := mm_write;
                lq_pos   := save_lq_pos
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  mb_trns^.trError_gg00 = e_ok
    THEN
        BEGIN
        mb_type2 := mm_write;
        IF  new_file
        THEN
            BEGIN
            lc_treeid               := mtree;
            lc_treeid.fileType_gg00 := [ftsByteStr_egg00, ftsConcurrent_egg00];
            lc_treeid.fileTfn_gg00  := tfnColumn_egg00;
            lc_treeid.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
            eFiletypeSet            := [];
            k64create_bd_file (mb_trns^, lc_treeid, m_create_file, mm_nil,
                  eFiletypeSet, 0);
            IF  mb_trns^.trError_gg00 = e_ok
            THEN
                BEGIN
                mtree := lc_treeid;
                lq_long_in_file := true
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        IF  mb_trns^.trError_gg00 = e_ok
        THEN
            BEGIN
            rest_len  := lq_len;
            input_pos := lq_data_offset + 1;
            str_vers  := NIL_STR_VERSION_GG00;
            WHILE (mb_trns^.trError_gg00 = e_ok) AND (rest_len > 0) DO
                BEGIN
                IF  rest_len > BUF_MXSP00
                THEN
                    lq_len := BUF_MXSP00
                ELSE
                    lq_len := rest_len;
                (*ENDIF*) 
                input_len := lq_len;
&               ifdef TRACE
                t01p2int4 (fs_kb, 'lq_pos      ', lq_pos
                      ,           'lq_len      ', lq_len);
                t01p2int4 (fs_kb, 'input_pos   ', input_pos
                      ,           'input_len   ', input_len);
                t01int4   (fs_kb, 'rest_len    ', rest_len);
&               endif
                k43ttwrite_string (mb_trns^, lq_lock_tabid, mtree,
                      ml_long_qual, mb_data_size, @mb_data^.mbp_buf,
                      input_pos, input_len, str_vers);
                input_pos := input_pos + input_len;
                rest_len  :=  rest_len - input_len;
                END
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  mb_trns^.trError_gg00 <> e_ok
    THEN
        BEGIN
        mb_type  := m_column;
        mb_type2 := mm_new_write;
        lq_pos   := save_lq_pos
        END
    ELSE
        BEGIN
        mb_type      := m_return_result;
        mb_struct    := mbs_long;
        lq_len       := save_lq_len;
        mcol_pos     := 0;
        mcol_cnt     := 0;
        mfirst_free  := 1;
        mb_qual_len  := MB_PART1_HEAD_MXGG00 + sizeof (ml_long_qual);
        mb_type2     := mm_nil;
        mb_data_len  := 0;
        IF  lq_try_unlock
        THEN
            k51unlock_table (mb_trns^.trTaskId_gg00, mb_trns^.trIndex_gg00,
                  mb_trns^.trState_gg00, lcl_lock)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k43ctrunc_column (VAR m : tgg00_MessBlock);
 
VAR
      no_op        : boolean;
      upgraded     : boolean;
      new_length   : tsp00_Int4;
      str_vers     : tsp00_Int4;
      page_count   : tsp00_Int4;
      prim_tabid   : tgg00_Surrogate;
      aux_buf      : tgg00_Rec;
 
BEGIN
WITH m, mb_qual^, ml_long_qual DO
    BEGIN
    mb_trns^.trError_gg00 := e_ok;
    upgraded        := false;
    no_op           := false;
    new_length      := lq_pos;
    prim_tabid      := lq_lock_tabid;
    IF  hsNoLog_egg00 in mtree.fileHandling_gg00
    THEN
        mb_trns^.trError_gg00 := e_not_implemented
    ELSE
        IF  (lq_data_offset > 0     ) AND
            (mb_data^.mbp_keylen > 0)
        THEN
            k43cnew_lock_column (m, NOT c_copy_target);
        (*ENDIF*) 
    (*ENDIF*) 
    IF  (mb_trns^.trError_gg00 = e_ok) AND (NOT lq_long_in_file)
    THEN
        BEGIN
        k44get_short_col_rec (m, aux_buf, prim_tabid, mtree.fileTabId_gg00);
        IF  mb_trns^.trError_gg00 = e_ok
        THEN
            BEGIN
            lq_long_size := aux_buf.len -
                  cgg_rec_key_offset - aux_buf.keylen;
&           ifdef TRACE
            t01int4 (fs_kb, 'scol len    ', lq_long_size);
&           endif
            IF  new_length > lq_long_size
            THEN
                mb_trns^.trError_gg00 := e_file_limit
            ELSE
                no_op := new_length = lq_long_size;
            (*ENDIF*) 
            IF  (mb_trns^.trError_gg00 = e_ok) AND NOT no_op
            THEN
                BEGIN
                aux_buf.len := cgg_rec_key_offset + aux_buf.keylen +
                      lq_pos;
                lq_long_size := new_length;
                (* PTS 1104430 E.Z. *)
                k44ins_del_upd_short_col_rec (m, aux_buf, prim_tabid,
                      mtree.fileTabId_gg00, m_update_rec, c_use_shc_buf);
                END
            (*ENDIF*) 
            END
        ELSE
            IF  mb_trns^.trError_gg00 = e_key_not_found
            THEN
                k45test_short_col_upgraded (m, upgraded);
            (*ENDIF*) 
        (*ENDIF*) 
        END;
&   ifdef TRACE
    (*ENDIF*) 
    t01int4 (fs_kb, 'upgraded    ', ord (upgraded));
&   endif
    IF  (upgraded OR lq_long_in_file) AND (mb_trns^.trError_gg00 = e_ok)
    THEN
        BEGIN
        IF  mb_trns^.trError_gg00 = e_ok
        THEN
            b05length_bytestr (mb_trns^, mtree, lq_long_size, page_count, str_vers);
        (*ENDIF*) 
        IF  mb_trns^.trError_gg00 = e_ok
        THEN
            IF  new_length > lq_long_size
            THEN
                mb_trns^.trError_gg00 := e_file_limit
            ELSE
                no_op := new_length = lq_long_size;
            (*ENDIF*) 
        (*ENDIF*) 
        IF  (mb_trns^.trError_gg00 = e_ok) AND NOT no_op
            AND
            gg06IsNilTrans (mb_trns^.trWriteTransId_gg00)
        THEN
            k50new_write_trans (mb_trns^);                           (* PTS 1108234 JA 2000-12-12 *)
        (*ENDIF*) 
        IF  (mb_trns^.trError_gg00 = e_ok) AND NOT no_op
        THEN
            BEGIN
            kb431TruncateBlob (mb_trns^, prim_tabid, mtree, str_vers, lq_long_size, new_length);
            IF  mb_trns^.trError_gg00 = e_ok
            THEN
                lq_long_size := new_length
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (mb_trns^.trError_gg00 <> e_ok)
    THEN
        BEGIN
        mb_type     := m_return_error;
        mb_type2    := mm_nil;
        mb_qual_len := 0;
        mb_data_len := 0;
        END;
    (*ENDIF*) 
    IF  (mb_trns^.trError_gg00 = e_ok) AND (NOT lq_trunc_req)
    THEN
        BEGIN
        IF  upgraded
        THEN
            lq_long_in_file := true;
        (*ENDIF*) 
        mb_type     := m_return_result;
        mb_struct   := mbs_long;
        mcol_pos    := 0;
        mcol_cnt    := 0;
        mfirst_free := 1;
        mb_qual_len := MB_PART1_HEAD_MXGG00 + sizeof (ml_long_qual);
        mb_data_len := 0;
        mb_type2    := mm_nil
        END;
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k43cwrite_column (VAR m : tgg00_MessBlock);
 
VAR
      upgraded      : boolean;
      lcm_result    : tsp00_LcompResult;
      dummy_granted : tgg00_LockReqMode;
      eFiletypeSet  : tgg00_ExtendedFiletypeSet;
      save_lq_pos   : tsp00_Int4;
      input_pos     : tsp00_Int4;
      input_len     : tsp00_Int4;
      rest_len      : tsp00_Int4;
      save_lq_len   : tsp00_Int4;
      str_vers      : tsp00_Int4;
      prim_tabid    : tgg00_Surrogate;
      lcl_lock      : tgg00_Lock;
      dummy_k       : tgg00_Lkey;
      shc_buf       : tgg00_Rec;
 
BEGIN
WITH m, mb_qual^, ml_long_qual DO
    BEGIN
&   ifdef TRACE
    t01p2int4    (fs_kb, 'part1_len   ', mb_qual_len
          ,              'part2_len   ', mb_data_len );
    t01long_qual (fs_kb, 'writ0 l_qual', ml_long_qual);
&   endif
    mb_trns^.trError_gg00 := e_ok;
    upgraded    := false;
    save_lq_pos := lq_pos;
    save_lq_len := lq_len;
    IF  hsNoLog_egg00 in mtree.fileHandling_gg00
    THEN
        mb_trns^.trError_gg00 := e_not_implemented
    ELSE
        IF  (lq_data_offset > 0     ) AND
            (mb_data^.mbp_keylen > 0)
        THEN
            k43cnew_lock_column (m, NOT c_copy_target)
        ELSE
            IF  lq_data_offset = 0
            THEN
                BEGIN
                WITH lcl_lock DO
                    BEGIN
                    lockTabId_gg00  := mtree.fileTabId_gg00;
                    lockTabId_gg00 [c_pos_str_id_sign] := chr (c_str_id_sign);
                    lockSite_gg00   := cgg04_nil_site;
                    lockMode_gg00   := lckTabExcl_egg00;
                    lockState_gg00  := [ ];
                    lockKeyLen_gg00 := 0;
                    lockKeyPos_gg00 := 0
                    END;
                (*ENDWITH*) 
                IF  (save_lq_pos = 1) OR (save_lq_pos = cgg_eo_bytestr)
                THEN
                    BEGIN
                    (* surrogate locking for putval mode *)
                    (* first write                       *)
                    k53lock (mb_trns^, lcl_lock.lockTabId_gg00, dummy_k,
                          lcl_lock.lockMode_gg00, [], NOT c_nowait,
                          NOT c_collision_test, dummy_granted);
                    IF  mb_trns^.trError_gg00 = e_wait_for_lock_release
                    THEN
                        k53wait (mb_trns^, mb_type, mb_type2)
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    IF  mb_trns^.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  lq_trunc_req AND (lq_data_offset = 0)
        THEN
            lq_try_unlock := true;
        (*ENDIF*) 
        IF  lq_trunc_req AND (save_lq_pos <> cgg_eo_bytestr) AND NOT lq_first_insert
        THEN
            BEGIN
            mb_type2 := mm_trunc;
            lq_pos   := save_lq_pos - 1;
            k43ctrunc_column (m);
&           ifdef TRACE
            t01p2int4 (fs_kb, 'part1_len   ', mb_qual_len
                  ,           'part2_len   ', mb_data_len );
            t01long_qual (fs_kb, 'writ1 l_qual', ml_long_qual);
&           endif
            IF  mb_trns^.trError_gg00 = e_ok
            THEN
                BEGIN
                mb_type2 := mm_write;
                lq_pos   := save_lq_pos
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  (mb_trns^.trError_gg00 = e_ok) AND ((lq_len > 0) OR (lq_first_insert))
    THEN
        BEGIN
        prim_tabid := lq_lock_tabid;
        IF  NOT lq_long_in_file
        THEN
            BEGIN
            IF  lq_first_insert
            THEN
                BEGIN
                IF  (lq_len > MAX_SHORTCOL_LEN_KB00)
                THEN
                    BEGIN
                    mtree.fileType_gg00 := [ ftsByteStr_egg00, ftsConcurrent_egg00 ];
                    mtree.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
                    mtree.fileTfn_gg00              := tfnColumn_egg00;
                    eFiletypeSet                    := [];
                    k64create_bd_file (mb_trns^, mtree, m_create_file, mm_nil,
                          eFiletypeSet, 0);
                    upgraded := true;
                    END
                ELSE
                    BEGIN
                    shc_buf.recKeyLen_gg00 := cgg04_str_col_entry_size;
                    shc_buf.recLen_gg00 := cgg_rec_key_offset + shc_buf.recKeyLen_gg00 + lq_len;
                    shc_buf.recVarcolOffset_gg00 := 0;
                    shc_buf.recVarcolCnt_gg00 := 0;
                    SAPDB_PascalMove ('VKB43 ',   6,    
                          cgg04_str_col_entry_size, sizeof(shc_buf.recBuf_gg00),
                          @mtree.fileTabId_gg00, 1,
                          @shc_buf.recBuf_gg00, cgg_rec_key_offset + 1,
                          cgg04_str_col_entry_size,
                          m.mb_trns^.trError_gg00);
                    IF  mb_trns^.trError_gg00 = e_ok
                    THEN
                        SAPDB_PascalMove ('VKB43 ',   7,    
                              mb_data_size, sizeof (shc_buf.recBuf_gg00),
                              @mb_data^.mbp_buf, 1,
                              @shc_buf.recBuf_gg00, cgg_rec_key_offset + shc_buf.recKeyLen_gg00 + 1,
                              lq_len,
                              m.mb_trns^.trError_gg00);
                    (*ENDIF*) 
                    IF  mb_trns^.trError_gg00 = e_ok
                    THEN
                        k44ins_del_upd_short_col_rec (m,
                              shc_buf, prim_tabid, mtree.fileTabId_gg00,
                              m_insert, c_use_shc_buf);
                    (*ENDIF*) 
                    IF  mb_trns^.trError_gg00 = e_ok
                    THEN
                        lq_pos := lq_pos + lq_len;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                k44get_short_col_rec (m, shc_buf, prim_tabid, mtree.fileTabId_gg00);
                IF  mb_trns^.trError_gg00 = e_ok
                THEN
                    BEGIN
                    lq_long_size := shc_buf.len - cgg_rec_key_offset -
                          shc_buf.keylen;
                    IF  lq_pos = cgg_eo_bytestr
                    THEN
                        lq_pos := lq_long_size + 1;
                    (*ENDIF*) 
                    IF  lq_pos > lq_long_size + 1
                    THEN
                        mb_trns^.trError_gg00 := e_file_limit
                    ELSE
                        IF  (lq_pos + lq_len - 1) > MAX_SHORTCOL_LEN_KB00
                        THEN
                            BEGIN
                            k44upgrade_to_bstr_file (m, prim_tabid, shc_buf,
                                  c_use_shc_buf);
                            IF  mb_trns^.trError_gg00 = e_ok
                            THEN
                                upgraded := true
                            (*ENDIF*) 
                            END
                        ELSE
                            BEGIN
                            lcm_result := l_less;
                            IF  shc_buf.len >=
                                (cgg_rec_key_offset + shc_buf.keylen +
                                lq_pos + lq_len - 1)
                            THEN
                                s30cmp (mb_data^.mbp_buf, lq_data_offset +1,
                                      lq_len, shc_buf.buf,
                                      cgg_rec_key_offset + shc_buf.keylen
                                      + lq_pos,
                                      lq_len, lcm_result);
                            (*ENDIF*) 
                            IF  lcm_result <> l_equal
                            THEN
                                BEGIN
                                SAPDB_PascalMove ('VKB43 ',   8,    
                                      mb_data_size, sizeof (shc_buf.buf),
                                      @mb_data^.mbp_buf, lq_data_offset + 1,
                                      @shc_buf.buf, cgg_rec_key_offset +
                                      shc_buf.keylen + lq_pos, lq_len,
                                      m.mb_trns^.trError_gg00);
                                IF  shc_buf.len < (cgg_rec_key_offset +
                                    shc_buf.keylen + lq_pos + lq_len - 1)
                                THEN
                                    BEGIN
                                    shc_buf.len := cgg_rec_key_offset +
                                          shc_buf.keylen + lq_pos
                                          + lq_len - 1;
                                    (* PTS 1104430 E.Z. *)
                                    END;
                                (*ENDIF*) 
                                IF  mb_trns^.trError_gg00 = e_ok
                                THEN
                                    k44ins_del_upd_short_col_rec (m,
                                          shc_buf, prim_tabid, mtree.fileTabId_gg00,
                                          m_update_rec, c_use_shc_buf)
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            IF  mb_trns^.trError_gg00 = e_ok
                            THEN
                                lq_pos := lq_pos + lq_len;
                            (*ENDIF*) 
                            END
                        (*ENDIF*) 
                    (*ENDIF*) 
                    END
                ELSE
                    IF  mb_trns^.trError_gg00 = e_key_not_found
                    THEN
                        k45test_short_col_upgraded (m, upgraded)
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
&       ifdef TRACE
        (*ENDIF*) 
        t01int4 (fs_kb, 'upgraded    ', ord (upgraded));
&       endif
        IF  upgraded OR lq_long_in_file
        THEN
            BEGIN
            lq_long_in_file := true;
            IF  mb_trns^.trError_gg00 = e_ok
            THEN
                BEGIN
                rest_len  := lq_len;
                input_pos := lq_data_offset + 1;
                str_vers  := NIL_STR_VERSION_GG00;
                WHILE (mb_trns^.trError_gg00 = e_ok) AND (rest_len > 0) DO
                    BEGIN
                    IF  rest_len > BUF_MXSP00
                    THEN
                        lq_len := BUF_MXSP00
                    ELSE
                        lq_len := rest_len;
                    (*ENDIF*) 
                    input_len := lq_len;
&                   ifdef TRACE
                    t01p2int4 (fs_kb, 'lq_pos      ', lq_pos
                          ,           'lq_len      ', lq_len);
                    t01p2int4 (fs_kb, 'input_pos   ', input_pos
                          ,           'input_len   ', input_len);
                    t01int4   (fs_kb, 'rest_len    ', rest_len);
&                   endif
                    k43ttwrite_string (mb_trns^, prim_tabid, mtree,
                          ml_long_qual, mb_data_size, @mb_data^.mbp_buf,
                          input_pos, input_len, str_vers);
                    input_pos := input_pos + input_len;
                    rest_len  :=  rest_len - input_len;
                    END
                (*ENDWHILE*) 
                END
            (*ENDIF*) 
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  mb_trns^.trError_gg00 <> e_ok
    THEN
        BEGIN
        mb_type  := m_column;
        mb_type2 := mm_write;
        lq_pos   := save_lq_pos
        END
    ELSE
        BEGIN
        mb_type      := m_return_result;
        mb_struct    := mbs_long;
        lq_len       := save_lq_len;
        mcol_pos     := 0;
        mcol_cnt     := 0;
        mfirst_free  := 1;
        mb_qual_len  := MB_PART1_HEAD_MXGG00 + sizeof (ml_long_qual);
        mb_type2     := mm_nil;
        mb_data_len  := 0;
        IF  lq_try_unlock
        THEN
            k51unlock_table (mb_trns^.trTaskId_gg00, mb_trns^.trIndex_gg00,
                  mb_trns^.trState_gg00, lcl_lock)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*         local opns           *)
(*------------------------------*) 
 
PROCEDURE
      k43ttwrite_string (
            VAR t              : tgg00_TransContext;
            VAR prim_tabid     : tgg00_Surrogate;
            VAR curr_file      : tgg00_FileId;
            VAR curr_long_qual : tgg00_LongQual;
            buf_size           : tsp00_Int4;
            buf_addr           : tsp00_MoveObjPtr;
            inpos              : tsp00_Int4;
            inlen              : tsp00_Int4;
            VAR str_vers       : tsp00_Int4);
 
VAR
      differences    : boolean;
      save_pos       : tsp00_Int4;
      save_len       : tsp00_Int4;
      frontpos       : tsp00_Int4;
      rearpos        : tsp00_Int4;
      old_string_len : tsp00_Int4;
      lwb            : tsp00_Int4;
      upb            : tsp00_Int4;
      page_count     : tsp00_Int4;
      old_buf_addr   : tsp00_MoveObjPtr;
      old_buf        : tsp00_Buf;
 
BEGIN
WITH curr_long_qual DO
    BEGIN
    t.trError_gg00 := e_ok;
    old_buf_addr   := @old_buf;
    frontpos       := 1;
    rearpos        := 0;
    lwb            := 0;
    upb            := 0;
    differences    := true;
    old_string_len := 0;
    IF  hsNoLog_egg00 in curr_file.fileHandling_gg00
    THEN
        t.trError_gg00 := e_not_implemented
    ELSE
        BEGIN
        IF  (lq_long_size = 0) AND (lq_long_in_file)
        THEN
            b05length_bytestr (t, curr_file, lq_long_size, page_count, str_vers)
        ELSE
            IF  str_vers = NIL_STR_VERSION_GG00
            THEN
                b05get_str_version  (t, curr_file, str_vers);
&           ifdef TRACE
            (*ENDIF*) 
        (*ENDIF*) 
        t01p2int4 (fs_kb, 'hhhlong_size', lq_long_size
              ,           'str_version ', str_vers);
&       endif
        IF  lq_pos > lq_long_size + 1
        THEN
            t.trError_gg00 := e_file_limit;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  lq_pos = cgg_eo_bytestr
        THEN
            BEGIN
            lwb    := lq_long_size + 1;
            lq_pos := lwb
            END
        ELSE
            lwb := lq_pos;
        (*ENDIF*) 
        upb := lwb + inlen - 1;
&       ifdef TRACE
        t01p2int4 (fs_kb, 'lwb         ', lwb
              ,           'upb         ', upb);
&       endif
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  lq_long_size > upb
        THEN
            old_string_len := inlen
        ELSE
            IF  lwb <= lq_long_size
            THEN
                old_string_len := (lq_long_size - lwb) + 1
            ELSE
                IF  (lq_pos = cgg_eo_bytestr)
                    OR (lq_long_size = lwb - 1)
                THEN
                    old_string_len := 0
                ELSE
                    t.trError_gg00 := e_file_limit
                (*ENDIF*) 
            (*ENDIF*) 
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    save_pos := lq_pos;
    save_len := lq_len;
    IF  (t.trError_gg00 = e_ok)
    THEN
        IF  old_string_len > 0
        THEN
            BEGIN (* -UJ- hier mal gucken, wie das mit dem Lesen aussieht....wg. INSERT --> brauch nix lesen!*)
            bd05ReadLob (t, curr_file, lwb, old_string_len,
                  sizeof (old_buf), @old_buf, 1);
            (*==================update optimzer=======================*)
            IF  (t.trError_gg00 = e_ok)
            THEN
                BEGIN
                kb43cmpct (sizeof (old_buf), buf_size,
                      old_buf_addr^, 1, old_string_len,
                      buf_addr^, inpos, inlen, frontpos, rearpos);
                IF  (frontpos = 0) AND (rearpos = 0)
                THEN
                    differences := false
                ELSE
                    BEGIN
                    inpos  := (inpos   + frontpos) - 1;
                    inlen  := (rearpos - frontpos) + 1;
                    lq_pos := (lq_pos + frontpos) - 1;
                    lq_len := (rearpos - frontpos) + 1;
                    IF  old_string_len > rearpos
                    THEN
                        old_string_len := (rearpos - frontpos) + 1
                    ELSE
                        old_string_len :=
                              (old_string_len - frontpos) + 1
                    (*ENDIF*) 
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
&       ifdef TRACE
        (*ENDIF*) 
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        t01moveobj (fs_kb, old_buf_addr^, 1, old_string_len);
        t01moveobj (fs_kb, buf_addr^, inpos, inpos + inlen - 1);
        t01p2int4  (fs_kb, 'frontpos    ', frontpos
              ,            'rearpos     ', rearpos);
        t01p2int4  (fs_kb, 'inpos       ', inpos
              ,            'inlen       ', inlen);
        t01p2int4  (fs_kb, 'oldstringlen', old_string_len
              ,            'lq_pos      ', lq_pos);
        t01p2int4  (fs_kb, 'lq_long_size', lq_long_size
              ,            'lq_len      ', lq_len);
        END;
&   endif
    (*ENDIF*) 
    IF  (t.trError_gg00 = e_ok) AND differences
        AND
        gg06IsNilTrans (t.trWriteTransId_gg00)
    THEN
        k50new_write_trans (t);                                      (* PTS 1108234 JA 2000-12-12 *)
    (*ENDIF*) 
    ;
    (*=================== ACTION======================*)
    IF  (t.trError_gg00 = e_ok) AND differences
    THEN
        kb431UpdateBlob (t, prim_tabid, curr_file, str_vers,  lq_long_size,
              lq_pos-1, buf_addr, inpos-1, inlen);
    (*ENDIF*) 
    lq_pos := save_pos;
    lq_len := save_len;
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        lq_pos := lq_pos + lq_len;
        IF  lq_pos > lq_long_size + 1
        THEN
            lq_long_size := lq_pos - 1
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
(*ENDWITH*) 
END;
 
(* PTS 1120899 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      kb43shrt_shrt_copy (
            VAR mtrans          : tgg00_TransContextPtr;
            VAR mheader         : tgg00_MessBufHeader;
            VAR dst_tree        : tgg00_FileId;
            VAR dst_surr        : tgg00_Surrogate;
            VAR dst_tab_id      : tgg00_Surrogate;
            VAR rec_buf         : tgg00_Rec;
            doUpdateIfDuplicate : boolean);
      (* PTS 1105795 M.Ki. *)
 
BEGIN
SAPDB_PascalMove ('VKB43 ',   9,    
      SURROGATE_MXGG00, sizeof(rec_buf.buf),
      @dst_surr, 1,
      @rec_buf.buf, cgg_rec_key_offset + 1,
      sizeof (tgg00_Surrogate), mtrans^.trError_gg00);
k44insdelupdshort_col_rec (mtrans, mheader, dst_tree,
      rec_buf, dst_tab_id, dst_surr, m_insert, c_use_shc_buf);
IF  (mtrans^.trError_gg00 = e_duplicate_key) AND doUpdateIfDuplicate
THEN
    BEGIN
    mtrans^.trError_gg00 := e_ok;
    k44insdelupdshort_col_rec (mtrans, mheader, dst_tree,
          rec_buf, dst_tab_id, dst_surr, m_update_rec, c_use_shc_buf);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb43long_long_copy (
            VAR mtrans   : tgg00_TransContextPtr;
            VAR dest_tree : tgg00_FileId;
            VAR src_id   : tgg00_FileId;
            VAR dst_id   : tgg00_FileId;
            src_file_len : tsp00_Int4);
      (* PTS 1105795 M.Ki. *)
 
VAR
      eFiletypeSet  : tgg00_ExtendedFiletypeSet;
      dst_file_len  : tsp00_Int4;
      old_dst_vers  : tsp00_Int4;
      lc_treeid     : tgg00_FileId;
 
BEGIN
mtrans^.trError_gg00    := e_ok;
(* create new COLUMN file for dst table: *)
lc_treeid               := dst_id;
lc_treeid.fileType_gg00 := [ ftsByteStr_egg00, ftsConcurrent_egg00 ];
lc_treeid.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
lc_treeid.fileTfn_gg00  := tfnColumn_egg00;
old_dst_vers            := NIL_STR_VERSION_GG00;
eFiletypeSet            := [];
IF  (mtrans^.trError_gg00 = e_ok)
THEN
    k64create_bd_file (mtrans^, lc_treeid, m_create_file, mm_nil,
          eFiletypeSet, 0);
(*ENDIF*) 
old_dst_vers := -MAX_INT4_SP00 + 1;
dst_file_len := 0;
IF  (mtrans^.trError_gg00 = e_ok) AND (src_file_len > 0) (* PTS 1120599 M.Ki *)
THEN
    kb431CopyBlob (mtrans^, dest_tree.fileTabId_gg00, src_id,
          lc_treeid, old_dst_vers, dst_file_len,
          0, 0, src_file_len);
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb43long_shrt_copy (
            VAR mtrans   : tgg00_TransContextPtr;
            VAR mheader  : tgg00_MessBufHeader;
            VAR src_id   : tgg00_FileId;
            VAR dst_surr : tgg00_Surrogate;
            VAR dst_tab_id   : tgg00_Surrogate;
            src_file_len : tsp00_Int4);
      (* PTS 1105795 M.Ki. *)
 
VAR
      read_len      : tsp00_Int4;
      dst_shc_buf   : tgg00_Rec;
 
BEGIN
(* read record *)
read_len := src_file_len;
IF  read_len > 0 (* PTS 1120600 M.Ki *)
THEN
    bd05ReadLob (mtrans^, src_id,
          1, read_len,
          sizeof(dst_shc_buf.recBody_gg00), @dst_shc_buf.recBody_gg00,
          SURROGATE_MXGG00 + 1);
(* build proper record and put dst's surrogate in record: *)
(*ENDIF*) 
dst_shc_buf.recLen_gg00    := cgg_rec_key_offset + SURROGATE_MXGG00 + read_len;
dst_shc_buf.recKeyLen_gg00 := SURROGATE_MXGG00;
SAPDB_PascalMove ('VKB43 ',  10,    
      SURROGATE_MXGG00, sizeof(dst_shc_buf.buf),
      @dst_surr, 1,
      @dst_shc_buf.buf, cgg_rec_key_offset + 1,
      sizeof (tgg00_Surrogate), mtrans^.trError_gg00);
IF  mtrans^.trError_gg00 = e_ok
THEN
    BEGIN
    k44insdelupdshort_col_rec (mtrans, mheader, src_id,
          dst_shc_buf, dst_tab_id,
          dst_surr, m_insert,
          c_use_shc_buf);
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k43CopyLongColumn (
            mtrans           : tgg00_TransContextPtr;
            VAR mheader      : tgg00_MessBufHeader;
            VAR sourceTabid  : tgg00_Surrogate;
            VAR sourceLongId : tgg00_Surrogate;
            VAR destTabid    : tgg00_Surrogate;
            VAR destLongId   : tgg00_Surrogate;
            createFile       : boolean);
 
VAR
      eFiletypeSet  : tgg00_ExtendedFiletypeSet;
      sourceBytes   : tsp00_Int4;
      destBytes     : tsp00_Int4;
      pageCount     : tsp00_Int4;
      sourceVersion : tsp00_Int4;
      old_dst_vers  : tsp00_Int4;
      sourceTree    : tgg00_FileId;
      destTree      : tgg00_FileId;
      recBuf        : tgg00_Rec;
 
BEGIN
&ifdef TRACE
t01surrogate (bi, 'sourceTabid ', sourceTabid);
t01surrogate (bi, 'sourceLongId', sourceLongId);
t01surrogate (bi, 'destTabid   ', destTabid);
t01surrogate (bi, 'destLongId  ', destLongId);
&endif
sourceTree := b01niltree_id;
g04short_col_tree_build (sourceTabid, sourceTree, mtrans^.trError_gg00);
sourceTree.fileBdUse_gg00 := [];
IF  mtrans^.trError_gg00 = e_ok
THEN
    k44get_shrt_col_rec (mtrans, sourceTree, recBuf,
          sourceTabid, sourceLongId);
(*ENDIF*) 
IF  mtrans^.trError_gg00 = e_ok
THEN
    BEGIN
    destTree := b01niltree_id;
    g04short_col_tree_build (destTabid, destTree, mtrans^.trError_gg00);
    destTree.fileBdUse_gg00 := [];
    END;
(*ENDIF*) 
IF  mtrans^.trError_gg00 = e_ok
THEN
    kb43shrt_shrt_copy (mtrans, mheader, destTree, destLongId,
          destTabid, recBuf, (* PTS 1129416 *) c_doUpdateIfDuplicate)
ELSE
    IF  mtrans^.trError_gg00 = e_key_not_found
    THEN
        BEGIN
        sourceTree.fileTabId_gg00 := sourceLongId;
        sourceTree.fileRoot_gg00  := NIL_PAGE_NO_GG00;
        sourceTree.fileType_gg00  := [ftsByteStr_egg00, ftsConcurrent_egg00];
        sourceTree.fileTfn_gg00   := tfnColumn_egg00;
        sourceTree.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
        b05length_bytestr (mtrans^, sourceTree, sourceBytes, pageCount, sourceVersion);
        IF  mtrans^.trError_gg00 = e_ok
        THEN
            BEGIN (* long -> long file *)
            IF  NOT createFile
            THEN
                BEGIN (* does short entry exist ? *)
                destTree := b01niltree_id;
                g04short_col_tree_build (destTabid, destTree, mtrans^.trError_gg00);
                destTree.fileBdUse_gg00 := [];
                k44get_shrt_col_rec (mtrans, destTree, recBuf,
                      destTabid, destLongId);
                IF  mtrans^.trError_gg00 = e_ok
                THEN
                    BEGIN (* yes, delete it *)
                    createFile := true;
                    k44insdelupdshort_col_rec (mtrans, mheader,
                          destTree, recBuf, destTabid, destLongId, m_delete, false);
                    END
                ELSE
                    IF  mtrans^.trError_gg00 = e_key_not_found
                    THEN
                        mtrans^.trError_gg00 := e_ok;
                    (*ENDIF*) 
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  mtrans^.trError_gg00 = e_ok
            THEN
                BEGIN
                destTree                := b01niltree_id;
                destTree.fileTabId_gg00 := destLongId;
                destTree.fileRoot_gg00  := NIL_PAGE_NO_GG00;
                destTree.fileType_gg00  := [ftsByteStr_egg00, ftsConcurrent_egg00];
                destTree.fileTfn_gg00   := tfnColumn_egg00;
                destTree.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
                eFiletypeSet            := [];
                IF  createFile
                THEN
                    k64create_bd_file (mtrans^, destTree, m_create_file,
                          mm_nil, eFiletypeSet, 0);
                (*ENDIF*) 
                old_dst_vers := -MAX_INT4_SP00 + 1;
                destBytes    := 0;
                IF  (mtrans^.trError_gg00 = e_ok) AND (sourceBytes > 0)
                THEN
                    kb431CopyBlob (mtrans^, destTabid, sourceTree, destTree,
                          old_dst_vers, destBytes, 0, 0, sourceBytes);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k43_ins_copy_column (
            VAR mtrans            : tgg00_TransContextPtr;
            VAR mheader           : tgg00_MessBufHeader;
            VAR src_tree          : tgg00_FileId;
            VAR dst_tree          : tgg00_FileId;
            VAR src_tab_id        : tgg00_Surrogate;
            VAR src_surr          : tgg00_Surrogate;
            VAR dst_surr          : tgg00_Surrogate;
            dst_has_shrt_col_file : boolean;
            VAR shrt_col_rec_ptr  : tgg00_RecPtr;
            use_shrt_col_rec      : boolean);
      (* PTS 1105795 M.Ki. *)
 
VAR
      e                 : tgg00_BasisError;
      dst_tab_id        : tgg00_Surrogate;
      src_lock_surr     : tgg00_Surrogate;
      src_file_len      : tsp00_Int4;
      src_vers          : tsp00_Int4;
      page_count        : tsp00_Int4;
      src_id            : tgg00_FileId;
      dst_id            : tgg00_FileId;
      dst_lkey          : tgg00_Lkey;
      wanted_lock_state : tgg00_LockReqState;
      dummy_granted     : tgg00_LockReqMode;
      src_shc_buf       : tgg00_Rec;
 
BEGIN
mtrans^.trError_gg00  := e_ok;
src_id                := src_tree;
src_id.fileName_gg00  := cgg_zero_fn;
src_id.fileBdUse_gg00 := [];
dst_id                := dst_tree;
dst_tab_id            := dst_surr;
&ifdef TRACE
t01surrogate (fs_kb, 'source_id   ', src_surr);
t01surrogate (fs_kb, 'src_id surr ', src_id.fileTabId_gg00);
t01surrogate (fs_kb, 'source_tab_i', src_tab_id);
t01int4      (fs_kb, 'has_shrt_col', ord(dst_has_shrt_col_file));
t01treeid    (fs_kb, 'src_tree    ', src_tree);
t01treeid    (fs_kb, 'dst_tree    ', dst_tree);
&endif
IF  mtrans^.trError_gg00 = e_ok
THEN
    BEGIN
    (* get new surrogate for destination *)
    k57table_key_get(mtrans^.trTaskId_gg00,
          mtrans^.trState_gg00, dst_lkey);
    SAPDB_PascalMove ('VKB43 ',  11,    
          sizeof (dst_lkey.k), sizeof(dst_surr),
          @dst_lkey.k, 1,
          @dst_surr, 1,
          sizeof (tgg00_Surrogate), mtrans^.trError_gg00);
&   ifdef TRACE
    t01surrogate (fs_kb, 'dst_surr    ', dst_surr);
    t01surrogate (fs_kb, 'dst_tab_id  ', dst_tab_id);
&   endif
    IF  gg06IsNilTrans (mtrans^.trWriteTransId_gg00)
    THEN
        k50new_write_trans (mtrans^);
    (*ENDIF*) 
    wanted_lock_state  := [lrsTemp_egg00];
    src_lock_surr      := src_surr;
    src_lock_surr[ 3 ] := chr (128);
    IF  NOT use_shrt_col_rec
    THEN
        BEGIN
        k53lock (mtrans^, src_lock_surr, dst_lkey, lckTabShare_egg00,
              wanted_lock_state, NOT c_nowait, NOT c_collision_test,
              dummy_granted);
        g04short_col_tree_build (src_tab_id, src_id, mtrans^.trError_gg00);
        IF  mtrans^.trError_gg00 = e_ok
        THEN
            k44get_shrt_col_rec (mtrans, src_id, src_shc_buf, src_tab_id,
                  src_surr);
        (*ENDIF*) 
        END
    ELSE
        src_shc_buf := shrt_col_rec_ptr^;
    (*ENDIF*) 
    IF  mtrans^.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  NOT use_shrt_col_rec
        THEN
            k53temp_unlock (mtrans^, src_lock_surr, dst_lkey,
                  lckTabShare_egg00);
        (*ENDIF*) 
        IF  dst_has_shrt_col_file
        THEN (* short col -> short col *)
            (* PTS 1120891 E.Z. *)
            kb43shrt_shrt_copy (mtrans, mheader, dst_id,
                  dst_surr, dst_tab_id, src_shc_buf, (* PTS 1129416 *) NOT c_doUpdateIfDuplicate)
        ELSE (* short col -> long file *)
            BEGIN (* put new surrogate in dst_id *)
            SAPDB_PascalMove ('VKB43 ',  12,    
                  SURROGATE_MXGG00, sizeof(src_shc_buf.buf),
                  @dst_surr, 1,
                  @dst_id.fileTabId_gg00, 1,
                  sizeof (tgg00_Surrogate), mtrans^.trError_gg00);
            k44copy_move_shrt_to_bstr_file (
                  mtrans, mheader, src_surr, dst_tab_id, src_id,
                  dst_id, src_shc_buf, c_use_shc_buf, NOT c_move_target);
            END;
        (*ENDIF*) 
        END
    ELSE
        IF  (mtrans^.trError_gg00 = e_file_not_found) OR
            (mtrans^.trError_gg00 = e_key_not_found)
        THEN
            BEGIN (* source is real LONG file *)
            mtrans^.trError_gg00 := e_ok;
            (* build proper src_id for COLUMN file; get source file length *)
            src_id                := src_tree;
            src_id.fileName_gg00  := cgg_zero_fn;
            SAPDB_PascalMove ('VKB43 ',  13,    
                  SURROGATE_MXGG00, sizeof(src_shc_buf.buf),
                  @src_surr, 1,
                  @src_id.fileTabId_gg00, 1,
                  SURROGATE_MXGG00, mtrans^.trError_gg00);
            src_id.fileRoot_gg00  := NIL_PAGE_NO_GG00;
            src_id.fileType_gg00  := [ftsByteStr_egg00, ftsConcurrent_egg00];
            src_id.fileTfn_gg00   := tfnColumn_egg00;
            src_id.fileVersion_gg00.ci2_gg00 := cgg_dummy_file_version;
&           ifdef TRACE
            t01surrogate (fs_kb, 'src_id surr ', src_id.fileTabId_gg00);
&           endif
            b05length_bytestr (mtrans^, src_id, src_file_len, page_count,
                  src_vers);
            IF  mtrans^.trError_gg00 = e_ok
            THEN
                IF  NOT dst_has_shrt_col_file OR
                    (src_file_len > MAX_SHORTCOL_LEN_KB00)
                THEN
                    BEGIN (* long file -> long file *)
                    SAPDB_PascalMove ('VKB43 ',  14,    
                          sizeof (dst_lkey.k), sizeof(dst_surr),
                          @dst_lkey.k, 1,
                          @dst_id.fileTabId_gg00, 1,
                          sizeof (tgg00_Surrogate), mtrans^.trError_gg00);
                    kb43long_long_copy (mtrans, dst_tree, src_id, dst_id,
                          src_file_len);
                    END
                ELSE (* value fits into dst's short col file *)
                    (* long file -> short col *)
                    kb43long_shrt_copy (mtrans, mheader,
                          src_id, dst_surr, dst_tab_id, src_file_len);
                (*ENDIF*) 
            (*ENDIF*) 
            IF  NOT use_shrt_col_rec
            THEN
                BEGIN
                e := mtrans^.trError_gg00;
                k53temp_unlock (mtrans^, src_lock_surr, dst_lkey,
                      lckTabShare_egg00);
                mtrans^.trError_gg00 := e;
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
