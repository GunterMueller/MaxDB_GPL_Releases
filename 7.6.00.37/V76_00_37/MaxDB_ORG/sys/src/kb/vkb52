/****************************************************************************
  module      : vkb52
  author      : JuergenA
  responsible : UweH
  special area: SQL locks
  see also    :
  description : all show commands are implemented here
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2001-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
*****************************************************************************/
 
.tt 1 $SAP$LiveCache$VKB52$
.tt 3 $UweH$KB_show_lock$2001-05-02$
 
Module  : KB_show_lock
 
Define  :
 
        PROCEDURE
              k52acc_objcoll_entry (
                    VAR ObjCollGlob     : tkb05_ObjCollGlob;
                    EntryIndex          : tgg00_TransIndex;
                    VAR ObjCollEntryPtr : tkb05_ObjCollEntryPtr);
 
        PROCEDURE
              k52acc_objreq_entry (
                    VAR ObjCollGlob    : tkb05_ObjCollGlob;
                    TransIndex         : tgg00_TransIndex;
                    VAR ObjReqEntryPtr : tkb05_ObjReqEntryPtr);
 
        PROCEDURE
              k52acc_trans_entry (
                    TransIndex        : tgg00_TransIndex;
                    VAR TransEntryPtr : tkb05_TransEntryPtr);
 
        PROCEDURE
              k52begexcl_lockstate (
                    TaskId                 : tsp00_TaskId;
                    VAR LockStateGlobPtr   : tkb05_LockStateGlobPtr);
 
        PROCEDURE
              k52begexcl_objcoll (
                    TaskId               : tsp00_TaskId;
                    VAR ObjCollGlobPtr   : tkb05_ObjCollGlobPtr);
 
        PROCEDURE
              k52begexcl_region (
                    TaskId              : tsp00_TaskId;
                    Region              : tkb05_RegionNo;
                    VAR RegionGlobPtr   : tkb05_RegionGlobPtr);
 
        PROCEDURE
              k52begexcl_supply_pool (
                    TaskId                   : tsp00_TaskId;
                    VAR SupplyPoolGlobPtr    : tkb05_SupplyPoolGlobPtr);
 
        PROCEDURE
              k52endexcl_lockstate (
                    TaskId                 : tsp00_TaskId;
                    VAR LockStateGlobPtr   : tkb05_LockStateGlobPtr);
 
        PROCEDURE
              k52endexcl_objcoll (
                    TaskId               : tsp00_TaskId;
                    VAR ObjCollGlobPtr   : tkb05_ObjCollGlobPtr);
 
        PROCEDURE
              k52endexcl_region (
                    TaskId              : tsp00_TaskId;
                    VAR RegionGlobPtr   : tkb05_RegionGlobPtr);
 
        PROCEDURE
              k52endexcl_supply_pool (
                    TaskId                   : tsp00_TaskId;
                    VAR SupplyPoolGlobPtr    : tkb05_SupplyPoolGlobPtr);
 
        PROCEDURE
              k52flush_consist_view    (VAR ConsistView   : tkb05_ConsistView);
 
        PROCEDURE
              k52flush_hash_open_trans (VAR HashOpenTrans : tkb05_HashOpenTrans);
 
        PROCEDURE
              k52flush_objreq_entry    (VAR ObjReqEntry   : tkb05_ObjReqEntry);
 
        PROCEDURE
              k52flush_row_lock        (VAR RowLock       : tkb05_RowLock);
 
        PROCEDURE
              k52flush_row_trans       (VAR RowTrans      : tkb05_RowTrans);
 
        PROCEDURE
              k52flush_tab_lock        (VAR TabLock       : tkb05_TabLock);
 
        PROCEDURE
              k52flush_tab_trans       (VAR TabTrans      : tkb05_TabTrans);
 
        PROCEDURE
              k52flush_trans_entry     (VAR TransEntry    : tkb05_TransEntry);
 
        PROCEDURE
              k52flush_trans_glob      (VAR TransGlob     : tkb05_TransGlob);
 
        PROCEDURE
              k52flush_trans_waiting   (VAR TransWaiting  : boolean);
 
        FUNCTION
              k52GetCollisionEntry (taskid : tsp00_TaskId;
                    VAR entryNumber   : tgg00_TransIndex;
                    VAR colEntryIndex : tgg00_TransIndex;
                    VAR reqEntryIndex : tgg00_TransIndex;
                    VAR fileno        : tsp00_C8;
                    VAR oid           : tgg00_OidSpace (*ptocSynonym tgg92_KernelOid&*);
                    VAR transno       : tgg91_TransNo;
                    VAR taskidOfTrans : tsp00_TaskId;
                    VAR isHolder      : boolean;
                    VAR isShareReq    : boolean) : boolean;
 
        PROCEDURE
              k52show_lock (VAR m : tgg00_MessBlock);
 
        FUNCTION
              k52used_items_of_region (VAR RegionGlob : tkb05_RegionGlob): tsp00_Int4;
 
        FUNCTION
              k52used_trans_of_region (VAR RegionGlob : tkb05_RegionGlob): tsp00_Int4;
 
        PROCEDURE
              k52x_item_error (
                    msg            : tsp00_C24;
                    ItemKind       : tkb05_ItemKind);
 
        PROCEDURE
              k52x_loop_error (
                    msg            : tsp00_C24;
                    error_no       : tsp00_Int4);
&       ifdef TRACE
 
        PROCEDURE
              k52xaddr_rowl (
                    debug   : tgg00_Debug;
                    msg     : tsp00_Sname;
                    RowLock : tkb05_RowLockPtr);
 
        PROCEDURE
              k52xaddr_rowl_check (
                    VAR RowRegionGlob : tkb05_RegionGlob;
                    RowLock : tkb05_RowLockPtr);
 
        PROCEDURE
              k52xaddr_rowt (
                    debug    : tgg00_Debug;
                    msg      : tsp00_Sname;
                    RowTrans : tkb05_RowTransPtr);
 
        PROCEDURE
              k52xaddr_rowt_check (
                    VAR TransRegionGlob : tkb05_RegionGlob;
                    RowTrans : tkb05_RowTransPtr);
 
        PROCEDURE
              k52xaddr_tabl (
                    debug   : tgg00_Debug;
                    msg     : tsp00_Sname;
                    TabLock : tkb05_TabLockPtr);
 
        PROCEDURE
              k52xaddr_tabl_check (
                    VAR TabRegionGlob : tkb05_RegionGlob;
                    TabLock : tkb05_TabLockPtr);
 
        PROCEDURE
              k52xaddr_tabt (
                    debug    : tgg00_Debug;
                    msg      : tsp00_Sname;
                    TabTrans : tkb05_TabTransPtr);
 
        PROCEDURE
              k52xaddr_tabt_check (
                    VAR TransRegionGlob : tkb05_RegionGlob;
                    TabTrans : tkb05_TabTransPtr);
 
        PROCEDURE
              k52xregion_supply_check (VAR RegionGlob : tkb05_RegionGlob);
 
        PROCEDURE
              k52xreq (
                    debug    : tgg00_Debug;
                    Req      : tkb05_ReqPtr);
 
        PROCEDURE
              k52xrow_lock (
                    debug : tgg00_Debug;
                    Row : tkb05_RowLockPtr);
 
        PROCEDURE
              k52xrow_region_check (VAR RowRegionGlob : tkb05_RegionGlob);
 
        PROCEDURE
              k52xrow_trans (
                    debug : tgg00_Debug;
                    Row : tkb05_RowTransPtr);
 
        PROCEDURE
              k52xtab_lock (
                    debug : tgg00_Debug;
                    Tab : tkb05_TabLockPtr);
 
        PROCEDURE
              k52xtab_region_check (VAR TabRegionGlob : tkb05_RegionGlob);
 
        PROCEDURE
              k52xtab_trans (
                    debug : tgg00_Debug;
                    Tab : tkb05_TabTransPtr);
 
        PROCEDURE
              k52xtrans (
                    debug      : tgg00_Debug;
                    TransEntry : tkb05_TransEntryPtr);
 
        PROCEDURE
              k52xwanted_lock (
                    debug            : tgg00_Debug;
                    VAR WantedLock   : tkb05_WantedLock);
&       endif
              (* ptocExport hkb52_1.h *)
 
        PROCEDURE
              k52dump_locklist (
                    TaskId       : tsp00_TaskId;
                    EnterRegions : boolean;
                    VAR HostFile : tgg00_VfFileref;
                    VAR buf      : tsp00_Page;
                    VAR OutPno   : tsp00_Int4;
                    VAR OutPos   : integer;
                    VAR HostErr  : tsp00_VfReturn;
                    VAR ErrText  : tsp00_ErrText);
 
.CM *-END-* define --------------------------------------
 
Use     :
 
        FROM
              KB_Check : VKB03;
 
        VAR
              kb03Check : tkb00_Check;
 
      ------------------------------ 
 
        FROM
              KB_locklist : VKB51;
 
        VAR
              k51glob  : tkb05_Glob;
 
        PROCEDURE
              k51info_lock (
                    TaskId         : tsp00_TaskId;
                    VAR LockInfo   : tkb05_LockInfo);
 
        FUNCTION
              k51tr_index_region (TransIndex : tgg00_TransIndex) : tkb05_RegionNo;
 
      ------------------------------ 
 
        FROM
              KB_ObjShare_lock : VKB501;
 
        (* PTS 1128244 FF 2004-03-18 new layer for share object locks *)
        (*                                                            *)
        FUNCTION
              k501GetHashHdrList(
                    ListIndex : tsp00_Int4) : tkb05_ObjShareLockCtrlPtr;
 
        FUNCTION
              k501GetHashHdrSize : tsp00_Int4;
 
        PROCEDURE
              k501GetStatistics(
                    VAR LockCntrlEntries      : tsp00_Int4;
                    VAR LockCntrlEntriesUsed  : tsp00_Int4;
                    VAR ShareLockEntries      : tsp00_Int4;
                    VAR ShareLockEntriesUsed  : tsp00_Int4;
                    VAR CollisionEntriesUsed  : tsp00_Int4);
 
        PROCEDURE
              k501UnlockHashHdrList(
                    ListIndex : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560DumpTransaction (
                    pTrans         : tsp00_Addr;
                    VAR pData      : tkb05_TransEntryPtr;
                    VAR dataLength : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              SQLManager : vak101;
 
        PROCEDURE
              a101_ResetGroupedTempFile(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId;
                    tempFileType   : tgg00_TfnTemp);
 
      ------------------------------ 
 
        FROM
              AK_Show_statistics : VAK42;
 
        FUNCTION
              a42getparseid (
                    VAR t        : tgg00_TransContext;
                    VAR pid      : tsp00_TaskId;
                    VAR parsid   : tsp00_C12;
                    VAR b_err    : tgg00_BasisError): boolean;
 
      ------------------------------ 
 
        FROM
              filesysteminterface_7 : VBD07;
 
        PROCEDURE
              b07cadd_record (
                    VAR t           : tgg00_TransContext;
                    VAR FileId      : tgg00_FileId;
                    VAR b           : tgg00_Rec);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01code           : tgg04_CodeGlobals;
              g01serverdb_ident : tgg04_ServerdbIdent;
              g01unicode        : boolean;
 
        PROCEDURE
              g01abort (
                    MsgNo     : tsp00_Int4;
                    MsgLabel  : tsp00_C8;
                    MsgText   : tsp00_C24;
                    BadValue  : tsp00_Int4);
 
        PROCEDURE
              g01check (
                    MsgNo      : tsp00_Int4;
                    MsgLabel   : tsp00_C8;
                    MsgText    : tsp00_C24;
                    BadValue   : tsp00_Int4;
                    Constraint : boolean);
 
        FUNCTION
              g01maxlocks : tsp00_Int4;
 
        PROCEDURE
              g01new_dump_page (
                    VAR hostfile : tgg00_VfFileref;
                    VAR buf      : tsp00_Page;
                    VAR out_pno  : tsp00_Int4;
                    VAR out_pos  : integer;
                    VAR host_err : tsp00_VfReturn;
                    VAR errtext  : tsp00_ErrText);
 
        PROCEDURE
              g01opmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C24;
                    msg_value : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              GG_cpp_auxiliary_functions : VGG06;
 
        FUNCTION
              gg06IsDummyTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        FUNCTION
              gg06IsNilOid (VAR oid : tgg00_OidSpace): boolean;
 
        FUNCTION    (* PTS 1128244 FF 2004-03-18 *)
              gg06IsZeroTrans (VAR TransNo : tgg91_TransNo): boolean;
 
        PROCEDURE
              gg06OidToLine (
                    VAR oid          : tgg00_OidSpace;
                    VAR LineLen      : integer;
                    VAR Line         : tkb05_RowId);
 
        PROCEDURE
              gg06SetNilTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              gg06SetZeroTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              gg06SetDummyTrans (VAR TransNo : tgg91_TransNo);
 
        PROCEDURE
              gg06SetNilOid (VAR oid : tgg00_OidSpace (*ptocSynonym tgg92_KernelOid&*));
 
      ------------------------------ 
 
        FROM
              Regions_and_Longwaits : VGG08;
 
        VAR
              g08lock0    : tsp00_RegionId;
              g08lockinit : tsp00_RegionId;
              g08lockpool : tsp00_RegionId;
              g08lockreq  : tsp00_RegionId;
              g08lockwait : tsp00_RegionId;
 
        PROCEDURE
              g08check_excl (region : tsp00_RegionId);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17counter_to_line (
                    counter               : tsp00_8ByteCounter;
                    VAR ln_len            : integer;
                    VAR ln                : tsp00_Line);
 
        PROCEDURE
              g17sname_to_line (
                    n             : tsp00_Sname;
                    VAR LnLen     : integer;
                    VAR ln        : tsp00_Line);
 
        PROCEDURE
              g17trimint4_to_line (
                    Int       : tsp00_Int4;
                    VAR LnLen : integer;
                    VAR ln    : tsp00_Line);
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vbegexcl (
                    TaskId     : tsp00_TaskId;
                    Region     : tsp00_RegionId);
 
        PROCEDURE
              vendexcl (
                    TaskId     : tsp00_TaskId;
                    Region     : tsp00_RegionId);
 
        FUNCTION
              vIsValidTask (pid : tsp00_TaskId ) : boolean;
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalFill (
                    mod_id     : tsp00_C6;
                    mod_num    : tsp00_Int4;
                    size       : tsp00_Int4;
                    buf        : tsp00_MoveObjPtr;
                    pos        : tsp00_Int4;
                    length     : tsp00_Int4;
                    fillchar   : char;
                    VAR err    : tgg00_BasisError);
 
        PROCEDURE
              SAPDB_PascalMove (
                    mod_id   : tsp00_C6;
                    mod_num  : tsp00_Int4;
                    src_upb  : tsp00_Int4;
                    dest_upb : tsp00_Int4;
                    src      : tsp00_MoveObjPtr;
                    src_pos  : tsp00_Int4;
                    dest     : tsp00_MoveObjPtr;
                    dest_pos : tsp00_Int4;
                    length   : tsp00_Int4;
                    VAR err  : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-20 : VSP20;
 
        PROCEDURE
              s20int4_to_buf (
                    val      : tsp00_Int4;
                    VAR dest : tsp00_MoveObj;
                    di       : tsp00_Int4);
 
        PROCEDURE
              s20int4_to_buf_1(
                    val      : tsp00_Int4;
                    VAR dest : tsp00_Page;
                    di       : tsp00_Int4);
 
        PROCEDURE
              s20int4_to_buf_2 (
                    val        : tsp00_Int4;
                    VAR destin : tsp00_Buf;
                    destin_pos : tsp00_Int4);
 
        PROCEDURE
              s20int4_to_buf_swap (
                    val        : tsp00_Int4;
                    sourceswap : tsp00_SwapKind;
                    VAR dest   : tsp00_Buf;
                    di         : tsp00_Int4;
                    destswap   : tsp00_SwapKind);
 
      ------------------------------ 
 
        FROM
              RTE-Extension-30 : VSP30;
 
        PROCEDURE
              s30map (
                    VAR code_t   : tsp00_Ctable;
                    VAR source   : tkb05_ShowStatRec;
                    spos         : tsp00_Int4;
                    VAR dest     : tkb05_ShowStatRec;
                    dpos         : tsp00_Int4;
                    length       : tsp00_Int4);
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01addr (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    bufaddr  : tkb05_SupplyItemPtr);
 
        PROCEDURE
              t01addr_1 (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    bufaddr  : tkb05_TransEntryPtr);
 
        PROCEDURE
              t01addr2 (
                    debug     : tgg00_Debug;
                    nam1      : tsp00_Sname;
                    bufaddr1  : tkb05_SupplyItemPtr;
                    nam2      : tsp00_Sname;
                    bufaddr2  : tkb05_SupplyItemPtr);
 
        PROCEDURE
              t01c4int (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    Int       : tsp00_C4);
 
        PROCEDURE
              t01bool (
                    debug    : tgg00_Debug;
                    nam      : tsp00_Sname;
                    curr_bool: boolean);
 
        PROCEDURE
              t01buf (
                    debug   : tgg00_Debug;
                    VAR buf : tkb05_RowId;
                    pos_anf : integer;
                    pos_end : integer);
 
        PROCEDURE
              t01buf1 (
                    debug    : tgg00_Debug;
                    VAR buf  : tkb05_ShortKey;
                    pos_anf  : integer;
                    pos_end  : integer);
 
        PROCEDURE
              t01int4 (
                    debug : tgg00_Debug;
                    nam : tsp00_Sname;
                    Int : tsp00_Int4);
 
        PROCEDURE
              t01lockmode (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    LockMode     : tgg00_LockReqMode);
 
        PROCEDURE
              t01lockstate (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    LockState     : tgg00_LockReqState);
 
        PROCEDURE
              t01messtype (
                    debug        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    mess_type    : tgg00_MessType);
 
        PROCEDURE
              t01name1 (
                    debug     : tgg00_Debug;
                    nam       : tsp00_Sname;
                    n         : tsp00_Name);
 
        PROCEDURE
              t01p2int4 (
                    debug : tgg00_Debug;
                    nam_1 : tsp00_Sname;
                    int_1 : tsp00_Int4;
                    nam_2 : tsp00_Sname;
                    int_2 : tsp00_Int4);
 
        PROCEDURE
              ta01SessionTrans (
                    debug             : tgg00_Debug;
                    nam               : tsp00_Sname;
                    VAR session       : tgg91_SessionNo;
                    VAR trans         : tgg91_TransNo;
                    VAR write_trans   : tgg91_TransNo;
                    VAR subtrans      : tgg00_SubtransNo);
 
        PROCEDURE
              t01str30 (debug : tgg00_Debug; str30 : tsp00_C30);
 
        PROCEDURE
              t01surrogate (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR TabId     : tgg00_Surrogate);
 
        FUNCTION
              t01trace (debug : tgg00_Debug) : boolean;
&       endif
 
.CM *-END-* use -----------------------------------------
 
Synonym :
 
        PROCEDURE
              gg06OidToLine;
 
              tsp00_Line tkb05_RowId
 
        PROCEDURE
              s20int4_to_buf_1;
 
              tsp00_MoveObj tsp00_Page
 
        PROCEDURE
              s20int4_to_buf_2;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s20int4_to_buf_swap;
 
              tsp00_MoveObj tsp00_Buf
 
        PROCEDURE
              s30map;
 
              tsp00_MoveObj tkb05_ShowStatRec
&             ifdef TRACE
 
        PROCEDURE
              t01addr;
 
              tsp00_BufAddr tkb05_SupplyItemPtr
 
        PROCEDURE
              t01addr_1;
 
              tsp00_BufAddr tkb05_TransEntryPtr
 
        PROCEDURE
              t01addr2;
 
              tsp00_BufAddr tkb05_SupplyItemPtr
 
        PROCEDURE
              t01buf;
 
              tsp00_Buf tkb05_RowId
 
        PROCEDURE
              t01buf1;
 
              tsp00_Buf tkb05_ShortKey
&             endif
 
.CM *-END-* synonym -------------------------------------
 
 
Release :      Date : 2000-09-05
 
***********************************************************
 
Specification:
 
 
Procedure K52ROW_SHOW
 
Creates a result record for a Row lock and inserts the record into the
temporary result file (FILE_ID).
 
 
Procedure K52SHOW_LOCK
 
Creates the result records for SHOW STATISTICS LOCK and inserts
the records into the temporary result file (FILE_ID).
 
 
Procedure K52TAB_SHOW
 
Creates a result record for a table lock and inserts the record into the
temporary result file (FILE_ID).
 
 
Procedure K52TRANS_SHOW
 
Creates a result record for a transaction description
and inserts the record into the temporary result file (FILE_ID).
 
 
Procedure K52USER_SHOW
 
Creates a result record containing the USERID and TERMID of a
transaction entry. The record is inserted
into the temporary result file (FILE_ID).
 
 
Procedure KB52HEXKEY_TO_REC
 
Copies a key substring to the result record at a specified
position (POS). The substring is specified by the position of the first
substing byte in the key (KEY_START) and the substring length (KEY_LEN).
 
 
Procedure KB52INFO_SHOW
 
Creates the result records for SHOW STATISTICS LOCK CONFIG and inserts
the records into the temporary result file (FILE_ID).
 
 
Procedure KB52INT_TO_REC
 
Converts a 4 byte integer into characters and inserts the number string
into the result record.
 
 
Procedure KB52MODE_TO_REC
 
Creates a string with the name of a given lockmode and
inserts the string into the result record.
 
 
Procedure KB52PARAM_TO_REC
 
Creates a result record consisting of the name of a parameter
and the integer value of the parameter (e.g. 'NO~OF~ENTRIES~~15').
Afterwards, the result record is inserted into the temporary
result file (FN).
 
 
Procedure KB52TABID_TO_REC
 
Gets the userid and the tablename for the specified TABID and
inserts these names into the result record.
 
 
Procedure KB52TERMID_TO_REC
 
Inserts the TermId into the result record.
 
.CM *-END-* specification -------------------------------
 
***********************************************************
 
Description:
 
Insertions into existing locks/requests:
 
TABLE ENTRY:                      sys excl / sys share
 
     wanted | sys excl    | sys share   | sys share
set         | (eot)       |             | (consistent)
======================================================
free        | sys excl    | sys share   | sys share
            | (eot)       |             | (consistent)
------------+-------------+-------------+-------------
sys excl    | sys excl    | sys excl    | sys excl
(eot)       | (eot)       | (eot)       | (eot)
------------+-------------+-------------+-------------
sys share   | sys excl    | sys share   | sys share
            | (eot)       |             |
------------+-------------+-------------+-------------
sys share   | sys excl    | sys share   | sys share
(consistent)| (eot)       |             | (consistent)
------------+-------------+-------------+-------------
Tab excl    | sys excl    | Tab excl    | Tab excl
(eot)       | (eot)       | (eot)       | (eot)
------------+-------------+-------------+-------------
Tab excl    | sys excl    | Tab excl    | Tab excl
            | (eot)       |             |
------------+-------------+-------------+-------------
Tab share   | sys excl    | Tab share   | Tab share
            | (eot)       |             |
------------+-------------+-------------+-------------
Tab share   | sys excl    | Tab share   | Tab share
(temp)      | (eot)       | (temp)      | (temp)
 
 
 
TABLE ENTRY:                                    Tab excl / Tab share
 
     wanted | Tab excl    | Tab excl    | Tab share   | Tab share
set         | (eot)       |             |             | (temp)
====================================================================
free        | Tab excl    | Tab excl    | Tab share   | Tab share
            | (eot)       |             |             | (temp)
------------+-------------+-------------+-------------+-------------
sys excl    | sys excl    | sys excl    | sys excl    | sys excl
(eot)       | (eot)       | (eot)       | (eot)       | (eot)
------------+-------------+-------------+-------------+-------------
sys share   | Tab excl    | Tab excl    | Tab share   | Tab share
            | (eot)       |             |             | (temp)
------------+-------------+-------------+-------------+-------------
sys share   | Tab excl    | Tab excl    | Tab share   | Tab share
(consistent)| (eot)       |             |             | (temp)
------------+-------------+-------------+-------------+-------------
Tab excl    | Tab excl    | Tab excl    | Tab excl    | Tab excl
(eot)       | (eot)       | (eot)       | (eot)       | (eot)
------------+-------------+-------------+-------------+-------------
Tab excl    | Tab excl    | Tab excl    | Tab excl    | Tab excl
            | (eot)       |             |             |
------------+-------------+-------------+-------------+-------------
Tab share   | Tab excl    | Tab excl    | Tab share   | Tab share
            | (eot)       |             |             |
------------+-------------+-------------+-------------+-------------
Tab share   | Tab excl    | Tab excl    | Tab share   | Tab share
(temp)      | (eot)       |             |             | (temp)
 
 
 
ROW ENTRY:                                    Row excl
 
     wanted | Row excl    | Row excl    | Row excl
set         | (eot)       |             | (consistent)
======================================================
free        | Row excl    | Row excl    | Row excl
            | (eot)       |             | (consistent)
------------+-------------+-------------+-------------
Row excl    | Row excl    | Row excl    | Row excl
(eot)       | (eot)       | (eot)       | (eot)
------------+-------------+-------------+-------------
Row excl    | Row excl    | Row excl    | Row excl
            | (eot)       |             |
------------+-------------+-------------+-------------
Row excl    | Row excl    | Row excl    | Row excl
(consistent)| (eot)       |             | (consistent)
------------+-------------+-------------+-------------
Row share   | Row excl    | Row excl    | Row excl
            | (eot)       |             |
------------+-------------+-------------+-------------
Row share   | Row excl    | Row excl    | Row excl
(consistent)| (eot)       |             | (consistent)
------------+-------------+-------------+-------------
Row optim   | Row excl    | Row excl    | Row excl
            | (eot)       |             |
------------+-------------+-------------+-------------
Row optim   | Row excl    | Row excl    | Row excl
(consistent)| (eot)       |             | (consistent)
 
 
 
ROW ENTRY:                                Row share / Row optimistic
 
     wanted | Row share   | Row share   | Row optim   | Row optim
set         |             | (consistent)|             | (consistent)
====================================================================
free        | Row share   | Row share   | Row optim   | Row optim
            |             | (consistent)|             | (consistent)
------------+-------------+-------------+-------------+-------------
Row excl    | Row excl    | Row excl    | Row excl    | Row excl
(eot)       | (eot)       | (eot)       | (eot)       | (eot)
------------+-------------+-------------+-------------+-------------
Row excl    | Row excl    | Row excl    | Row excl    | Row excl
            |             |             |             |
------------+-------------+-------------+-------------+-------------
Row excl    | Row excl    | Row excl    | Row excl    | Row excl
(consistent)|             | (consistent)|             | (consistent)
------------+-------------+-------------+-------------+-------------
Row share   | Row share   | Row share   | Row share   | Row share
            |             |             |             |
------------+-------------+-------------+-------------+-------------
Row share   | Row share   | Row share   | Row share   | Row share
(consistent)|             | (consistent)|             | (consistent)
------------+-------------+-------------+-------------+-------------
Row optim   | Row share   | Row share   | Row optim   | Row optim
            |             |             |             |
------------+-------------+-------------+-------------+-------------
Row optim   | Row share   | Row share   | Row optim   | Row optim
(consistent)|             | (consistent)|             | (consistent)
 
.CM *-END-* description ---------------------------------
 
**********************************************************
 
Structure:
 
.CM *-END-* structure -----------------------------------
 
**********************************************************
 
.CM -lll-
Code    :
 
 
CONST
      MAX_CHECK_ITEMS       = 20;
      (* *)
      IS_INT4               = true;
      (* *)
      CNSVIEW_IS_PROTECTED  = true;   (*PTS 1137874 FF 15-Sep-2005*)
      (* *)
      MSG01_MAX_LOCKS       = 'MAX LOCKS                               ';
      MSG02_TRANS_REGIONS   = 'TRANS LIST REGIONS                      ';
      MSG03_TAB_REGIONS     = 'TABLE LIST REGIONS                      ';
      MSG04_ROW_REGIONS     = 'ROW   LIST REGIONS                      ';
      MSG05_MAX_ENTRIES     = 'ENTRIES                                 ';
      MSG06_ENTRIES_USED    = 'USED ENTRIES                            ';
      MSG07_USED_PERCENT    = 'USED ENTRIES (%)                        ';
      MSG08_AVG_USED        = 'AVG USED ENTRIES                        ';
      MSG09_AVG_PERCENT     = 'AVG USED ENTRIES (%)                    ';
      MSG10_MAX_USED        = 'MAX USED ENTRIES                        ';
      MSG11_MAX_PERCENT     = 'MAX USED ENTRIES (%)                    ';
      MSG11A_SHR_ENTRIES    = 'OMS SHARE LOCK CONTROL ENTRIES          '; (* PTS 1128244 FF 2004-03-18 *)
      MSG11B_SHR_USED       = 'OMS SHARE LOCK CONTROL ENTRIES USED     '; (* PTS 1128244 FF 2004-03-18 *)
      MSG11C_SHR_REQUESTS   = 'OMS SHARE LOCK ENTRIES                  '; (* PTS 1128244 FF 2004-03-18 *)
      MSG11D_SHR_REQ_USED   = 'OMS SHARE LOCK ENTRIES USED             '; (* PTS 1128244 FF 2004-03-18 *)
      MSG11E_SHR_COLL_USED  = 'OMS SHARE LOCK COLLISION ENTRIES USED   '; (* PTS 1128244 FF 2004-03-18 *)
      MSG12_CONSIST_VIEW    = 'CONSIST VIEW ENTRIES                    ';
      MSG13_OPEN_TRANS      = 'OPEN TRANS ENTRIES                      ';
      MSG14_LOCK_ESCAL      = 'LOCK ESCALATION VALUE                   ';
      MSG15_ESCALATIONS     = 'LOCK ESCALATIONS                        ';
      MSG16_COLLISIONS      = 'LOCK COLLISIONS                         ';
      MSG16A_SQL_COLLISIONS = 'SQL LOCK COLLISIONS                     ';
      MSG16B_OMS_COLLISIONS = 'OMS LOCK COLLISIONS                     ';
      MSG17_DEADLOCKS       = 'DEADLOCKS                               ';
      MSG18_SQL_REQTIMEOUT  = 'SQL REQUEST TIMEOUTS                    ';
      MSG19_OBJ_REQTIMEOUT  = 'OMS REQUEST TIMEOUTS                    ';
      MSG20_LOCK_TRANS      = 'TRANSACTIONS HOLDING     LOCKS          ';
      MSG21_REQ_TRANS       = 'TRANSACTIONS REQUESTING  LOCKS          ';
      MSG22_OBJ_LOCK_TRANS  = 'TRANSACTIONS HOLDING OMS LOCKS          ';
      MSG23_CLOSED_LIST     = 'CHECKPOINT WANTED                       ';
      MSG24_SHUTDOWN        = 'SHUTDOWN   WANTED                       ';
      (* *)
      DUMPMARK_UNDEF       = 'K51UNDEF';
      DUMPCODE_UNDEF       = 1200;
      DUMPMARK_GLOB        = 'K51GLOB ';
      DUMPCODE_GLOB        = 1201;
      DUMPMARK_LOCK        = 'K51LOCK ';
      DUMPCODE_LOCK        = 1202;
      DUMPMARK_TRANS       = 'K51TRANS';
      DUMPCODE_TRANS       = 1203;
      DUMPMARK_TRANS_ENTRY = 'K51ENTRY';
      DUMPCODE_TRANS_ENTRY = 1204;
      DUMPMARK_TAB_TRANS   = 'K51TABTR';
      DUMPCODE_TAB_TRANS   = 1205;
      DUMPMARK_ROW_TRANS   = 'K51ROWTR';
      DUMPCODE_ROW_TRANS   = 1206;
      DUMPMARK_TAB_LOCK    = 'K51TAB  ';
      DUMPCODE_TAB_LOCK    = 1207;
      DUMPMARK_ROW_LOCK    = 'K51ROW  ';
      DUMPCODE_ROW_LOCK    = 1208;
      DUMPMARK_ROWID       = 'K51ROWID';
      DUMPCODE_ROWID       = 1209;
      DUMPMARK_REQ         = 'K51REQ  ';
      DUMPCODE_REQ         = 1210;
      DUMPMARK_TRANS_HASH  = 'K51HASH ';
      DUMPCODE_TRANS_HASH  = 1211;
      DUMPMARK_TAB_HASH    = 'K51HSTAB';
      DUMPCODE_TAB_HASH    = 1212;
      DUMPMARK_ROW_HASH    = 'K51HSROW';
      DUMPCODE_ROW_HASH    = 1213;
      DUMPMARK_CONSIST_TR  = 'K51CNSIS';
      DUMPCODE_CONSIST_TR  = 1214;
      DUMPMARK_OPEN_TRANS  = 'K51OPENT';
      DUMPCODE_OPEN_TRANS  = 1215;
      DUMPMARK_HASH_OPENTR = 'K51HOPNT';
      DUMPCODE_HASH_OPENTR = 1216;
      DUMPMARK_OBJ_COLL    = 'K51OCOLL';
      DUMPCODE_OBJ_COLL    = 1217;
      DUMPMARK_REQ_TRANS   = 'K51REQTR';
      DUMPCODE_REQ_TRANS   = 1218;
      DUMPMARK_SHR_LCKCTRL = 'K51SLCTR';   (* PTS 1128244 FF 2004-05-17 *)
      DUMPCODE_SHR_LCKCTRL = 1219;         (* PTS 1128244 FF 2004-05-17 *)
      DUMPMARK_SHR_LOCK    = 'K51SLOCK';   (* PTS 1128244 FF 2004-05-17 *)
      DUMPCODE_SHR_LOCK    = 1220;         (* PTS 1128244 FF 2004-05-17 *)
 
TYPE
 
      t_Show = RECORD
            shwBlankRec : tkb05_ShowStatRec;
            shwRec      : tkb05_ShowStatRec;
            shwRecCount : tsp00_Int4;
            shwCharSize : integer;
            shwInfoLen  : integer;
            shwHostCode : tsp00_CodeType
      END;
 
      t_RecPtr = ^tgg00_Rec;
 
 
(*------------------------------*) 
 
PROCEDURE
      k52acc_objcoll_entry (
            VAR ObjCollGlob     : tkb05_ObjCollGlob;
            EntryIndex          : tgg00_TransIndex;
            VAR ObjCollEntryPtr : tkb05_ObjCollEntryPtr);
 
BEGIN
IF  EntryIndex > k51glob.glTransEntries_kb05 (* PTS 1111799 UH 2001-10-01 *)
THEN
    ObjCollEntryPtr := @ObjCollGlob.oglObjCollList_kb05^[1]
ELSE
    ObjCollEntryPtr := @ObjCollGlob.oglObjCollList_kb05^[EntryIndex]
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52acc_objreq_entry (
            VAR ObjCollGlob    : tkb05_ObjCollGlob;
            TransIndex         : tgg00_TransIndex;
            VAR ObjReqEntryPtr : tkb05_ObjReqEntryPtr);
 
BEGIN
IF  TransIndex > k51glob.glTransEntries_kb05 (* PTS 1111799 UH 2001-10-01 *)
THEN
    ObjReqEntryPtr := @ObjCollGlob.oglObjReqList_kb05^[1]
ELSE
    ObjReqEntryPtr := @ObjCollGlob.oglObjReqList_kb05^[TransIndex]
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52acc_trans_entry (
            TransIndex        : tgg00_TransIndex;
            VAR TransEntryPtr : tkb05_TransEntryPtr);
 
BEGIN
IF  TransIndex > k51glob.glTransEntries_kb05 (* PTS 1111799 UH 2001-10-01 *)
THEN
    TransEntryPtr := k51glob.glTransList_kb05^[1]
ELSE
    TransEntryPtr := k51glob.glTransList_kb05^[TransIndex]
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52begexcl_lockstate (
            TaskId                 : tsp00_TaskId;
            VAR LockStateGlobPtr   : tkb05_LockStateGlobPtr);
 
BEGIN
vbegexcl (TaskId, g08lockinit);
LockStateGlobPtr := k51glob.glLockStateGlob_kb05
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52begexcl_objcoll (
            TaskId               : tsp00_TaskId;
            VAR ObjCollGlobPtr   : tkb05_ObjCollGlobPtr);
 
BEGIN
vbegexcl (TaskId, g08lockwait);
ObjCollGlobPtr := k51glob.glObjCollGlob_kb05
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52begexcl_region (
            TaskId              : tsp00_TaskId;
            Region              : tkb05_RegionNo;
            VAR RegionGlobPtr   : tkb05_RegionGlobPtr);
 
BEGIN
vbegexcl (TaskId, g08lock0 + Region);
RegionGlobPtr := k51glob.glRegionGlob_kb05^[Region]
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52begexcl_supply_pool (
            TaskId                   : tsp00_TaskId;
            VAR SupplyPoolGlobPtr    : tkb05_SupplyPoolGlobPtr);
 
BEGIN
vbegexcl (TaskId, g08lockpool);
SupplyPoolGlobPtr := k51glob.glSupplyPoolGlob_kb05
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52dump_locklist (
            TaskId       : tsp00_TaskId;
            EnterRegions : boolean;
            VAR HostFile : tgg00_VfFileref;
            VAR buf      : tsp00_Page;
            VAR OutPno   : tsp00_Int4;
            VAR OutPos   : integer;
            VAR HostErr  : tsp00_VfReturn;
            VAR ErrText  : tsp00_ErrText);
 
VAR
      MoveError      : tgg00_BasisError; (* dummy error *)
      CurrRegion     : integer;
      RegionCnt      : integer;
      i2             : tsp00_IntMapC2;
      i              : tsp00_Int4;
      UnivPtr        : tkb05_UnivPtr;
      CurrTrans      : tkb05_TransEntryPtr;
      pLogTrans      : tkb05_TransEntryPtr;
      LogTransLength : tsp00_Int4;
 
BEGIN
MoveError := e_ok;
IF  EnterRegions
THEN
    BEGIN
    vbegexcl (TaskId, g08lockinit);
    FOR CurrRegion := 1 TO k51glob.glRegions_kb05 DO
        vbegexcl (TaskId, g08lock0 + CurrRegion);
    (*ENDFOR*) 
    vbegexcl (TaskId, g08lockpool);
    vbegexcl (TaskId, g08lockreq );
    vbegexcl (TaskId, g08lockwait)
    END;
(*ENDIF*) 
HostErr := vf_ok;
IF  NOT k51glob.glGenerated_kb05
THEN
    (* -----  K 5 1 U N D E F  ----- *)
    kb52dump_header (HostFile, 0, DUMPMARK_UNDEF, DUMPCODE_UNDEF,
          buf, OutPno, OutPos, HostErr, ErrText)
ELSE
    (* -----  K 5 1 G L O B  ----- *)
    BEGIN
    (* sizeof (buf) ==> new page *)
    kb52dump_header (HostFile, sizeof (buf),
          DUMPMARK_GLOB, DUMPCODE_GLOB,
          buf, OutPno, OutPos, HostErr, ErrText);
    IF  HostErr = vf_ok
    THEN
        BEGIN
        SAPDB_PascalMove ('VKB52 ',   1,    
              sizeof (k51glob), sizeof (buf),
              @k51glob, 1, @buf, OutPos, sizeof (k51glob), MoveError);
        MoveError := e_ok; (* ignore error *)
        OutPos    := OutPos + sizeof (k51glob);
        SAPDB_PascalMove ('VKB52 ',   2,    
              sizeof (k51glob.glSupplyPoolGlob_kb05^), sizeof (buf),
              @k51glob.glSupplyPoolGlob_kb05^, 1, @buf, OutPos,
              sizeof (k51glob.glSupplyPoolGlob_kb05^), MoveError);
        MoveError := e_ok; (* ignore error *)
        OutPos    := OutPos + sizeof(k51glob.glSupplyPoolGlob_kb05^);
        SAPDB_PascalMove ('VKB52 ',   3,    
              sizeof (k51glob.glLockStateGlob_kb05^), sizeof (buf),
              @k51glob.glLockStateGlob_kb05^, 1, @buf, OutPos,
              sizeof (k51glob.glLockStateGlob_kb05^), MoveError);
        MoveError := e_ok; (* ignore error *)
        OutPos    := OutPos + sizeof (k51glob.glLockStateGlob_kb05^);
        SAPDB_PascalMove ('VKB52 ',   4,    
              sizeof (k51glob.glObjCollGlob_kb05^), sizeof (buf),
              @k51glob.glObjCollGlob_kb05^, 1, @buf, OutPos,
              sizeof (k51glob.glObjCollGlob_kb05^), MoveError);
        MoveError := e_ok; (* ignore error *)
        OutPos    := OutPos + sizeof (k51glob.glObjCollGlob_kb05^)
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  k51glob.glGenerated_kb05 AND (HostErr = vf_ok)
THEN
    (* -----  R E G I O N   G L O B  ----- *)
    BEGIN
    CurrRegion := 1;
    WHILE (HostErr = vf_ok) AND (CurrRegion <= k51glob.glRegions_kb05) DO
        BEGIN
        kb52dump_header (HostFile,
              sizeof (tsp00_Int2) + sizeof (tsp00_Int2) + sizeof (tkb05_RegionGlob),
              DUMPMARK_LOCK, DUMPCODE_LOCK,
              buf, OutPno, OutPos, HostErr, ErrText);
        i2.mapInt_sp00 := CurrRegion;
        buf [OutPos  ] := i2.mapC2_sp00 [1];
        buf [OutPos+1] := i2.mapC2_sp00 [2];
        OutPos         := OutPos + 2 + sizeof (tsp00_Int2);
        RegionCnt      := k51glob.glRegions_kb05 - CurrRegion + 1;
        IF  OutPos - 1 + RegionCnt * sizeof (tkb05_RegionGlob) > sizeof (buf)
        THEN
            RegionCnt := (sizeof (buf) - OutPos + 1) DIV sizeof (tkb05_RegionGlob);
        (*ENDIF*) 
        i2.mapInt_sp00 := RegionCnt;
        buf [OutPos-2] := i2.mapC2_sp00 [1];
        buf [OutPos-1] := i2.mapC2_sp00 [2];
        FOR i := 0 TO RegionCnt - 1 DO
            BEGIN
            SAPDB_PascalMove ('VKB52 ',   5,    
                  sizeof (tkb05_RegionGlob), sizeof(buf),
                  @k51glob.glRegionGlob_kb05^[CurrRegion + i]^, 1,
                  @buf, OutPos, sizeof (tkb05_RegionGlob), MoveError);
            MoveError := e_ok; (* ignore error *)
            OutPos    := OutPos + sizeof (tkb05_RegionGlob)
            END;
        (*ENDFOR*) 
        CurrRegion := CurrRegion + RegionCnt
        END
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  k51glob.glGenerated_kb05 AND (HostErr = vf_ok)
THEN
    (* -----  T R A N S   R E G I O N   G L O B  ----- *)
    BEGIN
    CurrRegion := 1;
    WHILE (HostErr = vf_ok) AND (CurrRegion <= k51glob.glTransRegions_kb05) DO
        BEGIN
        kb52dump_header (HostFile,
              sizeof (tsp00_Int2) + sizeof (tsp00_Int2) + sizeof (tkb05_TransGlob),
              DUMPMARK_TRANS, DUMPCODE_TRANS,
              buf, OutPno, OutPos, HostErr, ErrText);
        i2.mapInt_sp00 := CurrRegion;
        buf [OutPos  ] := i2.mapC2_sp00 [1];
        buf [OutPos+1] := i2.mapC2_sp00 [2];
        OutPos         := OutPos + 2 + sizeof (tsp00_Int2);
        RegionCnt      := k51glob.glTransRegions_kb05 - CurrRegion + 1;
        IF  OutPos - 1 + RegionCnt * sizeof (tkb05_TransGlob) > sizeof (buf)
        THEN
            RegionCnt := (sizeof (buf) - OutPos + 1) DIV sizeof (tkb05_TransGlob);
        (*ENDIF*) 
        i2.mapInt_sp00 := RegionCnt;
        buf [OutPos-2] := i2.mapC2_sp00 [1];
        buf [OutPos-1] := i2.mapC2_sp00 [2];
        FOR i := 0 TO RegionCnt - 1 DO
            BEGIN
            SAPDB_PascalMove ('VKB52 ',   6,    
                  sizeof (tkb05_TransGlob), sizeof(buf),
                  @k51glob.glRegionGlob_kb05^[CurrRegion + i]^.rglTransGlob_kb05^, 1,
                  @buf, OutPos, sizeof (tkb05_TransGlob), MoveError);
            MoveError := e_ok; (* ignore error *)
            OutPos    := OutPos + sizeof (tkb05_TransGlob)
            END;
        (*ENDFOR*) 
        CurrRegion := CurrRegion + RegionCnt
        END
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  k51glob.glGenerated_kb05 AND (HostErr = vf_ok)
THEN
    (* -----  T R A N S   E N T R I E S  ----- *)
    WITH k51glob DO
        BEGIN
        i := 1;
        LogTransLength := 0;
        WHILE (i <= glTransEntries_kb05) AND (HostErr = vf_ok) DO
            BEGIN
            CurrTrans := glTransList_kb05^[i];
            IF  CurrTrans^.teState_kb05 <> m_delete
            THEN
                BEGIN
                kb52dump_header (HostFile, sizeof (CurrTrans^)+LogTransLength,
                      DUMPMARK_TRANS_ENTRY, DUMPCODE_TRANS_ENTRY,
                      buf, OutPno, OutPos, HostErr, ErrText);
                IF  HostErr = vf_ok
                THEN
                    BEGIN
                    SAPDB_PascalMove ('VKB52 ',   7,    
                          sizeof (CurrTrans^), sizeof (buf),
                          @CurrTrans^, 1, @buf, OutPos, sizeof (CurrTrans^), MoveError);
                    MoveError := e_ok; (* ignore error *)
                    OutPos    := OutPos + sizeof (CurrTrans^);
                    (**)
                    IF  CurrTrans^.teLog_kb05.tlogTransPtr_kb05 <> NIL
                    THEN
                        BEGIN
                        kb560DumpTransaction (CurrTrans^.teLog_kb05.tlogTransPtr_kb05,
                              pLogTrans, LogTransLength);
                        SAPDB_PascalMove ('VKB52 ',   8,    
                              LogTransLength, sizeof (buf),
                              @pLogTrans^, 1, @buf, OutPos, LogTransLength, MoveError);
                        MoveError := e_ok; (* ignore error *)
                        OutPos    := OutPos + LogTransLength;
                        END;
                    (*ENDIF*) 
                    kb52dump_trans_tables (HostFile, CurrTrans^.teOwnAddr_kb05,
                          buf, OutPno, OutPos, HostErr, ErrText)
                    END
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            i := i + 1
            END
        (*ENDWHILE*) 
        END;
    (*ENDWITH*) 
(*ENDIF*) 
IF  k51glob.glGenerated_kb05 AND (HostErr = vf_ok)
THEN
    kb52dump_tables_and_obj_trans (HostFile, buf, OutPno, OutPos, HostErr, ErrText);
(*ENDIF*) 
IF  k51glob.glGenerated_kb05 AND (HostErr = vf_ok)
THEN
    kb52dump_rows (HostFile, buf, OutPno, OutPos, HostErr, ErrText);
(*ENDIF*) 
IF  k51glob.glGenerated_kb05 AND (HostErr = vf_ok)
THEN
    BEGIN
    CurrRegion := 1;
    WHILE (CurrRegion <= k51glob.glRegions_kb05) AND (HostErr = vf_ok) DO
        BEGIN
        IF  CurrRegion <= k51glob.glTransRegions_kb05
        THEN
            (* TransHash *)
            BEGIN
            UnivPtr.uvTransPtrList_kb05 :=
                  k51glob.glRegionGlob_kb05^[CurrRegion]^.rglTransGlob_kb05^.trTransHash_kb05;
            kb52dump_hashlist (HostFile,
                  DUMPMARK_TRANS_HASH, DUMPCODE_TRANS_HASH, CurrRegion,
                  UnivPtr.uvRowHash_kb05,
                  k51glob.glTransHashEntriesPerRegion_kb05,
                  buf, OutPno, OutPos, HostErr, ErrText)
            END
        ELSE
            IF  CurrRegion <= k51glob.glTransRegions_kb05 + k51glob.glTabRegions_kb05
            THEN
                (* TabHash *)
                BEGIN
                UnivPtr.uvTabHash_kb05 := k51glob.glRegionGlob_kb05^[CurrRegion]^.rglTabHash_kb05;
                kb52dump_hashlist (HostFile,
                      DUMPMARK_TAB_HASH, DUMPCODE_TAB_HASH, CurrRegion,
                      UnivPtr.uvRowHash_kb05,
                      k51glob.glTabHashEntriesPerRegion_kb05,
                      buf, OutPno, OutPos, HostErr, ErrText);
                END
            ELSE
                (* RowHash *)
                kb52dump_hashlist (HostFile,
                      DUMPMARK_ROW_HASH, DUMPCODE_ROW_HASH, CurrRegion,
                      k51glob.glRegionGlob_kb05^[CurrRegion]^.rglRowHash_kb05,
                      k51glob.glRowHashEntriesPerRegion_kb05,
                      buf, OutPno, OutPos, HostErr, ErrText);
            (*ENDIF*) 
        (*ENDIF*) 
        CurrRegion := CurrRegion + 1
        END
    (*ENDWHILE*) 
    END;
(*ENDIF*) 
IF  k51glob.glGenerated_kb05 AND (HostErr = vf_ok)
THEN
    (* PTS 1002114 JA 1999-03-02 *)
    kb52dump_obj_collision (HostFile, buf, OutPno, OutPos, HostErr, ErrText);
(*ENDIF*) 
IF  k51glob.glGenerated_kb05 AND (HostErr = vf_ok)
THEN
    (* PTS 1128244 FF 2004-05-17 *)
    kb52dump_share_locks (HostFile, buf, OutPno, OutPos, HostErr, ErrText);
(*ENDIF*) 
IF  EnterRegions
THEN
    BEGIN
    vendexcl (TaskId, g08lockwait);
    vendexcl (TaskId, g08lockreq );
    vendexcl (TaskId, g08lockpool);
    FOR CurrRegion := k51glob.glRegions_kb05 DOWNTO 1 DO
        vendexcl (TaskId, g08lock0 + CurrRegion);
    (*ENDFOR*) 
    vendexcl (TaskId, g08lockinit)
    END;
(*ENDIF*) 
IF  (HostErr = vf_ok)
THEN
    g01new_dump_page (HostFile, buf, OutPno, OutPos, HostErr, ErrText)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52endexcl_lockstate (
            TaskId                 : tsp00_TaskId;
            VAR LockStateGlobPtr   : tkb05_LockStateGlobPtr);
 
BEGIN
vendexcl (TaskId, LockStateGlobPtr^.lglOwnRegionId_kb05);
LockStateGlobPtr := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52endexcl_objcoll (
            TaskId               : tsp00_TaskId;
            VAR ObjCollGlobPtr   : tkb05_ObjCollGlobPtr);
 
BEGIN
vendexcl (TaskId, ObjCollGlobPtr^.oglOwnRegionId_kb05);
ObjCollGlobPtr := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52endexcl_region (
            TaskId              : tsp00_TaskId;
            VAR RegionGlobPtr   : tkb05_RegionGlobPtr);
 
BEGIN
vendexcl (TaskId, g08lock0 + RegionGlobPtr^.rglOwnRegion_kb05);
RegionGlobPtr := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52endexcl_supply_pool (
            TaskId                   : tsp00_TaskId;
            VAR SupplyPoolGlobPtr    : tkb05_SupplyPoolGlobPtr);
 
BEGIN
vendexcl (TaskId, SupplyPoolGlobPtr^.poolOwnRegionId_kb05);
SupplyPoolGlobPtr := NIL
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_consist_view (VAR ConsistView : tkb05_ConsistView);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_hash_open_trans (VAR HashOpenTrans : tkb05_HashOpenTrans);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_objreq_entry (VAR ObjReqEntry : tkb05_ObjReqEntry);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_row_lock (VAR RowLock : tkb05_RowLock);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_row_trans (VAR RowTrans : tkb05_RowTrans);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_tab_lock (VAR TabLock : tkb05_TabLock);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_tab_trans (VAR TabTrans : tkb05_TabTrans);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_trans_entry (VAR TransEntry : tkb05_TransEntry);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_trans_glob (VAR TransGlob : tkb05_TransGlob);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52flush_trans_waiting   (VAR TransWaiting  : boolean);
 
BEGIN
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52_GetCollEntry (taskid : tsp00_TaskId;
            ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
            colEntryIndex  : tgg00_TransIndex;
            VAR CollEntry  : tkb05_ObjCollEntryPtr);
 
VAR
      LockTrans : tkb05_TransEntryPtr;
 
BEGIN
(* If CollEntry is returned with NIL no entry was found *)
IF  kb03Check.chkRegion_kb00
THEN
    g08check_excl (ObjCollGlobPtr^.oglOwnRegionId_kb05);
(*ENDIF*) 
IF  (colEntryIndex = cgg_nil_transindex)
    OR
    (colEntryIndex > k51glob.glTransEntries_kb05)
THEN
    CollEntry := NIL
ELSE
    BEGIN
    CollEntry := @ObjCollGlobPtr^.oglObjCollList_kb05^[colEntryIndex];
    IF  CollEntry^.objcLockTransIndex_kb05 <> cgg_nil_transindex
    THEN
        BEGIN
        (*vbegexcl (taskid, g08lock0 + k51tr_index_region(CollEntry^.objcLockTransIndex_kb05));*)
        k52acc_trans_entry (CollEntry^.objcLockTransIndex_kb05, LockTrans);
        (* check CollEntry^.objcLockTransIndex_kb05 = LockTrans^.teFirstCollLock_kb05 *)
        IF  LockTrans^.teState_kb05 = m_delete
        THEN
            (* Collision entry was invalid - trans is doing commit => try next *)
            CollEntry := NIL;
        (*vendexcl (taskid, g08lock0 + k51tr_index_region(CollEntry^.objcLockTransIndex_kb05));*)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52_GetNextHolder (taskid : tsp00_TaskId;
            ObjCollGlobPtr    : tkb05_ObjCollGlobPtr;
            VAR colEntryIndex : tgg00_TransIndex;
            VAR CollEntry     : tkb05_ObjCollEntryPtr;
            VAR transno       : tgg91_TransNo;
            VAR taskidOfTrans : tsp00_TaskId);
 
VAR
      LockTrans : tkb05_TransEntryPtr;
 
BEGIN
(* If CollEntry is returned with NIL no more entries can be found *)
IF  kb03Check.chkRegion_kb00
THEN
    g08check_excl (ObjCollGlobPtr^.oglOwnRegionId_kb05);
(*ENDIF*) 
IF  colEntryIndex = cgg_nil_transindex
THEN
    colEntryIndex := 1;
(*ENDIF*) 
CollEntry := NIL;
WHILE (CollEntry = NIL)
      AND
      (colEntryIndex <= k51glob.glTransEntries_kb05) DO
    BEGIN
    CollEntry := @ObjCollGlobPtr^.oglObjCollList_kb05^[colEntryIndex];
    IF  CollEntry^.objcLockTransIndex_kb05 = cgg_nil_transindex
    THEN
        BEGIN
        IF  NOT gg06IsZeroTrans (CollEntry^.objcLockTransId_kb05)
            OR gg06IsNilOid (CollEntry^.objcOid_kb05)
            OR (cgg_nil_transindex = CollEntry^.objcFirstReq_kb05)
        THEN
            BEGIN
            colEntryIndex   := colEntryIndex + 1;
            CollEntry       := NIL
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        transno := CollEntry^.objcLockTransId_kb05;
        k52acc_trans_entry (CollEntry^.objcLockTransIndex_kb05, LockTrans);
        IF  (LockTrans^.teState_kb05 <> m_delete)
            AND
            (transno = LockTrans^.teWriteTransId_kb05)
        THEN
            taskidOfTrans := LockTrans^.teTaskId_kb05
        ELSE
            BEGIN
            (* Collision entry was invalid - trans is doing commit => try next *)
            colEntryIndex := colEntryIndex + 1;
            CollEntry     := NIL;
            END;
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      kb52_ReadTaskOfRequestor (ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
            reqEntryIndex : tgg00_TransIndex) : tsp00_TaskId;
 
BEGIN
kb52_ReadTaskOfRequestor := ObjCollGlobPtr^.oglObjReqList_kb05^[reqEntryIndex].objrWaitTaskId_kb05;
END;
 
(*------------------------------*) 
 
FUNCTION
      k52GetCollisionEntry (taskid : tsp00_TaskId;
            VAR entryNumber   : tgg00_TransIndex;
            VAR colEntryIndex : tgg00_TransIndex;
            VAR reqEntryIndex : tgg00_TransIndex;
            VAR fileno        : tsp00_C8;
            VAR oid           : tgg00_OidSpace;
            VAR transno       : tgg91_TransNo;
            VAR taskidOfTrans : tsp00_TaskId;
            VAR isHolder      : boolean;
            VAR isShareReq    : boolean) : boolean;
 
VAR
      ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
      CollEntry      : tkb05_ObjCollEntryPtr;
      ReqTrans       : tkb05_TransEntryPtr;
      loop           : integer;
      retry          : boolean;
      i              : integer;
 
BEGIN
(* If true is returned the info is valid, if false is returned there is no more to read *)
entryNumber := entryNumber + 1;
CollEntry   := NIL;
REPEAT
    BEGIN
    retry := false;
    IF  entryNumber > k51glob.glTransEntries_kb05
    THEN
        BEGIN
        IF  NOT gg06IsDummyTrans(transno)
        THEN
            BEGIN
            gg06SetDummyTrans(transno);
            gg06SetNilOid    (oid);
            FOR i := 1 TO sizeof (fileno) DO
                fileno[i]     := '\00';
            (*ENDFOR*) 
            isHolder      := true;
            isShareReq    := false;  (*PTS 1135178*)
            taskidOfTrans := cgg_nil_pid;
            CollEntry := @entryNumber;(*print overflow entry*)
            END;
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        k52begexcl_objcoll (taskid, ObjCollGlobPtr);
        isHolder := reqEntryIndex = cgg_nil_transindex;
        IF  isHolder
        THEN
            BEGIN
            kb52_GetNextHolder (taskid, ObjCollGlobPtr, colEntryIndex, CollEntry, transno, taskidOfTrans);
            IF  CollEntry <> NIL
            THEN
                BEGIN
                fileno        := CollEntry^.objcObjContHndl_kb05;
                oid           := CollEntry^.objcOid_kb05;
                reqEntryIndex := CollEntry^.objcFirstReq_kb05;
                IF  gg06IsZeroTrans (CollEntry^.objcLockTransId_kb05)
                THEN
                    retry := true
                ELSE
                    BEGIN
                    IF  reqEntryIndex = cgg_nil_transindex
                    THEN
                        colEntryIndex := colEntryIndex + 1;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END
        ELSE
            BEGIN
            kb52_GetCollEntry (taskid, ObjCollGlobPtr, colEntryIndex, CollEntry);
            IF  CollEntry = NIL
            THEN
                BEGIN
                (* while searching requests the coll entry became invalid so get next holder *)
                isHolder := true;
                kb52_GetNextHolder (taskid, ObjCollGlobPtr, colEntryIndex, CollEntry, transno, taskidOfTrans);
                IF  CollEntry <> NIL
                THEN
                    BEGIN
                    fileno        := CollEntry^.objcObjContHndl_kb05;
                    oid           := CollEntry^.objcOid_kb05;
                    reqEntryIndex := CollEntry^.objcFirstReq_kb05;
                    IF  gg06IsZeroTrans (CollEntry^.objcLockTransId_kb05)
                    THEN
                        retry := true
                    ELSE
                        BEGIN
                        IF  reqEntryIndex = cgg_nil_transindex
                        THEN
                            colEntryIndex := colEntryIndex + 1;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END
            ELSE
                BEGIN
                (*  go on with requests *)
                IF  reqEntryIndex <> cgg_nil_transindex
                THEN
                    (* next request found *)
                    BEGIN
                    k52acc_trans_entry (ObjCollGlobPtr^.oglObjReqList_kb05^[reqEntryIndex].objrOwnIndex_kb05, ReqTrans);
                    (*PTS 1135178*)
                    isShareReq    := ObjCollGlobPtr^.oglObjReqList_kb05^[reqEntryIndex].objrOmsShareLockReq;
                    transno       := ObjCollGlobPtr^.oglObjReqList_kb05^[reqEntryIndex].objrReqTransId_kb05;
                    IF  (ReqTrans^.teState_kb05 <> m_delete)
                        AND
                        (transno = ReqTrans^.teWriteTransId_kb05)
                    THEN
                        BEGIN
                        loop := 1000;
                        REPEAT
                            BEGIN
                            taskidOfTrans := kb52_ReadTaskOfRequestor(ObjCollGlobPtr, reqEntryIndex);
                            loop          := loop - 1;
                            END
                        UNTIL
                            vIsValidTask(taskidOfTrans) OR (loop = 0);
                        (*ENDREPEAT*) 
                        reqEntryIndex := ObjCollGlobPtr^.oglObjReqList_kb05^[reqEntryIndex].objrNextReq_kb05;
                        IF  reqEntryIndex = cgg_nil_transindex
                        THEN
                            colEntryIndex := colEntryIndex + 1;
                        (*ENDIF*) 
                        END
                    ELSE
                        BEGIN
                        (* No more requests, try to find next holder *)
                        CollEntry     := NIL;
                        colEntryIndex := colEntryIndex + 1;
                        isHolder      := true;
                        kb52_GetNextHolder (taskid, ObjCollGlobPtr, colEntryIndex, CollEntry, transno, taskidOfTrans);
                        IF  CollEntry <> NIL
                        THEN
                            BEGIN
                            fileno := CollEntry^.objcObjContHndl_kb05;
                            oid    := CollEntry^.objcOid_kb05;
                            reqEntryIndex := CollEntry^.objcFirstReq_kb05;
                            IF  gg06IsZeroTrans (CollEntry^.objcLockTransId_kb05)
                            THEN
                                retry := true
                            ELSE
                                BEGIN
                                IF  reqEntryIndex = cgg_nil_transindex
                                THEN
                                    colEntryIndex := colEntryIndex + 1;
                                (*ENDIF*) 
                                END;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END
                ELSE
                    BEGIN
                    (* No more requests, try to find next holder *)
                    colEntryIndex := colEntryIndex + 1;
                    isHolder      := true;
                    kb52_GetNextHolder (taskid, ObjCollGlobPtr, colEntryIndex, CollEntry, transno, taskidOfTrans);
                    IF  CollEntry <> NIL
                    THEN
                        BEGIN
                        fileno := CollEntry^.objcObjContHndl_kb05;
                        oid    := CollEntry^.objcOid_kb05;
                        reqEntryIndex := CollEntry^.objcFirstReq_kb05;
                        IF  gg06IsZeroTrans (CollEntry^.objcLockTransId_kb05)
                        THEN
                            retry := true
                        ELSE
                            BEGIN
                            IF  reqEntryIndex = cgg_nil_transindex
                            THEN
                                colEntryIndex := colEntryIndex + 1;
                            (*ENDIF*) 
                            END;
                        (*ENDIF*) 
                        END;
                    (*ENDIF*) 
                    END;
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        k52endexcl_objcoll (taskid, ObjCollGlobPtr);
        END;
    (*ENDIF*) 
    END
UNTIL
    (NOT retry);
(*ENDREPEAT*) 
k52GetCollisionEntry := CollEntry <> NIL;
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52show_lock (VAR m : tgg00_MessBlock);
 
VAR
      Show : t_Show;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
IF  (m.mb_type2 <> mm_lock       ) AND
    (m.mb_type2 <> mm_participant) AND
    (m.mb_type2 <> mm_subtrans   )
THEN
    kb52init_show (m, Show)
ELSE
    Show.shwRecCount := 0;
(*ENDIF*) 
CASE m.mb_type2 OF
    mm_config:
        kb52show_config (m.mb_trns^, m.mb_qual^.mtree, Show);
    mm_lock:
        BEGIN
        kb52select_tables (m.mb_trns^, m.mb_qual^.mtree, Show.shwRecCount);
        IF  m.mb_trns^.trError_gg00 = e_ok
        THEN
            kb52sel_obj_collisions (m.mb_trns^, m.mb_qual^.mtree, Show.shwRecCount)
        (*ENDIF*) 
        END;
    mm_object:
        kb52sel_consist_views (m.mb_trns^, m.mb_qual^.mtree, Show.shwRecCount);
    mm_running_cmds:
        BEGIN
        a101_ResetGroupedTempFile (m.mb_trns^, m.mb_qual^.mtree,
              ttfnSaveScheme_egg00);
        IF  m.mb_trns^.trError_gg00 = e_ok
        THEN
            kb52show_runing_cmds (m.mb_trns^, m.mb_qual^.mtree);
        (*ENDIF*) 
        END;
    mm_subtrans:
        kb52select_trans (m.mb_trns^, m.mb_qual^.mtree, Show.shwRecCount);
    mm_user:
        BEGIN
        a101_ResetGroupedTempFile (m.mb_trns^, m.mb_qual^.mtree,
              ttfnSaveScheme_egg00);
        IF  m.mb_trns^.trError_gg00 = e_ok
        THEN
            kb52user_show (m.mb_trns^, m.mb_qual^.mtree, Show.shwRecCount)
        (*ENDIF*) 
        END;
    OTHERWISE
        m.mb_trns^.trError_gg00 := e_not_implemented
    END;
(*ENDCASE*) 
m.mb_qual_len := 0;
m.mb_data_len := 0;
m.mb_type2    := mm_nil;
IF  m.mb_trns^.trError_gg00 <> e_ok
THEN
    m.mb_type := m_return_error
ELSE
    BEGIN
    m.mb_type     := m_return_result;
    m.mb_struct   := mbs_tree_id;
    m.mb_qual_len := FILE_ID_MXGG00;
    m.mb_data_len := 4;
    s20int4_to_buf (Show.shwRecCount, m.mb_data^.mbp_buf, 1)
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      k52used_items_of_region (VAR RegionGlob : tkb05_RegionGlob): tsp00_Int4;
 
VAR
      ItemsUsed : tsp00_Int4;
 
BEGIN
ItemsUsed :=
      k51glob.glSupplyItemsPerRegion_kb05 - RegionGlob.rglFreeItems_kb05
      +
      RegionGlob.rglExtentItems_kb05      - RegionGlob.rglExtentFreeItems_kb05;
(**)
IF  (ItemsUsed > k51glob.glMaxItemsPerRegion_kb05) OR (ItemsUsed < 0)
THEN
    BEGIN
    k52used_items_of_region := k51glob.glMaxItemsPerRegion_kb05;
    k52x_loop_error ('k52used_items_of_region ', ItemsUsed)
    END
ELSE
    k52used_items_of_region := ItemsUsed
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      k52used_trans_of_region (VAR RegionGlob : tkb05_RegionGlob): tsp00_Int4;
 
VAR
      TransUsed : tsp00_Int4;
 
BEGIN
TransUsed :=
      k51glob.glTransEntriesPerRegion_kb05 - RegionGlob.rglTransGlob_kb05^.trFreeEntries_kb05;
(* *)
IF  (TransUsed > k51glob.glTransEntriesPerRegion_kb05) OR (TransUsed < 0)
THEN
    k52used_trans_of_region := k51glob.glTransEntriesPerRegion_kb05
ELSE
    k52used_trans_of_region := TransUsed
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52x_item_error (
            msg            : tsp00_C24;
            ItemKind       : tkb05_ItemKind);
 
BEGIN
IF  kb03Check.chkLock_kb00 OR true
THEN
    g01abort (kb52c1XCheck_csp03, csp3_n_lock, msg, ord (ItemKind))
ELSE
    g01opmsg (sp3p_console, sp3m_error, kb52c1XCheck_csp03, csp3_n_lock, msg, ord (ItemKind))
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52x_loop_error (
            msg            : tsp00_C24;
            error_no       : tsp00_Int4);
 
BEGIN
IF  kb03Check.chkLock_kb00 OR true
THEN
    g01abort (kb52c2XCheck_csp03, csp3_n_lock, msg, error_no)
ELSE
    g01opmsg (sp3p_console, sp3m_error, kb52c2XCheck_csp03, csp3_n_lock, msg, error_no)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_hashlist (
            VAR HostFile : tgg00_VfFileref;
            DumpMark    : tsp00_C8;
            DumpCode    : tsp00_Int2;
            HashListNo  : tsp00_Int2;
            HashList    : tkb05_RowHashPtr;
            ListSize    : tsp00_Int4;
            VAR buf     : tsp00_Page;
            VAR OutPno  : tsp00_Int4;
            VAR OutPos  : integer;
            VAR HostErr : tsp00_VfReturn;
            VAR ErrText : tsp00_ErrText);
 
CONST
      ITEMS_PER_DUMP_ENTRY = 20;
 
VAR
      Found       : boolean;
      MoveErr     : tgg00_BasisError;  (* dummy error *)
      CurrHash    : tsp00_Int4;
      i           : tsp00_Int4;
      i2          : tsp00_IntMapC2;
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
CurrHash := 1;
WHILE (HostErr = vf_ok) AND (CurrHash <= ListSize) DO
    BEGIN
    kb52dump_header (HostFile,
          ITEMS_PER_DUMP_ENTRY *
          sizeof (tsp00_Int2) + ITEMS_PER_DUMP_ENTRY * (sizeof (tsp00_Int4) + sizeof (tsp00_ObjAddr)),
          DumpMark, DumpCode,
          buf, OutPno, OutPos, HostErr, ErrText);
    i2.mapInt_sp00 := HashListNo;
    buf [OutPos  ] := i2.mapC2_sp00 [1];
    buf [OutPos+1] := i2.mapC2_sp00 [2];
    OutPos         := OutPos + 2;
    i := 1;
    WHILE (HostErr = vf_ok) AND (i <= ITEMS_PER_DUMP_ENTRY) DO
        BEGIN
        Found := false;
        WHILE (CurrHash <= ListSize) AND NOT Found DO
            IF  HashList^[CurrHash] = NIL
            THEN
                CurrHash := CurrHash + 1
            ELSE
                Found := true;
            (*ENDIF*) 
        (*ENDWHILE*) 
        IF  CurrHash <= ListSize
        THEN
            BEGIN
            s20int4_to_buf_1 (CurrHash, buf, OutPos);
            UnivItemPtr.uiRowLock_kb05 := HashList^[CurrHash]
            END
        ELSE
            BEGIN
            s20int4_to_buf_1 (0, buf, OutPos);
            UnivItemPtr.uiRowLock_kb05 := NIL
            END;
        (*ENDIF*) 
        OutPos  := OutPos + 4;
        MoveErr := e_ok;
        SAPDB_PascalMove ('VKB52 ',   9,    
              sizeof (UnivItemPtr), sizeof (buf),
              @UnivItemPtr, 1, @buf, OutPos, sizeof (UnivItemPtr), MoveErr);
        OutPos   := OutPos + sizeof (UnivItemPtr);
        CurrHash := CurrHash + 1;
        i        := i + 1
        END
    (*ENDWHILE*) 
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_header (
            VAR HostFile : tgg00_VfFileref;
            DumpLen     : integer;
            DumpMark    : tsp00_C8;
            DumpCode    : tsp00_Int2;
            VAR buf     : tsp00_Page;
            VAR OutPno  : tsp00_Int4;
            VAR OutPos  : integer;
            VAR HostErr : tsp00_VfReturn;
            VAR ErrText : tsp00_ErrText);
 
CONST
      Header_c = 10;
 
VAR
      i2        : tsp00_IntMapC2;
      MoveError : tgg00_BasisError; (* dummy error *)
 
BEGIN
MoveError := e_ok;
IF  (OutPos - 1 + Header_c + DumpLen > sizeof (buf))
THEN
    g01new_dump_page (HostFile, buf, OutPno, OutPos, HostErr, ErrText);
(*ENDIF*) 
IF  HostErr = vf_ok
THEN
    BEGIN
    SAPDB_PascalMove ('VKB52 ',  10,    
          sizeof (DumpMark), sizeof (buf),
          @DumpMark, 1, @buf, OutPos, sizeof (DumpMark), MoveError);
    OutPos         := OutPos + sizeof (DumpMark);
    i2.mapInt_sp00 := DumpCode;
    buf [OutPos  ] := i2.mapC2_sp00 [1];
    buf [OutPos+1] := i2.mapC2_sp00 [2];
    OutPos         := OutPos + 2
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_item (
            VAR UnivItemPtr : tkb05_UnivItemPtr;
            ItemSize   : integer;
            VAR buf    : tsp00_Page;
            VAR OutPos : integer);
 
VAR
      MoveErr : tgg00_BasisError; (* dummy error *)
 
BEGIN
MoveErr := e_ok;
SAPDB_PascalMove ('VKB52 ',  11,    
      sizeof (UnivItemPtr), sizeof(buf),
      @UnivItemPtr, 1, @buf, OutPos, sizeof (UnivItemPtr), MoveErr);
MoveErr := e_ok; (* ignore error *)
OutPos  := OutPos + sizeof (UnivItemPtr);
SAPDB_PascalMove ('VKB52 ',  12,    
      ItemSize, sizeof (buf),
      @UnivItemPtr.uiSupplyItem_kb05^, 1, @buf, OutPos, ItemSize, MoveErr);
MoveErr := e_ok; (* ignore error *)
OutPos  := OutPos + ItemSize
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_obj_collision (
            VAR HostFile : tgg00_VfFileref;
            VAR buf     : tsp00_Page;
            VAR OutPno  : tsp00_Int4;
            VAR OutPos  : integer;
            VAR HostErr : tsp00_VfReturn;
            VAR ErrText : tsp00_ErrText);
 
VAR
      MoveErr       : tgg00_BasisError; (* dummy error *)
      ReqItemCnt    : tsp00_Int4;
      CurrCollision : tgg00_TransIndex;
      CurrReq       : tgg00_TransIndex;
      ObjCollEntry  : tkb05_ObjCollEntryPtr;
      ObjReqEntry   : tkb05_ObjReqEntryPtr;
 
BEGIN
CurrCollision := 1;
ReqItemCnt    := 0;
WHILE (HostErr = vf_ok) AND (CurrCollision <= k51glob.glTransEntries_kb05) DO
    BEGIN
    k52acc_objcoll_entry (k51glob.glObjCollGlob_kb05^, CurrCollision, ObjCollEntry);
    IF  NOT gg06IsNilOid (ObjCollEntry^.objcOid_kb05)
    THEN
        BEGIN
        kb52dump_header (HostFile, sizeof (ObjCollEntry^),
              DUMPMARK_OBJ_COLL, DUMPCODE_OBJ_COLL, buf, OutPno, OutPos, HostErr, ErrText);
        SAPDB_PascalMove ('VKB52 ',  13,    
              sizeof (ObjCollEntry^), sizeof (buf),
              @ObjCollEntry^, 1, @buf, OutPos, sizeof (ObjCollEntry^), MoveErr);
        OutPos     := OutPos + sizeof (ObjCollEntry^);
        MoveErr    := e_ok; (* ignore error *)
        ReqItemCnt := 0;
        CurrReq    := ObjCollEntry^.objcFirstReq_kb05;
        WHILE (HostErr = vf_ok) AND (CurrReq <> cgg_nil_transindex)
              AND (ReqItemCnt < k51glob.glTransEntries_kb05) DO
            BEGIN
            k52acc_objreq_entry (k51glob.glObjCollGlob_kb05^, CurrReq, ObjReqEntry);
            kb52dump_header (HostFile, sizeof (ObjReqEntry^),
                  DUMPMARK_REQ_TRANS, DUMPCODE_REQ_TRANS, buf, OutPno, OutPos, HostErr, ErrText);
            SAPDB_PascalMove ('VKB52 ',  14,    
                  sizeof (ObjReqEntry^), sizeof (buf),
                  @ObjReqEntry^, 1, @buf, OutPos, sizeof (ObjReqEntry^), MoveErr);
            OutPos     := OutPos + sizeof (ObjReqEntry^);
            MoveErr    := e_ok; (* ignore error *)
            CurrReq    := ObjReqEntry^.objrNextReq_kb05;
            ReqItemCnt := ReqItemCnt + 1
            END;
        (*ENDWHILE*) 
        IF  ReqItemCnt > k51glob.glTransEntries_kb05
        THEN
            kb52x_dump_loop_error ('kb52dump_obj_collision  ', 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    CurrCollision := CurrCollision + 1
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_open_trans_list (
            VAR HostFile   : tgg00_VfFileref;
            FirstOpenTrans : tkb05_OpenTransPtr;
            ItemLimit      : tsp00_Int4;
            VAR buf        : tsp00_Page;
            VAR OutPno     : tsp00_Int4;
            VAR OutPos     : integer;
            VAR HostErr    : tsp00_VfReturn;
            VAR ErrText    : tsp00_ErrText);
 
VAR
      ItemCnt     : tsp00_Int4;
      CurrOpen    : tkb05_OpenTransPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
CurrOpen := FirstOpenTrans;
ItemCnt  := 0;
WHILE (HostErr  = vf_ok) AND (CurrOpen <> NIL) AND (ItemCnt <= ItemLimit) DO
    BEGIN
    kb52dump_header (HostFile,
          sizeof (tkb05_OpenTransPtr) + sizeof (tkb05_OpenTrans),
          DUMPMARK_OPEN_TRANS, DUMPCODE_OPEN_TRANS,
          buf, OutPno, OutPos, HostErr, ErrText);
    IF  HostErr = vf_ok
    THEN
        BEGIN
        UnivItemPtr.uiOpenTrans_kb05 := CurrOpen;
        kb52dump_item (UnivItemPtr, sizeof (CurrOpen^), buf, OutPos)
        END;
    (*ENDIF*) 
    ItemCnt  := ItemCnt + 1;
    CurrOpen := CurrOpen^.openNext_kb05
    END;
(*ENDWHILE*) 
IF  ItemCnt > ItemLimit
THEN
    kb52x_dump_loop_error ('kb52dump_open_trans_list', 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_req_list (
            VAR HostFile : tgg00_VfFileref;
            FirstReq    : tkb05_ReqPtr;
            ItemLimit   : tsp00_Int4;
            VAR buf     : tsp00_Page;
            VAR OutPno  : tsp00_Int4;
            VAR OutPos  : integer;
            VAR HostErr : tsp00_VfReturn;
            VAR ErrText : tsp00_ErrText);
 
VAR
      ItemCnt     : tsp00_Int4;
      CurrReq     : tkb05_ReqPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
CurrReq := FirstReq;
ItemCnt := 0;
WHILE (HostErr  = vf_ok) AND (CurrReq <> NIL) AND (ItemCnt <= ItemLimit) DO
    BEGIN
    kb52dump_header (HostFile,
          sizeof (tkb05_ReqPtr) + sizeof (tkb05_Req),
          DUMPMARK_REQ, DUMPCODE_REQ,
          buf, OutPno, OutPos, HostErr, ErrText);
    IF  HostErr = vf_ok
    THEN
        BEGIN
        UnivItemPtr.uiReq_kb05 := CurrReq;
        kb52dump_item (UnivItemPtr, sizeof (CurrReq^), buf, OutPos)
        END;
    (*ENDIF*) 
    ItemCnt := ItemCnt + 1;
    CurrReq := CurrReq^.rqNextReq_kb05
    END;
(*ENDWHILE*) 
IF  ItemCnt > ItemLimit
THEN
    kb52x_dump_loop_error ('kb52dump_req_list       ', 1)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_rows (
            VAR HostFile : tgg00_VfFileref;
            VAR buf     : tsp00_Page;
            VAR OutPno  : tsp00_Int4;
            VAR OutPos  : integer;
            VAR HostErr : tsp00_VfReturn;
            VAR ErrText : tsp00_ErrText);
 
VAR
      CurrRowRegion    : tkb05_RegionNo;
      ItemCnt          : tsp00_Int4;
      ItemLimit        : tsp00_Int4;
      CurrHash         : tsp00_Int4;
      CurrRow          : tkb05_RowLockPtr;
      UnivItemPtr      : tkb05_UnivItemPtr;
      RowRegionGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
CurrRowRegion := 1;
WHILE (HostErr = vf_ok) AND (CurrRowRegion <= k51glob.glRowRegions_kb05) DO
    BEGIN
    RowRegionGlobPtr := k51glob.glRegionGlob_kb05^
          [k51glob.glTransRegions_kb05 + k51glob.glTabRegions_kb05 + CurrRowRegion];
    ItemLimit := k52used_items_of_region (RowRegionGlobPtr^);
    CurrHash  := 1;
    WHILE (HostErr = vf_ok) AND (CurrHash <= k51glob.glRowHashEntriesPerRegion_kb05) DO
        BEGIN
        IF  RowRegionGlobPtr^.rglRowHash_kb05 = NIL
        THEN
            CurrRow := NIL
        ELSE
            CurrRow := RowRegionGlobPtr^.rglRowHash_kb05^[CurrHash];
        (*ENDIF*) 
        ItemCnt := 0;
        WHILE (HostErr = vf_ok) AND (CurrRow <> NIL) AND (ItemCnt <= ItemLimit) DO
            BEGIN
            kb52dump_header (HostFile,
                  sizeof (tkb05_RowLockPtr) + sizeof (tkb05_RowLock),
                  DUMPMARK_ROW_LOCK, DUMPCODE_ROW_LOCK,
                  buf, OutPno, OutPos, HostErr, ErrText);
            IF  HostErr = vf_ok
            THEN
                BEGIN
                UnivItemPtr.uiRowLock_kb05 := CurrRow;
                kb52dump_item (UnivItemPtr, sizeof (CurrRow^), buf, OutPos)
                END;
            (*ENDIF*) 
            IF  (HostErr = vf_ok) AND (CurrRow^.rlRowIdItem_kb05 <> NIL)
            THEN
                BEGIN
                kb52dump_header (HostFile,
                      sizeof(tkb05_RowIdItemPtr) + sizeof(tkb05_RowIdItem),
                      DUMPMARK_ROWID, DUMPCODE_ROWID,
                      buf, OutPno, OutPos, HostErr, ErrText);
                IF  HostErr = vf_ok
                THEN
                    BEGIN
                    UnivItemPtr.uiRowIdItem_kb05 := CurrRow^.rlRowIdItem_kb05;
                    kb52dump_item (UnivItemPtr, sizeof (CurrRow^.rlRowIdItem_kb05^), buf, OutPos)
                    END;
                (*ENDIF*) 
                ItemCnt := ItemCnt + 1
                END;
            (*ENDIF*) 
            IF  (HostErr = vf_ok) AND (CurrRow^.rlFirstReqRow_kb05 <> NIL)
            THEN
                kb52dump_req_list (HostFile, CurrRow^.rlFirstReqRow_kb05,
                      ItemLimit, buf, OutPno, OutPos, HostErr, ErrText);
            (*ENDIF*) 
            ItemCnt := ItemCnt + 1;
            CurrRow := CurrRow^.rlNextHashRow_kb05
            END;
        (*ENDWHILE*) 
        IF  ItemCnt > ItemLimit
        THEN
            kb52x_dump_loop_error ('kb52dump_rows           ', 1);
        (*ENDIF*) 
        CurrHash := CurrHash + 1
        END;
    (*ENDWHILE*) 
    CurrRowRegion := CurrRowRegion + 1
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_share_locks (
            VAR HostFile : tgg00_VfFileref;
            VAR buf     : tsp00_Page;
            VAR OutPno  : tsp00_Int4;
            VAR OutPos  : integer;
            VAR HostErr : tsp00_VfReturn;
            VAR ErrText : tsp00_ErrText);
 
VAR
      MoveErr            : tgg00_BasisError; (* dummy error *)
      CurrHashList       : tsp00_Int4;
      NumHashLists       : tsp00_Int4;
      CurrShrLockCtrlPtr : tkb05_ObjShareLockCtrlPtr;
      CurrShrLockPtr     : tkb05_ObjShareLockPtr;
 
BEGIN
CurrHashList  := 0;
NumHashLists  := k501GetHashHdrSize;
WHILE (HostErr = vf_ok) AND (CurrHashList < NumHashLists) DO
    BEGIN
    CurrShrLockCtrlPtr := k501GetHashHdrList( CurrHashList );
    WHILE ( CurrShrLockCtrlPtr <> NIL ) DO
        BEGIN
        kb52dump_header (HostFile, sizeof (CurrShrLockCtrlPtr^),
              DUMPMARK_SHR_LCKCTRL, DUMPCODE_SHR_LCKCTRL, buf, OutPno, OutPos, HostErr, ErrText);
        SAPDB_PascalMove ('VKB52 ',  15,    
              sizeof (CurrShrLockCtrlPtr^), sizeof (buf),
              @CurrShrLockCtrlPtr^, 1, @buf, OutPos, sizeof (CurrShrLockCtrlPtr^), MoveErr);
        OutPos     := OutPos + sizeof (CurrShrLockCtrlPtr^);
        MoveErr    := e_ok; (* ignore error *)
        CurrShrLockPtr := CurrShrLockCtrlPtr^.objsObjShareLock_kb05;
        WHILE ( CurrShrLockPtr <> NIL ) DO
            BEGIN
            kb52dump_header (HostFile, sizeof (CurrShrLockPtr^),
                  DUMPMARK_SHR_LOCK, DUMPCODE_SHR_LOCK, buf, OutPno, OutPos, HostErr, ErrText);
            SAPDB_PascalMove ('VKB52 ',  16,    
                  sizeof (CurrShrLockPtr^), sizeof (buf),
                  @CurrShrLockPtr^, 1, @buf, OutPos, sizeof (CurrShrLockPtr^), MoveErr);
            OutPos     := OutPos + sizeof (CurrShrLockPtr^);
            MoveErr    := e_ok; (* ignore error *)
            CurrShrLockPtr := CurrShrLockPtr^.objrNxtShareLock_kb05;
            END;
        (*ENDWHILE*) 
        CurrShrLockCtrlPtr := CurrShrLockCtrlPtr^.objsNxtShareLockCtrl_kb05;
        END;
    (*ENDWHILE*) 
    k501UnlockHashHdrList( CurrHashList );
    CurrHashList := CurrHashList + 1;
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_tables_and_obj_trans (
            VAR HostFile : tgg00_VfFileref;
            VAR buf     : tsp00_Page;
            VAR OutPno  : tsp00_Int4;
            VAR OutPos  : integer;
            VAR HostErr : tsp00_VfReturn;
            VAR ErrText : tsp00_ErrText);
 
VAR
      CurrTabRegion    : tkb05_RegionNo;
      DumpCode         : tsp00_Int2;
      EntrySize        : integer;
      ItemCnt          : tsp00_Int4;
      ItemLimit        : tsp00_Int4;
      CurrHash         : tsp00_Int4;
      DumpMark         : tsp00_C8;
      CurrTab          : tkb05_TabLockPtr;
      UnivItemPtr      : tkb05_UnivItemPtr;
      TabRegionGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
CurrTabRegion := 1;
WHILE (HostErr = vf_ok) AND (CurrTabRegion <= k51glob.glTabRegions_kb05) DO
    BEGIN
    TabRegionGlobPtr := k51glob.glRegionGlob_kb05^ [k51glob.glTransRegions_kb05 + CurrTabRegion];
    ItemLimit        := k52used_items_of_region (TabRegionGlobPtr^);
    CurrHash         := 1;
    WHILE (HostErr = vf_ok) AND (CurrHash <= k51glob.glTabHashEntriesPerRegion_kb05) DO
        BEGIN
        IF  TabRegionGlobPtr^.rglTabHash_kb05 = NIL
        THEN
            CurrTab := NIL
        ELSE
            CurrTab := TabRegionGlobPtr^.rglTabHash_kb05^[CurrHash];
        (*ENDIF*) 
        ItemCnt := 0;
        WHILE (HostErr = vf_ok) AND (CurrTab <> NIL) AND (ItemCnt <= ItemLimit) DO
            BEGIN
            CASE CurrTab^.tlItemKind_kb05 OF
                ikConsistView_ekb05:
                    BEGIN
                    EntrySize := sizeof (tkb05_ConsistView);
                    DumpMark  := DUMPMARK_CONSIST_TR;
                    DumpCode  := DUMPCODE_CONSIST_TR;
                    END ;
                ikHashOpenTrans_ekb05:
                    BEGIN
                    EntrySize := sizeof (tkb05_HashOpenTrans);
                    DumpMark  := DUMPMARK_HASH_OPENTR;
                    DumpCode  := DUMPCODE_HASH_OPENTR;
                    END ;
                OTHERWISE
                    BEGIN
                    EntrySize := sizeof (tkb05_TabLock);
                    DumpMark  := DUMPMARK_TAB_LOCK;
                    DumpCode  := DUMPCODE_TAB_LOCK;
                    END
                END;
            (*ENDCASE*) 
            UnivItemPtr.uiTabLock_kb05 := CurrTab;
            kb52dump_header (HostFile,
                  sizeof (tkb05_TabLockPtr) + EntrySize, DumpMark, DumpCode,
                  buf, OutPno, OutPos, HostErr, ErrText);
            IF  HostErr = vf_ok
            THEN
                kb52dump_item (UnivItemPtr, EntrySize, buf, OutPos);
            (*ENDIF*) 
            IF  CurrTab^.tlItemKind_kb05 = ikTabLock_ekb05
            THEN
                BEGIN
                IF  (HostErr = vf_ok) AND (CurrTab^.tlFirstReqTab_kb05 <> NIL)
                THEN
                    kb52dump_req_list (HostFile, CurrTab^.tlFirstReqTab_kb05,
                          ItemLimit, buf, OutPno, OutPos, HostErr, ErrText);
                (*ENDIF*) 
                IF  (HostErr = vf_ok) AND (CurrTab^.tlFirstReqRow_kb05 <> NIL)
                THEN
                    kb52dump_req_list (HostFile, CurrTab^.tlFirstReqRow_kb05,
                          ItemLimit, buf, OutPno, OutPos, HostErr, ErrText);
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            IF  CurrTab^.tlItemKind_kb05 = ikConsistView_ekb05
            THEN
                BEGIN
                IF  (HostErr = vf_ok)
                    AND
                    (UnivItemPtr.uiConsistView_kb05^.cstFirstOpenTrans_kb05 <> NIL)
                THEN
                    kb52dump_open_trans_list (HostFile,
                          UnivItemPtr.uiConsistView_kb05^.cstFirstOpenTrans_kb05,
                          ItemLimit, buf, OutPno, OutPos, HostErr, ErrText)
                (*ENDIF*) 
                END;
            (*ENDIF*) 
            ItemCnt := ItemCnt + 1;
            CurrTab := CurrTab^.tlNextHashTab_kb05
            END;
        (*ENDWHILE*) 
        IF  ItemCnt > ItemLimit
        THEN
            kb52x_dump_loop_error ('kb52dump_tables_and_obj_', 1);
        (*ENDIF*) 
        CurrHash := CurrHash + 1
        END;
    (*ENDWHILE*) 
    CurrTabRegion := CurrTabRegion + 1
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52dump_trans_tables (
            VAR HostFile : tgg00_VfFileref;
            ThisTrans   : tkb05_TransEntryPtr;
            VAR buf     : tsp00_Page;
            VAR OutPno  : tsp00_Int4;
            VAR OutPos  : integer;
            VAR HostErr : tsp00_VfReturn;
            VAR ErrText : tsp00_ErrText);
 
VAR
      ItemLimit   : tsp00_Int4;
      RowItemCnt  : tsp00_Int4;
      TabItemCnt  : tsp00_Int4;
      CurrTab     : tkb05_TabTransPtr;
      CurrRow     : tkb05_RowTransPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
ItemLimit  := k52used_items_of_region (k51glob.glRegionGlob_kb05^[ThisTrans^.teOwnRegion_kb05]^);
TabItemCnt := 0;
CurrTab    := ThisTrans^.teFirstTab_kb05;
WHILE (HostErr = vf_ok) AND (CurrTab <> NIL) AND (TabItemCnt <= ItemLimit) DO
    BEGIN
    kb52dump_header (HostFile,
          sizeof (tkb05_TabTransPtr) + sizeof (tkb05_TabTrans),
          DUMPMARK_TAB_TRANS, DUMPCODE_TAB_TRANS,
          buf, OutPno, OutPos, HostErr, ErrText);
    IF  HostErr = vf_ok
    THEN
        BEGIN
        UnivItemPtr.uiTabTrans_kb05 := CurrTab;
        kb52dump_item (UnivItemPtr, sizeof (CurrTab^), buf, OutPos);
        RowItemCnt := 0;
        CurrRow    := CurrTab^.ttFirstRow_kb05;
        WHILE (HostErr = vf_ok) AND (CurrRow <> NIL) AND (RowItemCnt <= ItemLimit) DO
            BEGIN
            kb52dump_header (HostFile,
                  sizeof (tkb05_RowTransPtr) + sizeof (tkb05_RowTrans),
                  DUMPMARK_ROW_TRANS, DUMPCODE_ROW_TRANS,
                  buf, OutPno, OutPos, HostErr, ErrText);
            IF  HostErr = vf_ok
            THEN
                BEGIN
                UnivItemPtr.uiRowTrans_kb05 := CurrRow;
                kb52dump_item (UnivItemPtr, sizeof (CurrRow^), buf, OutPos)
                END;
            (*ENDIF*) 
            RowItemCnt := RowItemCnt + 1;
            CurrRow    := CurrRow^.rtNextRow_kb05
            END;
        (*ENDWHILE*) 
        IF  RowItemCnt > ItemLimit
        THEN
            kb52x_dump_loop_error ('kb52dump_trans_tables   ', 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    TabItemCnt := TabItemCnt + 1;
    CurrTab    := CurrTab^.ttNextTab_kb05
    END;
(*ENDWHILE*) 
IF  TabItemCnt > ItemLimit
THEN
    kb52x_dump_loop_error ('kb52dump_trans_tables   ', 2)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52init_show (
            VAR m          : tgg00_MessBlock;
            VAR Show       : t_Show);
 
VAR
      i : integer;
 
BEGIN
Show.shwInfoLen  := 0;
Show.shwRecCount := 0;
IF  g01unicode
THEN
    BEGIN
    Show.shwHostCode := csp_unicode;
    Show.shwCharSize := 2
    END
ELSE
    BEGIN
    Show.shwCharSize := 1;
    Show.shwHostCode := csp_ascii
    END;
(*ENDIF*) 
SAPDB_PascalFill ('VKB52 ',  17,    
      sizeof (Show.shwBlankRec), @Show.shwBlankRec, 1,
      sizeof (Show.shwBlankRec), bsp_c1, m.mb_trns^.trError_gg00);
m.mb_trns^.trError_gg00 := e_ok; (* always ok *)
WITH Show.shwBlankRec DO
    BEGIN
    shtKeyLen_kb05 := sizeof (shtKey_kb05);
    shtKey_kb05    := cgg_zero_c4;
    IF  m.mb_type2 = mm_config
    THEN
        BEGIN
        IF  Show.shwHostCode = csp_unicode
        THEN
            shtRecLen_kb05 := sizeof (shtHeader_kb05         )
                  +           sizeof (shtDefByte_kb05        )
                  +           sizeof (shtDescUnicode_kb05    )
                  +           sizeof (shtDefByte2Unicode_kb05)
                  +           sizeof (shtValUnicode_kb05     )
        ELSE
            shtRecLen_kb05 := sizeof (shtHeader_kb05  )
                  +           sizeof (shtDefByte_kb05 )
                  +           sizeof (shtDesc_kb05    )
                  +           sizeof (shtDefByte2_kb05)
                  +           sizeof (shtVal_kb05     );
        (*ENDIF*) 
        IF  Show.shwHostCode = csp_unicode
        THEN
            BEGIN
            shtDefByte_kb05         := csp_unicode_def_byte;
            shtDefByte2Unicode_kb05 := csp_unicode_def_byte;
            i := 1;
            WHILE i <= sizeof (shtDescUnicode_kb05) DO
                BEGIN
                shtDescUnicode_kb05 [i] := csp_unicode_mark;
                i := i + 2
                END;
            (*ENDWHILE*) 
            i := 1;
            WHILE i <= sizeof (shtValUnicode_kb05) DO
                BEGIN
                shtValUnicode_kb05 [i] := csp_unicode_mark;
                i := i + 2
                END
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END
    ELSE
        BEGIN
        shtRecLen_kb05 := sizeof (shtHeader_kb05 )
              +           sizeof (shtDefByte_kb05)
              +           sizeof (shtInfo_kb05   );
        IF  Show.shwHostCode <> csp_unicode
        THEN
            shtRecLen_kb05 := shtRecLen_kb05 - sizeof (shtInfo_kb05) DIV 2;
        (*ENDIF*) 
        IF  Show.shwHostCode = csp_unicode
        THEN
            BEGIN
            shtDefByte_kb05 := csp_unicode_def_byte;
            i := 1;
            WHILE i <= sizeof (shtInfo_kb05) DO
                BEGIN
                shtInfo_kb05 [i] := csp_unicode_mark;
                i := i + 2
                END
            (*ENDWHILE*) 
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52new_rec (VAR Show : t_Show);
 
BEGIN
WITH Show DO
    BEGIN
    shwRec     := shwBlankRec;
    shwInfoLen := 0;
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52object_to_sel_rec (
            TransIndex : tgg00_TransIndex;
            VAR oid : tgg00_OidSpace;
            VAR rec : tkb05_ShowRec);
 
VAR
      len       : integer;
      CurrTrans : tkb05_TransEntryPtr;
 
BEGIN
k52acc_trans_entry (TransIndex, CurrTrans);
kb52trans_to_sel_rec (CurrTrans, NOT CNSVIEW_IS_PROTECTED, rec); (*PTS 1137874 FF 15-Sep-2005*)
rec.shrLock_kb05.lshTabId_kb05     := cgg_zero_id;
rec.shrLock_kb05.lshRowId_kb05 [1] := ' ';
rec.shrLock_kb05.lshRowId_kb05 [2] := 'O';
rec.shrLock_kb05.lshRowId_kb05 [3] := 'I';
rec.shrLock_kb05.lshRowId_kb05 [4] := 'D';
rec.shrLock_kb05.lshRowId_kb05 [5] := ' ';
len := 5;
gg06OidToLine (oid, len, rec.shrLock_kb05.lshRowId_kb05);
rec.shrLock_kb05.lshRowIdLen_kb05   := len;
rec.shrLock_kb05.lshUndefRowId_kb05 := false;
FOR len := rec.shrLock_kb05.lshRowIdLen_kb05 + 1 TO sizeof (rec.shrLock_kb05.lshRowId_kb05) DO
    rec.shrLock_kb05.lshRowId_kb05 [len] := chr (0)
(*ENDFOR*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52param_to_rec (
            VAR t       : tgg00_TransContext;
            IsInt4      : boolean;
            VAR FileId  : tgg00_FileId;
            VAR Show    : t_Show;
            ParamDesc   : tkb05_ShtDesc;
            ParamIntVal : tsp00_Int4;
            ParamCntVal : tsp00_8ByteCounter);
 
VAR
      i     : integer;
      LnLen : integer;
      ln    : tsp00_Line;
 
BEGIN
t.trError_gg00 := e_ok;
kb52new_rec (Show);
LnLen := 0;
IF  (ParamDesc = MSG23_CLOSED_LIST) OR
    (ParamDesc = MSG24_SHUTDOWN   )
THEN
    BEGIN
    IF  ParamIntVal = ord (true)
    THEN
        g17sname_to_line ('TRUE        ', LnLen, ln)
    ELSE
        g17sname_to_line ('FALSE       ', LnLen, ln)
    (*ENDIF*) 
    END
ELSE
    IF  IsInt4
    THEN
        g17trimint4_to_line (ParamIntVal, LnLen, ln)
    ELSE
        g17counter_to_line (ParamCntVal, LnLen, ln);
    (*ENDIF*) 
(*ENDIF*) 
WITH Show DO
    IF  shwHostCode = csp_unicode
    THEN
        BEGIN
        FOR i := 1 TO sizeof (ParamDesc) DO
            shwRec.shtDescUnicode_kb05 [2 * i] := ParamDesc [i];
        (*ENDFOR*) 
        FOR i := 1 TO LnLen DO
            shwRec.shtValUnicode_kb05  [2 * i] := ln [i];
        (*ENDFOR*) 
        END
    ELSE
        BEGIN
        shwRec.shtDesc_kb05 := ParamDesc;
        FOR i := 1 TO LnLen DO
            shwRec.shtVal_kb05 [i] := ln [i]
        (*ENDFOR*) 
        END;
    (*ENDIF*) 
(*ENDWITH*) 
kb52write_show_rec (t, FileId, Show)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52sel_consist_views (
            VAR Trans    : tgg00_TransContext;
            VAR FileId   : tgg00_FileId;
            VAR RecCount : tsp00_Int4);
 
VAR
      CurrTabRegion     : tkb05_RegionNo;
      CurrOpenIndex     : integer;
      ConsistCnt        : tsp00_Int4;
      OpenEntryCnt      : tsp00_Int4;
      CurrConsistView   : tkb05_ConsistViewPtr;
      CurrOpenEntry     : tkb05_OpenTransPtr;
      ConsistRgnGlobPtr : tkb05_RegionGlobPtr;
      NilOpenTransId    : tgg91_TransNo;
      ZeroOpenTransId   : tgg91_TransNo;
 
BEGIN
Trans.trError_gg00 := e_ok;
gg06SetNilTrans (NilOpenTransId);
gg06SetZeroTrans (ZeroOpenTransId);
CurrTabRegion := k51glob.glTransRegions_kb05 + 1;
WHILE (Trans.trError_gg00 = e_ok)
      AND
      (CurrTabRegion <= k51glob.glTransRegions_kb05 + k51glob.glTabRegions_kb05) DO
    BEGIN
    k52begexcl_region (Trans.trTaskId_gg00, CurrTabRegion, ConsistRgnGlobPtr);
    CurrConsistView := ConsistRgnGlobPtr^.rglFirstConsistView_kb05;
    ConsistCnt      := 0;
    WHILE (Trans.trError_gg00 = e_ok) AND (CurrConsistView <> NIL)
          AND
          (ConsistCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        IF  CurrConsistView^.cstItemKind_kb05 <> ikConsistView_ekb05
        THEN
            k52x_item_error ('kb52sel_consist_views/1 ', CurrConsistView^.cstItemKind_kb05);
        (*ENDIF*) 
        IF  CurrConsistView^.cstFirstOpenTrans_kb05 = NIL
        THEN
            kb52write_consist_view_rec (Trans, FileId, CurrConsistView^, NilOpenTransId, RecCount)
        ELSE
            BEGIN
            CurrOpenEntry := CurrConsistView^.cstFirstOpenTrans_kb05;
            OpenEntryCnt  := 0;
            WHILE (Trans.trError_gg00 = e_ok) AND (CurrOpenEntry <> NIL)
                  AND
                  (OpenEntryCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
                BEGIN
                IF  CurrOpenEntry^.openItemKind_kb05 <> ikOpenTrans_ekb05
                THEN
                    k52x_item_error ('kb52sel_consist_views/2 ', CurrOpenEntry^.openItemKind_kb05);
                (*ENDIF*) 
                CurrOpenIndex := 1;
                WHILE (Trans.trError_gg00 = e_ok)
                      AND
                      (CurrOpenIndex <= CurrOpenEntry^.openCount_kb05)
                      AND
                      (CurrOpenIndex <= TRANS_PER_OPEN_ENTRY_KB05) (* security *) DO
                    BEGIN
                    kb52write_consist_view_rec (Trans, FileId, CurrConsistView^,
                          CurrOpenEntry^.openTransId_kb05 [CurrOpenIndex], RecCount);
                    CurrOpenIndex := CurrOpenIndex + 1
                    END;
                (*ENDWHILE*) 
                OpenEntryCnt  := OpenEntryCnt + 1;
                CurrOpenEntry := CurrOpenEntry^.openNext_kb05
                END;
            (*ENDWHILE*) 
            IF  OpenEntryCnt > k51glob.glMaxItemsPerRegion_kb05
            THEN
                k52x_loop_error ('kb52sel_consist_views   ', 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ConsistCnt      := ConsistCnt + 1;
        CurrConsistView := CurrConsistView^.cstNextConsistView_kb05
        END;
    (*ENDWHILE*) 
    (* +++ PTS 1120151 FF 2003-01-29 +++ *)
    CurrConsistView := ConsistRgnGlobPtr^.rglCancelConsView_kb05;
    WHILE (Trans.trError_gg00 = e_ok) AND (CurrConsistView <> NIL)
          AND
          (ConsistCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
        BEGIN
        IF  CurrConsistView^.cstItemKind_kb05 <> ikConsistView_ekb05
        THEN
            k52x_item_error ('kb52sel_consist_views/3 ', CurrConsistView^.cstItemKind_kb05);
        (*ENDIF*) 
        IF  CurrConsistView^.cstFirstOpenTrans_kb05 = NIL
        THEN
            kb52write_consist_view_rec (Trans, FileId, CurrConsistView^, NilOpenTransId, RecCount)
        ELSE
            BEGIN
            CurrOpenEntry := CurrConsistView^.cstFirstOpenTrans_kb05;
            OpenEntryCnt  := 0;
            WHILE (Trans.trError_gg00 = e_ok) AND (CurrOpenEntry <> NIL)
                  AND
                  (OpenEntryCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
                BEGIN
                IF  CurrOpenEntry^.openItemKind_kb05 <> ikOpenTrans_ekb05
                THEN
                    k52x_item_error ('kb52sel_consist_views/4 ', CurrOpenEntry^.openItemKind_kb05);
                (*ENDIF*) 
                CurrOpenIndex := 1;
                WHILE (Trans.trError_gg00 = e_ok)
                      AND
                      (CurrOpenIndex <= CurrOpenEntry^.openCount_kb05)
                      AND
                      (CurrOpenIndex <= TRANS_PER_OPEN_ENTRY_KB05) (* security *) DO
                    BEGIN
                    kb52write_consist_view_rec (Trans, FileId, CurrConsistView^,
                          CurrOpenEntry^.openTransId_kb05 [CurrOpenIndex], RecCount);
                    CurrOpenIndex := CurrOpenIndex + 1
                    END;
                (*ENDWHILE*) 
                OpenEntryCnt  := OpenEntryCnt + 1;
                CurrOpenEntry := CurrOpenEntry^.openNext_kb05
                END;
            (*ENDWHILE*) 
            IF  OpenEntryCnt > k51glob.glMaxItemsPerRegion_kb05
            THEN
                k52x_loop_error ('kb52sel_consist_views   ', 1);
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        ConsistCnt      := ConsistCnt + 1;
        CurrConsistView := CurrConsistView^.cstNextConsistView_kb05
        END;
    (*ENDWHILE*) 
    (* --- PTS 1120151 FF 2003-01-29 --- *)
    k52endexcl_region (Trans.trTaskId_gg00, ConsistRgnGlobPtr);
    CurrTabRegion := CurrTabRegion + 1
    END;
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52sel_obj_collisions (
            VAR t        : tgg00_TransContext;
            VAR FileId   : tgg00_FileId;
            VAR RecCount : tsp00_Int4);
 
VAR
      CurrCollision  : integer;
      ReqCnt         : tsp00_Int4;
      CurrReq        : tgg00_TransIndex;
      rec            : tkb05_ShowRec;
      CurrObjColl    : tkb05_ObjCollEntryPtr;
      ReqEntry       : tkb05_ObjReqEntryPtr;
      ObjCollGlobPtr : tkb05_ObjCollGlobPtr;
 
BEGIN
t.trError_gg00                   := e_ok;
rec.shrRec_kb05.len              := sizeof (rec.shrLock_kb05);
rec.shrLock_kb05.lshFiller1_kb05 := false;
CurrCollision := 1;
k52begexcl_objcoll (t.trTaskId_gg00, ObjCollGlobPtr);
WHILE (t.trError_gg00 = e_ok) AND (CurrCollision <= k51glob.glTransEntries_kb05) DO
    BEGIN
    k52acc_objcoll_entry (ObjCollGlobPtr^, CurrCollision, CurrObjColl);
    IF  NOT gg06IsNilOid (CurrObjColl^.objcOid_kb05)
        AND
        (CurrObjColl^.objcLockTransIndex_kb05 <> cgg_nil_transindex) (* PTS 1133169 UH 2004-12-28 *)
    THEN
        BEGIN
        kb52object_to_sel_rec (CurrObjColl^.objcLockTransIndex_kb05, CurrObjColl^.objcOid_kb05, rec);
        rec.shrTrans_kb05.tshLockMode_kb05 := lckRowExcl_egg00;
        rec.shrTrans_kb05.tshReqMode_kb05  := lckFree_egg00;
        rec.shrLock_kb05.lshTabId_kb05     := CurrObjColl^.objcObjContHndl_kb05;
        kb52write_sel_rec (t, FileId, RecCount, rec);
        ReqCnt  := 0;
        CurrReq := CurrObjColl^.objcFirstReq_kb05;
        WHILE (t.trError_gg00 = e_ok) AND (CurrReq <> cgg_nil_transindex)
              AND (ReqCnt <= k51glob.glTransEntries_kb05) DO
            BEGIN
            kb52object_to_sel_rec (CurrReq, CurrObjColl^.objcOid_kb05, rec);
            rec.shrTrans_kb05.tshLockMode_kb05 := lckFree_egg00;
            rec.shrTrans_kb05.tshReqMode_kb05  := lckRowExcl_egg00;
            rec.shrLock_kb05.lshTabId_kb05     := CurrObjColl^.objcObjContHndl_kb05;
            kb52write_sel_rec (t, FileId, RecCount, rec);
            k52acc_objreq_entry (ObjCollGlobPtr^, CurrReq, ReqEntry);
            CurrReq := ReqEntry^.objrNextReq_kb05;
            ReqCnt  := ReqCnt + 1
            END;
        (*ENDWHILE*) 
        IF  ReqCnt > k51glob.glTransEntries_kb05
        THEN
            k52x_loop_error ('kb52sel_obj_collisions  ', 1)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    CurrCollision := CurrCollision + 1
    END;
(*ENDWHILE*) 
k52endexcl_objcoll (t.trTaskId_gg00, ObjCollGlobPtr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52sel_rows (
            VAR t         : tgg00_TransContext;
            VAR FileId    : tgg00_FileId;
            VAR RecCount  : tsp00_Int4;
            VAR rec       : tkb05_ShowRec;
            ItemLimit     : tsp00_Int4;
            Trans         : tkb05_TransEntryPtr;
            Tab           : tkb05_TabTransPtr);
 
VAR
      i       : integer;
      ItemCnt : tsp00_Int4;
      CurrRow : tkb05_RowTransPtr;
 
BEGIN
t.trError_gg00 := e_ok;
CurrRow        := Tab^.ttFirstRow_kb05;
IF  CurrRow <> NIL
THEN
    (* skip to last descending row *)
    BEGIN
    ItemCnt := 0;
    WHILE (CurrRow^.rtNextRow_kb05 <> NIL) AND (ItemCnt <= ItemLimit) DO
        BEGIN
        CurrRow := CurrRow^.rtNextRow_kb05;
        ItemCnt := ItemCnt + 1
        END;
    (*ENDWHILE*) 
    IF  ItemCnt > ItemLimit
    THEN
        k52x_loop_error ('k52sel_rows             ', 1)
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
ItemCnt := 0;
(* display rows ascending *)
WHILE (t.trError_gg00 = e_ok) AND (CurrRow <> NIL) AND (ItemCnt <= ItemLimit) DO
    BEGIN
    IF  CurrRow^.rtRow_kb05 <> NIL                                   (* PTS 1106270 JA 2000-04-06 *)
    THEN
        BEGIN
        kb52trans_to_sel_rec (Trans, CNSVIEW_IS_PROTECTED, rec);     (*PTS 1137874 FF 15-Sep-2005*)
        rec.shrLock_kb05.lshUndefRowId_kb05 := false;
        rec.shrLock_kb05.lshRowIdLen_kb05   := CurrRow^.rtKeyLen_kb05;
        rec.shrTrans_kb05.tshLockMode_kb05  := CurrRow^.rtLockMode_kb05;
        rec.shrTrans_kb05.tshReqMode_kb05   := CurrRow^.rtReqMode_kb05;
        rec.shrTrans_kb05.tshLockState_kb05 := CurrRow^.rtLockState_kb05;
        rec.shrTrans_kb05.tshReqState_kb05  := CurrRow^.rtReqState_kb05;
        IF  CurrRow^.rtKeyLen_kb05 > sizeof (CurrRow^.rtShortKey_kb05)
        THEN
            rec.shrLock_kb05.lshRowId_kb05 := CurrRow^.rtRow_kb05^.rlRowIdItem_kb05^.riRowId_kb05
        ELSE
            BEGIN
            FOR i := 1 TO CurrRow^.rtKeyLen_kb05 DO
                rec.shrLock_kb05.lshRowId_kb05 [i] := CurrRow^.rtShortKey_kb05 [i];
            (*ENDFOR*) 
            FOR i := CurrRow^.rtKeyLen_kb05 + 1 TO sizeof (rec.shrLock_kb05.lshRowId_kb05) DO
                rec.shrLock_kb05.lshRowId_kb05 [i] := chr (0)
            (*ENDFOR*) 
            END;
        (*ENDIF*) 
        kb52write_sel_rec (t, FileId, RecCount, rec)
        END;
    (*ENDIF*) 
    CurrRow := CurrRow^.rtPrevRow_kb05;
    ItemCnt := ItemCnt + 1
    END;
(*ENDWHILE*) 
IF  ItemCnt > ItemLimit
THEN
    k52x_loop_error ('k52sel_rows             ', 2)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52select_tables (
            VAR t              : tgg00_TransContext;
            VAR FileId         : tgg00_FileId;
            VAR RecCount       : tsp00_Int4);
 
VAR
      IsTabLock       : boolean;
      IsTabReq        : boolean;
      CurrRegion      : tkb05_RegionNo;
      ItemLimit       : tsp00_Int4;
      TransLimit      : tsp00_Int4;
      TabItemCnt      : tsp00_Int4;
      TransCnt        : tsp00_Int4;
      CurrTab         : tkb05_TabTransPtr;
      CurrTrans       : tkb05_TransEntryPtr;
      rec             : tkb05_ShowRec;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
t.trError_gg00 := e_ok;
rec.shrRec_kb05.len              := sizeof (rec.shrLock_kb05);
rec.shrLock_kb05.lshFiller1_kb05 := false;
CurrRegion := 1;
WHILE (t.trError_gg00 = e_ok) AND (CurrRegion <= k51glob.glTransRegions_kb05) DO
    BEGIN
    k52begexcl_region (t.trTaskId_gg00, CurrRegion, TransRgnGlobPtr);
    TransLimit := k52used_trans_of_region (TransRgnGlobPtr^);
    ItemLimit  := k52used_items_of_region (TransRgnGlobPtr^);
    CurrTrans  := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
    TransCnt   := 0;
    WHILE (t.trError_gg00 = e_ok) AND (CurrTrans <> NIL) AND (TransCnt <= TransLimit) DO
        BEGIN
        CurrTab    := CurrTrans^.teFirstTab_kb05;
        TabItemCnt := 0;
        WHILE (t.trError_gg00 = e_ok) AND (CurrTab <> NIL) AND (TabItemCnt <= ItemLimit) DO
            BEGIN
            rec.shrLock_kb05.lshTabId_kb05 := CurrTab^.ttTabId_kb05;
            IsTabLock := (CurrTab^.ttLockMode_kb05 <> lckFree_egg00);
            IsTabReq  :=
                  (CurrTab^.ttReqMode_kb05 = lckSysShare_egg00) OR
                  (CurrTab^.ttReqMode_kb05 = lckSysExcl_egg00 ) OR
                  (CurrTab^.ttReqMode_kb05 = lckTabShare_egg00) OR
                  (CurrTab^.ttReqMode_kb05 = lckTabExcl_egg00 );
            IF  IsTabLock OR IsTabReq
            THEN
                BEGIN
                kb52trans_to_sel_rec (CurrTrans, CNSVIEW_IS_PROTECTED, rec); (*PTS 1137874 FF 15-Sep-2005*)
                rec.shrLock_kb05.lshUndefRowId_kb05 := true;
                rec.shrLock_kb05.lshRowIdLen_kb05   := 0;
                IF  IsTabLock
                THEN
                    BEGIN
                    rec.shrTrans_kb05.tshLockMode_kb05  := CurrTab^.ttLockMode_kb05;
                    rec.shrTrans_kb05.tshLockState_kb05 := CurrTab^.ttLockState_kb05
                    END
                ELSE
                    BEGIN
                    rec.shrTrans_kb05.tshLockMode_kb05  := lckFree_egg00;
                    rec.shrTrans_kb05.tshLockState_kb05 := [ ]
                    END;
                (*ENDIF*) 
                IF  IsTabReq
                THEN
                    BEGIN
                    rec.shrTrans_kb05.tshReqMode_kb05  := CurrTab^.ttReqMode_kb05;
                    rec.shrTrans_kb05.tshReqState_kb05 := CurrTab^.ttReqState_kb05
                    END
                ELSE
                    BEGIN
                    rec.shrTrans_kb05.tshReqMode_kb05  := lckFree_egg00;
                    rec.shrTrans_kb05.tshReqState_kb05 := [ ]
                    END;
                (*ENDIF*) 
                kb52write_sel_rec (t, FileId, RecCount, rec)
                END;
            (*ENDIF*) 
            IF  (t.trError_gg00 = e_ok) AND (CurrTab^.ttFirstRow_kb05 <> NIL)
            THEN
                kb52sel_rows (t, FileId, RecCount, rec, ItemLimit, CurrTrans, CurrTab);
            (*ENDIF*) 
            TabItemCnt := TabItemCnt + 1;
            CurrTab    := CurrTab^.ttNextTab_kb05
            END;
        (*ENDWHILE*) 
        IF  TabItemCnt > ItemLimit
        THEN
            k52x_loop_error ('kb52select_tables       ', 1);
        (*ENDIF*) 
        TransCnt  := TransCnt + 1;
        CurrTrans := CurrTrans^.teNextTrans_kb05
        END;
    (*ENDWHILE*) 
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
    IF  TransCnt > TransLimit
    THEN
        k52x_loop_error ('kb52select_tables       ', 2);
    (*ENDIF*) 
    CurrRegion := CurrRegion + 1
    END
(*ENDWHILE*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52select_trans (
            VAR t             : tgg00_TransContext;
            VAR FileId        : tgg00_FileId;
            VAR RecCount      : tsp00_Int4);
 
VAR
      CurrRegion      : tkb05_RegionNo;
      TransCnt        : tsp00_Int4;
      TransLimit      : tsp00_Int4;
      CurrTrans       : tkb05_TransEntryPtr;
      rec             : tkb05_ShowRec;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
 
BEGIN
t.trError_gg00      := e_ok;
rec.shrRec_kb05.len := sizeof (rec.shrTrans_kb05);
CurrRegion          := 1;
REPEAT
    k52begexcl_region (t.trTaskId_gg00, CurrRegion, TransRgnGlobPtr);
    TransLimit := k52used_trans_of_region (TransRgnGlobPtr^);
    CurrTrans  := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
    TransCnt   := 0;
    WHILE (t.trError_gg00 = e_ok) AND (CurrTrans <> NIL) AND (TransCnt <= TransLimit) DO
        BEGIN
        kb52trans_to_sel_rec (CurrTrans, CNSVIEW_IS_PROTECTED, rec); (*PTS 1137874 FF 15-Sep-2005*)
        kb52write_sel_rec (t, FileId, RecCount, rec);
        TransCnt  := TransCnt + 1;
        CurrTrans := CurrTrans^.teNextTrans_kb05
        END;
    (*ENDWHILE*) 
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
    IF  TransCnt > TransLimit
    THEN
        k52x_loop_error ('kb52select_trans        ', 1);
    (*ENDIF*) 
    CurrRegion := CurrRegion + 1
UNTIL
    (CurrRegion > k51glob.glTransRegions_kb05) OR (t.trError_gg00 <> e_ok)
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52show_config (
            VAR t            : tgg00_TransContext;
            VAR FileId       : tgg00_FileId;
            VAR Show         : t_Show);
 
VAR
      IsClosed              : boolean;
      ShutdWanted           : boolean;
      UsedPercent           : tsp00_Int4;
      LockInfo              : tkb05_LockInfo;
      LockCntrlEntries      : tsp00_Int4;   (* PTS 1128244 FF 2004-03-18 *)
      LockCntrlEntriesUsed  : tsp00_Int4;   (* PTS 1128244 FF 2004-03-18 *)
      ShareLockEntries      : tsp00_Int4;   (* PTS 1128244 FF 2004-03-18 *)
      ShareLockEntriesUsed  : tsp00_Int4;   (* PTS 1128244 FF 2004-03-18 *)
      CollisionEntriesUsed  : tsp00_Int4;   (* PTS 1128244 FF 2004-03-18 *)
 
BEGIN
(* PTS 1103743 JA 1999-08-25 *)
t.trError_gg00 := e_ok;
(* *)
k51info_lock (t.trTaskId_gg00, LockInfo);
(* *)
IsClosed    := false;
ShutdWanted := false;
kb52param_to_rec (t, IS_INT4, FileId, Show, MSG01_MAX_LOCKS, g01maxlocks, 0);
IF  t.trError_gg00 = e_ok
THEN
    kb52param_to_rec (t, IS_INT4, FileId, Show, MSG02_TRANS_REGIONS,
          k51glob.glTransRegions_kb05, 0);
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    kb52param_to_rec (t, IS_INT4, FileId, Show, MSG03_TAB_REGIONS,
          k51glob.glTabRegions_kb05, 0);
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    kb52param_to_rec (t, IS_INT4, FileId, Show, MSG04_ROW_REGIONS,
          k51glob.glRowRegions_kb05, 0);
(*ENDIF*) 
WITH LockInfo DO
    BEGIN
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG05_MAX_ENTRIES, infMaxEntries_kb05, 0);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG06_ENTRIES_USED, infEntriesUsed_kb05, 0);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  (infEntriesUsed_kb05 = 0) OR (infMaxEntries_kb05 = 0)
        THEN
            UsedPercent := 0
        ELSE
            UsedPercent:= ((infEntriesUsed_kb05 * 1000) DIV infMaxEntries_kb05 + 5) DIV 10;
        (*ENDIF*) 
        IF  (UsedPercent = 100) AND (infEntriesUsed_kb05 < infMaxEntries_kb05)
        THEN
            UsedPercent := 99;
        (*ENDIF*) 
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG07_USED_PERCENT, UsedPercent, 0)
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG08_AVG_USED, infAvgUsed_kb05, 0);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  (infAvgUsed_kb05 = 0) OR (infMaxEntries_kb05 = 0)
        THEN
            UsedPercent := 0
        ELSE
            UsedPercent := ((infAvgUsed_kb05 * 1000) DIV infMaxEntries_kb05 + 5) DIV 10;
        (*ENDIF*) 
        IF  (UsedPercent = 100) AND (infAvgUsed_kb05 < infMaxEntries_kb05)
        THEN
            UsedPercent := 99;
        (*ENDIF*) 
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG09_AVG_PERCENT, UsedPercent, 0)
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG10_MAX_USED, infMaxUsed_kb05, 0);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        IF  (infMaxUsed_kb05 = 0) OR (infMaxEntries_kb05 = 0)
        THEN
            UsedPercent := 0
        ELSE
            UsedPercent := ((infMaxUsed_kb05 * 1000) DIV infMaxEntries_kb05 + 5) DIV 10;
        (*ENDIF*) 
        IF  (UsedPercent = 100) AND (infMaxUsed_kb05 < infMaxEntries_kb05)
        THEN
            UsedPercent := 99;
        (*ENDIF*) 
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG11_MAX_PERCENT, UsedPercent, 0)
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        BEGIN
        (* BEGIN PTS 1128244 FF 2004-03-18 *)
        k501GetStatistics(LockCntrlEntries, LockCntrlEntriesUsed, ShareLockEntries,
              ShareLockEntriesUsed, CollisionEntriesUsed );
        IF  t.trError_gg00 = e_ok
        THEN
            kb52param_to_rec (t, IS_INT4, FileId, Show, MSG11A_SHR_ENTRIES, LockCntrlEntries, 0);
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            kb52param_to_rec (t, IS_INT4, FileId, Show, MSG11B_SHR_USED, LockCntrlEntriesUsed, 0);
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            kb52param_to_rec (t, IS_INT4, FileId, Show, MSG11C_SHR_REQUESTS, ShareLockEntries, 0);
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            kb52param_to_rec (t, IS_INT4, FileId, Show, MSG11D_SHR_REQ_USED, ShareLockEntriesUsed, 0);
        (* END PTS 1128244 FF 2004-03-18 *)
        (*ENDIF*) 
        IF  t.trError_gg00 = e_ok
        THEN
            kb52param_to_rec (t, IS_INT4, FileId, Show, MSG11E_SHR_COLL_USED, CollisionEntriesUsed, 0);
        (* END PTS 1128244 FF 2004-03-18 *)
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG12_CONSIST_VIEW, infConsistViewCnt_kb05, 0);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG13_OPEN_TRANS, infOpenTransCnt_kb05, 0);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG14_LOCK_ESCAL, infEscalValue_kb05, 0);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, NOT IS_INT4, FileId, Show, MSG15_ESCALATIONS, 0, infEscalations_kb05);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, NOT IS_INT4, FileId, Show,
              MSG16A_SQL_COLLISIONS, 0, infSqlCollisions_kb05);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, NOT IS_INT4, FileId, Show,
              MSG16B_OMS_COLLISIONS, 0, infOmsCollisions_kb05);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, NOT IS_INT4, FileId, Show, MSG17_DEADLOCKS, 0, infDeadlocks_kb05);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, NOT IS_INT4, FileId, Show, MSG18_SQL_REQTIMEOUT, 0, infSqlReqTimeouts_kb05);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, NOT IS_INT4, FileId, Show, MSG19_OBJ_REQTIMEOUT, 0, infObjReqTimeouts_kb05);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG20_LOCK_TRANS, infLockTrans_kb05, 0);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG21_REQ_TRANS, infReqTrans_kb05, 0);
    (*ENDIF*) 
    IF  t.trError_gg00 = e_ok
    THEN
        kb52param_to_rec (t, IS_INT4, FileId, Show, MSG22_OBJ_LOCK_TRANS, infObjLockTrans_kb05, 0)
    (*ENDIF*) 
    END;
(*ENDWITH*) 
IF  t.trError_gg00 = e_ok
THEN
    kb52param_to_rec (t, IS_INT4, FileId, Show, MSG23_CLOSED_LIST, ord (IsClosed), 0);
(*ENDIF*) 
IF  t.trError_gg00 = e_ok
THEN
    kb52param_to_rec (t, IS_INT4, FileId, Show, MSG24_SHUTDOWN, ord (ShutdWanted), 0)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52show_runing_cmds (
            VAR t          : tgg00_TransContext;
            VAR file_id    : tgg00_FileId);
 
VAR
      CurrRegion      : tkb05_RegionNo;
      TransCnt        : tsp00_Int4;
      TransLimit      : tsp00_Int4;
      CurrTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
      parsid          : tsp00_C12;
      rec             : tgg00_Rec;
 
BEGIN
t.trError_gg00 := e_ok;
CurrRegion     := 1;
REPEAT
    k52begexcl_region (t.trTaskId_gg00, CurrRegion, TransRgnGlobPtr);
    TransLimit := k52used_trans_of_region (TransRgnGlobPtr^);
    CurrTrans  := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
    TransCnt   := 0;
    WHILE (t.trError_gg00 = e_ok) AND (CurrTrans <> NIL) AND (TransCnt <= TransLimit) DO
        BEGIN
        IF  CurrTrans^.teUserId_kb05 <> cgg_zero_userid
        THEN
            BEGIN
            IF  a42getparseid (t, CurrTrans^.teTaskId_kb05, parsid, t.trError_gg00)
                AND
                (t.trError_gg00 = e_ok)
            THEN
                BEGIN
                rec.len    := cgg_rec_key_offset;
                rec.keylen := sizeof(CurrTrans^.teTaskId_kb05);
                rec.recVarcolOffset_gg00 := 0;
                rec.recVarcolCnt_gg00    := 0;
                s20int4_to_buf_2 (CurrTrans^.teTaskId_kb05, rec.buf, rec.len+1);
                rec.len    := rec.len + sizeof(CurrTrans^.teTaskId_kb05);
                SAPDB_PascalMove ('VKB52 ',  18,    
                      sizeof (parsid), sizeof (rec.buf),
                      @parsid, 1, @rec.buf, rec.len+1, sizeof (parsid), t.trError_gg00);
                IF  t.trError_gg00 = e_ok
                THEN
                    BEGIN
                    rec.len                := rec.len + sizeof (parsid);
                    file_id.fileBdUse_gg00 := [ ];
                    kb52write_temp_rec (t, file_id, rec)             (* PTS 1106067 JA 2000-03-21 *)
                    END
                (*ENDIF*) 
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        TransCnt  := TransCnt + 1;
        CurrTrans := CurrTrans^.teNextTrans_kb05
        END;
    (*ENDWHILE*) 
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
    IF  TransCnt > TransLimit
    THEN
        k52x_loop_error ('kb52show_runing_cmds    ', 1);
    (*ENDIF*) 
    CurrRegion := CurrRegion + 1
UNTIL
    (t.trError_gg00 <> e_ok) OR (CurrRegion > k51glob.glTransRegions_kb05)
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52trans_to_sel_rec (
            ThisTrans          : tkb05_TransEntryPtr;
            bConsviewProtected : boolean;    (*PTS 1137874 FF 15-Sep-2005*)
            VAR rec            : tkb05_ShowRec);
 
BEGIN
WITH rec.shrTrans_kb05, ThisTrans^ DO
    BEGIN
    tshTaskId_kb05       := teTaskId_kb05;
    tshSession_kb05      := teSessionId_kb05;
    tshWriteTransId_kb05 := teWriteTransId_kb05;
    tshSubtrans_kb05     := teSubtransId_kb05;
    tshStartDate_kb05    := teStartDate_kb05;
    tshStartTime_kb05    := teStartTime_kb05;
    tshSelTransId_kb05   := teSelectTransId_kb05;
    tshTermId_kb05       := teTermId_kb05;
    tshUserId_kb05       := teUserId_kb05;
    tshTimeWrite_kb05    := teTimeLastWrite_kb05;
    tshTrLockMode_kb05   := teLockMode_kb05;
    tshLockMode_kb05     := lckFree_egg00;
    tshReqMode_kb05      := lckFree_egg00;
    tshLockState_kb05    := [ ];
    tshReqState_kb05     := [ ];
    gg06SetNilTrans (tshConsistView_kb05);
    IF  teObjLockMode_kb05 = tlmEotExcl_ekb05
    THEN
        tshTrLockMode_kb05 := tlmEotExcl_ekb05;
    (*ENDIF*) 
    IF  teObjReq_kb05 <> cgg_nil_transindex
    THEN
        BEGIN
        tshReqTimeout_kb05 := teObjReqTimeout_kb05;
        tshTrReqMode_kb05  := tlmExcl_ekb05
        END
    ELSE
        BEGIN
        tshReqTimeout_kb05 := teReqTimeout_kb05;
        tshTrReqMode_kb05  := teReqMode_kb05
        END;
    (*ENDIF*) 
    IF  (teConsistView_kb05 <> NIL)
        AND bConsviewProtected    (*PTS 1137874*)
    THEN
        BEGIN
        (* PTS 1137874  bConsviewProtected means:                                   *)
        (* transaction is holding semaphore for exclusive access on ThisTrans       *)
        (* therefore no kb51DelConsistTrans or kb51CancelConsistTrans or            *)
        (* kb50CheckConsistViewOfTransWithCancel can destroy the consistentview     *)
        (* or reset the pointer within ThisTrans                                    *)
        (* ==> following read accesses are safe and NOT dirty, even if done without *)
        (*     aquiring consist/tab region                                          *)
        IF  (teConsistView_kb05^.cstCurrTransIndex_kb05 = teOwnIndex_kb05)
            AND
            (teConsistView_kb05^.cstItemKind_kb05 = ikConsistView_ekb05)
        THEN
            (* dirty read: outside consist/tab region *)
            tshConsistView_kb05 := teConsistView_kb05^.cstConsistViewNo_kb05.surrTransId_kb05
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDWITH*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52user_show (
            VAR t          : tgg00_TransContext;
            VAR FileId     : tgg00_FileId;
            VAR RecCount   : tsp00_Int4);
 
VAR
      CurrRegion      : tkb05_RegionNo;
      TransCnt        : tsp00_Int4;
      TransLimit      : tsp00_Int4;
      CurrTrans       : tkb05_TransEntryPtr;
      TransRgnGlobPtr : tkb05_RegionGlobPtr;
      rec             : tgg00_Rec;
 
BEGIN
t.trError_gg00 := e_ok;
CurrRegion     := 1;
REPEAT
    k52begexcl_region (t.trTaskId_gg00, CurrRegion, TransRgnGlobPtr);
    TransLimit := k52used_trans_of_region (TransRgnGlobPtr^);
    CurrTrans  := TransRgnGlobPtr^.rglTransGlob_kb05^.trFirst_kb05;
    TransCnt   := 0;
    WHILE (t.trError_gg00 = e_ok) AND (CurrTrans <> NIL) AND (TransCnt <= TransLimit) DO
        BEGIN
        IF  CurrTrans^.teUserId_kb05 <> cgg_zero_userid
        THEN
            BEGIN
            rec.keylen          := 2 + sizeof (CurrTrans^.teUserId_kb05) + 4;
            rec.len             := cgg_rec_key_offset;
            rec.buf [rec.len+1] := chr (0); (* site *)
            rec.buf [rec.len+2] := chr (0); (* site *)
            rec.len             := rec.len + 2;
            SAPDB_PascalMove ('VKB52 ',  19,    
                  sizeof (CurrTrans^.teUserId_kb05), sizeof (rec.buf),
                  @CurrTrans^.teUserId_kb05, 1, @rec.buf, rec.len + 1,
                  sizeof (CurrTrans^.teUserId_kb05), t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                BEGIN
                rec.len  := rec.len + sizeof (CurrTrans^.teUserId_kb05);
                RecCount := RecCount + 1;
                s20int4_to_buf_swap (RecCount, g01code.kernel_swap, rec.buf, rec.len+1, sw_normal);
                rec.len           := rec.len + 4 + 1;
                rec.buf [rec.len] := ' '
                END;
            (*ENDIF*) 
            SAPDB_PascalMove ('VKB52 ',  20,    
                  sizeof (CurrTrans^.teUserId_kb05), sizeof (rec.buf),
                  @CurrTrans^.teUserId_kb05, 1, @rec.buf, rec.len+1,
                  sizeof (CurrTrans^.teUserId_kb05), t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                BEGIN
                rec.len           := rec.len + sizeof (CurrTrans^.teUserId_kb05) +1;
                rec.buf [rec.len] := ' ';
                WITH CurrTrans^ DO
                    BEGIN
                    SAPDB_PascalMove ('VKB52 ',  21,    
                          sizeof (teTermId_kb05), sizeof (rec.buf),
                          @teTermId_kb05, 1, @rec.buf, rec.len+1,
                          sizeof (teTermId_kb05), t.trError_gg00);
                    rec.len := rec.len + sizeof (teTermId_kb05) + 1;
                    END
                (*ENDWITH*) 
                END;
            (*ENDIF*) 
            IF  t.trError_gg00 = e_ok
            THEN
                rec.buf [rec.len] := ' ';
            (*ENDIF*) 
            SAPDB_PascalMove ('VKB52 ',  22,    
                  sizeof (g01serverdb_ident.svServerdb_gg04),
                  sizeof (rec.buf),
                  @g01serverdb_ident.svServerdb_gg04, 1,
                  @rec.buf, rec.len+1,
                  sizeof (g01serverdb_ident.svServerdb_gg04), t.trError_gg00);
            IF  t.trError_gg00 = e_ok
            THEN
                BEGIN
                rec.len := rec.len + sizeof (g01serverdb_ident.svServerdb_gg04) + 1;
                rec.buf [rec.len]   := csp_defined_byte;
                rec.buf [rec.len+1] := CurrTrans^.teSessionId_kb05.ci4_gg00 [1];
                rec.buf [rec.len+2] := CurrTrans^.teSessionId_kb05.ci4_gg00 [2];
                rec.buf [rec.len+3] := CurrTrans^.teSessionId_kb05.ci4_gg00 [3];
                rec.buf [rec.len+4] := CurrTrans^.teSessionId_kb05.ci4_gg00 [4];
                rec.len             := rec.len + 4;
                rec.buf [rec.len+1] := csp_defined_byte;
                rec.buf [rec.len+2] := chr(0);
                rec.len             := rec.len + 2;
                rec.recVarcolOffset_gg00 := rec.len - cgg_rec_key_offset - rec.keylen;
                rec.recVarcolCnt_gg00    := 0;
                FileId.fileBdUse_gg00    := [ ];
                kb52write_temp_rec (t, FileId, rec)              (* PTS 1106067 JA 2000-03-21 *)
                END
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        TransCnt  := TransCnt + 1;
        CurrTrans := CurrTrans^.teNextTrans_kb05
        END;
    (*ENDWHILE*) 
    k52endexcl_region (t.trTaskId_gg00, TransRgnGlobPtr);
    IF  TransCnt > TransLimit
    THEN
        k52x_loop_error ('kb52user_show           ', 1);
    (*ENDIF*) 
    CurrRegion := CurrRegion + 1
UNTIL
    (t.trError_gg00 <> e_ok) OR (CurrRegion > k51glob.glTransRegions_kb05)
(*ENDREPEAT*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52write_consist_view_rec (
            VAR Trans       : tgg00_TransContext;
            VAR FileId      : tgg00_FileId;
            VAR ConsistView : tkb05_ConsistView;
            VAR OpenTransId : tgg91_TransNo;
            VAR RecCount    : tsp00_Int4);
 
VAR
      rec : tkb05_ShowRec;
 
BEGIN
WITH rec.shrConsist_kb05 DO
    BEGIN
    cshRecLen_kb05       := sizeof (rec.shrConsist_kb05);
    cshConsistView_kb05  := ConsistView.cstConsistViewNo_kb05.surrTransId_kb05;
    cshCreatorTrans_kb05 := ConsistView.cstCreatorTransId_kb05; (* PTS 1125503 FF 2003-11-19 *)
    cshOpenTrans_kb05    := OpenTransId;
    cshStartDate_kb05    := ConsistView.cstStartDate_kb05;
    cshStartTime_kb05    := ConsistView.cstStartTime_kb05;
    cshTimeLastUsed_kb05 := ConsistView.cstTimeLastUsed_kb05;
    (* PTS 1120151 FF 2003-01-29 *)
    IF  ConsistView.cstCancelled_kb05
    THEN
        cshCancelled_kb05 := true
    ELSE
        cshCancelled_kb05 := false;
    (*ENDIF*) 
    END;
(*ENDWITH*) 
kb52write_sel_rec (Trans, FileId, RecCount, rec)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52write_temp_rec (
            VAR Trans               : tgg00_TransContext;
            VAR FileId              : tgg00_FileId;
            VAR rec                 : tgg00_Rec);
 
VAR
      NoWaitIsAlreadySet : boolean;
 
BEGIN
(* PTS 1106067 JA 2000-03-21 *)
(* CR 1107769 TS 2000-09-05 *)
NoWaitIsAlreadySet := (tsDbFullNowait_egg00 IN Trans.trState_gg00);
Trans.trState_gg00 := Trans.trState_gg00 + [tsDbFullNowait_egg00];
b07cadd_record (Trans, FileId, rec);
IF  NOT NoWaitIsAlreadySet
THEN
    Trans.trState_gg00 := Trans.trState_gg00 - [tsDbFullNowait_egg00];
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52write_sel_rec (
            VAR t              : tgg00_TransContext;
            VAR FileId         : tgg00_FileId;
            VAR RecCount       : tsp00_Int4;
            VAR rec            : tkb05_ShowRec);
 
BEGIN
t.trError_gg00                       := e_ok;
rec.shrRec_kb05.keylen               := sizeof (rec.shrTrans_kb05.tshKey_kb05);
rec.shrRec_kb05.recVarcolOffset_gg00 := 0;
rec.shrRec_kb05.recVarcolCnt_gg00    := 0;
RecCount                             := RecCount + 1;
s20int4_to_buf_swap (RecCount,
      g01code.kernel_swap, rec.shrRec_kb05.buf, cgg_rec_key_offset + 1, sw_normal);
FileId.fileBdUse_gg00 := [ ];
kb52write_temp_rec (t, FileId, rec.shrRec_kb05);                     (* PTS 1106067 JA 2000-03-21 *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52write_show_rec (
            VAR t      : tgg00_TransContext;
            VAR FileId : tgg00_FileId;
            VAR Show   : t_Show);
 
VAR
      RecPtr : t_RecPtr;
 
BEGIN
Show.shwRec.shtVarcolOffset_kb05 := 0;
Show.shwRec.shtVarcolCnt_kb05    := 0;
RecPtr                           := @Show.shwRec;
Show.shwRecCount                 := Show.shwRecCount + 1;
s20int4_to_buf_swap (Show.shwRecCount,
      g01code.kernel_swap, RecPtr^.buf, cgg_rec_key_offset + 1, sw_normal);
FileId.fileBdUse_gg00 := [ ];
kb52write_temp_rec (t, FileId, RecPtr^)                              (* PTS 1106067 JA 2000-03-21 *)
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52x_dump_loop_error (msg : tsp00_C24; error_no : tsp00_Int4);
 
BEGIN
g01opmsg (sp3p_console, sp3m_error, kb52c1XCheck_csp03, csp3_n_lock, msg, error_no)
END;
 
(*==============================================================================*)
(**)
&ifdef TRACE
(*------------------------------*) 
 
PROCEDURE
      k52xaddr_rowl (
            debug   : tgg00_Debug;
            msg     : tsp00_Sname;
            RowLock : tkb05_RowLockPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
UnivItemPtr.uiRowLock_kb05 := RowLock;
t01addr (debug, msg, UnivItemPtr.uiSupplyItem_kb05);
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xaddr_rowl_check (
            VAR RowRegionGlob : tkb05_RegionGlob;
            RowLock : tkb05_RowLockPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
g01check (kb52c1XPtrCheck_csp03, csp3_n_lock,
      'RowLock: wrong ItemKind ', RowRegionGlob.rglOwnRegion_kb05,
      RowLock^.rlItemKind_kb05 = ikRowLock_ekb05);
UnivItemPtr.uiRowLock_kb05 := RowLock;
kb52xitem_ptr_check (RowRegionGlob, UnivItemPtr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xaddr_rowt (
            debug    : tgg00_Debug;
            msg      : tsp00_Sname;
            RowTrans : tkb05_RowTransPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
UnivItemPtr.uiRowTrans_kb05 := RowTrans;
t01addr (debug, msg, UnivItemPtr.uiSupplyItem_kb05);
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xaddr_rowt_check (
            VAR TransRegionGlob : tkb05_RegionGlob;
            RowTrans : tkb05_RowTransPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
g01check (kb52c1XPtrCheck_csp03, csp3_n_lock,
      'RowTrans: wrong ItemKind', TransRegionGlob.rglOwnRegion_kb05,
      RowTrans^.rtItemKind_kb05 = ikRowTrans_ekb05);
UnivItemPtr.uiRowTrans_kb05 := RowTrans;
kb52xitem_ptr_check (TransRegionGlob, UnivItemPtr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xaddr_tabl (
            debug   : tgg00_Debug;
            msg     : tsp00_Sname;
            TabLock : tkb05_TabLockPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
UnivItemPtr.uiTabLock_kb05 := TabLock;
t01addr (debug, msg, UnivItemPtr.uiSupplyItem_kb05);
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xaddr_tabl_check (
            VAR TabRegionGlob : tkb05_RegionGlob;
            TabLock : tkb05_TabLockPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
g01check (kb52c1XPtrCheck_csp03, csp3_n_lock,
      'TabLock: wrong ItemKind ', TabRegionGlob.rglOwnRegion_kb05,
      TabLock^.tlItemKind_kb05 = ikTabLock_ekb05);
UnivItemPtr.uiTabLock_kb05 := TabLock;
kb52xitem_ptr_check (TabRegionGlob, UnivItemPtr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xaddr_tabt (
            debug    : tgg00_Debug;
            msg      : tsp00_Sname;
            TabTrans : tkb05_TabTransPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
UnivItemPtr.uiTabTrans_kb05 := TabTrans;
t01addr (debug, msg, UnivItemPtr.uiSupplyItem_kb05);
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xaddr_tabt_check (
            VAR TransRegionGlob : tkb05_RegionGlob;
            TabTrans : tkb05_TabTransPtr);
 
VAR
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
g01check (kb52c1XPtrCheck_csp03, csp3_n_lock,
      'TabTrans: wrong ItemKind', TransRegionGlob.rglOwnRegion_kb05,
      TabTrans^.ttItemKind_kb05 = ikTabTrans_ekb05);
UnivItemPtr.uiTabTrans_kb05 := TabTrans;
kb52xitem_ptr_check (TransRegionGlob, UnivItemPtr)
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xregion_supply_check (VAR RegionGlob : tkb05_RegionGlob);
 
VAR
      ItemCnt       : tsp00_Int4;
      ExtentSegmCnt : tsp00_Int4;
      curr          : tkb05_SupplyItemPtr;
      CurrSegm      : tkb05_SupplySegmPtr;
 
BEGIN
IF  kb03Check.chkLock_kb00
THEN
    WITH k51glob DO
        BEGIN
        g01check (kb52c1XSupplyCheck_csp03, csp3_n_lock,
              'FreeItems > MaxItems    ', RegionGlob.rglOwnRegion_kb05,
              (RegionGlob.rglFreeItems_kb05 <= glSupplyItemsPerRegion_kb05) AND
              (RegionGlob.rglFreeItems_kb05 >= 0));
        g01check (kb52c1XSupplyCheck_csp03, csp3_n_lock,
              'ExtFreeItems>ExtMaxItems', RegionGlob.rglOwnRegion_kb05,
              (RegionGlob.rglExtentFreeItems_kb05 <= RegionGlob.rglExtentItems_kb05) AND
              (RegionGlob.rglExtentFreeItems_kb05 >= 0)
              AND
              (RegionGlob.rglExtentItems_kb05 <= glSupplyPoolItems_kb05));
        (* *)
        ItemCnt := 0;
        curr    := RegionGlob.rglFirstFree_kb05;
        WHILE (curr <> NIL) AND (ItemCnt <= glSupplyItemsPerRegion_kb05) DO
            BEGIN
            g01check (kb52c2XSupplyCheck_csp03, csp3_n_lock,
                  'ExtentItem in free list ', RegionGlob.rglOwnRegion_kb05,
                  NOT curr^.siExtentItem_kb05);
            ItemCnt := ItemCnt + 1;
            curr    := curr^.siNext_kb05
            END;
        (*ENDWHILE*) 
        g01check (kb52c2XSupplyCheck_csp03, csp3_n_lock,
              'free ItemCnt mismatch   ', ItemCnt,
              ItemCnt = RegionGlob.rglFreeItems_kb05);
        (* *)
        ExtentSegmCnt := 0;
        CurrSegm      := RegionGlob.rglExtentFirstSegm_kb05;
        WHILE (CurrSegm <> NIL) AND (ExtentSegmCnt <= glSupplyPoolSegments_kb05) DO
            BEGIN
            ExtentSegmCnt := ExtentSegmCnt + 1;
            CurrSegm      := CurrSegm^.sgmNext_kb05
            END;
        (*ENDWHILE*) 
        g01check (kb52c3XSupplyCheck_csp03, csp3_n_lock,
              'ExtentSegmCnt mismatch  ', ExtentSegmCnt,
              ExtentSegmCnt = RegionGlob.rglExtentItems_kb05 DIV ITEMS_PER_SUPPLY_SEGM_KB05);
        (* *)
        ItemCnt := 0;
        curr    := RegionGlob.rglExtentFirstFree_kb05;
        WHILE (curr <> NIL) AND (ItemCnt <= ExtentSegmCnt * ITEMS_PER_SUPPLY_SEGM_KB05) DO
            BEGIN
            g01check (kb52c3XSupplyCheck_csp03, csp3_n_lock,
                  'NormalItem in ExtentList', RegionGlob.rglOwnRegion_kb05, curr^.siExtentItem_kb05);
            ItemCnt := ItemCnt + 1;
            curr    := curr^.siNext_kb05
            END;
        (*ENDWHILE*) 
        g01check (kb52c3XSupplyCheck_csp03, csp3_n_lock,
              'free ExtItemCnt mismatch', ItemCnt,
              ItemCnt = RegionGlob.rglExtentFreeItems_kb05)
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xreq (
            debug    : tgg00_Debug;
            Req      : tkb05_ReqPtr);
 
VAR
      Uptr1 : tkb05_UnivItemPtr;
      Uptr2 : tkb05_UnivItemPtr;
 
BEGIN
IF  t01trace (debug) AND (Req <> NIL)
THEN
    BEGIN
    t01str30     (debug, '------------------------------');
    Uptr1.uiReq_kb05 :=                  Req;
    t01addr      (debug, ' R E Q =====', Uptr1.uiSupplyItem_kb05);
    Uptr1.uiReq_kb05 :=                  Req^.rqNextReq_kb05;
    Uptr2.uiReq_kb05 :=                  Req^.rqPrevReq_kb05;
    t01addr2     (debug, ' RQ next_req', Uptr1.uiSupplyItem_kb05
          ,              '    prev_req', Uptr2.uiSupplyItem_kb05);
    Uptr1.uiReq_kb05 :=                  Req^.rqLastReq_kb05;
    t01addr      (debug, ' RQ last_req', Uptr1.uiSupplyItem_kb05);
    t01int4      (debug, ' RQ transidx', Req^.rqTransIndex_kb05);
    t01bool      (debug, ' RQ eot     ', Req^.rqEotWanted_kb05);
    t01lockmode  (debug, ' RQ req_mode', Req^.rqReqMode_kb05);
    t01lockmode  (debug, ' RQ lockmode', Req^.rqLockMode_kb05);
    t01p2int4    (debug, ' RQ rowshare', Req^.rqRowShareLocks_kb05
          ,              '    row_excl', Req^.rqRowExclLocks_kb05)
    END
ELSE
    t01addr (debug, 'Req         ', NIL)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xrow_lock (
            debug : tgg00_Debug;
            Row : tkb05_RowLockPtr);
 
VAR
      Uptr1 : tkb05_UnivItemPtr;
      Uptr2 : tkb05_UnivItemPtr;
 
BEGIN
IF  t01trace (debug) AND (Row <> NIL)
THEN
    BEGIN
    t01str30      (debug, '------------------------------');
    Uptr1.uiRowLock_kb05 :=               Row;
    Uptr2.uiRowLock_kb05 :=               Row^.rlNextHashRow_kb05;
    t01addr2      (debug, ' R O W  lock', Uptr1.uiSupplyItem_kb05
          ,               '   next_hash', Uptr2.uiSupplyItem_kb05);
    Uptr1.uiReq_kb05 :=                   Row^.rlFirstReqRow_kb05;
    t01addr       (debug, ' R FirstReq ', Uptr1.uiSupplyItem_kb05);
    t01surrogate  (debug, ' R TabId    ', Row^.rlTabId_kb05);
    t01p2int4     (debug, ' R KeyLen   ', Row^.rlKeyLen_kb05
          ,               '   excl_idx ', Row^.rlExclTransIndex_kb05);
    t01p2int4     (debug, ' R row_share', Row^.rlRowShareLocks_kb05
          ,               '   row_optim', Row^.rlRowOptimCnt_kb05);
    t01int4       (debug, ' R row_vers ', Row^.rlRowOptimVers_kb05);
    t01p2int4     (debug, ' R share1_tr', Row^.rlShare1TransIndex_kb05
          ,               '   share2_tr', Row^.rlShare2TransIndex_kb05);
    Uptr1.uiRowIdItem_kb05 :=             Row^.rlRowIdItem_kb05;
    t01addr       (debug, ' R RowId    ', Uptr1.uiSupplyItem_kb05);
    IF  Row^.rlRowIdItem_kb05 <> NIL
    THEN
        t01buf (debug, Row^.rlRowIdItem_kb05^.riRowId_kb05, 1,
              sizeof  (Row^.rlRowIdItem_kb05^.riRowId_kb05))
    ELSE
        t01buf1 (debug, Row^.rlShortKey_kb05, 1,
              sizeof   (Row^.rlShortKey_kb05))
    (*ENDIF*) 
    END
ELSE
    t01addr (debug, 'RowLock     ', NIL)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xrow_region_check (VAR RowRegionGlob : tkb05_RegionGlob);
 
VAR
      CurrHash    : tsp00_Int4;
      ItemLimit   : tsp00_Int4;
      ReqItemCnt  : tsp00_Int4;
      RowItemCnt  : tsp00_Int4;
      SumItemCnt  : tsp00_Int4;
      CurrReq     : tkb05_ReqPtr;
      CurrRow     : tkb05_RowLockPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
IF  kb03Check.chkLock_kb00
THEN
    BEGIN
    ItemLimit := k52used_items_of_region (RowRegionGlob);
    IF  (RowRegionGlob.rglRowHash_kb05 <> NIL) AND (ItemLimit <= MAX_CHECK_ITEMS)
    THEN
        BEGIN
        SumItemCnt := 0;
        FOR CurrHash := 1 TO k51glob.glRowHashEntriesPerRegion_kb05 DO
            BEGIN
            CurrRow    := RowRegionGlob.rglRowHash_kb05^[CurrHash];
            RowItemCnt := 0;
            WHILE (CurrRow <> NIL) AND (RowItemCnt <= ItemLimit) DO
                BEGIN
                UnivItemPtr.uiRowLock_kb05 := CurrRow;
                kb52xitem_ptr_check (RowRegionGlob, UnivItemPtr);
                CurrReq    := CurrRow^.rlFirstReqRow_kb05;
                ReqItemCnt := 0;
                WHILE (CurrReq <> NIL) AND (ReqItemCnt <= ItemLimit) DO
                    BEGIN
                    UnivItemPtr.uiReq_kb05 := CurrReq;
                    kb52xitem_ptr_check (RowRegionGlob, UnivItemPtr);
                    SumItemCnt := SumItemCnt + 1;
                    ReqItemCnt := ReqItemCnt + 1;
                    CurrReq    := CurrReq^.rqNextReq_kb05
                    END;
                (*ENDWHILE*) 
                IF  ReqItemCnt > ItemLimit
                THEN
                    k52x_loop_error ('k52xrow_region_check    ', 1);
                (*ENDIF*) 
                SumItemCnt := SumItemCnt + 1;
                RowItemCnt := RowItemCnt + 1;
                CurrRow    := CurrRow^.rlNextHashRow_kb05
                END;
            (*ENDWHILE*) 
            IF  RowItemCnt > ItemLimit
            THEN
                k52x_loop_error ('k52xrow_region_check    ', 2)
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        IF  SumItemCnt > ItemLimit
        THEN
            k52x_loop_error ('k52xrow_region_check    ', 3)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xrow_trans (
            debug : tgg00_Debug;
            Row : tkb05_RowTransPtr);
 
VAR
      Uptr1 : tkb05_UnivItemPtr;
      Uptr2 : tkb05_UnivItemPtr;
 
BEGIN
IF  t01trace (debug) AND (Row <> NIL)
THEN
    BEGIN
    t01str30      (debug, '------------------------------');
    Uptr1.uiRowTrans_kb05 :=              Row;
    Uptr2.uiRowLock_kb05  :=              Row^.rtRow_kb05;
    t01addr2      (debug, ' R O W Trans', Uptr1.uiSupplyItem_kb05
          ,               '   RowLock  ', Uptr2.uiSupplyItem_kb05);
    Uptr1.uiRowTrans_kb05 :=              Row^.rtNextRow_kb05;
    Uptr2.uiRowTrans_kb05 :=              Row^.rtPrevRow_kb05;
    t01addr2      (debug, ' R next_row ', Uptr1.uiSupplyItem_kb05
          ,               '   prev_row ', Uptr2.uiSupplyItem_kb05);
    t01lockmode   (debug, ' R lockmode ', Row^.rtLockMode_kb05);
    t01lockstate  (debug, ' R lockstate', Row^.rtLockState_kb05);
    t01lockmode   (debug, ' R req_mode ', Row^.rtReqMode_kb05);
    t01lockstate  (debug, ' R req_state', Row^.rtReqState_kb05);
    t01p2int4     (debug, ' R row_vers ', Row^.rtRowOptimVers_kb05
          ,               '   rowregion', Row^.rtRowRegion_kb05);
    t01p2int4     (debug, ' R tab_vers ', Row^.rtTabOptimVers_kb05
          ,               '   row_hash ', Row^.rtRowHash_kb05);
    t01int4       (debug, ' R KeyLen   ', Row^.rtKeyLen_kb05);
    t01buf1 (debug, Row^.rtShortKey_kb05, 1, sizeof(Row^.rtShortKey_kb05))
    END
ELSE
    t01addr (debug, 'RowTrans    ', NIL)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xtab_lock (
            debug : tgg00_Debug;
            Tab : tkb05_TabLockPtr);
 
VAR
      Uptr1 : tkb05_UnivItemPtr;
      Uptr2 : tkb05_UnivItemPtr;
 
BEGIN
IF  t01trace (debug) AND (Tab <> NIL)
THEN
    BEGIN
    t01str30      (debug, '------------------------------');
    Uptr1.uiTabLock_kb05 :=               Tab;
    Uptr2.uiTabLock_kb05 :=               Tab^.tlNextHashTab_kb05;
    t01addr2      (debug, ' T A B  lock', Uptr1.uiSupplyItem_kb05
          ,               '   next_hash', Uptr2.uiSupplyItem_kb05);
    Uptr1.uiReq_kb05 :=                   Tab^.tlFirstReqTab_kb05;
    Uptr2.uiReq_kb05 :=                   Tab^.tlFirstReqRow_kb05;
    t01addr2      (debug, ' T req_tab  ', Uptr1.uiSupplyItem_kb05
          ,               '   req_row  ', Uptr2.uiSupplyItem_kb05);
    t01surrogate  (debug, ' T TabId    ', Tab^.tlTabId_kb05);
    t01bool       (debug, ' T sys_excl ', Tab^.tlIsSysExcl_kb05);
    t01p2int4     (debug, ' T excl_idx ', Tab^.tlExclTransIndex_kb05
          ,               '   tab_vers ', Tab^.tlTabOptimVers_kb05);
    t01p2int4     (debug, ' T share1_tr', Tab^.tlShare1TransIndex_kb05
          ,               '   share2_tr', Tab^.tlShare2TransIndex_kb05);
    t01p2int4     (debug, ' T sys_share', Tab^.tlSysShareLocks_kb05
          ,               '   tab_share', Tab^.tlTabShareLocks_kb05);
    t01p2int4     (debug, ' T row_share', Tab^.tlRowShareLocks_kb05
          ,               '   row_optim', Tab^.tlRowOptimCnt_kb05);
    t01int4       (debug, ' T row_excl ', Tab^.tlRowExclLocks_kb05)
    END
ELSE
    t01addr (debug, 'TabLock     ', NIL)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xtab_region_check (VAR TabRegionGlob : tkb05_RegionGlob);
 
VAR
      i           : integer;
      CurrHash    : tsp00_Int4;
      ItemLimit   : tsp00_Int4;
      TabItemCnt  : tsp00_Int4;
      ReqItemCnt  : tsp00_Int4;
      SumItemCnt  : tsp00_Int4;
      CurrReq     : tkb05_ReqPtr;
      CurrTab     : tkb05_TabLockPtr;
      UnivItemPtr : tkb05_UnivItemPtr;
 
BEGIN
IF  kb03Check.chkLock_kb00
THEN
    BEGIN
    ItemLimit := k52used_items_of_region (TabRegionGlob);
    IF  (TabRegionGlob.rglTabHash_kb05 <> NIL) AND (ItemLimit <= MAX_CHECK_ITEMS)
    THEN
        BEGIN
        SumItemCnt := 0;
        FOR CurrHash := 1 TO k51glob.glTabHashEntriesPerRegion_kb05 DO
            BEGIN
            CurrTab    := TabRegionGlob.rglTabHash_kb05^[CurrHash];
            TabItemCnt := 0;
            WHILE (CurrTab <> NIL) AND (TabItemCnt <= ItemLimit) DO
                BEGIN
                UnivItemPtr.uiTabLock_kb05 := CurrTab;
                kb52xitem_ptr_check (TabRegionGlob, UnivItemPtr);
                FOR i := 1 TO 2 DO
                    BEGIN
                    IF  i = 1
                    THEN
                        CurrReq := CurrTab^.tlFirstReqTab_kb05
                    ELSE
                        CurrReq := CurrTab^.tlFirstReqRow_kb05;
                    (*ENDIF*) 
                    ReqItemCnt := 0;
                    WHILE (CurrReq <> NIL) AND (ReqItemCnt <= ItemLimit) DO
                        BEGIN
                        UnivItemPtr.uiReq_kb05 := CurrReq;
                        kb52xitem_ptr_check (TabRegionGlob, UnivItemPtr);
                        SumItemCnt := SumItemCnt + 1;
                        ReqItemCnt := ReqItemCnt + 1;
                        CurrReq    := CurrReq^.rqNextReq_kb05
                        END;
                    (*ENDWHILE*) 
                    IF  ReqItemCnt > ItemLimit
                    THEN
                        k52x_loop_error ('k52xrow_region_check    ', i)
                    (*ENDIF*) 
                    END;
                (*ENDFOR*) 
                SumItemCnt := SumItemCnt + 1;
                TabItemCnt := TabItemCnt + 1;
                CurrTab    := CurrTab^.tlNextHashTab_kb05
                END;
            (*ENDWHILE*) 
            IF  TabItemCnt > ItemLimit
            THEN
                k52x_loop_error ('k52xrow_region_check    ', 3)
            (*ENDIF*) 
            END;
        (*ENDFOR*) 
        IF  SumItemCnt > ItemLimit
        THEN
            k52x_loop_error ('k52xrow_region_check    ', 4)
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xtab_trans (
            debug : tgg00_Debug;
            Tab : tkb05_TabTransPtr);
 
VAR
      Uptr1 : tkb05_UnivItemPtr;
      Uptr2 : tkb05_UnivItemPtr;
 
BEGIN
IF  t01trace (debug) AND (Tab <> NIL)
THEN
    BEGIN
    t01str30      (debug, '------------------------------');
    Uptr1.uiTabTrans_kb05 :=              Tab;
    Uptr2.uiTabLock_kb05  :=              Tab^.ttTab_kb05;
    t01addr2      (debug, ' T A B Trans', Uptr1.uiSupplyItem_kb05
          ,               '   TabLock  ', Uptr2.uiSupplyItem_kb05);
    Uptr1.uiRowTrans_kb05 :=              Tab^.ttFirstRow_kb05;
    Uptr2.uiRowTrans_kb05 :=              Tab^.ttConsistentRow_kb05;
    t01addr2      (debug, ' T first_row', Uptr1.uiSupplyItem_kb05
          ,               '   consistnt', Uptr2.uiSupplyItem_kb05);
    Uptr1.uiTabTrans_kb05 :=              Tab^.ttNextTab_kb05;
    t01addr       (debug, ' T next_tab ', Uptr1.uiSupplyItem_kb05);
    t01surrogate  (debug, ' T TabId    ', Tab^.ttTabId_kb05);
    t01lockmode   (debug, ' T lockmode ', Tab^.ttLockMode_kb05);
    t01lockstate  (debug, ' T lockstate', Tab^.ttLockState_kb05);
    t01lockmode   (debug, ' T req_mode ', Tab^.ttReqMode_kb05);
    t01lockstate  (debug, ' T req_state', Tab^.ttReqState_kb05);
    t01p2int4     (debug, ' T tabregion', Tab^.ttTabRegion_kb05
          ,               '   tab_hash ', Tab^.ttTabHash_kb05);
    t01p2int4     (debug, ' T row_share', Tab^.ttRowShareLocks_kb05
          ,               '   row_optim', Tab^.ttRowOptimCnt_kb05);
    t01int4       (debug, ' T row_excl ', Tab^.ttRowExclLocks_kb05);
    END
ELSE
    t01addr (debug, 'TabTrans    ', NIL)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xtrans (
            debug      : tgg00_Debug;
            TransEntry : tkb05_TransEntryPtr);
 
VAR
      ItemCnt : tsp00_Int4;
      Uptr1   : tkb05_UnivItemPtr;
      Uptr2   : tkb05_UnivItemPtr;
      CurrRow : tkb05_RowTransPtr;
      CurrTab : tkb05_TabTransPtr;
 
BEGIN
IF  (TransEntry <> NIL) AND t01trace (debug)
THEN
    WITH TransEntry^ DO
        BEGIN
        t01str30         (debug, '------------------------------');
        t01addr_1        (debug, '=== TRANS ==', TransEntry);
        ta01SessionTrans (debug, ' TR Trans   ', teSessionId_kb05
              ,                                  teSelectTransId_kb05
              ,                                  teWriteTransId_kb05
              ,                                  teSubtransId_kb05);
        t01p2int4        (debug, ' TR index   ', teOwnIndex_kb05
              ,                  '    proc_id ', teTaskId_kb05);
        (* *)
        t01addr_1        (debug, ' TR own_addr', teOwnAddr_kb05);
        t01addr_1        (debug, ' TR nexthash', teNextHash_kb05);
        t01addr_1        (debug, '    prevhash', tePrevHash_kb05);
        t01addr_1        (debug, ' TR next_tr ', teNextTrans_kb05);
        t01addr_1        (debug, '    prev_tr ', tePrevTrans_kb05);
        Uptr1.uiTabTrans_kb05 :=                 teFirstTab_kb05;
        t01addr          (debug, ' TR frst_tab', Uptr1.uiSupplyItem_kb05);
        Uptr1.uiTabTrans_kb05 :=                 teTabRecentlyUsed_kb05;
        Uptr2.uiRowTrans_kb05 :=                 teRowRecentlyUsed_kb05;
        t01addr2         (debug, ' TR tab_used', Uptr1.uiSupplyItem_kb05
              ,                  '    row_used', Uptr2.uiSupplyItem_kb05);
        Uptr1.uiTabTrans_kb05 :=                 teReqTab_kb05;
        Uptr2.uiRowTrans_kb05 :=                 teReqRow_kb05;
        t01addr2         (debug, ' TR req_tab ', Uptr1.uiSupplyItem_kb05
              ,                  '    req_row ', Uptr2.uiSupplyItem_kb05);
        (* *)
        t01c4int   (debug, ' TR userid  ', teUserId_kb05);
        t01p2int4  (debug, ' TR tmp_func', teLog_kb05.tlogTempFunctRollb_kb05
              ,            '    t_logCnt', teLog_kb05.tlogTempEntryCnt_kb05);
        t01p2int4  (debug, ' TR log_root', teLog_kb05.tlogTempFileRoot_kb05
              ,            '    aux_fnno', teLog_kb05.tlogAuxFnNo_kb05);
        t01int4    (debug, ' TR req_time', teReqTimeout_kb05);
        t01p2int4  (debug, ' TR region  ', teOwnRegion_kb05
              ,            '    time_wrt', teTimeLastWrite_kb05);
        (* --- te_info --- *)
        IF  teInfo_kb05 = [ ]
        THEN
            t01name1 (debug, ' TR info    ', 'EMPTY             ')
        ELSE
            BEGIN
            IF  tiAuxPermExists_ekb05 in teInfo_kb05
            THEN
                t01name1 (debug, ' TR info    ', 'tiAuxPermExists   ');
            (*ENDIF*) 
            IF  tiAuxTempExists_ekb05 in teInfo_kb05
            THEN
                t01name1 (debug, ' TR info    ', 'tiAuxTempExists   ');
            (*ENDIF*) 
            IF  tiCollision_ekb05 in teInfo_kb05
            THEN
                t01name1 (debug, ' TR info    ', 'tiCollision       ');
            (*ENDIF*) 
            IF  tiExclusiveUser_ekb05 in teInfo_kb05
            THEN
                t01name1 (debug, ' TR info    ', 'tiExclusiveUser   ');
            (*ENDIF*) 
            IF  tiUserTask_ekb05 in teInfo_kb05
            THEN
                t01name1 (debug, ' TR info    ', 'tiUserTask        ');
            (*ENDIF*) 
            IF  tiPriority_ekb05 in teInfo_kb05
            THEN
                t01name1 (debug, ' TR info    ', 'tiPriority        ');
            (*ENDIF*) 
            IF  tiCancelled_ekb05 in teInfo_kb05
            THEN
                t01name1 (debug, ' TR info    ', 'tiCancelled       ');
            (*ENDIF*) 
            END;
        (*ENDIF*) 
        t01p2int4   (debug, ' TR lockmode', ord (teLockMode_kb05)
              ,             '    req_mode', ord (teReqMode_kb05));
        t01messtype (debug, ' TR state   ', teState_kb05);
        t01p2int4   (debug, ' TR start_dt', teStartDate_kb05
              ,             '    start_tm', teStartTime_kb05);
        CurrTab := teFirstTab_kb05;
        ItemCnt := 0;
        WHILE (CurrTab <> NIL) AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
            BEGIN
            Uptr1.uiTabTrans_kb05 := CurrTab;
            t01addr (debug, ' TR   Tab   ', Uptr1.uiSupplyItem_kb05);
            CurrRow := CurrTab^.ttFirstRow_kb05;
            WHILE (CurrRow <> NIL) AND (ItemCnt <= k51glob.glMaxItemsPerRegion_kb05) DO
                BEGIN
                Uptr1.uiRowTrans_kb05 := CurrRow;
                t01addr (debug, ' TR   Row   ', Uptr1.uiSupplyItem_kb05);
                ItemCnt := ItemCnt + 1;
                CurrRow := CurrRow^.rtNextRow_kb05
                END;
            (*ENDWHILE*) 
            ItemCnt := ItemCnt + 1;
            CurrTab := CurrTab^.ttNextTab_kb05
            END;
        (*ENDWHILE*) 
        IF  ItemCnt > k51glob.glMaxItemsPerRegion_kb05
        THEN
            k52x_loop_error ('k52xtrans               ', 1)
        (*ENDIF*) 
        END
    (*ENDWITH*) 
ELSE
    t01addr_1 (debug, 'TransEntry  ', TransEntry)
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      k52xwanted_lock (
            debug            : tgg00_Debug;
            VAR WantedLock   : tkb05_WantedLock);
 
BEGIN
IF  t01trace (debug)
THEN
    WITH WantedLock DO
        BEGIN
        t01surrogate (debug, ' W TabId    ', wlTabId_kb05     );
        t01lockmode  (debug, ' W lockmode ', wlMode_kb05      );
        t01lockstate (debug, ' W lockstate', wlState_kb05     );
        t01int4      (debug, ' W KeyLen   ', wlKeyLen_kb05    );
        t01bool      (debug, ' W row_wnted', wlRowWanted_kb05);
        IF  hdCheckCollision_ekb05 in wlHandling_kb05
        THEN
            t01name1 (debug, ' W handling ', 'check_collision   ');
        (*ENDIF*) 
        IF  hdInsLock_ekb05 in wlHandling_kb05
        THEN
            t01name1 (debug, ' W handling ', 'ins_lock          ');
        (*ENDIF*) 
        IF  hdInsReq_ekb05 in wlHandling_kb05
        THEN
            t01name1 (debug, ' W handling ', 'ins_req           ');
        (*ENDIF*) 
        IF  hdCheckOwnReq_ekb05 in wlHandling_kb05
        THEN
            t01name1 (debug, ' W handling ', 'check_own_req     ');
        (*ENDIF*) 
        t01lockmode  (debug, ' W granted  ', wlGrantedMode_kb05);
        IF  wlRowWanted_kb05
        THEN
            t01buf (debug, wlRowId_kb05, 1, sizeof (wlRowId_kb05))
        (*ENDIF*) 
        END
    (*ENDWITH*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb52xitem_ptr_check (
            VAR RegionGlob : tkb05_RegionGlob;
            ItemPtr : tkb05_UnivItemPtr);
 
VAR
      IsOk     : boolean;
      i        : tsp00_Int4;
      CurrSegm : tkb05_SupplySegmPtr;
      SegmCnt  : tsp00_Int4;
 
BEGIN
IsOk := false;
IF  ItemPtr.uiSupplyItem_kb05 <> NIL
THEN
    WITH k51glob DO
        IF  NOT ItemPtr.uiSupplyItem_kb05^.siExtentItem_kb05
        THEN
            BEGIN
            i := 1;
            WHILE (i <= glSupplyItemsPerRegion_kb05) AND NOT IsOk DO
                IF  ItemPtr.uiSupplyItem_kb05 = @RegionGlob.rglSupplyBlock_kb05^[i]
                THEN
                    IsOk := true
                ELSE
                    i := i + 1
                (*ENDIF*) 
            (*ENDWHILE*) 
            END
        ELSE
            BEGIN
            SegmCnt  := 0;
            CurrSegm := RegionGlob.rglExtentFirstSegm_kb05;
            WHILE NOT IsOk AND (CurrSegm <> NIL) AND (SegmCnt <= glSupplyPoolSegments_kb05) DO
                BEGIN
                i := 1;
                WHILE (i <= ITEMS_PER_SUPPLY_SEGM_KB05) AND NOT IsOk DO
                    IF  ItemPtr.uiSupplyItem_kb05 = @CurrSegm^.sgmItemList_kb05[i]
                    THEN
                        IsOk := true
                    ELSE
                        i := i + 1;
                    (*ENDIF*) 
                (*ENDWHILE*) 
                SegmCnt  := SegmCnt + 1;
                CurrSegm := CurrSegm^.sgmNext_kb05
                END;
            (*ENDWHILE*) 
            IF  SegmCnt > glSupplyPoolSegments_kb05
            THEN
                k52x_loop_error ('kb52xitem_ptr_check     ', 1)
            (*ENDIF*) 
            END;
        (*ENDIF*) 
    (*ENDWITH*) 
(*ENDIF*) 
IF  NOT IsOk
THEN
    BEGIN
    t01addr (td_always, '*** BAD PTR ', ItemPtr.uiSupplyItem_kb05);
    g01abort (kb52c1XPtrCheck_csp03, csp3_n_lock,
          'illegal ItemAddr, region', RegionGlob.rglOwnRegion_kb05)
    END
(*ENDIF*) 
END;
 
&endif
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
