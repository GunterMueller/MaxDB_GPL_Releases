/****************************************************************************
  module      : vkb05
  author      : JuergenA
  responsible : UweH
  special area: KB_functions
  created     : 1980-02-15
  last changed: 2000-01-07  12:00
  see also    :
  description :
 .nf
 
    ========== licence begin  GPL
    Copyright (c) 2000-2005 SAP AG
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    ========== licence end
.fo
 
 
*****************************************************************************/
 
.tt 1 $SAP$LiveCache$VKB05$
.tt 3 $UweH$KB_functions$2000-08-18$
 
Module  : KB_functions
 
Define  :
 
        PROCEDURE
              k05cold_functions (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              k05functions (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              k05GetBadLogVolume (VAR mblock : tgg00_MessBlock);
 
        PROCEDURE
              k05init;
 
        FUNCTION
              k05is_fatal_error (e : tgg00_BasisError): boolean;
 
        FUNCTION
              k05MaxStackUsage : tsp00_Int4;
 
        PROCEDURE
              kb05ReturnErrorHandling (
                    VAR Trans        : tgg00_TransContext;
                    BeginSubtransSet : boolean;
                    StartMessType    : tgg00_MessType);
 
.CM *-END-* define --------------------------------------
.sp;.cp 3
Use     :
 
        FROM
              Scanner : VAK01;
 
        VAR
              a01diag_monitor_on : boolean;
              a01diag_analyze_on : boolean;
 
      ------------------------------ 
 
        FROM
              AK_Table : VAK11;
 
        PROCEDURE
              a11put_date_time (
                    VAR date : tsp00_Int4;
                    VAR time : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              KB_Check : VKB03;
 
        PROCEDURE
              kb03CheckInit;
 
      ------------------------------ 
 
        FROM
              KB_index_handling : VKB33;
 
        PROCEDURE
              k33create_index (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k33diagnose_index (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_headmaster : VKB38;
 
        PROCEDURE
              k38e_autosave_end (VAR t : tgg00_TransContext; is_quick : boolean);
 
        PROCEDURE
              k38i_autosave_init (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k38set_not_generated;
 
        PROCEDURE
              k38sh_autosave_show (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_stringcol_copy_trunc_expand : VKB43;
 
        PROCEDURE
              k43begin_load (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k43cwrite_column (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k43cnwrite_column (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_stringcol_read_search_length : VKB45;
 
        PROCEDURE
              k45cnread_column (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_trans_state : VKB50;
 
        PROCEDURE
              k50not_connected (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k50transindex_check (VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              KB_locklist : VKB51;
 
        VAR
              k51_kb_func_calls : tsp00_8ByteCounter;
 
        PROCEDURE
              k51examine_trans (VAR t : tgg00_TransContext);
 
        PROCEDURE
              k51set_not_generated;
 
        PROCEDURE
              k51sys_share_remove (
                    TaskId                : tsp00_TaskId;
                    TransIndex            : tgg00_TransIndex;
                    VAR TransState        : tgg00_TransState);
 
      ------------------------------ 
 
        FROM
              KB_show_lock : VKB52;
 
        PROCEDURE
              k52show_lock (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_transaction : VKB53;
 
        PROCEDURE
              k53connect (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k53end_of_trans (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k53lock_command (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k53release (
                    VAR t            : tgg00_TransContext;
                    force_release    : boolean;
                    internal_session : boolean);
 
        PROCEDURE
              k53unlock (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k53wait (
                    VAR t     : tgg00_TransContext;
                    MessType  : tgg00_MessType;
                    MessType2 : tgg00_MessType2);
 
        PROCEDURE
              k53perm_temp_lock (
                    VAR t          : tgg00_TransContext;
                    lock_unlock    : tgg00_MessType;
                    lock_mode      : tgg00_LockReqMode;
                    lock_handling  : tgg00_HandlingSet;
                    VAR lock_tabid : tgg00_Surrogate;
                    VAR k          : tgg00_Lkey);
 
      ------------------------------ 
 
        FROM
              KB_temp_logging : VKB54;
 
        PROCEDURE
              k54create_drop_temp_file (
                    VAR t            : tgg00_TransContext;
                    create_drop_type : tgg00_MessType;
                    VAR temp_file    : tgg00_FileId);
 
      ------------------------------ 
 
        FROM
              KB_Logging : VKB560;
 
        PROCEDURE
              kb560BeginSubtransLogTransaction (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              kb560EndSubtransLogTransaction (VAR Trans : tgg00_TransContext);
 
        PROCEDURE
              kb560RollbackLogTransAction (
                    VAR Trans    : tgg00_TransContext;
                    RollbackKind : tgg00_MessType2;
                    SubTransNo   : tgg00_SubtransNo);
 
        PROCEDURE
              kb560StartSavepoint (
                    VAR Trans : tgg00_TransContext;
                    MessType2 : tgg00_MessType2);
 
      ------------------------------ 
 
        FROM
              KB_restart_record : VKB57;
 
        PROCEDURE
              k57sequence_no (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k57set_not_generated;
 
        PROCEDURE
              k57stamp_logged (
                    VAR trans_state : tgg00_TransState;
                    task_id         : tsp00_TaskId;
                    stamp_type      : tgg00_MessType2;
                    buffer          : tsp00_MoveObjPtr;
                    buf_len         : tsp00_Int4;
                    VAR b_err       : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              KB_ins_del_upd : VKB61;
 
        PROCEDURE
              k61add_upd_record (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k61del_upd_qual (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k61ins_del_upd (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k61table_ins_del_upd (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_file_table_handling : VKB64;
 
        PROCEDURE
              k64begin_load (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64change_filetype (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64cmd_drop (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64end_load (VAR m  : tgg00_MessBlock);
 
        PROCEDURE
              k64set_file_version (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64set_treeleafnodes (
                    VAR t      : tgg00_TransContext;
                    VAR fileId : tgg00_FileId);
 
        PROCEDURE
              k64table_create (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k64temp_file_handling (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_change_key : VKB66;
 
        PROCEDURE
              k66modify_table (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_get : VKB71;
 
        PROCEDURE
              k71column_statistic (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k71file_statistic (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k71get (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k71select (VAR m  : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              Single_Select : VKB720;
 
        PROCEDURE
              k720_single_select (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              Single_Select_Part2 : VKB721;
 
        PROCEDURE
              k721eval_pagecount (VAR m : tgg00_MessBlock);
 
        PROCEDURE
              k721read_subquery (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              Unionhandling : VKB722;
 
        PROCEDURE
              k722_union_select (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_Join_Select : VKB74;
 
        PROCEDURE
              k74_join_select (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              KB_Fetch : VKB75;
 
        PROCEDURE
              k75_fetch (VAR m : tgg00_MessBlock);
 
      ------------------------------ 
 
        FROM
              filesysteminterface_1  : VBD01;
 
        PROCEDURE
              b01check_table (
                    VAR t                : tgg00_TransContext;
                    VAR file_id          : tgg00_FileId;
                    long_col_cnt         : tsp00_Int2;
                    new_long_col_cnt     : tsp00_Int2;
                    bWithExtendedCheck   : boolean;
                    check_long_existence : boolean;
                    bQuiet               : boolean;
                    bUpdateLeaves        : boolean);
 
        PROCEDURE
              b01end_read_only (VAR t : tgg00_TransContext);
 
      ------------------------------ 
 
        FROM
              Trace : VBD120;
 
        PROCEDURE
              b120InsertTrace (
                    VAR t        : tgg00_TransContext;
                    trace_layer  : tgg00_Debug;
                    trace_object : tgg00_VtraceType;
                    body_len     : tsp00_Int2;
                    trace_body   : tgg11_VtraceBodyPtr);
 
      ------------------------------ 
 
        FROM
              task_temp_data_cache : VBD21;
 
        PROCEDURE
              b21m_reset_monitor (
                    temp_cache_ptr : tgg00_TempDataCachePtr;
                    reset_sum : boolean);
 
      ------------------------------ 
 
        FROM
              FileDir_Wrapper : vbd998;
 
        FUNCTION
              bd998IsTempFile(
                    VAR trans  : tgg00_TransContext;
                    VAR fileId : tgg00_FileId(*ptocConst*)) : boolean;
 
        FUNCTION
              bd998GetExtendedTempFileType(
                    VAR trans      : tgg00_TransContext;
                    VAR tempFileId : tgg00_FileId(*ptocConst*)) : tgg00_TfnTemp;
 
      ------------------------------ 
 
        FROM
              RTE_kernel : VEN101;
 
        PROCEDURE
              vclock (
                    VAR sec      : tsp00_Int4;
                    VAR microsec : tsp00_Int4);
 
        PROCEDURE
              vscheck (VAR maxstacksize : tsp00_Int4);
 
        PROCEDURE
              vsReinit(
                    pid      : tsp00_TaskId;
                    max_used : tsp00_Int4);
 
        PROCEDURE
              vsscan (VAR maxstacksize : tsp00_Int4);
 
      ------------------------------ 
 
        FROM
              Configuration_Parameter : VGG01;
 
        VAR
              g01vtrace                 : tgg00_VtraceState;
              gg01_kb_stack_measurement : boolean;
 
        PROCEDURE
              g01abort (
                    msg_no     : tsp00_Int4;
                    msg_label  : tsp00_C8;
                    msg_text   : tsp00_C24;
                    bad_value  : tsp00_Int4);
 
        PROCEDURE
              g01optextmsg (
                    msg_prio  : tsp3_priority;
                    msg_type  : tsp3_msg_type;
                    msg_no    : tsp00_Int4;
                    msg_label : tsp00_C8;
                    msg_text  : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              Kernel_move_and_fill : VGG101;
 
        PROCEDURE
              SAPDB_PascalMove  (
                    mod_id         : tsp00_C6;
                    mod_intern_num : tsp00_Int4;
                    source_upb     : tsp00_Int4;
                    destin_upb     : tsp00_Int4;
                    source         : tsp00_MoveObjPtr;
                    source_pos     : tsp00_Int4;
                    destin         : tsp00_MoveObjPtr;
                    destin_pos     : tsp00_Int4;
                    length         : tsp00_Int4;
                    VAR e          : tgg00_BasisError);
 
      ------------------------------ 
 
        FROM
              GG_edit_routines : VGG17;
 
        PROCEDURE
              g17int4to_line (
                    int       : tsp00_Int4;
                    with_zero : boolean;
                    int_len   : integer;
                    ln_pos    : integer;
                    VAR ln    : tsp00_Line);
 
        PROCEDURE
              g17basis_err_to_line (
                    b_err      : tgg00_BasisError;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_C40);
 
        PROCEDURE
              g17messtype_to_line (
                    mess_type  : tgg00_MessType;
                    VAR ln_len : integer;
                    VAR ln     : tsp00_C40);
 
      ------------------------------ 
 
        FROM
              KernelAdministration_Interface : VGG999;
 
        PROCEDURE
              gg999CheckData(
                    VAR trans          : tgg00_TransContext;
                    bWithExtendedCheck : boolean;
                    bWithIndexes       : boolean;
                    bWithDeleteUnreferencedBlobs : boolean;
                    VAR badIndexCount  : tsp00_Int4;
                    VAR totalBadCount  : tsp00_Int4 );
 
        PROCEDURE
              gg999CheckDataWithUpdate(
                    VAR trans          : tgg00_TransContext;
                    bWithExtendedCheck : boolean;
                    VAR pagesUsed      : tsp00_Int4;
                    VAR blocksReleased : tsp00_Int4;
                    VAR badIndexCount  : tsp00_Int4;
                    VAR totalBadCount  : tsp00_Int4 );
 
        PROCEDURE
              gg999GetBadLogVolume(
                    VAR trans      : tgg00_TransContext;
                    VAR devicename : tsp00_VFilename );
 
        PROCEDURE
              gg999WriteUserForcedDump(
                    TaskId           : tsp00_TaskId;
                    VAR FileName     : tsp00_VFilename;
                    VAR DumpStateSet : tgg00_DumpStateSet );
 
        PROCEDURE
              ggg999Diagnose( VAR MessBlock : tgg00_MessBlock );
&       ifdef TRACE
 
      ------------------------------ 
 
        FROM
              Test_Procedures : VTA01;
 
        PROCEDURE
              t01handling (
                    layer : tgg00_Debug;
                    nam : tsp00_Sname;
                    s   : tgg00_HandlingSet);
 
        PROCEDURE
              t01messblock (
                    debug         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    VAR m         : tgg00_MessBlock);
 
        PROCEDURE
              t01messtype (
                    layer        : tgg00_Debug;
                    nam          : tsp00_Sname;
                    mess_type    : tgg00_MessType);
 
        PROCEDURE
              t01mess2type (
                    layer         : tgg00_Debug;
                    nam           : tsp00_Sname;
                    mess_type     : tgg00_MessType2);
 
        PROCEDURE
              t01name (layer : tgg00_Debug; nam : tsp00_Name);
 
        FUNCTION
              t01trace (debug : tgg00_Debug) : boolean;
&       endif
 
.CM *-END-* use -----------------------------------------
.sp;.cp 3
Synonym :
 
        PROCEDURE
              g17basis_err_to_line;
 
              tsp00_Line tsp00_C40
 
        PROCEDURE
              g17messtype_to_line;
 
              tsp00_Line tsp00_C40
 
.CM *-END-* synonym -------------------------------------
.sp;.cp 3
Author  : J. Stanicki/J.Aurisch
.sp
.cp 3
Created : 1980-02-15
.sp
.cp 3
.sp
.cp 3
Release :      Date : 2000-10-18
.sp
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Specification:
 
Update Use:
 
Procedure K05COLD_FUNCTIONS
.sp
Distributor for KB functions in COLD mode.
.sp 2;.cp 4
Procedure K05FUNCTIONS
.sp
Distributor for KB functions in a restarted database (WARM mode).
At the end of K05FUNCTIONS, a rollback is executed if
the error KB_ROLLBACK_WANTED is set and a command rollback is executed
if a non fatal error is occurred.
The fact that the process is no longer in the KB layer
is recorded in the lock list so that if there is a lock timeout,
the timeout process can remove the locks.
.br
When "fatal" errors occur, an emergency shutdown is executed.
.sp 2;.cp 4
Procedure K05INIT
.sp
This procedure is called when SQL-DB (XSTART) is started.  It sets
the NOT GENERATED state for the various global KB variables.
.sp 2;.cp 4
Function K05IS_FATAL_ERROR
.sp
The result of this function is TRUE if the specified basis error should
lead to an emergency shutdown.
.CM *-END-* specification -------------------------------
.sp 2;
***********************************************************
.sp
.cp 10
.fo
.oc _/1
Description:
.sp
The distributor can be regarded as a driver program for the
local DB system consisting of the KB and BD layer.
.br
The individual procedures for the orders to be executed are called
via K05COLD_FUNCTIONS and K05FUNCTIONS, according to the
message types received. After the order has been processed, the
result is sent back (M_RETURN_RESULT) or, in the
case of an error, a return message (M_RETURN_ERROR) is sent back
with the basis error.
.sp 2;.cp 5;.nf
VTRACE for KB calls with tree id (and key):
-----------------------------------+-------------
| mess type| mess2 type | table id | klen | key |
-----------------------------------+-------------
      1           1   SURROGATE_MXGG00   1    klen
.sp 2;.cp 5
VTRACE for other commands:
--------------------------
| mess type | mess2 type |
--------------------------
      1            1
.sp 2;.cp 5
VTRACE for termination of VKB05
---------------
| basis error |
---------------
       2
.fo
.CM *-END-* description ---------------------------------
.sp 2
***********************************************************
.sp
.nf
.oc _/1
Structure:
 
.CM *-END-* structure -----------------------------------
.sp 2
**********************************************************
.sp
.cp 25
.nf
.oc _/1
.CM -lll-
Code    :
 
 
VAR
      kb05MaxStackUsed : tsp00_Int4;
 
CONST
      c_with_lock        = true;
      c_quick            = true;
      c_reset_sum        = true;
      c_internal_session = true;
 
 
(*------------------------------*) 
 
PROCEDURE
      k05cold_functions (VAR mblock : tgg00_MessBlock);
 
VAR
      StartMessType : tgg00_MessType;
      mess_trace    : tgg11_KbDateTimeTrace;
 
BEGIN
mblock.mb_trns^.trError_gg00 := e_ok;
StartMessType                := mblock.mb_type;
&ifdef TRACE
t01name      (kb_funct, '==================');
t01messblock (kb_funct, 'MESSBUF ----', mblock);
&endif
IF  g01vtrace.vtrAll_gg00
THEN
    BEGIN
    WITH mess_trace.kbdtHead_gg11 DO
        BEGIN
        kbMessType_gg11  := mblock.mb_type;
        kbMessType2_gg11 := mblock.mb_type2;
        kbError_gg11     := e_ok
        END;
    (*ENDWITH*) 
    a11put_date_time (mess_trace.kbdtDate_gg11, mess_trace.kbdtTime_gg11);
    b120InsertTrace (mblock.mb_trns^, kb, vttKbColdFunctions_egg00, sizeof (mess_trace), @mess_trace);
    END;
(*ENDIF*) 
IF  (mblock.mb_trns^.trIndex_gg00 <> cgg_nil_transindex) AND
    (mblock.mb_trns^.trError_gg00   <> e_move_error      )
THEN
    k50transindex_check (mblock.mb_trns^);
(*ENDIF*) 
IF  mblock.mb_trns^.trError_gg00 <> e_move_error
THEN
    CASE mblock.mb_type OF
        m_change   (*
        ========   *):
            mblock.mb_trns^.trError_gg00 := e_not_implemented;
        m_diagnose   (*
        ==========   *):
            IF  mblock.mb_type2 = mm_dump
            THEN
                gg999WriteUserForcedDump (mblock.mb_trns^.trTaskId_gg00,
                      mblock.mb_qual^.mut_hostfn, mblock.mb_qual^.mut_dump_state )
            ELSE
                ggg999Diagnose (mblock);
            (*ENDIF*) 
        m_insert   (*
        ========   *):
            k61add_upd_record (mblock);
        m_outcopy   (*
        =========   *):
            mblock.mb_trns^.trError_gg00 := e_not_implemented;
        m_release   (*
        =========   *):
            BEGIN
            END;
        m_update_rec   (*
        ============   *)
        :
            k61add_upd_record (mblock);
        m_verify   (*
        ========   *)
        :
            IF  mblock.mb_qual^.mv_delete_longfile (* PTS 1133300 UH 2005-01-11 *)
            THEN
                kb05_CheckData (mblock) (* PTS 1133300 UH 2005-01-11 *)
            ELSE
                kb05_CheckDataWithUpdate (mblock);
            (*ENDIF*) 
        OTHERWISE
            mblock.mb_trns^.trError_gg00 := e_not_implemented
        END;
    (*ENDCASE*) 
(*ENDIF*) 
IF  (mblock.mb_type <> m_return_result)
    OR
    ((mblock.mb_trns^.trError_gg00 <> e_ok)
    AND
    ((StartMessType <> m_outcopy) OR
    (mblock.mb_trns^.trError_gg00 <> e_no_next_record)))
THEN
    BEGIN
    mblock.mb_type  := m_return_error;
    mblock.mb_type2 := mm_nil;
    IF  StartMessType <> m_diagnose
    THEN
        mblock.mb_data_len := 0;
    (*ENDIF*) 
    IF  (StartMessType = m_verify          ) OR
        (StartMessType = m_save_parallel   ) OR
        (StartMessType = m_restore_parallel)
    THEN
        mblock.mb_struct := mbs_buf
    ELSE
        BEGIN
        mblock.mb_qual_len  := 0;
        mblock.mb_struct    := mbs_nil
        END
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00
THEN
    BEGIN
    WITH mess_trace.kbdtHead_gg11 DO
        BEGIN
        IF  (mblock.mb_type = m_return_result) AND (mblock.mb_trns^.trError_gg00 = e_ok)
        THEN
            kbMessType_gg11 := m_return_result
        ELSE
            kbMessType_gg11 := m_return_error;
        (*ENDIF*) 
        kbMessType2_gg11 := mm_nil;
        kbError_gg11     := mblock.mb_trns^.trError_gg00
        END;
    (*ENDWITH*) 
    a11put_date_time (mess_trace.kbdtDate_gg11, mess_trace.kbdtTime_gg11);
    b120InsertTrace (mblock.mb_trns^, kb, vttKbColdFunctions_egg00, sizeof (mess_trace), @mess_trace);
    END;
&ifdef TRACE
(*ENDIF*) 
t01messblock (kb_funct, 'RETURN MBUF ', mblock);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k05functions (VAR mblock : tgg00_MessBlock);
 
VAR
      BeginSubtransSet : boolean;
      StartMessType    : tgg00_MessType;
      StartMessType2   : tgg00_MessType2;
      keylen           : integer;
      len              : integer;
      start_time_sec   : tsp00_Int4;
      start_time_msec  : tsp00_Int4;
      stop_time_sec    : tsp00_Int4;
      stop_time_msec   : tsp00_Int4;
      diff_sec         : tsp00_Int4;
      diff_msec        : tsp00_Int4;
      currStack        : tsp00_Int4;
      maxStackUsed     : tsp00_Int4;
      mess_trace       : tgg11_KbTabKeyTrace;
      mess_time_trace  : tgg11_KbTimeTrace;
 
BEGIN
IF  gg01_kb_stack_measurement
THEN
    BEGIN
    vscheck (currStack);
    vsReinit(mblock.mb_trns^.trTaskId_gg00, 0);
    END;
(*ENDIF*) 
BeginSubtransSet := false;
WITH mblock.mb_trns^ DO
    BEGIN
    trError_gg00   := e_ok;
    trState_gg00   := trState_gg00 - [tsFunctRollbSet_egg00];
    trRteCommPtr_gg00^.virt_reads := -MAX_INT2_SP00;
    END;
(*ENDWITH*) 
StartMessType   := mblock.mb_type;
StartMessType2  := mblock.mb_type2;
start_time_sec  := 0;
start_time_msec := 0;
k51_kb_func_calls := k51_kb_func_calls + ONE_8BYTE_CNT_GG04; (* PTS 1103743 JA 1999-08-25 *)
IF  g01vtrace.vtrTime_gg00 OR a01diag_monitor_on OR a01diag_analyze_on
THEN
    BEGIN
    vclock (start_time_sec, start_time_msec);
    IF  a01diag_monitor_on OR a01diag_analyze_on
    THEN
        b21m_reset_monitor (mblock.mb_trns^.trBdTcachePtr_gg00,
              NOT c_reset_sum);
    (*ENDIF*) 
    END;
&ifdef TRACE
(*ENDIF*) 
t01name      (kb_funct, '==================');
t01messblock (kb_funct, 'MESSBUF ----', mblock);
IF  t01trace (ak_isolev)
THEN
    BEGIN
    IF  (mblock.mb_type in [m_delete, m_insert, m_insert_select,
        m_select, m_select_row, m_update])
        AND (mblock.mb_type2 <> mm_device)
        AND (mblock.mb_type2 <> mm_log   )
    THEN
        BEGIN
        IF  
            (NOT bd998IsTempFile (mblock.mb_trns^, mblock.mb_qual^.mtree))
            OR (bd998GetExtendedTempFileType (mblock.mb_trns^, mblock.mb_qual^.mtree)
            <> ttfnPars_egg00)
        THEN
            BEGIN
            t01name      (ak_isolev, '  KB05 k05function');
            t01messtype  (ak_isolev, 'mess_type   ', mblock.mb_type);
            t01mess2type (ak_isolev, 'mess2_type  ', mblock.mb_type2);
            t01handling  (ak_isolev, 'handling    ',
                  mblock.mb_qual^.mtree.fileHandling_gg00)
            END
        (*ENDIF*) 
        END
    (*ENDIF*) 
    END;
&endif
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00
THEN
    BEGIN
    WITH mess_trace.kbtkTabHead_gg11.kbtHead_gg11 DO
        BEGIN
        kbMessType_gg11  := mblock.mb_type;
        kbMessType2_gg11 := mblock.mb_type2;
        kbSubtrans_gg11  := mblock.mb_trns^.trSubtransId_gg00
        END;
    (*ENDWITH*) 
    len := sizeof (mess_trace.kbtkTabHead_gg11.kbtHead_gg11);
    IF  (mblock.mb_type in [m_delete, m_fetch, m_insert_select,
        m_select, m_select_row, m_update, m_update_rec])
        OR
        ((mblock.mb_type  =  m_insert ) AND
        ( mblock.mb_type2 <> mm_device) AND
        ( mblock.mb_type2 <> mm_log   ))
        OR
        ((mblock.mb_type  =  m_get   ) AND
        ( mblock.mb_type2 <> mm_pages) AND
        ( mblock.mb_type2 <> mm_read ))
    THEN
        (* write FileId into vtrace *)
        BEGIN
        mess_trace.kbtkTabHead_gg11.kbtTabId_gg11  := mblock.mb_qual^.mtree.fileTabId_gg00;
        mess_trace.kbtkTabHead_gg11.kbtKeyLen_gg11 := 0;
        len := sizeof (mess_trace.kbtkTabHead_gg11);
        IF  ((mblock.mb_type = m_update) AND
            (mblock.mb_type2 = mm_nil))
            OR
            ((mblock.mb_type = m_insert) AND (mblock.mb_type2 = mm_nil))
            OR
            ((mblock.mb_type = m_delete) AND (mblock.mb_type2 = mm_nil))
            OR
            ((mblock.mb_type = m_get) AND (mblock.mb_type2 <> mm_test))
            OR
            ((mblock.mb_type  = m_select_row) AND
            ( mblock.mb_type2 = mm_direct   ))
            OR
            (mblock.mb_type = m_update_rec)
        THEN
            (* write key into vtrace *)
            BEGIN
            keylen := mblock.mb_data^.mbp_keylen;
            mess_trace.kbtkTabHead_gg11.kbtKeyLen_gg11 := keylen;
            IF  len + keylen > sizeof (tgg11_VtraceBody)
            THEN
                keylen := sizeof (tgg11_VtraceBody) - len;
            (*ENDIF*) 
            SAPDB_PascalMove ('VKB05 ',   1,    
                  mblock.mb_data_size, sizeof (mess_trace.kbtkKey_gg11),
                  @mblock.mb_data^.mbp_key.k, 1,
                  @mess_trace.kbtkKey_gg11, 1, keylen, mblock.mb_trns^.trError_gg00);
            len := len + keylen
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  mblock.mb_trns^.trError_gg00 <> e_move_error
    THEN
        b120InsertTrace (mblock.mb_trns^, kb, vttKbFunctions_egg00, len, @mess_trace)
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  mblock.mb_trns^.trError_gg00 <> e_move_error
THEN
    CASE mblock.mb_type OF
        m_autosave (*
        =======    *):
            CASE mblock.mb_type2 OF
                mm_clear:
                    k38e_autosave_end (mblock.mb_trns^, c_quick);
                mm_last:
                    k38e_autosave_end (mblock.mb_trns^, NOT c_quick);
                mm_nil:
                    k38i_autosave_init (mblock);
                mm_outcopy:
                    k38sh_autosave_show (mblock);
                OTHERWISE
                    mblock.mb_trns^.trError_gg00 := e_not_implemented
                END;
            (*ENDCASE*) 
        m_begin (*
        ======= *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            CASE mblock.mb_type2 OF
                mm_string:
                    k43begin_load (mblock);
                mm_key, mm_nokey:
                    k64begin_load (mblock);
                OTHERWISE
                    mblock.mb_trns^.trError_gg00 := e_not_implemented
                END;
            (*ENDCASE*) 
            END;
        m_change (*
        ======== *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            CASE mblock.mb_type2 OF
                mm_key, mm_table :
                    k66modify_table (mblock);
                mm_file :
                    k64change_filetype (mblock);
                OTHERWISE
                    mblock.mb_trns^.trError_gg00 := e_not_implemented
                END;
            (*ENDCASE*) 
            END;
        m_column   (*
        ========   *):
            (* PTS 1120287 E.Z. *)
            CASE mblock.mb_type2 OF
                mm_new_read:
                    k45cnread_column  (mblock);
                mm_new_write:
                    BEGIN
                    BeginSubtransSet := true;
                    kb560BeginSubtransLogTransaction (mblock.mb_trns^);
                    k43cnwrite_column (mblock);
                    END;
                mm_write:
                    BEGIN
                    BeginSubtransSet := true;
                    kb560BeginSubtransLogTransaction (mblock.mb_trns^);
                    k43cwrite_column  (mblock);
                    END;
                OTHERWISE
                    mblock.mb_trns^.trError_gg00 := e_not_implemented
                END;
            (*ENDCASE*) 
        m_column_statistic  (*
        ==================  *):
            k71column_statistic (mblock);
        m_commit   (*
        ========   *):
            IF  mblock.mb_type2 = mm_keep_lock
            THEN
                mblock.mb_trns^.trError_gg00 := e_not_implemented
            ELSE
                k53end_of_trans (mblock);
            (*ENDIF*) 
        m_connect   (*
        =========   *):
            k53connect (mblock);
        m_create_index   (*
        ==============   *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            IF  mblock.mb_type2 <> mm_participant
            THEN
                k33create_index (mblock)
            ELSE
                mblock.mb_trns^.trError_gg00 := e_not_implemented;
            (*ENDIF*) 
            END;
        m_create_table (*
        ============== *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            IF  ftsTemp_egg00 in mblock.mb_qual^.mtree.fileType_gg00
            THEN
                k54create_drop_temp_file (mblock.mb_trns^,
                      mblock.mb_type, mblock.mb_qual^.mtree)
            ELSE
                k64table_create (mblock);
            (*ENDIF*) 
            END;
        m_down  (*
        ======  *):
            IF  mblock.mb_type2 = mm_user
            THEN
                k50not_connected (mblock)
            ELSE
                mblock.mb_trns^.trError_gg00 := e_not_implemented;
            (*ENDIF*) 
        m_delete, m_update   (*
        ==================   *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            IF  (mblock.mb_type2 = mm_qual ) OR
                (mblock.mb_type2 = mm_empty) OR
                (mblock.mb_type2 = mm_trunc)
            THEN
                BEGIN
                mblock.mb_trns^.trRteCommPtr_gg00^.file_record_cnt := 0;
                (* in file_record_cnt the deletes pages are counted *)
                k61del_upd_qual (mblock)
                END
            ELSE
                k61ins_del_upd (mblock);
            (*ENDIF*) 
            END;
        m_destroy_temp   (*
        ==============   *):
            k64temp_file_handling (mblock);
        m_diagnose   (*
        ==========   *):
            CASE mblock.mb_type2 OF
                mm_dump:
                    gg999WriteUserForcedDump (mblock.mb_trns^.trTaskId_gg00,
                          mblock.mb_qual^.mut_hostfn, mblock.mb_qual^.mut_dump_state );
                mm_index:
                    k33diagnose_index (mblock);
                OTHERWISE
                    mblock.mb_trns^.trError_gg00 := e_not_implemented
                END;
            (*ENDCASE*) 
        m_drop (*
        ====== *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            IF  (mblock.mb_type2 = mm_table) AND
                bd998IsTempFile (mblock.mb_trns^, mblock.mb_qual^.mtree)
            THEN
                k54create_drop_temp_file (mblock.mb_trns^,
                      mblock.mb_type, mblock.mb_qual^.mtree)
            ELSE
                k64cmd_drop (mblock);
            (*ENDIF*) 
            END;
        m_eval   (*
        ======   *):
            CASE mblock.mb_type2 OF
                mm_pages, mm_key, mm_table:
                    k721eval_pagecount (mblock);
                OTHERWISE
                    mblock.mb_trns^.trError_gg00 := e_not_implemented
                END;
            (*ENDCASE*) 
        m_fetch   (*
        =======   *):
            k75_fetch (mblock);
        m_flush   (*
        =======   *):
            WITH mblock DO
                BEGIN
                mb_struct       := mbs_result;
                mb_type         := m_return_result;
                mb_type2        := mm_nil;
                mb_qual_len     := 0;
                mb_data_len     := 0;
                mb_trns^.trError_gg00 := e_ok
                END;
            (*ENDWITH*) 
        m_get   (*
        =====   *):
            WITH mblock DO
                CASE mb_type2 OF
                    mm_read, mm_pages:
                        mblock.mb_trns^.trError_gg00 := e_not_implemented;
                    OTHERWISE:
                        BEGIN
                        k71get (mblock);
                        IF  mb_trns^.trError_gg00 <> e_ok
                        THEN
                            BEGIN
                            mb_struct    := mbs_nil;
                            mb_type      := m_return_error;
                            mb_type2     := mm_nil;
                            mb_qual_len  := 0;
                            mb_data_len  := 0
                            END
                        (*ENDIF*) 
                        END;
                    END;
                (*ENDCASE*) 
            (*ENDWITH*) 
        m_index_statistic, m_table_statistic   (*
        ====================================   *):
            k71file_statistic (mblock);
        m_insert   (*
        ========   *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            k61ins_del_upd (mblock);
            END;
        m_insert_select   (*
        ===============   *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            k61table_ins_del_upd (mblock);
            END;
        m_key   (*
        ======  *):
            k721read_subquery (mblock);
        m_lock   (*
        ======   *):
            k53lock_command (mblock);
        m_mend   (*
        ======   *):
            k64end_load (mblock);
        m_move   (*
        =======   *):
            k64temp_file_handling (mblock);
        m_nextval   (*
        =======   *):
            k57sequence_no (mblock);
        (* PTS 1107952 E.Z. *)
        m_release   (*
        =========   *):
            k53release (mblock.mb_trns^, mblock.mb_type2 = mm_ignore, NOT c_internal_session);
        m_reload, m_unload   (*
        ==================   *):
            BEGIN
            mblock.mb_trns^.trError_gg00 := e_not_implemented;
            END;
        (* PTS 1115982 E.Z. *)
        m_rollback   (*
        ==========   *):
            CASE mblock.mb_type2 OF
                mm_keep_lock,
                mm_subtrans:
                    mblock.mb_trns^.trError_gg00 := e_not_implemented;
                OTHERWISE
                    k53end_of_trans (mblock)
                END;
            (*ENDCASE*) 
        m_select   (*
        ========   *):
            IF  (mblock.mb_type2 = mm_with_join) OR
                (mblock.mb_type2 = mm_join_with_last_tab)
            THEN
                k74_join_select (mblock)
            ELSE
                k720_single_select (mblock);
            (*ENDIF*) 
        m_select_row   (*
        ============   *):
            BEGIN
            k71select (mblock);
            IF  mblock.mb_trns^.trError_gg00 <> e_ok
            THEN
                WITH mblock DO
                    BEGIN
                    mb_struct    := mbs_nil;
                    mb_type      := m_return_error;
                    mb_type2     := mm_nil;
                    mb_qual_len  := 0;
                    mb_data_len  := 0
                    END
                (*ENDWITH*) 
            (*ENDIF*) 
            END;
        m_set   (*
        =====   *):
            CASE mblock.mb_type2 OF
                mm_end_read_only:
                    BEGIN
                    kb560StartSavepoint (mblock.mb_trns^, mm_end_read_only);
                    IF  mblock.mb_trns^.trError_gg00 = e_ok
                    THEN
                        b01end_read_only (mblock.mb_trns^)
                    (*ENDIF*) 
                    END;
                mm_pages:
                    BEGIN
                    BeginSubtransSet := true;
                    kb560BeginSubtransLogTransaction (mblock.mb_trns^);
                    k64set_treeleafnodes (mblock.mb_trns^,
                          mblock.mb_qual^.mtree);
                    END;
                OTHERWISE
                    mblock.mb_trns^.trError_gg00 := e_not_implemented
                END;
            (*ENDCASE*) 
        m_show   (*
        ======   *):
            k52show_lock (mblock);
        m_stamp   (*
        =======   *):
            BEGIN
            k57stamp_logged (mblock.mb_trns^.trState_gg00,
                  mblock.mb_trns^.trTaskId_gg00,
                  mblock.mb_type2,
                  @mblock.mb_data^.mbp_buf, mblock.mb_data_size,
                  mblock.mb_trns^.trError_gg00);
            mblock.mb_qual_len := 0;
            mblock.mb_data_len := SURROGATE_MXGG00;
            mblock.mb_type     := m_return_result;
            mblock.mb_type2    := mm_nil;
            mblock.mb_struct   := mbs_buf
            END;
        m_succ_file_version   (*
        ===================   *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            k64set_file_version (mblock);
            END;
        m_union   (*
        =======   *):
            k722_union_select (mblock);
        m_unlock   (*
        ========   *):
            IF  mblock.mb_type2 = mm_table
            THEN
                (* PTS 1103526 JA 1999-09-03 *)
                WITH mblock.mb_trns^ DO
                    k51sys_share_remove (trTaskId_gg00, trIndex_gg00, trState_gg00)
                (*ENDWITH*) 
            ELSE
                k53unlock (mblock);
            (*ENDIF*) 
        m_update_rec   (*
        ============   *):
            BEGIN
            BeginSubtransSet := true;
            kb560BeginSubtransLogTransaction (mblock.mb_trns^);
            k61ins_del_upd (mblock);
            END;
        m_verify       (*
        ============   *):
            CASE mblock.mb_type2 OF
                (* PTS 1108979 E.Z. *)
                mm_table :
                    kb05_CheckTable (mblock, NOT c_with_lock);
                mm_lock :
                    kb05_CheckTable (mblock,     c_with_lock);
                mm_participant :
                    mblock.mb_trns^.trError_gg00 := e_not_implemented;
                OTHERWISE
                    kb05_CheckData (mblock)
                END;
            (*ENDCASE*) 
        OTHERWISE
            mblock.mb_trns^.trError_gg00 := e_not_implemented
        END;
    (*ENDCASE*) 
(*ENDIF*) 
IF  mblock.mb_trns^.trError_gg00 <> e_ok
THEN
    kb05ReturnErrorHandling (mblock.mb_trns^, BeginSubtransSet, StartMessType)
ELSE
    IF  BeginSubtransSet
    THEN
        kb560EndSubtransLogTransaction (mblock.mb_trns^);
    (*ENDIF*) 
(*ENDIF*) 
IF  ((mblock.mb_type <> m_return_result) OR
    ( mblock.mb_trns^.trError_gg00 <> e_ok  ))
    AND
    (mblock.mb_trns^.trError_gg00 <> e_wait_for_lock_release)
    AND
    (StartMessType <> m_save_parallel   )
    AND
    (StartMessType <> m_restore_parallel)
THEN
    BEGIN
    mblock.mb_struct := mbs_nil;
    mblock.mb_type   := m_return_error;
    mblock.mb_type2  := mm_nil;
    IF  (StartMessType <> m_verify) AND
        (
        ((mblock.mb_trns^.trError_gg00 <> e_no_next_record) AND
        ( mblock.mb_trns^.trError_gg00 <> e_key_not_found))
        OR
        (mblock.mb_qual_len  <> MB_PART1_HEAD_MXGG00 +
        cgg04_return_stack_entries * STACK_ENTRY_MXGG00)
        )
    THEN
        mblock.mb_qual_len := 0;
    (*ENDIF*) 
    IF  (StartMessType <> m_fetch) OR
        (mblock.mb_trns^.trError_gg00 <> e_no_next_record)
    THEN
        mblock.mb_data_len := 0
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  g01vtrace.vtrAll_gg00
THEN
    BEGIN
    IF  g01vtrace.vtrTime_gg00
    THEN
        BEGIN
        vclock (stop_time_sec, stop_time_msec);
        diff_sec  := stop_time_sec - start_time_sec;
        diff_msec := stop_time_msec - start_time_msec;
        IF  stop_time_msec < start_time_msec
        THEN
            BEGIN
            diff_sec  := diff_sec  - 1;
            diff_msec := diff_msec + 1000000 ;
            END
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    WITH mess_time_trace.kbtmHead_gg11 DO
        BEGIN
        IF  (mblock.mb_type = m_return_result) AND (mblock.mb_trns^.trError_gg00 = e_ok)
        THEN
            kbMessType_gg11 := m_return_result
        ELSE
            kbMessType_gg11 := m_return_error;
        (*ENDIF*) 
        kbMessType2_gg11 := mm_nil;
        kbError_gg11     := mblock.mb_trns^.trError_gg00
        END;
    (*ENDWITH*) 
    IF  g01vtrace.vtrTime_gg00
    THEN
        BEGIN
        mess_time_trace.kbtmHead_gg11.kbMessType2_gg11 := mm_test;
        mess_time_trace.kbtmSec_gg11  := diff_sec;
        mess_time_trace.kbtmMsec_gg11 := diff_msec;
        len := sizeof (mess_time_trace)
        END
    ELSE
        len := sizeof (mess_time_trace.kbtmHead_gg11);
    (*ENDIF*) 
    b120InsertTrace (mblock.mb_trns^, kb, vttKbFunctions_egg00, len, @mess_time_trace);
    END;
(*ENDIF*) 
IF  gg01_kb_stack_measurement
THEN
    BEGIN
    vsscan (maxStackUsed);
    maxStackUsed := maxStackUsed - currStack;
    IF  maxStackUsed > kb05MaxStackUsed
    THEN
        kb05MaxStackUsed := maxStackUsed;
    (*ENDIF*) 
    END;
(*ENDIF*) 
;
&ifdef TRACE
t01messblock (kb_funct, 'RETURN MBUF ', mblock);
&endif
END;
 
(*------------------------------*) 
 
PROCEDURE
      k05init;
 
BEGIN
kb05MaxStackUsed := 0;
kb03CheckInit;        (* PTS 1103957 JA 1999-09-15 *)
k38set_not_generated;
k51set_not_generated;
k57set_not_generated
END;
 
(*------------------------------*) 
 
FUNCTION
      k05is_fatal_error (e : tgg00_BasisError): boolean;
 
BEGIN
CASE e OF
    e_bad_fdir,
    e_bad_logpage,
    e_disk_not_accessible,
    e_illegal_branchlength,
    e_illegal_entrylength,
    e_illegal_entrypos,
    e_illegal_keylength,
    e_illegal_page_no,
    e_invalid_entrypos,
    e_invalid_index_structure,
    e_invalid_leaves_structure,
    e_no_converter_entry,
    e_page_in_wrong_tree,
    e_log_error,
    e_undo_log_write_error, (* UH 2004-09-27 begin *)
    e_undo_log_execute_error,
    e_redo_log_execute_error,
    e_history_write_error,
    e_history_read_error,
    e_history_remove_error,
    e_redo_log_read_error,
    e_redo_log_write_error, (* UH 2004-09-27 end *)
    e_sysbuffer_overflow,
    e_corrupted_datapage_from_io:
        k05is_fatal_error := true;
    OTHERWISE
        k05is_fatal_error := false
    END
(*ENDCASE*) 
END;
 
(* PTS 1117472 E.Z. *)
(*------------------------------*) 
 
PROCEDURE
      k05GetBadLogVolume (VAR mblock : tgg00_MessBlock);
 
VAR
      DevName       : tsp00_VFilename;
 
BEGIN
gg999GetBadLogVolume(mblock.mb_trns^, DevName);
IF  mblock.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    mblock.mb_data^.mbp_buf[1] := csp_ascii_blank;
    SAPDB_PascalMove ('VKB05 ',   2,    
          sizeof(DevName), mblock.mb_data_size,
          @DevName, 1, @mblock.mb_data^.mbp_buf, 2,
          sizeof(DevName), mblock.mb_trns^.trError_gg00);
    mblock.mb_data_len := 1 + sizeof(DevName);
    mblock.mb_type := m_return_result;
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
FUNCTION
      k05MaxStackUsage : tsp00_Int4;
 
BEGIN
k05MaxStackUsage := kb05MaxStackUsed;
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb05ReturnErrorHandling (
            VAR Trans        : tgg00_TransContext;
            BeginSubtransSet : boolean;
            StartMessType    : tgg00_MessType);
      (******** hkb05.h ********)
 
VAR
      AuxError    : tgg00_BasisError;
      msgLen      : integer;
      errLen      : integer;
      typeLen     : integer;
      errCodeTxt  : tsp00_C40;
      messTypeTxt : tsp00_C40;
      msgTxt      : tsp00_C40;
 
BEGIN
IF  Trans.trError_gg00 <> e_ok
THEN
    BEGIN
    IF  Trans.trError_gg00 = e_cancelled
    THEN
        BEGIN
        k51examine_trans (Trans);
        IF  Trans.trError_gg00 = e_ok
        THEN
            Trans.trError_gg00 := e_cancelled
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    IF  k05is_fatal_error (Trans.trError_gg00)
    THEN
        BEGIN
        IF  NOT (
            (StartMessType = m_verify)
            AND
            ((Trans.trError_gg00 = e_invalid_leaves_structure) OR
            ( Trans.trError_gg00 = e_invalid_index_structure ) OR
            ( Trans.trError_gg00 = e_page_in_wrong_tree      ) OR
            ( Trans.trError_gg00 = e_no_converter_entry      ) OR (* PTS 1106076 TS 2000-04-25 *)
            ( Trans.trError_gg00 = e_bad_datapage            ) OR
            ( Trans.trError_gg00 = e_illegal_entrypos        ) OR (* PTS 1105530 TS 2000-02-08 *)
            ( Trans.trError_gg00 = e_illegal_entrylength     ) OR (* PTS 1122016 TS 2003-05-09 *)
            ( Trans.trError_gg00 = e_illegal_page_no         ) OR (* PTS 1125096 TS 2003-11-21 *)
            ( Trans.trError_gg00 = e_illegal_keylength      ))
            )
        THEN
            BEGIN
            msgTxt      := bsp_c40;
            messTypeTxt := bsp_c40;
            errCodeTxt  := bsp_c40;
            msgLen      := 0;
            typeLen     := 0;
            errLen      := 0;
            (* *)
            g17messtype_to_line  (StartMessType, typeLen, messTypeTxt);
            g17basis_err_to_line (Trans.trError_gg00, errLen,  errCodeTxt );
            (* *)
            IF  typeLen + errLen + 1 <= sizeof (tsp00_C40)
            THEN
                BEGIN
                AuxError := e_ok;
                SAPDB_PascalMove ('VKB05 ',   3,    
                      sizeof (messTypeTxt), sizeof (msgTxt),
                      @messTypeTxt, 1, @msgTxt, msgLen + 1, typeLen, AuxError);
                msgLen := msgLen + typeLen;
                msgTxt [msgLen + 1] := '/';
                SAPDB_PascalMove ('VKB05 ',   4,    
                      sizeof (errCodeTxt), sizeof (msgTxt),
                      @errCodeTxt, 1, @msgTxt, msgLen + 2, errLen, AuxError)
                END;
            (*ENDIF*) 
            g01optextmsg (sp3p_syscon, sp3m_error,  kbMsg_csp03, csp3_n_shutdown, msgTxt);
            g01abort (kbMsg_csp03, csp3_n_shutdown,'*** EMERGENCY ***       ', ord(Trans.trError_gg00));
            END
        (*ENDIF*) 
        END
    ELSE
        IF  (Trans.trError_gg00 <> e_new_hostfile_required) AND
            (Trans.trError_gg00 <> e_rollback_wanted      ) AND
            (Trans.trError_gg00 <> e_shutdown             ) AND
            (* PTS 1114833 UJ *)
            (Trans.trError_gg00 <> e_work_rolled_back     ) AND
            (Trans.trError_gg00 <> e_wait_for_lock_release) AND
            (StartMessType      <> m_restart              ) AND
            (StartMessType      <> m_save_parallel        )
        THEN
            BEGIN
            AuxError           := Trans.trError_gg00;
            Trans.trError_gg00 := e_ok;
            k51examine_trans (Trans);
            IF  BeginSubtransSet
            THEN
                kb560RollbackLogTransAction (Trans, mm_nil, Trans.trSubtransId_gg00);
            (*ENDIF*) 
            IF  Trans.trError_gg00 = e_ok
            THEN
                Trans.trError_gg00 := AuxError
            (*ENDIF*) 
            END
        ELSE
            IF  BeginSubtransSet
            THEN
                kb560EndSubtransLogTransaction (Trans);
            (*ENDIF*) 
        (*ENDIF*) 
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb05_CheckTable (
            VAR m     : tgg00_MessBlock;
            with_lock : boolean);
 
VAR
      bUpdateLeaves : boolean;
      bQuiet        : boolean;
      k             : tgg00_Lkey;
      aux_error     : tgg00_BasisError;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
IF  with_lock
THEN
    BEGIN
    k53perm_temp_lock (m.mb_trns^, m_lock, lckTabShare_egg00,
          [hsTempLock_egg00], m.mb_qual^.mv_tree.fileTabId_gg00, k);
    IF  m.mb_trns^.trError_gg00 = e_wait_for_lock_release
    THEN
        k53wait (m.mb_trns^, m.mb_type, m.mb_type2);
    (*ENDIF*) 
    END;
(*ENDIF*) 
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    bUpdateLeaves := false; (* TODO *)
    bQuiet        := bUpdateLeaves;
    b01check_table (m.mb_trns^, m.mb_qual^.mv_tree,
          m.mb_qual^.mv_longcnt, m.mb_qual^.mv_newlongcnt,
          m.mb_qual^.mv_extended, with_lock, bQuiet, bUpdateLeaves );
    IF  with_lock
    THEN
        BEGIN
        aux_error := m.mb_trns^.trError_gg00;
        k53perm_temp_lock (m.mb_trns^, m_unlock, lckTabShare_egg00,
              [hsTempLock_egg00], m.mb_qual^.mv_tree.fileTabId_gg00, k);
        IF  aux_error <> e_ok
        THEN
            m.mb_trns^.trError_gg00 := aux_error
        (*ENDIF*) 
        END;
    (*ENDIF*) 
    END;
(*ENDIF*) 
m.mb_qual_len := 0;
m.mb_data_len := 0;
m.mb_struct   := mbs_nil;
m.mb_type2    := mm_nil;
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    m.mb_type := m_return_result
ELSE
    m.mb_type := m_return_error
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb05_CheckData (VAR m : tgg00_MessBlock);
 
VAR
      pos           : integer;
      badIndexCount : tsp00_Int4;
      totalBadCount : tsp00_Int4;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
IF  m.mb_qual^.mv_delete_longfile (* PTS 1133300 UH 2005-01-11 *)
THEN
    m.mb_qual^.mv_extended := true;
(*ENDIF*) 
gg999CheckData (m.mb_trns^, m.mb_qual^.mv_extended,
      (m.mb_type2 <> mm_index),  m.mb_qual^.mv_delete_longfile, (* PTS 1133300 UH 2005-01-11 *)
      badIndexCount, totalBadCount);
IF  m.mb_trns^.trError_gg00 <> e_ok
THEN
    BEGIN
    IF  (m.mb_trns^.trError_gg00 = e_dbm_command_not_possible) OR
        (m.mb_trns^.trError_gg00 = e_cancelled               )
    THEN
        m.mb_qual_len := 0
    ELSE
        BEGIN
        m.mb_type   := m_return_result;
        m.mb_struct := mbs_buf;
        pos         := 1;
        kb05_Int4ToBuf (badIndexCount, 10, pos, m.mb_qual^.buf, m.mb_trns^.trError_gg00);
        kb05_Int4ToBuf (totalBadCount, 10, pos, m.mb_qual^.buf, m.mb_trns^.trError_gg00);
        m.mb_qual_len  := pos - 1
        END
    (*ENDIF*) 
    END
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb05_CheckDataWithUpdate (VAR m : tgg00_MessBlock);
 
VAR
      pos            : integer;
      badIndexCount  : tsp00_Int4;
      totalBadCount  : tsp00_Int4;
      pagesUsed      : tsp00_Int4;
      blocksReleased : tsp00_Int4;
 
BEGIN
m.mb_trns^.trError_gg00 := e_ok;
gg999CheckDataWithUpdate (m.mb_trns^, m.mb_qual^.mv_extended,
      pagesUsed, blocksReleased, badIndexCount, totalBadCount);
IF  m.mb_trns^.trError_gg00 = e_ok
THEN
    BEGIN
    m.mb_type   := m_return_result;
    m.mb_struct := mbs_buf;
    pos         := 1;
    kb05_Int4ToBuf (pagesUsed, 10, pos, m.mb_qual^.buf, m.mb_trns^.trError_gg00);
    kb05_Int4ToBuf (blocksReleased, 10, pos, m.mb_qual^.buf, m.mb_trns^.trError_gg00);
    m.mb_qual_len  := pos - 1
    END
ELSE
    IF  (m.mb_trns^.trError_gg00 = e_dbm_command_not_possible) OR
        (m.mb_trns^.trError_gg00 = e_cancelled               )
    THEN
        m.mb_qual_len := 0
    ELSE
        BEGIN
        m.mb_type   := m_return_result;
        m.mb_struct := mbs_buf;
        pos         := 1;
        kb05_Int4ToBuf (badIndexCount, 10, pos, m.mb_qual^.buf, m.mb_trns^.trError_gg00);
        kb05_Int4ToBuf (totalBadCount, 10, pos, m.mb_qual^.buf, m.mb_trns^.trError_gg00);
        m.mb_qual_len  := pos - 1
        END
    (*ENDIF*) 
(*ENDIF*) 
END;
 
(*------------------------------*) 
 
PROCEDURE
      kb05_Int4ToBuf (
            int            : tsp00_Int4;
            length         : integer;
            VAR pos        : integer;
            VAR buf        : tsp00_Buf;
            VAR move_err   : tgg00_BasisError);
 
CONST
      WITH_ZERO = true;
 
VAR
      ln : tsp00_Line;
 
BEGIN
g17int4to_line (int, WITH_ZERO, length, 1, ln);
SAPDB_PascalMove ('VKB05 ',   5,    
      sizeof (ln), sizeof (buf), @ln, 1, @buf, pos, length, move_err);
pos := pos + length
END;
 
.CM *-END-* code ----------------------------------------
.SP 2 
***********************************************************
.PA 
